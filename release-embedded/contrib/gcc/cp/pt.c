begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle parameterized types (templates) for GNU C++.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.    Rewritten by Jason Merrill (jason@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Known bugs or deficiencies include:       all methods must be provided in header files; can't use a source      file that contains only the method templates and "just win".  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-objcp-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"decl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_comment
comment|/* The type of functions taking a tree, and some additional data, and    returning an int.  */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|tree_fn_t
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* The PENDING_TEMPLATES is a TREE_LIST of templates whose    instantiations have been deferred, either because their definitions    were not yet available, or because we were putting off doing the work.    The TREE_PURPOSE of each entry is either a DECL (for a function or    static data member), or a TYPE (for a class) indicating what we are    hoping to instantiate.  The TREE_VALUE is not used.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|pending_templates
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|last_pending_template
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|processing_template_parmlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|template_header_count
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|saved_trees
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|inline_parm_levels
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|current_tinst_level
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|saved_access_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Live only within one (recursive) call to tsubst_expr.  We use    this to pass the statement expression node from the STMT_EXPR    to the EXPR_STMT that is its result.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|cur_stmt_expr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A map from local variable declarations in the body of the template    presently being instantiated to the corresponding instantiated    local variables.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|local_specializations
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNIFY_ALLOW_NONE
value|0
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_MORE_CV_QUAL
value|1
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_LESS_CV_QUAL
value|2
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_DERIVED
value|4
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_INTEGER
value|8
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_OUTER_LEVEL
value|16
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
value|32
end_define

begin_define
define|#
directive|define
name|UNIFY_ALLOW_OUTER_LESS_CV_QUAL
value|64
end_define

begin_function_decl
specifier|static
name|void
name|push_access_scope
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_access_scope
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|resolve_overloaded_unification
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|unification_kind_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_one_overload
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|unification_kind_t
parameter_list|,
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unify
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pending_template
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|push_tinst_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_tinst_level
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reopen_tinst_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|classtype_mangled_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_initializer_list
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_class_bindings
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|coerce_template_parms
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tsubst_enum
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|add_to_template_args
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|add_outermost_template_args
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_instantiated_args
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|maybe_adjust_types_for_deduction
parameter_list|(
name|unification_kind_t
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_unification_real
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|unification_kind_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_template_header
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_nontype_argument_function
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_nontype_argument
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|convert_template_argument
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|for_each_template_parm
parameter_list|(
name|tree
parameter_list|,
name|tree_fn_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|pointer_set_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|build_template_parm_index
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inline_needs_template_parms
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_inline_template_parms_recursive
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|retrieve_local_specialization
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|register_local_specialization
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|reduce_template_parm_level
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mark_template_parm
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|template_parm_this_level_p
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_friend_function
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_friend_class
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_complete_type_without_circularity
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_bindings
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|template_decl_level
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_cv_quals_for_unify
parameter_list|(
name|int
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_template_arg
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_template_args
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_template_parms
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|regenerate_decl_from_template
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|most_specialized_class
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_aggr_type
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_arg_types
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_function_type
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_specialization_scope
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|process_partial_specialization
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_current_access_from_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_default_tmpl_args
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_template_base
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|try_class_unification
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|coerce_template_template_parms
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|template_args_equal
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tsubst_default_arguments
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|for_each_template_parm_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|copy_default_args_to_explicit_spec_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_default_args_to_explicit_spec
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|invalid_nontype_parm_type_p
parameter_list|(
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eq_local_specializations
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|dependent_type_p_r
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_expr
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|tsubst_copy
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tsubst_flags_t
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Make the current scope suitable for access checking when we are    processing T.  T can be FUNCTION_DECL for instantiated function    template, or VAR_DECL for static member variable (need by    instantiate_decl).  */
end_comment

begin_function
specifier|static
name|void
name|push_access_scope
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|push_to_top_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|saved_access_scope
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|current_function_decl
argument_list|,
name|saved_access_scope
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore the scope set up by push_access_scope.  T is the node we    are processing.  */
end_comment

begin_function
specifier|static
name|void
name|pop_access_scope
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|current_function_decl
operator|=
name|TREE_VALUE
argument_list|(
name|saved_access_scope
argument_list|)
expr_stmt|;
name|saved_access_scope
operator|=
name|TREE_CHAIN
argument_list|(
name|saved_access_scope
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|pop_nested_class
argument_list|()
expr_stmt|;
else|else
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do any processing required when DECL (a member template    declaration) is finished.  Returns the TEMPLATE_DECL corresponding    to DECL, unless it is a specialization, in which case the DECL    itself is returned.  */
end_comment

begin_function
name|tree
name|finish_member_template_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|check_member_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|tmpl
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|error
argument_list|(
literal|"data member %qD cannot be a member template"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|check_member_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
return|;
block|}
else|else
return|return
name|decl
return|;
block|}
else|else
name|error
argument_list|(
literal|"invalid member template declaration %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Returns the template nesting level of the indicated class TYPE.     For example, in:      template<class T>      struct A      {        template<class U>        struct B {};      };     A<T>::B<U> has depth two, while A<T> has depth one.    Both A<T>::B<int> and A<int>::B<U> have depth one, if    they are instantiations, not specializations.     This function is guaranteed to return 0 if passed NULL_TREE so    that, for example, `template_class_depth (current_class_type)' is    always safe.  */
end_comment

begin_function
name|int
name|template_class_depth
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|;
name|type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|?
name|CP_DECL_CONTEXT
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
operator|++
name|depth
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
operator|++
name|depth
expr_stmt|;
block|}
block|}
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if processing DECL as part of do_pending_inlines    needs us to push template parms.  */
end_comment

begin_function
specifier|static
name|int
name|inline_needs_template_parms
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|most_general_template
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|>
operator|(
name|processing_template_decl
operator|+
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of maybe_begin_member_template_processing.    Push the template parms in PARMS, starting from LEVELS steps into the    chain, and ending at the beginning, since template parms are listed    innermost first.  */
end_comment

begin_function
specifier|static
name|void
name|push_inline_template_parms_recursive
parameter_list|(
name|tree
name|parmlist
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
name|tree
name|parms
init|=
name|TREE_VALUE
argument_list|(
name|parmlist
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|levels
operator|>
literal|1
condition|)
name|push_inline_template_parms_recursive
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parmlist
argument_list|)
argument_list|,
name|levels
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|size_int
argument_list|(
name|processing_template_decl
argument_list|)
argument_list|,
name|parms
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
operator|=
literal|1
expr_stmt|;
name|begin_scope
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|?
name|sk_template_parms
else|:
name|sk_template_spec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parm
operator|==
name|error_mark_node
condition|)
continue|continue;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
block|{
comment|/* Make a CONST_DECL as is done in process_template_parm. 	       It is ugly that we recreate this here; the original 	       version built in process_template_parm is no longer 	       available.  */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Restore the template parameter context for a member template or    a friend template defined in a class definition.  */
end_comment

begin_function
name|void
name|maybe_begin_member_template_processing
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|levels
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inline_needs_template_parms
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|most_general_template
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|levels
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|-
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
operator|--
name|levels
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|push_inline_template_parms_recursive
argument_list|(
name|parms
argument_list|,
name|levels
argument_list|)
expr_stmt|;
block|}
comment|/* Remember how many levels of template parameters we pushed so that      we can pop them later.  */
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|inline_parm_levels
argument_list|,
name|levels
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Undo the effects of maybe_begin_member_template_processing.  */
end_comment

begin_function
name|void
name|maybe_end_member_template_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|last
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|int
argument_list|,
name|inline_parm_levels
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|last
operator|=
name|VEC_pop
argument_list|(
name|int
argument_list|,
name|inline_parm_levels
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
block|{
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a new template argument vector which contains all of ARGS,    but has as its innermost set of arguments the EXTRA_ARGS.  */
end_comment

begin_function
specifier|static
name|tree
name|add_to_template_args
parameter_list|(
name|tree
name|args
parameter_list|,
name|tree
name|extra_args
parameter_list|)
block|{
name|tree
name|new_args
decl_stmt|;
name|int
name|extra_depth
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|extra_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|make_tree_vec
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|+
name|extra_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|extra_depth
condition|;
operator|++
name|j
operator|,
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|extra_args
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* Like add_to_template_args, but only the outermost ARGS are added to    the EXTRA_ARGS.  In particular, all but TMPL_ARGS_DEPTH    (EXTRA_ARGS) levels are added.  This function is used to combine    the template arguments from a partial instantiation with the    template arguments used to attain the full instantiation from the    partial instantiation.  */
end_comment

begin_function
specifier|static
name|tree
name|add_outermost_template_args
parameter_list|(
name|tree
name|args
parameter_list|,
name|tree
name|extra_args
parameter_list|)
block|{
name|tree
name|new_args
decl_stmt|;
comment|/* If there are more levels of EXTRA_ARGS than there are ARGS,      something very fishy is going on.  */
name|gcc_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|>=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If *all* the new arguments will be the EXTRA_ARGS, just return      them.  */
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
condition|)
return|return
name|extra_args
return|;
comment|/* For the moment, we make ARGS look like it contains fewer levels.  */
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|-=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|add_to_template_args
argument_list|(
name|args
argument_list|,
name|extra_args
argument_list|)
expr_stmt|;
comment|/* Now, we restore ARGS to its full dimensions.  */
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|+=
name|TMPL_ARGS_DEPTH
argument_list|(
name|extra_args
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* Return the N levels of innermost template arguments from the ARGS.  */
end_comment

begin_function
name|tree
name|get_innermost_template_args
parameter_list|(
name|tree
name|args
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|tree
name|new_args
decl_stmt|;
name|int
name|extra_levels
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* If N is 1, just return the innermost set of template arguments.  */
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
return|;
comment|/* If we're not removing anything, just return the arguments we were      given.  */
name|extra_levels
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|-
name|n
expr_stmt|;
name|gcc_assert
argument_list|(
name|extra_levels
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_levels
operator|==
literal|0
condition|)
return|return
name|args
return|;
comment|/* Make a new set of arguments, not containing the outer arguments.  */
name|new_args
operator|=
name|make_tree_vec
argument_list|(
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|new_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
operator|+
name|extra_levels
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new_args
return|;
block|}
end_function

begin_comment
comment|/* We've got a template header coming up; push to a new level for storing    the parms.  */
end_comment

begin_function
name|void
name|begin_template_parm_list
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We use a non-tag-transparent scope here, which causes pushtag to      put tags in this scope, rather than in the enclosing class or      namespace scope.  This is the right thing, since we want      TEMPLATE_DECLS, and not TYPE_DECLS for template classes.  For a      global template class, push_template_decl handles putting the      TEMPLATE_DECL into top-level scope.  For a nested template class,      e.g.:         template<class T> struct S1 { 	 template<class T> struct S2 {};        };       pushtag contains special code to call pushdecl_with_scope on the      TEMPLATE_DECL for S2.  */
name|begin_scope
argument_list|(
name|sk_template_parms
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
operator|++
name|processing_template_parmlist
expr_stmt|;
name|note_template_header
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine is called when a specialization is declared.  If it is    invalid to declare a specialization here, an error is reported and    false is returned, otherwise this routine will return true.  */
end_comment

begin_function
specifier|static
name|bool
name|check_specialization_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|scope
init|=
name|current_scope
argument_list|()
decl_stmt|;
comment|/* [temp.expl.spec]       An explicit specialization shall be declared in the namespace of      which the template is a member, or, for member templates, in the      namespace of which the enclosing class or enclosing class      template is a member.  An explicit specialization of a member      function, member class or static data member of a class template      shall be declared in the namespace of which the class template      is a member.  */
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"explicit specialization in non-namespace scope %qD"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* [temp.expl.spec]       In an explicit specialization declaration for a member of a class      template or a member template that appears in namespace scope,      the member template and some of its enclosing class templates may      remain unspecialized, except that the declaration shall not      explicitly specialize a class member template if its enclosing      class templates are not explicitly specialized as well.  */
if|if
condition|(
name|current_template_parms
condition|)
block|{
name|error
argument_list|(
literal|"enclosing class templates are not explicitly specialized"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We've just seen template<>.  */
end_comment

begin_function
name|bool
name|begin_specialization
parameter_list|(
name|void
parameter_list|)
block|{
name|begin_scope
argument_list|(
name|sk_template_spec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|note_template_header
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|check_specialization_scope
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Called at then end of processing a declaration preceded by    template<>.  */
end_comment

begin_function
name|void
name|end_specialization
parameter_list|(
name|void
parameter_list|)
block|{
name|finish_scope
argument_list|()
expr_stmt|;
name|reset_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Any template<>'s that we have seen thus far are not referring to a    function specialization.  */
end_comment

begin_function
name|void
name|reset_specialization
parameter_list|(
name|void
parameter_list|)
block|{
name|processing_specialization
operator|=
literal|0
expr_stmt|;
name|template_header_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just seen a template header.  If SPECIALIZATION is nonzero,    it was of the form template<>.  */
end_comment

begin_function
specifier|static
name|void
name|note_template_header
parameter_list|(
name|int
name|specialization
parameter_list|)
block|{
name|processing_specialization
operator|=
name|specialization
expr_stmt|;
name|template_header_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're beginning an explicit instantiation.  */
end_comment

begin_function
name|void
name|begin_explicit_instantiation
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|processing_explicit_instantiation
argument_list|)
expr_stmt|;
name|processing_explicit_instantiation
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_explicit_instantiation
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|processing_explicit_instantiation
argument_list|)
expr_stmt|;
name|processing_explicit_instantiation
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An explicit specialization or partial specialization TMPL is being    declared.  Check that the namespace in which the specialization is    occurring is permissible.  Returns false iff it is invalid to    specialize TMPL in the current namespace.  */
end_comment

begin_function
specifier|static
name|bool
name|check_specialization_namespace
parameter_list|(
name|tree
name|tmpl
parameter_list|)
block|{
name|tree
name|tpl_ns
init|=
name|decl_namespace_context
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
comment|/* [tmpl.expl.spec]       An explicit specialization shall be declared in the namespace of      which the template is a member, or, for member templates, in the      namespace of which the enclosing class or enclosing class      template is a member.  An explicit specialization of a member      function, member class or static data member of a class template      shall be declared in the namespace of which the class template is      a member.  */
if|if
condition|(
name|is_associated_namespace
argument_list|(
name|current_namespace
argument_list|,
name|tpl_ns
argument_list|)
condition|)
comment|/* Same or super-using namespace.  */
return|return
name|true
return|;
else|else
block|{
name|pedwarn
argument_list|(
literal|"specialization of %qD in different namespace"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"  from definition of %q+#D"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* SPEC is an explicit instantiation.  Check that it is valid to    perform this explicit instantiation in the current namespace.  */
end_comment

begin_function
specifier|static
name|void
name|check_explicit_instantiation_namespace
parameter_list|(
name|tree
name|spec
parameter_list|)
block|{
name|tree
name|ns
decl_stmt|;
comment|/* DR 275: An explicit instantiation shall appear in an enclosing      namespace of its template.  */
name|ns
operator|=
name|decl_namespace_context
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_ancestor
argument_list|(
name|current_namespace
argument_list|,
name|ns
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"explicit instantiation of %qD in namespace %qD "
literal|"(which does not enclose namespace %qD)"
argument_list|,
name|spec
argument_list|,
name|current_namespace
argument_list|,
name|ns
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The TYPE is being declared.  If it is a template type, that means it    is a partial specialization.  Do appropriate error-checking.  */
end_comment

begin_function
name|tree
name|maybe_process_partial_specialization
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|error
argument_list|(
literal|"name of class shadows template template parameter %qD"
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* This is for ordinary explicit specialization and partial 	 specialization of a template class such as:  	   template<> class C<int>;  	 or:  	   template<class T> class C<T*>;  	 Make sure that `C<int>' and `C<T*>' are implicit instantiations.  */
if|if
condition|(
name|CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|check_specialization_namespace
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|push_template_decl
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"specialization of %qT after instantiation"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
name|context
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|context
argument_list|)
condition|)
block|{
comment|/* This is for an explicit specialization of member class 	 template according to [temp.expl.spec/18]:  	   template<> template<class U> class C<int>::D;  	 The context `C<int>' must be an implicit instantiation. 	 Otherwise this is just a member class template declared 	 earlier like:  	   template<> class C<int> { template<class U> class D; }; 	   template<> template<class U> class C<int>::D;  	 In the first case, `C<int>::D' is a specialization of `C<T>::D' 	 while in the second case, `C<int>::D' is a primary template 	 and `C<T>::D' may not exist.  */
if|if
condition|(
name|CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|context
argument_list|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_namespace
operator|!=
name|decl_namespace_context
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"specializing %q#T in different namespace"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"  from definition of %q+#D"
argument_list|,
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for invalid specialization after instantiation:  	       template<> template<> class C<int>::D<int>; 	       template<> template<class U> class C<int>::D;  */
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|type
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|context
condition|)
name|error
argument_list|(
literal|"specialization %qT after instantiation %qT"
argument_list|,
name|type
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark TYPE as a specialization.  And as a result, we only 	     have one level of template argument for the innermost 	     class template.  */
name|SET_CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|processing_specialization
condition|)
block|{
name|error
argument_list|(
literal|"explicit specialization of non-template %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if we can optimize the retrieval of specializations    for TMPL, a TEMPLATE_DECL.  In particular, for such a template, we    do not use DECL_TEMPLATE_SPECIALIZATIONS at all.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|optimize_specialization_lookup_p
parameter_list|(
name|tree
name|tmpl
parameter_list|)
block|{
return|return
operator|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|tmpl
argument_list|)
comment|/* DECL_CLASS_SCOPE_P holds of T::f even if T is a template 	     parameter.  */
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
comment|/* The optimized lookup depends on the fact that the 	     template arguments for the member function template apply 	     purely to the containing class, which is not true if the 	     containing class is an explicit or partial 	     specialization.  */
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_MEMBER_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|tmpl
argument_list|)
comment|/* It is possible to have a template that is not a member 	     template and is not a member of a template class:  	     template<typename T> 	     struct S { friend A::f(); };  	     Here, the friend function is a template, but the context does 	     not have template information.  The optimized lookup relies 	     on having ARGS be the template arguments for both the class 	     and the function template.  */
operator|&&
operator|!
name|DECL_FRIEND_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the specialization (in the sense of [temp.spec] - a    specialization is either an instantiation or an explicit    specialization) of TMPL for the given template ARGS.  If there is    no such specialization, return NULL_TREE.  The ARGS are a vector of    arguments, or a vector of vectors of arguments, in the case of    templates with more than one level of parameters.     If TMPL is a type template and CLASS_SPECIALIZATIONS_P is true,    then we search for a partial specialization matching ARGS.  This    parameter is ignored if TMPL is not a class template.  */
end_comment

begin_function
specifier|static
name|tree
name|retrieve_specialization
parameter_list|(
name|tree
name|tmpl
parameter_list|,
name|tree
name|args
parameter_list|,
name|bool
name|class_specializations_p
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|)
expr_stmt|;
comment|/* There should be as many levels of arguments as there are      levels of parameters.  */
name|gcc_assert
argument_list|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|==
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_specialization_lookup_p
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|class_template
decl_stmt|;
name|tree
name|class_specialization
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|methods
expr_stmt|;
name|tree
name|fns
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* The template arguments actually apply to the containing 	 class.  Find the class specialization with those 	 arguments.  */
name|class_template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
name|class_specialization
operator|=
name|retrieve_specialization
argument_list|(
name|class_template
argument_list|,
name|args
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|class_specialization
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Now, find the appropriate entry in the CLASSTYPE_METHOD_VEC 	 for the specialization.  */
name|idx
operator|=
name|class_method_index_for_fn
argument_list|(
name|class_specialization
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Iterate through the methods with the indicated name, looking 	 for the one that has an instance of TMPL.  */
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|class_specialization
argument_list|)
expr_stmt|;
for|for
control|(
name|fns
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|methods
argument_list|,
name|idx
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
operator|==
name|tmpl
condition|)
return|return
name|fn
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
else|else
block|{
name|tree
modifier|*
name|sp
decl_stmt|;
name|tree
modifier|*
name|head
decl_stmt|;
comment|/* Class templates store their instantiations on the 	 DECL_TEMPLATE_INSTANTIATIONS list; other templates use the 	 DECL_TEMPLATE_SPECIALIZATIONS list.  */
if|if
condition|(
operator|!
name|class_specializations_p
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|sp
operator|=
operator|&
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
else|else
name|sp
operator|=
operator|&
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|head
operator|=
name|sp
expr_stmt|;
comment|/* Iterate through the list until we find a matching template.  */
while|while
condition|(
operator|*
name|sp
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|spec
init|=
operator|*
name|sp
decl_stmt|;
if|if
condition|(
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|spec
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
comment|/* Use the move-to-front heuristic to speed up future 		 searches.  */
if|if
condition|(
name|spec
operator|!=
operator|*
name|head
condition|)
block|{
operator|*
name|sp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|spec
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
return|;
block|}
name|sp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like retrieve_specialization, but for local declarations.  */
end_comment

begin_function
specifier|static
name|tree
name|retrieve_local_specialization
parameter_list|(
name|tree
name|tmpl
parameter_list|)
block|{
name|tree
name|spec
init|=
operator|(
name|tree
operator|)
name|htab_find_with_hash
argument_list|(
name|local_specializations
argument_list|,
name|tmpl
argument_list|,
name|htab_hash_pointer
argument_list|(
name|tmpl
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|spec
condition|?
name|TREE_PURPOSE
argument_list|(
name|spec
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff DECL is a specialization of TMPL.  */
end_comment

begin_function
name|int
name|is_specialization_of
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|tmpl
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
for|for
control|(
name|t
operator|=
name|decl
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|?
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|t
operator|==
name|tmpl
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|t
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
name|NULL_TREE
control|)
if|if
condition|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|t
argument_list|,
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero iff DECL is a specialization of friend declaration    FRIEND according to [temp.friend].  */
end_comment

begin_function
name|bool
name|is_specialization_of_friend
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|friend
parameter_list|)
block|{
name|bool
name|need_template
init|=
name|true
decl_stmt|;
name|int
name|template_depth
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
argument_list|)
expr_stmt|;
comment|/* For [temp.friend/6] when FRIEND is an ordinary member function      of a template class, we want to check if DECL is a specialization      if this.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|friend
argument_list|)
operator|&&
operator|!
name|DECL_USE_TEMPLATE
argument_list|(
name|friend
argument_list|)
condition|)
block|{
comment|/* We want a TEMPLATE_DECL for `is_specialization_of'.  */
name|friend
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|friend
argument_list|)
expr_stmt|;
name|need_template
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|friend
argument_list|)
condition|)
name|need_template
operator|=
name|false
expr_stmt|;
comment|/* There is nothing to do if this is not a template friend.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|is_specialization_of
argument_list|(
name|decl
argument_list|,
name|friend
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* [temp.friend/6]      A member of a class template may be declared to be a friend of a      non-template class.  In this case, the corresponding member of      every specialization of the class template is a friend of the      class granting friendship.       For example, given a template friend declaration         template<class T> friend void A<T>::f();       the member function below is considered a friend         template<> struct A<int> { 	 void f();        };       For this type of template friend, TEMPLATE_DEPTH below will be      nonzero.  To determine if DECL is a friend of FRIEND, we first      check if the enclosing class is a specialization of another.  */
name|template_depth
operator|=
name|template_class_depth
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|friend
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_depth
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_specialization_of
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|friend
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Next, we check the members themselves.  In order to handle 	 a few tricky cases, such as when FRIEND's are  	   template<class T> friend void A<T>::g(T t); 	   template<class T> template<T t> friend void A<T>::h();  	 and DECL's are  	   void A<int>::g(int); 	   template<int> void A<int>::h();  	 we need to figure out ARGS, the template arguments from 	 the context of DECL.  This is required for template substitution 	 of `T' in the function parameter of `g' and template parameter 	 of `h' in the above examples.  Here ARGS corresponds to `int'.  */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|current_depth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|current_depth
operator|<
name|template_depth
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|context
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_depth
operator|==
literal|0
condition|)
name|args
operator|=
name|TYPE_TI_ARGS
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|args
operator|=
name|add_to_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|context
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|current_depth
operator|++
expr_stmt|;
block|}
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|bool
name|is_template
decl_stmt|;
name|tree
name|friend_type
decl_stmt|;
name|tree
name|decl_type
decl_stmt|;
name|tree
name|friend_args_type
decl_stmt|;
name|tree
name|decl_args_type
decl_stmt|;
comment|/* Make sure that both DECL and FRIEND are templates or 	     non-templates.  */
name|is_template
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_template
operator|^
name|is_template
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|is_template
condition|)
block|{
comment|/* If both are templates, check template parameter list.  */
name|tree
name|friend_parms
init|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|friend
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_none
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|friend_parms
argument_list|)
condition|)
return|return
name|false
return|;
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|friend_type
operator|=
name|tsubst_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|friend
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_none
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|friend_type
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* Check if return types match.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|friend_type
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Check if function parameter types match, ignoring the 	     `this' parameter.  */
name|friend_args_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
name|decl_args_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|decl_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|friend
argument_list|)
condition|)
name|friend_args_type
operator|=
name|TREE_CHAIN
argument_list|(
name|friend_args_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl_args_type
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_args_type
argument_list|)
expr_stmt|;
return|return
name|compparms
argument_list|(
name|decl_args_type
argument_list|,
name|friend_args_type
argument_list|)
return|;
block|}
else|else
block|{
comment|/* DECL is a TYPE_DECL */
name|bool
name|is_template
decl_stmt|;
name|tree
name|decl_type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Make sure that both DECL and FRIEND are templates or 	     non-templates.  */
name|is_template
operator|=
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|decl_type
argument_list|)
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|decl_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_template
operator|^
name|is_template
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|is_template
condition|)
block|{
name|tree
name|friend_parms
decl_stmt|;
comment|/* If both are templates, check the name of the two 		 TEMPLATE_DECL's first because is_friend didn't.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|decl_type
argument_list|)
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|friend
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Now check template parameter list.  */
name|friend_parms
operator|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|friend
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_none
argument_list|)
expr_stmt|;
return|return
name|comp_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|decl_type
argument_list|)
argument_list|)
argument_list|,
name|friend_parms
argument_list|)
return|;
block|}
else|else
return|return
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|friend
argument_list|)
operator|)
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Register the specialization SPEC as a specialization of TMPL with    the indicated ARGS.  IS_FRIEND indicates whether the specialization    is actually just a friend declaration.  Returns SPEC, or an    equivalent prior declaration, if available.  */
end_comment

begin_function
specifier|static
name|tree
name|register_specialization
parameter_list|(
name|tree
name|spec
parameter_list|,
name|tree
name|tmpl
parameter_list|,
name|tree
name|args
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
argument_list|)
condition|)
comment|/* This is the FUNCTION_DECL for a partial instantiation.  Don't        register it; we want the corresponding TEMPLATE_DECL instead.        We use `uses_template_parms (DECL_TI_ARGS (spec))' rather than        the more obvious `uses_template_parms (spec)' to avoid problems        with default function arguments.  In particular, given        something like this:  	  template<class T> void f(T t1, T t = T())         the default argument expression is not substituted for in an        instantiation unless and until it is actually needed.  */
return|return
name|spec
return|;
name|fn
operator|=
name|retrieve_specialization
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* We can sometimes try to re-register a specialization that we've      already got.  In particular, regenerate_decl_from_template calls      duplicate_decls which will update the specialization list.  But,      we'll still get called again here anyhow.  It's more convenient      to simply allow this than to try to prevent it.  */
if|if
condition|(
name|fn
operator|==
name|spec
condition|)
return|return
name|spec
return|;
elseif|else
if|if
condition|(
name|fn
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|fn
argument_list|)
operator|||
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"specialization of %qD after instantiation"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|clone
decl_stmt|;
comment|/* This situation should occur only if the first 		 specialization is an implicit instantiation, the 		 second is an explicit specialization, and the 		 implicit instantiation has not yet been used.  That 		 situation can occur if we have implicitly 		 instantiated a member function and then specialized 		 it later.  		 We can also wind up here if a friend declaration that 		 looked like an instantiation turns out to be a 		 specialization:  		   template<class T> void foo(T); 		   class S { friend void foo<>(int) }; 		   template<> void foo(int);  		 We transform the existing DECL in place so that any 		 pointers to it become pointers to the updated 		 declaration.  		 If there was a definition for the template, but not 		 for the specialization, we want this to look as if 		 there were no definition, and vice versa.  */
name|DECL_INITIAL
argument_list|(
name|fn
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|duplicate_decls
argument_list|(
name|spec
argument_list|,
name|fn
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
comment|/* The call to duplicate_decls will have applied 		 [temp.expl.spec]:  		   An explicit specialization of a function template 		   is inline only if it is explicitly declared to be, 		   and independently of whether its function template 		   is.  		to the primary function; now copy the inline bits to 		the various clones.  */
name|FOR_EACH_CLONE
argument_list|(
argument|clone
argument_list|,
argument|fn
argument_list|)
block|{
name|DECL_DECLARED_INLINE_P
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|clone
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
name|check_specialization_namespace
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|duplicate_decls
argument_list|(
name|spec
argument_list|,
name|fn
argument_list|,
name|is_friend
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|spec
argument_list|)
condition|)
comment|/* Dup decl failed, but this is a new definition. Set the 	       line number so any errors match this new 	       definition.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|fn
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|spec
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
block|}
comment|/* A specialization must be declared in the same namespace as the      template it is specializing.  */
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
operator|&&
operator|!
name|check_specialization_namespace
argument_list|(
name|tmpl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|spec
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|decl_namespace_context
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimize_specialization_lookup_p
argument_list|(
name|tmpl
argument_list|)
condition|)
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|args
argument_list|,
name|spec
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|spec
return|;
block|}
end_function

begin_comment
comment|/* Unregister the specialization SPEC as a specialization of TMPL.    Replace it with NEW_SPEC, if NEW_SPEC is non-NULL.  Returns true    if the SPEC was listed as a specialization of TMPL.  */
end_comment

begin_function
name|bool
name|reregister_specialization
parameter_list|(
name|tree
name|spec
parameter_list|,
name|tree
name|tmpl
parameter_list|,
name|tree
name|new_spec
parameter_list|)
block|{
name|tree
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
operator|&
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
operator|*
name|s
operator|!=
name|NULL_TREE
condition|;
name|s
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|s
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
operator|*
name|s
argument_list|)
operator|==
name|spec
condition|)
block|{
if|if
condition|(
operator|!
name|new_spec
condition|)
operator|*
name|s
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
operator|*
name|s
argument_list|)
operator|=
name|new_spec
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare an entry in the local specializations hash table P1 (which    is really a pointer to a TREE_LIST) with P2 (which is really a    DECL).  */
end_comment

begin_function
specifier|static
name|int
name|eq_local_specializations
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
name|TREE_VALUE
argument_list|(
operator|(
name|tree
operator|)
name|p1
argument_list|)
operator|==
operator|(
name|tree
operator|)
name|p2
return|;
block|}
end_function

begin_comment
comment|/* Hash P1, an entry in the local specializations table.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_local_specialization
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|)
block|{
return|return
name|htab_hash_pointer
argument_list|(
name|TREE_VALUE
argument_list|(
operator|(
name|tree
operator|)
name|p1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like register_specialization, but for local declarations.  We are    registering SPEC, an instantiation of TMPL.  */
end_comment

begin_function
specifier|static
name|void
name|register_local_specialization
parameter_list|(
name|tree
name|spec
parameter_list|,
name|tree
name|tmpl
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|local_specializations
argument_list|,
name|tmpl
argument_list|,
name|htab_hash_pointer
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|build_tree_list
argument_list|(
name|spec
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TYPE is a class type.  Returns true if TYPE is an explicitly    specialized class.  */
end_comment

begin_function
name|bool
name|explicit_class_specialization_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|!
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print the list of candidate FNS in an error message.  */
end_comment

begin_function
name|void
name|print_candidates
parameter_list|(
name|tree
name|fns
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
for|for
control|(
name|fn
operator|=
name|fns
init|;
name|fn
operator|!=
name|NULL_TREE
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|tree
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
init|;
name|f
condition|;
name|f
operator|=
name|OVL_NEXT
argument_list|(
name|f
argument_list|)
control|)
name|error
argument_list|(
literal|"%s %+#D"
argument_list|,
name|str
argument_list|,
name|OVL_CURRENT
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the template (one of the functions given by TEMPLATE_ID)    which can be specialized to match the indicated DECL with the    explicit template args given in TEMPLATE_ID.  The DECL may be    NULL_TREE if none is available.  In that case, the functions in    TEMPLATE_ID are non-members.     If NEED_MEMBER_TEMPLATE is nonzero the function is known to be a    specialization of a member template.     The TEMPLATE_COUNT is the number of references to qualifying    template classes that appeared in the name of the function. See    check_explicit_specialization for a more accurate description.     TSK indicates what kind of template declaration (if any) is being    declared.  TSK_TEMPLATE indicates that the declaration given by    DECL, though a FUNCTION_DECL, has template parameters, and is    therefore a template function.     The template args (those explicitly specified and those deduced)    are output in a newly created vector *TARGS_OUT.     If it is impossible to determine the result, an error message is    issued.  The error_mark_node is returned to indicate failure.  */
end_comment

begin_function
specifier|static
name|tree
name|determine_specialization
parameter_list|(
name|tree
name|template_id
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
modifier|*
name|targs_out
parameter_list|,
name|int
name|need_member_template
parameter_list|,
name|int
name|template_count
parameter_list|,
name|tmpl_spec_kind
name|tsk
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|explicit_targs
decl_stmt|;
name|tree
name|candidates
init|=
name|NULL_TREE
decl_stmt|;
comment|/* A TREE_LIST of templates of which DECL may be a specialization.      The TREE_VALUE of each node is a TEMPLATE_DECL.  The      corresponding TREE_PURPOSE is the set of template arguments that,      when used to instantiate the template, would produce a function      with the signature of DECL.  */
name|tree
name|templates
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|header_count
decl_stmt|;
name|struct
name|cp_binding_level
modifier|*
name|b
decl_stmt|;
operator|*
name|targs_out
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|template_id
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|explicit_targs
operator|=
name|TREE_OPERAND
argument_list|(
name|template_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check for baselinks.  */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD is not a function template"
argument_list|,
name|fns
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Count the number of template headers specified for this      specialization.  */
name|header_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
operator|->
name|kind
operator|==
name|sk_template_parms
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
operator|++
name|header_count
expr_stmt|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|decl_arg_types
decl_stmt|;
name|tree
name|fn_arg_types
decl_stmt|;
comment|/* In case of explicit specialization, we need to check if 	     the number of template headers appearing in the specialization 	     is correct. This is usually done in check_explicit_specialization, 	     but the check done there cannot be exhaustive when specializing 	     member functions. Consider the following code:  	     template<> void A<int>::f(int); 	     template<> template<> void A<int>::f(int);  	     Assuming that A<int> is not itself an explicit specialization 	     already, the first line specializes "f" which is a non-template 	     member function, whilst the second line specializes "f" which 	     is a template member function. So both lines are syntactically 	     correct, and check_explicit_specialization does not reject 	     them.  	     Here, we can do better, as we are matching the specialization 	     against the declarations. We count the number of template 	     headers, and we check if they match TEMPLATE_COUNT + 1 	     (TEMPLATE_COUNT is the number of qualifying template classes, 	     plus there must be another header for the member template 	     itself).  	     Notice that if header_count is zero, this is not a 	     specialization but rather a template instantiation, so there 	     is no check we can perform here.  */
if|if
condition|(
name|header_count
operator|&&
name|header_count
operator|!=
name|template_count
operator|+
literal|1
condition|)
continue|continue;
comment|/* Check that the number of template arguments at the 	     innermost level for DECL is the same as for FN.  */
if|if
condition|(
name|current_binding_level
operator|->
name|kind
operator|==
name|sk_template_parms
operator|&&
operator|!
name|current_binding_level
operator|->
name|explicit_spec_p
operator|&&
operator|(
name|TREE_VEC_LENGTH
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|current_template_parms
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* DECL might be a specialization of FN.  */
name|decl_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|fn_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a non-static member function, we need to make sure 	     that the const qualification is the same.  Since 	     get_bindings does not try to merge the "this" parameter, 	     we must do the comparison explicitly.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|fn_arg_types
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|decl_arg_types
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Skip the "this" parameter and, for constructors of 	     classes with virtual bases, the VTT parameter.  A 	     full specialization of a constructor will have a VTT 	     parameter, but a template never will.  */
name|decl_arg_types
operator|=
name|skip_artificial_parms_for
argument_list|(
name|decl
argument_list|,
name|decl_arg_types
argument_list|)
expr_stmt|;
name|fn_arg_types
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|fn_arg_types
argument_list|)
expr_stmt|;
comment|/* Check that the number of function parameters matches. 	     For example, 	       template<class T> void f(int i = 0); 	       template<> void f<int>(); 	     The specialization f<int> is invalid but is not caught 	     by get_bindings below.  */
if|if
condition|(
name|list_length
argument_list|(
name|fn_arg_types
argument_list|)
operator|!=
name|list_length
argument_list|(
name|decl_arg_types
argument_list|)
condition|)
continue|continue;
comment|/* Function templates cannot be specializations; there are 	     no partial specializations of functions.  Therefore, if 	     the type of DECL does not match FN, there is no 	     match.  */
if|if
condition|(
name|tsk
operator|==
name|tsk_template
condition|)
block|{
if|if
condition|(
name|compparms
argument_list|(
name|fn_arg_types
argument_list|,
name|decl_arg_types
argument_list|)
condition|)
name|candidates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See whether this function might be a specialization of this 	     template.  */
name|targs
operator|=
name|get_bindings
argument_list|(
name|fn
argument_list|,
name|decl
argument_list|,
name|explicit_targs
argument_list|,
comment|/*check_ret=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targs
condition|)
comment|/* We cannot deduce template arguments that when used to 	       specialize TMPL will produce DECL.  */
continue|continue;
comment|/* Save this template, and the arguments deduced.  */
name|templates
operator|=
name|tree_cons
argument_list|(
name|targs
argument_list|,
name|fn
argument_list|,
name|templates
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_member_template
condition|)
comment|/* FN is an ordinary member function, and we need a 	   specialization of a member template.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* We can get IDENTIFIER_NODEs here in certain erroneous 	   cases.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* This is just an ordinary non-member function.  Nothing can 	   be a specialization of that.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Cannot specialize functions that are created implicitly.  */
empty_stmt|;
else|else
block|{
name|tree
name|decl_arg_types
decl_stmt|;
comment|/* This is an ordinary member function.  However, since 	     we're here, we can assume it's enclosing class is a 	     template class.  For example,  	       template<typename T> struct S { void f(); }; 	       template<> void S<int>::f() {}  	     Here, S<int>::f is a non-template, but S<int> is a 	     template class.  If FN has the same type as DECL, we 	     might be in business.  */
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* Its enclosing class is an explicit specialization 	       of a template class.  This is not a candidate.  */
continue|continue;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* The return types differ.  */
continue|continue;
comment|/* Adjust the type of DECL in case FN is a static member.  */
name|decl_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl_arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|compparms
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|decl_arg_types
argument_list|)
condition|)
comment|/* They match!  */
name|candidates
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|candidates
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|templates
operator|&&
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
condition|)
block|{
comment|/* We have:  	   [temp.expl.spec]  	   It is possible for a specialization with a given function 	   signature to be instantiated from more than one function 	   template.  In such cases, explicit specification of the 	   template arguments must be used to uniquely identify the 	   function template specialization being specialized.  	 Note that here, there's no suggestion that we're supposed to 	 determine which of the candidate templates is most 	 specialized.  However, we, also have:  	   [temp.func.order]  	   Partial ordering of overloaded function template 	   declarations is used in the following contexts to select 	   the function template to which a function template 	   specialization refers:  	   -- when an explicit specialization refers to a function 	      template.  	 So, we do use the partial ordering rules, at least for now. 	 This extension can only serve to make invalid programs valid, 	 so it's safe.  And, there is strong anecdotal evidence that 	 the committee intended the partial ordering rules to apply; 	 the EDG front-end has that behavior, and John Spicer claims 	 that the committee simply forgot to delete the wording in 	 [temp.expl.spec].  */
name|tree
name|tmpl
init|=
name|most_specialized_instantiation
argument_list|(
name|templates
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpl
operator|!=
name|error_mark_node
condition|)
block|{
name|templates
operator|=
name|tmpl
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|templates
operator|==
name|NULL_TREE
operator|&&
name|candidates
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"template-id %qD for %q+D does not match any template "
literal|"declaration"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|templates
operator|&&
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
operator|)
operator|||
operator|(
name|candidates
operator|&&
name|TREE_CHAIN
argument_list|(
name|candidates
argument_list|)
operator|)
operator|||
operator|(
name|templates
operator|&&
name|candidates
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"ambiguous template specialization %qD for %q+D"
argument_list|,
name|template_id
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|chainon
argument_list|(
name|candidates
argument_list|,
name|templates
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* We have one, and exactly one, match.  */
if|if
condition|(
name|candidates
condition|)
block|{
name|tree
name|fn
init|=
name|TREE_VALUE
argument_list|(
name|candidates
argument_list|)
decl_stmt|;
comment|/* DECL is a re-declaration of a template function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
return|return
name|fn
return|;
comment|/* It was a specialization of an ordinary member function in a 	 template class.  */
operator|*
name|targs_out
operator|=
name|copy_node
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_TI_TEMPLATE
argument_list|(
name|fn
argument_list|)
return|;
block|}
comment|/* It was a specialization of a template.  */
name|targs
operator|=
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|TREE_VALUE
argument_list|(
name|templates
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|targs
argument_list|)
condition|)
block|{
operator|*
name|targs_out
operator|=
name|copy_node
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
operator|*
name|targs_out
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
operator|*
name|targs_out
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|targs_out
operator|=
name|TREE_PURPOSE
argument_list|(
name|templates
argument_list|)
expr_stmt|;
return|return
name|TREE_VALUE
argument_list|(
name|templates
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a chain of parameter types, exactly like the SPEC_TYPES,    but with the default argument values filled in from those in the    TMPL_TYPES.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_default_args_to_explicit_spec_1
parameter_list|(
name|tree
name|spec_types
parameter_list|,
name|tree
name|tmpl_types
parameter_list|)
block|{
name|tree
name|new_spec_types
decl_stmt|;
if|if
condition|(
operator|!
name|spec_types
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|spec_types
operator|==
name|void_list_node
condition|)
return|return
name|void_list_node
return|;
comment|/* Substitute into the rest of the list.  */
name|new_spec_types
operator|=
name|copy_default_args_to_explicit_spec_1
argument_list|(
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|tmpl_types
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the default argument for this parameter.  */
return|return
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tmpl_types
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|spec_types
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is an explicit specialization.  Replicate default arguments    from the template it specializes.  (That way, code like:       template<class T> void f(T = 3);      template<> void f(double);      void g () { f (); }     works, as required.)  An alternative approach would be to look up    the correct default arguments at the call-site, but this approach    is consistent with how implicit instantiations are handled.  */
end_comment

begin_function
specifier|static
name|void
name|copy_default_args_to_explicit_spec
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|spec_types
decl_stmt|;
name|tree
name|tmpl_types
decl_stmt|;
name|tree
name|new_spec_types
decl_stmt|;
name|tree
name|old_type
decl_stmt|;
name|tree
name|new_type
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|object_type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|in_charge
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vtt
init|=
name|NULL_TREE
decl_stmt|;
comment|/* See if there's anything we need to do.  */
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|tmpl_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tmpl_types
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
name|old_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|spec_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|old_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Remove the this pointer, but remember the object's type for 	 CV quals.  */
name|object_type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|spec_types
argument_list|)
argument_list|)
expr_stmt|;
name|spec_types
operator|=
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
expr_stmt|;
name|tmpl_types
operator|=
name|TREE_CHAIN
argument_list|(
name|tmpl_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* DECL may contain more parameters than TMPL due to the extra 	     in-charge parameter in constructors and destructors.  */
name|in_charge
operator|=
name|spec_types
expr_stmt|;
name|spec_types
operator|=
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|vtt
operator|=
name|spec_types
expr_stmt|;
name|spec_types
operator|=
name|TREE_CHAIN
argument_list|(
name|spec_types
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Compute the merged default arguments.  */
name|new_spec_types
operator|=
name|copy_default_args_to_explicit_spec_1
argument_list|(
name|spec_types
argument_list|,
name|tmpl_types
argument_list|)
expr_stmt|;
comment|/* Compute the new FUNCTION_TYPE.  */
if|if
condition|(
name|object_type
condition|)
block|{
if|if
condition|(
name|vtt
condition|)
name|new_spec_types
operator|=
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|vtt
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_charge
condition|)
comment|/* Put the in-charge parameter back.  */
name|new_spec_types
operator|=
name|hash_tree_cons
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|in_charge
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|in_charge
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
name|new_type
operator|=
name|build_method_type_directly
argument_list|(
name|object_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|old_type
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
block|}
else|else
name|new_type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_type
argument_list|)
argument_list|,
name|new_spec_types
argument_list|)
expr_stmt|;
name|new_type
operator|=
name|cp_build_type_attribute_variant
argument_list|(
name|new_type
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|old_type
argument_list|)
argument_list|)
expr_stmt|;
name|new_type
operator|=
name|build_exception_variant
argument_list|(
name|new_type
argument_list|,
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|old_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|new_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see if the function just declared, as indicated in    DECLARATOR, and in DECL, is a specialization of a function    template.  We may also discover that the declaration is an explicit    instantiation at this point.     Returns DECL, or an equivalent declaration that should be used    instead if all goes well.  Issues an error message if something is    amiss.  Returns error_mark_node if the error is not easily    recoverable.     FLAGS is a bitmask consisting of the following flags:     2: The function has a definition.    4: The function is a friend.     The TEMPLATE_COUNT is the number of references to qualifying    template classes that appeared in the name of the function.  For    example, in       template<class T> struct S { void f(); };      void S<int>::f();     the TEMPLATE_COUNT would be 1.  However, explicitly specialized    classes are not counted in the TEMPLATE_COUNT, so that in       template<class T> struct S {};      template<> struct S<int> { void f(); }      template<> void S<int>::f();     the TEMPLATE_COUNT would be 0.  (Note that this declaration is    invalid; there should be no template<>.)     If the function is a specialization, it is marked as such via    DECL_TEMPLATE_SPECIALIZATION.  Furthermore, its DECL_TEMPLATE_INFO    is set up correctly, and it is added to the list of specializations    for that template.  */
end_comment

begin_function
name|tree
name|check_explicit_specialization
parameter_list|(
name|tree
name|declarator
parameter_list|,
name|tree
name|decl
parameter_list|,
name|int
name|template_count
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|have_def
init|=
name|flags
operator|&
literal|2
decl_stmt|;
name|int
name|is_friend
init|=
name|flags
operator|&
literal|4
decl_stmt|;
name|int
name|specialization
init|=
literal|0
decl_stmt|;
name|int
name|explicit_instantiation
init|=
literal|0
decl_stmt|;
name|int
name|member_specialization
init|=
literal|0
decl_stmt|;
name|tree
name|ctype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|dname
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tmpl_spec_kind
name|tsk
decl_stmt|;
if|if
condition|(
name|is_friend
condition|)
block|{
if|if
condition|(
operator|!
name|processing_specialization
condition|)
name|tsk
operator|=
name|tsk_none
expr_stmt|;
else|else
name|tsk
operator|=
name|tsk_excessive_parms
expr_stmt|;
block|}
else|else
name|tsk
operator|=
name|current_tmpl_spec_kind
argument_list|(
name|template_count
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tsk
condition|)
block|{
case|case
name|tsk_none
case|:
if|if
condition|(
name|processing_specialization
condition|)
block|{
name|specialization
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
name|is_friend
condition|)
comment|/* This could be something like:  	       template<class T> void f(T); 	       class S { friend void f<>(int); }  */
name|specialization
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* This case handles bogus declarations like template<> 		 template<class T> void f<int>(); */
name|error
argument_list|(
literal|"template-id %qD in declaration of primary template"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
break|break;
case|case
name|tsk_invalid_member_spec
case|:
comment|/* The error has already been reported in 	 check_specialization_scope.  */
return|return
name|error_mark_node
return|;
case|case
name|tsk_invalid_expl_inst
case|:
name|error
argument_list|(
literal|"template parameter list used in explicit instantiation"
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|tsk_expl_inst
case|:
if|if
condition|(
name|have_def
condition|)
name|error
argument_list|(
literal|"definition provided for explicit instantiation"
argument_list|)
expr_stmt|;
name|explicit_instantiation
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tsk_excessive_parms
case|:
case|case
name|tsk_insufficient_parms
case|:
if|if
condition|(
name|tsk
operator|==
name|tsk_excessive_parms
condition|)
name|error
argument_list|(
literal|"too many template parameter lists in declaration of %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|template_header_count
condition|)
name|error
argument_list|(
literal|"too few template parameter lists in declaration of %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"explicit specialization of %qD must be introduced by "
literal|"%<template<>%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|tsk_expl_spec
case|:
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
name|member_specialization
operator|=
literal|1
expr_stmt|;
else|else
name|specialization
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|tsk_template
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* This case handles bogus declarations like template<> 	     template<class T> void f<int>(); */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|declarator
argument_list|)
condition|)
name|error
argument_list|(
literal|"function template partial specialization %qD "
literal|"is not allowed"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"template-id %qD in declaration of primary template"
argument_list|,
name|declarator
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|ctype
operator|&&
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|ctype
argument_list|)
condition|)
comment|/* This is a specialization of a member template, without 	   specialization the containing class.  Something like:  	     template<class T> struct S { 	       template<class U> void f (U); 	     }; 	     template<> template<class U> void S<int>::f(U) {}  	   That's a specialization -- but of the entire template.  */
name|specialization
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
condition|)
block|{
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"default argument specified in explicit specialization"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|specialization
operator|||
name|member_specialization
operator|||
name|explicit_instantiation
condition|)
block|{
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|targs
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Make sure that the declarator is a TEMPLATE_ID_EXPR.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|fns
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
condition|)
name|fns
operator|=
name|dname
expr_stmt|;
else|else
block|{
comment|/* If there is no class context, the explicit instantiation 		 must be at namespace scope.  */
name|gcc_assert
argument_list|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the namespace binding, using the declaration 		 context.  */
name|fns
operator|=
name|lookup_qualified_name
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|dname
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
operator|||
operator|!
name|is_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD is not a template function"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|fns
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_associated_namespace
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|CP_DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD is not declared in %qD"
argument_list|,
name|decl
argument_list|,
name|current_namespace
argument_list|)
expr_stmt|;
block|}
block|}
name|declarator
operator|=
name|lookup_template_function
argument_list|(
name|fns
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declarator
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit_instantiation
condition|)
comment|/* A specialization in class scope.  This is invalid, 	       but the error will already have been flagged by 	       check_specialization_scope.  */
return|return
name|error_mark_node
return|;
else|else
block|{
comment|/* It's not valid to write an explicit instantiation in 		 class scope, e.g.:  		   class C { template void f(); }  		   This case is caught by the parser.  However, on 		   something like:  		   template class C { void f(); };  		   (which is invalid) we can get here.  The error will be 		   issued later.  */
empty_stmt|;
block|}
return|return
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|ctype
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
block|{
comment|/* Find the list of functions in ctype that have the same 	     name as the declared function.  */
name|tree
name|name
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|fns
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|constructor_name_p
argument_list|(
name|name
argument_list|,
name|ctype
argument_list|)
condition|)
block|{
name|int
name|is_constructor
init|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_constructor
condition|?
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|ctype
argument_list|)
else|:
operator|!
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
comment|/* From [temp.expl.spec]:  		     If such an explicit specialization for the member 		     of a class template names an implicitly-declared 		     special member function (clause _special_), the 		     program is ill-formed.  		     Similar language is found in [temp.explicit].  */
name|error
argument_list|(
literal|"specialization of implicitly-declared special member function"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|name
operator|=
name|is_constructor
condition|?
name|ctor_identifier
else|:
name|dtor_identifier
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|idx
operator|=
name|lookup_fnfields_1
argument_list|(
name|ctype
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
name|fns
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|methods
expr_stmt|;
name|tree
name|ovl
decl_stmt|;
comment|/* For a type-conversion operator, we cannot do a 		 name-based lookup.  We might be looking for `operator 		 int' which will be a specialization of `operator T'. 		 So, we find *all* the conversion operators, and then 		 select from them.  */
name|fns
operator|=
name|NULL_TREE
expr_stmt|;
name|methods
operator|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
condition|)
for|for
control|(
name|idx
operator|=
name|CLASSTYPE_FIRST_CONVERSION_SLOT
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|methods
argument_list|,
name|idx
argument_list|,
name|ovl
argument_list|)
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
operator|!
name|DECL_CONV_FN_P
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ovl
argument_list|)
argument_list|)
condition|)
comment|/* There are no more conversion functions.  */
break|break;
comment|/* Glue all these conversion functions together 		       with those we already have.  */
for|for
control|(
init|;
name|ovl
condition|;
name|ovl
operator|=
name|OVL_NEXT
argument_list|(
name|ovl
argument_list|)
control|)
name|fns
operator|=
name|ovl_cons
argument_list|(
name|OVL_CURRENT
argument_list|(
name|ovl
argument_list|)
argument_list|,
name|fns
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fns
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"no member function %qD declared in %qT"
argument_list|,
name|name
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
else|else
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|=
name|fns
expr_stmt|;
block|}
comment|/* Figure out what exactly is being specialized at this point. 	 Note that for an explicit instantiation, even one for a 	 member function, we cannot tell apriori whether the 	 instantiation is for a member template, or just a member 	 function of a template class.  Even if a member template is 	 being instantiated, the member template arguments may be 	 elided if they can be deduced from the rest of the 	 declaration.  */
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|declarator
argument_list|,
name|decl
argument_list|,
operator|&
name|targs
argument_list|,
name|member_specialization
argument_list|,
name|template_count
argument_list|,
name|tsk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpl
operator|||
name|tmpl
operator|==
name|error_mark_node
condition|)
comment|/* We couldn't figure out what this declaration was 	   specializing.  */
return|return
name|error_mark_node
return|;
else|else
block|{
name|tree
name|gen_tmpl
init|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
if|if
condition|(
name|explicit_instantiation
condition|)
block|{
comment|/* We don't set DECL_EXPLICIT_INSTANTIATION here; that 		 is done by do_decl_instantiation later.  */
name|int
name|arg_depth
init|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
decl_stmt|;
name|int
name|parm_depth
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_depth
operator|>
name|parm_depth
condition|)
block|{
comment|/* If TMPL is not the most general template (for 		     example, if TMPL is a friend template that is 		     injected into namespace scope), then there will 		     be too many levels of TARGS.  Remove some of them 		     here.  */
name|int
name|i
decl_stmt|;
name|tree
name|new_targs
decl_stmt|;
name|new_targs
operator|=
name|make_tree_vec
argument_list|(
name|parm_depth
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg_depth
operator|-
name|parm_depth
init|;
name|i
operator|<
name|arg_depth
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|new_targs
argument_list|,
name|i
operator|-
operator|(
name|arg_depth
operator|-
name|parm_depth
operator|)
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|targs
operator|=
name|new_targs
expr_stmt|;
block|}
return|return
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|tf_error
argument_list|)
return|;
block|}
comment|/* If we thought that the DECL was a member function, but it 	     turns out to be specializing a static member function, 	     make DECL a static member function as well.  */
if|if
condition|(
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
name|revert_static_member_fn
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If this is a specialization of a member template of a 	     template class, we want to return the TEMPLATE_DECL, not 	     the specialization of it.  */
if|if
condition|(
name|tsk
operator|==
name|tsk_template
condition|)
block|{
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|have_def
condition|)
block|{
name|DECL_SOURCE_LOCATION
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We want to use the argument list specified in the 		     definition, not in the original declaration.  */
name|DECL_ARGUMENTS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|tmpl
return|;
block|}
comment|/* Set up the DECL_TEMPLATE_INFO for DECL.  */
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|targs
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Inherit default function arguments from the template 	     DECL is specializing.  */
name|copy_default_args_to_explicit_spec
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* This specialization has the same protection as the 	     template it specializes.  */
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
comment|/* If DECL is a friend declaration, declared using an 	     unqualified name, the namespace associated with DECL may 	     have been set incorrectly.  For example, in:  	       template<typename T> void f(T); 	       namespace N { 		 struct S { friend void f<int>(int); } 	       }  	     we will have set the DECL_CONTEXT for the friend 	     declaration to N, rather than to the global namespace.  */
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_friend
operator|&&
operator|!
name|have_def
condition|)
comment|/* This is not really a declaration of a specialization. 	       It's just the name of an instantiation.  But, it's not 	       a request for an instantiation, either.  */
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* This is indeed a specialization.  In case of constructors 	       and destructors, we need in-charge and not-in-charge 	       versions in V3 ABI.  */
name|clone_function_decl
argument_list|(
name|decl
argument_list|,
comment|/*update_method_vec_p=*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Register this specialization so that we can find it 	     again.  */
name|decl
operator|=
name|register_specialization
argument_list|(
name|decl
argument_list|,
name|gen_tmpl
argument_list|,
name|targs
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff PARMS1 and PARMS2 are identical sets of template    parameters.  These are represented in the same format used for    DECL_TEMPLATE_PARMS.  */
end_comment

begin_function
name|int
name|comp_template_parms
parameter_list|(
name|tree
name|parms1
parameter_list|,
name|tree
name|parms2
parameter_list|)
block|{
name|tree
name|p1
decl_stmt|;
name|tree
name|p2
decl_stmt|;
if|if
condition|(
name|parms1
operator|==
name|parms2
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p1
operator|=
name|parms1
operator|,
name|p2
operator|=
name|parms2
init|;
name|p1
operator|!=
name|NULL_TREE
operator|&&
name|p2
operator|!=
name|NULL_TREE
condition|;
name|p1
operator|=
name|TREE_CHAIN
argument_list|(
name|p1
argument_list|)
operator|,
name|p2
operator|=
name|TREE_CHAIN
argument_list|(
name|p2
argument_list|)
control|)
block|{
name|tree
name|t1
init|=
name|TREE_VALUE
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|tree
name|t2
init|=
name|TREE_VALUE
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|t2
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t1
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|parm2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|t2
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If either of the template parameters are invalid, assume              they match for the sake of error recovery. */
if|if
condition|(
name|parm1
operator|==
name|error_mark_node
operator|||
name|parm2
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm1
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
name|p1
operator|!=
name|NULL_TREE
operator|)
operator|!=
operator|(
name|p2
operator|!=
name|NULL_TREE
operator|)
condition|)
comment|/* One set of parameters has more parameters lists than the        other.  */
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Complain if DECL shadows a template parameter.     [temp.local]: A template-parameter shall not be redeclared within its    scope (including nested scopes).  */
end_comment

begin_function
name|void
name|check_template_shadow
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|olddecl
decl_stmt|;
comment|/* If we're not in a template, we can't possibly shadow a template      parameter.  */
if|if
condition|(
operator|!
name|current_template_parms
condition|)
return|return;
comment|/* Figure out what we're shadowing.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|OVERLOAD
condition|)
name|decl
operator|=
name|OVL_CURRENT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|olddecl
operator|=
name|innermost_non_namespace_value
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's no previous binding for this name, we're not shadowing      anything, let alone a template parameter.  */
if|if
condition|(
operator|!
name|olddecl
condition|)
return|return;
comment|/* If we're not shadowing a template parameter, we're done.  Note      that OLDDECL might be an OVERLOAD (or perhaps even an      ERROR_MARK), so we can't just blithely assume it to be a _DECL      node.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return;
comment|/* We check for decl != olddecl to avoid bogus errors for using a      name inside a class.  We check TPFI to avoid duplicate errors for      inline member templates.  */
if|if
condition|(
name|decl
operator|==
name|olddecl
operator|||
name|TEMPLATE_PARMS_FOR_INLINE
argument_list|(
name|current_template_parms
argument_list|)
condition|)
return|return;
name|error
argument_list|(
literal|"declaration of %q+#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" shadows template parm %q+#D"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,    ORIG_LEVEL, DECL, and TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_parm_index
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|orig_level
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|TEMPLATE_PARM_INDEX
argument_list|)
decl_stmt|;
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
operator|=
name|index
expr_stmt|;
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|level
expr_stmt|;
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|t
argument_list|)
operator|=
name|orig_level
expr_stmt|;
name|TEMPLATE_PARM_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_INVARIANT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose    TEMPLATE_PARM_LEVEL has been decreased by LEVELS.  If such a    TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a    new one is created.  */
end_comment

begin_function
specifier|static
name|tree
name|reduce_template_parm_level
parameter_list|(
name|tree
name|index
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|levels
parameter_list|)
block|{
if|if
condition|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
operator|)
condition|)
block|{
name|tree
name|orig_decl
init|=
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|t
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TREE_CODE
argument_list|(
name|orig_decl
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|orig_decl
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_INVARIANT
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|orig_decl
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_template_parm_index
argument_list|(
name|TEMPLATE_PARM_IDX
argument_list|(
name|index
argument_list|)
argument_list|,
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|index
argument_list|)
operator|-
name|levels
argument_list|,
name|TEMPLATE_PARM_ORIG_LEVEL
argument_list|(
name|index
argument_list|)
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Template template parameters need this.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|DECL_TEMPLATE_PARMS
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TEMPLATE_PARM_DECL
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TEMPLATE_PARM_DESCENDANTS
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process information from new template parameter PARM and append it to the    LIST being built.  This new parameter is a non-type parameter iff    IS_NON_TYPE is true.  */
end_comment

begin_function
name|tree
name|process_template_parm
parameter_list|(
name|tree
name|list
parameter_list|,
name|tree
name|parm
parameter_list|,
name|bool
name|is_non_type
parameter_list|)
block|{
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|tree
name|defval
decl_stmt|;
name|tree
name|err_parm_list
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
name|defval
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|tree
name|p
init|=
name|tree_last
argument_list|(
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|&&
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|p
operator|=
name|TREE_VALUE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|idx
expr_stmt|;
block|}
else|else
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_non_type
condition|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|err_parm_list
operator|=
name|build_tree_list
argument_list|(
name|defval
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|err_parm_list
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|err_parm_list
argument_list|)
return|;
block|}
else|else
block|{
comment|/* [temp.param]  	   The top-level cv-qualifiers on the template-parameter are 	   ignored when determining its type.  */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalid_nontype_parm_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|err_parm_list
operator|=
name|build_tree_list
argument_list|(
name|defval
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|err_parm_list
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|err_parm_list
argument_list|)
return|;
block|}
block|}
comment|/* A template parameter is not modifiable.  */
name|TREE_CONSTANT
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|&&
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TEMPLATE_TEMPLATE_PARM
argument_list|)
expr_stmt|;
comment|/* This is for distinguishing between real templates and template 	     template parameters */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|t
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|=
name|t
expr_stmt|;
name|decl
operator|=
name|parm
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TEMPLATE_TYPE_PARM
argument_list|)
expr_stmt|;
comment|/* parm is either IDENTIFIER_NODE or NULL_TREE.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|parm
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|decl
expr_stmt|;
name|parm
operator|=
name|decl
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
operator|=
name|build_template_parm_index
argument_list|(
name|idx
argument_list|,
name|processing_template_decl
argument_list|,
name|processing_template_decl
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_tree_list
argument_list|(
name|defval
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return
name|chainon
argument_list|(
name|list
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The end of a template parameter list has been reached.  Process the    tree list into a parameter vector, converting each parameter into a more    useful form.	 Type parameters are saved as IDENTIFIER_NODEs, and others    as PARM_DECLs.  */
end_comment

begin_function
name|tree
name|end_template_parm_list
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
name|int
name|nparms
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|next
decl_stmt|;
name|tree
name|saved_parmlist
init|=
name|make_tree_vec
argument_list|(
name|list_length
argument_list|(
name|parms
argument_list|)
argument_list|)
decl_stmt|;
name|current_template_parms
operator|=
name|tree_cons
argument_list|(
name|size_int
argument_list|(
name|processing_template_decl
argument_list|)
argument_list|,
name|saved_parmlist
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parms
operator|,
name|nparms
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|next
operator|,
name|nparms
operator|++
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|saved_parmlist
argument_list|,
name|nparms
argument_list|)
operator|=
name|parm
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
operator|--
name|processing_template_parmlist
expr_stmt|;
return|return
name|saved_parmlist
return|;
block|}
end_function

begin_comment
comment|/* end_template_decl is called after a template declaration is seen.  */
end_comment

begin_function
name|void
name|end_template_decl
parameter_list|(
name|void
parameter_list|)
block|{
name|reset_specialization
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return;
comment|/* This matches the pushlevel in begin_template_parm_list.  */
name|finish_scope
argument_list|()
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
name|current_template_parms
operator|=
name|TREE_CHAIN
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a template argument vector containing the template PARMS.    The innermost PARMS are given first.  */
end_comment

begin_function
specifier|static
name|tree
name|current_template_args
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|header
decl_stmt|;
name|tree
name|args
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|length
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|current_template_parms
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|length
decl_stmt|;
comment|/* If there is only one level of template parameters, we do not      create a TREE_VEC of TREE_VECs.  Instead, we return a single      TREE_VEC containing the arguments.  */
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|args
operator|=
name|make_tree_vec
argument_list|(
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|current_template_parms
init|;
name|header
condition|;
name|header
operator|=
name|TREE_CHAIN
argument_list|(
name|header
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|copy_node
argument_list|(
name|TREE_VALUE
argument_list|(
name|header
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* T will be a list if we are called from within a 	     begin/end_template_parm_list pair, but a vector directly 	     if within a begin/end_member_template_processing pair.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|t
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|length
operator|>
literal|1
condition|)
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
operator|--
name|l
argument_list|)
operator|=
name|a
expr_stmt|;
else|else
name|args
operator|=
name|a
expr_stmt|;
block|}
return|return
name|args
return|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_DECL corresponding to DECL, using the indicated    template PARMS.  If MEMBER_TEMPLATE_P is true, the new template is    a member template.  Used by push_template_decl below.  */
end_comment

begin_function
specifier|static
name|tree
name|build_template_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|parms
parameter_list|,
name|bool
name|member_template_p
parameter_list|)
block|{
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|parms
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_MEMBER_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|member_template_p
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_CONSTRUCTOR_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_DESTRUCTOR_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_NONCONVERTING_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_NONCONVERTING_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|tmpl
argument_list|,
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmpl
return|;
block|}
end_function

begin_struct
struct|struct
name|template_parm_data
block|{
comment|/* The level of the template parameters we are currently      processing.  */
name|int
name|level
decl_stmt|;
comment|/* The index of the specialization argument we are currently      processing.  */
name|int
name|current_arg
decl_stmt|;
comment|/* An array whose size is the number of template parameters.  The      elements are nonzero if the parameter has been used in any one      of the arguments processed so far.  */
name|int
modifier|*
name|parms
decl_stmt|;
comment|/* An array whose size is the number of template arguments.  The      elements are nonzero if the argument makes use of template      parameters of this level.  */
name|int
modifier|*
name|arg_uses_template_parms
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Subroutine of push_template_decl used to see if each template    parameter in a partial specialization is used in the explicit    argument list.  If T is of the LEVEL given in DATA (which is    treated as a template_parm_data*), then DATA->PARMS is marked    appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|mark_template_parm
parameter_list|(
name|tree
name|t
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|level
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|template_parm_data
modifier|*
name|tpd
init|=
operator|(
expr|struct
name|template_parm_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
name|tpd
operator|->
name|level
condition|)
block|{
name|tpd
operator|->
name|parms
index|[
name|idx
index|]
operator|=
literal|1
expr_stmt|;
name|tpd
operator|->
name|arg_uses_template_parms
index|[
name|tpd
operator|->
name|current_arg
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Return zero so that for_each_template_parm will continue the      traversal of the tree; we want to mark *every* template parm.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process the partial specialization DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|process_partial_specialization
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|maintmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|specargs
init|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|inner_args
init|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|specargs
argument_list|)
decl_stmt|;
name|tree
name|inner_parms
init|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|current_template_parms
argument_list|)
decl_stmt|;
name|tree
name|main_inner_parms
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|maintmpl
argument_list|)
decl_stmt|;
name|int
name|nargs
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_args
argument_list|)
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|did_error_intro
init|=
literal|0
decl_stmt|;
name|struct
name|template_parm_data
name|tpd
decl_stmt|;
name|struct
name|template_parm_data
name|tpd2
decl_stmt|;
comment|/* We check that each of the template parameters given in the      partial specialization is used in the argument list to the      specialization.  For example:         template<class T> struct S;        template<class T> struct S<T*>;       The second declaration is OK because `T*' uses the template      parameter T, whereas         template<class T> struct S<int>;       is no good.  Even trickier is:         template<class T>        struct S1        { 	  template<class U> 	  struct S2; 	  template<class U> 	  struct S2<T>;        };       The S2<T> declaration is actually invalid; it is a      full-specialization.  Of course,  	  template<class U> 	  struct S2<T (*)(U)>;       or some such would have been OK.  */
name|tpd
operator|.
name|level
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|current_template_parms
argument_list|)
expr_stmt|;
name|tpd
operator|.
name|parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tpd
operator|.
name|parms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|ntparms
argument_list|)
expr_stmt|;
name|tpd
operator|.
name|arg_uses_template_parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tpd
operator|.
name|arg_uses_template_parms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|tpd
operator|.
name|current_arg
operator|=
name|i
expr_stmt|;
name|for_each_template_parm
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|mark_template_parm
argument_list|,
operator|&
name|tpd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|tpd
operator|.
name|parms
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
comment|/* One of the template parms was not used in the 	   specialization.  */
if|if
condition|(
operator|!
name|did_error_intro
condition|)
block|{
name|error
argument_list|(
literal|"template parameters not used in partial specialization:"
argument_list|)
expr_stmt|;
name|did_error_intro
operator|=
literal|1
expr_stmt|;
block|}
name|error
argument_list|(
literal|"        %qD"
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.class.spec]       The argument list of the specialization shall not be identical to      the implicit argument list of the primary template.  */
if|if
condition|(
name|comp_template_args
argument_list|(
name|inner_args
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"partial specialization %qT does not specialize any template arguments"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* [temp.class.spec]       A partially specialized non-type argument expression shall not      involve template parameters of the partial specialization except      when the argument expression is a simple identifier.       The type of a template parameter corresponding to a specialized      non-type argument shall not be dependent on a parameter of the      specialization.  */
name|gcc_assert
argument_list|(
name|nargs
operator|==
name|DECL_NTPARMS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
name|tpd2
operator|.
name|parms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
comment|/* These first two lines are the `non-type' bit.  */
operator|!
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_DECL
comment|/* This next line is the `argument expression is not just a 	     simple identifier' condition and also the `specialized 	     non-type argument' bit.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
block|{
if|if
condition|(
name|tpd
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"template argument %qE involves template parameter(s)"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Look at the corresponding template parameter, 		 marking which template parameters its type depends 		 upon.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|main_inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tpd2
operator|.
name|parms
condition|)
block|{
comment|/* We haven't yet initialized TPD2.  Do so now.  */
name|tpd2
operator|.
name|arg_uses_template_parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
comment|/* The number of parameters here is the number in the 		     main template, which, as checked in the assertion 		     above, is NARGS.  */
name|tpd2
operator|.
name|parms
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|tpd2
operator|.
name|level
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the template parameters.  But this time, we're 		 looking for the template parameters of the main 		 template, not in the specialization.  */
name|tpd2
operator|.
name|current_arg
operator|=
name|i
expr_stmt|;
name|tpd2
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|tpd2
operator|.
name|parms
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nargs
argument_list|)
expr_stmt|;
name|for_each_template_parm
argument_list|(
name|type
argument_list|,
operator|&
name|mark_template_parm
argument_list|,
operator|&
name|tpd2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpd2
operator|.
name|arg_uses_template_parms
index|[
name|i
index|]
condition|)
block|{
comment|/* The type depended on some template parameters. 		     If they are fully specialized in the 		     specialization, that's OK.  */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nargs
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|tpd2
operator|.
name|parms
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|tpd
operator|.
name|arg_uses_template_parms
index|[
name|j
index|]
condition|)
block|{
name|error
argument_list|(
literal|"type %qT of template argument %qE depends "
literal|"on template parameter(s)"
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|retrieve_specialization
argument_list|(
name|maintmpl
argument_list|,
name|specargs
argument_list|,
comment|/*class_specializations_p=*/
name|true
argument_list|)
condition|)
comment|/* We've already got this specialization.  */
return|return
name|decl
return|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|specargs
argument_list|,
name|inner_parms
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|maintmpl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Check that a template declaration's use of default arguments is not    invalid.  Here, PARMS are the template parameters.  IS_PRIMARY is    nonzero if DECL is the thing declared by a primary template.    IS_PARTIAL is nonzero if DECL is a partial specialization.  */
end_comment

begin_function
specifier|static
name|void
name|check_default_tmpl_args
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|parms
parameter_list|,
name|int
name|is_primary
parameter_list|,
name|int
name|is_partial
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|last_level_to_check
decl_stmt|;
name|tree
name|parm_level
decl_stmt|;
comment|/* [temp.param]       A default template-argument shall not be specified in a      function template declaration or a function template definition, nor      in the template-parameter-list of the definition of a member of a      class template.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* You can't have a function template declaration in a local        scope, nor you can you define a member of a class template in a        local scope.  */
return|return;
if|if
condition|(
name|current_class_type
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
comment|/* If this is either a friend defined in the scope of the class 	 or a member function.  */
operator|&&
operator|(
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
condition|?
name|same_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
else|:
name|DECL_FRIEND_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|?
name|same_type_p
argument_list|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
else|:
name|false
operator|)
comment|/* And, if it was a member function, it really was defined in 	 the scope of the class.  */
operator|&&
operator|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
comment|/* We already checked these parameters when the template was        declared, so there's no need to do it again now.  This function        was defined in class scope, but we're processing it's body now        that the class is complete.  */
return|return;
comment|/* [temp.param]       If a template-parameter has a default template-argument, all      subsequent template-parameters shall have a default      template-argument supplied.  */
for|for
control|(
name|parm_level
operator|=
name|parms
init|;
name|parm_level
condition|;
name|parm_level
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_level
argument_list|)
control|)
block|{
name|tree
name|inner_parms
init|=
name|TREE_VALUE
argument_list|(
name|parm_level
argument_list|)
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
decl_stmt|;
name|int
name|seen_def_arg_p
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|parm
init|=
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|parm
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
name|seen_def_arg_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|seen_def_arg_p
condition|)
block|{
name|error
argument_list|(
literal|"no default argument for %qD"
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For better subsequent error-recovery, we indicate that 		 there should have been a default argument.  */
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|is_partial
operator|||
operator|!
name|is_primary
condition|)
comment|/* For an ordinary class template, default template arguments are        allowed at the innermost level, e.g.: 	 template<class T = int> 	 struct S {};        but, in a partial specialization, they're not allowed even        there, as we have in [temp.class.spec]:  	 The template parameter list of a specialization shall not 	 contain default template argument values.         So, for a partial specialization, or for a function template,        we look at all of them.  */
empty_stmt|;
else|else
comment|/* But, for a primary class template that is not a partial        specialization we look at all template parameters except the        innermost ones.  */
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Figure out what error message to issue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|msg
operator|=
literal|"default template arguments may not be used in function templates"
expr_stmt|;
elseif|else
if|if
condition|(
name|is_partial
condition|)
name|msg
operator|=
literal|"default template arguments may not be used in partial specializations"
expr_stmt|;
else|else
name|msg
operator|=
literal|"default argument for template parameter for class enclosing %qD"
expr_stmt|;
if|if
condition|(
name|current_class_type
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* If we're inside a class definition, there's no need to        examine the parameters to the class itself.  On the one        hand, they will be checked when the class is defined, and,        on the other, default arguments are valid in things like: 	 template<class T = double> 	 struct S { template<class U> void f(U); };        Here the default argument for `S' has no bearing on the        declaration of `f'.  */
name|last_level_to_check
operator|=
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* Check everything.  */
name|last_level_to_check
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm_level
operator|=
name|parms
init|;
name|parm_level
operator|&&
name|TMPL_PARMS_DEPTH
argument_list|(
name|parm_level
argument_list|)
operator|>=
name|last_level_to_check
condition|;
name|parm_level
operator|=
name|TREE_CHAIN
argument_list|(
name|parm_level
argument_list|)
control|)
block|{
name|tree
name|inner_parms
init|=
name|TREE_VALUE
argument_list|(
name|parm_level
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
decl_stmt|;
name|ntparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|inner_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
condition|)
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear out the default argument so that we are not 	         confused later.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|inner_parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* At this point, if we're still interested in issuing messages, 	 they must apply to classes surrounding the object declared.  */
if|if
condition|(
name|msg
condition|)
name|msg
operator|=
literal|"default argument for template parameter for class enclosing %qD"
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Worker for push_template_decl_real, called via    for_each_template_parm.  DATA is really an int, indicating the    level of the parameters we are interested in.  If T is a template    parameter of that level, return nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|template_parm_this_level_p
parameter_list|(
name|tree
name|t
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|this_level
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|level
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|level
operator|==
name|this_level
return|;
block|}
end_function

begin_comment
comment|/* Creates a TEMPLATE_DECL for the indicated DECL using the template    parameters given by current_template_args, or reuses a    previously existing one, if appropriate.  Returns the DECL, or an    equivalent one, if it is replaced via a call to duplicate_decls.     If IS_FRIEND is true, DECL is a friend declaration.  */
end_comment

begin_function
name|tree
name|push_template_decl_real
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|is_friend
parameter_list|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|info
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|int
name|primary
decl_stmt|;
name|int
name|is_partial
decl_stmt|;
name|int
name|new_template_p
init|=
literal|0
decl_stmt|;
comment|/* True if the template is a member template, in the sense of      [temp.mem].  */
name|bool
name|member_template_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|decl
return|;
comment|/* See if this is a partial specialization.  */
name|is_partial
operator|=
operator|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FRIEND_P
argument_list|(
name|decl
argument_list|)
condition|)
name|is_friend
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|is_friend
condition|)
comment|/* For a friend, we want the context of the friend function, not        the type of which it is a friend.  */
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
comment|/* In the case of a virtual function, we want the class in which        it is defined.  */
name|ctx
operator|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* Otherwise, if we're currently defining some class, the DECL        is assumed to be a member of the class.  */
name|ctx
operator|=
name|current_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|&&
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|current_namespace
argument_list|)
expr_stmt|;
comment|/* See if this is a primary template.  */
if|if
condition|(
name|is_friend
operator|&&
name|ctx
condition|)
comment|/* A friend template that specifies a class context, i.e.          template<typename T> friend void A<T>::f();        is not primary.  */
name|primary
operator|=
literal|0
expr_stmt|;
else|else
name|primary
operator|=
name|template_parm_scope_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|primary
condition|)
block|{
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|member_template_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|ANON_AGGRNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"template class without a name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* [temp.mem]  		 A destructor shall not be a member template.  */
name|error
argument_list|(
literal|"destructor %qD declared as member template"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|NEW_DELETE_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|void_list_node
operator|||
operator|!
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|)
argument_list|)
argument_list|)
operator|==
name|void_list_node
operator|)
operator|)
condition|)
block|{
comment|/* [basic.stc.dynamic.allocation]  		 An allocation function can be a function 		 template. ... Template allocation functions shall 		 have two or more parameters.  */
name|error
argument_list|(
literal|"invalid template declaration of %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"template declaration of %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* Check to see that the rules regarding the use of default      arguments are not being violated.  */
name|check_default_tmpl_args
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|,
name|primary
argument_list|,
name|is_partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_partial
condition|)
return|return
name|process_partial_specialization
argument_list|(
name|decl
argument_list|)
return|;
name|args
operator|=
name|current_template_args
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|CLASS_TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
operator|)
operator|||
operator|(
name|is_friend
operator|&&
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If DECL is a TYPE_DECL for a class-template, then there won't 	 be DECL_LANG_SPECIFIC.  The information equivalent to 	 DECL_TEMPLATE_INFO is found in TYPE_TEMPLATE_INFO instead.  */
elseif|else
if|if
condition|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Since a template declaration already existed for this 	     class-type, we must be redeclaring it here.  Make sure 	     that the redeclaration is valid.  */
name|redeclare_class_template
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_template_parms
argument_list|)
expr_stmt|;
comment|/* We don't need to create a new TEMPLATE_DECL; just use the 	     one we already had.  */
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|,
name|member_template_p
argument_list|)
expr_stmt|;
name|new_template_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* A specialization of a member template of a template 		 class.  */
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|tree
name|a
decl_stmt|,
name|t
decl_stmt|,
name|current
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
operator|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"%qD does not declare a template type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"template definition of non-template %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_MEMBER_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|new_tmpl
decl_stmt|;
comment|/* The declaration is a specialization of a member 	     template, declared outside the class.  Therefore, the 	     innermost template arguments will be NULL, so we 	     replace them with the arguments determined by the 	     earlier call to check_explicit_specialization.  */
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|new_tmpl
operator|=
name|build_template_decl
argument_list|(
name|decl
argument_list|,
name|current_template_parms
argument_list|,
name|member_template_p
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
operator|=
name|new_tmpl
expr_stmt|;
name|SET_DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|new_tmpl
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_tmpl
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|new_tmpl
argument_list|,
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|args
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Make sure the template headers we got make sense.  */
name|parms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|i
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
operator|!=
name|i
condition|)
block|{
name|error
argument_list|(
literal|"expected %d levels of template parms for %q#D, got %d"
argument_list|,
name|i
argument_list|,
name|decl
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|current
operator|=
name|decl
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|a
operator|=
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|current
operator|==
name|decl
condition|)
name|error
argument_list|(
literal|"got %d template parameters for %q#D"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"got %d template parameters for %q#T"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|a
argument_list|)
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  but %d required"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Perhaps we should also check that the parms are used in the 	       appropriate qualifying scopes in the declarator?  */
if|if
condition|(
name|current
operator|==
name|decl
condition|)
name|current
operator|=
name|ctx
expr_stmt|;
else|else
name|current
operator|=
name|TYPE_CONTEXT
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Push template declarations for global functions and types.  Note      that we do not try to push a global template friend declared in a      template class; such a thing may well depend on the template      parameters of the class.  */
if|if
condition|(
name|new_template_p
operator|&&
operator|!
name|ctx
operator|&&
operator|!
operator|(
name|is_friend
operator|&&
name|template_class_depth
argument_list|(
name|current_class_type
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|tmpl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|tmpl
argument_list|,
name|is_friend
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Hide template friend classes that haven't been declared yet.  */
if|if
condition|(
name|is_friend
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|DECL_ANTICIPATED
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FRIEND_P
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|primary
condition|)
block|{
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|int
name|depth
init|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* It is a conversion operator. See if the type converted to 	     depends on innermost template operands.  */
if|if
condition|(
name|uses_template_parms_level
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|,
name|depth
argument_list|)
condition|)
name|DECL_TEMPLATE_CONV_FN_P
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* The DECL_TI_ARGS of DECL contains full set of arguments referring      back to its most general template.  If TMPL is a specialization,      ARGS may only have the innermost set of arguments.  Add the missing      argument levels if necessary.  */
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
condition|)
name|args
operator|=
name|add_outermost_template_args
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|info
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_IMPLICIT_TYPEDEF_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|SET_TYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ctx
operator|||
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
comment|/* Don't change the name if we've already set it up.  */
operator|&&
operator|!
name|IDENTIFIER_TEMPLATE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|classtype_mangled_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
name|info
expr_stmt|;
return|return
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|push_template_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|push_template_decl_real
argument_list|(
name|decl
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when a class template TYPE is redeclared with the indicated    template PARMS, e.g.:       template<class T> struct S;      template<class T> struct S {};  */
end_comment

begin_function
name|bool
name|redeclare_class_template
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|parms
parameter_list|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|tmpl_parms
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qT is not a template type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|tmpl
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
comment|/* The type is nested in some template class.  Nothing to worry        about here; there are no new template parameters for the nested        type.  */
return|return
name|true
return|;
if|if
condition|(
operator|!
name|parms
condition|)
block|{
name|error
argument_list|(
literal|"template specifiers not specified in declaration of %qD"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|parms
operator|=
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|tmpl_parms
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"previous declaration %q+D"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"used %d template parameter(s) instead of %d"
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|tmpl_parms
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tmpl_parm
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|tree
name|tmpl_default
decl_stmt|;
name|tree
name|parm_default
decl_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|tmpl_parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|tmpl_default
operator|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|parm_default
operator|=
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TMPL_PARM and PARM can be either TYPE_DECL, PARM_DECL, or 	 TEMPLATE_DECL.  */
if|if
condition|(
name|tmpl_parm
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tmpl_parm
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|tmpl_parm
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl_parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"template parameter %q+#D"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"redeclared here as %q#D"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|tmpl_default
operator|!=
name|NULL_TREE
operator|&&
name|parm_default
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* We have in [temp.param]:  	     A template-parameter may not be given default arguments 	     by two different declarations in the same scope.  */
name|error
argument_list|(
literal|"redefinition of default argument for %q#D"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%J  original definition appeared here"
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|parm_default
operator|!=
name|NULL_TREE
condition|)
comment|/* Update the previous template parameters (which are the ones 	   that will really count) with the new default value.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tmpl_parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|parm_default
expr_stmt|;
elseif|else
if|if
condition|(
name|tmpl_default
operator|!=
name|NULL_TREE
condition|)
comment|/* Update the new parameters, too; they'll be used as the 	   parameters for any members.  */
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
name|tmpl_default
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Simplify EXPR if it is a non-dependent expression.  Returns the    (possibly simplified) expression.  */
end_comment

begin_function
name|tree
name|fold_non_dependent_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
comment|/* If we're in a template, but EXPR isn't value dependent, simplify      it.  We're supposed to treat:         template<typename T> void f(T[1 + 1]);        template<typename T> void f(T[2]);       as two declarations of the same function, for example.  */
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
operator|&&
operator|!
name|value_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|saved_processing_template_decl
decl_stmt|;
name|saved_processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|expr
operator|=
name|tsubst_copy_and_build
argument_list|(
name|expr
argument_list|,
comment|/*args=*/
name|NULL_TREE
argument_list|,
name|tf_error
argument_list|,
comment|/*in_decl=*/
name|NULL_TREE
argument_list|,
comment|/*function_p=*/
name|false
argument_list|,
comment|/*integral_constant_expression_p=*/
name|true
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* EXPR is an expression which is used in a constant-expression context.    For instance, it could be a VAR_DECL with a constant initializer.    Extract the innest constant expression.     This is basically a more powerful version of    integral_constant_value, which can be used also in templates where    initializers can maintain a syntactic rather than semantic form    (even if they are non-dependent, for access-checking purposes).  */
end_comment

begin_function
specifier|static
name|tree
name|fold_decl_constant_value
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|const_expr
init|=
name|expr
decl_stmt|;
do|do
block|{
name|expr
operator|=
name|fold_non_dependent_expr
argument_list|(
name|const_expr
argument_list|)
expr_stmt|;
name|const_expr
operator|=
name|integral_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|expr
operator|!=
name|const_expr
condition|)
do|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of convert_nontype_argument. Converts EXPR to TYPE, which    must be a function or a pointer-to-function type, as specified    in [temp.arg.nontype]: disambiguate EXPR if it is an overload set,    and check that the resulting function has external linkage.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_nontype_argument_function
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|fns
init|=
name|expr
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|fn_no_ptr
decl_stmt|;
name|fn
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|fns
argument_list|,
name|tf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|fn_no_ptr
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn_no_ptr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|fn_no_ptr
operator|=
name|TREE_OPERAND
argument_list|(
name|fn_no_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn_no_ptr
argument_list|)
operator|==
name|BASELINK
condition|)
name|fn_no_ptr
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fn_no_ptr
argument_list|)
expr_stmt|;
comment|/* [temp.arg.nontype]/1       A template-argument for a non-type, non-template template-parameter      shall be one of:      [...]      -- the address of an object or function with external linkage.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|fn_no_ptr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because function %qD has not external linkage"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|,
name|fn_no_ptr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Attempt to convert the non-type template parameter EXPR to the    indicated TYPE.  If the conversion is successful, return the    converted value.  If the conversion is unsuccessful, return    NULL_TREE if we issued an error message, or error_mark_node if we    did not.  We issue error messages for out-and-out bad template    parameters, but not simply because the conversion failed, since we    might be just trying to do argument deduction.  Both TYPE and EXPR    must be non-dependent.     The conversion follows the special rules described in    [temp.arg.nontype], and it is much more strict than an implicit    conversion.     This function is called twice for each template argument (see    lookup_template_class for a more accurate description of this    problem). This means that we need to handle expressions which    are not valid in a C++ source, but can be created from the    first call (for instance, casts to perform conversions). These    hacks can go away after we fix the double coercion problem.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_nontype_argument
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|expr_type
decl_stmt|;
comment|/* Detect immediately string literals as invalid non-type argument.      This special-case is not needed for correctness (we would easily      catch this later), but only to provide better diagnostic for this      common user mistake. As suggested by DR 100, we do not mention      linkage issues in the diagnostic as this is not the point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because string literals can never be used in this context"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* If we are in a template, EXPR may be non-dependent, but still      have a syntactic, rather than semantic, form.  For example, EXPR      might be a SCOPE_REF, rather than the VAR_DECL to which the      SCOPE_REF refers.  Preserving the qualifying scope is necessary      so that access checking can be performed when the template is      instantiated -- but here we need the resolved form so that we can      convert the argument.  */
name|expr
operator|=
name|fold_non_dependent_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* HACK: Due to double coercion, we can get a      NOP_EXPR<REFERENCE_TYPE>(ADDR_EXPR<POINTER_TYPE> (arg)) here,      which is the tree that we built on the first call (see      below when coercing to reference to object or to reference to      function). We just strip everything and get to the arg.      See g++.old-deja/g++.oliva/template4.C and g++.dg/template/nontype9.C      for examples.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
if|if
condition|(
name|TYPE_REF_OBJ_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_REFFN_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* ??? Maybe we could use convert_from_reference here, but we 	     would need to relax its constraints because the NOP_EXPR 	     could actually change the type to something more cv-qualified, 	     and this is not folded by convert_from_reference.  */
name|tree
name|addr
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr_type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* We could also generate a NOP_EXPR(ADDR_EXPR()) when the 	 parameter is a pointer to object, through decay and 	 qualification conversion. Let's strip everything.  */
elseif|else
if|if
condition|(
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
argument_list|)
expr_stmt|;
comment|/* Skip the ADDR_EXPR only if it is part of the decay for 	     an array. Otherwise, it is part of the original argument 	     in the source code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* [temp.arg.nontype]/5, bullet 1       For a non-type template-parameter of integral or enumeration type,      integral promotions (_conv.prom_) and integral conversions      (_conv.integral_) are applied.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|expr_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|expr
operator|=
name|fold_decl_constant_value
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Notice that there are constant expressions like '4 % 0' which 	 do not fold into integer constants.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because it is a non-constant expression"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* At this point, an implicit conversion does what we want, 	 because we already know that the expression is of integral 	 type.  */
name|expr
operator|=
name|ocp_convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|CONV_IMPLICIT
argument_list|,
name|LOOKUP_PROTECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Conversion was allowed: fold it to a bare integer constant.  */
name|expr
operator|=
name|fold
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.arg.nontype]/5, bullet 2       For a non-type template-parameter of type pointer to object,      qualification conversions (_conv.qual_) and the array-to-pointer      conversion (_conv.array_) are applied.  */
elseif|else
if|if
condition|(
name|TYPE_PTROBV_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* [temp.arg.nontype]/1  (TC1 version, DR 49):  	 A template-argument for a non-type, non-template template-parameter 	 shall be one of: [...]  	 -- the name of a non-type template-parameter; 	 -- the address of an object or function with external linkage, [...] 	    expressed as "& id-expression" where the& is optional if the name 	    refers to a function or array, or if the corresponding 	    template-parameter is a reference.  	Here, we do not care about functions, as they are invalid anyway 	for a parameter of type pointer-to-object.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* Non-type template parameters are OK.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%qD is not a valid template argument "
literal|"because %qD is a variable, not the address of "
literal|"a variable"
argument_list|,
name|expr
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Other values, like integer constants, might be valid 	     non-type arguments of some other type.  */
return|return
name|error_mark_node
return|;
block|}
else|else
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
condition|?
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
else|:
name|expr
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument of type %qT "
literal|"because %qE is not a variable"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument of type %qT "
literal|"because %qD does not have external linkage"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|expr
operator|=
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* [temp.arg.nontype]/5, bullet 3       For a non-type template-parameter of type reference to object, no      conversions apply. The type referred to by the reference may be more      cv-qualified than the (otherwise identical) type of the      template-argument. The template-parameter is bound directly to the      template-argument, which must be an lvalue.  */
elseif|else
if|if
condition|(
name|TYPE_REF_OBJ_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr_type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|at_least_as_qualified_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because of conflicts in cv-qualification"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|real_lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because it is not an lvalue"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* [temp.arg.nontype]/1  	 A template-argument for a non-type, non-template template-parameter 	 shall be one of: [...]  	 -- the address of an object or function with external linkage.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL_LINKAGE_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because object %qD has not external linkage"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|expr
operator|=
name|build_nop
argument_list|(
name|type
argument_list|,
name|build_address
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.arg.nontype]/5, bullet 4       For a non-type template-parameter of type pointer to function, only      the function-to-pointer conversion (_conv.func_) is applied. If the      template-argument represents a set of overloaded functions (or a      pointer to such), the matching function is selected from the set      (_over.over_).  */
elseif|else
if|if
condition|(
name|TYPE_PTRFN_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* If the argument is a template-id, we might not have enough 	 context information to decay the pointer.  */
if|if
condition|(
operator|!
name|type_unknown_p
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
name|expr
operator|=
name|decay_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|expr
operator|=
name|convert_nontype_argument_function
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|expr
return|;
block|}
comment|/* [temp.arg.nontype]/5, bullet 5       For a non-type template-parameter of type reference to function, no      conversions apply. If the template-argument represents a set of      overloaded functions, the matching function is selected from the set      (_over.over_).  */
elseif|else
if|if
condition|(
name|TYPE_REFFN_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because it is a pointer"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"try using %qE instead"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|expr
operator|=
name|convert_nontype_argument_function
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr
operator|||
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|expr
return|;
name|expr
operator|=
name|build_nop
argument_list|(
name|type
argument_list|,
name|build_address
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.arg.nontype]/5, bullet 6       For a non-type template-parameter of type pointer to member function,      no conversions apply. If the template-argument represents a set of      overloaded member functions, the matching member function is selected      from the set (_over.over_).  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|expr
operator|=
name|instantiate_type
argument_list|(
name|type
argument_list|,
name|expr
argument_list|,
name|tf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* There is no way to disable standard conversions in 	 resolve_address_of_overloaded_function (called by 	 instantiate_type). It is possible that the call succeeded by 	 converting&B::I to&D::I (where B is a base of D), so we need 	 to reject this conversion here.  	 Actually, even if there was a way to disable standard conversions, 	 it would still be better to reject them here so that we can 	 provide a superior diagnostic.  */
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
block|{
comment|/* Make sure we are just one standard conversion off.  */
name|gcc_assert
argument_list|(
name|can_convert
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%qE is not a valid template argument for type %qT "
literal|"because it is of type %qT"
argument_list|,
name|expr
argument_list|,
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"standard conversions are not allowed in this context"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
comment|/* [temp.arg.nontype]/5, bullet 7       For a non-type template-parameter of type pointer to data member,      qualification conversions (_conv.qual_) are applied.  */
elseif|else
if|if
condition|(
name|TYPE_PTRMEM_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|expr
operator|=
name|perform_qualification_conversions
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|expr
return|;
block|}
comment|/* A template non-type parameter must be one of the above.  */
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* Sanity check: did we actually convert the argument to the      right type?  */
name|gcc_assert
argument_list|(
name|same_type_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARM_PARMS and ARG_PARMS matches using rule for    template template parameters.  Both PARM_PARMS and ARG_PARMS are    vectors of TREE_LIST nodes containing TYPE_DECL, TEMPLATE_DECL    or PARM_DECL.     Consider the example:      template<class T> class A;      template<template<class U> class TT> class B;     For B<A>, PARM_PARMS are the parameters to TT, while ARG_PARMS are    the parameters to A, and OUTER_ARGS contains A.  */
end_comment

begin_function
specifier|static
name|int
name|coerce_template_template_parms
parameter_list|(
name|tree
name|parm_parms
parameter_list|,
name|tree
name|arg_parms
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|,
name|tree
name|outer_args
parameter_list|)
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|arg_parms
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parm_parms
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|arg_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|!=
name|nparms
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|parm_parms
argument_list|,
name|i
argument_list|)
operator|==
name|error_mark_node
operator|||
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|i
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parm_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|arg_parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
operator|||
name|arg
operator|==
name|error_mark_node
operator|||
name|parm
operator|==
name|NULL_TREE
operator|||
name|parm
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
break|break;
case|case
name|TEMPLATE_DECL
case|:
comment|/* We encounter instantiations of templates like 	       template<template<template<class> class> class TT> 	       class C;  */
block|{
name|tree
name|parmparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|coerce_template_template_parms
argument_list|(
name|parmparm
argument_list|,
name|argparm
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
name|outer_args
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
comment|/* The tsubst call is used to handle cases such as  	       template<int> class C {}; 	       template<class T, template<T> class TT> class D {}; 	       D<int, C> d;  	     i.e. the parameter list of TT depends on earlier parameters.  */
if|if
condition|(
operator|!
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|&&
operator|!
name|same_type_p
argument_list|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|outer_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Convert the indicated template ARG as necessary to match the    indicated template PARM.  Returns the converted ARG, or    error_mark_node if the conversion was unsuccessful.  Error and    warning messages are issued under control of COMPLAIN.  This    conversion is for the Ith parameter in the parameter list.  ARGS is    the full set of template arguments deduced so far.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_template_argument
parameter_list|(
name|tree
name|parm
parameter_list|,
name|tree
name|arg
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|int
name|i
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
name|int
name|is_type
decl_stmt|,
name|requires_type
decl_stmt|,
name|is_tmpl_type
decl_stmt|,
name|requires_tmpl_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
comment|/* The template argument was the name of some 	 member function.  That's usually 	 invalid, but static members are OK.  In any 	 case, grab the underlying fields/functions 	 and issue an error later if required.  */
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|unknown_type_node
expr_stmt|;
block|}
name|requires_tmpl_type
operator|=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
expr_stmt|;
name|requires_type
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|requires_tmpl_type
operator|)
expr_stmt|;
name|is_tmpl_type
operator|=
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
operator|)
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
operator|)
condition|)
name|arg
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TYPE_P
argument_list|(
name|arg
argument_list|)
operator|||
name|is_tmpl_type
expr_stmt|;
if|if
condition|(
name|requires_type
operator|&&
operator|!
name|is_type
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|pedwarn
argument_list|(
literal|"to refer to a type member of a template parameter, "
literal|"use %<typename %E%>"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|make_typename_type
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|,
name|typename_type
argument_list|,
name|complain
operator|&
name|tf_error
argument_list|)
expr_stmt|;
name|is_type
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_type
operator|!=
name|requires_type
condition|)
block|{
if|if
condition|(
name|in_decl
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
name|error
argument_list|(
literal|"type/value mismatch at argument %d in template "
literal|"parameter list for %qD"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
name|error
argument_list|(
literal|"  expected a constant of type %qT, got %qT"
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
operator|(
name|is_tmpl_type
condition|?
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
else|:
name|arg
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|requires_tmpl_type
condition|)
name|error
argument_list|(
literal|"  expected a class template, got %qE"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"  expected a type, got %qE"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_tmpl_type
operator|^
name|requires_tmpl_type
condition|)
block|{
if|if
condition|(
name|in_decl
operator|&&
operator|(
name|complain
operator|&
name|tf_error
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"type/value mismatch at argument %d in template "
literal|"parameter list for %qD"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_tmpl_type
condition|)
name|error
argument_list|(
literal|"  expected a type, got %qT"
argument_list|,
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"  expected a class template, got %qT"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_type
condition|)
block|{
if|if
condition|(
name|requires_tmpl_type
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
condition|)
comment|/* The number of argument required is not known yet. 	       Just accept it for now.  */
name|val
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|parmparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argparm
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|coerce_template_template_parms
argument_list|(
name|parmparm
argument_list|,
name|argparm
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
name|args
argument_list|)
condition|)
block|{
name|val
operator|=
name|arg
expr_stmt|;
comment|/* TEMPLATE_TEMPLATE_PARM node is preferred over 		     TEMPLATE_DECL.  */
if|if
condition|(
name|val
operator|!=
name|error_mark_node
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in_decl
operator|&&
operator|(
name|complain
operator|&
name|tf_error
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"type/value mismatch at argument %d in "
literal|"template parameter list for %qD"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  expected a template of type %qD, got %qD"
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
else|else
name|val
operator|=
name|arg
expr_stmt|;
comment|/* We only form one instance of each template specialization. 	 Therefore, if we use a non-canonical variant (i.e., a 	 typedef), any future messages referring to the type will use 	 the typedef, which is confusing if those future uses do not 	 themselves also use the typedef.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|val
argument_list|)
condition|)
name|val
operator|=
name|canonical_type_variant
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|t
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|invalid_nontype_parm_type_p
argument_list|(
name|t
argument_list|,
name|complain
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|t
argument_list|)
condition|)
comment|/* We used to call digest_init here.  However, digest_init 	   will report errors, which we don't want when complain 	   is zero.  More importantly, digest_init will try too 	   hard to convert things: for example, `0' should not be 	   converted to pointer type at this point according to 	   the standard.  Accepting this is not merely an 	   extension, since deciding whether or not these 	   conversions can occur is part of determining which 	   function template to call, or whether a given explicit 	   argument specification is valid.  */
name|val
operator|=
name|convert_nontype_argument
argument_list|(
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
condition|)
name|val
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
name|error_mark_node
operator|&&
operator|(
name|complain
operator|&
name|tf_error
operator|)
condition|)
name|error
argument_list|(
literal|"could not convert template argument %qE to %qT"
argument_list|,
name|arg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Convert all template arguments to their appropriate types, and    return a vector containing the innermost resulting template    arguments.  If any error occurs, return error_mark_node. Error and    warning messages are issued under control of COMPLAIN.     If REQUIRE_ALL_ARGS is false, argument deduction will be performed    for arguments not specified in ARGS.  Otherwise, if    USE_DEFAULT_ARGS is true, default arguments will be used to fill in    unspecified arguments.  If REQUIRE_ALL_ARGS is true, but    USE_DEFAULT_ARGS is false, then all arguments must be specified in    ARGS.  */
end_comment

begin_function
specifier|static
name|tree
name|coerce_template_parms
parameter_list|(
name|tree
name|parms
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|in_decl
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|bool
name|require_all_args
parameter_list|,
name|bool
name|use_default_args
parameter_list|)
block|{
name|int
name|nparms
decl_stmt|,
name|nargs
decl_stmt|,
name|i
decl_stmt|,
name|lost
init|=
literal|0
decl_stmt|;
name|tree
name|inner_args
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|tree
name|new_inner_args
decl_stmt|;
name|bool
name|saved_skip_evaluation
decl_stmt|;
name|inner_args
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|inner_args
condition|?
name|NUM_TMPL_ARGS
argument_list|(
name|inner_args
argument_list|)
else|:
literal|0
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|>
name|nparms
operator|||
operator|(
name|nargs
operator|<
name|nparms
operator|&&
name|require_all_args
operator|&&
operator|(
operator|!
name|use_default_args
operator|||
operator|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|nargs
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|TREE_PURPOSE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|nargs
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of template arguments (%d, should be %d)"
argument_list|,
name|nargs
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|error
argument_list|(
literal|"provided for %q+D"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* We need to evaluate the template arguments, even though this      template-id may be nested within a "sizeof".  */
name|saved_skip_evaluation
operator|=
name|skip_evaluation
expr_stmt|;
name|skip_evaluation
operator|=
name|false
expr_stmt|;
name|new_inner_args
operator|=
name|make_tree_vec
argument_list|(
name|nparms
argument_list|)
expr_stmt|;
name|new_args
operator|=
name|add_outermost_template_args
argument_list|(
name|args
argument_list|,
name|new_inner_args
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* Get the Ith template parameter.  */
name|parm
operator|=
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|==
name|error_mark_node
condition|)
block|{
name|TREE_VEC_ELT
argument_list|(
name|new_inner_args
argument_list|,
name|i
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
comment|/* Calculate the Ith argument.  */
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|inner_args
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|require_all_args
condition|)
comment|/* There must be a default arg in this case.  */
name|arg
operator|=
name|tsubst_template_arg
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
break|break;
name|gcc_assert
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"template argument %d is invalid"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|convert_template_argument
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|new_args
argument_list|,
name|complain
argument_list|,
name|i
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
name|lost
operator|++
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_inner_args
argument_list|,
name|i
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
name|skip_evaluation
operator|=
name|saved_skip_evaluation
expr_stmt|;
if|if
condition|(
name|lost
condition|)
return|return
name|error_mark_node
return|;
return|return
name|new_inner_args
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if template args OT and NT are equivalent.  */
end_comment

begin_function
specifier|static
name|int
name|template_args_equal
parameter_list|(
name|tree
name|ot
parameter_list|,
name|tree
name|nt
parameter_list|)
block|{
if|if
condition|(
name|nt
operator|==
name|ot
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|nt
argument_list|)
operator|==
name|TREE_VEC
condition|)
comment|/* For member templates */
return|return
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|comp_template_args
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|nt
argument_list|)
condition|)
return|return
name|TYPE_P
argument_list|(
name|ot
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ot
argument_list|)
operator|==
name|TREE_VEC
operator|||
name|TYPE_P
argument_list|(
name|ot
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|cp_tree_equal
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets    of template arguments.  Returns 0 otherwise.  */
end_comment

begin_function
name|int
name|comp_template_args
parameter_list|(
name|tree
name|oldargs
parameter_list|,
name|tree
name|newargs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|newargs
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|oldargs
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|nt
init|=
name|TREE_VEC_ELT
argument_list|(
name|newargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|ot
init|=
name|TREE_VEC_ELT
argument_list|(
name|oldargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|template_args_equal
argument_list|(
name|ot
argument_list|,
name|nt
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given class template name and parameter list, produce a user-friendly name    for the instantiation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mangle_class_name_for_template
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|parms
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
specifier|static
name|struct
name|obstack
name|scratch_obstack
decl_stmt|;
specifier|static
name|char
modifier|*
name|scratch_firstobj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparms
decl_stmt|;
if|if
condition|(
operator|!
name|scratch_firstobj
condition|)
name|gcc_obstack_init
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
expr_stmt|;
else|else
name|obstack_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|scratch_firstobj
argument_list|)
expr_stmt|;
name|scratch_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
define|#
directive|define
name|ccat
parameter_list|(
name|C
parameter_list|)
value|obstack_1grow (&scratch_obstack, (C));
define|#
directive|define
name|cat
parameter_list|(
name|S
parameter_list|)
value|obstack_grow (&scratch_obstack, (S), strlen (S))
name|cat
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
name|nparms
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|nparms
operator|==
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparms
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|parms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VEC_ELT
argument_list|(
name|arglist
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|i
condition|)
name|ccat
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|cat
argument_list|(
name|type_as_string
argument_list|(
name|arg
argument_list|,
name|TFF_CHASE_TYPEDEF
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* Already substituted with real template.  Just output 		 the template name here */
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
condition|)
block|{
comment|/* The template may be defined in a namespace, or 		     may be a member template.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|CLASS_TYPE_P
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|decl_as_string
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
name|cat
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
block|}
name|cat
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output the parameter declaration.  */
name|cat
argument_list|(
name|type_as_string
argument_list|(
name|arg
argument_list|,
name|TFF_CHASE_TYPEDEF
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
argument_list|)
expr_stmt|;
comment|/* No need to check arglist against parmlist here; we did that 	 in coerce_template_parms, called from lookup_template_class.  */
name|cat
argument_list|(
name|expr_as_string
argument_list|(
name|arg
argument_list|,
name|TFF_PLAIN_IDENTIFIER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|bufp
init|=
name|obstack_next_free
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|offset
operator|--
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|scratch_obstack
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* B<C<char>>, not B<C<char>> */
if|if
condition|(
name|bufp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|ccat
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|ccat
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|ccat
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|scratch_obstack
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|classtype_mangled_name
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
comment|/* Specializations have already had their names set up in 	 lookup_template_class.  */
operator|&&
operator|!
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|tmpl
init|=
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* For non-primary templates, the template parameters are 	 implicit from their surrounding context.  */
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|mangled_name
init|=
name|mangle_class_name_for_template
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|mangled_name
argument_list|)
decl_stmt|;
name|IDENTIFIER_TEMPLATE
argument_list|(
name|id
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|id
return|;
block|}
block|}
return|return
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pending_template
parameter_list|(
name|tree
name|d
parameter_list|)
block|{
name|tree
name|ti
init|=
operator|(
name|TYPE_P
argument_list|(
name|d
argument_list|)
condition|?
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
else|:
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
operator|)
decl_stmt|;
name|tree
name|pt
decl_stmt|;
name|int
name|level
decl_stmt|;
if|if
condition|(
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
condition|)
return|return;
comment|/* We are called both from instantiate_decl, where we've already had a      tinst_level pushed, and instantiate_template, where we haven't.      Compensate.  */
name|level
operator|=
operator|!
operator|(
name|current_tinst_level
operator|&&
name|TINST_DECL
argument_list|(
name|current_tinst_level
argument_list|)
operator|==
name|d
operator|)
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|push_tinst_level
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|pt
operator|=
name|tree_cons
argument_list|(
name|current_tinst_level
argument_list|,
name|d
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_pending_template
condition|)
name|TREE_CHAIN
argument_list|(
name|last_pending_template
argument_list|)
operator|=
name|pt
expr_stmt|;
else|else
name|pending_templates
operator|=
name|pt
expr_stmt|;
name|last_pending_template
operator|=
name|pt
expr_stmt|;
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|ti
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|pop_tinst_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a TEMPLATE_ID_EXPR corresponding to the indicated FNS and    ARGLIST.  Valid choices for FNS are given in the cp-tree.def    documentation for TEMPLATE_ID_EXPR.  */
end_comment

begin_function
name|tree
name|lookup_template_function
parameter_list|(
name|tree
name|fns
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|fns
operator|==
name|error_mark_node
operator|||
name|arglist
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
operator|!
name|arglist
operator|||
name|TREE_CODE
argument_list|(
name|arglist
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|fns
operator|&&
operator|(
name|is_overloaded_fn
argument_list|(
name|fns
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
block|{
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
operator|=
name|build2
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|unknown_type_node
argument_list|,
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
return|return
name|fns
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fns
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|OVERLOAD
operator|||
operator|!
name|type
condition|)
name|type
operator|=
name|unknown_type_node
expr_stmt|;
return|return
name|build2
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|type
argument_list|,
name|fns
argument_list|,
name|arglist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Within the scope of a template class S<T>, the name S gets bound    (in build_self_reference) to a TYPE_DECL for the class, not a    TEMPLATE_DECL.  If DECL is a TYPE_DECL for current_class_type,    or one of its enclosing classes, and that type is a template,    return the associated TEMPLATE_DECL.  Otherwise, the original    DECL is returned.  */
end_comment

begin_function
name|tree
name|maybe_get_template_decl_from_type_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|?
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
else|:
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of    parameters, find the desired type.     D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.     IN_DECL, if non-NULL, is the template declaration we are trying to    instantiate.     If ENTERING_SCOPE is nonzero, we are about to enter the scope of    the class we are looking up.     Issue error and warning messages under control of COMPLAIN.     If the template class is really a local class in a template    function, then the FUNCTION_CONTEXT is the function in which it is    being instantiated.     ??? Note that this function is currently called *twice* for each    template-id: the first time from the parser, while creating the    incomplete type (finish_template_type), and the second type during the    real instantiation (instantiate_template_class). This is surely something    that we want to avoid. It also causes some problems with argument    coercion (see convert_nontype_argument for more information on this).  */
end_comment

begin_function
name|tree
name|lookup_template_class
parameter_list|(
name|tree
name|d1
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|tree
name|in_decl
parameter_list|,
name|tree
name|context
parameter_list|,
name|int
name|entering_scope
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|tree
name|template
init|=
name|NULL_TREE
decl_stmt|,
name|parmlist
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|value
init|=
name|innermost_non_namespace_value
argument_list|(
name|d1
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|&&
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|value
argument_list|)
condition|)
name|template
operator|=
name|value
expr_stmt|;
else|else
block|{
if|if
condition|(
name|context
condition|)
name|push_decl_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|template
operator|=
name|lookup_name
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|template
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|pop_decl_namespace
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|template
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|d1
argument_list|)
decl_stmt|;
comment|/* If we are declaring a constructor, say A<T>::A<T>, we will get 	 an implicit typename for the second A.  Deal with it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|template
operator|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
operator|(
name|TYPE_P
argument_list|(
name|d1
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|d1
argument_list|)
operator|)
condition|)
block|{
name|template
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d1
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|d1
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|template
operator|=
name|d1
expr_stmt|;
name|d1
operator|=
name|DECL_NAME
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
expr_stmt|;
block|}
comment|/* Issue an error message if we didn't find a template.  */
if|if
condition|(
operator|!
name|template
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"%qT is not a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|!=
name|TEMPLATE_DECL
comment|/* Make sure it's a user visible template, if it was named by 	    the user.  */
operator|||
operator|(
operator|(
name|complain
operator|&
name|tf_user
operator|)
operator|&&
operator|!
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
operator|&&
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
name|error
argument_list|(
literal|"non-template type %qT used as a template"
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|error
argument_list|(
literal|"for template declaration %q+D"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
name|complain
operator|&=
operator|~
name|tf_user
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
comment|/* Create a new TEMPLATE_DECL and TEMPLATE_TEMPLATE_PARM node to store 	 template arguments */
name|tree
name|parm
decl_stmt|;
name|tree
name|arglist2
decl_stmt|;
name|parmlist
operator|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
expr_stmt|;
comment|/* Consider an example where a template template parameter declared as  	   template<class T, class U = std::allocator<T>> class TT  	 The template parameter level of T and U are one level larger than 	 of TT.  To proper process the default argument of U, say when an 	 instantiation `TT<int>' is seen, we need to build the full 	 arguments containing {int} as the innermost level.  Outer levels, 	 available when not appearing as default template argument, can be 	 obtained from `current_template_args ()'.  	 Suppose that TT is later substituted with std::vector.  The above 	 instantiation is `TT<int, std::allocator<T>>' with TT at 	 level 1, and T at level 2, while the template arguments at level 1 	 becomes {std::vector} and the inner level 2 is {int}.  */
if|if
condition|(
name|current_template_parms
condition|)
name|arglist
operator|=
name|add_to_template_args
argument_list|(
name|current_template_args
argument_list|()
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arglist2
operator|=
name|coerce_template_parms
argument_list|(
name|parmlist
argument_list|,
name|arglist
argument_list|,
name|template
argument_list|,
name|complain
argument_list|,
comment|/*require_all_args=*/
name|true
argument_list|,
comment|/*use_default_args=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist2
operator|==
name|error_mark_node
operator|||
operator|(
operator|!
name|uses_template_parms
argument_list|(
name|arglist2
argument_list|)
operator|&&
name|check_instantiated_args
argument_list|(
name|template
argument_list|,
name|arglist2
argument_list|,
name|complain
argument_list|)
operator|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|parm
operator|=
name|bind_template_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|,
name|arglist2
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|template_type
init|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|type_decl
decl_stmt|;
name|tree
name|found
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|arg_depth
decl_stmt|;
name|int
name|parm_depth
decl_stmt|;
name|int
name|is_partial_instantiation
decl_stmt|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|gen_tmpl
argument_list|)
expr_stmt|;
name|parm_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|parmlist
argument_list|)
expr_stmt|;
name|arg_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_depth
operator|==
literal|1
operator|&&
name|parm_depth
operator|>
literal|1
condition|)
block|{
comment|/* We've been given an incomplete set of template arguments. 	     For example, given:  	       template<class T> struct S1 { 		 template<class U> struct S2 {}; 		 template<class U> struct S2<U*> {}; 		};  	     we will be called with an ARGLIST of `U*', but the 	     TEMPLATE will be `template<class T> template<class U> struct S1<T>::S2'.  We must fill in the missing 	     arguments.  */
name|arglist
operator|=
name|add_outermost_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|arg_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
comment|/* Now we should have enough arguments.  */
name|gcc_assert
argument_list|(
name|parm_depth
operator|==
name|arg_depth
argument_list|)
expr_stmt|;
comment|/* From here on, we're only interested in the most general 	 template.  */
name|template
operator|=
name|gen_tmpl
expr_stmt|;
comment|/* Calculate the BOUND_ARGS.  These will be the args that are 	 actually tsubst'd into the definition to create the 	 instantiation.  */
if|if
condition|(
name|parm_depth
operator|>
literal|1
condition|)
block|{
comment|/* We have multiple levels of arguments to coerce, at once.  */
name|int
name|i
decl_stmt|;
name|int
name|saved_depth
init|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|bound_args
init|=
name|make_tree_vec
argument_list|(
name|parm_depth
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|saved_depth
operator|,
name|t
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|template
argument_list|)
init|;
name|i
operator|>
literal|0
operator|&&
name|t
operator|!=
name|NULL_TREE
condition|;
operator|--
name|i
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|a
init|=
name|coerce_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|template
argument_list|,
name|complain
argument_list|,
comment|/*require_all_args=*/
name|true
argument_list|,
comment|/*use_default_args=*/
name|true
argument_list|)
decl_stmt|;
comment|/* Don't process further if one of the levels fails.  */
if|if
condition|(
name|a
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Restore the ARGLIST to its full size.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|=
name|saved_depth
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
block|}
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|bound_args
argument_list|,
name|i
argument_list|,
name|a
argument_list|)
expr_stmt|;
comment|/* We temporarily reduce the length of the ARGLIST so 		 that coerce_template_parms will see only the arguments 		 corresponding to the template parameters it is 		 examining.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
block|}
comment|/* Restore the ARGLIST to its full size.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|=
name|saved_depth
expr_stmt|;
name|arglist
operator|=
name|bound_args
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|coerce_template_parms
argument_list|(
name|INNERMOST_TEMPLATE_PARMS
argument_list|(
name|parmlist
argument_list|)
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|template
argument_list|,
name|complain
argument_list|,
comment|/*require_all_args=*/
name|true
argument_list|,
comment|/*use_default_args=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|==
name|error_mark_node
condition|)
comment|/* We were unable to bind the arguments.  */
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
comment|/* In the scope of a template class, explicit references to the 	 template class refer to the type of the template, not any 	 instantiation of it.  For example, in:  	   template<class T> class C { void f(C<T>); }  	 the `C<T>' is just the same as `C'.  Outside of the 	 class, however, such a reference is an instantiation.  */
if|if
condition|(
name|comp_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|template_type
argument_list|)
argument_list|,
name|arglist
argument_list|)
condition|)
block|{
name|found
operator|=
name|template_type
expr_stmt|;
if|if
condition|(
operator|!
name|entering_scope
operator|&&
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
block|{
name|tree
name|ctx
decl_stmt|;
for|for
control|(
name|ctx
operator|=
name|current_class_type
init|;
name|ctx
operator|&&
name|TREE_CODE
argument_list|(
name|ctx
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|;
name|ctx
operator|=
operator|(
name|TYPE_P
argument_list|(
name|ctx
argument_list|)
condition|?
name|TYPE_CONTEXT
argument_list|(
name|ctx
argument_list|)
else|:
name|DECL_CONTEXT
argument_list|(
name|ctx
argument_list|)
operator|)
control|)
if|if
condition|(
name|TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|ctx
argument_list|,
name|template_type
argument_list|)
condition|)
goto|goto
name|found_ctx
goto|;
comment|/* We're not in the scope of the class, so the 		 TEMPLATE_TYPE is not the type we want after all.  */
name|found
operator|=
name|NULL_TREE
expr_stmt|;
name|found_ctx
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|found
argument_list|)
expr_stmt|;
comment|/* If we already have this specialization, return it.  */
name|found
operator|=
name|retrieve_specialization
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|found
argument_list|)
expr_stmt|;
comment|/* This type is a "partial instantiation" if any of the template 	 arguments still involve template parameters.  Note that we set 	 IS_PARTIAL_INSTANTIATION for partial specializations as 	 well.  */
name|is_partial_instantiation
operator|=
name|uses_template_parms
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
comment|/* If the deduced arguments are invalid, then the binding 	 failed.  */
if|if
condition|(
operator|!
name|is_partial_instantiation
operator|&&
name|check_instantiated_args
argument_list|(
name|template
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|complain
argument_list|)
condition|)
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_partial_instantiation
operator|&&
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|template
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|found
operator|=
name|xref_tag_from_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|template
argument_list|)
argument_list|,
comment|/*tag_scope=*/
name|ts_global
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|template
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|context
operator|=
name|global_namespace
expr_stmt|;
comment|/* Create the type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
operator|!
name|is_partial_instantiation
condition|)
block|{
name|set_current_access_from_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|start_enum
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We don't want to call start_enum for this type, since 	       the values for the enumeration constants may involve 	       template parameters.  And, no one should be interested 	       in the enumeration constants for such a type.  */
name|t
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TREE_CODE
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|t
argument_list|)
operator|=
name|CLASSTYPE_DECLARED_CLASS
argument_list|(
name|template_type
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_IMPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_FOR_JAVA
argument_list|(
name|template_type
argument_list|)
expr_stmt|;
comment|/* A local class.  Make sure the decl gets registered properly.  */
if|if
condition|(
name|context
operator|==
name|current_function_decl
condition|)
name|pushtag
argument_list|(
name|DECL_NAME
argument_list|(
name|template
argument_list|)
argument_list|,
name|t
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|)
expr_stmt|;
block|}
comment|/* If we called start_enum or pushtag above, this information 	 will already be set up.  */
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|=
name|FROB_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|create_implicit_typedef
argument_list|(
name|DECL_NAME
argument_list|(
name|template
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|type_decl
argument_list|)
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|type_decl
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_PRIVATE
argument_list|(
name|type_decl
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|type_decl
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|template_type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|type_decl
argument_list|)
operator|=
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VISIBILITY_SPECIFIED
argument_list|(
name|template_type
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|type_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|type_decl
argument_list|)
operator|=
name|CLASSTYPE_VISIBILITY
argument_list|(
name|template_type
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the template information.  We have to figure out which 	 template is the immediate parent if this is a full 	 instantiation.  */
if|if
condition|(
name|parm_depth
operator|==
literal|1
operator|||
name|is_partial_instantiation
operator|||
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
comment|/* This case is easy; there are no member templates involved.  */
name|found
operator|=
name|template
expr_stmt|;
else|else
block|{
comment|/* This is a full instantiation of a member template.  Look 	     for a partial instantiation of which this is an instance.  */
for|for
control|(
name|found
operator|=
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
init|;
name|found
condition|;
name|found
operator|=
name|TREE_CHAIN
argument_list|(
name|found
argument_list|)
control|)
block|{
name|int
name|success
decl_stmt|;
name|tree
name|tmpl
init|=
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We only want partial instantiations, here, not 		 specializations or full instantiations.  */
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|||
operator|!
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|found
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Temporarily reduce by one the number of levels in the 		 ARGLIST and in FOUND so as to avoid comparing the 		 last set of arguments.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|--
expr_stmt|;
comment|/* See if the arguments match.  If they do, then TMPL is 		 the partial instantiation we want.  */
name|success
operator|=
name|comp_template_args
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Restore the argument vectors to their full size.  */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|++
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|found
operator|=
name|tmpl
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* There was no partial instantiation. This happens 		 where C<T> is a member template of A<T> and it's used 		 in something like  		  template<typename T> struct B { A<T>::C<int> m; }; 		  B<float>;  		 Create the partial instantiation. 	       */
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|--
expr_stmt|;
name|found
operator|=
name|tsubst
argument_list|(
name|template
argument_list|,
name|arglist
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|arglist
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
name|SET_TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|,
name|tree_cons
argument_list|(
name|found
argument_list|,
name|arglist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|arglist
argument_list|,
name|t
argument_list|,
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|!
name|is_partial_instantiation
condition|)
comment|/* Now that the type has been registered on the instantiations 	   list, we set up the enumerators.  Because the enumeration 	   constants may involve the enumeration type itself, we make 	   sure to register the type first, and then create the 	   constants.  That way, doing tsubst_expr for the enumeration 	   constants won't result in recursive calls here; we'll find 	   the instantiation and exit above.  */
name|tsubst_enum
argument_list|(
name|template_type
argument_list|,
name|t
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Reset the name of the type, now that CLASSTYPE_TEMPLATE_INFO 	 is set up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|DECL_NAME
argument_list|(
name|type_decl
argument_list|)
operator|=
name|classtype_mangled_name
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_partial_instantiation
condition|)
comment|/* If the type makes use of template parameters, the 	   code that generates debugging information will crash.  */
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Possibly limit visibility based on template args.  */
name|TREE_PUBLIC
argument_list|(
name|type_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|determine_visibility
argument_list|(
name|type_decl
argument_list|)
expr_stmt|;
name|POP_TIMEVAR_AND_RETURN
argument_list|(
name|TV_NAME_LOOKUP
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|timevar_pop
argument_list|(
name|TV_NAME_LOOKUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|pair_fn_data
block|{
name|tree_fn_t
name|fn
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|struct
name|pointer_set_t
modifier|*
name|visited
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Called from for_each_template_parm via walk_tree.  */
end_comment

begin_function
specifier|static
name|tree
name|for_each_template_parm_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|struct
name|pair_fn_data
modifier|*
name|pfd
init|=
operator|(
expr|struct
name|pair_fn_data
operator|*
operator|)
name|d
decl_stmt|;
name|tree_fn_t
name|fn
init|=
name|pfd
operator|->
name|fn
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|pfd
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
operator|!
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|METHOD_TYPE
case|:
comment|/* Since we're not going to walk subtrees, we have to do this 	 explicitly here.  */
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Fall through.  */
case|case
name|FUNCTION_TYPE
case|:
comment|/* Check the return type.  */
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Check the parameter types.  Since default arguments are not 	 instantiated until they are needed, the TYPE_ARG_TYPES may 	 contain expressions that involve template parameters.  But, 	 no-one should be looking at them yet.  And, once they're 	 instantiated, they don't contain template parameters, so 	 there's no point in looking at them then, either.  */
block|{
name|tree
name|parm
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Since we've already handled the TYPE_ARG_TYPES, we don't 	   want walk_tree walking into them itself.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|TYPEOF_TYPE
case|:
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|FUNCTION_DECL
case|:
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Fall through.  */
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
comment|/* Record template parameters such as `T' inside `TT<T>'.  */
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Fall through.  */
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
if|if
condition|(
name|fn
operator|&&
call|(
modifier|*
name|fn
call|)
argument_list|(
name|t
argument_list|,
name|data
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|TEMPLATE_DECL
case|:
comment|/* A template template parameter is encountered.  */
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Already substituted template template parameter */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TYPENAME_TYPE
case|:
if|if
condition|(
operator|!
name|fn
operator|||
name|for_each_template_parm
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|for_each_template_parm
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|INDIRECT_REF
case|:
case|case
name|COMPONENT_REF
case|:
comment|/* If there's no type, then this thing must be some expression 	 involving template parameters.  */
if|if
condition|(
operator|!
name|fn
operator|&&
operator|!
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|MODOP_EXPR
case|:
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
case|case
name|PSEUDO_DTOR_EXPR
case|:
if|if
condition|(
operator|!
name|fn
condition|)
return|return
name|error_mark_node
return|;
break|break;
case|case
name|BASELINK
case|:
comment|/* If we do not handle this case specially, we end up walking 	 the BINFO hierarchy, which is circular, and therefore 	 confuses walk_tree.  */
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|for_each_template_parm
argument_list|(
name|BASELINK_FUNCTIONS
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|fn
argument_list|,
name|data
argument_list|,
name|pfd
operator|->
name|visited
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
break|break;
default|default:
break|break;
block|}
comment|/* We didn't find any template parameters we liked.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* For each TEMPLATE_TYPE_PARM, TEMPLATE_TEMPLATE_PARM,    BOUND_TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX in T,    call FN with the parameter and the DATA.    If FN returns nonzero, the iteration is terminated, and    for_each_template_parm returns 1.  Otherwise, the iteration    continues.  If FN never returns a nonzero value, the value    returned by for_each_template_parm is 0.  If FN is NULL, it is    considered to be the function which always returns 1.  */
end_comment

begin_function
specifier|static
name|int
name|for_each_template_parm
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|pointer_set_t
modifier|*
name|visited
parameter_list|)
block|{
name|struct
name|pair_fn_data
name|pfd
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* Set up.  */
name|pfd
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|pfd
operator|.
name|data
operator|=
name|data
expr_stmt|;
comment|/* Walk the tree.  (Conceptually, we would like to walk without      duplicates, but for_each_template_parm_r recursively calls      for_each_template_parm, so we would need to reorganize a fair      bit to use walk_tree_without_duplicates, so we keep our own      visited list.)  */
if|if
condition|(
name|visited
condition|)
name|pfd
operator|.
name|visited
operator|=
name|visited
expr_stmt|;
else|else
name|pfd
operator|.
name|visited
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
name|result
operator|=
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|for_each_template_parm_r
argument_list|,
operator|&
name|pfd
argument_list|,
name|pfd
operator|.
name|visited
argument_list|)
operator|!=
name|NULL_TREE
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
operator|!
name|visited
condition|)
block|{
name|pointer_set_destroy
argument_list|(
name|pfd
operator|.
name|visited
argument_list|)
expr_stmt|;
name|pfd
operator|.
name|visited
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns true if T depends on any template parameter.  */
end_comment

begin_function
name|int
name|uses_template_parms
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|bool
name|dependent_p
decl_stmt|;
name|int
name|saved_processing_template_decl
decl_stmt|;
name|saved_processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
if|if
condition|(
operator|!
name|saved_processing_template_decl
condition|)
name|processing_template_decl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|dependent_p
operator|=
name|any_dependent_template_arguments_p
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|dependent_p
operator|=
operator|(
name|uses_template_parms
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|uses_template_parms
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|||
name|EXPR_P
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BASELINK
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|CONSTANT_CLASS_P
argument_list|(
name|t
argument_list|)
condition|)
name|dependent_p
operator|=
operator|(
name|type_dependent_expression_p
argument_list|(
name|t
argument_list|)
operator|||
name|value_dependent_expression_p
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|t
operator|==
name|error_mark_node
argument_list|)
expr_stmt|;
name|dependent_p
operator|=
name|false
expr_stmt|;
block|}
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
return|return
name|dependent_p
return|;
block|}
end_function

begin_comment
comment|/* Returns true if T depends on any template parameter with level LEVEL.  */
end_comment

begin_function
name|int
name|uses_template_parms_level
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|level
parameter_list|)
block|{
return|return
name|for_each_template_parm
argument_list|(
name|t
argument_list|,
name|template_parm_this_level_p
argument_list|,
operator|&
name|level
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|tinst_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|max_tinst_depth
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|depth_reached
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|tinst_level_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_template_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're starting to instantiate D; record the template instantiation context    for diagnostics and to restore it later.  */
end_comment

begin_function
specifier|static
name|int
name|push_tinst_level
parameter_list|(
name|tree
name|d
parameter_list|)
block|{
name|tree
name|new
decl_stmt|;
if|if
condition|(
name|tinst_depth
operator|>=
name|max_tinst_depth
condition|)
block|{
comment|/* If the instantiation in question still has unbound template parms, 	 we don't really care if we can't instantiate it, so just return. 	 This happens with base instantiation for implicit `typename'.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|d
argument_list|)
condition|)
return|return
literal|0
return|;
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
name|error
argument_list|(
literal|"template instantiation depth exceeds maximum of %d (use "
literal|"-ftemplate-depth-NN to increase the maximum) instantiating %qD"
argument_list|,
name|max_tinst_depth
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|print_instantiation_context
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|new
operator|=
name|make_node
argument_list|(
name|TINST_LEVEL
argument_list|)
expr_stmt|;
name|TINST_DECL
argument_list|(
name|new
argument_list|)
operator|=
name|d
expr_stmt|;
name|TINST_LOCATION
argument_list|(
name|new
argument_list|)
operator|=
name|input_location
expr_stmt|;
name|TINST_IN_SYSTEM_HEADER_P
argument_list|(
name|new
argument_list|)
operator|=
name|in_system_header
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|new
argument_list|)
operator|=
name|current_tinst_level
expr_stmt|;
name|current_tinst_level
operator|=
name|new
expr_stmt|;
operator|++
name|tinst_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|tinst_depth
operator|>
name|depth_reached
condition|)
name|depth_reached
operator|=
name|tinst_depth
expr_stmt|;
endif|#
directive|endif
operator|++
name|tinst_level_tick
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We're done instantiating this template; return to the instantiation    context.  */
end_comment

begin_function
specifier|static
name|void
name|pop_tinst_level
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|old
init|=
name|current_tinst_level
decl_stmt|;
comment|/* Restore the filename and line number stashed away when we started      this instantiation.  */
name|input_location
operator|=
name|TINST_LOCATION
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|in_system_header
operator|=
name|TINST_IN_SYSTEM_HEADER_P
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|current_tinst_level
operator|=
name|TREE_CHAIN
argument_list|(
name|old
argument_list|)
expr_stmt|;
operator|--
name|tinst_depth
expr_stmt|;
operator|++
name|tinst_level_tick
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're instantiating a deferred template; restore the template    instantiation context in which the instantiation was requested, which    is one step out from LEVEL.  */
end_comment

begin_function
specifier|static
name|void
name|reopen_tinst_level
parameter_list|(
name|tree
name|level
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|tinst_depth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|level
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
operator|++
name|tinst_depth
expr_stmt|;
name|current_tinst_level
operator|=
name|level
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the TINST_LEVEL which gives the original instantiation    context.  */
end_comment

begin_function
name|tree
name|outermost_tinst_level
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|tree_last
argument_list|(
name|current_tinst_level
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DECL is a friend FUNCTION_DECL or TEMPLATE_DECL.  ARGS is the    vector of template arguments, as for tsubst.     Returns an appropriate tsubst'd friend declaration.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_function
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|tree
name|new_friend
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
comment|/* This was a friend declared with an explicit template        argument list, e.g.:         friend void f<>(T);         to indicate that f was a template instantiation, not a new        function declaration.  Now, we have to figure out what        instantiation of what template.  */
block|{
name|tree
name|template_id
decl_stmt|,
name|arglist
decl_stmt|,
name|fns
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|ns
init|=
name|decl_namespace_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|current_class_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Friend functions are looked up in the containing namespace scope. 	 We must enter that scope, to avoid finding member functions of the 	 current cless with same name.  */
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|fns
operator|=
name|tsubst_expr
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|template_id
operator|=
name|lookup_template_function
argument_list|(
name|fns
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|determine_specialization
argument_list|(
name|template_id
argument_list|,
name|new_friend
argument_list|,
operator|&
name|new_args
argument_list|,
comment|/*need_member_template=*/
literal|0
argument_list|,
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
argument_list|,
name|tsk_none
argument_list|)
expr_stmt|;
return|return
name|instantiate_template
argument_list|(
name|tmpl
argument_list|,
name|new_args
argument_list|,
name|tf_error
argument_list|)
return|;
block|}
name|new_friend
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* The NEW_FRIEND will look like an instantiation, to the      compiler, but is not an instantiation from the point of view of      the language.  For example, we might have had:       template<class T> struct S {        template<class U> friend void f(T, U);      };       Then, in S<int>, template<class U> void f(int, U) is not an      instantiation of anything.  */
if|if
condition|(
name|new_friend
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|DECL_USE_TEMPLATE
argument_list|(
name|new_friend
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|DECL_USE_TEMPLATE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The mangled name for the NEW_FRIEND is incorrect.  The function      is not a template instantiation and should not be mangled like      one.  Therefore, we forget the mangling here; we'll recompute it      later if we need it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_friend
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
block|{
name|SET_DECL_RTL
argument_list|(
name|new_friend
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|new_friend
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|new_friend
argument_list|)
condition|)
block|{
name|tree
name|old_decl
decl_stmt|;
name|tree
name|new_friend_template_info
decl_stmt|;
name|tree
name|new_friend_result_template_info
decl_stmt|;
name|tree
name|ns
decl_stmt|;
name|int
name|new_friend_is_defn
decl_stmt|;
comment|/* We must save some information from NEW_FRIEND before calling 	 duplicate decls since that function will free NEW_FRIEND if 	 possible.  */
name|new_friend_template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
name|new_friend_is_defn
operator|=
operator|(
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|template_for_substitution
argument_list|(
name|new_friend
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|new_friend
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* This declaration is a `primary' template.  */
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|new_friend
argument_list|)
operator|=
name|new_friend
expr_stmt|;
name|new_friend_result_template_info
operator|=
name|DECL_TEMPLATE_INFO
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|new_friend
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|new_friend_result_template_info
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is a defn.  */
if|if
condition|(
name|new_friend_is_defn
condition|)
name|DECL_INITIAL
argument_list|(
name|new_friend
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Inside pushdecl_namespace_level, we will push into the 	 current namespace. However, the friend function should go 	 into the namespace of the template.  */
name|ns
operator|=
name|decl_namespace_context
argument_list|(
name|new_friend
argument_list|)
expr_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|old_decl
operator|=
name|pushdecl_namespace_level
argument_list|(
name|new_friend
argument_list|,
comment|/*is_friend=*/
name|true
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|old_decl
operator|!=
name|new_friend
condition|)
block|{
comment|/* This new friend declaration matched an existing 	     declaration.  For example, given:  	       template<class T> void f(T); 	       template<class U> class C { 		 template<class T> friend void f(T) {} 	       };  	     the friend declaration actually provides the definition 	     of `f', once C has been instantiated for some type.  So, 	     old_decl will be the out-of-class template declaration, 	     while new_friend is the in-class definition.  	     But, if `f' was called before this point, the 	     instantiation of `f' will have DECL_TI_ARGS corresponding 	     to `T' but not to `U', references to which might appear 	     in the definition of `f'.  Previously, the most general 	     template for an instantiation of `f' was the out-of-class 	     version; now it is the in-class version.  Therefore, we 	     run through all specialization of `f', adding to their 	     DECL_TI_ARGS appropriately.  In particular, they need a 	     new set of outer arguments, corresponding to the 	     arguments for this class instantiation.  	     The same situation can arise with something like this:  	       friend void f(int); 	       template<class T> class C { 		 friend void f(T) {} 	       };  	     when `C<int>' is instantiated.  Now, `f(int)' is defined 	     in the class.  */
if|if
condition|(
operator|!
name|new_friend_is_defn
condition|)
comment|/* On the other hand, if the in-class declaration does 	       *not* provide a definition, then we don't want to alter 	       existing definitions.  We can just leave everything 	       alone.  */
empty_stmt|;
else|else
block|{
comment|/* Overwrite whatever template info was there before, if 		 any, with the new template information pertaining to 		 the declaration.  */
name|DECL_TEMPLATE_INFO
argument_list|(
name|old_decl
argument_list|)
operator|=
name|new_friend_template_info
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
name|reregister_specialization
argument_list|(
name|new_friend
argument_list|,
name|most_general_template
argument_list|(
name|old_decl
argument_list|)
argument_list|,
name|old_decl
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|new_friend_args
decl_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|=
name|new_friend_result_template_info
expr_stmt|;
name|new_friend_args
operator|=
name|TI_ARGS
argument_list|(
name|new_friend_template_info
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
init|;
name|t
operator|!=
name|NULL_TREE
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|spec
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
operator|=
name|add_outermost_template_args
argument_list|(
name|new_friend_args
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|spec
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now, since specializations are always supposed to 		     hang off of the most general template, we must move 		     them.  */
name|t
operator|=
name|most_general_template
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|old_decl
condition|)
block|{
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
operator|=
name|chainon
argument_list|(
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|old_decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
comment|/* The information from NEW_FRIEND has been merged into OLD_DECL 	     by duplicate_decls.  */
name|new_friend
operator|=
name|old_decl
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|new_friend
argument_list|)
decl_stmt|;
name|bool
name|dependent_p
decl_stmt|;
comment|/* In the code 	   template<class T> class C { 	     template<class U> friend void C1<U>::f (); // case 1 	     friend void C2<T>::f ();			 // case 2 	   }; 	 we only need to make sure CONTEXT is a complete type for 	 case 2.  To distinguish between the two cases, we note that 	 CONTEXT of case 1 remains dependent type after tsubst while 	 this isn't true for case 2.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
if|if
condition|(
operator|!
name|dependent_p
operator|&&
operator|!
name|complete_type_or_else
argument_list|(
name|context
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
block|{
comment|/* Check to see that the declaration is really present, and, 	     possibly obtain an improved declaration.  */
name|tree
name|fn
init|=
name|check_classfn
argument_list|(
name|context
argument_list|,
name|new_friend
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
name|new_friend
operator|=
name|fn
expr_stmt|;
block|}
block|}
return|return
name|new_friend
return|;
block|}
end_function

begin_comment
comment|/* FRIEND_TMPL is a friend TEMPLATE_DECL.  ARGS is the vector of    template arguments, as for tsubst.     Returns an appropriate tsubst'd friend type or error_mark_node on    failure.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_friend_class
parameter_list|(
name|tree
name|friend_tmpl
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|tree
name|friend_type
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|friend_tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|push_nested_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|push_nested_class
argument_list|(
name|tsubst
argument_list|(
name|context
argument_list|,
name|args
argument_list|,
name|tf_none
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Look for a class template declaration.  We look for hidden names      because two friend declarations of the same template are the      same.  For example, in:         struct A {           template<typename> friend class F;        };        template<typename> struct B {           template<typename> friend class F;        };       both F templates are the same.  */
name|tmpl
operator|=
name|lookup_name_real
argument_list|(
name|DECL_NAME
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/*block_p=*/
name|true
argument_list|,
literal|0
argument_list|,
name|LOOKUP_COMPLAIN
operator||
name|LOOKUP_HIDDEN
argument_list|)
expr_stmt|;
comment|/* But, if we don't find one, it might be because we're in a      situation like this:         template<class T>        struct S { 	 template<class U> 	 friend struct S;        };       Here, in the scope of (say) S<int>, `S' is bound to a TYPE_DECL      for `S<int>', not the TEMPLATE_DECL.  */
if|if
condition|(
operator|!
name|tmpl
operator|||
operator|!
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tmpl
operator|=
name|lookup_name_prefer_type
argument_list|(
name|DECL_NAME
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmpl
operator|=
name|maybe_get_template_decl_from_type_decl
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpl
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
comment|/* The friend template has already been declared.  Just 	 check to see that the declarations match, and install any new 	 default parameters.  We must tsubst the default parameters, 	 of course.  We only need the innermost template parameters 	 because that is all that redeclare_class_template will look 	 at.  */
if|if
condition|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|)
operator|>
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|tree
name|parms
decl_stmt|;
name|parms
operator|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|friend_tmpl
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|)
expr_stmt|;
name|redeclare_class_template
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
block|}
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The friend template has not already been declared.  In this 	 case, the instantiation of the template class will cause the 	 injection of this template into the global scope.  */
name|tmpl
operator|=
name|tsubst
argument_list|(
name|friend_tmpl
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* The new TMPL is not an instantiation of anything, so we 	 forget its origins.  We don't reset CLASSTYPE_TI_TEMPLATE for 	 the new type because that is supposed to be the corresponding 	 template decl, i.e., TMPL.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|tmpl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Inject this template into the global scope.  */
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|pushdecl_top_level_maybe_friend
argument_list|(
name|tmpl
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|pop_nested_namespace
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
return|return
name|friend_type
return|;
block|}
end_function

begin_comment
comment|/* Returns zero if TYPE cannot be completed later due to circularity.    Otherwise returns one.  */
end_comment

begin_function
specifier|static
name|int
name|can_complete_type_without_circularity
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|can_complete_type_without_circularity
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
name|tree
name|instantiate_class_template
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|template
decl_stmt|,
name|args
decl_stmt|,
name|pattern
decl_stmt|,
name|t
decl_stmt|,
name|member
decl_stmt|;
name|tree
name|typedecl
decl_stmt|;
name|tree
name|pbinfo
decl_stmt|;
name|tree
name|base_list
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|dependent_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* Figure out which template is being instantiated.  */
name|template
operator|=
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|)
expr_stmt|;
comment|/* Determine what specialization of the original template to      instantiate.  */
name|t
operator|=
name|most_specialized_class
argument_list|(
name|type
argument_list|,
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
block|{
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|t
condition|)
block|{
comment|/* This TYPE is actually an instantiation of a partial 	 specialization.  We replace the innermost set of ARGS with 	 the arguments appropriate for substitution.  For example, 	 given:  	   template<class T> struct S {}; 	   template<class T> struct S<T*> {};  	 and supposing that we are instantiating S<int*>, ARGS will 	 presently be {int*} -- but we need {int}.  */
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pattern
operator|=
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* If the template we're instantiating is incomplete, then clearly      there's nothing we can do.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|pattern
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* If we've recursively instantiated too many templates, stop.  */
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type
return|;
comment|/* Now we're really doing the instantiation.  Mark the type as in      the process of being defined.  */
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We may be in the middle of deferred access check.  Disable      it now.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
name|push_to_top_level
argument_list|()
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Set the input location to the template definition. This is needed      if tsubsting causes an error.  */
name|typedecl
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|in_system_header
operator|=
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_NEW_OPERATOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ARRAY_NEW_OPERATOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_GETS_DELETE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_GETS_DELETE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_HAS_CONVERSION
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_HAS_CONVERSION
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_PACKED
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_FOR_JAVA
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* For libjava's JArray<T> */
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|pattern
argument_list|)
condition|)
name|SET_ANON_AGGR_TYPE_P
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_VISIBILITY_SPECIFIED
argument_list|(
name|pattern
argument_list|)
condition|)
block|{
name|CLASSTYPE_VISIBILITY_SPECIFIED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_VISIBILITY
argument_list|(
name|type
argument_list|)
operator|=
name|CLASSTYPE_VISIBILITY
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
name|pbinfo
operator|=
name|TYPE_BINFO
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* We should never instantiate a nested class before its enclosing      class; we need to look up the nested class by name before we can      instantiate it, and that lookup should instantiate the enclosing      class.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_CLASS_SCOPE_P
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|||
name|COMPLETE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|TYPE_BEING_DEFINED
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base_list
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|BINFO_N_BASE_BINFOS
argument_list|(
name|pbinfo
argument_list|)
condition|)
block|{
name|tree
name|pbase_binfo
decl_stmt|;
name|tree
name|context
init|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|pushed_scope
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We must enter the scope containing the type, as that is where 	 the accessibility of types named in dependent bases are 	 looked up from.  */
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|context
condition|?
name|context
else|:
name|global_namespace
argument_list|)
expr_stmt|;
comment|/* Substitute into each of the bases to determine the actual 	 basetypes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|pbinfo
argument_list|,
name|i
argument_list|,
name|pbase_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|base
decl_stmt|;
name|tree
name|access
init|=
name|BINFO_BASE_ACCESS
argument_list|(
name|pbinfo
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Substitute to figure out the base class.  */
name|base
operator|=
name|tsubst
argument_list|(
name|BINFO_TYPE
argument_list|(
name|pbase_binfo
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
continue|continue;
name|base_list
operator|=
name|tree_cons
argument_list|(
name|access
argument_list|,
name|base
argument_list|,
name|base_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|pbase_binfo
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|base_list
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* The list is now in reverse order; correct that.  */
name|base_list
operator|=
name|nreverse
argument_list|(
name|base_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
block|}
comment|/* Now call xref_basetypes to set up all the base-class      information.  */
name|xref_basetypes
argument_list|(
name|type
argument_list|,
name|base_list
argument_list|)
expr_stmt|;
comment|/* Now that our base classes are set up, enter the scope of the      class, so that name lookups into base classes, etc. will work      correctly.  This is precisely analogous to what we do in      begin_class_definition when defining an ordinary non-template      class.  */
name|pushclass
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Now members are processed in the order of declaration.  */
for|for
control|(
name|member
operator|=
name|CLASSTYPE_DECL_LIST
argument_list|(
name|pattern
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|TREE_VALUE
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|member
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Build new CLASSTYPE_NESTED_UTDS.  */
name|tree
name|newtag
decl_stmt|;
name|bool
name|class_template_p
decl_stmt|;
name|class_template_p
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|CLASSTYPE_IS_TEMPLATE
argument_list|(
name|t
argument_list|)
operator|)
expr_stmt|;
comment|/* If the member is a class template, then -- even after 		 substitution -- there may be dependent types in the 		 template argument list for the class.  We increment 		 PROCESSING_TEMPLATE_DECL so that dependent_type_p, as 		 that function will assume that no types are dependent 		 when outside of a template.  */
if|if
condition|(
name|class_template_p
condition|)
operator|++
name|processing_template_decl
expr_stmt|;
name|newtag
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|tf_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_template_p
condition|)
operator|--
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|newtag
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newtag
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|class_template_p
condition|)
comment|/* Unfortunately, lookup_template_class sets 		       CLASSTYPE_IMPLICIT_INSTANTIATION for a partial 		       instantiation (i.e., for the type of a member 		       template class nested within a template class.) 		       This behavior is required for 		       maybe_process_partial_specialization to work 		       correctly, but is not accurate in this case; 		       the TAG is not an instantiation of anything. 		       (The corresponding TEMPLATE_DECL is an 		       instantiation, but the TYPE is not.) */
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|newtag
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now, we call pushtag to put this NEWTAG into the scope of 		     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid 		     pushtag calling push_template_decl.  We don't have to do 		     this for enums because it will already have been done in 		     tsubst_enum.  */
if|if
condition|(
name|name
condition|)
name|SET_IDENTIFIER_TYPE_VALUE
argument_list|(
name|name
argument_list|,
name|newtag
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|newtag
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Build new TYPE_METHODS.  */
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
operator|++
name|processing_template_decl
expr_stmt|;
name|r
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|tf_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
operator|--
name|processing_template_decl
expr_stmt|;
name|set_current_access_from_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Build new TYPE_FIELDS.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
name|tree
name|r
decl_stmt|;
comment|/* The the file and line for this declaration, to 		     assist in error message reporting.  Since we 		     called push_tinst_level above, we don't need to 		     restore these.  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
operator|++
name|processing_template_decl
expr_stmt|;
name|r
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
operator|--
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* In [temp.inst]:  			   [t]he initialization (and any associated 			   side-effects) of a static data member does 			   not occur unless the static data member is 			   itself used in a way that requires the 			   definition of the static data member to 			   exist.  			 Therefore, we do not substitute into the 			 initialized for the static data member here.  */
name|finish_static_data_member_decl
argument_list|(
name|r
argument_list|,
comment|/*init=*/
name|NULL_TREE
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
comment|/*asmspec_tree=*/
name|NULL_TREE
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|r
argument_list|)
condition|)
name|check_static_variable_definition
argument_list|(
name|r
argument_list|,
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Determine whether R has a valid type and can be 			 completed later.  If R is invalid, then it is 			 replaced by error_mark_node so that it will not be 			 added to TYPE_FIELDS.  */
name|tree
name|rtype
init|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|can_complete_type_without_circularity
argument_list|(
name|rtype
argument_list|)
condition|)
name|complete_type
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|rtype
argument_list|)
condition|)
block|{
name|cxx_incomplete_type_error
argument_list|(
name|r
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
name|r
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
comment|/* If it is a TYPE_DECL for a class-scoped ENUMERAL_TYPE, 		     such a thing will already have been added to the field 		     list by tsubst_enum in finish_member_declaration in the 		     CLASSTYPE_NESTED_UTDS case above.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|r
argument_list|)
operator|)
condition|)
block|{
name|set_current_access_from_decl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|finish_member_declaration
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Build new CLASSTYPE_FRIEND_CLASSES.  */
name|tree
name|friend_type
init|=
name|t
decl_stmt|;
name|bool
name|adjust_processing_template_decl
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
comment|/* template<class T> friend class C;  */
name|friend_type
operator|=
name|tsubst_friend_class
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|adjust_processing_template_decl
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|UNBOUND_CLASS_TEMPLATE
condition|)
block|{
comment|/* template<class T> friend class C::D;  */
name|friend_type
operator|=
name|tsubst
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|friend_type
operator|=
name|TREE_TYPE
argument_list|(
name|friend_type
argument_list|)
expr_stmt|;
name|adjust_processing_template_decl
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|friend_type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
comment|/* This could be either  		       friend class T::C;  		     when dependent_type_p is false or  		       template<class U> friend class T::C;  		     otherwise.  */
name|friend_type
operator|=
name|tsubst
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Bump processing_template_decl for correct 		     dependent_type_p calculation.  */
operator|++
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|friend_type
argument_list|)
condition|)
name|adjust_processing_template_decl
operator|=
name|true
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|friend_type
argument_list|)
operator|&&
name|hidden_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|friend_type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* friend class C;  		     where C hasn't been declared yet.  Let's lookup name 		     from namespace scope directly, bypassing any name that 		     come from dependent base class.  */
name|tree
name|ns
init|=
name|decl_namespace_context
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|friend_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The call to xref_tag_from_type does injection for friend 		     classes.  */
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|friend_type
operator|=
name|xref_tag_from_type
argument_list|(
name|friend_type
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|)
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|friend_type
argument_list|)
condition|)
comment|/* friend class C<T>;  */
name|friend_type
operator|=
name|tsubst
argument_list|(
name|friend_type
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Otherwise it's  		   friend class C;  		 where C is already declared or  		   friend class C<int>;  		 We don't have to do anything in these cases.  */
if|if
condition|(
name|adjust_processing_template_decl
condition|)
comment|/* Trick make_friend_class into realizing that the friend 		   we're adding is a template, not an ordinary class.  It's 		   important that we use make_friend_class since it will 		   perform some error-checking and output cross-reference 		   information.  */
operator|++
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|friend_type
operator|!=
name|error_mark_node
condition|)
name|make_friend_class
argument_list|(
name|type
argument_list|,
name|friend_type
argument_list|,
comment|/*complain=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust_processing_template_decl
condition|)
operator|--
name|processing_template_decl
expr_stmt|;
block|}
else|else
block|{
comment|/* Build new DECL_FRIENDLIST.  */
name|tree
name|r
decl_stmt|;
comment|/* The the file and line for this declaration, to 		 assist in error message reporting.  Since we 		 called push_tinst_level above, we don't need to 		 restore these.  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
operator|++
name|processing_template_decl
expr_stmt|;
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|tsubst_friend_function
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|add_friend
argument_list|(
name|type
argument_list|,
name|r
argument_list|,
comment|/*complain=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Set the file and line number information to whatever is given for      the class itself.  This puts error messages involving generated      implicit functions at a predictable point, and the same point      that would be used for non-template classes.  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|typedecl
argument_list|)
expr_stmt|;
name|unreverse_member_declarations
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|finish_struct_1
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now that the class is complete, instantiate default arguments for      any member functions.  We don't do this earlier because the      default arguments may reference members of the class.  */
if|if
condition|(
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|template
argument_list|)
condition|)
for|for
control|(
name|t
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
comment|/* Implicitly generated member functions will not have template 	     information; they are not instantiations, but instead are 	     created "fresh" for each instantiation.  */
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
name|tsubst_default_arguments
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|popclass
argument_list|()
expr_stmt|;
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
comment|/* The vtable for a template class can be emitted in any translation      unit in which the class is instantiated.  When there is no key      method, however, finish_struct_1 will already have added TYPE to      the keyed_classes list.  */
if|if
condition|(
name|TYPE_CONTAINS_VPTR_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_KEY_METHOD
argument_list|(
name|type
argument_list|)
condition|)
name|keyed_classes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|,
name|keyed_classes
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|tsubst_template_arg
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|r
operator|=
name|t
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|r
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|tsubst_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*integral_constant_expression_p=*/
name|true
argument_list|)
expr_stmt|;
name|r
operator|=
name|fold_non_dependent_expr
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Substitute ARGS into the vector or list of template arguments T.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_template_args
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|int
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|int
name|need_new
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|tree
modifier|*
name|elts
init|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|orig_arg
init|=
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|new_arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_arg
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|new_arg
operator|=
name|tsubst_template_args
argument_list|(
name|orig_arg
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
name|new_arg
operator|=
name|tsubst_template_arg
argument_list|(
name|orig_arg
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|elts
index|[
name|i
index|]
operator|=
name|new_arg
expr_stmt|;
if|if
condition|(
name|new_arg
operator|!=
name|orig_arg
condition|)
name|need_new
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_new
condition|)
return|return
name|t
return|;
name|t
operator|=
name|make_tree_vec
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|TREE_VEC_ELT
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|elts
index|[
name|i
index|]
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the result of substituting ARGS into the template parameters    given by PARMS.  If there are m levels of ARGS and m + n levels of    PARMS, then the result will contain n levels of PARMS.  For    example, if PARMS is `template<class T> template<class U>    template<T*, U, class V>' and ARGS is {{int}, {double}} then the    result will be `template<int*, double, class V>'.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_template_parms
parameter_list|(
name|tree
name|parms
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|new_parms
decl_stmt|;
comment|/* When substituting into a template, we must set      PROCESSING_TEMPLATE_DECL as the template parameters may be      dependent if they are based on one-another, and the dependency      predicates are short-circuit outside of templates.  */
operator|++
name|processing_template_decl
expr_stmt|;
for|for
control|(
name|new_parms
operator|=
operator|&
name|r
init|;
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|>
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|;
name|new_parms
operator|=
operator|&
operator|(
name|TREE_CHAIN
argument_list|(
operator|*
name|new_parms
argument_list|)
operator|)
operator|,
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
name|tree
name|new_vec
init|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|new_vec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|tuple
decl_stmt|;
name|tree
name|default_value
decl_stmt|;
name|tree
name|parm_decl
decl_stmt|;
if|if
condition|(
name|parms
operator|==
name|error_mark_node
condition|)
continue|continue;
name|tuple
operator|=
name|TREE_VEC_ELT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tuple
operator|==
name|error_mark_node
condition|)
continue|continue;
name|default_value
operator|=
name|TREE_PURPOSE
argument_list|(
name|tuple
argument_list|)
expr_stmt|;
name|parm_decl
operator|=
name|TREE_VALUE
argument_list|(
name|tuple
argument_list|)
expr_stmt|;
name|parm_decl
operator|=
name|tsubst
argument_list|(
name|parm_decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm_decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|invalid_nontype_parm_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm_decl
argument_list|)
argument_list|,
name|complain
argument_list|)
condition|)
name|parm_decl
operator|=
name|error_mark_node
expr_stmt|;
name|default_value
operator|=
name|tsubst_template_arg
argument_list|(
name|default_value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tuple
operator|=
name|build_tree_list
argument_list|(
name|default_value
argument_list|,
name|parm_decl
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|new_vec
argument_list|,
name|i
argument_list|)
operator|=
name|tuple
expr_stmt|;
block|}
operator|*
name|new_parms
operator|=
name|tree_cons
argument_list|(
name|size_int
argument_list|(
name|TMPL_PARMS_DEPTH
argument_list|(
name|parms
argument_list|)
operator|-
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|,
name|new_vec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
operator|--
name|processing_template_decl
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Substitute the ARGS into the indicated aggregate (or enumeration)    type T.  If T is not an aggregate or enumeration type, it is    handled as if by tsubst.  IN_DECL is as for tsubst.  If    ENTERING_SCOPE is nonzero, T is the context for a template which    we are presently tsubst'ing.  Return the substituted value.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_aggr_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|,
name|int
name|entering_scope
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
comment|/* Else fall through.  */
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|argvec
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|tree
name|r
decl_stmt|;
name|bool
name|saved_skip_evaluation
decl_stmt|;
comment|/* In "sizeof(X<I>)" we need to evaluate "I".  */
name|saved_skip_evaluation
operator|=
name|skip_evaluation
expr_stmt|;
name|skip_evaluation
operator|=
name|false
expr_stmt|;
comment|/* First, determine the context for the type we are looking 	     up.  */
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|context
operator|=
name|tsubst_aggr_type
argument_list|(
name|context
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Then, figure out what arguments are appropriate for the 	     type we are trying to find.  For example, given:  	       template<class T> struct S; 	       template<class T, class U> void f(T, U) { S<U> su; }  	     and supposing that we are instantiating f<int, double>, 	     then our ARGS will be {int, double}, but, when looking up 	     S we only want {double}.  */
name|argvec
operator|=
name|tsubst_template_args
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
name|r
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
name|r
operator|=
name|lookup_template_class
argument_list|(
name|t
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|context
argument_list|,
name|entering_scope
argument_list|,
name|complain
argument_list|)
expr_stmt|;
name|r
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
block|}
name|skip_evaluation
operator|=
name|saved_skip_evaluation
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
comment|/* This is not a template type, so there's nothing to do.  */
return|return
name|t
return|;
default|default:
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Substitute into the default argument ARG (a default argument for    FN), which has the indicated TYPE.  */
end_comment

begin_function
name|tree
name|tsubst_default_argument
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|saved_class_ptr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|saved_class_ref
init|=
name|NULL_TREE
decl_stmt|;
comment|/* This default argument came from a template.  Instantiate the      default argument here, not in tsubst.  In the case of      something like:         template<class T>        struct S { 	 static T t(); 	 void f(T = t());        };       we must be careful to do name lookup in the scope of S<T>,      rather than in the current class.  */
name|push_access_scope
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* The "this" pointer is not valid in a default argument.  */
if|if
condition|(
name|cfun
condition|)
block|{
name|saved_class_ptr
operator|=
name|current_class_ptr
expr_stmt|;
name|cp_function_chain
operator|->
name|x_current_class_ptr
operator|=
name|NULL_TREE
expr_stmt|;
name|saved_class_ref
operator|=
name|current_class_ref
expr_stmt|;
name|cp_function_chain
operator|->
name|x_current_class_ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
comment|/* The default argument expression may cause implicitly defined      member functions to be synthesized, which will result in garbage      collection.  We must treat this situation as if we were within      the body of function so as to avoid collecting live data on the      stack.  */
operator|++
name|function_depth
expr_stmt|;
name|arg
operator|=
name|tsubst_expr
argument_list|(
name|arg
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
operator|--
name|function_depth
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* Restore the "this" pointer.  */
if|if
condition|(
name|cfun
condition|)
block|{
name|cp_function_chain
operator|->
name|x_current_class_ptr
operator|=
name|saved_class_ptr
expr_stmt|;
name|cp_function_chain
operator|->
name|x_current_class_ref
operator|=
name|saved_class_ref
expr_stmt|;
block|}
name|pop_access_scope
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Make sure the default argument is reasonable.  */
name|arg
operator|=
name|check_default_argument
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Substitute into all the default arguments for FN.  */
end_comment

begin_function
specifier|static
name|void
name|tsubst_default_arguments
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
name|tree
name|tmpl_args
decl_stmt|;
name|tmpl_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If this function is not yet instantiated, we certainly don't need      its default arguments.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|tmpl_args
argument_list|)
condition|)
return|return;
for|for
control|(
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
condition|)
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
operator|=
name|tsubst_default_argument
argument_list|(
name|fn
argument_list|,
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Substitute the ARGS into the T, which is a _DECL.  Return the    result of the substitution.  Issue error and warning messages under    control of COMPLAIN.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_decl
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|location_t
name|saved_loc
decl_stmt|;
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|in_decl
init|=
name|t
decl_stmt|;
comment|/* Set the filename and linenumber to improve error-reporting.  */
name|saved_loc
operator|=
name|input_location
expr_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_DECL
case|:
block|{
comment|/* We can get here when processing a member function template, 	   member class template, and template template parameter of 	   a template class.  */
name|tree
name|decl
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl_args
decl_stmt|;
name|tree
name|full_args
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Template template parameter is treated here.  */
name|tree
name|new_type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|new_type
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|new_type
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|new_type
argument_list|)
operator|=
name|r
expr_stmt|;
break|break;
block|}
comment|/* We might already have an instance of this template. 	   The ARGS are for the surrounding class type, so the 	   full args contain the tsubst'd args for the context, 	   plus the innermost args from the template decl.  */
name|tmpl_args
operator|=
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|?
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
else|:
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because this is a template, the arguments will still be 	   dependent, even after substitution.  If 	   PROCESSING_TEMPLATE_DECL is not set, the dependency 	   predicates will short-circuit.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|full_args
operator|=
name|tsubst_template_args
argument_list|(
name|tmpl_args
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|full_args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* tsubst_template_args doesn't copy the vector if 	   nothing changed.  But, *something* should have 	   changed.  */
name|gcc_assert
argument_list|(
name|full_args
operator|!=
name|tmpl_args
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|t
argument_list|,
name|full_args
argument_list|,
comment|/*class_specializations_p=*/
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
comment|/* Make a new template decl.  It will be similar to the 	   original, but will record the current template arguments. 	   We also create a new function declaration, which is just 	   like the old one, but points to this new template, rather 	   than the old one.  */
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|r
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|build_tree_list
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|new_type
decl_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
name|new_type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|new_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|new_type
expr_stmt|;
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|new_type
argument_list|)
operator|=
name|r
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_MAIN_DECL
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|r
argument_list|)
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_CONTEXT
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|new_decl
decl_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
name|new_decl
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
if|if
condition|(
name|new_decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|new_decl
expr_stmt|;
name|DECL_TI_TEMPLATE
argument_list|(
name|new_decl
argument_list|)
operator|=
name|r
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_TI_ARGS
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_TI_ARGS
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|new_decl
argument_list|)
expr_stmt|;
block|}
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATIONS
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* The template parameters for this new template are all the 	   template parameters for the old template, except the 	   outermost level of parameters.  */
name|DECL_TEMPLATE_PARMS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_template_parms
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_PRIMARY_TEMPLATE
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
comment|/* Record this non-type partial instantiation.  */
name|register_specialization
argument_list|(
name|r
argument_list|,
name|t
argument_list|,
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
block|{
name|tree
name|ctx
decl_stmt|;
name|tree
name|argvec
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|friends
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|member
decl_stmt|;
name|int
name|args_depth
decl_stmt|;
name|int
name|parms_depth
decl_stmt|;
comment|/* Nobody should be tsubst'ing into non-template functions.  */
name|gcc_assert
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|tree
name|spec
decl_stmt|;
name|bool
name|dependent_p
decl_stmt|;
comment|/* If T is not dependent, just return it.  We have to 	       increment PROCESSING_TEMPLATE_DECL because 	       value_dependent_expression_p assumes that nothing is 	       dependent when PROCESSING_TEMPLATE_DECL is zero.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|dependent_p
operator|=
name|value_dependent_expression_p
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
if|if
condition|(
operator|!
name|dependent_p
condition|)
return|return
name|t
return|;
comment|/* Calculate the most general template of which R is a 	       specialization, and the complete set of arguments used to 	       specialize R.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|argvec
operator|=
name|tsubst_template_args
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
comment|/* We can see more levels of arguments than parameters if 	       there was a specialization of a member template, like 	       this:  		 template<class T> struct S { template<class U> void f(); } 		 template<> template<class U> void S<int>::f(U);  	       Here, we'll be substituting into the specialization, 	       because that's where we can find the code we actually 	       want to generate, but we'll have enough arguments for 	       the most general template.  	       We also deal with the peculiar case:  		 template<class T> struct S { 		   template<class U> friend void f(); 		 }; 		 template<class U> void f() {} 		 template S<int>; 		 template void f<double>();  	       Here, the ARGS for the instantiation of will be {int, 	       double}.  But, we only need as many ARGS as there are 	       levels of template parameters in CODE_PATTERN.  We are 	       careful not to get fooled into reducing the ARGS in 	       situations like:  		 template<class T> struct S { template<class U> void f(U); } 		 template<class T> template<> void S<T>::f(int) {}  	       which we can spot because the pattern will be a 	       specialization in this case.  */
name|args_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|parms_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_depth
operator|>
name|parms_depth
operator|&&
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
name|args
operator|=
name|get_innermost_template_args
argument_list|(
name|args
argument_list|,
name|parms_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This special case arises when we have something like this:  		 template<class T> struct S { 		   friend void f<int>(int, double); 		 };  	       Here, the DECL_TI_TEMPLATE for the friend declaration 	       will be an IDENTIFIER_NODE.  We are being called from 	       tsubst_friend_function, and we want only to create a 	       new decl (R) with appropriate types so that we can call 	       determine_specialization.  */
name|gen_tmpl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|constructor_name
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|member
operator|=
literal|2
expr_stmt|;
else|else
name|member
operator|=
literal|1
expr_stmt|;
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|t
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|member
operator|=
literal|0
expr_stmt|;
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* We do NOT check for matching decls pushed separately at this 	   point, as they may not represent instantiations of this 	   template, and in any case are considered separate under the 	   discrete model.  */
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Clear out the mangled name and RTL for the instantiation.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|r
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|member
operator|&&
name|DECL_CONV_FN_P
argument_list|(
name|r
argument_list|)
condition|)
comment|/* Type-conversion operator.  Reconstruct the name, in 	     case it's the name of one of the template's parameters.  */
name|DECL_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|mangle_conv_op_name_for_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is an instantiation of a function with internal 	   linkage, we already know what object file linkage will be 	   assigned to the instantiation.  */
name|DECL_INTERFACE_KNOWN
argument_list|(
name|r
argument_list|)
operator|=
operator|!
name|TREE_PUBLIC
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_USED
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|r
argument_list|)
argument_list|)
operator|=
name|r
expr_stmt|;
block|}
comment|/* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do 	   this in the special friend case mentioned above where 	   GEN_TMPL is NULL.  */
if|if
condition|(
name|gen_tmpl
condition|)
block|{
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|register_specialization
argument_list|(
name|r
argument_list|,
name|gen_tmpl
argument_list|,
name|argvec
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* We're not supposed to instantiate default arguments 	       until they are called, for a template.  But, for a 	       declaration like:  		 template<class T> void f () 		 { extern void g(int i = T()); }  	       we should do the substitution when the template is 	       instantiated.  We handle the member function case in 	       instantiate_class_template since the default arguments 	       might refer to other members of the class.  */
if|if
condition|(
operator|!
name|member
operator|&&
operator|!
name|PRIMARY_TEMPLATE_P
argument_list|(
name|gen_tmpl
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|argvec
argument_list|)
condition|)
name|tsubst_default_arguments
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Copy the list of befriending classes.  */
for|for
control|(
name|friends
operator|=
operator|&
name|DECL_BEFRIENDING_CLASSES
argument_list|(
name|r
argument_list|)
init|;
operator|*
name|friends
condition|;
name|friends
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|friends
argument_list|)
control|)
block|{
operator|*
name|friends
operator|=
name|copy_node
argument_list|(
operator|*
name|friends
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
operator|*
name|friends
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
operator|*
name|friends
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|r
argument_list|)
operator|||
name|DECL_DESTRUCTOR_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|maybe_retrofit_in_chrg
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|r
argument_list|)
condition|)
name|grok_ctor_properties
argument_list|(
name|ctx
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* If this is an instantiation of a member template, clone it. 	       If it isn't, that'll be handled by 	       clone_constructors_and_destructors.  */
if|if
condition|(
name|PRIMARY_TEMPLATE_P
argument_list|(
name|gen_tmpl
argument_list|)
condition|)
name|clone_function_decl
argument_list|(
name|r
argument_list|,
comment|/*update_method_vec_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
operator|&&
operator|!
name|grok_op_properties
argument_list|(
name|r
argument_list|,
operator|(
name|complain
operator|&
name|tf_error
operator|)
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_FRIEND_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|SET_DECL_FRIEND_CONTEXT
argument_list|(
name|r
argument_list|,
name|tsubst
argument_list|(
name|DECL_FRIEND_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Possibly limit visibility based on template args.  */
name|DECL_VISIBILITY
argument_list|(
name|r
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ATTRIBUTES
argument_list|(
name|r
argument_list|)
operator|=
name|remove_attribute
argument_list|(
literal|"visibility"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|determine_visibility
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|type
decl_stmt|;
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
name|SET_DECL_TEMPLATE_PARM_P
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|type_decays_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|cp_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
condition|)
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|r
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type_passed_as
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIELD_DECL
case|:
block|{
name|tree
name|type
decl_stmt|;
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|cp_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* DECL_INITIAL gives the number of bits in a bit-field.  */
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*integral_constant_expression_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* We don't have to set DECL_CONTEXT here; it is set by 	   finish_member_declaration.  */
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|error
argument_list|(
literal|"instantiation of %q+D as type %qT"
argument_list|,
name|r
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|USING_DECL
case|:
comment|/* We reach here only for member using decls.  */
if|if
condition|(
name|DECL_DEPENDENT_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|r
operator|=
name|do_class_using_decl
argument_list|(
name|tsubst_copy
argument_list|(
name|USING_DECL_SCOPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|r
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_DECL
case|:
case|case
name|VAR_DECL
case|:
block|{
name|tree
name|argvec
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|gen_tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|tmpl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|ctx
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|local_p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|t
operator|==
name|TYPE_MAIN_DECL
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If this is the canonical decl, we don't have to 		   mess with instantiations, and often we can't (for 		   typename, template type parms and such).  Note that 		   TYPE_NAME is not correct for the above test if 		   we've copied the type for a typedef.  */
name|r
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check to see if we already have the specialization we 	   need.  */
name|spec
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* T is a static data member or namespace-scope entity. 	       We have to substitute into namespace-scope variables 	       (even though such entities are never templates) because 	       of cases like: 	        	         template<class T> void f() { extern T t; }  	       where the entity referenced is not known until 	       instantiation time.  */
name|local_p
operator|=
name|false
expr_stmt|;
name|ctx
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|ctx
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* If CTX is unchanged, then T is in fact the 		   specialization we want.  That situation occurs when 		   referencing a static data member within in its own 		   class.  We can use pointer equality, rather than 		   same_type_p, because DECL_CONTEXT is always 		   canonical.  */
if|if
condition|(
name|ctx
operator|==
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
name|spec
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|spec
condition|)
block|{
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|argvec
operator|=
name|tsubst
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|spec
operator|=
operator|(
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|argvec
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A local variable.  */
name|local_p
operator|=
name|true
expr_stmt|;
comment|/* Subsequent calls to pushdecl will fill this in.  */
name|ctx
operator|=
name|NULL_TREE
expr_stmt|;
name|spec
operator|=
name|retrieve_local_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If we already have the specialization we need, there is 	   nothing more to do.  */
if|if
condition|(
name|spec
condition|)
block|{
name|r
operator|=
name|spec
expr_stmt|;
break|break;
block|}
comment|/* Create a new node for the specialization we need.  */
name|r
operator|=
name|copy_decl
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Even if the original location is out of scope, the 	       newly substituted one is not.  */
name|DECL_DEAD_FOR_LOCAL
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INITIALIZED_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* It may seem that this case cannot occur, since:  		     typedef void f(); 		     void g() { f x; }  		   declares a function, not a variable.  However:        		     typedef void f(); 		     template<typename T> void g() { T t; } 		     template void g<f>();  		   is an attempt to declare a variable with function 		   type.  */
name|error
argument_list|(
literal|"variable %qD has function type"
argument_list|,
comment|/* R is not yet sufficiently initialized, so we 			  just use its name.  */
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|type
operator|=
name|complete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_var_type
argument_list|(
name|DECL_NAME
argument_list|(
name|r
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|ve
init|=
name|DECL_VALUE_EXPR
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|ve
operator|=
name|tsubst_expr
argument_list|(
name|ve
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|r
argument_list|,
name|ve
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_SELF_REFERENCE_P
argument_list|(
name|t
argument_list|)
condition|)
name|SET_DECL_SELF_REFERENCE_P
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|type
expr_stmt|;
name|cp_apply_type_quals_to_decl
argument_list|(
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|r
argument_list|)
operator|=
name|ctx
expr_stmt|;
comment|/* Clear out the mangled name and RTL for the instantiation.  */
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|r
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TS_DECL_WRTL
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|r
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* The initializer must not be expanded until it is required; 	   see [temp.inst].  */
name|DECL_INITIAL
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TS_DECL_WRTL
argument_list|)
condition|)
name|SET_DECL_RTL
argument_list|(
name|r
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|r
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Possibly limit visibility based on template args.  */
name|DECL_VISIBILITY
argument_list|(
name|r
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ATTRIBUTES
argument_list|(
name|r
argument_list|)
operator|=
name|remove_attribute
argument_list|(
literal|"visibility"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|determine_visibility
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
comment|/* A static data member declaration is always marked 	       external when it is declared in-class, even if an 	       initializer is present.  We mimic the non-template 	       processing here.  */
name|DECL_EXTERNAL
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|register_specialization
argument_list|(
name|r
argument_list|,
name|gen_tmpl
argument_list|,
name|argvec
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|tmpl
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|register_local_specialization
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|layout_decl
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Restore the file and line information.  */
name|input_location
operator|=
name|saved_loc
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Substitute into the ARG_TYPES of a function type.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_arg_types
parameter_list|(
name|tree
name|arg_types
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|remaining_arg_types
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|default_arg
decl_stmt|;
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
operator|!
name|arg_types
operator|||
name|arg_types
operator|==
name|void_list_node
condition|)
return|return
name|arg_types
return|;
name|remaining_arg_types
operator|=
name|tsubst_arg_types
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining_arg_types
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
name|error
argument_list|(
literal|"invalid parameter type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
name|error
argument_list|(
literal|"in declaration %q+D"
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* Do array-to-pointer, function-to-pointer conversion, and ignore      top-level qualifiers as required.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type_decays_to
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not substitute into default arguments here.  The standard      mandates that they be instantiated only when needed, which is      done in build_over_call.  */
name|default_arg
operator|=
name|TREE_PURPOSE
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_arg
operator|&&
name|TREE_CODE
argument_list|(
name|default_arg
argument_list|)
operator|==
name|DEFAULT_ARG
condition|)
block|{
comment|/* We've instantiated a template before its default arguments 	 have been parsed.  This can happen for a nested template 	 class, and is not an error unless we require the default 	 argument in a call of this function.  */
name|result
operator|=
name|tree_cons
argument_list|(
name|default_arg
argument_list|,
name|type
argument_list|,
name|remaining_arg_types
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|DEFARG_INSTANTIATIONS
argument_list|(
name|default_arg
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|hash_tree_cons
argument_list|(
name|default_arg
argument_list|,
name|type
argument_list|,
name|remaining_arg_types
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Substitute into a FUNCTION_TYPE or METHOD_TYPE.  This routine does    *not* handle the exception-specification for FNTYPE, because the    initial substitution of explicitly provided template parameters    during argument deduction forbids substitution into the    exception-specification:       [temp.deduct]       All references in the function type of the function template to  the      corresponding template parameters are replaced by the specified tem-      plate argument values.  If a substitution in a template parameter or      in  the function type of the function template results in an invalid      type, type deduction fails.  [Note: The equivalent  substitution  in      exception specifications is done only when the function is instanti-      ated, at which point a program is  ill-formed  if  the  substitution      results in an invalid type.]  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_function_type
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|return_type
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
comment|/* The TYPE_CONTEXT is not used for function/method types.  */
name|gcc_assert
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Substitute the return type.  */
name|return_type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* The standard does not presently indicate that creation of a      function type with an invalid return type is a deduction failure.      However, that is clearly analogous to creating an array of "void"      or a reference to a reference.  This is core issue #486.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"function returning an array"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"function returning a function"
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* Substitute the argument types.  */
name|arg_types
operator|=
name|tsubst_arg_types
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Construct a new type node and return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|fntype
operator|=
name|build_function_type
argument_list|(
name|return_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|r
init|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* [temp.deduct]  	     Type deduction may fail for any of the following 	     reasons:  	     -- Attempting to create "pointer to member of T" when T 	     is not a class type.  */
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"creating pointer to member function of non-class type %qT"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|fntype
operator|=
name|build_method_type_directly
argument_list|(
name|r
argument_list|,
name|return_type
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fntype
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|fntype
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|cp_build_type_attribute_variant
argument_list|(
name|fntype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fntype
return|;
block|}
end_function

begin_comment
comment|/* FNTYPE is a FUNCTION_TYPE or METHOD_TYPE.  Substitute the template    ARGS into that specification, and return the substituted    specification.  If there is no specification, return NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_exception_specification
parameter_list|(
name|tree
name|fntype
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|specs
decl_stmt|;
name|tree
name|new_specs
decl_stmt|;
name|specs
operator|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|new_specs
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|specs
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_VALUE
argument_list|(
name|specs
argument_list|)
condition|)
name|new_specs
operator|=
name|specs
expr_stmt|;
else|else
while|while
condition|(
name|specs
condition|)
block|{
name|tree
name|spec
decl_stmt|;
name|spec
operator|=
name|tsubst
argument_list|(
name|TREE_VALUE
argument_list|(
name|specs
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|error_mark_node
condition|)
return|return
name|spec
return|;
name|new_specs
operator|=
name|add_exception_specifier
argument_list|(
name|new_specs
argument_list|,
name|spec
argument_list|,
name|complain
argument_list|)
expr_stmt|;
name|specs
operator|=
name|TREE_CHAIN
argument_list|(
name|specs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|new_specs
return|;
block|}
end_function

begin_comment
comment|/* Take the tree structure T and replace template parameters used    therein with the argument vector ARGS.  IN_DECL is an associated    decl for diagnostics.  If an error occurs, returns ERROR_MARK_NODE.    Issue error and warning messages under control of COMPLAIN.  Note    that we must be relatively non-tolerant of extensions here, in    order to preserve conformance; if we allow substitutions that    should not be allowed, we may allow argument deductions that should    not succeed, and therefore report ambiguous overload situations    where there are none.  In theory, we could allow the substitution,    but indicate that it should have failed, and allow our caller to    make sure that the right thing happens, but we don't try to do this    yet.     This function is used for dealing with types, decls and the like;    for expressions, use tsubst_expr or tsubst_copy.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
operator|||
name|t
operator|==
name|integer_type_node
operator|||
name|t
operator|==
name|void_type_node
operator|||
name|t
operator|==
name|char_type_node
operator|||
name|t
operator|==
name|unknown_type_node
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst_decl
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|type
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type
operator|!=
name|unknown_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPENAME_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
name|type
operator|=
name|tsubst
argument_list|(
name|type
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
return|return
name|tsubst_aggr_type
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
return|;
case|case
name|ERROR_MARK
case|:
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
return|return
name|t
return|;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|t
operator|==
name|integer_type_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|t
return|;
block|{
name|tree
name|max
decl_stmt|,
name|omax
init|=
name|TREE_OPERAND
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|max
operator|=
name|tsubst_expr
argument_list|(
name|omax
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
name|max
operator|=
name|fold_decl_constant_value
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|!=
name|TEMPLATE_PARM_INDEX
operator|&&
operator|!
name|at_function_scope_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"array bound is not an integer constant"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [temp.deduct]  	   Type deduction may fail for any of the following 	   reasons:  	     Attempting to create an array with a size that is 	     zero or negative.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|max
argument_list|)
operator|&&
operator|!
operator|(
name|complain
operator|&
name|tf_error
operator|)
condition|)
comment|/* We must fail if performing argument deduction (as 	     indicated by the state of complain), so that 	     another substitution can be found.  */
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|max
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|INT_CST_LT
argument_list|(
name|max
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"creating array with negative size (%qE)"
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|compute_array_index_type
argument_list|(
name|NULL_TREE
argument_list|,
name|max
argument_list|)
return|;
block|}
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
block|{
name|int
name|idx
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|levels
decl_stmt|;
name|tree
name|arg
init|=
name|NULL_TREE
decl_stmt|;
name|r
operator|=
name|NULL_TREE
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|args
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|level
operator|=
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|levels
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
name|levels
condition|)
name|arg
operator|=
name|TMPL_ARG
argument_list|(
name|args
argument_list|,
name|level
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
elseif|else
if|if
condition|(
name|arg
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|int
name|quals
decl_stmt|;
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cv-quals from the template are discarded when 		   substituting in a function or reference type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|quals
operator|=
name|cp_type_quals
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|quals
operator|=
name|cp_type_quals
argument_list|(
name|arg
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|arg
argument_list|,
name|quals
argument_list|,
name|complain
operator||
name|tf_ignore_bad_quals
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
comment|/* We are processing a type constructed from a 		   template template parameter.  */
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* We can get a TEMPLATE_TEMPLATE_PARM here when we 		   are resolving nested-types in the signature of a 		   member function templates.  Otherwise ARG is a 		   TEMPLATE_DECL and is the real template to be 		   instantiated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
name|arg
operator|=
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|r
operator|=
name|lookup_template_class
argument_list|(
name|arg
argument_list|,
name|argvec
argument_list|,
name|in_decl
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|arg
argument_list|)
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|,
name|complain
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
else|else
comment|/* TEMPLATE_TEMPLATE_PARM or TEMPLATE_PARM_INDEX.  */
return|return
name|arg
return|;
block|}
if|if
condition|(
name|level
operator|==
literal|1
condition|)
comment|/* This can happen during the attempted tsubst'ing in 	     unify.  This means that we don't yet have any information 	     about the template parameter in question.  */
return|return
name|t
return|;
comment|/* If we get here, we must have been looking at a parm for a 	   more deeply nested template.  Make a new version of this 	   template parameter, but with a lower level.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
if|if
condition|(
name|cp_type_quals
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|r
operator|=
name|tsubst
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|r
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
operator||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|?
name|tf_ignore_bad_quals
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|copy_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|r
argument_list|)
operator|=
name|reduce_template_parm_level
argument_list|(
name|TEMPLATE_TYPE_PARM_INDEX
argument_list|(
name|t
argument_list|)
argument_list|,
name|r
argument_list|,
name|levels
argument_list|)
expr_stmt|;
name|TYPE_STUB_DECL
argument_list|(
name|r
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|r
argument_list|)
operator|=
name|TEMPLATE_TYPE_DECL
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
operator|=
name|r
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|r
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
name|tree
name|argvec
init|=
name|tsubst
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|argvec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO
argument_list|(
name|r
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|r
operator|=
name|reduce_template_parm_level
argument_list|(
name|t
argument_list|,
name|type
argument_list|,
name|levels
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
block|{
name|purpose
operator|=
name|tsubst
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|value
operator|=
name|tsubst
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
block|{
name|chain
operator|=
name|tsubst
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|hash_tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
case|case
name|TREE_BINFO
case|:
comment|/* We should never be tsubsting a binfo.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|TREE_VEC
case|:
comment|/* A vector of template arguments.  */
name|gcc_assert
argument_list|(
operator|!
name|type
argument_list|)
expr_stmt|;
return|return
name|tsubst_template_args
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* [temp.deduct]  	   Type deduction may fail for any of the following 	   reasons:  	   -- Attempting to create a pointer to reference type. 	   -- Attempting to create a reference to a reference type or 	      a reference to void.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|code
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
condition|)
block|{
specifier|static
name|location_t
name|last_loc
decl_stmt|;
comment|/* We keep track of the last time we issued this error 	       message to avoid spewing a ton of messages during a 	       single bad template instantiation.  */
if|if
condition|(
name|complain
operator|&
name|tf_error
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|&&
name|last_loc
operator|!=
name|input_location
else|#
directive|else
operator|&&
operator|(
name|last_loc
operator|.
name|line
operator|!=
name|input_line
operator|||
name|last_loc
operator|.
name|file
operator|!=
name|input_filename
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
name|error
argument_list|(
literal|"forming reference to void"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"forming %s to reference type %qT"
argument_list|,
operator|(
name|code
operator|==
name|POINTER_TYPE
operator|)
condition|?
literal|"pointer"
else|:
literal|"reference"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|last_loc
operator|=
name|input_location
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|r
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|r
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|r
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|r
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|error_mark_node
condition|)
comment|/* Will this ever be needed for TYPE_..._TO values?  */
name|layout_type
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|OFFSET_TYPE
case|:
block|{
name|r
operator|=
name|tsubst
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* [temp.deduct]  	       Type deduction may fail for any of the following 	       reasons:  	       -- Attempting to create "pointer to member of T" when T 		  is not a class type.  */
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"creating pointer to member of non-class type %qT"
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"creating pointer to member reference type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"creating pointer to member of type void"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* The type of the implicit object parameter gets its 	       cv-qualifiers from the FUNCTION_TYPE. */
name|tree
name|method_type
decl_stmt|;
name|tree
name|this_type
init|=
name|cp_build_qualified_type
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|r
argument_list|)
argument_list|,
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|memptr
decl_stmt|;
name|method_type
operator|=
name|build_method_type_directly
argument_list|(
name|this_type
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|memptr
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|method_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|memptr
argument_list|,
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
else|else
return|return
name|cp_build_qualified_type_real
argument_list|(
name|build_ptrmem_type
argument_list|(
name|r
argument_list|,
name|type
argument_list|)
argument_list|,
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
block|{
name|tree
name|fntype
decl_stmt|;
name|tree
name|specs
decl_stmt|;
name|fntype
operator|=
name|tsubst_function_type
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Substitute the exception specification.  */
name|specs
operator|=
name|tsubst_exception_specification
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|specs
condition|)
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|fntype
argument_list|,
name|specs
argument_list|)
expr_stmt|;
return|return
name|fntype
return|;
block|}
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|domain
init|=
name|tsubst
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* As an optimization, we avoid regenerating the array type if 	   it will obviously be the same as T.  */
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|domain
operator|==
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* These checks should match the ones in grokdeclarator.  	   [temp.deduct]  	   The deduction may fail for any of the following reasons:  	   -- Attempting to create an array with an element type that 	      is void, a function type, or a reference type, or [DR337] 	      an abstract class type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"creating array of %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_PURE_VIRTUALS
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"creating array of %qT, which is an abstract class type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|r
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
return|;
block|}
case|case
name|NEGATE_EXPR
case|:
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|e
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|e
argument_list|)
return|;
block|}
case|case
name|TYPENAME_TYPE
case|:
block|{
name|tree
name|ctx
init|=
name|tsubst_aggr_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
decl_stmt|;
name|tree
name|f
init|=
name|tsubst_copy
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|error_mark_node
operator|||
name|f
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"%qT is not a class, struct, or union type"
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|ctx
argument_list|)
operator|&&
operator|!
name|TYPE_BEING_DEFINED
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* Normally, make_typename_type does not require that the CTX 	       have complete type in order to allow things like:  		 template<class T> struct S { typename S<T>::X Y; };  	       But, such constructs have already been resolved by this 	       point, so here CTX really should have complete type, unless 	       it's a partial instantiation.  */
name|ctx
operator|=
name|complete_type
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|cxx_incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
name|f
operator|=
name|make_typename_type
argument_list|(
name|ctx
argument_list|,
name|f
argument_list|,
name|typename_type
argument_list|,
operator|(
name|complain
operator|&
name|tf_error
operator|)
operator||
name|tf_keep_type_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|error_mark_node
condition|)
return|return
name|f
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|complain
operator||=
name|tf_ignore_bad_quals
expr_stmt|;
name|f
operator|=
name|TREE_TYPE
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|!=
name|TYPENAME_TYPE
condition|)
block|{
if|if
condition|(
name|TYPENAME_IS_ENUM_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|f
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
name|error
argument_list|(
literal|"%qT resolves to %qT, which is not an enumeration type"
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPENAME_IS_CLASS_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|f
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qT resolves to %qT, which is is not a class type"
argument_list|,
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|cp_build_qualified_type_real
argument_list|(
name|f
argument_list|,
name|cp_type_quals
argument_list|(
name|f
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|t
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
block|{
name|tree
name|ctx
init|=
name|tsubst_aggr_type
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|parm_list
init|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|==
name|error_mark_node
operator|||
name|name
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|parm_list
condition|)
name|parm_list
operator|=
name|tsubst_template_parms
argument_list|(
name|parm_list
argument_list|,
name|args
argument_list|,
name|complain
argument_list|)
expr_stmt|;
return|return
name|make_unbound_class_template
argument_list|(
name|ctx
argument_list|,
name|name
argument_list|,
name|parm_list
argument_list|,
name|complain
argument_list|)
return|;
block|}
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|CALL_EXPR
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|ARRAY_REF
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|SCOPE_REF
case|:
block|{
name|tree
name|e1
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|tree
name|e2
init|=
name|tsubst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|e1
operator|==
name|error_mark_node
operator|||
name|e2
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|QUALIFIED_NAME_IS_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|TYPEOF_TYPE
case|:
block|{
name|tree
name|type
decl_stmt|;
name|type
operator|=
name|finish_typeof
argument_list|(
name|tsubst_expr
argument_list|(
name|TYPEOF_TYPE_EXPR
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cp_build_qualified_type_real
argument_list|(
name|type
argument_list|,
name|cp_type_quals
argument_list|(
name|t
argument_list|)
operator||
name|cp_type_quals
argument_list|(
name|type
argument_list|)
argument_list|,
name|complain
argument_list|)
return|;
block|}
default|default:
name|sorry
argument_list|(
literal|"use of %qs in template"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|t
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like tsubst_expr for a BASELINK.  OBJECT_TYPE, if non-NULL, is the    type of the expression on the left-hand side of the "." or "->"    operator.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_baselink
parameter_list|(
name|tree
name|baselink
parameter_list|,
name|tree
name|object_type
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|tree
name|qualifying_scope
decl_stmt|;
name|tree
name|fns
decl_stmt|;
name|tree
name|optype
decl_stmt|;
name|tree
name|template_args
init|=
literal|0
decl_stmt|;
name|bool
name|template_id_p
init|=
name|false
decl_stmt|;
comment|/* A baselink indicates a function from a base class.  Both the        BASELINK_ACCESS_BINFO and the base class referenced may        indicate bases of the template class, rather than the        instantiated class.  In addition, lookups that were not        ambiguous before may be ambiguous now.  Therefore, we perform        the lookup again.  */
name|qualifying_scope
operator|=
name|BINFO_TYPE
argument_list|(
name|BASELINK_ACCESS_BINFO
argument_list|(
name|baselink
argument_list|)
argument_list|)
expr_stmt|;
name|qualifying_scope
operator|=
name|tsubst
argument_list|(
name|qualifying_scope
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
name|optype
operator|=
name|BASELINK_OPTYPE
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|template_id_p
operator|=
name|true
expr_stmt|;
name|template_args
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_args
condition|)
name|template_args
operator|=
name|tsubst_template_args
argument_list|(
name|template_args
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|fns
argument_list|)
argument_list|)
expr_stmt|;
name|baselink
operator|=
name|lookup_fnfields
argument_list|(
name|qualifying_scope
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* If lookup found a single function, mark it as used at this        point.  (If it lookup found multiple functions the one selected        later by overload resolution will be marked as used at that        point.)  */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|baselink
argument_list|)
condition|)
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|baselink
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template_id_p
operator|&&
operator|!
name|really_overloaded_fn
argument_list|(
name|fns
argument_list|)
condition|)
name|mark_used
argument_list|(
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add back the template arguments, if present.  */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|baselink
argument_list|)
operator|&&
name|template_id_p
condition|)
name|BASELINK_FUNCTIONS
argument_list|(
name|baselink
argument_list|)
operator|=
name|build_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|BASELINK_FUNCTIONS
argument_list|(
name|baselink
argument_list|)
argument_list|,
name|template_args
argument_list|)
expr_stmt|;
comment|/* Update the conversion operator type.  */
name|BASELINK_OPTYPE
argument_list|(
name|baselink
argument_list|)
operator|=
name|tsubst
argument_list|(
name|optype
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|object_type
condition|)
name|object_type
operator|=
name|current_class_type
expr_stmt|;
return|return
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|baselink
argument_list|,
name|qualifying_scope
argument_list|,
name|object_type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like tsubst_expr for a SCOPE_REF, given by QUALIFIED_ID.  DONE is    true if the qualified-id will be a postfix-expression in-and-of    itself; false if more of the postfix-expression follows the    QUALIFIED_ID.  ADDRESS_P is true if the qualified-id is the operand    of "&".  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_qualified_id
parameter_list|(
name|tree
name|qualified_id
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|,
name|bool
name|done
parameter_list|,
name|bool
name|address_p
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|bool
name|is_template
decl_stmt|;
name|tree
name|template_args
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|qualified_id
argument_list|)
operator|==
name|SCOPE_REF
argument_list|)
expr_stmt|;
comment|/* Figure out what name to look up.  */
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|qualified_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|is_template
operator|=
name|true
expr_stmt|;
name|template_args
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_args
condition|)
name|template_args
operator|=
name|tsubst_template_args
argument_list|(
name|template_args
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|is_template
operator|=
name|false
expr_stmt|;
name|template_args
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Substitute into the qualifying scope.  When there are no ARGS, we      are just trying to simplify a non-dependent expression.  In that      case the qualifying scope may be dependent, and, in any case,      substituting will not help.  */
name|scope
operator|=
name|TREE_OPERAND
argument_list|(
name|qualified_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|scope
operator|=
name|tsubst
argument_list|(
name|scope
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|expr
operator|=
name|tsubst_copy
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
block|}
else|else
name|expr
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|scope
argument_list|,
name|expr
argument_list|,
name|QUALIFIED_NAME_IS_TEMPLATE
argument_list|(
name|qualified_id
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
comment|/* If this were actually a destructor call, it would have been 	   parsed as such by the parser.  */
name|expr
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|expr
operator|=
name|lookup_qualified_name
argument_list|(
name|scope
argument_list|,
name|expr
argument_list|,
comment|/*is_type_p=*/
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|?
name|DECL_TEMPLATE_RESULT
argument_list|(
name|expr
argument_list|)
else|:
name|expr
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
name|error
argument_list|(
literal|"dependent-name %qE is parsed as a non-type, but "
literal|"instantiation yields a type"
argument_list|,
name|qualified_id
argument_list|)
expr_stmt|;
name|inform
argument_list|(
literal|"say %<typename %E%> if a type is meant"
argument_list|,
name|qualified_id
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|check_accessibility_of_qualified_id
argument_list|(
name|expr
argument_list|,
comment|/*object_type=*/
name|NULL_TREE
argument_list|,
name|scope
argument_list|)
expr_stmt|;
comment|/* Remember that there was a reference to this entity.  */
name|mark_used
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|qualified_name_lookup_error
argument_list|(
name|scope
argument_list|,
name|TREE_OPERAND
argument_list|(
name|qualified_id
argument_list|,
literal|1
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|is_template
condition|)
name|expr
operator|=
name|lookup_template_function
argument_list|(
name|expr
argument_list|,
name|template_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
operator|&&
name|complain
operator|&
name|tf_error
condition|)
name|qualified_name_lookup_error
argument_list|(
name|scope
argument_list|,
name|TREE_OPERAND
argument_list|(
name|qualified_id
argument_list|,
literal|1
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
name|expr
operator|=
operator|(
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|expr
argument_list|,
name|scope
argument_list|,
name|current_class_type
argument_list|)
operator|)
expr_stmt|;
name|expr
operator|=
operator|(
name|finish_qualified_id_expr
argument_list|(
name|scope
argument_list|,
name|expr
argument_list|,
name|done
argument_list|,
name|address_p
argument_list|,
name|QUALIFIED_NAME_IS_TEMPLATE
argument_list|(
name|qualified_id
argument_list|)
argument_list|,
comment|/*template_arg_p=*/
name|false
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Expressions do not generally have reference type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SCOPE_REF
comment|/* However, if we're about to form a pointer-to-member, we just 	 want the referenced member referenced.  */
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|OFFSET_REF
condition|)
name|expr
operator|=
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Like tsubst, but deals with expressions.  This function just replaces    template parms; to finish processing the resultant expression, use    tsubst_expr.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_copy
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PARM_DECL
case|:
name|r
operator|=
name|retrieve_local_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
case|case
name|CONST_DECL
case|:
block|{
name|tree
name|enum_type
decl_stmt|;
name|tree
name|v
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst_copy
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
comment|/* There is no need to substitute into namespace-scope 	   enumerators.  */
if|if
condition|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* If ARGS is NULL, then T is known to be non-dependent.  */
if|if
condition|(
name|args
operator|==
name|NULL_TREE
condition|)
return|return
name|integral_constant_value
argument_list|(
name|t
argument_list|)
return|;
comment|/* Unfortunately, we cannot just call lookup_name here. 	   Consider:  	     template<int I> int f() { 	     enum E { a = I }; 	     struct S { void g() { E e = a; } }; 	     };  	   When we instantiate f<7>::S::g(), say, lookup_name is not 	   clever enough to find f<7>::a.  */
name|enum_type
operator|=
name|tsubst_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|TYPE_VALUES
argument_list|(
name|enum_type
argument_list|)
init|;
name|v
operator|!=
name|NULL_TREE
condition|;
name|v
operator|=
name|TREE_CHAIN
argument_list|(
name|v
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|v
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|v
argument_list|)
return|;
comment|/* We didn't find the name.  That should never happen; if 	     name-lookup found it during preliminary parsing, we 	     should find it again here during instantiation.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|FIELD_DECL
case|:
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|ctx
decl_stmt|;
name|ctx
operator|=
name|tsubst_aggr_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*entering_scope=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|r
init|=
name|lookup_field
argument_list|(
name|ctx
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"using invalid field %qD"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|r
return|;
block|}
block|}
return|return
name|t
return|;
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
operator|)
operator|||
name|local_variable_p
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|mark_used
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
case|case
name|BASELINK
case|:
return|return
name|tsubst_baselink
argument_list|(
name|t
argument_list|,
name|current_class_type
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
case|case
name|TEMPLATE_DECL
case|:
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
elseif|else
if|if
condition|(
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_MEMBER_TEMPLATE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
elseif|else
if|if
condition|(
name|DECL_CLASS_SCOPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|uses_template_parms
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Template template argument like the following example need 	     special treatment:  	       template<template<class> class TT> struct C {}; 	       template<class T> struct D { 		 template<class U> struct E {}; 		 C<E> c;				// #1 	       }; 	       D<int> d;				// #2  	     We are processing the template argument `E' in #1 for 	     the template instantiation #2.  Originally, `E' is a 	     TEMPLATE_DECL with `D<T>' as its DECL_CONTEXT.  Now we 	     have to substitute this with one having context `D<int>'.  */
name|tree
name|context
init|=
name|tsubst
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
return|return
name|lookup_field
argument_list|(
name|context
argument_list|,
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
return|;
block|}
else|else
comment|/* Ordinary template template argument.  */
return|return
name|t
return|;
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|NOP_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|UNARY_PLUS_EXPR
case|:
comment|/* Unary + */
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
case|case
name|ARROW_EXPR
case|:
case|case
name|THROW_EXPR
case|:
case|case
name|TYPEID_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|build1
argument_list|(
name|code
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|object
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|object
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
block|{
name|tree
name|base
init|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|name
operator|=
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|name
operator|=
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|base
argument_list|,
name|name
argument_list|,
comment|/*template_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|BASELINK
condition|)
name|name
operator|=
name|tsubst_baselink
argument_list|(
name|name
argument_list|,
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|tsubst_copy
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|object
argument_list|,
name|name
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|COMPOUND_EXPR
case|:
case|case
name|DOTSTAR_EXPR
case|:
case|case
name|MEMBER_REF
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|SCOPE_REF
case|:
return|return
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|QUALIFIED_NAME_IS_TEMPLATE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
return|return
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
return|return
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
case|case
name|MODOP_EXPR
case|:
case|case
name|PSEUDO_DTOR_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_NO_WARNING
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|NEW_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|DELETE_EXPR
case|:
block|{
name|r
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DELETE_EXPR_USE_VEC
argument_list|(
name|r
argument_list|)
operator|=
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
comment|/* Substituted template arguments */
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|fn
operator|=
name|tsubst_copy
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
name|targs
operator|=
name|tsubst_template_args
argument_list|(
name|targs
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|lookup_template_function
argument_list|(
name|fn
argument_list|,
name|targs
argument_list|)
return|;
block|}
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|tsubst_copy
argument_list|(
name|purpose
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|tsubst_copy
argument_list|(
name|value
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|tsubst_copy
argument_list|(
name|chain
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|TEMPLATE_PARM_INDEX
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|TYPENAME_TYPE
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
case|case
name|TYPEOF_TYPE
case|:
case|case
name|TYPE_DECL
case|:
return|return
name|tsubst
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
case|case
name|IDENTIFIER_NODE
case|:
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|new_type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
return|return
name|mangle_conv_op_name_for_type
argument_list|(
name|new_type
argument_list|)
return|;
block|}
else|else
return|return
name|t
return|;
case|case
name|CONSTRUCTOR
case|:
comment|/* This is handled by tsubst_copy_and_build.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|VA_ARG_EXPR
case|:
return|return
name|build_x_va_arg
argument_list|(
name|tsubst_copy
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|CLEANUP_POINT_EXPR
case|:
comment|/* We shouldn't have built any of these during initial template 	 generation.  Instead, they should be built during instantiation 	 in response to the saved STMT_IS_FULL_EXPR_P setting.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|OFFSET_REF
case|:
name|mark_used
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
default|default:
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like tsubst_copy, but specifically for OpenMP clauses.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_omp_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
name|tree
name|new_clauses
init|=
name|NULL
decl_stmt|,
name|nc
decl_stmt|,
name|oc
decl_stmt|;
for|for
control|(
name|oc
operator|=
name|clauses
init|;
name|oc
condition|;
name|oc
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|oc
argument_list|)
control|)
block|{
name|nc
operator|=
name|copy_node
argument_list|(
name|oc
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|nc
argument_list|)
operator|=
name|new_clauses
expr_stmt|;
name|new_clauses
operator|=
name|nc
expr_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|nc
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_SHARED
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
name|OMP_CLAUSE_OPERAND
argument_list|(
name|nc
argument_list|,
literal|0
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|OMP_CLAUSE_OPERAND
argument_list|(
name|oc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|finish_omp_clauses
argument_list|(
name|nreverse
argument_list|(
name|new_clauses
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like tsubst_copy_and_build, but unshare TREE_LIST nodes.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_copy_asm_operands
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
define|#
directive|define
name|RECUR
parameter_list|(
name|t
parameter_list|)
value|tsubst_copy_asm_operands (t, args, complain, in_decl)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|t
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|tsubst_copy_and_build
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*function_p=*/
name|false
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
return|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|RECUR
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|RECUR
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|RECUR
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
undef|#
directive|undef
name|RECUR
block|}
end_function

begin_comment
comment|/* Like tsubst_copy for expressions, etc. but also does semantic    processing.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_expr
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|,
name|bool
name|integral_constant_expression_p
parameter_list|)
block|{
define|#
directive|define
name|RECUR
parameter_list|(
name|NODE
parameter_list|)
define|\
value|tsubst_expr ((NODE), args, complain, in_decl,	\ 	       integral_constant_expression_p)
name|tree
name|stmt
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|t
argument_list|)
condition|)
name|input_location
operator|=
name|EXPR_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATEMENT_CODE_P
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
operator|=
name|STMT_IS_FULL_EXPR_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
name|t
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|RECUR
argument_list|(
name|tsi_stmt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CTOR_INITIALIZER
case|:
name|finish_mem_initializers
argument_list|(
name|tsubst_initializer_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
name|finish_return_stmt
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPR_STMT
case|:
name|tmp
operator|=
name|RECUR
argument_list|(
name|EXPR_STMT_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_STMT_STMT_EXPR_RESULT
argument_list|(
name|t
argument_list|)
condition|)
name|finish_stmt_expr_expr
argument_list|(
name|tmp
argument_list|,
name|cur_stmt_expr
argument_list|)
expr_stmt|;
else|else
name|finish_expr_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|USING_STMT
case|:
name|do_using_directive
argument_list|(
name|RECUR
argument_list|(
name|USING_STMT_NAMESPACE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_EXPR
case|:
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|decl
operator|=
name|DECL_EXPR_DECL
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|finish_label_decl
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|USING_DECL
condition|)
block|{
name|tree
name|scope
init|=
name|USING_DECL_SCOPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|scope
operator|=
name|RECUR
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lookup_qualified_name
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
comment|/*is_type_p=*/
name|false
argument_list|,
comment|/*complain=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|qualified_name_lookup_error
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|do_local_using_decl
argument_list|(
name|decl
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* By marking the declaration as instantiated, we avoid 		   trying to instantiate it.  Since instantiate_decl can't 		   handle local variables, and since we've already done 		   all that needs to be done, that's the right thing to 		   do.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|ANON_AGGR_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* Anonymous aggregates are a special case.  */
name|finish_anon_union
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|maybe_push_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_PRETTY_FUNCTION_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* For __PRETTY_FUNCTION__ we have to adjust the 			   initializer.  */
specifier|const
name|char
modifier|*
specifier|const
name|name
init|=
name|cxx_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|init
operator|=
name|cp_fname_init
argument_list|(
name|name
argument_list|,
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|init
operator|=
name|RECUR
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* A DECL_EXPR can also be used as an expression, in the condition 	   clause of an if/for/while construct.  */
return|return
name|decl
return|;
block|}
case|case
name|FOR_STMT
case|:
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|tmp
operator|=
name|RECUR
argument_list|(
name|FOR_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_for_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|FOR_INIT_STMT
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|finish_for_init_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|RECUR
argument_list|(
name|FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_for_cond
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|RECUR
argument_list|(
name|FOR_EXPR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_for_expr
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|WHILE_STMT
case|:
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|tmp
operator|=
name|RECUR
argument_list|(
name|WHILE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_while_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|tmp
operator|=
name|RECUR
argument_list|(
name|WHILE_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_while_stmt_cond
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|WHILE_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_while_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO_STMT
case|:
comment|/* APPLE LOCAL begin for-fsf-4_4 3274130 5295549 */
block|\
name|tmp
operator|=
name|RECUR
argument_list|(
name|DO_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_do_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* APPLE LOCAL end for-fsf-4_4 3274130 5295549 */
block|\
name|RECUR
argument_list|(
name|DO_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_do_body
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|RECUR
argument_list|(
name|DO_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_do_stmt
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_STMT
case|:
name|stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|RECUR
argument_list|(
name|IF_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|THEN_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_then_clause
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|begin_else_clause
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|ELSE_CLAUSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_else_clause
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
name|finish_if_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
if|if
condition|(
name|BIND_EXPR_BODY_BLOCK
argument_list|(
name|t
argument_list|)
condition|)
name|stmt
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
else|else
name|stmt
operator|=
name|begin_compound_stmt
argument_list|(
name|BIND_EXPR_TRY_BLOCK
argument_list|(
name|t
argument_list|)
condition|?
name|BCS_TRY_BLOCK
else|:
literal|0
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BIND_EXPR_BODY_BLOCK
argument_list|(
name|t
argument_list|)
condition|)
name|finish_function_body
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
name|finish_compound_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|BREAK_STMT
case|:
name|finish_break_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|CONTINUE_STMT
case|:
name|finish_continue_stmt
argument_list|()
expr_stmt|;
break|break;
case|case
name|SWITCH_STMT
case|:
name|stmt
operator|=
name|begin_switch_stmt
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|RECUR
argument_list|(
name|SWITCH_STMT_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_switch_cond
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|SWITCH_STMT_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_switch_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|CASE_LABEL_EXPR
case|:
name|finish_case_label
argument_list|(
name|RECUR
argument_list|(
name|CASE_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|CASE_HIGH
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
name|finish_label_stmt
argument_list|(
name|DECL_NAME
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
name|tmp
operator|=
name|GOTO_DESTINATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
comment|/* Computed goto's must be tsubst'd into.  On the other hand, 	   non-computed gotos must not be; the identifier in question 	   will have no binding.  */
name|tmp
operator|=
name|RECUR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|DECL_NAME
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|finish_goto_stmt
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|tmp
operator|=
name|finish_asm_stmt
argument_list|(
name|ASM_VOLATILE_P
argument_list|(
name|t
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|ASM_STRING
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|tsubst_copy_asm_operands
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy_asm_operands
argument_list|(
name|ASM_INPUTS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|tsubst_copy_asm_operands
argument_list|(
name|ASM_CLOBBERS
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|tree
name|asm_expr
init|=
name|tmp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|asm_expr
argument_list|)
operator|==
name|CLEANUP_POINT_EXPR
condition|)
name|asm_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|asm_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_INPUT_P
argument_list|(
name|asm_expr
argument_list|)
operator|=
name|ASM_INPUT_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TRY_BLOCK
case|:
if|if
condition|(
name|CLEANUP_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|stmt
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|RECUR
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_cleanup_try_block
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finish_cleanup
argument_list|(
name|RECUR
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|compound_stmt
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|stmt
operator|=
name|begin_function_try_block
argument_list|(
operator|&
name|compound_stmt
argument_list|)
expr_stmt|;
else|else
name|stmt
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|RECUR
argument_list|(
name|TRY_STMTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|finish_function_try_block
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
name|finish_try_block
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FN_TRY_BLOCK_P
argument_list|(
name|t
argument_list|)
condition|)
name|finish_function_handler_sequence
argument_list|(
name|stmt
argument_list|,
name|compound_stmt
argument_list|)
expr_stmt|;
else|else
name|finish_handler_sequence
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HANDLER
case|:
block|{
name|tree
name|decl
init|=
name|HANDLER_PARMS
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|decl
operator|=
name|tsubst
argument_list|(
name|decl
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Prevent instantiate_decl from trying to instantiate 	       this variable.  We've already done all that needs to be 	       done.  */
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|stmt
operator|=
name|begin_handler
argument_list|()
expr_stmt|;
name|finish_handler_parms
argument_list|(
name|decl
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|RECUR
argument_list|(
name|HANDLER_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|finish_handler
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_DEFN
case|:
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_PARALLEL
case|:
name|tmp
operator|=
name|tsubst_omp_clauses
argument_list|(
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_omp_parallel
argument_list|()
expr_stmt|;
name|RECUR
argument_list|(
name|OMP_PARALLEL_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|OMP_PARALLEL_COMBINED
argument_list|(
name|finish_omp_parallel
argument_list|(
name|tmp
argument_list|,
name|stmt
argument_list|)
argument_list|)
operator|=
name|OMP_PARALLEL_COMBINED
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
block|{
name|tree
name|clauses
decl_stmt|,
name|decl
decl_stmt|,
name|init
decl_stmt|,
name|cond
decl_stmt|,
name|incr
decl_stmt|,
name|body
decl_stmt|,
name|pre_body
decl_stmt|;
name|clauses
operator|=
name|tsubst_omp_clauses
argument_list|(
name|OMP_FOR_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|OMP_FOR_INIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|decl
operator|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
name|RECUR
argument_list|(
name|OMP_FOR_COND
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|incr
operator|=
name|RECUR
argument_list|(
name|OMP_FOR_INCR
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_omp_structured_block
argument_list|()
expr_stmt|;
name|pre_body
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|RECUR
argument_list|(
name|OMP_FOR_PRE_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pre_body
operator|=
name|pop_stmt_list
argument_list|(
name|pre_body
argument_list|)
expr_stmt|;
name|body
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|RECUR
argument_list|(
name|OMP_FOR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|pop_stmt_list
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|t
operator|=
name|finish_omp_for
argument_list|(
name|EXPR_LOCATION
argument_list|(
name|t
argument_list|)
argument_list|,
name|decl
argument_list|,
name|init
argument_list|,
name|cond
argument_list|,
name|incr
argument_list|,
name|body
argument_list|,
name|pre_body
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|OMP_FOR_CLAUSES
argument_list|(
name|t
argument_list|)
operator|=
name|clauses
expr_stmt|;
name|add_stmt
argument_list|(
name|finish_omp_structured_block
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
name|tmp
operator|=
name|tsubst_omp_clauses
argument_list|(
name|OMP_CLAUSES
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|RECUR
argument_list|(
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OMP_BODY
argument_list|(
name|t
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|OMP_CLAUSES
argument_list|(
name|t
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|add_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_CRITICAL
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
name|stmt
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|RECUR
argument_list|(
name|OMP_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|OMP_BODY
argument_list|(
name|t
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|add_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_ATOMIC
case|:
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|op0
operator|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|finish_omp_atomic
argument_list|(
name|OMP_ATOMIC_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_assert
argument_list|(
operator|!
name|STATEMENT_CODE_P
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tsubst_copy_and_build
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*function_p=*/
name|false
argument_list|,
name|integral_constant_expression_p
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
undef|#
directive|undef
name|RECUR
block|}
end_function

begin_comment
comment|/* T is a postfix-expression that is not being used in a function    call.  Return the substituted version of T.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_non_call_postfix_expression
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|t
operator|=
name|tsubst_qualified_id
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*done=*/
name|false
argument_list|,
comment|/*address_p=*/
name|false
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|tsubst_copy_and_build
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*function_p=*/
name|false
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Like tsubst but deals with expressions and performs semantic    analysis.  FUNCTION_P is true if T is the "F" in "F (ARGS)".  */
end_comment

begin_function
name|tree
name|tsubst_copy_and_build
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|,
name|tree
name|in_decl
parameter_list|,
name|bool
name|function_p
parameter_list|,
name|bool
name|integral_constant_expression_p
parameter_list|)
block|{
define|#
directive|define
name|RECUR
parameter_list|(
name|NODE
parameter_list|)
define|\
value|tsubst_copy_and_build (NODE, args, complain, in_decl, 	\
comment|/*function_p=*/
value|false,			\ 			 integral_constant_expression_p)
name|tree
name|op1
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL_TREE
operator|||
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|t
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|USING_DECL
case|:
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|IDENTIFIER_NODE
case|:
block|{
name|tree
name|decl
decl_stmt|;
name|cp_id_kind
name|idk
decl_stmt|;
name|bool
name|non_integral_constant_expression_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|error_msg
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|new_type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|t
operator|=
name|mangle_conv_op_name_for_type
argument_list|(
name|new_type
argument_list|)
expr_stmt|;
block|}
comment|/* Look up the name.  */
name|decl
operator|=
name|lookup_name
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* By convention, expressions use ERROR_MARK_NODE to indicate 	   failure, not NULL_TREE.  */
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
name|decl
operator|=
name|error_mark_node
expr_stmt|;
name|decl
operator|=
name|finish_id_expression
argument_list|(
name|t
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|idk
argument_list|,
name|integral_constant_expression_p
argument_list|,
comment|/*allow_non_integral_constant_expression_p=*/
name|false
argument_list|,
operator|&
name|non_integral_constant_expression_p
argument_list|,
comment|/*template_p=*/
name|false
argument_list|,
comment|/*done=*/
name|true
argument_list|,
comment|/*address_p=*/
name|false
argument_list|,
comment|/*template_arg_p=*/
name|false
argument_list|,
operator|&
name|error_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_msg
condition|)
name|error
argument_list|(
literal|"%s"
argument_list|,
name|error_msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|function_p
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|decl
operator|=
name|unqualified_name_lookup_error
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
case|case
name|TEMPLATE_ID_EXPR
case|:
block|{
name|tree
name|object
decl_stmt|;
name|tree
name|template
init|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|targs
condition|)
name|targs
operator|=
name|tsubst_template_args
argument_list|(
name|targs
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|template
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|object
operator|=
name|TREE_OPERAND
argument_list|(
name|template
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|template
operator|=
name|TREE_OPERAND
argument_list|(
name|template
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|object
operator|=
name|NULL_TREE
expr_stmt|;
name|template
operator|=
name|lookup_template_function
argument_list|(
name|template
argument_list|,
name|targs
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
condition|)
return|return
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|template
argument_list|)
argument_list|,
name|object
argument_list|,
name|template
argument_list|,
name|NULL_TREE
argument_list|)
return|;
else|else
return|return
name|baselink_for_fns
argument_list|(
name|template
argument_list|)
return|;
block|}
case|case
name|INDIRECT_REF
case|:
block|{
name|tree
name|r
init|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|REFERENCE_REF_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* A type conversion to reference type will be enclosed in 	       such an indirect ref, but the substitution of the cast 	       will have also added such an indirect ref.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|r
operator|=
name|convert_from_reference
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|build_x_indirect_ref
argument_list|(
name|r
argument_list|,
literal|"unary *"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|NOP_EXPR
case|:
return|return
name|build_nop
argument_list|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|integral_constant_expression_p
operator|&&
operator|!
name|cast_valid_in_integral_constant_expression_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"a cast to a type other than an integral or "
literal|"enumeration type cannot appear in a constant-expression"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|op
operator|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|CAST_EXPR
case|:
return|return
name|build_functional_cast
argument_list|(
name|type
argument_list|,
name|op
argument_list|)
return|;
case|case
name|REINTERPRET_CAST_EXPR
case|:
return|return
name|build_reinterpret_cast
argument_list|(
name|type
argument_list|,
name|op
argument_list|)
return|;
case|case
name|CONST_CAST_EXPR
case|:
return|return
name|build_const_cast
argument_list|(
name|type
argument_list|,
name|op
argument_list|)
return|;
case|case
name|DYNAMIC_CAST_EXPR
case|:
return|return
name|build_dynamic_cast
argument_list|(
name|type
argument_list|,
name|op
argument_list|)
return|;
case|case
name|STATIC_CAST_EXPR
case|:
return|return
name|build_static_cast
argument_list|(
name|type
argument_list|,
name|op
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|op1
operator|=
name|tsubst_non_call_postfix_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_x_unary_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|UNARY_PLUS_EXPR
case|:
comment|/* Unary + */
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
return|return
name|build_x_unary_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ADDR_EXPR
case|:
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|op1
operator|=
name|tsubst_qualified_id
argument_list|(
name|op1
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*done=*/
name|true
argument_list|,
comment|/*address_p=*/
name|true
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|tsubst_non_call_postfix_expression
argument_list|(
name|op1
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|LABEL_DECL
condition|)
return|return
name|finish_label_address_expr
argument_list|(
name|DECL_NAME
argument_list|(
name|op1
argument_list|)
argument_list|)
return|;
return|return
name|build_x_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|MEMBER_REF
case|:
case|case
name|DOTSTAR_EXPR
case|:
return|return
name|build_x_binary_op
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_NO_WARNING
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
name|ERROR_MARK
else|:
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_NO_WARNING
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|ERROR_MARK
else|:
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
return|;
case|case
name|SCOPE_REF
case|:
return|return
name|tsubst_qualified_id
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*done=*/
name|true
argument_list|,
comment|/*address_p=*/
name|false
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
name|op1
operator|=
name|tsubst_non_call_postfix_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
return|return
name|build_x_binary_op
argument_list|(
name|ARRAY_REF
argument_list|,
name|op1
argument_list|,
operator|(
name|TREE_NO_WARNING
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
name|ERROR_MARK
else|:
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_NO_WARNING
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|ERROR_MARK
else|:
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
return|;
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
block|{
comment|/* When there are no ARGS, we are trying to evaluate a 	     non-dependent expression from the parser.  Trying to do 	     the substitutions may not work.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|skip_evaluation
expr_stmt|;
name|op1
operator|=
name|tsubst_copy_and_build
argument_list|(
name|op1
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*function_p=*/
name|false
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
operator|--
name|skip_evaluation
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|cxx_sizeof_or_alignof_type
argument_list|(
name|op1
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|true
argument_list|)
return|;
else|else
return|return
name|cxx_sizeof_or_alignof_expr
argument_list|(
name|op1
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|MODOP_EXPR
case|:
block|{
name|tree
name|r
init|=
name|build_x_modify_expr
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* TREE_NO_WARNING must be set if either the expression was 	   parenthesized or it uses an operator such as>>= rather 	   than plain assignment.  In the former case, it was already 	   set and must be copied.  In the latter case, 	   build_x_modify_expr sets it and it must not be reset 	   here.  */
if|if
condition|(
name|TREE_NO_WARNING
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_NO_WARNING
argument_list|(
name|r
argument_list|)
operator|=
name|TREE_NO_WARNING
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|ARROW_EXPR
case|:
name|op1
operator|=
name|tsubst_non_call_postfix_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Remember that there was a reference to this entity.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|op1
argument_list|)
condition|)
name|mark_used
argument_list|(
name|op1
argument_list|)
expr_stmt|;
return|return
name|build_x_arrow
argument_list|(
name|op1
argument_list|)
return|;
case|case
name|NEW_EXPR
case|:
return|return
name|build_new
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
argument_list|)
argument_list|,
name|NEW_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|DELETE_EXPR
case|:
return|return
name|delete_sanity
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|DELETE_EXPR_USE_VEC
argument_list|(
name|t
argument_list|)
argument_list|,
name|DELETE_EXPR_USE_GLOBAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|build_x_compound_expr
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|function
decl_stmt|;
name|tree
name|call_args
decl_stmt|;
name|bool
name|qualified_p
decl_stmt|;
name|bool
name|koenig_p
decl_stmt|;
name|function
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When we parsed the expression,  we determined whether or 	   not Koenig lookup should be performed.  */
name|koenig_p
operator|=
name|KOENIG_LOOKUP_P
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|SCOPE_REF
condition|)
block|{
name|qualified_p
operator|=
name|true
expr_stmt|;
name|function
operator|=
name|tsubst_qualified_id
argument_list|(
name|function
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*done=*/
name|false
argument_list|,
comment|/*address_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|qualified_p
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SCOPE_REF
operator|||
operator|(
name|BASELINK_P
argument_list|(
name|op
argument_list|)
operator|&&
name|BASELINK_QUALIFIED_P
argument_list|(
name|op
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|qualified_p
operator|=
name|false
expr_stmt|;
name|function
operator|=
name|tsubst_copy_and_build
argument_list|(
name|function
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
operator|!
name|qualified_p
argument_list|,
name|integral_constant_expression_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|function
argument_list|)
condition|)
name|qualified_p
operator|=
name|true
expr_stmt|;
block|}
name|call_args
operator|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not perform argument-dependent lookup if normal 	   lookup finds a non-function, in accordance with the 	   expected resolution of DR 218.  */
if|if
condition|(
name|koenig_p
operator|&&
operator|(
operator|(
name|is_overloaded_fn
argument_list|(
name|function
argument_list|)
comment|/* If lookup found a member function, the Koenig lookup is 		    not appropriate, even if an unqualified-name was used 		    to denote the function.  */
operator|&&
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|get_first_fn
argument_list|(
name|function
argument_list|)
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
name|function
operator|=
name|perform_koenig_lookup
argument_list|(
name|function
argument_list|,
name|call_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|unqualified_name_lookup_error
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Remember that there was a reference to this entity.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|function
argument_list|)
condition|)
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|OFFSET_REF
condition|)
return|return
name|build_offset_ref_call_from_tree
argument_list|(
name|function
argument_list|,
name|call_args
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|finish_call_expr
argument_list|(
name|function
argument_list|,
name|call_args
argument_list|,
comment|/*disallow_virtual=*/
name|false
argument_list|,
comment|/*koenig_p=*/
name|false
argument_list|)
return|;
else|else
return|return
operator|(
name|build_new_method_call
argument_list|(
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|function
argument_list|,
literal|1
argument_list|)
argument_list|,
name|call_args
argument_list|,
name|NULL_TREE
argument_list|,
name|qualified_p
condition|?
name|LOOKUP_NONVIRTUAL
else|:
name|LOOKUP_NORMAL
argument_list|,
comment|/*fn_p=*/
name|NULL
argument_list|)
operator|)
return|;
block|}
return|return
name|finish_call_expr
argument_list|(
name|function
argument_list|,
name|call_args
argument_list|,
comment|/*disallow_virtual=*/
name|qualified_p
argument_list|,
name|koenig_p
argument_list|)
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build_x_conditional_expr
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|PSEUDO_DTOR_EXPR
case|:
return|return
name|finish_pseudo_destructor_expr
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TREE_LIST
case|:
block|{
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|void_list_node
condition|)
return|return
name|t
return|;
name|purpose
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
condition|)
name|purpose
operator|=
name|RECUR
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
name|value
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|value
operator|=
name|RECUR
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|&&
name|chain
operator|!=
name|void_type_node
condition|)
name|chain
operator|=
name|RECUR
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|purpose
operator|==
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|&&
name|value
operator|==
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|chain
operator|==
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
return|return
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
return|;
block|}
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|object
decl_stmt|;
name|tree
name|object_type
decl_stmt|;
name|tree
name|member
decl_stmt|;
name|object
operator|=
name|tsubst_non_call_postfix_expression
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* Remember that there was a reference to this entity.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|object
argument_list|)
condition|)
name|mark_used
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object_type
operator|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|member
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
name|member
operator|=
name|tsubst_baselink
argument_list|(
name|member
argument_list|,
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
else|else
name|member
operator|=
name|tsubst_copy
argument_list|(
name|member
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|object_type
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|object_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|BIT_NOT_EXPR
condition|)
return|return
name|finish_pseudo_destructor_expr
argument_list|(
name|object
argument_list|,
name|NULL_TREE
argument_list|,
name|object_type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|BIT_NOT_EXPR
operator|)
condition|)
return|return
name|finish_pseudo_destructor_expr
argument_list|(
name|object
argument_list|,
name|object
argument_list|,
name|object_type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
comment|/* Lookup the template functions now that we know what the 	       scope is.  */
name|tmpl
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|member
operator|=
name|lookup_qualified_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tmpl
argument_list|,
comment|/*is_type_p=*/
name|false
argument_list|,
comment|/*complain=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|member
argument_list|)
condition|)
block|{
name|BASELINK_FUNCTIONS
argument_list|(
name|member
argument_list|)
operator|=
name|build_nt
argument_list|(
name|TEMPLATE_ID_EXPR
argument_list|,
name|BASELINK_FUNCTIONS
argument_list|(
name|member
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|member
operator|=
operator|(
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|member
argument_list|,
name|BINFO_TYPE
argument_list|(
name|BASELINK_BINFO
argument_list|(
name|member
argument_list|)
argument_list|)
argument_list|,
name|object_type
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|qualified_name_lookup_error
argument_list|(
name|object_type
argument_list|,
name|tmpl
argument_list|,
name|member
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
operator|!
name|CLASS_TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qT is not a class or namespace"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qD is not a class or namespace"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|member
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
return|return
name|finish_non_static_data_member
argument_list|(
name|member
argument_list|,
name|object
argument_list|,
name|NULL_TREE
argument_list|)
return|;
return|return
name|finish_class_member_access_expr
argument_list|(
name|object
argument_list|,
name|member
argument_list|,
comment|/*template_p=*/
name|false
argument_list|)
return|;
block|}
case|case
name|THROW_EXPR
case|:
return|return
name|build_throw
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|n
expr_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|idx
decl_stmt|;
name|tree
name|type
init|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
name|bool
name|process_index_p
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* digest_init will do the wrong thing if we let it.  */
if|if
condition|(
name|type
operator|&&
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* We do not want to process the index of aggregate 	   initializers as they are identifier nodes which will be 	   looked up by digest_init.  */
name|process_index_p
operator|=
operator|!
operator|(
name|type
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
name|n
operator|=
name|VEC_copy
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|n
argument_list|,
name|idx
argument_list|,
name|ce
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|ce
operator|->
name|index
operator|&&
name|process_index_p
condition|)
name|ce
operator|->
name|index
operator|=
name|RECUR
argument_list|(
name|ce
operator|->
name|index
argument_list|)
expr_stmt|;
name|ce
operator|->
name|value
operator|=
name|RECUR
argument_list|(
name|ce
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|finish_compound_literal
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
return|;
return|return
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|n
argument_list|)
return|;
block|}
case|case
name|TYPEID_EXPR
case|:
block|{
name|tree
name|operand_0
init|=
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|operand_0
argument_list|)
condition|)
return|return
name|get_typeid
argument_list|(
name|operand_0
argument_list|)
return|;
return|return
name|build_typeid
argument_list|(
name|operand_0
argument_list|)
return|;
block|}
case|case
name|VAR_DECL
case|:
if|if
condition|(
operator|!
name|args
condition|)
return|return
name|t
return|;
comment|/* Fall through */
case|case
name|PARM_DECL
case|:
block|{
name|tree
name|r
init|=
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
comment|/* If the original type was a reference, we'll be wrapped in 	     the appropriate INDIRECT_REF.  */
name|r
operator|=
name|convert_from_reference
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
case|case
name|VA_ARG_EXPR
case|:
return|return
name|build_x_va_arg
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|tsubst_copy
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
argument_list|)
return|;
case|case
name|OFFSETOF_EXPR
case|:
return|return
name|finish_offsetof
argument_list|(
name|RECUR
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|STMT_EXPR
case|:
block|{
name|tree
name|old_stmt_expr
init|=
name|cur_stmt_expr
decl_stmt|;
name|tree
name|stmt_expr
init|=
name|begin_stmt_expr
argument_list|()
decl_stmt|;
name|cur_stmt_expr
operator|=
name|stmt_expr
expr_stmt|;
name|tsubst_expr
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|t
argument_list|)
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
name|integral_constant_expression_p
argument_list|)
expr_stmt|;
name|stmt_expr
operator|=
name|finish_stmt_expr
argument_list|(
name|stmt_expr
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|cur_stmt_expr
operator|=
name|old_stmt_expr
expr_stmt|;
return|return
name|stmt_expr
return|;
block|}
case|case
name|CONST_DECL
case|:
name|t
operator|=
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
expr_stmt|;
comment|/* As in finish_id_expression, we resolve enumeration constants 	 to their underlying values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|used_types_insert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
return|;
block|}
return|return
name|t
return|;
default|default:
comment|/* Handle Objective-C++ constructs, if appropriate.  */
block|{
name|tree
name|subst
init|=
name|objcp_tsubst_copy_and_build
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|,
comment|/*function_p=*/
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|subst
condition|)
return|return
name|subst
return|;
block|}
return|return
name|tsubst_copy
argument_list|(
name|t
argument_list|,
name|args
argument_list|,
name|complain
argument_list|,
name|in_decl
argument_list|)
return|;
block|}
undef|#
directive|undef
name|RECUR
block|}
end_function

begin_comment
comment|/* Verify that the instantiated ARGS are valid. For type arguments,    make sure that the type's linkage is ok. For non-type arguments,    make sure they are constants if they are integral or enumerations.    Emit an error under control of COMPLAIN, and return TRUE on error.  */
end_comment

begin_function
specifier|static
name|bool
name|check_instantiated_args
parameter_list|(
name|tree
name|tmpl
parameter_list|,
name|tree
name|args
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|int
name|ix
decl_stmt|,
name|len
init|=
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
decl_stmt|;
name|bool
name|result
init|=
name|false
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|!=
name|len
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|args
argument_list|,
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* [basic.link]: A name with no linkage (notably, the name 	     of a class or enumeration declared in a local scope) 	     shall not be used to declare an entity with linkage. 	     This implies that names with no linkage cannot be used as 	     template arguments.  */
name|tree
name|nt
init|=
name|no_linkage_check
argument_list|(
name|t
argument_list|,
comment|/*relaxed_p=*/
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|nt
condition|)
block|{
comment|/* DR 488 makes use of a type with no linkage cause 		 type deduction to fail.  */
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
block|{
if|if
condition|(
name|TYPE_ANONYMOUS_P
argument_list|(
name|nt
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qT is/uses anonymous type"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"template argument for %qD uses local type %qT"
argument_list|,
name|tmpl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|true
expr_stmt|;
block|}
comment|/* In order to avoid all sorts of complications, we do not 	     allow variably-modified types as template arguments.  */
elseif|else
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"%qT is a variably modified type"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|result
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* A non-type argument of integral or enumerated type must be a 	 constant.  */
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|&&
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"integral expression %qE is not constant"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|result
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|&&
operator|(
name|complain
operator|&
name|tf_error
operator|)
condition|)
name|error
argument_list|(
literal|"  trying to instantiate %qD"
argument_list|,
name|tmpl
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Instantiate the indicated variable or function template TMPL with    the template arguments in TARG_PTR.  */
end_comment

begin_function
name|tree
name|instantiate_template
parameter_list|(
name|tree
name|tmpl
parameter_list|,
name|tree
name|targ_ptr
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|tree
name|fndecl
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|HOST_WIDE_INT
name|saved_processing_template_decl
decl_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|)
expr_stmt|;
comment|/* If this function is a clone, handle it specially.  */
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|tmpl
argument_list|)
condition|)
block|{
name|tree
name|spec
decl_stmt|;
name|tree
name|clone
decl_stmt|;
name|spec
operator|=
name|instantiate_template
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|,
name|complain
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Look for the clone.  */
name|FOR_EACH_CLONE
argument_list|(
argument|clone
argument_list|,
argument|spec
argument_list|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|clone
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|tmpl
argument_list|)
condition|)
return|return
name|clone
return|;
comment|/* We should always have found the clone by now.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|tmpl
argument_list|,
name|targ_ptr
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|!=
name|gen_tmpl
condition|)
block|{
comment|/* The TMPL is a partial instantiation.  To get a full set of 	 arguments we must add the arguments used to perform the 	 partial instantiation.  */
name|targ_ptr
operator|=
name|add_outermost_template_args
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have this specialization.  */
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|targ_ptr
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
condition|)
return|return
name|spec
return|;
block|}
if|if
condition|(
name|check_instantiated_args
argument_list|(
name|gen_tmpl
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|targ_ptr
argument_list|)
argument_list|,
name|complain
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* We are building a FUNCTION_DECL, during which the access of its      parameters and return types have to be checked.  However this      FUNCTION_DECL which is the desired context for access checking      is not built yet.  We solve this chicken-and-egg problem by      deferring all checks until we have the FUNCTION_DECL.  */
name|push_deferring_access_checks
argument_list|(
name|dk_deferred
argument_list|)
expr_stmt|;
comment|/* Although PROCESSING_TEMPLATE_DECL may be true at this point      (because, for example, we have encountered a non-dependent      function call in the body of a template function and must now      determine which of several overloaded functions will be called),      within the instantiation itself we are not processing a      template.  */
name|saved_processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
comment|/* Substitute template parameters to obtain the specialization.  */
name|fndecl
operator|=
name|tsubst
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|,
name|targ_ptr
argument_list|,
name|complain
argument_list|,
name|gen_tmpl
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
if|if
condition|(
name|fndecl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* Now we know the specialization, compute access previously      deferred.  */
name|push_access_scope
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|perform_deferred_access_checks
argument_list|()
expr_stmt|;
name|pop_access_scope
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
comment|/* The DECL_TI_TEMPLATE should always be the immediate parent      template, not the most general template.  */
name|DECL_TI_TEMPLATE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|tmpl
expr_stmt|;
comment|/* If we've just instantiated the main entry point for a function,      instantiate all the alternate entry points as well.  We do this      by cloning the instantiation of the main entry point, not by      instantiating the template clones.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|gen_tmpl
argument_list|)
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|TREE_CHAIN
argument_list|(
name|gen_tmpl
argument_list|)
argument_list|)
condition|)
name|clone_function_decl
argument_list|(
name|fndecl
argument_list|,
comment|/*update_method_vec_p=*/
literal|0
argument_list|)
expr_stmt|;
return|return
name|fndecl
return|;
block|}
end_function

begin_comment
comment|/* The FN is a TEMPLATE_DECL for a function.  The ARGS are the    arguments that are being used when calling it.  TARGS is a vector    into which the deduced template arguments are placed.     Return zero for success, 2 for an incomplete match that doesn't resolve    all the types, and 1 for complete failure.  An error message will be    printed only for an incomplete match.     If FN is a conversion operator, or we are trying to produce a specific    specialization, RETURN_TYPE is the return type desired.     The EXPLICIT_TARGS are explicit template arguments provided via a    template-id.     The parameter STRICT is one of:     DEDUCE_CALL:      We are deducing arguments for a function call, as in      [temp.deduct.call].     DEDUCE_CONV:      We are deducing arguments for a conversion function, as in      [temp.deduct.conv].     DEDUCE_EXACT:      We are deducing arguments when doing an explicit instantiation      as in [temp.explicit], when determining an explicit specialization      as in [temp.expl.spec], or when taking the address of a function      template, as in [temp.deduct.funcaddr].  */
end_comment

begin_function
name|int
name|fn_type_unification
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|explicit_targs
parameter_list|,
name|tree
name|targs
parameter_list|,
name|tree
name|args
parameter_list|,
name|tree
name|return_type
parameter_list|,
name|unification_kind_t
name|strict
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|parms
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|int
name|result
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_targs
condition|)
block|{
comment|/* [temp.deduct]  	 The specified template arguments must match the template 	 parameters in kind (i.e., type, nontype, template), and there 	 must not be more arguments than there are parameters; 	 otherwise type deduction fails.  	 Nontype arguments must match the types of the corresponding 	 nontype template parameters, or must be convertible to the 	 types of the corresponding nontype parameters as specified in 	 _temp.arg.nontype_, otherwise type deduction fails.  	 All references in the function type of the function template 	 to the corresponding template parameters are replaced by the 	 specified template argument values.  If a substitution in a 	 template parameter or in the function type of the function 	 template results in an invalid type, type deduction fails.  */
name|int
name|i
decl_stmt|;
name|tree
name|converted_args
decl_stmt|;
name|bool
name|incomplete
decl_stmt|;
if|if
condition|(
name|explicit_targs
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
name|converted_args
operator|=
operator|(
name|coerce_template_parms
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|explicit_targs
argument_list|,
name|NULL_TREE
argument_list|,
name|tf_none
argument_list|,
comment|/*require_all_args=*/
name|false
argument_list|,
comment|/*use_default_args=*/
name|false
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|converted_args
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Substitute the explicit args into the function type.  This is 	 necessary so that, for instance, explicitly declared function 	 arguments can match null pointed constants.  If we were given 	 an incomplete set of explicit args, we must not do semantic 	 processing during substitution as we could create partial 	 instantiations.  */
name|incomplete
operator|=
name|NUM_TMPL_ARGS
argument_list|(
name|explicit_targs
argument_list|)
operator|!=
name|NUM_TMPL_ARGS
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|+=
name|incomplete
expr_stmt|;
name|fntype
operator|=
name|tsubst
argument_list|(
name|fntype
argument_list|,
name|converted_args
argument_list|,
name|tf_none
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|processing_template_decl
operator|-=
name|incomplete
expr_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Place the explicitly specified arguments in TARGS.  */
for|for
control|(
name|i
operator|=
name|NUM_TMPL_ARGS
argument_list|(
name|converted_args
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|converted_args
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Never do unification on the 'this' parameter.  */
name|parms
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
condition|)
block|{
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|return_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* We allow incomplete unification without an error message here      because the standard doesn't seem to explicitly prohibit it.  Our      callers must be ready to deal with unification failures in any      event.  */
name|result
operator|=
name|type_unification_real
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|fn
argument_list|)
argument_list|,
name|targs
argument_list|,
name|parms
argument_list|,
name|args
argument_list|,
comment|/*subr=*/
literal|0
argument_list|,
name|strict
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
comment|/* All is well so far.  Now, check:         [temp.deduct]         When all template arguments have been deduced, all uses of        template parameters in nondeduced contexts are replaced with        the corresponding deduced argument values.  If the        substitution results in an invalid type, as described above,        type deduction fails.  */
if|if
condition|(
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|targs
argument_list|,
name|tf_none
argument_list|,
name|NULL_TREE
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Adjust types before performing type deduction, as described in    [temp.deduct.call] and [temp.deduct.conv].  The rules in these two    sections are symmetric.  PARM is the type of a function parameter    or the return type of the conversion function.  ARG is the type of    the argument passed to the call, or the type of the value    initialized with the result of the conversion function.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_adjust_types_for_deduction
parameter_list|(
name|unification_kind_t
name|strict
parameter_list|,
name|tree
modifier|*
name|parm
parameter_list|,
name|tree
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
break|break;
case|case
name|DEDUCE_CONV
case|:
block|{
comment|/* Swap PARM and ARG throughout the remainder of this 	   function; the handling is precisely symmetric since PARM 	   will initialize ARG rather than vice versa.  */
name|tree
modifier|*
name|temp
init|=
name|parm
decl_stmt|;
name|parm
operator|=
name|arg
expr_stmt|;
name|arg
operator|=
name|temp
expr_stmt|;
break|break;
block|}
case|case
name|DEDUCE_EXACT
case|:
comment|/* There is nothing to do in this case.  */
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
comment|/* [temp.deduct.call]  	 If P is not a reference type:  	 --If A is an array type, the pointer type produced by the 	 array-to-pointer standard conversion (_conv.array_) is 	 used in place of A for type deduction; otherwise,  	 --If A is a function type, the pointer type produced by 	 the function-to-pointer standard conversion 	 (_conv.func_) is used in place of A for type deduction; 	 otherwise,  	 --If A is a cv-qualified type, the top level 	 cv-qualifiers of A's type are ignored for type 	 deduction.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
operator|*
name|arg
operator|=
name|build_pointer_type
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
else|else
operator|*
name|arg
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* [temp.deduct.call]       If P is a cv-qualified type, the top level cv-qualifiers      of P's type are ignored for type deduction.  If P is a      reference type, the type referred to by P is used for      type deduction.  */
operator|*
name|parm
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|parm
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
operator|*
name|parm
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|parm
argument_list|)
expr_stmt|;
name|result
operator||=
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
expr_stmt|;
block|}
comment|/* DR 322. For conversion deduction, remove a reference type on parm      too (which has been swapped into ARG).  */
if|if
condition|(
name|strict
operator|==
name|DEDUCE_CONV
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
operator|*
name|arg
operator|=
name|TREE_TYPE
argument_list|(
operator|*
name|arg
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Most parms like fn_type_unification.     If SUBR is 1, we're being called recursively (to unify the    arguments of a function or method parameter of a function    template). */
end_comment

begin_function
specifier|static
name|int
name|type_unification_real
parameter_list|(
name|tree
name|tparms
parameter_list|,
name|tree
name|targs
parameter_list|,
name|tree
name|xparms
parameter_list|,
name|tree
name|xargs
parameter_list|,
name|int
name|subr
parameter_list|,
name|unification_kind_t
name|strict
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|tree
name|parm
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|int
name|sub_strict
decl_stmt|;
name|int
name|saw_undeduced
init|=
literal|0
decl_stmt|;
name|tree
name|parms
decl_stmt|,
name|args
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|tparms
argument_list|)
operator|==
name|TREE_VEC
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|xparms
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|xparms
argument_list|)
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|xargs
operator|||
name|TREE_CODE
argument_list|(
name|xargs
argument_list|)
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ntparms
operator|>
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|strict
condition|)
block|{
case|case
name|DEDUCE_CALL
case|:
name|sub_strict
operator|=
operator|(
name|UNIFY_ALLOW_OUTER_LEVEL
operator||
name|UNIFY_ALLOW_MORE_CV_QUAL
operator||
name|UNIFY_ALLOW_DERIVED
operator|)
expr_stmt|;
break|break;
case|case
name|DEDUCE_CONV
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_LESS_CV_QUAL
expr_stmt|;
break|break;
case|case
name|DEDUCE_EXACT
case|:
name|sub_strict
operator|=
name|UNIFY_ALLOW_NONE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|again
label|:
name|parms
operator|=
name|xparms
expr_stmt|;
name|args
operator|=
name|xargs
expr_stmt|;
while|while
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|args
operator|&&
name|args
operator|!=
name|void_list_node
condition|)
block|{
name|parm
operator|=
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
comment|/* We can't deduce anything from this, but we might get all the 	   template args from other function args.  */
continue|continue;
comment|/* Conversions will be performed on a function argument that 	 corresponds with a function parameter that contains only 	 non-deducible template parameters and explicitly specified 	 template parameters.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|same_type_p
argument_list|(
name|parm
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strict
operator|!=
name|DEDUCE_EXACT
operator|&&
name|can_convert_arg
argument_list|(
name|parm
argument_list|,
name|type
argument_list|,
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|?
name|NULL_TREE
else|:
name|arg
argument_list|,
name|flags
argument_list|)
condition|)
continue|continue;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_unknown_p
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* [temp.deduct.type]   	         A template-argument can be deduced from a pointer to 		 function or pointer to member function argument if 		 the set of overloaded functions does not contain 		 function templates and at most one of a set of 		 overloaded functions provides a unique match.  */
if|if
condition|(
name|resolve_overloaded_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|)
condition|)
continue|continue;
return|return
literal|1
return|;
block|}
name|arg
operator|=
name|unlowered_expr_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
block|}
block|{
name|int
name|arg_strict
init|=
name|sub_strict
decl_stmt|;
if|if
condition|(
operator|!
name|subr
condition|)
name|arg_strict
operator||=
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|arg_strict
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* Fail if we've reached the end of the parm list, and more args      are present, and the parm list isn't variadic.  */
if|if
condition|(
name|args
operator|&&
name|args
operator|!=
name|void_list_node
operator|&&
name|parms
operator|==
name|void_list_node
condition|)
return|return
literal|1
return|;
comment|/* Fail if parms are left and they don't have default values.  */
if|if
condition|(
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parms
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|subr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|tree
name|tparm
decl_stmt|;
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|i
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is an undeduced nontype parameter that depends on 	     a type parameter, try another pass; its type may have been 	     deduced from a later argument than the one from which 	     this parameter can be deduced.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|uses_template_parms
argument_list|(
name|TREE_TYPE
argument_list|(
name|tparm
argument_list|)
argument_list|)
operator|&&
operator|!
name|saw_undeduced
operator|++
condition|)
goto|goto
name|again
goto|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of type_unification_real.  Args are like the variables    at the call site.  ARG is an overloaded function (or template-id);    we try deducing template args from each of the overloads, and if    only one succeeds, we go with that.  Modifies TARGS and returns    true on success.  */
end_comment

begin_function
specifier|static
name|bool
name|resolve_overloaded_unification
parameter_list|(
name|tree
name|tparms
parameter_list|,
name|tree
name|targs
parameter_list|,
name|tree
name|parm
parameter_list|,
name|tree
name|arg
parameter_list|,
name|unification_kind_t
name|strict
parameter_list|,
name|int
name|sub_strict
parameter_list|)
block|{
name|tree
name|tempargs
init|=
name|copy_node
argument_list|(
name|targs
argument_list|)
decl_stmt|;
name|int
name|good
init|=
literal|0
decl_stmt|;
name|bool
name|addr_p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr_p
operator|=
name|true
expr_stmt|;
block|}
else|else
name|addr_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
comment|/* Handle `&x' where `x' is some static or non-static member        function name.  */
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|OFFSET_REF
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Strip baselink information.  */
if|if
condition|(
name|BASELINK_P
argument_list|(
name|arg
argument_list|)
condition|)
name|arg
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
comment|/* If we got some explicit template args, we need to plug them into 	 the affected templates before we try to unify, in case the 	 explicit args will completely resolve the templates in question.  */
name|tree
name|expl_subargs
init|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|OVL_NEXT
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|tree
name|subargs
decl_stmt|,
name|elem
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
continue|continue;
name|subargs
operator|=
name|get_bindings
argument_list|(
name|fn
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|fn
argument_list|)
argument_list|,
name|expl_subargs
argument_list|,
comment|/*check_ret=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|subargs
condition|)
block|{
name|elem
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|subargs
argument_list|,
name|tf_none
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|good
operator|+=
name|try_one_overload
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|elem
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|,
name|addr_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OVERLOAD
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* If ARG is, for example, "(0,&f)" then its type will be unknown        -- but the deduction does not succeed because the expression is        not just the function on its own.  */
return|return
name|false
return|;
else|else
for|for
control|(
init|;
name|arg
condition|;
name|arg
operator|=
name|OVL_NEXT
argument_list|(
name|arg
argument_list|)
control|)
name|good
operator|+=
name|try_one_overload
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|TREE_TYPE
argument_list|(
name|OVL_CURRENT
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|,
name|strict
argument_list|,
name|sub_strict
argument_list|,
name|addr_p
argument_list|)
expr_stmt|;
comment|/* [temp.deduct.type] A template-argument can be deduced from a pointer      to function or pointer to member function argument if the set of      overloaded functions does not contain function templates and at most      one of a set of overloaded functions provides a unique match.       So if we found multiple possibilities, we return success but don't      deduce anything.  */
if|if
condition|(
name|good
operator|==
literal|1
condition|)
block|{
name|int
name|i
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|good
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of resolve_overloaded_unification; does deduction for a single    overload.  Fills TARGS with any deduced arguments, or error_mark_node if    different overloads deduce different arguments for a given parm.    ADDR_P is true if the expression for which deduction is being    performed was of the form "& fn" rather than simply "fn".     Returns 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|try_one_overload
parameter_list|(
name|tree
name|tparms
parameter_list|,
name|tree
name|orig_targs
parameter_list|,
name|tree
name|targs
parameter_list|,
name|tree
name|parm
parameter_list|,
name|tree
name|arg
parameter_list|,
name|unification_kind_t
name|strict
parameter_list|,
name|int
name|sub_strict
parameter_list|,
name|bool
name|addr_p
parameter_list|)
block|{
name|int
name|nargs
decl_stmt|;
name|tree
name|tempargs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* [temp.deduct.type] A template-argument can be deduced from a pointer      to function or pointer to member function argument if the set of      overloaded functions does not contain function templates and at most      one of a set of overloaded functions provides a unique match.       So if this is a template, just return success.  */
if|if
condition|(
name|uses_template_parms
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|arg
operator|=
name|build_ptrmemfunc_type
argument_list|(
name|build_pointer_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_p
condition|)
name|arg
operator|=
name|build_pointer_type
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|sub_strict
operator||=
name|maybe_adjust_types_for_deduction
argument_list|(
name|strict
argument_list|,
operator|&
name|parm
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* We don't copy orig_targs for this because if we have already deduced      some template args from previous args, unify would complain when we      try to deduce a template parameter for the same argument, even though      there isn't really a conflict.  */
name|nargs
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|tempargs
operator|=
name|make_tree_vec
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|tempargs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|,
name|sub_strict
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* First make sure we didn't deduce anything that conflicts with      explicitly specified args.  */
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|oldelt
init|=
name|TREE_VEC_ELT
argument_list|(
name|orig_targs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|elt
condition|)
comment|/*NOP*/
empty_stmt|;
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|elt
argument_list|)
condition|)
comment|/* Since we're unifying against ourselves, we will fill in 	   template args used in the function parm list with our own 	   template parms.  Discard them.  */
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|oldelt
operator|&&
operator|!
name|template_args_equal
argument_list|(
name|oldelt
argument_list|,
name|elt
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|i
operator|--
condition|;
control|)
block|{
name|tree
name|elt
init|=
name|TREE_VEC_ELT
argument_list|(
name|tempargs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
condition|)
name|TREE_VEC_ELT
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
operator|=
name|elt
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* PARM is a template class (perhaps with unbound template    parameters).  ARG is a fully instantiated type.  If ARG can be    bound to PARM, return ARG, otherwise return NULL_TREE.  TPARMS and    TARGS are as for unify.  */
end_comment

begin_function
specifier|static
name|tree
name|try_class_unification
parameter_list|(
name|tree
name|tparms
parameter_list|,
name|tree
name|targs
parameter_list|,
name|tree
name|parm
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|copy_of_targs
decl_stmt|;
if|if
condition|(
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|||
operator|(
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|!=
name|most_general_template
argument_list|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* We need to make a new template argument vector for the call to      unify.  If we used TARGS, we'd clutter it up with the result of      the attempted unification, even if this class didn't work out.      We also don't want to commit ourselves to all the unifications      we've already done, since unification is supposed to be done on      an argument-by-argument basis.  In other words, consider the      following pathological case:         template<int I, int J, int K>        struct S {};         template<int I, int J>        struct S<I, J, 2> : public S<I, I, I>, S<J, J, J> {};         template<int I, int J, int K>        void f(S<I, J, K>, S<I, I, I>);         void g() { 	 S<0, 0, 0> s0; 	 S<0, 1, 2> s2;  	 f(s0, s2);        }       Now, by the time we consider the unification involving `s2', we      already know that we must have `f<0, 0, 0>'.  But, even though      `S<0, 1, 2>' is derived from `S<0, 0, 0>', the code is invalid      because there are two ways to unify base classes of S<0, 1, 2>      with S<I, I, I>.  If we kept the already deduced knowledge, we      would reject the possibility I=1.  */
name|copy_of_targs
operator|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If unification failed, we're done.  */
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|copy_of_targs
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Given a template type PARM and a class type ARG, find the unique    base type in ARG that is an instance of PARM.  We do not examine    ARG itself; only its base-classes.  If there is not exactly one    appropriate base class, return NULL_TREE.  PARM may be the type of    a partial specialization, as well as a plain template type.  Used    by unify.  */
end_comment

begin_function
specifier|static
name|tree
name|get_template_base
parameter_list|(
name|tree
name|tparms
parameter_list|,
name|tree
name|targs
parameter_list|,
name|tree
name|parm
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|binfo
decl_stmt|;
name|gcc_assert
argument_list|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|complete_type
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|binfo
condition|)
comment|/* The type could not be completed.  */
return|return
name|NULL_TREE
return|;
comment|/* Walk in inheritance graph order.  The search order is not      important, and this avoids multiple walks of virtual bases.  */
for|for
control|(
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
init|;
name|binfo
condition|;
name|binfo
operator|=
name|TREE_CHAIN
argument_list|(
name|binfo
argument_list|)
control|)
block|{
name|tree
name|r
init|=
name|try_class_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
block|{
comment|/* If there is more than one satisfactory baseclass, then:  	       [temp.deduct.call]  	      If they yield more than one possible deduced A, the type 	      deduction fails.  	     applies.  */
if|if
condition|(
name|rval
operator|&&
operator|!
name|same_type_p
argument_list|(
name|r
argument_list|,
name|rval
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|rval
operator|=
name|r
expr_stmt|;
block|}
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Returns the level of DECL, which declares a template parameter.  */
end_comment

begin_function
specifier|static
name|int
name|template_decl_level
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
return|return
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
case|case
name|PARM_DECL
case|:
return|return
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decide whether ARG can be unified with PARM, considering only the    cv-qualifiers of each type, given STRICT as documented for unify.    Returns nonzero iff the unification is OK on that basis.  */
end_comment

begin_function
specifier|static
name|int
name|check_cv_quals_for_unify
parameter_list|(
name|int
name|strict
parameter_list|,
name|tree
name|arg
parameter_list|,
name|tree
name|parm
parameter_list|)
block|{
name|int
name|arg_quals
init|=
name|cp_type_quals
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|parm_quals
init|=
name|cp_type_quals
argument_list|(
name|parm
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|&&
operator|!
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
operator|)
condition|)
block|{
comment|/*  Although a CVR qualifier is ignored when being applied to a 	  substituted template parameter ([8.3.2]/1 for example), that 	  does not apply during deduction [14.8.2.4]/1, (even though 	  that is not explicitly mentioned, [14.8.2.4]/9 indicates 	  this).  Except when we're allowing additional CV qualifiers 	  at the outer level [14.8.2.1]/3,1st bullet.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
operator|(
name|parm_quals
operator|&
operator|(
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|)
operator|&&
operator|(
name|parm_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|strict
operator|&
operator|(
name|UNIFY_ALLOW_MORE_CV_QUAL
operator||
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
operator|)
operator|)
operator|&&
operator|(
name|arg_quals
operator|&
name|parm_quals
operator|)
operator|!=
name|parm_quals
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|strict
operator|&
operator|(
name|UNIFY_ALLOW_LESS_CV_QUAL
operator||
name|UNIFY_ALLOW_OUTER_LESS_CV_QUAL
operator|)
operator|)
operator|&&
operator|(
name|parm_quals
operator|&
name|arg_quals
operator|)
operator|!=
name|arg_quals
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Deduce the value of template parameters.  TPARMS is the (innermost)    set of template parameters to a template.  TARGS is the bindings    for those template parameters, as determined thus far; TARGS may    include template arguments for outer levels of template parameters    as well.  PARM is a parameter to a template function, or a    subcomponent of that parameter; ARG is the corresponding argument.    This function attempts to match PARM with ARG in a manner    consistent with the existing assignments in TARGS.  If more values    are deduced, then TARGS is updated.     Returns 0 if the type deduction succeeds, 1 otherwise.  The    parameter STRICT is a bitwise or of the following flags:       UNIFY_ALLOW_NONE:        Require an exact match between PARM and ARG.      UNIFY_ALLOW_MORE_CV_QUAL:        Allow the deduced ARG to be more cv-qualified (by qualification        conversion) than ARG.      UNIFY_ALLOW_LESS_CV_QUAL:        Allow the deduced ARG to be less cv-qualified than ARG.      UNIFY_ALLOW_DERIVED:        Allow the deduced ARG to be a template base class of ARG,        or a pointer to a template base class of the type pointed to by        ARG.      UNIFY_ALLOW_INTEGER:        Allow any integral type to be deduced.  See the TEMPLATE_PARM_INDEX        case for more information.      UNIFY_ALLOW_OUTER_LEVEL:        This is the outermost level of a deduction. Used to determine validity        of qualification conversions. A valid qualification conversion must        have const qualified pointers leading up to the inner type which        requires additional CV quals, except at the outer level, where const        is not required [conv.qual]. It would be normal to set this flag in        addition to setting UNIFY_ALLOW_MORE_CV_QUAL.      UNIFY_ALLOW_OUTER_MORE_CV_QUAL:        This is the outermost level of a deduction, and PARM can be more CV        qualified at this point.      UNIFY_ALLOW_OUTER_LESS_CV_QUAL:        This is the outermost level of a deduction, and PARM can be less CV        qualified at this point.  */
end_comment

begin_function
specifier|static
name|int
name|unify
parameter_list|(
name|tree
name|tparms
parameter_list|,
name|tree
name|targs
parameter_list|,
name|tree
name|parm
parameter_list|,
name|tree
name|arg
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|tree
name|targ
decl_stmt|;
name|tree
name|tparm
decl_stmt|;
name|int
name|strict_in
init|=
name|strict
decl_stmt|;
comment|/* I don't think this will do the right thing with respect to types.      But the only case I've seen it in so far has been array bounds, where      signedness is the only information lost, and I think that will be      okay.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|parm
operator|=
name|TREE_OPERAND
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|==
name|unknown_type_node
condition|)
comment|/* We can't deduce anything from this, but we might get all the        template args from other function args.  */
return|return
literal|0
return|;
comment|/* If PARM uses template parameters, then we can't bail out here,      even if ARG == PARM, since we won't record unifications for the      template parameters.  We might need them if we're trying to      figure out which of two things is more specialized.  */
if|if
condition|(
name|arg
operator|==
name|parm
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Immediately reject some pairs that won't unify because of      cv-qualification mismatches.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|arg
argument_list|)
comment|/* It is the elements of the array which hold the cv quals of an array 	 type, and the elements might be template type parms. We'll check 	 when we recurse.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
comment|/* We check the cv-qualifiers when unifying with template type 	 parameters below.  We want to allow ARG `const T' to unify with 	 PARM `T' for example, when computing which of two templates 	 is more specialized, for example.  */
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
operator|&&
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict_in
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_OUTER_LEVEL
operator|)
operator|&&
name|TYPE_P
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|CP_TYPE_CONST_P
argument_list|(
name|parm
argument_list|)
condition|)
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_MORE_CV_QUAL
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_OUTER_LEVEL
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_DERIVED
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_OUTER_MORE_CV_QUAL
expr_stmt|;
name|strict
operator|&=
operator|~
name|UNIFY_ALLOW_OUTER_LESS_CV_QUAL
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPENAME_TYPE
case|:
case|case
name|SCOPE_REF
case|:
case|case
name|UNBOUND_CLASS_TEMPLATE
case|:
comment|/* In a type which contains a nested-name-specifier, template 	 argument values cannot be deduced for template parameters used 	 within the nested-name-specifier.  */
return|return
literal|0
return|;
case|case
name|TEMPLATE_TYPE_PARM
case|:
case|case
name|TEMPLATE_TEMPLATE_PARM
case|:
case|case
name|BOUND_TEMPLATE_TEMPLATE_PARM
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tparm
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TEMPLATE_TYPE_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|same_type_p
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
return|;
name|idx
operator|=
name|TEMPLATE_TYPE_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|targs
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for mixed types and values.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
comment|/* ARG must be constructed from a template class or a template 	     template parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|BOUND_TEMPLATE_TEMPLATE_PARM
operator|&&
operator|!
name|CLASSTYPE_SPECIALIZATION_OF_PRIMARY_TEMPLATE_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
block|{
name|tree
name|parmvec
init|=
name|TYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|tree
name|argvec
init|=
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|TYPE_TI_ARGS
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|argtmplvec
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|TYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The resolution to DR150 makes clear that default 	       arguments for an N-argument may not be used to bind T 	       to a template template parameter with fewer than N 	       parameters.  It is not safe to permit the binding of 	       default arguments as an extension, as that may change 	       the meaning of a conforming program.  Consider:  		  struct Dense { static const unsigned int dim = 1; };  		  template<template<typename> class View, 			    typename Block> 		  void operator+(float, View<Block> const&);  		  template<typename Block, 			    unsigned int Dim = Block::dim> 		  struct Lvalue_proxy { operator float() const; };  		  void 		  test_1d (void) { 		    Lvalue_proxy<Dense> p; 		    float b; 		    b + p; 		  }  	      Here, if Lvalue_proxy is permitted to bind to View, then 	      the global operator+ will be used; if they are not, the 	      Lvalue_proxy will be converted to float.  */
if|if
condition|(
name|coerce_template_parms
argument_list|(
name|argtmplvec
argument_list|,
name|parmvec
argument_list|,
name|TYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|tf_none
argument_list|,
comment|/*require_all_args=*/
name|true
argument_list|,
comment|/*use_default_args=*/
name|false
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Deduce arguments T, i from TT<T> or TT<i>. 	       We check each element of PARMVEC and ARGVEC individually 	       rather than the whole TREE_VEC since they can have 	       different number of elements.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parmvec
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parmvec
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|argvec
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
name|arg
operator|=
name|TYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Fall through to deduce template name.  */
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
block|{
comment|/* Deduce template name TT from TT, TT<>, TT<T> and TT<i>.  */
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targ
operator|!=
name|NULL_TREE
operator|&&
name|template_args_equal
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targ
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* If PARM is `const T' and ARG is only `int', we don't have 	     a match unless we are allowing additional qualification. 	     If ARG is `const int' and PARM is just `T' that's OK; 	     that binds `const int' to `T'.  */
if|if
condition|(
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|strict_in
operator||
name|UNIFY_ALLOW_LESS_CV_QUAL
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Consider the case where ARG is `const volatile int' and 	     PARM is `const T'.  Then, T should be `volatile int'.  */
name|arg
operator|=
name|cp_build_qualified_type_real
argument_list|(
name|arg
argument_list|,
name|cp_type_quals
argument_list|(
name|arg
argument_list|)
operator|&
operator|~
name|cp_type_quals
argument_list|(
name|parm
argument_list|)
argument_list|,
name|tf_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
comment|/* Simple cases: Value already set, does match or doesn't.  */
if|if
condition|(
name|targ
operator|!=
name|NULL_TREE
operator|&&
name|same_type_p
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|targ
condition|)
return|return
literal|1
return|;
comment|/* Make sure that ARG is not a variable-sized array.  (Note 	     that were talking about variable-sized arrays (like 	     `int[n]'), rather than arrays of unknown size (like 	     `int[]').)  We'll get very confused by such a type since 	     the bound of the array will not be computable in an 	     instantiation.  Besides, such types are not allowed in 	     ISO C++, so we can do as we please here.  */
if|if
condition|(
name|variably_modified_type_p
argument_list|(
name|arg
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
name|TREE_VEC_ELT
argument_list|(
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|targs
argument_list|)
argument_list|,
name|idx
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
name|tparm
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|tparms
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tparm
operator|==
name|error_mark_node
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TEMPLATE_PARM_LEVEL
argument_list|(
name|parm
argument_list|)
operator|!=
name|template_decl_level
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* The PARM is not one we're trying to unify.  Just check 	   to see if it matches ARG.  */
return|return
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|&&
name|cp_tree_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
operator|)
return|;
name|idx
operator|=
name|TEMPLATE_PARM_IDX
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|targ
operator|=
name|TREE_VEC_ELT
argument_list|(
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|targs
argument_list|)
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
condition|)
return|return
operator|!
name|cp_tree_equal
argument_list|(
name|targ
argument_list|,
name|arg
argument_list|)
return|;
comment|/* [temp.deduct.type] If, in the declaration of a function template 	 with a non-type template-parameter, the non-type 	 template-parameter is used in an expression in the function 	 parameter-list and, if the corresponding template-argument is 	 deduced, the template-argument type shall match the type of the 	 template-parameter exactly, except that a template-argument 	 deduced from an array bound may be of any integral type. 	 The non-type parameter might use already deduced type parameters.  */
name|tparm
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|targs
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* Template-parameter dependent expression.  Just accept it for now. 	   It will later be processed in convert_template_argument.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|tparm
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strict
operator|&
name|UNIFY_ALLOW_INTEGER
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|tparm
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|)
condition|)
comment|/* Convert the ARG to the type of PARM; the deduced non-type 	   template argument must exactly match the types of the 	   corresponding parameter.  */
name|arg
operator|=
name|fold
argument_list|(
name|build_nop
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uses_template_parms
argument_list|(
name|tparm
argument_list|)
condition|)
comment|/* We haven't deduced the type of this parameter yet.  Try again 	   later.  */
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
name|TREE_VEC_ELT
argument_list|(
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|targs
argument_list|)
argument_list|,
name|idx
argument_list|)
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PTRMEM_CST
case|:
block|{
comment|/* A pointer-to-member constant can be unified only with 	 another constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|PTRMEM_CST
condition|)
return|return
literal|1
return|;
comment|/* Just unify the class member. It would be useless (and possibly 	 wrong, depending on the strict flags) to unify also 	 PTRMEM_CST_CLASS, because we want to be sure that both parm and 	 arg refer to the same variable, even if through different 	 classes. For instance:  	 struct A { int x; }; 	 struct B : A { };  	 Unification of&A::x and&B::x must succeed.  */
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|parm
argument_list|)
argument_list|,
name|PTRMEM_CST_MEMBER
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
block|}
case|case
name|POINTER_TYPE
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
literal|1
return|;
comment|/* [temp.deduct.call]  	   A can be another pointer or pointer to member type that can 	   be converted to the deduced A via a qualification 	   conversion (_conv.qual_).  	   We pass down STRICT here rather than UNIFY_ALLOW_NONE. 	   This will allow for additional cv-qualification of the 	   pointed-to types if appropriate.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
comment|/* The derived-to-base conversion only persists through one 	     level of pointers.  */
name|strict
operator||=
operator|(
name|strict_in
operator|&
name|UNIFY_ALLOW_DERIVED
operator|)
expr_stmt|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
block|}
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
operator|&
name|UNIFY_ALLOW_MORE_CV_QUAL
argument_list|)
return|;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|==
name|NULL_TREE
operator|)
operator|!=
operator|(
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
operator|==
name|NULL_TREE
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|parm_max
decl_stmt|;
name|tree
name|arg_max
decl_stmt|;
name|bool
name|parm_cst
decl_stmt|;
name|bool
name|arg_cst
decl_stmt|;
comment|/* Our representation of array types uses "N - 1" as the 	     TYPE_MAX_VALUE for an array with "N" elements, if "N" is 	     not an integer constant.  We cannot unify arbitrarily 	     complex expressions, so we eliminate the MINUS_EXPRs 	     here.  */
name|parm_max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
name|parm_cst
operator|=
name|TREE_CODE
argument_list|(
name|parm_max
argument_list|)
operator|==
name|INTEGER_CST
expr_stmt|;
if|if
condition|(
operator|!
name|parm_cst
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|parm_max
argument_list|)
operator|==
name|MINUS_EXPR
argument_list|)
expr_stmt|;
name|parm_max
operator|=
name|TREE_OPERAND
argument_list|(
name|parm_max
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|arg_max
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg_cst
operator|=
name|TREE_CODE
argument_list|(
name|arg_max
argument_list|)
operator|==
name|INTEGER_CST
expr_stmt|;
if|if
condition|(
operator|!
name|arg_cst
condition|)
block|{
comment|/* The ARG_MAX may not be a simple MINUS_EXPR, if we are 		 trying to unify the type of a variable with the type 		 of a template parameter.  For example:                     template<unsigned int N> 		   void f (char (&) [N]); 		   int g();  		   void h(int i) {                      char a[g(i)]; 		     f(a);                     }                  Here, the type of the ARG will be "int [g(i)]", and                 may be a SAVE_EXPR, etc.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg_max
argument_list|)
operator|!=
name|MINUS_EXPR
condition|)
return|return
literal|1
return|;
name|arg_max
operator|=
name|TREE_OPERAND
argument_list|(
name|arg_max
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If only one of the bounds used a MINUS_EXPR, compensate 	     by adding one to the other bound.  */
if|if
condition|(
name|parm_cst
operator|&&
operator|!
name|arg_cst
condition|)
name|parm_max
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|parm_max
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg_cst
operator|&&
operator|!
name|parm_cst
condition|)
name|arg_max
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg_max
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm_max
argument_list|,
name|arg_max
argument_list|,
name|UNIFY_ALLOW_INTEGER
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
operator|&
name|UNIFY_ALLOW_MORE_CV_QUAL
argument_list|)
return|;
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|VOID_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We have already checked cv-qualification at the top of the 	 function.  */
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* As far as unification is concerned, this wins.	 Later checks 	 will invalidate it if necessary.  */
return|return
literal|0
return|;
comment|/* Types INTEGER_CST and MINUS_EXPR can come from array bounds.  */
comment|/* Type INTEGER_CST can come from ordinary constant template args.  */
case|case
name|INTEGER_CST
case|:
while|while
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|1
return|;
return|return
operator|!
name|tree_int_cst_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|TREE_VEC
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_VEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
operator|!=
name|TREE_VEC_LENGTH
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|parm
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|parm
argument_list|,
name|i
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
block|}
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|strict_in
operator|&
name|UNIFY_ALLOW_DERIVED
condition|)
block|{
comment|/* First, we try to unify the PARM and ARG directly.  */
name|t
operator|=
name|try_class_unification
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
comment|/* Fallback to the special case allowed in 		     [temp.deduct.call]:  		       If P is a class, and P has the form 		       template-id, then A can be a derived class of 		       the deduced A.  Likewise, if P is a pointer to 		       a class of the form template-id, A can be a 		       pointer to a derived class pointed to by the 		       deduced A.  */
name|t
operator|=
name|get_template_base
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|parm
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|arg
argument_list|)
operator|&&
operator|(
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|parm
argument_list|)
operator|==
name|CLASSTYPE_TI_TEMPLATE
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
comment|/* Perhaps PARM is something like S<U> and ARG is S<int>. 	       Then, we should unify `int' and `U'.  */
name|t
operator|=
name|arg
expr_stmt|;
else|else
comment|/* There's no chance of unification succeeding.  */
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|parm
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|t
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|METHOD_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* CV qualifications for methods can never be deduced, they must 	 match exactly.  We need to check them explicitly here, 	 because type_unification_real treats them as any other 	 cvqualified parameter.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
operator|(
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|UNIFY_ALLOW_NONE
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|type_unification_real
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|1
argument_list|,
name|DEDUCE_EXACT
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
return|;
case|case
name|OFFSET_TYPE
case|:
comment|/* Unify a pointer to member with a pointer to member function, which 	 deduces the type of the member as a function type. */
if|if
condition|(
name|TYPE_PTRMEMFUNC_P
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|tree
name|method_type
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|cp_cv_quals
name|cv_quals
decl_stmt|;
comment|/* Check top-level cv qualifiers */
if|if
condition|(
operator|!
name|check_cv_quals_for_unify
argument_list|(
name|UNIFY_ALLOW_NONE
argument_list|,
name|arg
argument_list|,
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_PTRMEMFUNC_OBJECT_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Determine the type of the function we are unifying against. */
name|method_type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_PTRMEMFUNC_FN_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|method_type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|method_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the cv-qualifiers of the member function from the 	     implicit object parameter and place them on the function 	     type to be restored later. */
name|cv_quals
operator|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|method_type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fntype
operator|=
name|build_qualified_type
argument_list|(
name|fntype
argument_list|,
name|cv_quals
argument_list|)
expr_stmt|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|fntype
argument_list|,
name|strict
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|OFFSET_TYPE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|strict
argument_list|)
return|;
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|unify
argument_list|(
name|tparms
argument_list|,
name|targs
argument_list|,
name|DECL_INITIAL
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|,
name|strict
argument_list|)
return|;
if|if
condition|(
name|arg
operator|!=
name|integral_constant_value
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|FIELD_DECL
case|:
case|case
name|TEMPLATE_DECL
case|:
comment|/* Matched cases are handled by the ARG == PARM test above.  */
return|return
literal|1
return|;
default|default:
name|gcc_assert
argument_list|(
name|EXPR_P
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must be looking at an expression.  This can happen with 	 something like:  	   template<int I> 	   void foo(S<I>, S<I + 2>);  	 This is a "nondeduced context":  	   [deduct.type]  	   The nondeduced contexts are:  	   --A type that is a template-id in which one or more of 	     the template-arguments is an expression that references 	     a template-parameter.  	 In these cases, we assume deduction succeeded, but don't 	 actually infer any unifications.  */
if|if
condition|(
operator|!
name|uses_template_parms
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|template_args_equal
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note that DECL can be defined in this translation unit, if    required.  */
end_comment

begin_function
specifier|static
name|void
name|mark_definable
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|clone
decl_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_CLONE
argument_list|(
argument|clone
argument_list|,
argument|decl
argument_list|)
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|clone
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called if RESULT is explicitly instantiated, or is a member of an    explicitly instantiated class.  */
end_comment

begin_function
name|void
name|mark_decl_instantiated
parameter_list|(
name|tree
name|result
parameter_list|,
name|int
name|extern_p
parameter_list|)
block|{
name|SET_DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* If this entity has already been written out, it's too late to      make any modifications.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|result
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
comment|/* The TREE_PUBLIC flag for function declarations will have been        set correctly by tsubst.  */
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This might have been set by an earlier implicit instantiation.  */
name|DECL_COMDAT
argument_list|(
name|result
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extern_p
condition|)
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|result
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|mark_definable
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Always make artificials weak.  */
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|result
argument_list|)
operator|&&
name|flag_weak
condition|)
name|comdat_linkage
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* For WIN32 we also want to put explicit instantiations in 	 linkonce sections.  */
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|result
argument_list|)
condition|)
name|maybe_make_one_only
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* If EXTERN_P, then this function will not be emitted -- unless      followed by an explicit instantiation, at which point its linkage      will be adjusted.  If !EXTERN_P, then this function will be      emitted here.  In neither circumstance do we want      import_export_decl to adjust the linkage.  */
name|DECL_INTERFACE_KNOWN
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given two function templates PAT1 and PAT2, return:     1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].    -1 if PAT2 is more specialized than PAT1.    0 if neither is more specialized.     LEN indicates the number of parameters we should consider    (defaulted parameters should not be considered).     The 1998 std underspecified function template partial ordering, and    DR214 addresses the issue.  We take pairs of arguments, one from    each of the templates, and deduce them against each other.  One of    the templates will be more specialized if all the *other*    template's arguments deduce against its arguments and at least one    of its arguments *does* *not* deduce against the other template's    corresponding argument.  Deduction is done as for class templates.    The arguments used in deduction have reference and top level cv    qualifiers removed.  Iff both arguments were originally reference    types *and* deduction succeeds in both directions, the template    with the more cv-qualified argument wins for that pairing (if    neither is more cv-qualified, they both are equal).  Unlike regular    deduction, after all the arguments have been deduced in this way,    we do *not* verify the deduced template argument values can be    substituted into non-deduced contexts, nor do we have to verify    that all template arguments have been deduced.  */
end_comment

begin_function
name|int
name|more_specialized_fn
parameter_list|(
name|tree
name|pat1
parameter_list|,
name|tree
name|pat2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|decl1
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|pat1
argument_list|)
decl_stmt|;
name|tree
name|decl2
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|pat2
argument_list|)
decl_stmt|;
name|tree
name|targs1
init|=
name|make_tree_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|pat1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|targs2
init|=
name|make_tree_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|pat2
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tparms1
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|pat1
argument_list|)
decl_stmt|;
name|tree
name|tparms2
init|=
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|pat2
argument_list|)
decl_stmt|;
name|tree
name|args1
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|args2
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|better1
init|=
literal|0
decl_stmt|;
name|int
name|better2
init|=
literal|0
decl_stmt|;
comment|/* Remove the this parameter from non-static member functions.  If      one is a non-static member function and the other is not a static      member function, remove the first parameter from that function      also.  This situation occurs for operator functions where we      locate both a member function (with this pointer) and non-member      operator (with explicit first operand).  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
comment|/* LEN is the number of significant arguments for DECL1 */
name|args1
operator|=
name|TREE_CHAIN
argument_list|(
name|args1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl2
argument_list|)
condition|)
name|args2
operator|=
name|TREE_CHAIN
argument_list|(
name|args2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|decl2
argument_list|)
condition|)
block|{
name|args2
operator|=
name|TREE_CHAIN
argument_list|(
name|args2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|args1
operator|=
name|TREE_CHAIN
argument_list|(
name|args1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If only one is a conversion operator, they are unordered.  */
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl1
argument_list|)
operator|!=
name|DECL_CONV_FN_P
argument_list|(
name|decl2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Consider the return type for a conversion function */
if|if
condition|(
name|DECL_CONV_FN_P
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
name|args1
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|args1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl2
argument_list|)
argument_list|)
argument_list|,
name|args2
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|processing_template_decl
operator|++
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|args1
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|TREE_VALUE
argument_list|(
name|args2
argument_list|)
decl_stmt|;
name|int
name|deduce1
decl_stmt|,
name|deduce2
decl_stmt|;
name|int
name|quals1
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|quals2
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg1
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|quals1
operator|=
name|cp_type_quals
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|arg2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|quals2
operator|=
name|cp_type_quals
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|quals1
operator|<
literal|0
operator|)
operator|!=
operator|(
name|quals2
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* Only of the args is a reference, see if we should apply 	     array/function pointer decay to it.  This is not part of 	     DR214, but is, IMHO, consistent with the deduction rules 	     for the function call itself, and with our earlier 	     implementation of the underspecified partial ordering 	     rules.  (nathan).  */
if|if
condition|(
name|quals1
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
name|arg1
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH. */
case|case
name|FUNCTION_TYPE
case|:
name|arg1
operator|=
name|build_pointer_type
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
case|case
name|ARRAY_TYPE
case|:
name|arg2
operator|=
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH. */
case|case
name|FUNCTION_TYPE
case|:
name|arg2
operator|=
name|build_pointer_type
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|arg1
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|deduce1
operator|=
operator|!
name|unify
argument_list|(
name|tparms1
argument_list|,
name|targs1
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
expr_stmt|;
name|deduce2
operator|=
operator|!
name|unify
argument_list|(
name|tparms2
argument_list|,
name|targs2
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deduce1
condition|)
name|better2
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|deduce2
condition|)
name|better1
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|better1
operator|<
literal|0
operator|&&
name|better2
operator|<
literal|0
condition|)
comment|/* We've failed to deduce something in either direction. 	   These must be unordered.  */
break|break;
if|if
condition|(
name|deduce1
operator|&&
name|deduce2
operator|&&
name|quals1
operator|>=
literal|0
operator|&&
name|quals2
operator|>=
literal|0
condition|)
block|{
comment|/* Deduces in both directions, see if quals can 	     disambiguate.  Pretend the worse one failed to deduce. */
if|if
condition|(
operator|(
name|quals1
operator|&
name|quals2
operator|)
operator|==
name|quals2
condition|)
name|deduce1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|quals1
operator|&
name|quals2
operator|)
operator|==
name|quals1
condition|)
name|deduce2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|deduce1
operator|&&
operator|!
name|deduce2
operator|&&
operator|!
name|better2
condition|)
name|better2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|deduce2
operator|&&
operator|!
name|deduce1
operator|&&
operator|!
name|better1
condition|)
name|better1
operator|=
literal|1
expr_stmt|;
name|args1
operator|=
name|TREE_CHAIN
argument_list|(
name|args1
argument_list|)
expr_stmt|;
name|args2
operator|=
name|TREE_CHAIN
argument_list|(
name|args2
argument_list|)
expr_stmt|;
block|}
name|processing_template_decl
operator|--
expr_stmt|;
return|return
operator|(
name|better1
operator|>
literal|0
operator|)
operator|-
operator|(
name|better2
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine which of two partial specializations is more specialized.     PAT1 is a TREE_LIST whose TREE_TYPE is the _TYPE node corresponding    to the first partial specialization.  The TREE_VALUE is the    innermost set of template parameters for the partial    specialization.  PAT2 is similar, but for the second template.     Return 1 if the first partial specialization is more specialized;    -1 if the second is more specialized; 0 if neither is more    specialized.     See [temp.class.order] for information about determining which of    two templates is more specialized.  */
end_comment

begin_function
specifier|static
name|int
name|more_specialized_class
parameter_list|(
name|tree
name|pat1
parameter_list|,
name|tree
name|pat2
parameter_list|)
block|{
name|tree
name|targs
decl_stmt|;
name|tree
name|tmpl1
decl_stmt|,
name|tmpl2
decl_stmt|;
name|int
name|winner
init|=
literal|0
decl_stmt|;
name|tmpl1
operator|=
name|TREE_TYPE
argument_list|(
name|pat1
argument_list|)
expr_stmt|;
name|tmpl2
operator|=
name|TREE_TYPE
argument_list|(
name|pat2
argument_list|)
expr_stmt|;
comment|/* Just like what happens for functions, if we are ordering between      different class template specializations, we may encounter dependent      types in the arguments, and we need our dependency check functions      to behave correctly.  */
operator|++
name|processing_template_decl
expr_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat1
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|tmpl1
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|tmpl2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|--
name|winner
expr_stmt|;
name|targs
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|pat2
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|tmpl2
argument_list|)
argument_list|,
name|CLASSTYPE_TI_ARGS
argument_list|(
name|tmpl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targs
condition|)
operator|++
name|winner
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
return|return
name|winner
return|;
block|}
end_function

begin_comment
comment|/* Return the template arguments that will produce the function signature    DECL from the function template FN, with the explicit template    arguments EXPLICIT_ARGS.  If CHECK_RETTYPE is true, the return type must    also match.  Return NULL_TREE if no satisfactory arguments could be    found.  */
end_comment

begin_function
specifier|static
name|tree
name|get_bindings
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|explicit_args
parameter_list|,
name|bool
name|check_rettype
parameter_list|)
block|{
name|int
name|ntparms
init|=
name|DECL_NTPARMS
argument_list|(
name|fn
argument_list|)
decl_stmt|;
name|tree
name|targs
init|=
name|make_tree_vec
argument_list|(
name|ntparms
argument_list|)
decl_stmt|;
name|tree
name|decl_type
decl_stmt|;
name|tree
name|decl_arg_types
decl_stmt|;
comment|/* Substitute the explicit template arguments into the type of DECL.      The call to fn_type_unification will handle substitution into the      FN.  */
name|decl_type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_args
operator|&&
name|uses_template_parms
argument_list|(
name|decl_type
argument_list|)
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|converted_args
decl_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* We can get here for some invalid specializations.  */
return|return
name|NULL_TREE
return|;
name|converted_args
operator|=
name|coerce_template_parms
argument_list|(
name|DECL_INNERMOST_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|,
name|explicit_args
argument_list|,
name|NULL_TREE
argument_list|,
name|tf_none
argument_list|,
comment|/*require_all_args=*/
name|false
argument_list|,
comment|/*use_default_args=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|converted_args
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|decl_type
operator|=
name|tsubst
argument_list|(
name|decl_type
argument_list|,
name|converted_args
argument_list|,
name|tf_none
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_type
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
block|}
comment|/* Never do unification on the 'this' parameter.  */
name|decl_arg_types
operator|=
name|skip_artificial_parms_for
argument_list|(
name|decl
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|decl_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_type_unification
argument_list|(
name|fn
argument_list|,
name|explicit_args
argument_list|,
name|targs
argument_list|,
name|decl_arg_types
argument_list|,
operator|(
name|check_rettype
operator|||
name|DECL_CONV_FN_P
argument_list|(
name|fn
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|decl_type
argument_list|)
else|:
name|NULL_TREE
operator|)
argument_list|,
name|DEDUCE_EXACT
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|targs
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost template arguments that, when applied to a    template specialization whose innermost template parameters are    TPARMS, and whose specialization arguments are PARMS, yield the    ARGS.     For example, suppose we have:       template<class T, class U> struct S {};      template<class T> struct S<T*, int> {};     Then, suppose we want to get `S<double*, int>'.  The TPARMS will be    {T}, the SPEC_ARGS will be {T*, int} and the ARGS will be {double*,    int}.  The resulting vector will be {double}, indicating that `T'    is bound to `double'.  */
end_comment

begin_function
specifier|static
name|tree
name|get_class_bindings
parameter_list|(
name|tree
name|tparms
parameter_list|,
name|tree
name|spec_args
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ntparms
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|tparms
argument_list|)
decl_stmt|;
name|tree
name|deduced_args
decl_stmt|;
name|tree
name|innermost_deduced_args
decl_stmt|;
name|innermost_deduced_args
operator|=
name|make_tree_vec
argument_list|(
name|ntparms
argument_list|)
expr_stmt|;
if|if
condition|(
name|TMPL_ARGS_HAVE_MULTIPLE_LEVELS
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|deduced_args
operator|=
name|copy_node
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|deduced_args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|deduced_args
argument_list|)
argument_list|,
name|innermost_deduced_args
argument_list|)
expr_stmt|;
block|}
else|else
name|deduced_args
operator|=
name|innermost_deduced_args
expr_stmt|;
if|if
condition|(
name|unify
argument_list|(
name|tparms
argument_list|,
name|deduced_args
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|spec_args
argument_list|)
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|args
argument_list|)
argument_list|,
name|UNIFY_ALLOW_NONE
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntparms
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TREE_VEC_ELT
argument_list|(
name|innermost_deduced_args
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Verify that nondeduced template arguments agree with the type      obtained from argument deduction.       For example:         struct A { typedef int X; };        template<class T, class U> struct C {};        template<class T> struct C<T, typename T::X> {};       Then with the instantiation `C<A, int>', we can deduce that      `T' is `A' but unify () does not check whether `typename T::X'      is `int'.  */
name|spec_args
operator|=
name|tsubst
argument_list|(
name|spec_args
argument_list|,
name|deduced_args
argument_list|,
name|tf_none
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_args
operator|==
name|error_mark_node
comment|/* We only need to check the innermost arguments; the other 	 arguments will always agree.  */
operator|||
operator|!
name|comp_template_args
argument_list|(
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|spec_args
argument_list|)
argument_list|,
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|args
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|deduced_args
return|;
block|}
end_function

begin_comment
comment|/* TEMPLATES is a TREE_LIST.  Each TREE_VALUE is a TEMPLATE_DECL.    Return the TREE_LIST node with the most specialized template, if    any.  If there is no most specialized template, the error_mark_node    is returned.     Note that this function does not look at, or modify, the    TREE_PURPOSE or TREE_TYPE of any of the nodes.  Since the node    returned is one of the elements of INSTANTIATIONS, callers may    store information in the TREE_PURPOSE or TREE_TYPE of the nodes,    and retrieve it from the value returned.  */
end_comment

begin_function
name|tree
name|most_specialized_instantiation
parameter_list|(
name|tree
name|templates
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|,
name|champ
decl_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
name|champ
operator|=
name|templates
expr_stmt|;
for|for
control|(
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|templates
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
block|{
name|int
name|fate
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|get_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*check_ret=*/
name|false
argument_list|)
condition|)
name|fate
operator|--
expr_stmt|;
if|if
condition|(
name|get_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*check_ret=*/
name|false
argument_list|)
condition|)
name|fate
operator|++
expr_stmt|;
if|if
condition|(
name|fate
operator|==
operator|-
literal|1
condition|)
name|champ
operator|=
name|fn
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|fate
condition|)
block|{
comment|/* Equally specialized, move to next function.  If there 	     is no next function, nothing's most specialized.  */
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|champ
operator|=
name|fn
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|champ
condition|)
comment|/* Now verify that champ is better than everything earlier in the        instantiation list.  */
for|for
control|(
name|fn
operator|=
name|templates
init|;
name|fn
operator|!=
name|champ
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
name|get_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*check_ret=*/
name|false
argument_list|)
operator|||
operator|!
name|get_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|DECL_TEMPLATE_RESULT
argument_list|(
name|TREE_VALUE
argument_list|(
name|champ
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*check_ret=*/
name|false
argument_list|)
condition|)
block|{
name|champ
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
name|processing_template_decl
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|champ
condition|)
return|return
name|error_mark_node
return|;
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* If DECL is a specialization of some template, return the most    general such template.  Otherwise, returns NULL_TREE.     For example, given:       template<class T> struct S { template<class U> void f(U); };     if TMPL is `template<class U> void S<int>::f(U)' this will return    the full template.  This function will not trace past partial    specializations, however.  For example, given in addition:       template<class T> struct S<T*> { template<class U> void f(U); };     if TMPL is `template<class U> void S<int*>::f(U)' this will return    `template<class T> template<class U> S<T*>::f(U)'.  */
end_comment

begin_function
name|tree
name|most_general_template
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* If DECL is a FUNCTION_DECL, find the TEMPLATE_DECL of which it is      an immediate specialization.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The DECL_TI_TEMPLATE can be an IDENTIFIER_NODE for a 	   template friend.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
return|return
name|NULL_TREE
return|;
block|}
else|else
return|return
name|NULL_TREE
return|;
block|}
comment|/* Look for more and more general templates.  */
while|while
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* The DECL_TI_TEMPLATE can be an IDENTIFIER_NODE in some cases. 	 (See cp-tree.h for details.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|TEMPLATE_DECL
condition|)
break|break;
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* Stop if we run into an explicitly specialized class template.  */
if|if
condition|(
operator|!
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
break|break;
name|decl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return the most specialized of the class template partial    specializations of TMPL which can produce TYPE, a specialization of    TMPL.  The value returned is actually a TREE_LIST; the TREE_TYPE is    a _TYPE node corresponding to the partial specialization, while the    TREE_PURPOSE is the set of template arguments that must be    substituted into the TREE_TYPE in order to generate TYPE.     If the choice of partial specialization is ambiguous, a diagnostic    is issued, and the error_mark_node is returned.  If there are no    partial specializations of TMPL matching TYPE, then NULL_TREE is    returned.  */
end_comment

begin_function
specifier|static
name|tree
name|most_specialized_class
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|tmpl
parameter_list|)
block|{
name|tree
name|list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|champ
decl_stmt|;
name|int
name|fate
decl_stmt|;
name|bool
name|ambiguous_p
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_TEMPLATE_SPECIALIZATIONS
argument_list|(
name|tmpl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|partial_spec_args
decl_stmt|;
name|tree
name|spec_args
decl_stmt|;
name|partial_spec_args
operator|=
name|CLASSTYPE_TI_ARGS
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|spec_args
operator|=
name|get_class_bindings
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|partial_spec_args
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_args
condition|)
block|{
name|list
operator|=
name|tree_cons
argument_list|(
name|spec_args
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|list
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|list
condition|)
return|return
name|NULL_TREE
return|;
name|ambiguous_p
operator|=
name|false
expr_stmt|;
name|t
operator|=
name|list
expr_stmt|;
name|champ
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|==
literal|1
condition|)
empty_stmt|;
else|else
block|{
if|if
condition|(
name|fate
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|ambiguous_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|champ
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ambiguous_p
condition|)
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
operator|&&
name|t
operator|!=
name|champ
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|fate
operator|=
name|more_specialized_class
argument_list|(
name|champ
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fate
operator|!=
literal|1
condition|)
block|{
name|ambiguous_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ambiguous_p
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
literal|"candidates are:"
decl_stmt|;
name|error
argument_list|(
literal|"ambiguous class template instantiation for %q#T"
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|list
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|error
argument_list|(
literal|"%s %+#T"
argument_list|,
name|str
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"               "
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
return|return
name|champ
return|;
block|}
end_function

begin_comment
comment|/* Explicitly instantiate DECL.  */
end_comment

begin_function
name|void
name|do_decl_instantiation
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|storage
parameter_list|)
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|decl
operator|||
name|decl
operator|==
name|error_mark_node
condition|)
comment|/* An error occurred, for which grokdeclarator has already issued        an appropriate message.  */
return|return;
elseif|else
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"explicit instantiation of non-template %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* There is an asymmetry here in the way VAR_DECLs and 	 FUNCTION_DECLs are handled by grokdeclarator.  In the case of 	 the latter, the DECL we get back will be marked as a 	 template instantiation, and the appropriate 	 DECL_TEMPLATE_INFO will be set up.  This does not happen for 	 VAR_DECLs so we do the lookup here.  Probably, grokdeclarator 	 should handle VAR_DECLs as it currently handles 	 FUNCTION_DECLs.  */
name|result
operator|=
name|lookup_field
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|error
argument_list|(
literal|"no matching template for %qD found"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"explicit instantiation of %q#D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|result
operator|=
name|decl
expr_stmt|;
comment|/* Check for various error cases.  Note that if the explicit      instantiation is valid the RESULT will currently be marked as an      *implicit* instantiation; DECL_EXPLICIT_INSTANTIATION is not set      until we get here.  */
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|/* DR 259 [temp.spec].  	 Both an explicit instantiation and a declaration of an explicit 	 specialization shall not appear in a program unless the explicit 	 instantiation follows a declaration of the explicit specialization.  	 For a given set of template parameters, if an explicit 	 instantiation of a template appears after a declaration of an 	 explicit specialization for that template, the explicit 	 instantiation has no effect.  */
return|return;
block|}
elseif|else
if|if
condition|(
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall explicitly instantiate any template more 	 than once.  	 We check DECL_NOT_REALLY_EXTERN so as not to complain when 	 the first instantiation was `extern' and the second is not, 	 and EXTERN_P for the opposite case.  */
if|if
condition|(
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|extern_p
condition|)
name|pedwarn
argument_list|(
literal|"duplicate explicit instantiation of %q#D"
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|/* If an "extern" explicit instantiation follows an ordinary 	 explicit instantiation, the template is instantiated.  */
if|if
condition|(
name|extern_p
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no matching template for %qD found"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_TEMPLATE_INFO
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"explicit instantiation of non-template %q#D"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|storage
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids the use of %<extern%> on explicit "
literal|"instantiations"
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"storage class %qD applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|check_explicit_instantiation_namespace
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|mark_decl_instantiated
argument_list|(
name|result
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|result
argument_list|,
comment|/*defer_ok=*/
literal|1
argument_list|,
comment|/*expl_inst_class_mem_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_class_instantiated
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|extern_p
parameter_list|)
block|{
name|SET_CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_KNOWN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|extern_p
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|extern_p
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
block|{
name|CLASSTYPE_DEBUG_REQUESTED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from do_type_instantiation through binding_table_foreach to    do recursive instantiation for the type bound in ENTRY.  */
end_comment

begin_function
specifier|static
name|void
name|bt_instantiate_type_proc
parameter_list|(
name|binding_entry
name|entry
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|storage
init|=
operator|*
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|entry
operator|->
name|type
argument_list|)
operator|&&
operator|!
name|uses_template_parms
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|entry
operator|->
name|type
argument_list|)
argument_list|)
condition|)
name|do_type_instantiation
argument_list|(
name|TYPE_MAIN_DECL
argument_list|(
name|entry
operator|->
name|type
argument_list|)
argument_list|,
name|storage
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from do_type_instantiation to instantiate a member    (a member function or a static member variable) of an    explicitly instantiated class template.  */
end_comment

begin_function
specifier|static
name|void
name|instantiate_class_member
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|extern_p
parameter_list|)
block|{
name|mark_decl_instantiated
argument_list|(
name|decl
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extern_p
condition|)
name|instantiate_decl
argument_list|(
name|decl
argument_list|,
comment|/*defer_ok=*/
literal|1
argument_list|,
comment|/*expl_inst_class_mem_p=*/
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform an explicit instantiation of template class T.  STORAGE, if    non-null, is the RID for extern, inline or static.  COMPLAIN is    nonzero if this is called from the parser, zero if called recursively,    since the standard is unclear (as detailed below).  */
end_comment

begin_function
name|void
name|do_type_instantiation
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|storage
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
name|int
name|extern_p
init|=
literal|0
decl_stmt|;
name|int
name|nomem_p
init|=
literal|0
decl_stmt|;
name|int
name|static_p
init|=
literal|0
decl_stmt|;
name|int
name|previous_instantiation_extern_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|t
argument_list|)
operator|||
operator|!
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"explicit instantiation of non-template type %qT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"explicit instantiation of %q#T before definition of template"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|storage
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids the use of %qE on explicit instantiations"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
condition|)
name|nomem_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
name|extern_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|storage
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
condition|)
name|static_p
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"storage class %qD applied to template instantiation"
argument_list|,
name|storage
argument_list|)
expr_stmt|;
name|extern_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CLASSTYPE_TEMPLATE_SPECIALIZATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* DR 259 [temp.spec].  	 Both an explicit instantiation and a declaration of an explicit 	 specialization shall not appear in a program unless the explicit 	 instantiation follows a declaration of the explicit specialization.  	 For a given set of template parameters, if an explicit 	 instantiation of a template appears after a declaration of an 	 explicit specialization for that template, the explicit 	 instantiation has no effect.  */
return|return;
block|}
elseif|else
if|if
condition|(
name|CLASSTYPE_EXPLICIT_INSTANTIATION
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* [temp.spec]  	 No program shall explicitly instantiate any template more 	 than once.  	 If PREVIOUS_INSTANTIATION_EXTERN_P, then the first explicit 	 instantiation was `extern'.  If EXTERN_P then the second is. 	 These cases are OK.  */
name|previous_instantiation_extern_p
operator|=
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|previous_instantiation_extern_p
operator|&&
operator|!
name|extern_p
operator|&&
operator|(
name|complain
operator|&
name|tf_error
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"duplicate explicit instantiation of %q#T"
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* If we've already instantiated the template, just return now.  */
if|if
condition|(
operator|!
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
condition|)
return|return;
block|}
name|check_explicit_instantiation_namespace
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|mark_class_instantiated
argument_list|(
name|t
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nomem_p
condition|)
return|return;
block|{
name|tree
name|tmp
decl_stmt|;
comment|/* In contrast to implicit instantiation, where only the        declarations, and not the definitions, of members are        instantiated, we have here:  	 [temp.explicit]  	 The explicit instantiation of a class template specialization 	 implies the instantiation of all of its members not 	 previously explicitly specialized in the translation unit 	 containing the explicit instantiation.         Of course, we can't instantiate member template classes, since        we don't have any arguments for them.  Note that the standard        is unclear on whether the instantiation of the members are        *explicit* instantiations or not.  However, the most natural        interpretation is that it should be an explicit instantiation.  */
if|if
condition|(
operator|!
name|static_p
condition|)
for|for
control|(
name|tmp
operator|=
name|TYPE_METHODS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
name|instantiate_class_member
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
init|;
name|tmp
condition|;
name|tmp
operator|=
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmp
argument_list|)
condition|)
name|instantiate_class_member
argument_list|(
name|tmp
argument_list|,
name|extern_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|t
argument_list|)
condition|)
name|binding_table_foreach
argument_list|(
name|CLASSTYPE_NESTED_UTDS
argument_list|(
name|t
argument_list|)
argument_list|,
name|bt_instantiate_type_proc
argument_list|,
operator|&
name|storage
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a function DECL, which is a specialization of TMPL, modify    DECL to be a re-instantiation of TMPL with the same template    arguments.  TMPL should be the template into which tsubst'ing    should occur for DECL, not the most general template.     One reason for doing this is a scenario like this:       template<class T>      void f(const T&, int i);       void g() { f(3, 7); }       template<class T>      void f(const T& t, const int i) { }     Note that when the template is first instantiated, with    instantiate_template, the resulting DECL will have no name for the    first parameter, and the wrong type for the second.  So, when we go    to instantiate the DECL, we regenerate it.  */
end_comment

begin_function
specifier|static
name|void
name|regenerate_decl_from_template
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|tmpl
parameter_list|)
block|{
comment|/* The arguments used to instantiate DECL, from the most general      template.  */
name|tree
name|args
decl_stmt|;
name|tree
name|code_pattern
decl_stmt|;
name|args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
comment|/* Make sure that we can see identifiers, and compute access      correctly.  */
name|push_access_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|decl_parm
decl_stmt|;
name|tree
name|pattern_parm
decl_stmt|;
name|tree
name|specs
decl_stmt|;
name|int
name|args_depth
decl_stmt|;
name|int
name|parms_depth
decl_stmt|;
name|args_depth
operator|=
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|parms_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args_depth
operator|>
name|parms_depth
condition|)
name|args
operator|=
name|get_innermost_template_args
argument_list|(
name|args
argument_list|,
name|parms_depth
argument_list|)
expr_stmt|;
name|specs
operator|=
name|tsubst_exception_specification
argument_list|(
name|TREE_TYPE
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|build_exception_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|specs
argument_list|)
expr_stmt|;
comment|/* Merge parameter declarations.  */
name|decl_parm
operator|=
name|skip_artificial_parms_for
argument_list|(
name|decl
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|pattern_parm
operator|=
name|skip_artificial_parms_for
argument_list|(
name|code_pattern
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|code_pattern
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|decl_parm
condition|)
block|{
name|tree
name|parm_type
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl_parm
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|pattern_parm
argument_list|)
condition|)
name|DECL_NAME
argument_list|(
name|decl_parm
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|pattern_parm
argument_list|)
expr_stmt|;
name|parm_type
operator|=
name|tsubst
argument_list|(
name|TREE_TYPE
argument_list|(
name|pattern_parm
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|parm_type
operator|=
name|type_decays_to
argument_list|(
name|parm_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl_parm
argument_list|)
argument_list|,
name|parm_type
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|decl_parm
argument_list|)
operator|=
name|parm_type
expr_stmt|;
name|attributes
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|pattern_parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ATTRIBUTES
argument_list|(
name|decl_parm
argument_list|)
operator|!=
name|attributes
condition|)
block|{
name|DECL_ATTRIBUTES
argument_list|(
name|decl_parm
argument_list|)
operator|=
name|attributes
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
operator|&
name|decl_parm
argument_list|,
name|attributes
argument_list|,
comment|/*flags=*/
literal|0
argument_list|)
expr_stmt|;
block|}
name|decl_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|decl_parm
argument_list|)
expr_stmt|;
name|pattern_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|pattern_parm
argument_list|)
expr_stmt|;
block|}
comment|/* Merge additional specifiers from the CODE_PATTERN.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|code_pattern
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|code_pattern
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_error
argument_list|,
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|pop_access_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the TEMPLATE_DECL into which DECL_TI_ARGS(DECL) should be    substituted to get DECL.  */
end_comment

begin_function
name|tree
name|template_for_substitution
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Set TMPL to the template whose DECL_TEMPLATE_RESULT is the pattern      for the instantiation.  This is not always the most general      template.  Consider, for example:  	template<class T> 	struct S { template<class U> void f(); 		   template<> void f<int>(); };       and an instantiation of S<double>::f<int>.  We want TD to be the      specialization S<T>::f<int>, not the more general S<T>::f<U>.  */
while|while
condition|(
comment|/* An instantiation cannot have a definition, so we need a 	    more general template.  */
name|DECL_TEMPLATE_INSTANTIATION
argument_list|(
name|tmpl
argument_list|)
comment|/* We must also deal with friend templates.  Given:  		template<class T> struct S { 		  template<class U> friend void f() {}; 		};  	      S<int>::f<U> say, is not an instantiation of S<T>::f<U>, 	      so far as the language is concerned, but that's still 	      where we get the pattern for the instantiation from.  On 	      other hand, if the definition comes outside the class, say:  		template<class T> struct S { 		  template<class U> friend void f(); 		}; 		template<class U> friend void f() {}  	      we don't need to look any further.  That's what the check for 	      DECL_INITIAL is for.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION
argument_list|(
name|tmpl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* The present template, TD, should not be a definition.  If it 	 were a definition, we should be using it!  Note that we 	 cannot restructure the loop to just keep going until we find 	 a template with a definition, since that might go too far if 	 a specialization was declared, but not defined.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|DECL_IN_AGGR_P
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the more general template.  */
name|tmpl
operator|=
name|DECL_TI_TEMPLATE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
return|return
name|tmpl
return|;
block|}
end_function

begin_comment
comment|/* Produce the definition of D, a _DECL generated from a template.  If    DEFER_OK is nonzero, then we don't have to actually do the    instantiation now; we just have to do it sometime.  Normally it is    an error if this is an explicit instantiation but D is undefined.    EXPL_INST_CLASS_MEM_P is true iff D is a member of an    explicitly instantiated class template.  */
end_comment

begin_function
name|tree
name|instantiate_decl
parameter_list|(
name|tree
name|d
parameter_list|,
name|int
name|defer_ok
parameter_list|,
name|bool
name|expl_inst_class_mem_p
parameter_list|)
block|{
name|tree
name|tmpl
init|=
name|DECL_TI_TEMPLATE
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|tree
name|gen_args
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|tree
name|td
decl_stmt|;
name|tree
name|code_pattern
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|gen_tmpl
decl_stmt|;
name|bool
name|pattern_defined
decl_stmt|;
name|int
name|need_push
decl_stmt|;
name|location_t
name|saved_loc
init|=
name|input_location
decl_stmt|;
name|int
name|saved_in_system_header
init|=
name|in_system_header
decl_stmt|;
name|bool
name|external_p
decl_stmt|;
comment|/* This function should only be used to instantiate templates for      functions and static member variables.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
comment|/* Variables are never deferred; if instantiation is required, they      are instantiated right away.  That allows for better code in the      case that an expression refers to the value of the variable --      if the variable has a constant value the referring expression can      take advantage of that fact.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|defer_ok
operator|=
literal|0
expr_stmt|;
comment|/* Don't instantiate cloned functions.  Instead, instantiate the      functions they cloned.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|=
name|DECL_CLONED_FUNCTION
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|d
argument_list|)
condition|)
comment|/* D has already been instantiated.  It might seem reasonable to        check whether or not D is an explicit instantiation, and, if so,        stop here.  But when an explicit instantiation is deferred        until the end of the compilation, DECL_EXPLICIT_INSTANTIATION        is set, even though we still need to do the instantiation.  */
return|return
name|d
return|;
comment|/* If we already have a specialization of this declaration, then      there's no reason to instantiate it.  Note that      retrieve_specialization gives us both instantiations and      specializations, so we must explicitly check      DECL_TEMPLATE_SPECIALIZATION.  */
name|gen_tmpl
operator|=
name|most_general_template
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|gen_args
operator|=
name|DECL_TI_ARGS
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|spec
operator|=
name|retrieve_specialization
argument_list|(
name|gen_tmpl
argument_list|,
name|gen_args
argument_list|,
comment|/*class_specializations_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL_TREE
operator|&&
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|spec
argument_list|)
condition|)
return|return
name|spec
return|;
comment|/* This needs to happen before any tsubsting.  */
if|if
condition|(
operator|!
name|push_tinst_level
argument_list|(
name|d
argument_list|)
condition|)
return|return
name|d
return|;
name|timevar_push
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
comment|/* Set TD to the template whose DECL_TEMPLATE_RESULT is the pattern      for the instantiation.  */
name|td
operator|=
name|template_for_substitution
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|code_pattern
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* We should never be trying to instantiate a member of a class      template or partial specialization.  */
name|gcc_assert
argument_list|(
name|d
operator|!=
name|code_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|DECL_NAMESPACE_SCOPE_P
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|DECL_INITIALIZED_IN_CLASS_P
argument_list|(
name|d
argument_list|)
operator|)
operator|||
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|td
argument_list|)
condition|)
comment|/* In the case of a friend template whose definition is provided        outside the class, we may have too many arguments.  Drop the        ones we don't need.  The same is true for specializations.  */
name|args
operator|=
name|get_innermost_template_args
argument_list|(
name|gen_args
argument_list|,
name|TMPL_PARMS_DEPTH
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|td
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|args
operator|=
name|gen_args
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|pattern_defined
operator|=
operator|(
name|DECL_SAVED_TREE
argument_list|(
name|code_pattern
argument_list|)
operator|!=
name|NULL_TREE
operator|)
expr_stmt|;
else|else
name|pattern_defined
operator|=
operator|!
name|DECL_IN_AGGR_P
argument_list|(
name|code_pattern
argument_list|)
expr_stmt|;
comment|/* We may be in the middle of deferred access check.  Disable it now.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
comment|/* Unless an explicit instantiation directive has already determined      the linkage of D, remember that a definition is available for      this entity.  */
if|if
condition|(
name|pattern_defined
operator|&&
operator|!
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
condition|)
name|mark_definable
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|in_system_header
operator|=
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* If D is a member of an explicitly instantiated class template,      and no definition is available, treat it like an implicit      instantiation.  */
if|if
condition|(
operator|!
name|pattern_defined
operator|&&
name|expl_inst_class_mem_p
operator|&&
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SET_DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|defer_ok
condition|)
block|{
comment|/* Recheck the substitutions to obtain any warning messages 	 about ignoring cv qualifiers.  */
name|tree
name|gen
init|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|gen_tmpl
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|gen
argument_list|)
decl_stmt|;
comment|/* Make sure that we can see identifiers, and compute access 	 correctly.  D is already the target FUNCTION_DECL with the 	 right context.  */
name|push_access_scope
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|gen
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tsubst
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|gen
argument_list|)
argument_list|,
name|gen_args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|tsubst
argument_list|(
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|type
argument_list|)
argument_list|,
name|gen_args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Don't simply tsubst the function type, as that will give 	     duplicate warnings about poor parameter qualifications. 	     The function arguments are the same as the decl_arguments 	     without the top level cv qualifiers.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|tsubst
argument_list|(
name|type
argument_list|,
name|gen_args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|pop_access_scope
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see whether we know that this template will be      instantiated in some other file, as with "extern template"      extension.  */
name|external_p
operator|=
operator|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|d
argument_list|)
operator|&&
name|DECL_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|)
expr_stmt|;
comment|/* In general, we do not instantiate such templates...  */
if|if
condition|(
name|external_p
comment|/* ... but we instantiate inline functions so that we can inline 	 them and ... */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|d
argument_list|)
operator|)
comment|/* ... we instantiate static data members whose values are 	 needed in integral constant expressions.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P
argument_list|(
name|d
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* Defer all other templates, unless we have been explicitly      forbidden from doing so.  */
if|if
condition|(
comment|/* If there is no definition, we cannot instantiate the 	 template.  */
operator|!
name|pattern_defined
comment|/* If it's OK to postpone instantiation, do so.  */
operator|||
name|defer_ok
comment|/* If this is a static data member that will be defined 	 elsewhere, we don't want to instantiate the entire data 	 member, but we do want to instantiate the initializer so that 	 we can substitute that elsewhere.  */
operator|||
operator|(
name|external_p
operator|&&
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
block|{
comment|/* The definition of the static data member is now required so 	 we must substitute the initializer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
condition|)
block|{
name|tree
name|ns
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|ns
operator|=
name|decl_namespace_context
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|push_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
name|cp_finish_decl
argument_list|(
name|d
argument_list|,
name|init
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
comment|/*asmspec_tree=*/
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|pop_nested_class
argument_list|()
expr_stmt|;
name|pop_nested_namespace
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
comment|/* We restore the source position here because it's used by 	 add_pending_template.  */
name|input_location
operator|=
name|saved_loc
expr_stmt|;
if|if
condition|(
name|at_eof
operator|&&
operator|!
name|pattern_defined
operator|&&
name|DECL_EXPLICIT_INSTANTIATION
argument_list|(
name|d
argument_list|)
condition|)
comment|/* [temp.explicit]  	   The definition of a non-exported function template, a 	   non-exported member function template, or a non-exported 	   member function or static data member of a class template 	   shall be present in every translation unit in which it is 	   explicitly instantiated.  */
name|pedwarn
argument_list|(
literal|"explicit instantiation of %qD but no definition available"
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* ??? Historically, we have instantiated inline functions, even 	 when marked as "extern template".  */
if|if
condition|(
operator|!
operator|(
name|external_p
operator|&&
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
operator|)
condition|)
name|add_pending_template
argument_list|(
name|d
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Tell the repository that D is available in this translation unit      -- and see if it is supposed to be instantiated here.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|DECL_REALLY_EXTERN
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
name|repo_emit_p
argument_list|(
name|d
argument_list|)
condition|)
block|{
comment|/* In a PCH file, despite the fact that the repository hasn't 	 requested instantiation in the PCH it is still possible that 	 an instantiation will be required in a file that includes the 	 PCH.  */
if|if
condition|(
name|pch_file
condition|)
name|add_pending_template
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Instantiate inline functions so that the inliner can do its 	 job, even though we'll not be emitting a copy of this 	 function.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|flag_inline_trees
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|d
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
name|need_push
operator|=
operator|!
name|cfun
operator|||
operator|!
name|global_bindings_p
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_push
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
comment|/* Mark D as instantiated so that recursive calls to      instantiate_decl do not try to instantiate it again.  */
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|d
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Regenerate the declaration in case the template has been modified      by a subsequent redeclaration.  */
name|regenerate_decl_from_template
argument_list|(
name|d
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* We already set the file and line above.  Reset them now in case      they changed as a result of calling regenerate_decl_from_template.  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|init
decl_stmt|;
comment|/* Clear out DECL_RTL; whatever was there before may not be right 	 since we've reset the type of the declaration.  */
name|SET_DECL_RTL
argument_list|(
name|d
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The initializer is placed in DECL_INITIAL by 	 regenerate_decl_from_template.  Pull it out so that 	 finish_decl can process it.  */
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|d
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_INITIALIZED_P
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear DECL_EXTERNAL so that cp_finish_decl will process the 	 initializer.  That function will defer actual emission until 	 we have a chance to determine linkage.  */
name|DECL_EXTERNAL
argument_list|(
name|d
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Enter the scope of D so that access-checking works correctly.  */
name|push_nested_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|d
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_nested_class
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|d
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|htab_t
name|saved_local_specializations
decl_stmt|;
name|tree
name|subst_decl
decl_stmt|;
name|tree
name|tmpl_parm
decl_stmt|;
name|tree
name|spec_parm
decl_stmt|;
comment|/* Save away the current list, in case we are instantiating one 	 template from within the body of another.  */
name|saved_local_specializations
operator|=
name|local_specializations
expr_stmt|;
comment|/* Set up the list of local specializations.  */
name|local_specializations
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|hash_local_specialization
argument_list|,
name|eq_local_specializations
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set up context.  */
name|start_preparsed_function
argument_list|(
name|d
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* Create substitution entries for the parameters.  */
name|subst_decl
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|template_for_substitution
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|tmpl_parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|subst_decl
argument_list|)
expr_stmt|;
name|spec_parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|register_local_specialization
argument_list|(
name|spec_parm
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
name|spec_parm
operator|=
name|skip_artificial_parms_for
argument_list|(
name|d
argument_list|,
name|spec_parm
argument_list|)
expr_stmt|;
name|tmpl_parm
operator|=
name|skip_artificial_parms_for
argument_list|(
name|subst_decl
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|tmpl_parm
condition|)
block|{
name|register_local_specialization
argument_list|(
name|spec_parm
argument_list|,
name|tmpl_parm
argument_list|)
expr_stmt|;
name|tmpl_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|tmpl_parm
argument_list|)
expr_stmt|;
name|spec_parm
operator|=
name|TREE_CHAIN
argument_list|(
name|spec_parm
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|spec_parm
argument_list|)
expr_stmt|;
comment|/* Substitute into the body of the function.  */
name|tsubst_expr
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|code_pattern
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|tmpl
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
comment|/* We don't need the local specializations any more.  */
name|htab_delete
argument_list|(
name|local_specializations
argument_list|)
expr_stmt|;
name|local_specializations
operator|=
name|saved_local_specializations
expr_stmt|;
comment|/* Finish the function.  */
name|d
operator|=
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_or_defer_fn
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* We're not deferring instantiation any more.  */
name|TI_PENDING_TEMPLATE_FLAG
argument_list|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|d
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_push
condition|)
name|pop_from_top_level
argument_list|()
expr_stmt|;
name|out
label|:
name|input_location
operator|=
name|saved_loc
expr_stmt|;
name|in_system_header
operator|=
name|saved_in_system_header
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
name|pop_tinst_level
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_PARSE
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Run through the list of templates that we wish we could    instantiate, and instantiate any we can.  RETRIES is the    number of times we retry pending template instantiation.  */
end_comment

begin_function
name|void
name|instantiate_pending_templates
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
name|tree
modifier|*
name|t
decl_stmt|;
name|tree
name|last
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|reconsider
decl_stmt|;
name|location_t
name|saved_loc
init|=
name|input_location
decl_stmt|;
name|int
name|saved_in_system_header
init|=
name|in_system_header
decl_stmt|;
comment|/* Instantiating templates may trigger vtable generation.  This in turn      may require further template instantiations.  We place a limit here      to avoid infinite loop.  */
if|if
condition|(
name|pending_templates
operator|&&
name|retries
operator|>=
name|max_tinst_depth
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|pending_templates
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"template instantiation depth exceeds maximum of %d"
literal|" instantiating %q+D, possibly from virtual table generation"
literal|" (use -ftemplate-depth-NN to increase the maximum)"
argument_list|,
name|max_tinst_depth
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* Pretend that we defined it.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return;
block|}
do|do
block|{
name|reconsider
operator|=
literal|0
expr_stmt|;
name|t
operator|=
operator|&
name|pending_templates
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
name|tree
name|instantiation
init|=
name|TREE_VALUE
argument_list|(
operator|*
name|t
argument_list|)
decl_stmt|;
name|reopen_tinst_level
argument_list|(
name|TREE_PURPOSE
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|tree
name|fn
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiate_class_template
argument_list|(
name|instantiation
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_TEMPLATE_INSTANTIATION
argument_list|(
name|instantiation
argument_list|)
condition|)
for|for
control|(
name|fn
operator|=
name|TYPE_METHODS
argument_list|(
name|instantiation
argument_list|)
init|;
name|fn
condition|;
name|fn
operator|=
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
control|)
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
condition|)
name|instantiate_decl
argument_list|(
name|fn
argument_list|,
comment|/*defer_ok=*/
literal|0
argument_list|,
comment|/*expl_inst_class_mem_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|instantiation
argument_list|)
condition|)
comment|/* If INSTANTIATION has been instantiated, then we don't 		   need to consider it again in the future.  */
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|last
operator|=
operator|*
name|t
expr_stmt|;
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|instantiation
argument_list|)
operator|&&
operator|!
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
block|{
name|instantiation
operator|=
name|instantiate_decl
argument_list|(
name|instantiation
argument_list|,
comment|/*defer_ok=*/
literal|0
argument_list|,
comment|/*expl_inst_class_mem_p=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
name|reconsider
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_TEMPLATE_SPECIALIZATION
argument_list|(
name|instantiation
argument_list|)
operator|||
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|instantiation
argument_list|)
condition|)
comment|/* If INSTANTIATION has been instantiated, then we don't 		   need to consider it again in the future.  */
operator|*
name|t
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|last
operator|=
operator|*
name|t
expr_stmt|;
name|t
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|tinst_depth
operator|=
literal|0
expr_stmt|;
name|current_tinst_level
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|last_pending_template
operator|=
name|last
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
name|input_location
operator|=
name|saved_loc
expr_stmt|;
name|in_system_header
operator|=
name|saved_in_system_header
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Substitute ARGVEC into T, which is a list of initializers for    either base class or a non-static data member.  The TREE_PURPOSEs    are DECLs, and the TREE_VALUEs are the initializer values.  Used by    instantiate_decl.  */
end_comment

begin_function
specifier|static
name|tree
name|tsubst_initializer_list
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|argvec
parameter_list|)
block|{
name|tree
name|inits
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
name|decl
operator|=
name|tsubst_copy
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|expand_member_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|in_base_initializer
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|tsubst_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
name|argvec
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*integral_constant_expression_p=*/
name|false
argument_list|)
expr_stmt|;
name|in_base_initializer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|init
operator|=
name|build_tree_list
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|=
name|inits
expr_stmt|;
name|inits
operator|=
name|init
expr_stmt|;
block|}
block|}
return|return
name|inits
return|;
block|}
end_function

begin_comment
comment|/* Set CURRENT_ACCESS_SPECIFIER based on the protection of DECL.  */
end_comment

begin_function
specifier|static
name|void
name|set_current_access_from_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|current_access_specifier
operator|=
name|access_private_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|current_access_specifier
operator|=
name|access_protected_node
expr_stmt|;
else|else
name|current_access_specifier
operator|=
name|access_public_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Instantiate an enumerated type.  TAG is the template type, NEWTAG    is the instantiation (which should have been created with    start_enum) and ARGS are the template arguments to use.  */
end_comment

begin_function
specifier|static
name|void
name|tsubst_enum
parameter_list|(
name|tree
name|tag
parameter_list|,
name|tree
name|newtag
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|tree
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|TYPE_VALUES
argument_list|(
name|tag
argument_list|)
init|;
name|e
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
block|{
name|tree
name|value
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Note that in a template enum, the TREE_VALUE is the 	 CONST_DECL, not the corresponding INTEGER_CST.  */
name|value
operator|=
name|tsubst_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|args
argument_list|,
name|tf_warning_or_error
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*integral_constant_expression_p=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Give this enumeration constant the correct access.  */
name|set_current_access_from_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Actually build the enumerator itself.  */
name|build_enumerator
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|value
argument_list|,
name|newtag
argument_list|)
expr_stmt|;
block|}
name|finish_enum
argument_list|(
name|newtag
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_NAME
argument_list|(
name|newtag
argument_list|)
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_NAME
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL is a FUNCTION_DECL that is a template specialization.  Return    its type -- but without substituting the innermost set of template    arguments.  So, innermost set of template parameters will appear in    the type.  */
end_comment

begin_function
name|tree
name|get_mostly_instantiated_function_type
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|fn_type
decl_stmt|;
name|tree
name|tmpl
decl_stmt|;
name|tree
name|targs
decl_stmt|;
name|tree
name|tparms
decl_stmt|;
name|int
name|parm_depth
decl_stmt|;
name|tmpl
operator|=
name|most_general_template
argument_list|(
name|DECL_TI_TEMPLATE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|targs
operator|=
name|DECL_TI_ARGS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|tparms
operator|=
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
name|parm_depth
operator|=
name|TMPL_PARMS_DEPTH
argument_list|(
name|tparms
argument_list|)
expr_stmt|;
comment|/* There should be as many levels of arguments as there are levels      of parameters.  */
name|gcc_assert
argument_list|(
name|parm_depth
operator|==
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
name|fn_type
operator|=
name|TREE_TYPE
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm_depth
operator|==
literal|1
condition|)
comment|/* No substitution is necessary.  */
empty_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|save_access_control
decl_stmt|;
name|tree
name|partial_args
decl_stmt|;
comment|/* Replace the innermost level of the TARGS with NULL_TREEs to 	 let tsubst know not to substitute for those parameters.  */
name|partial_args
operator|=
name|make_tree_vec
argument_list|(
name|TREE_VEC_LENGTH
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
condition|;
operator|++
name|i
control|)
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|partial_args
argument_list|,
name|i
argument_list|,
name|TMPL_ARGS_LEVEL
argument_list|(
name|targs
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|SET_TMPL_ARGS_LEVEL
argument_list|(
name|partial_args
argument_list|,
name|TMPL_ARGS_DEPTH
argument_list|(
name|targs
argument_list|)
argument_list|,
name|make_tree_vec
argument_list|(
name|DECL_NTPARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Disable access control as this function is used only during 	 name-mangling.  */
name|save_access_control
operator|=
name|flag_access_control
expr_stmt|;
name|flag_access_control
operator|=
literal|0
expr_stmt|;
operator|++
name|processing_template_decl
expr_stmt|;
comment|/* Now, do the (partial) substitution to figure out the 	 appropriate function type.  */
name|fn_type
operator|=
name|tsubst
argument_list|(
name|fn_type
argument_list|,
name|partial_args
argument_list|,
name|tf_error
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
operator|--
name|processing_template_decl
expr_stmt|;
comment|/* Substitute into the template parameters to obtain the real 	 innermost set of parameters.  This step is important if the 	 innermost set of template parameters contains value 	 parameters whose types depend on outer template parameters.  */
name|TREE_VEC_LENGTH
argument_list|(
name|partial_args
argument_list|)
operator|--
expr_stmt|;
name|tparms
operator|=
name|tsubst_template_parms
argument_list|(
name|tparms
argument_list|,
name|partial_args
argument_list|,
name|tf_error
argument_list|)
expr_stmt|;
name|flag_access_control
operator|=
name|save_access_control
expr_stmt|;
block|}
return|return
name|fn_type
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue if we're processing a template different from    the last one involved in diagnostics.  */
end_comment

begin_function
name|int
name|problematic_instantiation_changed
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|last_template_error_tick
operator|!=
name|tinst_level_tick
return|;
block|}
end_function

begin_comment
comment|/* Remember current template involved in diagnostics.  */
end_comment

begin_function
name|void
name|record_last_problematic_instantiation
parameter_list|(
name|void
parameter_list|)
block|{
name|last_template_error_tick
operator|=
name|tinst_level_tick
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|current_instantiation
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_tinst_level
return|;
block|}
end_function

begin_comment
comment|/* [temp.param] Check that template non-type parm TYPE is of an allowable    type. Return zero for ok, nonzero for disallowed. Issue error and    warning messages under control of COMPLAIN.  */
end_comment

begin_function
specifier|static
name|int
name|invalid_nontype_parm_type_p
parameter_list|(
name|tree
name|type
parameter_list|,
name|tsubst_flags_t
name|complain
parameter_list|)
block|{
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|complain
operator|&
name|tf_error
condition|)
name|error
argument_list|(
literal|"%q#T is not a valid type for a template constant parameter"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if TYPE is dependent, in the sense of [temp.dep.type].    Assumes that TYPE really is a type, and not the ERROR_MARK_NODE.*/
end_comment

begin_function
specifier|static
name|bool
name|dependent_type_p_r
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
comment|/* [temp.dep.type]       A type is dependent if it is:       -- a template parameter. Template template parameters are types 	for us (since TYPE_P holds true for them) so we handle 	them here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
return|return
name|true
return|;
comment|/* -- a qualified-id with a nested-name-specifier which contains a 	class-name that names a dependent type or whose unqualified-id 	names a dependent type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
return|return
name|true
return|;
comment|/* -- a cv-qualified type where the cv-unqualified type is 	dependent.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* -- a compound type constructed from any dependent type.  */
if|if
condition|(
name|TYPE_PTR_TO_MEMBER_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
name|dependent_type_p
argument_list|(
name|TYPE_PTRMEM_CLASS_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|dependent_type_p
argument_list|(
name|TYPE_PTRMEM_POINTED_TO_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|arg_type
decl_stmt|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
for|for
control|(
name|arg_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
init|;
name|arg_type
condition|;
name|arg_type
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_type
argument_list|)
control|)
if|if
condition|(
name|dependent_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
comment|/* -- an array type constructed from any dependent type or whose 	size is specified by a constant expression that is 	value-dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|(
name|value_dependent_expression_p
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|type_dependent_expression_p
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
comment|/* -- a template-id in which either the template name is a template      parameter ...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_TEMPLATE_TEMPLATE_PARM
condition|)
return|return
name|true
return|;
comment|/* ... or any of the template arguments is a dependent type or 	an expression that is type-dependent or value-dependent.  */
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|CLASSTYPE_TEMPLATE_INFO
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|any_dependent_template_arguments_p
argument_list|(
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|CLASSTYPE_TI_ARGS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
comment|/* All TYPEOF_TYPEs are dependent; if the argument of the `typeof'      expression is not type-dependent, then it should already been      have resolved.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPEOF_TYPE
condition|)
return|return
name|true
return|;
comment|/* The standard does not specifically mention types that are local      to template functions or local classes, but they should be      considered dependent too.  For example:         template<int I> void f() { 	 enum E { a = I }; 	 S<sizeof (E)> s;        }       The size of `E' cannot be known until the value of `I' has been      determined.  Therefore, `E' must be considered dependent.  */
name|scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
return|;
elseif|else
if|if
condition|(
name|scope
operator|&&
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|type_dependent_expression_p
argument_list|(
name|scope
argument_list|)
return|;
comment|/* Other types are non-dependent.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if TYPE is dependent, in the sense of    [temp.dep.type].  */
end_comment

begin_function
name|bool
name|dependent_type_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* If there are no template parameters in scope, then there can't be      any dependent types.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
comment|/* If we are not processing a template, then nobody should be 	 providing us with a dependent type.  */
name|gcc_assert
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TEMPLATE_TYPE_PARM
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If the type is NULL, we have not computed a type for the entity      in question; in that case, the type is dependent.  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|true
return|;
comment|/* Erroneous types can be considered non-dependent.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* If we have not already computed the appropriate value for TYPE,      do so now.  */
if|if
condition|(
operator|!
name|TYPE_DEPENDENT_P_VALID
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TYPE_DEPENDENT_P
argument_list|(
name|type
argument_list|)
operator|=
name|dependent_type_p_r
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_DEPENDENT_P_VALID
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TYPE_DEPENDENT_P
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if EXPRESSION is dependent, according to CRITERION.  */
end_comment

begin_function
specifier|static
name|bool
name|dependent_scope_ref_p
parameter_list|(
name|tree
name|expression
parameter_list|,
name|bool
name|criterion
parameter_list|(
name|tree
parameter_list|)
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|SCOPE_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|scope
operator|=
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* [temp.dep.expr]       An id-expression is type-dependent if it contains a      nested-name-specifier that contains a class-name that names a      dependent type.  */
comment|/* The suggested resolution to Core Issue 2 implies that if the      qualifying type is the current class, then we must peek      inside it.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|name
argument_list|)
operator|&&
name|currently_open_class
argument_list|(
name|scope
argument_list|)
operator|&&
operator|!
name|criterion
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the EXPRESSION is value-dependent, in the sense of    [temp.dep.constexpr].  EXPRESSION is already known to be a constant    expression.  */
end_comment

begin_function
name|bool
name|value_dependent_expression_p
parameter_list|(
name|tree
name|expression
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return
name|false
return|;
comment|/* A name declared with a dependent type.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|expression
argument_list|)
operator|&&
name|type_dependent_expression_p
argument_list|(
name|expression
argument_list|)
condition|)
return|return
name|true
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
condition|)
block|{
case|case
name|IDENTIFIER_NODE
case|:
comment|/* A name that has not been looked up -- must be dependent.  */
return|return
name|true
return|;
case|case
name|TEMPLATE_PARM_INDEX
case|:
comment|/* A non-type template parm.  */
return|return
name|true
return|;
case|case
name|CONST_DECL
case|:
comment|/* A non-type template parm.  */
if|if
condition|(
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|expression
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|VAR_DECL
case|:
comment|/* A constant with integral or enumeration type and is initialized 	  with an expression that is value-dependent.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|expression
argument_list|)
operator|&&
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expression
argument_list|)
argument_list|)
operator|&&
name|value_dependent_expression_p
argument_list|(
name|DECL_INITIAL
argument_list|(
name|expression
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|DYNAMIC_CAST_EXPR
case|:
case|case
name|STATIC_CAST_EXPR
case|:
case|case
name|CONST_CAST_EXPR
case|:
case|case
name|REINTERPRET_CAST_EXPR
case|:
case|case
name|CAST_EXPR
case|:
comment|/* These expressions are value-dependent if the type to which 	 the cast occurs is dependent or the expression being casted 	 is value-dependent.  */
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expression
argument_list|)
decl_stmt|;
if|if
condition|(
name|dependent_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* A functional cast has a list of operands.  */
name|expression
operator|=
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expression
condition|)
block|{
comment|/* If there are no operands, it must be an expression such 	       as "int()". This should not happen for aggregate types 	       because it would form non-constant expressions.  */
name|gcc_assert
argument_list|(
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|TREE_LIST
condition|)
return|return
name|any_value_dependent_elements_p
argument_list|(
name|expression
argument_list|)
return|;
return|return
name|value_dependent_expression_p
argument_list|(
name|expression
argument_list|)
return|;
block|}
case|case
name|SIZEOF_EXPR
case|:
case|case
name|ALIGNOF_EXPR
case|:
comment|/* A `sizeof' expression is value-dependent if the operand is 	 type-dependent.  */
name|expression
operator|=
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|expression
argument_list|)
condition|)
return|return
name|dependent_type_p
argument_list|(
name|expression
argument_list|)
return|;
return|return
name|type_dependent_expression_p
argument_list|(
name|expression
argument_list|)
return|;
case|case
name|SCOPE_REF
case|:
return|return
name|dependent_scope_ref_p
argument_list|(
name|expression
argument_list|,
name|value_dependent_expression_p
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
return|return
operator|(
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CALL_EXPR
case|:
comment|/* A CALL_EXPR may appear in a constant expression if it is a 	 call to a builtin function, e.g., __builtin_constant_p.  All 	 such calls are value-dependent.  */
return|return
name|true
return|;
case|case
name|MODOP_EXPR
case|:
return|return
operator|(
operator|(
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|)
return|;
default|default:
comment|/* A constant expression is value-dependent if any subexpression is 	 value-dependent.  */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_reference
case|:
case|case
name|tcc_unary
case|:
return|return
operator|(
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|tcc_comparison
case|:
case|case
name|tcc_binary
case|:
return|return
operator|(
operator|(
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
return|;
case|case
name|tcc_expression
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
argument_list|)
condition|;
operator|++
name|i
control|)
comment|/* In some cases, some of the operands may be missing. 		 (For example, in the case of PREDECREMENT_EXPR, the 		 amount to increment by may be missing.)  That doesn't 		 make the expression dependent.  */
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
default|default:
break|break;
block|}
block|}
comment|/* The expression is not value-dependent.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the EXPRESSION is type-dependent, in the sense of    [temp.dep.expr].  */
end_comment

begin_function
name|bool
name|type_dependent_expression_p
parameter_list|(
name|tree
name|expression
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return
name|false
return|;
if|if
condition|(
name|expression
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* An unresolved name is always dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|USING_DECL
condition|)
return|return
name|true
return|;
comment|/* Some expression forms are never type-dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|PSEUDO_DTOR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|SIZEOF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|ALIGNOF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|TYPEID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|DELETE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|VEC_DELETE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|THROW_EXPR
condition|)
return|return
name|false
return|;
comment|/* The types of these expressions depends only on the type to which      the cast occurs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|DYNAMIC_CAST_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|STATIC_CAST_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|CONST_CAST_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|REINTERPRET_CAST_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|CAST_EXPR
condition|)
return|return
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expression
argument_list|)
argument_list|)
return|;
comment|/* The types of these expressions depends only on the type created      by the expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|NEW_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|VEC_NEW_EXPR
condition|)
block|{
comment|/* For NEW_EXPR tree nodes created inside a template, either 	 the object type itself or a TREE_LIST may appear as the 	 operand 1.  */
name|tree
name|type
init|=
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_LIST
condition|)
comment|/* This is an array type.  We need to check array dimensions 	   as well.  */
return|return
name|dependent_type_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|||
name|value_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|dependent_type_p
argument_list|(
name|type
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|SCOPE_REF
operator|&&
name|dependent_scope_ref_p
argument_list|(
name|expression
argument_list|,
name|type_dependent_expression_p
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_LANG_SPECIFIC
argument_list|(
name|expression
argument_list|)
operator|&&
name|DECL_TEMPLATE_INFO
argument_list|(
name|expression
argument_list|)
operator|&&
operator|(
name|any_dependent_template_arguments_p
argument_list|(
name|INNERMOST_TEMPLATE_ARGS
argument_list|(
name|DECL_TI_ARGS
argument_list|(
name|expression
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|expression
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expression
argument_list|)
operator|==
name|unknown_type_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|type_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|OFFSET_REF
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|expression
operator|=
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
name|false
return|;
block|}
comment|/* SCOPE_REF with non-null TREE_TYPE is always non-dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|SCOPE_REF
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|BASELINK
condition|)
name|expression
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|expression
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
if|if
condition|(
name|any_dependent_template_arguments_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|expression
operator|=
name|TREE_OPERAND
argument_list|(
name|expression
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|OVERLOAD
operator|||
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
while|while
condition|(
name|expression
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|OVL_CURRENT
argument_list|(
name|expression
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|expression
operator|=
name|OVL_NEXT
argument_list|(
name|expression
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expression
argument_list|)
operator|!=
name|TYPE_DECL
argument_list|)
expr_stmt|;
return|return
operator|(
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|expression
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if ARGS (a TREE_LIST of arguments to a function call)    contains a type-dependent expression.  */
end_comment

begin_function
name|bool
name|any_type_dependent_arguments_p
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
while|while
condition|(
name|args
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|true
return|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if LIST (a TREE_LIST whose TREE_VALUEs are    expressions) contains any value-dependent expressions.  */
end_comment

begin_function
name|bool
name|any_value_dependent_elements_p
parameter_list|(
name|tree
name|list
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
control|)
if|if
condition|(
name|value_dependent_expression_p
argument_list|(
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the ARG (a template argument) is dependent.  */
end_comment

begin_function
specifier|static
name|bool
name|dependent_template_arg_p
parameter_list|(
name|tree
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
return|return
name|dependent_template_p
argument_list|(
name|arg
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|arg
argument_list|)
condition|)
return|return
name|dependent_type_p
argument_list|(
name|arg
argument_list|)
return|;
else|else
return|return
operator|(
name|type_dependent_expression_p
argument_list|(
name|arg
argument_list|)
operator|||
name|value_dependent_expression_p
argument_list|(
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if ARGS (a collection of template arguments) contains    any dependent arguments.  */
end_comment

begin_function
name|bool
name|any_dependent_template_arguments_p
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
return|return
name|false
return|;
if|if
condition|(
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TMPL_ARGS_DEPTH
argument_list|(
name|args
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|level
init|=
name|TMPL_ARGS_LEVEL
argument_list|(
name|args
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TREE_VEC_LENGTH
argument_list|(
name|level
argument_list|)
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|dependent_template_arg_p
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|level
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the template TMPL is dependent.  */
end_comment

begin_function
name|bool
name|dependent_template_p
parameter_list|(
name|tree
name|tmpl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|OVERLOAD
condition|)
block|{
while|while
condition|(
name|tmpl
condition|)
block|{
if|if
condition|(
name|dependent_template_p
argument_list|(
name|OVL_FUNCTION
argument_list|(
name|tmpl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|tmpl
operator|=
name|OVL_CHAIN
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
comment|/* Template template parameters are dependent.  */
if|if
condition|(
name|DECL_TEMPLATE_TEMPLATE_PARM_P
argument_list|(
name|tmpl
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|TEMPLATE_TEMPLATE_PARM
condition|)
return|return
name|true
return|;
comment|/* So are names that have not been looked up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|SCOPE_REF
operator|||
name|TREE_CODE
argument_list|(
name|tmpl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
name|true
return|;
comment|/* So are member templates of dependent classes.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
condition|)
return|return
name|dependent_type_p
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|tmpl
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the specialization TMPL<ARGS> is dependent.  */
end_comment

begin_function
name|bool
name|dependent_template_id_p
parameter_list|(
name|tree
name|tmpl
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
return|return
operator|(
name|dependent_template_p
argument_list|(
name|tmpl
argument_list|)
operator|||
name|any_dependent_template_arguments_p
argument_list|(
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* TYPE is a TYPENAME_TYPE.  Returns the ordinary TYPE to which the    TYPENAME_TYPE corresponds.  Returns ERROR_MARK_NODE if no such TYPE    can be found.  Note that this function peers inside uninstantiated    templates and therefore should be used only in extremely limited    situations.  ONLY_CURRENT_P restricts this peering to the currently    open classes hierarchy (which is required when comparing types).  */
end_comment

begin_function
name|tree
name|resolve_typename_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|only_current_p
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|quals
decl_stmt|;
name|tree
name|pushed_scope
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPENAME_TYPE
argument_list|)
expr_stmt|;
name|scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If the SCOPE is itself a TYPENAME_TYPE, then we need to resolve      it first before we can figure out what NAME refers to.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
name|scope
operator|=
name|resolve_typename_type
argument_list|(
name|scope
argument_list|,
name|only_current_p
argument_list|)
expr_stmt|;
comment|/* If we don't know what SCOPE refers to, then we cannot resolve the      TYPENAME_TYPE.  */
if|if
condition|(
name|scope
operator|==
name|error_mark_node
operator|||
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
return|return
name|error_mark_node
return|;
comment|/* If the SCOPE is a template type parameter, we have no way of      resolving the name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
return|return
name|type
return|;
comment|/* If the SCOPE is not the current instantiation, there's no reason      to look inside it.  */
if|if
condition|(
name|only_current_p
operator|&&
operator|!
name|currently_open_class
argument_list|(
name|scope
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* If SCOPE is a partial instantiation, it will not have a valid      TYPE_FIELDS list, so use the original template.  */
name|scope
operator|=
name|CLASSTYPE_PRIMARY_TEMPLATE_TYPE
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* Enter the SCOPE so that name lookup will be resolved as if we      were in the class definition.  In particular, SCOPE will no      longer be considered a dependent type.  */
name|pushed_scope
operator|=
name|push_scope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
comment|/* Look up the declaration.  */
name|decl
operator|=
name|lookup_member
argument_list|(
name|scope
argument_list|,
name|name
argument_list|,
comment|/*protect=*/
literal|0
argument_list|,
comment|/*want_type=*/
name|true
argument_list|)
expr_stmt|;
comment|/* Obtain the set of qualifiers applied to the TYPE.  */
name|quals
operator|=
name|cp_type_quals
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* For a TYPENAME_TYPE like "typename X::template Y<T>", we want to      find a TEMPLATE_DECL.  Otherwise, we want to find a TYPE_DECL.  */
if|if
condition|(
operator|!
name|decl
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|tmpl
decl_stmt|;
name|tree
name|args
decl_stmt|;
comment|/* Obtain the template and the arguments.  */
name|tmpl
operator|=
name|TREE_OPERAND
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_OPERAND
argument_list|(
name|TYPENAME_TYPE_FULLNAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Instantiate the template.  */
name|type
operator|=
name|lookup_template_class
argument_list|(
name|tmpl
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*entering_scope=*/
literal|0
argument_list|,
name|tf_error
operator||
name|tf_user
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Qualify the resulting type.  */
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|quals
condition|)
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
comment|/* Leave the SCOPE.  */
if|if
condition|(
name|pushed_scope
condition|)
name|pop_scope
argument_list|(
name|pushed_scope
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* EXPR is an expression which is not type-dependent.  Return a proxy    for EXPR that can be used to compute the types of larger    expressions containing EXPR.  */
end_comment

begin_function
name|tree
name|build_non_dependent_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|inner_expr
decl_stmt|;
comment|/* Preserve null pointer constants so that the type of things like      "p == 0" where "p" is a pointer can be determined.  */
if|if
condition|(
name|null_ptr_cst_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
comment|/* Preserve OVERLOADs; the functions must be available to resolve      types.  */
name|inner_expr
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_expr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|inner_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_expr
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|inner_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|inner_expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|inner_expr
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|inner_expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
return|return
name|expr
return|;
comment|/* There is no need to return a proxy for a variable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
condition|)
return|return
name|expr
return|;
comment|/* Preserve string constants; conversions from string constants to      "char *" are allowed, even though normally a "const char *"      cannot be used to initialize a "char *".  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|expr
return|;
comment|/* Preserve arithmetic constants, as an optimization -- there is no      reason to create a new node.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|expr
return|;
comment|/* Preserve THROW_EXPRs -- all throw-expressions have type "void".      There is at least one place where we want to know that a      particular expression is a throw-expression: when checking a ?:      expression, there are special rules if the second or third      argument is a throw-expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|THROW_EXPR
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
condition|?
name|build_non_dependent_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|build_non_dependent_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
argument_list|,
name|build_non_dependent_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
operator|&&
operator|!
name|COMPOUND_EXPR_OVERLOADED
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_non_dependent_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* If the type is unknown, it can't really be non-dependent */
name|gcc_assert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|unknown_type_node
argument_list|)
expr_stmt|;
comment|/* Otherwise, build a NON_DEPENDENT_EXPR.       REFERENCE_TYPEs are not stripped for expressions in templates      because doing so would play havoc with mangling.  Consider, for      example:         template<typename T> void f<T& g>() { g(); }       In the body of "f", the expression for "g" will have      REFERENCE_TYPE, even though the standard says that it should      not.  The reason is that we must preserve the syntactic form of      the expression so that mangling (say) "f<g>" inside the body of      "f" works out correctly.  Therefore, the REFERENCE_TYPE is      stripped here.  */
return|return
name|build1
argument_list|(
name|NON_DEPENDENT_EXPR
argument_list|,
name|non_reference
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARGS is a TREE_LIST of expressions as arguments to a function call.    Return a new TREE_LIST with the various arguments replaced with    equivalent non-dependent expressions.  */
end_comment

begin_function
name|tree
name|build_non_dependent_args
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
name|tree
name|a
decl_stmt|;
name|tree
name|new_args
decl_stmt|;
name|new_args
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|args
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
name|new_args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_non_dependent_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|,
name|new_args
argument_list|)
expr_stmt|;
return|return
name|nreverse
argument_list|(
name|new_args
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-pt.h"
end_include

end_unit

