begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle the hair of processing (but not expanding) inline functions.    Also manage function and variable name overloading.    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Handle method declarations.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_comment
comment|/* Various flags to control the mangling process.  */
end_comment

begin_enum
enum|enum
name|mangling_flags
block|{
comment|/* No flags.  */
name|mf_none
init|=
literal|0
block|,
comment|/* The thing we are presently mangling is part of a template type,      rather than a fully instantiated type.  Therefore, we may see      complex expressions where we would normally expect to see a      simple integer constant.  */
name|mf_maybe_uninstantiated
init|=
literal|1
block|,
comment|/* When mangling a numeric value, use the form `_XX_' (instead of      just `XX') if the value has more than one digit.  */
name|mf_use_underscores_around_value
init|=
literal|2
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|mangling_flags
name|mangling_flags
typedef|;
end_typedef

begin_function_decl
specifier|static
name|tree
name|thunk_adjust
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_build_assign_ref
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_build_copy_constructor
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|synthesize_exception_spec
parameter_list|(
name|tree
parameter_list|,
name|tree
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|locate_dtor
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|locate_ctor
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|locate_copy
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|make_alias_for_thunk
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called once to initialize method.c.  */
end_comment

begin_function
name|void
name|init_method
parameter_list|(
name|void
parameter_list|)
block|{
name|init_mangle
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a this or result adjusting thunk to FUNCTION.  THIS_ADJUSTING    indicates whether it is a this or result adjusting thunk.    FIXED_OFFSET and VIRTUAL_OFFSET indicate how to do the adjustment    (see thunk_adjust).  VIRTUAL_OFFSET can be NULL, but FIXED_OFFSET    never is.  VIRTUAL_OFFSET is the /index/ into the vtable for this    adjusting thunks, we scale it to a byte offset. For covariant    thunks VIRTUAL_OFFSET is the virtual binfo.  You must post process    the returned thunk with finish_thunk.  */
end_comment

begin_function
name|tree
name|make_thunk
parameter_list|(
name|tree
name|function
parameter_list|,
name|bool
name|this_adjusting
parameter_list|,
name|tree
name|fixed_offset
parameter_list|,
name|tree
name|virtual_offset
parameter_list|)
block|{
name|HOST_WIDE_INT
name|d
decl_stmt|;
name|tree
name|thunk
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* We can have this thunks to covariant thunks, but not vice versa.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_THIS_THUNK_P
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|DECL_RESULT_THUNK_P
argument_list|(
name|function
argument_list|)
operator|||
name|this_adjusting
argument_list|)
expr_stmt|;
comment|/* Scale the VIRTUAL_OFFSET to be in terms of bytes.  */
if|if
condition|(
name|this_adjusting
operator|&&
name|virtual_offset
condition|)
name|virtual_offset
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|virtual_offset
argument_list|,
name|convert
argument_list|(
name|ssizetype
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|tree_low_cst
argument_list|(
name|fixed_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if we already have the thunk in question.  For this_adjusting      thunks VIRTUAL_OFFSET will be an INTEGER_CST, for covariant thunks it      will be a BINFO.  */
for|for
control|(
name|thunk
operator|=
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
init|;
name|thunk
condition|;
name|thunk
operator|=
name|TREE_CHAIN
argument_list|(
name|thunk
argument_list|)
control|)
if|if
condition|(
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk
argument_list|)
operator|==
name|this_adjusting
operator|&&
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|==
name|d
operator|&&
operator|!
name|virtual_offset
operator|==
operator|!
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|&&
operator|(
operator|!
name|virtual_offset
operator|||
operator|(
name|this_adjusting
condition|?
name|tree_int_cst_equal
argument_list|(
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
argument_list|,
name|virtual_offset
argument_list|)
else|:
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|==
name|virtual_offset
operator|)
operator|)
condition|)
return|return
name|thunk
return|;
comment|/* All thunks must be created before FUNCTION is actually emitted;      the ABI requires that all thunks be emitted together with the      function to which they transfer control.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Likewise, we can only be adding thunks to a function declared in      the class currently being laid out.  */
name|gcc_assert
argument_list|(
name|TYPE_SIZE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
operator|&&
name|TYPE_BEING_DEFINED
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|thunk
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|thunk
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|SET_DECL_THUNK_P
argument_list|(
name|thunk
argument_list|,
name|this_adjusting
argument_list|)
expr_stmt|;
name|THUNK_TARGET
argument_list|(
name|thunk
argument_list|)
operator|=
name|function
expr_stmt|;
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|=
name|d
expr_stmt|;
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
operator|=
name|virtual_offset
expr_stmt|;
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* The thunk itself is not a constructor or destructor, even if      the thing it is thunking to is.  */
name|DECL_INTERFACE_KNOWN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_DESTRUCTOR_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if this thunk is a member of a local class, we don't      need a static chain.  */
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The THUNK is not a pending inline, even if the FUNCTION is.  */
name|DECL_PENDING_INLINE_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Nor has it been deferred.  */
name|DECL_DEFERRED_FN
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Nor is it a template instantiation.  */
name|DECL_USE_TEMPLATE
argument_list|(
name|thunk
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|thunk
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Add it to the list of thunks associated with FUNCTION.  */
name|TREE_CHAIN
argument_list|(
name|thunk
argument_list|)
operator|=
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
operator|=
name|thunk
expr_stmt|;
return|return
name|thunk
return|;
block|}
end_function

begin_comment
comment|/* Finish THUNK, a thunk decl.  */
end_comment

begin_function
name|void
name|finish_thunk
parameter_list|(
name|tree
name|thunk
parameter_list|)
block|{
name|tree
name|function
decl_stmt|,
name|name
decl_stmt|;
name|tree
name|fixed_offset
init|=
name|ssize_int
argument_list|(
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|virtual_offset
init|=
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|DECL_NAME
argument_list|(
name|thunk
argument_list|)
operator|&&
name|DECL_THUNK_P
argument_list|(
name|thunk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_offset
operator|&&
name|DECL_RESULT_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
name|virtual_offset
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|virtual_offset
argument_list|)
expr_stmt|;
name|function
operator|=
name|THUNK_TARGET
argument_list|(
name|thunk
argument_list|)
expr_stmt|;
name|name
operator|=
name|mangle_thunk
argument_list|(
name|function
argument_list|,
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk
argument_list|)
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
comment|/* We can end up with declarations of (logically) different      covariant thunks, that do identical adjustments.  The two thunks      will be adjusting between within different hierarchies, which      happen to have the same layout.  We must nullify one of them to      refer to the other.  */
if|if
condition|(
name|DECL_RESULT_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|tree
name|cov_probe
decl_stmt|;
for|for
control|(
name|cov_probe
operator|=
name|DECL_THUNKS
argument_list|(
name|function
argument_list|)
init|;
name|cov_probe
condition|;
name|cov_probe
operator|=
name|TREE_CHAIN
argument_list|(
name|cov_probe
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|cov_probe
argument_list|)
operator|==
name|name
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
argument_list|)
expr_stmt|;
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
operator|=
operator|(
name|THUNK_ALIAS
argument_list|(
name|cov_probe
argument_list|)
condition|?
name|THUNK_ALIAS
argument_list|(
name|cov_probe
argument_list|)
else|:
name|cov_probe
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|DECL_NAME
argument_list|(
name|thunk
argument_list|)
operator|=
name|name
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|thunk
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust PTR by the constant FIXED_OFFSET, and by the vtable    offset indicated by VIRTUAL_OFFSET, if that is    non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and    zero for a result adjusting thunk.  */
end_comment

begin_function
specifier|static
name|tree
name|thunk_adjust
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|bool
name|this_adjusting
parameter_list|,
name|HOST_WIDE_INT
name|fixed_offset
parameter_list|,
name|tree
name|virtual_offset
parameter_list|)
block|{
if|if
condition|(
name|this_adjusting
condition|)
comment|/* Adjust the pointer by the constant.  */
name|ptr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|ssize_int
argument_list|(
name|fixed_offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's a virtual offset, look up that value in the vtable and      adjust the pointer again.  */
if|if
condition|(
name|virtual_offset
condition|)
block|{
name|tree
name|vtable
decl_stmt|;
name|ptr
operator|=
name|save_expr
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* The vptr is always at offset zero in the object.  */
name|vtable
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|build_pointer_type
argument_list|(
name|vtable_entry_type
argument_list|)
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Form the vtable address.  */
name|vtable
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|)
argument_list|,
name|vtable
argument_list|)
expr_stmt|;
comment|/* Find the entry with the vcall offset.  */
name|vtable
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|,
name|vtable
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
comment|/* Get the offset itself.  */
name|vtable
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vtable
argument_list|)
argument_list|)
argument_list|,
name|vtable
argument_list|)
expr_stmt|;
comment|/* Adjust the `this' pointer.  */
name|ptr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|vtable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_adjusting
condition|)
comment|/* Adjust the pointer by the constant.  */
name|ptr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|ssize_int
argument_list|(
name|fixed_offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|thunk_labelno
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Create a static alias to function.  */
end_comment

begin_function
name|tree
name|make_alias_for
parameter_list|(
name|tree
name|function
parameter_list|,
name|tree
name|newid
parameter_list|)
block|{
name|tree
name|alias
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|newid
argument_list|,
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|alias
argument_list|)
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|cxx_dup_lang_specific_decl
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|alias
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|alias
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_THIS_STATIC
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SAVED_FUNCTION_DATA
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_DESTRUCTOR_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CLONED_FUNCTION
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_PENDING_INLINE_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_DEFERRED_FN
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_USE_TEMPLATE
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INSTANTIATED
argument_list|(
name|alias
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_TEMPLATE_INFO
argument_list|(
name|alias
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|alias
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|alias
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|alias
argument_list|,
name|DECL_NAME
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|alias
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|alias
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|make_alias_for_thunk
parameter_list|(
name|tree
name|function
parameter_list|)
block|{
name|tree
name|alias
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LTHUNK"
argument_list|,
name|thunk_labelno
argument_list|)
expr_stmt|;
name|thunk_labelno
operator|++
expr_stmt|;
name|alias
operator|=
name|make_alias_for
argument_list|(
name|function
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_syntax_only
condition|)
name|assemble_alias
argument_list|(
name|alias
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
end_function

begin_comment
comment|/* Emit the definition of a C++ multiple inheritance or covariant    return vtable thunk.  If EMIT_P is nonzero, the thunk is emitted    immediately.  */
end_comment

begin_function
name|void
name|use_thunk
parameter_list|(
name|tree
name|thunk_fndecl
parameter_list|,
name|bool
name|emit_p
parameter_list|)
block|{
name|tree
name|a
decl_stmt|,
name|t
decl_stmt|,
name|function
decl_stmt|,
name|alias
decl_stmt|;
name|tree
name|virtual_offset
decl_stmt|;
name|HOST_WIDE_INT
name|fixed_offset
decl_stmt|,
name|virtual_value
decl_stmt|;
name|bool
name|this_adjusting
init|=
name|DECL_THIS_THUNK_P
argument_list|(
name|thunk_fndecl
argument_list|)
decl_stmt|;
comment|/* We should have called finish_thunk to give it a name.  */
name|gcc_assert
argument_list|(
name|DECL_NAME
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We should never be using an alias, always refer to the      aliased thunk.  */
name|gcc_assert
argument_list|(
operator|!
name|THUNK_ALIAS
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
return|return;
name|function
operator|=
name|THUNK_TARGET
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
condition|)
comment|/* We already turned this thunk into an ordinary function.        There's no need to process this thunk again.  */
return|return;
if|if
condition|(
name|DECL_THUNK_P
argument_list|(
name|function
argument_list|)
condition|)
comment|/* The target is itself a thunk, process it now.  */
name|use_thunk
argument_list|(
name|function
argument_list|,
name|emit_p
argument_list|)
expr_stmt|;
comment|/* Thunks are always addressable; they only appear in vtables.  */
name|TREE_ADDRESSABLE
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Figure out what function is being thunked to.  It's referenced in      this translation unit.  */
name|TREE_ADDRESSABLE
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_used
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emit_p
condition|)
return|return;
if|if
condition|(
name|TARGET_USE_LOCAL_THUNK_ALIAS_P
argument_list|(
name|function
argument_list|)
condition|)
name|alias
operator|=
name|make_alias_for_thunk
argument_list|(
name|function
argument_list|)
expr_stmt|;
else|else
name|alias
operator|=
name|function
expr_stmt|;
name|fixed_offset
operator|=
name|THUNK_FIXED_OFFSET
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|virtual_offset
operator|=
name|THUNK_VIRTUAL_OFFSET
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_offset
condition|)
block|{
if|if
condition|(
operator|!
name|this_adjusting
condition|)
name|virtual_offset
operator|=
name|BINFO_VPTR_FIELD
argument_list|(
name|virtual_offset
argument_list|)
expr_stmt|;
name|virtual_value
operator|=
name|tree_low_cst
argument_list|(
name|virtual_offset
argument_list|,
comment|/*pos=*/
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|virtual_value
argument_list|)
expr_stmt|;
block|}
else|else
name|virtual_value
operator|=
literal|0
expr_stmt|;
comment|/* And, if we need to emit the thunk, it's used.  */
name|mark_used
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
comment|/* This thunk is actually defined.  */
name|DECL_EXTERNAL
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* The linkage of the function may have changed.  FIXME in linkage      rewrite.  */
name|TREE_PUBLIC
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ONE_ONLY
argument_list|(
name|function
argument_list|)
condition|)
name|make_decl_one_only
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_syntax_only
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|push_to_top_level
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_USE_LOCAL_THUNK_ALIAS_P
argument_list|(
name|function
argument_list|)
operator|&&
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
name|resolve_unique_section
argument_list|(
name|function
argument_list|,
literal|0
argument_list|,
name|flag_function_sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|function
argument_list|)
operator|!=
name|NULL
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|resolve_unique_section
argument_list|(
name|thunk_fndecl
argument_list|,
literal|0
argument_list|,
name|flag_function_sections
argument_list|)
expr_stmt|;
comment|/* Output the thunk into the same section as function.  */
name|DECL_SECTION_NAME
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|function
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up cloned argument trees for the thunk.  */
name|t
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|function
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|x
init|=
name|copy_node
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|thunk_fndecl
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|x
expr_stmt|;
block|}
name|a
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|this_adjusting
operator|&&
name|targetm
operator|.
name|asm_out
operator|.
name|can_output_mi_thunk
argument_list|(
name|thunk_fndecl
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_value
argument_list|,
name|alias
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
name|tree
name|fn_block
decl_stmt|;
name|current_function_decl
operator|=
name|thunk_fndecl
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
literal|0
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|thunk_fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The back-end expects DECL_INITIAL to contain a BLOCK, so we 	 create one.  */
name|fn_block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|fn_block
argument_list|)
operator|=
name|a
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|fn_block
expr_stmt|;
name|init_function_start
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|current_function_is_thunk
operator|=
literal|1
expr_stmt|;
name|assemble_start_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|output_mi_thunk
argument_list|(
name|asm_out_file
argument_list|,
name|thunk_fndecl
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_value
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|assemble_end_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|init_insn_lengths
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
name|cfun
operator|=
literal|0
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If this is a covariant thunk, or we don't have the necessary 	 code for efficient thunks, generate a thunk function that 	 just makes a call to the real function.  Unfortunately, this 	 doesn't work for varargs.  */
if|if
condition|(
name|varargs_function_p
argument_list|(
name|function
argument_list|)
condition|)
name|error
argument_list|(
literal|"generic thunk code fails for method %q#D which uses %<...%>"
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|start_preparsed_function
argument_list|(
name|thunk_fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
comment|/* We don't bother with a body block for thunks.  */
comment|/* There's no need to check accessibility inside the thunk body.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|t
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|this_adjusting
condition|)
name|t
operator|=
name|thunk_adjust
argument_list|(
name|t
argument_list|,
comment|/*this_adjusting=*/
literal|1
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
comment|/* Build up the call to the real function.  */
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|a
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|nreverse
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_call
argument_list|(
name|alias
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|CALL_FROM_THUNK_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|this_adjusting
condition|)
block|{
name|tree
name|cond
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
comment|/* If the return type is a pointer, we need to 		     protect against NULL.  We know there will be an 		     adjustment, because that's why we're emitting a 		     thunk.  */
name|t
operator|=
name|save_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cond
operator|=
name|cp_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|thunk_adjust
argument_list|(
name|t
argument_list|,
comment|/*this_adjusting=*/
literal|0
argument_list|,
name|fixed_offset
argument_list|,
name|virtual_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|cond
argument_list|,
name|t
argument_list|,
name|cp_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|build_cplus_new
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|finish_return_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Since we want to emit the thunk, we explicitly mark its name as 	 referenced.  */
name|mark_decl_referenced
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
comment|/* But we don't want debugging information about it.  */
name|DECL_IGNORED_P
argument_list|(
name|thunk_fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Re-enable access control.  */
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
name|thunk_fndecl
operator|=
name|finish_function
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tree_lowering_passes
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
name|expand_body
argument_list|(
name|thunk_fndecl
argument_list|)
expr_stmt|;
block|}
name|pop_from_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for synthesizing methods which have default semantics defined.  */
end_comment

begin_comment
comment|/* Generate code for default X(X&) constructor.  */
end_comment

begin_function
specifier|static
name|void
name|do_build_copy_constructor
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|parm
init|=
name|FUNCTION_FIRST_USER_PARM
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
decl_stmt|;
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
decl_stmt|;
name|tree
name|member_init_list
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|cvquals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|vbases
expr_stmt|;
comment|/* Initialize all the base-classes with the parameter converted 	 to their type so that we get their copy constructor and not 	 another constructor that takes current_class_type.  We must 	 deal with the binfo's directly as a direct base might be 	 inaccessible due to ambiguity.  */
for|for
control|(
name|vbases
operator|=
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|current_class_type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|vbases
argument_list|,
name|i
argument_list|,
name|binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|binfo
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|binfo
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|base_binfo
argument_list|)
condition|)
continue|continue;
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|base_binfo
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|base_binfo
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|init
init|=
name|parm
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
name|tree
name|expr_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|expr_type
argument_list|)
condition|)
comment|/* Just use the field; anonymous types can't have 	       nontrivial copy ctors or assignment ops.  */
empty_stmt|;
else|else
continue|continue;
comment|/* Compute the type of "init->field".  If the copy-constructor 	     parameter is, for example, "const S&", and the type of 	     the field is "T", then the type will usually be "const 	     T".  (There are no cv-qualified variants of reference 	     types.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
block|{
name|int
name|quals
init|=
name|cvquals
decl_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|expr_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|expr_type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
name|init
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|expr_type
argument_list|,
name|init
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|init
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|member_init_list
operator|=
name|tree_cons
argument_list|(
name|field
argument_list|,
name|init
argument_list|,
name|member_init_list
argument_list|)
expr_stmt|;
block|}
name|finish_mem_initializers
argument_list|(
name|member_init_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_build_assign_ref
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|parm
init|=
name|TREE_CHAIN
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|compound_stmt
decl_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|parm
operator|=
name|convert_from_reference
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
operator|&&
name|is_empty_class
argument_list|(
name|current_class_type
argument_list|)
condition|)
comment|/* Don't copy the padding byte; it might not have been allocated        if *this is a base subobject.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|current_class_type
argument_list|)
condition|)
block|{
name|tree
name|t
init|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|current_class_ref
argument_list|,
name|parm
argument_list|)
decl_stmt|;
name|finish_expr_stmt
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|fields
decl_stmt|;
name|int
name|cvquals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
comment|/* Assign to each of the direct base classes.  */
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|current_class_type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|converted_parm
decl_stmt|;
comment|/* We must convert PARM directly to the base class 	     explicitly since the base class may be ambiguous.  */
name|converted_parm
operator|=
name|build_base_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|parm
argument_list|,
name|base_binfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Call the base class assignment operator.  */
name|finish_expr_stmt
argument_list|(
name|build_special_member_call
argument_list|(
name|current_class_ref
argument_list|,
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|converted_parm
argument_list|)
argument_list|,
name|base_binfo
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Assign to each of the non-static data members.  */
for|for
control|(
name|fields
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|comp
init|=
name|current_class_ref
decl_stmt|;
name|tree
name|init
init|=
name|parm
decl_stmt|;
name|tree
name|field
init|=
name|fields
decl_stmt|;
name|tree
name|expr_type
decl_stmt|;
name|int
name|quals
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|field
argument_list|)
condition|)
continue|continue;
name|expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|CP_TYPE_CONST_P
argument_list|(
name|expr_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-static const member %q#D, can't use default "
literal|"assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"non-static reference member %q#D, can't use "
literal|"default assignment operator"
argument_list|,
name|field
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|VFIELD_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ANON_AGGR_TYPE_P
argument_list|(
name|expr_type
argument_list|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|expr_type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
comment|/* Just use the field; anonymous types can't have 	       nontrivial copy ctors or assignment ops.  */
empty_stmt|;
else|else
continue|continue;
name|comp
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|expr_type
argument_list|,
name|comp
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Compute the type of init->field  */
name|quals
operator|=
name|cvquals
expr_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|field
argument_list|)
condition|)
name|quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|expr_type
operator|=
name|cp_build_qualified_type
argument_list|(
name|expr_type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|init
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|expr_type
argument_list|,
name|init
argument_list|,
name|field
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
condition|)
name|init
operator|=
name|build_modify_expr
argument_list|(
name|comp
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|comp
argument_list|)
argument_list|,
name|comp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|finish_expr_stmt
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_return_stmt
argument_list|(
name|current_class_ref
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Synthesize FNDECL, a non-static member function.   */
end_comment

begin_function
name|void
name|synthesize_method
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|bool
name|nested
init|=
operator|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|)
decl_stmt|;
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|bool
name|need_body
init|=
name|true
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|location_t
name|save_input_location
init|=
name|input_location
decl_stmt|;
name|int
name|error_count
init|=
name|errorcount
decl_stmt|;
name|int
name|warning_count
init|=
name|warningcount
decl_stmt|;
comment|/* Reset the source location, we might have been previously      deferred, and thus have saved where we were first needed.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|fndecl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we've been asked to synthesize a clone, just synthesize the      cloned function instead.  Doing so will automatically fill in the      body for the clone.  */
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fndecl
argument_list|)
condition|)
name|fndecl
operator|=
name|DECL_CLONED_FUNCTION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* We may be in the middle of deferred access check.  Disable      it now.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_deferred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|push_to_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|push_function_context_to
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|start_preparsed_function
argument_list|(
name|fndecl
argument_list|,
name|NULL_TREE
argument_list|,
name|SF_DEFAULT
operator||
name|SF_PRE_PARSED
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|begin_function_body
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_OVERLOADED_OPERATOR_P
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|do_build_assign_ref
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|need_body
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|arg_chain
init|=
name|FUNCTION_FIRST_USER_PARMTYPE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg_chain
operator|!=
name|void_list_node
condition|)
name|do_build_copy_constructor
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|finish_mem_initializers
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't yet generated the body of the function, just      generate an empty compound statement.  */
if|if
condition|(
name|need_body
condition|)
block|{
name|tree
name|compound_stmt
decl_stmt|;
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
name|BCS_FN_BODY
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
name|finish_function_body
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|expand_or_defer_fn
argument_list|(
name|finish_function
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|save_input_location
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|pop_from_top_level
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nested
condition|)
name|pop_function_context_from
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
if|if
condition|(
name|error_count
operator|!=
name|errorcount
operator|||
name|warning_count
operator|!=
name|warningcount
condition|)
name|inform
argument_list|(
literal|"%Hsynthesized method %qD first required here "
argument_list|,
operator|&
name|input_location
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use EXTRACTOR to locate the relevant function called for each base&    class field of TYPE. CLIENT allows additional information to be passed    to EXTRACTOR.  Generates the union of all exceptions generated by those    functions.  Note that we haven't updated TYPE_FIELDS and such of any    variants yet, so we need to look at the main one.  */
end_comment

begin_function
specifier|static
name|tree
name|synthesize_exception_spec
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
function_decl|(
modifier|*
name|extractor
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|client
parameter_list|)
block|{
name|tree
name|raises
init|=
name|empty_except_spec
decl_stmt|;
name|tree
name|fields
init|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|fn
init|=
call|(
modifier|*
name|extractor
call|)
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
name|client
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|fn_raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|raises
operator|=
name|merge_exception_specifiers
argument_list|(
name|raises
argument_list|,
name|fn_raises
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|fields
condition|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|tree
name|fn
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fields
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|fields
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
continue|continue;
name|fn
operator|=
call|(
modifier|*
name|extractor
call|)
argument_list|(
name|type
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
name|tree
name|fn_raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|raises
operator|=
name|merge_exception_specifiers
argument_list|(
name|raises
argument_list|,
name|fn_raises
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|raises
return|;
block|}
end_function

begin_comment
comment|/* Locate the dtor of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_dtor
parameter_list|(
name|tree
name|type
parameter_list|,
name|void
modifier|*
name|client
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|CLASSTYPE_DESTRUCTORS
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Locate the default ctor of TYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_ctor
parameter_list|(
name|tree
name|type
parameter_list|,
name|void
modifier|*
name|client
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fns
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_DEFAULT_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Call lookup_fnfields_1 to create the constructor declarations, if      necessary.  */
if|if
condition|(
name|CLASSTYPE_LAZY_DEFAULT_CTOR
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|lazily_declare_fn
argument_list|(
name|sfk_constructor
argument_list|,
name|type
argument_list|)
return|;
for|for
control|(
name|fns
operator|=
name|CLASSTYPE_CONSTRUCTORS
argument_list|(
name|type
argument_list|)
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|parms
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|sufficient_parms_p
argument_list|(
name|parms
argument_list|)
condition|)
return|return
name|fn
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|copy_data
block|{
name|tree
name|name
decl_stmt|;
name|int
name|quals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Locate the copy ctor or copy assignment of TYPE. CLIENT_    points to a COPY_DATA holding the name (NULL for the ctor)    and desired qualifiers of the source operand.  */
end_comment

begin_function
specifier|static
name|tree
name|locate_copy
parameter_list|(
name|tree
name|type
parameter_list|,
name|void
modifier|*
name|client_
parameter_list|)
block|{
name|struct
name|copy_data
modifier|*
name|client
init|=
operator|(
expr|struct
name|copy_data
operator|*
operator|)
name|client_
decl_stmt|;
name|tree
name|fns
decl_stmt|;
name|tree
name|best
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|excess_p
init|=
name|false
decl_stmt|;
if|if
condition|(
name|client
operator|->
name|name
condition|)
block|{
name|int
name|ix
decl_stmt|;
name|ix
operator|=
name|lookup_fnfields_1
argument_list|(
name|type
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|fns
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|type
argument_list|)
argument_list|,
name|ix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* If construction of the copy constructor was postponed, create 	 it now.  */
if|if
condition|(
name|CLASSTYPE_LAZY_COPY_CTOR
argument_list|(
name|type
argument_list|)
condition|)
name|lazily_declare_fn
argument_list|(
name|sfk_copy_constructor
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fns
operator|=
name|CLASSTYPE_CONSTRUCTORS
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|NULL_TREE
return|;
for|for
control|(
init|;
name|fns
condition|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
control|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|src_type
decl_stmt|;
name|int
name|excess
decl_stmt|;
name|int
name|quals
decl_stmt|;
name|parms
operator|=
name|skip_artificial_parms_for
argument_list|(
name|fn
argument_list|,
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parms
condition|)
continue|continue;
name|src_type
operator|=
name|non_reference
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_type
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|src_type
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sufficient_parms_p
argument_list|(
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
continue|continue;
name|quals
operator|=
name|cp_type_quals
argument_list|(
name|src_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|quals
operator|&
operator|~
name|quals
condition|)
continue|continue;
name|excess
operator|=
name|quals
operator|&
operator|~
name|client
operator|->
name|quals
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
operator|(
name|excess_p
operator|&&
operator|!
name|excess
operator|)
condition|)
block|{
name|best
operator|=
name|fn
expr_stmt|;
name|excess_p
operator|=
name|excess
expr_stmt|;
block|}
else|else
comment|/* Ambiguous */
return|return
name|NULL_TREE
return|;
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Implicitly declare the special function indicated by KIND, as a    member of TYPE.  For copy constructors and assignment operators,    CONST_P indicates whether these functions should take a const    reference argument or a non-const reference.  Returns the    FUNCTION_DECL for the implicitly declared function.  */
end_comment

begin_function
specifier|static
name|tree
name|implicitly_declare_fn
parameter_list|(
name|special_function_kind
name|kind
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|const_p
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|parameter_types
init|=
name|void_list_node
decl_stmt|;
name|tree
name|return_type
decl_stmt|;
name|tree
name|fn_type
decl_stmt|;
name|tree
name|raises
init|=
name|empty_except_spec
decl_stmt|;
name|tree
name|rhs_parm_type
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|this_parm
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|HOST_WIDE_INT
name|saved_processing_template_decl
decl_stmt|;
comment|/* Because we create declarations for implicitly declared functions      lazily, we may be creating the declaration for a member of TYPE      while in some completely different context.  However, TYPE will      never be a dependent class (because we never want to do lookups      for implicitly defined functions in a dependent class).      Furthermore, we must set PROCESSING_TEMPLATE_DECL to zero here      because we only create clones for constructors and destructors      when not in a template.  */
name|gcc_assert
argument_list|(
operator|!
name|dependent_type_p
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|saved_processing_template_decl
operator|=
name|processing_template_decl
expr_stmt|;
name|processing_template_decl
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
operator|&&
operator|!
name|TYPE_FOR_JAVA
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|sfk_destructor
condition|)
comment|/* See comment in check_special_function_return_type.  */
name|return_type
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
else|else
name|return_type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|return_type
operator|=
name|void_type_node
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|sfk_destructor
case|:
comment|/* Destructor.  */
name|name
operator|=
name|constructor_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_dtor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|sfk_constructor
case|:
comment|/* Default constructor.  */
name|name
operator|=
name|constructor_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_ctor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|sfk_copy_constructor
case|:
case|case
name|sfk_assignment_operator
case|:
block|{
name|struct
name|copy_data
name|data
decl_stmt|;
name|data
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|data
operator|.
name|quals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|sfk_assignment_operator
condition|)
block|{
name|return_type
operator|=
name|build_reference_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|name
operator|=
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
expr_stmt|;
name|data
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
else|else
name|name
operator|=
name|constructor_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_p
condition|)
block|{
name|data
operator|.
name|quals
operator|=
name|TYPE_QUAL_CONST
expr_stmt|;
name|rhs_parm_type
operator|=
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
block|}
else|else
name|rhs_parm_type
operator|=
name|type
expr_stmt|;
name|rhs_parm_type
operator|=
name|build_reference_type
argument_list|(
name|rhs_parm_type
argument_list|)
expr_stmt|;
name|parameter_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs_parm_type
argument_list|,
name|parameter_types
argument_list|)
expr_stmt|;
name|raises
operator|=
name|synthesize_exception_spec
argument_list|(
name|type
argument_list|,
operator|&
name|locate_copy
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Create the function.  */
name|fn_type
operator|=
name|build_method_type_directly
argument_list|(
name|type
argument_list|,
name|return_type
argument_list|,
name|parameter_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|fn_type
operator|=
name|build_exception_variant
argument_list|(
name|fn_type
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|fn
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|name
argument_list|,
name|fn_type
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|fn
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|sfk_constructor
operator|||
name|kind
operator|==
name|sfk_copy_constructor
condition|)
name|DECL_CONSTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|sfk_destructor
condition|)
name|DECL_DESTRUCTOR_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|DECL_ASSIGNMENT_OPERATOR_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_OVERLOADED_OPERATOR_CODE
argument_list|(
name|fn
argument_list|,
name|NOP_EXPR
argument_list|)
expr_stmt|;
block|}
comment|/* Create the explicit arguments.  */
if|if
condition|(
name|rhs_parm_type
condition|)
block|{
comment|/* Note that this parameter is *not* marked DECL_ARTIFICIAL; we 	 want its type to be included in the mangled function 	 name.  */
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
operator|=
name|cp_build_parm_decl
argument_list|(
name|NULL_TREE
argument_list|,
name|rhs_parm_type
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Add the "this" parameter.  */
name|this_parm
operator|=
name|build_this_parm
argument_list|(
name|fn_type
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|this_parm
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
operator|=
name|this_parm
expr_stmt|;
name|grokclassfn
argument_list|(
name|type
argument_list|,
name|fn
argument_list|,
name|kind
operator|==
name|sfk_destructor
condition|?
name|DTOR_FLAG
else|:
name|NO_SPECIAL
argument_list|)
expr_stmt|;
name|set_linkage_according_to_type
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|fn
argument_list|,
name|toplevel_bindings_p
argument_list|()
argument_list|,
name|at_eof
argument_list|)
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TREE_USED
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore PROCESSING_TEMPLATE_DECL.  */
name|processing_template_decl
operator|=
name|saved_processing_template_decl
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Add an implicit declaration to TYPE for the kind of function    indicated by SFK.  Return the FUNCTION_DECL for the new implicit    declaration.  */
end_comment

begin_function
name|tree
name|lazily_declare_fn
parameter_list|(
name|special_function_kind
name|sfk
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|bool
name|const_p
decl_stmt|;
comment|/* Figure out whether or not the argument has a const reference      type.  */
if|if
condition|(
name|sfk
operator|==
name|sfk_copy_constructor
condition|)
name|const_p
operator|=
name|TYPE_HAS_CONST_INIT_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sfk
operator|==
name|sfk_assignment_operator
condition|)
name|const_p
operator|=
name|TYPE_HAS_CONST_ASSIGN_REF
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
comment|/* In this case, CONST_P will be ignored.  */
name|const_p
operator|=
name|false
expr_stmt|;
comment|/* Declare the function.  */
name|fn
operator|=
name|implicitly_declare_fn
argument_list|(
name|sfk
argument_list|,
name|type
argument_list|,
name|const_p
argument_list|)
expr_stmt|;
comment|/* A destructor may be virtual.  */
if|if
condition|(
name|sfk
operator|==
name|sfk_destructor
condition|)
name|check_for_override
argument_list|(
name|fn
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Add it to CLASSTYPE_METHOD_VEC.  */
name|add_method
argument_list|(
name|type
argument_list|,
name|fn
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Add it to TYPE_METHODS.  */
if|if
condition|(
name|sfk
operator|==
name|sfk_destructor
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
condition|)
comment|/* The ABI requires that a virtual destructor go at the end of the        vtable.  */
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* G++ 3.2 put the implicit destructor at the *beginning* of the 	 TYPE_METHODS list, which cause the destructor to be emitted 	 in an incorrect location in the vtable.  */
if|if
condition|(
name|warn_abi
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wabi
argument_list|,
literal|"vtable layout for class %qT may not be ABI-compliant"
literal|"and may change in a future version of GCC due to "
literal|"implicit virtual destructor"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fn
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|=
name|fn
expr_stmt|;
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|type
argument_list|,
name|fn
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfk
operator|==
name|sfk_assignment_operator
condition|)
name|CLASSTYPE_LAZY_ASSIGNMENT_OP
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Remember that the function has been created.  */
if|if
condition|(
name|sfk
operator|==
name|sfk_constructor
condition|)
name|CLASSTYPE_LAZY_DEFAULT_CTOR
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sfk
operator|==
name|sfk_copy_constructor
condition|)
name|CLASSTYPE_LAZY_COPY_CTOR
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sfk
operator|==
name|sfk_destructor
condition|)
name|CLASSTYPE_LAZY_DESTRUCTOR
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Create appropriate clones.  */
name|clone_function_decl
argument_list|(
name|fn
argument_list|,
comment|/*update_method_vec=*/
name|true
argument_list|)
expr_stmt|;
block|}
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Given a FUNCTION_DECL FN and a chain LIST, skip as many elements of LIST    as there are artificial parms in FN.  */
end_comment

begin_function
name|tree
name|skip_artificial_parms_for
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|list
parameter_list|)
block|{
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
return|return
name|list
return|;
if|if
condition|(
name|DECL_HAS_IN_CHARGE_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_HAS_VTT_PARM_P
argument_list|(
name|fn
argument_list|)
condition|)
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-cp-method.h"
end_include

end_unit

