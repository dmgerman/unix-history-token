begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform the semantic phase of parsing, i.e., the process of    building tree structure, checking semantic consistency, and    building RTL.  These routines are used both during actual parsing    and during the instantiation of template functions.     Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.    Written by Mark Mitchell (mmitchell@usa.net) based on code found    formerly in parse.y and pt.c.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* There routines provide a modular interface to perform many parsing    operations.  They may therefore be used during actual parsing, or    during template instantiation, which may be regarded as a    degenerate form of parsing.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|maybe_convert_cond
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|simplify_aggr_init_exprs_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_associated_thunks
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|finalize_nrv_r
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Deferred Access Checking Overview    ---------------------------------     Most C++ expressions and declarations require access checking    to be performed during parsing.  However, in several cases,    this has to be treated differently.     For member declarations, access checking has to be deferred    until more information about the declaration is known.  For    example:       class A { 	 typedef int X;        public: 	 X f();      };       A::X A::f();      A::X g();     When we are parsing the function return type `A::X', we don't    really know if this is allowed until we parse the function name.     Furthermore, some contexts require that access checking is    never performed at all.  These include class heads, and template    instantiations.     Typical use of access checking functions is described here:     1. When we enter a context that requires certain access checking       mode, the function `push_deferring_access_checks' is called with       DEFERRING argument specifying the desired mode.  Access checking       may be performed immediately (dk_no_deferred), deferred       (dk_deferred), or not performed (dk_no_check).     2. When a declaration such as a type, or a variable, is encountered,       the function `perform_or_defer_access_check' is called.  It       maintains a VEC of all deferred checks.     3. The global `current_class_type' or `current_function_decl' is then       setup by the parser.  `enforce_access' relies on these information       to check access.     4. Upon exiting the context mentioned in step 1,       `perform_deferred_access_checks' is called to check all declaration       stored in the VEC. `pop_deferring_access_checks' is then       called to restore the previous access checking mode.        In case of parsing error, we simply call `pop_deferring_access_checks'       without `perform_deferred_access_checks'.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|deferred_access
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* A VEC representing name-lookups for which we have deferred      checking access controls.  We cannot check the accessibility of      names used in a decl-specifier-seq until we know what is being      declared because code like:         class A { 	 class B {}; 	 B* f();        }         A::B* A::f() { return 0; }       is valid, even though `A::B' is not generally accessible.  */
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|GTY
argument_list|(
argument|()
argument_list|)
name|deferred_access_checks
expr_stmt|;
comment|/* The current mode of access checks.  */
name|enum
name|deferring_kind
name|deferring_access_checks_kind
block|;  }
end_typedef

begin_expr_stmt
name|deferred_access
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_O
argument_list|(
name|deferred_access
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_O
argument_list|(
name|deferred_access
argument_list|,
name|gc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Data for deferred access checking.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|deferred_access
argument_list|,
name|gc
argument_list|)
operator|*
name|deferred_access_stack
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|deferred_access_no_check
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Save the current deferred access states and start deferred    access checking iff DEFER_P is true.  */
end_comment

begin_function
name|void
name|push_deferring_access_checks
parameter_list|(
name|deferring_kind
name|deferring
parameter_list|)
block|{
comment|/* For context like template instantiation, access checking      disabling applies to all nested context.  */
if|if
condition|(
name|deferred_access_no_check
operator|||
name|deferring
operator|==
name|dk_no_check
condition|)
name|deferred_access_no_check
operator|++
expr_stmt|;
else|else
block|{
name|deferred_access
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|VEC_safe_push
argument_list|(
name|deferred_access
argument_list|,
name|gc
argument_list|,
name|deferred_access_stack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|deferred_access_checks
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|deferring_access_checks_kind
operator|=
name|deferring
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume deferring access checks again after we stopped doing    this previously.  */
end_comment

begin_function
name|void
name|resume_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|deferred_access_no_check
condition|)
name|VEC_last
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
operator|->
name|deferring_access_checks_kind
operator|=
name|dk_deferred
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop deferring access checks.  */
end_comment

begin_function
name|void
name|stop_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|deferred_access_no_check
condition|)
name|VEC_last
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
operator|->
name|deferring_access_checks_kind
operator|=
name|dk_no_deferred
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard the current deferred access checks and restore the    previous states.  */
end_comment

begin_function
name|void
name|pop_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|deferred_access_no_check
condition|)
name|deferred_access_no_check
operator|--
expr_stmt|;
else|else
name|VEC_pop
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a TREE_LIST representing the deferred checks.    The TREE_PURPOSE of each node is the type through which the    access occurred; the TREE_VALUE is the declaration named.    */
end_comment

begin_expr_stmt
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|get_deferred_access_checks
argument_list|(
argument|void
argument_list|)
block|{
if|if
condition|(
name|deferred_access_no_check
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
name|VEC_last
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
operator|->
name|deferred_access_checks
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/* Take current deferred checks and combine with the    previous states if we also defer checks previously.    Otherwise perform checks now.  */
end_comment

begin_function
name|void
name|pop_to_parent_deferring_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|deferred_access_no_check
condition|)
name|deferred_access_no_check
operator|--
expr_stmt|;
else|else
block|{
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
expr_stmt|;
name|deferred_access
modifier|*
name|ptr
decl_stmt|;
name|checks
operator|=
operator|(
name|VEC_last
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
operator|->
name|deferred_access_checks
operator|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|VEC_last
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|deferring_access_checks_kind
operator|==
name|dk_no_deferred
condition|)
block|{
comment|/* Check access.  */
name|perform_access_checks
argument_list|(
name|checks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Merge with parent.  */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|deferred_access_check
modifier|*
name|chk
decl_stmt|,
modifier|*
name|probe
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|deferred_access_check
argument_list|,
name|checks
argument_list|,
name|i
argument_list|,
name|chk
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|deferred_access_check
argument_list|,
name|ptr
operator|->
name|deferred_access_checks
argument_list|,
name|j
argument_list|,
name|probe
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|probe
operator|->
name|binfo
operator|==
name|chk
operator|->
name|binfo
operator|&&
name|probe
operator|->
name|decl
operator|==
name|chk
operator|->
name|decl
operator|&&
name|probe
operator|->
name|diag_decl
operator|==
name|chk
operator|->
name|diag_decl
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* Insert into parent's checks.  */
name|VEC_safe_push
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|,
name|ptr
operator|->
name|deferred_access_checks
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform the access checks in CHECKS.  The TREE_PURPOSE of each node    is the BINFO indicating the qualifying scope used to access the    DECL node stored in the TREE_VALUE of the node.  */
end_comment

begin_decl_stmt
name|void
name|perform_access_checks
argument_list|(
name|VEC
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|)
operator|*
name|checks
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|deferred_access_check
modifier|*
name|chk
decl_stmt|;
if|if
condition|(
operator|!
name|checks
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|deferred_access_check
argument_list|,
name|checks
argument_list|,
name|i
argument_list|,
name|chk
argument_list|)
condition|;
operator|++
name|i
control|)
name|enforce_access
argument_list|(
name|chk
operator|->
name|binfo
argument_list|,
name|chk
operator|->
name|decl
argument_list|,
name|chk
operator|->
name|diag_decl
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Perform the deferred access checks.     After performing the checks, we still have to keep the list    `deferred_access_stack->deferred_access_checks' since we may want    to check access for them again later in a different context.    For example:       class A {        typedef int X;        static X a;      };      A::X A::a, x;	// No error for `A::a', error for `x'     We have to perform deferred access of `A::X', first with `A::a',    next with `x'.  */
end_comment

begin_function
name|void
name|perform_deferred_access_checks
parameter_list|(
name|void
parameter_list|)
block|{
name|perform_access_checks
argument_list|(
name|get_deferred_access_checks
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Defer checking the accessibility of DECL, when looked up in    BINFO. DIAG_DECL is the declaration to use to print diagnostics.  */
end_comment

begin_function
name|void
name|perform_or_defer_access_check
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|diag_decl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|deferred_access
modifier|*
name|ptr
decl_stmt|;
name|deferred_access_check
modifier|*
name|chk
decl_stmt|;
name|deferred_access_check
modifier|*
name|new_access
decl_stmt|;
comment|/* Exit if we are in a context that no access checking is performed.      */
if|if
condition|(
name|deferred_access_no_check
condition|)
return|return;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_BINFO
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|VEC_last
argument_list|(
name|deferred_access
argument_list|,
name|deferred_access_stack
argument_list|)
expr_stmt|;
comment|/* If we are not supposed to defer access checks, just check now.  */
if|if
condition|(
name|ptr
operator|->
name|deferring_access_checks_kind
operator|==
name|dk_no_deferred
condition|)
block|{
name|enforce_access
argument_list|(
name|binfo
argument_list|,
name|decl
argument_list|,
name|diag_decl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* See if we are already going to perform this check.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|deferred_access_check
argument_list|,
name|ptr
operator|->
name|deferred_access_checks
argument_list|,
name|i
argument_list|,
name|chk
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
operator|->
name|decl
operator|==
name|decl
operator|&&
name|chk
operator|->
name|binfo
operator|==
name|binfo
operator|&&
name|chk
operator|->
name|diag_decl
operator|==
name|diag_decl
condition|)
block|{
return|return;
block|}
block|}
comment|/* If not, record the check.  */
name|new_access
operator|=
name|VEC_safe_push
argument_list|(
name|deferred_access_check
argument_list|,
name|gc
argument_list|,
name|ptr
operator|->
name|deferred_access_checks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_access
operator|->
name|binfo
operator|=
name|binfo
expr_stmt|;
name|new_access
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|new_access
operator|->
name|diag_decl
operator|=
name|diag_decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the current statement is a full expression,    i.e. temporaries created during that statement should be destroyed    at the end of the statement.  */
end_comment

begin_function
name|int
name|stmts_are_full_exprs_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_stmt_tree
argument_list|()
operator|->
name|stmts_are_full_exprs_p
return|;
block|}
end_function

begin_comment
comment|/* T is a statement.  Add it to the statement-tree.  This is the C++    version.  The C/ObjC frontends have a slightly different version of    this function.  */
end_comment

begin_function
name|tree
name|add_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|t
argument_list|)
operator|&&
name|code
operator|!=
name|LABEL_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|t
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
comment|/* When we expand a statement-tree, we must know whether or not the 	 statements are full-expressions.  We record that fact here.  */
name|STMT_IS_FULL_EXPR_P
argument_list|(
name|t
argument_list|)
operator|=
name|stmts_are_full_exprs_p
argument_list|()
expr_stmt|;
block|}
comment|/* Add T to the statement-tree.  Non-side-effect statements need to be      recorded during statement expressions.  */
name|append_to_statement_list_force
argument_list|(
name|t
argument_list|,
operator|&
name|cur_stmt_list
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Returns the stmt_tree (if any) to which statements are currently    being added.  If there is no active statement-tree, NULL is    returned.  */
end_comment

begin_function
name|stmt_tree
name|current_stmt_tree
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cfun
condition|?
operator|&
name|cfun
operator|->
name|language
operator|->
name|base
operator|.
name|x_stmt_tree
else|:
operator|&
name|scope_chain
operator|->
name|x_stmt_tree
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If statements are full expressions, wrap STMT in a CLEANUP_POINT_EXPR.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_cleanup_point_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expr
operator|=
name|fold_build_cleanup_point_expr
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Like maybe_cleanup_point_expr except have the type of the new expression be    void so we don't need to create a temporary variable to hold the inner    expression.  The reason why we do this is because the original type might be    an aggregate and we cannot create a temporary variable for that type.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_cleanup_point_expr_void
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|expr
operator|=
name|fold_build_cleanup_point_expr
argument_list|(
name|void_type_node
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Create a declaration statement for the declaration given by the DECL.  */
end_comment

begin_function
name|void
name|add_decl_expr
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|DECL_EXPR
argument_list|,
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
name|r
operator|=
name|maybe_cleanup_point_expr_void
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if TYPE is an anonymous union or struct type.  We have to use a    flag for this because "A union for which objects or pointers are    declared is not an anonymous union" [class.union].  */
end_comment

begin_function
name|int
name|anon_aggr_type_p
parameter_list|(
name|tree
name|node
parameter_list|)
block|{
return|return
name|ANON_AGGR_TYPE_P
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a scope.  */
end_comment

begin_function
name|tree
name|do_poplevel
parameter_list|(
name|tree
name|stmt_list
parameter_list|)
block|{
name|tree
name|block
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|block
operator|=
name|poplevel
argument_list|(
name|kept_level_p
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stmt_list
operator|=
name|pop_stmt_list
argument_list|(
name|stmt_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|stmt_list
operator|=
name|c_build_bind_expr
argument_list|(
name|block
argument_list|,
name|stmt_list
argument_list|)
expr_stmt|;
comment|/* ??? See c_end_compound_stmt re statement expressions.  */
block|}
return|return
name|stmt_list
return|;
block|}
end_function

begin_comment
comment|/* Begin a new scope.  */
end_comment

begin_function
specifier|static
name|tree
name|do_pushlevel
parameter_list|(
name|scope_kind
name|sk
parameter_list|)
block|{
name|tree
name|ret
init|=
name|push_stmt_list
argument_list|()
decl_stmt|;
if|if
condition|(
name|stmts_are_full_exprs_p
argument_list|()
condition|)
name|begin_scope
argument_list|(
name|sk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Queue a cleanup.  CLEANUP is an expression/statement to be executed    when the current scope is exited.  EH_ONLY is true when this is not    meant to apply to normal control flow transfer.  */
end_comment

begin_function
name|void
name|push_cleanup
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|cleanup
parameter_list|,
name|bool
name|eh_only
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|NULL
argument_list|,
name|cleanup
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|CLEANUP_EH_ONLY
argument_list|(
name|stmt
argument_list|)
operator|=
name|eh_only
expr_stmt|;
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|CLEANUP_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a conditional that might contain a declaration.  When generating    normal code, we want the declaration to appear before the statement    containing the conditional.  When generating template code, we want the    conditional to be rendered as the raw DECL_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|begin_cond
parameter_list|(
name|tree
modifier|*
name|cond_p
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
operator|*
name|cond_p
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish such a conditional.  */
end_comment

begin_function
specifier|static
name|void
name|finish_cond
parameter_list|(
name|tree
modifier|*
name|cond_p
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|tree
name|cond
init|=
name|pop_stmt_list
argument_list|(
operator|*
name|cond_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|DECL_EXPR
condition|)
name|expr
operator|=
name|cond
expr_stmt|;
block|}
operator|*
name|cond_p
operator|=
name|expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If *COND_P specifies a conditional with a declaration, transform the    loop such that 	    while (A x = 42) { } 	    for (; A x = 42;) { }    becomes 	    while (true) { A x = 42; if (!x) break; } 	    for (;;) { A x = 42; if (!x) break; }    The statement list for BODY will be empty if the conditional did    not declare anything.  */
end_comment

begin_function
specifier|static
name|void
name|simplify_loop_decl_cond
parameter_list|(
name|tree
modifier|*
name|cond_p
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|tree
name|cond
decl_stmt|,
name|if_stmt
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|body
argument_list|)
condition|)
return|return;
name|cond
operator|=
operator|*
name|cond_p
expr_stmt|;
operator|*
name|cond_p
operator|=
name|boolean_true_node
expr_stmt|;
name|if_stmt
operator|=
name|begin_if_stmt
argument_list|()
expr_stmt|;
name|cond
operator|=
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_if_stmt_cond
argument_list|(
name|cond
argument_list|,
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_break_stmt
argument_list|()
expr_stmt|;
name|finish_then_clause
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|finish_if_stmt
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a goto-statement.  */
end_comment

begin_function
name|tree
name|finish_goto_stmt
parameter_list|(
name|tree
name|destination
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|destination
operator|=
name|lookup_label
argument_list|(
name|destination
argument_list|)
expr_stmt|;
comment|/* We warn about unused labels with -Wunused.  That means we have to      mark the used labels as used.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|destination
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|TREE_USED
argument_list|(
name|destination
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* The DESTINATION is being used as an rvalue.  */
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|destination
operator|=
name|decay_conversion
argument_list|(
name|destination
argument_list|)
expr_stmt|;
comment|/* We don't inline calls to functions with computed gotos. 	 Those functions are typically up to some funny business, 	 and may be depending on the labels being at particular 	 addresses, or some such.  */
name|DECL_UNINLINABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|check_goto
argument_list|(
name|destination
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|GOTO_EXPR
argument_list|,
name|destination
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* COND is the condition-expression for an if, while, etc.,    statement.  Convert it to a boolean value, if appropriate.  */
end_comment

begin_function
specifier|static
name|tree
name|maybe_convert_cond
parameter_list|(
name|tree
name|cond
parameter_list|)
block|{
comment|/* Empty conditions remain empty.  */
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Wait until we instantiate templates before doing conversion.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|cond
return|;
comment|/* Do the conversion.  */
name|cond
operator|=
name|convert_from_reference
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|cond
argument_list|)
operator|&&
name|warn_parentheses
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|cond
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|condition_conversion
argument_list|(
name|cond
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression-statement, whose EXPRESSION is as indicated.  */
end_comment

begin_function
name|tree
name|finish_expr_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|r
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|warn_sequence_point
condition|)
name|verify_sequence_points
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_to_void
argument_list|(
name|expr
argument_list|,
literal|"statement"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
name|convert_to_void
argument_list|(
name|build_non_dependent_expr
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|"statement"
argument_list|)
expr_stmt|;
comment|/* Simplification of inner statement expressions, compound exprs, 	 etc can result in us already having an EXPR_STMT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|CLEANUP_POINT_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|EXPR_STMT
condition|)
name|expr
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|maybe_cleanup_point_expr_void
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|add_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin an if-statement.  Returns a newly created IF_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_if_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|,
name|scope
decl_stmt|;
name|scope
operator|=
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|IF_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|scope
expr_stmt|;
name|begin_cond
argument_list|(
operator|&
name|IF_COND
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_if_stmt_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|if_stmt
parameter_list|)
block|{
name|finish_cond
argument_list|(
operator|&
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
argument_list|,
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the then-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|tree
name|finish_then_clause
parameter_list|(
name|tree
name|if_stmt
parameter_list|)
block|{
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|if_stmt
return|;
block|}
end_function

begin_comment
comment|/* Begin the else-clause of an if-statement.  */
end_comment

begin_function
name|void
name|begin_else_clause
parameter_list|(
name|tree
name|if_stmt
parameter_list|)
block|{
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the else-clause of an if-statement, which may be given by    IF_STMT.  */
end_comment

begin_function
name|void
name|finish_else_clause
parameter_list|(
name|tree
name|if_stmt
parameter_list|)
block|{
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an if-statement.  */
end_comment

begin_function
name|void
name|finish_if_stmt
parameter_list|(
name|tree
name|if_stmt
parameter_list|)
block|{
name|tree
name|scope
init|=
name|TREE_CHAIN
argument_list|(
name|if_stmt
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_stmt
argument_list|(
name|do_poplevel
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
name|empty_body_warning
argument_list|(
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|,
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a while-statement.  Returns a newly created WHILE_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_while_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|WHILE_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|WHILE_BODY
argument_list|(
name|r
argument_list|)
operator|=
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
name|begin_cond
argument_list|(
operator|&
name|WHILE_COND
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Process the COND of a while-statement, which may be given by    WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|while_stmt
parameter_list|)
block|{
name|finish_cond
argument_list|(
operator|&
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
argument_list|,
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|simplify_loop_decl_cond
argument_list|(
operator|&
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
argument_list|,
name|WHILE_BODY
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a while-statement, which may be given by WHILE_STMT.  */
end_comment

begin_function
name|void
name|finish_while_stmt
parameter_list|(
name|tree
name|while_stmt
parameter_list|)
block|{
name|WHILE_BODY
argument_list|(
name|while_stmt
argument_list|)
operator|=
name|do_poplevel
argument_list|(
name|WHILE_BODY
argument_list|(
name|while_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a do-statement.  Returns a newly created DO_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_do_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|DO_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|DO_BODY
argument_list|(
name|r
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the body of a do-statement, which may be given by DO_STMT.  */
end_comment

begin_function
name|void
name|finish_do_body
parameter_list|(
name|tree
name|do_stmt
parameter_list|)
block|{
name|DO_BODY
argument_list|(
name|do_stmt
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|DO_BODY
argument_list|(
name|do_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a do-statement, which may be given by DO_STMT, and whose    COND is as indicated.  */
end_comment

begin_function
name|void
name|finish_do_stmt
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|do_stmt
parameter_list|)
block|{
name|cond
operator|=
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|DO_COND
argument_list|(
name|do_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a return-statement.  The EXPRESSION returned, if any, is as    indicated.  */
end_comment

begin_function
name|tree
name|finish_return_stmt
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|bool
name|no_warning
decl_stmt|;
name|expr
operator|=
name|check_return_expr
argument_list|(
name|expr
argument_list|,
operator|&
name|no_warning
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_openmp
operator|&&
operator|!
name|check_omp_return
argument_list|()
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|DECL_DESTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|||
operator|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|targetm
operator|.
name|cxx
operator|.
name|cdtor_returns_this
argument_list|()
operator|)
condition|)
block|{
comment|/* Similarly, all destructors must run destructors for 	     base-classes before returning.  So, all returns in a 	     destructor get sent to the DTOR_LABEL; finish_function emits 	     code to return a value there.  */
return|return
name|finish_goto_stmt
argument_list|(
name|cdtor_label
argument_list|)
return|;
block|}
block|}
name|r
operator|=
name|build_stmt
argument_list|(
name|RETURN_EXPR
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|r
argument_list|)
operator||=
name|no_warning
expr_stmt|;
name|r
operator|=
name|maybe_cleanup_point_expr_void
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */
end_comment

begin_function
name|tree
name|begin_for_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|FOR_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_new_for_scope
operator|>
literal|0
condition|)
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|do_pushlevel
argument_list|(
name|sk_for
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|FOR_INIT_STMT
argument_list|(
name|r
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the for-init-statement of a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_init_stmt
parameter_list|(
name|tree
name|for_stmt
parameter_list|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
name|FOR_INIT_STMT
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|FOR_INIT_STMT
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
name|FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
name|begin_cond
argument_list|(
operator|&
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the COND of a for-statement, which may be given by    FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|for_stmt
parameter_list|)
block|{
name|finish_cond
argument_list|(
operator|&
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
argument_list|,
name|maybe_convert_cond
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|simplify_loop_decl_cond
argument_list|(
operator|&
name|FOR_COND
argument_list|(
name|for_stmt
argument_list|)
argument_list|,
name|FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the increment-EXPRESSION in a for-statement, which may be    given by FOR_STMT.  */
end_comment

begin_function
name|void
name|finish_for_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|for_stmt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expr
condition|)
return|return;
comment|/* If EXPR is an overloaded function, issue an error; there is no      context available to use to perform overload resolution.  */
if|if
condition|(
name|type_unknown_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|cxx_incomplete_type_error
argument_list|(
name|expr
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|warn_sequence_point
condition|)
name|verify_sequence_points
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|convert_to_void
argument_list|(
name|expr
argument_list|,
literal|"3rd expression in for"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
name|convert_to_void
argument_list|(
name|build_non_dependent_expr
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|"3rd expression in for"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|maybe_cleanup_point_expr_void
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|FOR_EXPR
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a for-statement, which may be given by    FOR_STMT.  The increment-EXPR for the loop must be    provided.  */
end_comment

begin_function
name|void
name|finish_for_stmt
parameter_list|(
name|tree
name|for_stmt
parameter_list|)
block|{
name|FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|do_poplevel
argument_list|(
name|FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop the scope for the body of the loop.  */
if|if
condition|(
name|flag_new_for_scope
operator|>
literal|0
condition|)
block|{
name|tree
name|scope
init|=
name|TREE_CHAIN
argument_list|(
name|for_stmt
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_stmt
argument_list|(
name|do_poplevel
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a break-statement.  */
end_comment

begin_function
name|tree
name|finish_break_stmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|BREAK_STMT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a continue-statement.  */
end_comment

begin_function
name|tree
name|finish_continue_stmt
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|CONTINUE_STMT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Begin a switch-statement.  Returns a new SWITCH_STMT if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_switch_stmt
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|,
name|scope
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|SWITCH_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|scope
operator|=
name|do_pushlevel
argument_list|(
name|sk_block
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|scope
expr_stmt|;
name|begin_cond
argument_list|(
operator|&
name|SWITCH_STMT_COND
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the cond of a switch-statement.  */
end_comment

begin_function
name|void
name|finish_switch_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|tree
name|switch_stmt
parameter_list|)
block|{
name|tree
name|orig_type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|index
decl_stmt|;
comment|/* Convert the condition to an integer or enumeration type.  */
name|cond
operator|=
name|build_expr_type_conversion
argument_list|(
name|WANT_INT
operator||
name|WANT_ENUM
argument_list|,
name|cond
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"switch quantity not an integer"
argument_list|)
expr_stmt|;
name|cond
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|orig_type
operator|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* [stmt.switch]  	     Integral promotions are performed.  */
name|cond
operator|=
name|perform_integral_promotions
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|cond
operator|=
name|maybe_cleanup_point_expr
argument_list|(
name|cond
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|!=
name|error_mark_node
condition|)
block|{
name|index
operator|=
name|get_unwidened
argument_list|(
name|cond
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* We can't strip a conversion from a signed type to an unsigned, 	     because if we did, int_fits_type_p would do the wrong thing 	     when checking case values for being in range, 	     and it's too hard to do the right thing.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|==
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
name|cond
operator|=
name|index
expr_stmt|;
block|}
block|}
name|finish_cond
argument_list|(
operator|&
name|SWITCH_STMT_COND
argument_list|(
name|switch_stmt
argument_list|)
argument_list|,
name|cond
argument_list|)
expr_stmt|;
name|SWITCH_STMT_TYPE
argument_list|(
name|switch_stmt
argument_list|)
operator|=
name|orig_type
expr_stmt|;
name|add_stmt
argument_list|(
name|switch_stmt
argument_list|)
expr_stmt|;
name|push_switch
argument_list|(
name|switch_stmt
argument_list|)
expr_stmt|;
name|SWITCH_STMT_BODY
argument_list|(
name|switch_stmt
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a switch-statement, which may be given by    SWITCH_STMT.  The COND to switch on is indicated.  */
end_comment

begin_function
name|void
name|finish_switch_stmt
parameter_list|(
name|tree
name|switch_stmt
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
name|SWITCH_STMT_BODY
argument_list|(
name|switch_stmt
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|SWITCH_STMT_BODY
argument_list|(
name|switch_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|pop_switch
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
name|scope
operator|=
name|TREE_CHAIN
argument_list|(
name|switch_stmt
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|switch_stmt
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|add_stmt
argument_list|(
name|do_poplevel
argument_list|(
name|scope
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a try-block.  Returns a newly-created TRY_BLOCK if    appropriate.  */
end_comment

begin_function
name|tree
name|begin_try_block
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
init|=
name|build_stmt
argument_list|(
name|TRY_BLOCK
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|TRY_STMTS
argument_list|(
name|r
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  The block returned in    *COMPOUND_STMT is an artificial outer scope, containing the    function-try-block.  */
end_comment

begin_function
name|tree
name|begin_function_try_block
parameter_list|(
name|tree
modifier|*
name|compound_stmt
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
comment|/* This outer scope does not exist in the C++ standard, but we need      a place to put __FUNCTION__ and similar variables.  */
operator|*
name|compound_stmt
operator|=
name|begin_compound_stmt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|begin_try_block
argument_list|()
expr_stmt|;
name|FN_TRY_BLOCK_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish a try-block, which may be given by TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_try_block
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the body of a cleanup try-block, which may be given by    TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_cleanup_try_block
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|TRY_STMTS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an implicitly generated try-block, with a cleanup is given    by CLEANUP.  */
end_comment

begin_function
name|void
name|finish_cleanup
parameter_list|(
name|tree
name|cleanup
parameter_list|,
name|tree
name|try_block
parameter_list|)
block|{
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
operator|=
name|cleanup
expr_stmt|;
name|CLEANUP_P
argument_list|(
name|try_block
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, for a function-try-block.  */
end_comment

begin_function
name|void
name|finish_function_try_block
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|finish_try_block
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
comment|/* FIXME : something queer about CTOR_INITIALIZER somehow following      the try block, but moving it inside.  */
name|in_function_try_handler
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a handler-sequence for a try-block, which may be given by    TRY_BLOCK.  */
end_comment

begin_function
name|void
name|finish_handler_sequence
parameter_list|(
name|tree
name|try_block
parameter_list|)
block|{
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
name|check_handlers
argument_list|(
name|TRY_HANDLERS
argument_list|(
name|try_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the handler-seq for a function-try-block, given by    TRY_BLOCK.  COMPOUND_STMT is the outer block created by    begin_function_try_block.  */
end_comment

begin_function
name|void
name|finish_function_handler_sequence
parameter_list|(
name|tree
name|try_block
parameter_list|,
name|tree
name|compound_stmt
parameter_list|)
block|{
name|in_function_try_handler
operator|=
literal|0
expr_stmt|;
name|finish_handler_sequence
argument_list|(
name|try_block
argument_list|)
expr_stmt|;
name|finish_compound_stmt
argument_list|(
name|compound_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a handler.  Returns a HANDLER if appropriate.  */
end_comment

begin_function
name|tree
name|begin_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|HANDLER
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Create a binding level for the eh_info and the exception object      cleanup.  */
name|HANDLER_BODY
argument_list|(
name|r
argument_list|)
operator|=
name|do_pushlevel
argument_list|(
name|sk_catch
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish the handler-parameters for a handler, which may be given by    HANDLER.  DECL is the declaration for the catch parameter, or NULL    if this is a `catch (...)' clause.  */
end_comment

begin_function
name|void
name|finish_handler_parms
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|handler
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|decl
condition|)
block|{
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|push_template_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|HANDLER_PARMS
argument_list|(
name|handler
argument_list|)
operator|=
name|decl
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|type
operator|=
name|expand_start_catch_block
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|HANDLER_TYPE
argument_list|(
name|handler
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
operator|&&
name|type
condition|)
name|mark_used
argument_list|(
name|eh_type_info
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a handler, which may be given by HANDLER.  The BLOCKs are    the return value from the matching call to finish_handler_parms.  */
end_comment

begin_function
name|void
name|finish_handler
parameter_list|(
name|tree
name|handler
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
name|expand_end_catch_block
argument_list|()
expr_stmt|;
name|HANDLER_BODY
argument_list|(
name|handler
argument_list|)
operator|=
name|do_poplevel
argument_list|(
name|HANDLER_BODY
argument_list|(
name|handler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a compound statement.  FLAGS contains some bits that control the    behavior and context.  If BCS_NO_SCOPE is set, the compound statement    does not define a scope.  If BCS_FN_BODY is set, this is the outermost    block of a function.  If BCS_TRY_BLOCK is set, this is the block    created on behalf of a TRY statement.  Returns a token to be passed to    finish_compound_stmt.  */
end_comment

begin_function
name|tree
name|begin_compound_stmt
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|BCS_NO_SCOPE
condition|)
block|{
name|r
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|STATEMENT_LIST_NO_SCOPE
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Normally, we try hard to keep the BLOCK for a statement-expression. 	 But, if it's a statement-expression with a scopeless block, there's 	 nothing to keep, and we don't want to accidentally keep a block 	 *inside* the scopeless block.  */
name|keep_next_level
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
name|do_pushlevel
argument_list|(
name|flags
operator|&
name|BCS_TRY_BLOCK
condition|?
name|sk_try
else|:
name|sk_block
argument_list|)
expr_stmt|;
comment|/* When processing a template, we need to remember where the braces were,      so that we can set up identical scopes when instantiating the template      later.  BIND_EXPR is a handy candidate for this.      Note that do_poplevel won't create a BIND_EXPR itself here (and thus      result in nested BIND_EXPRs), since we don't build BLOCK nodes when      processing templates.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|r
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BIND_EXPR_TRY_BLOCK
argument_list|(
name|r
argument_list|)
operator|=
operator|(
name|flags
operator|&
name|BCS_TRY_BLOCK
operator|)
operator|!=
literal|0
expr_stmt|;
name|BIND_EXPR_BODY_BLOCK
argument_list|(
name|r
argument_list|)
operator|=
operator|(
name|flags
operator|&
name|BCS_FN_BODY
operator|)
operator|!=
literal|0
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Finish a compound-statement, which is given by STMT.  */
end_comment

begin_function
name|void
name|finish_compound_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|BIND_EXPR_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|do_poplevel
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STATEMENT_LIST_NO_SCOPE
argument_list|(
name|stmt
argument_list|)
condition|)
name|stmt
operator|=
name|pop_stmt_list
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Destroy any ObjC "super" receivers that may have been 	 created.  */
name|objc_clear_super_receiver
argument_list|()
expr_stmt|;
name|stmt
operator|=
name|do_poplevel
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
comment|/* ??? See c_end_compound_stmt wrt statement expressions.  */
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an asm-statement, whose components are a STRING, some    OUTPUT_OPERANDS, some INPUT_OPERANDS, and some CLOBBERS.  Also note    whether the asm-statement should be considered volatile.  */
end_comment

begin_function
name|tree
name|finish_asm_stmt
parameter_list|(
name|int
name|volatile_p
parameter_list|,
name|tree
name|string
parameter_list|,
name|tree
name|output_operands
parameter_list|,
name|tree
name|input_operands
parameter_list|,
name|tree
name|clobbers
parameter_list|)
block|{
name|tree
name|r
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|int
name|ninputs
init|=
name|list_length
argument_list|(
name|input_operands
argument_list|)
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|output_operands
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
name|tree
name|operand
decl_stmt|;
name|int
name|i
decl_stmt|;
name|oconstraints
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|noutputs
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|string
operator|=
name|resolve_asm_operand_names
argument_list|(
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|t
operator|=
name|output_operands
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|operand
operator|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* ??? Really, this should not be here.  Users should be using a 	     proper lvalue, dammit.  But there's a long history of using 	     casts in the output operands.  In cases like longlong.h, this 	     becomes a primitive form of typechecking -- if the cast can be 	     removed, then the output operand had a type of the proper width; 	     otherwise we'll get an error.  Gross, but ...  */
name|STRIP_NOPS
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lvalue_or_else
argument_list|(
name|operand
argument_list|,
name|lv_asm
argument_list|)
condition|)
name|operand
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|operand
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|operand
argument_list|)
operator|||
name|CP_TYPE_CONST_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
comment|/* Functions are not modifiable, even though they are 		     lvalues.  */
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
comment|/* If it's an aggregate and any field is const, then it is 		     effectively const.  */
operator|||
operator|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|readonly_error
argument_list|(
name|operand
argument_list|,
literal|"assignment (via 'asm' output)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
expr_stmt|;
if|if
condition|(
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
condition|)
block|{
comment|/* If the operand is going to end up in memory, 		 mark it addressable.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
operator|!
name|cxx_mark_addressable
argument_list|(
name|operand
argument_list|)
condition|)
name|operand
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|operand
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|operand
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|t
operator|=
name|input_operands
init|;
name|t
condition|;
operator|++
name|i
operator|,
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operand
operator|=
name|decay_conversion
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the type of the operand hasn't been determined (e.g., 	     because it involves an overloaded function), then issue 	     an error message.  There's no context available to 	     resolve the overloading.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|operand
argument_list|)
operator|==
name|unknown_type_node
condition|)
block|{
name|error
argument_list|(
literal|"type of asm operand %qE could not be determined"
argument_list|,
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|operand
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
name|ninputs
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
condition|)
block|{
comment|/* If the operand is going to end up in memory, 		 mark it addressable.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
block|{
comment|/* Strip the nops as we allow this case.  FIXME, this really 		     should be rejected or made deprecated.  */
name|STRIP_NOPS
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cxx_mark_addressable
argument_list|(
name|operand
argument_list|)
condition|)
name|operand
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
else|else
name|operand
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|operand
expr_stmt|;
block|}
block|}
name|r
operator|=
name|build_stmt
argument_list|(
name|ASM_EXPR
argument_list|,
name|string
argument_list|,
name|output_operands
argument_list|,
name|input_operands
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
name|ASM_VOLATILE_P
argument_list|(
name|r
argument_list|)
operator|=
name|volatile_p
operator|||
name|noutputs
operator|==
literal|0
expr_stmt|;
name|r
operator|=
name|maybe_cleanup_point_expr_void
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a label with the indicated NAME.  */
end_comment

begin_function
name|tree
name|finish_label_stmt
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|decl
init|=
name|define_label
argument_list|(
name|input_location
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_EXPR
argument_list|,
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a series of declarations for local labels.  G++ allows users    to declare "local" labels, i.e., labels with scope.  This extension    is useful when writing code involving statement-expressions.  */
end_comment

begin_function
name|void
name|finish_label_decl
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|at_function_scope_p
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"__label__ declarations are only allowed in function scopes"
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_decl_expr
argument_list|(
name|declare_local_label
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When DECL goes out of scope, make sure that CLEANUP is executed.  */
end_comment

begin_function
name|void
name|finish_decl_cleanup
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|cleanup
parameter_list|)
block|{
name|push_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the current scope exits with an exception, run CLEANUP.  */
end_comment

begin_function
name|void
name|finish_eh_cleanup
parameter_list|(
name|tree
name|cleanup
parameter_list|)
block|{
name|push_cleanup
argument_list|(
name|NULL
argument_list|,
name|cleanup
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The MEM_INITS is a list of mem-initializers, in reverse of the    order they were written by the user.  Each node is as for    emit_mem_initializers.  */
end_comment

begin_function
name|void
name|finish_mem_initializers
parameter_list|(
name|tree
name|mem_inits
parameter_list|)
block|{
comment|/* Reorder the MEM_INITS so that they are in the order they appeared      in the source program.  */
name|mem_inits
operator|=
name|nreverse
argument_list|(
name|mem_inits
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|add_stmt
argument_list|(
name|build_min_nt
argument_list|(
name|CTOR_INITIALIZER
argument_list|,
name|mem_inits
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_mem_initializers
argument_list|(
name|mem_inits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a parenthesized expression EXPR.  */
end_comment

begin_function
name|tree
name|finish_parenthesized_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|EXPR_P
argument_list|(
name|expr
argument_list|)
condition|)
comment|/* This inhibits warnings in c_common_truthvalue_conversion.  */
name|TREE_NO_WARNING
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|OFFSET_REF
condition|)
comment|/* [expr.unary.op]/3 The qualified id of a pointer-to-member must not be        enclosed in parentheses.  */
name|PTRMEM_OK_P
argument_list|(
name|expr
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|STRING_CST
condition|)
name|PAREN_STRING_LITERAL_P
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Finish a reference to a non-static data member (DECL) that is not    preceded by `.' or `->'.  */
end_comment

begin_function
name|tree
name|finish_non_static_data_member
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|object
parameter_list|,
name|tree
name|qualifying_scope
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|object
condition|)
block|{
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of member %q+D in static member function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid use of non-static data member %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"from this location"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_USED
argument_list|(
name|current_class_ptr
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
operator|!
name|qualifying_scope
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Set the cv qualifiers.  */
name|int
name|quals
init|=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_class_ref
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_MUTABLE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|quals
operator|&=
operator|~
name|TYPE_QUAL_CONST
expr_stmt|;
name|quals
operator||=
name|cp_type_quals
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|cp_build_qualified_type
argument_list|(
name|type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
return|return
name|build_min
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|object
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
else|else
block|{
name|tree
name|access_type
init|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
decl_stmt|;
name|tree
name|lookup_context
init|=
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|DERIVED_FROM_P
argument_list|(
name|lookup_context
argument_list|,
name|access_type
argument_list|)
condition|)
block|{
name|access_type
operator|=
name|TYPE_CONTEXT
argument_list|(
name|access_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|access_type
operator|&&
name|DECL_P
argument_list|(
name|access_type
argument_list|)
condition|)
name|access_type
operator|=
name|DECL_CONTEXT
argument_list|(
name|access_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|access_type
condition|)
block|{
name|error
argument_list|(
literal|"object missing in reference to %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"from this location"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
comment|/* If PROCESSING_TEMPLATE_DECL is nonzero here, then 	 QUALIFYING_SCOPE is also non-null.  Wrap this in a SCOPE_REF 	 for now.  */
if|if
condition|(
name|processing_template_decl
condition|)
return|return
name|build_qualified_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|qualifying_scope
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*template_p=*/
name|false
argument_list|)
return|;
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|access_type
argument_list|)
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If the data member was named `C::M', convert `*this' to `C' 	 first.  */
if|if
condition|(
name|qualifying_scope
condition|)
block|{
name|tree
name|binfo
init|=
name|NULL_TREE
decl_stmt|;
name|object
operator|=
name|build_scoped_ref
argument_list|(
name|object
argument_list|,
name|qualifying_scope
argument_list|,
operator|&
name|binfo
argument_list|)
expr_stmt|;
block|}
return|return
name|build_class_member_access_expr
argument_list|(
name|object
argument_list|,
name|decl
argument_list|,
comment|/*access_path=*/
name|NULL_TREE
argument_list|,
comment|/*preserve_reference=*/
name|false
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* DECL was the declaration to which a qualified-id resolved.  Issue    an error message if it is not accessible.  If OBJECT_TYPE is    non-NULL, we have just seen `x->' or `x.' and OBJECT_TYPE is the    type of `*x', or `x', respectively.  If the DECL was named as    `A::B' then NESTED_NAME_SPECIFIER is `A'.  */
end_comment

begin_function
name|void
name|check_accessibility_of_qualified_id
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|object_type
parameter_list|,
name|tree
name|nested_name_specifier
parameter_list|)
block|{
name|tree
name|scope
decl_stmt|;
name|tree
name|qualifying_type
init|=
name|NULL_TREE
decl_stmt|;
comment|/* If we're not checking, return immediately.  */
if|if
condition|(
name|deferred_access_no_check
condition|)
return|return;
comment|/* Determine the SCOPE of DECL.  */
name|scope
operator|=
name|context_for_name_lookup
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If the SCOPE is not a type, then DECL is not a member.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
return|return;
comment|/* Compute the scope through which DECL is being accessed.  */
if|if
condition|(
name|object_type
comment|/* OBJECT_TYPE might not be a class type; consider:  	   class A { typedef int I; }; 	   I *p; 	   p->A::I::~I();  	 In this case, we will have "A::I" as the DECL, but "I" as the 	 OBJECT_TYPE.  */
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|object_type
argument_list|)
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|scope
argument_list|,
name|object_type
argument_list|)
condition|)
comment|/* If we are processing a `->' or `.' expression, use the type of the        left-hand side.  */
name|qualifying_type
operator|=
name|object_type
expr_stmt|;
elseif|else
if|if
condition|(
name|nested_name_specifier
condition|)
block|{
comment|/* If the reference is to a non-static member of the 	 current class, treat it as if it were referenced through 	 `this'.  */
if|if
condition|(
name|DECL_NONSTATIC_MEMBER_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|current_class_ptr
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|scope
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|qualifying_type
operator|=
name|current_class_type
expr_stmt|;
comment|/* Otherwise, use the type indicated by the 	 nested-name-specifier.  */
else|else
name|qualifying_type
operator|=
name|nested_name_specifier
expr_stmt|;
block|}
else|else
comment|/* Otherwise, the name must be from the current class or one of        its bases.  */
name|qualifying_type
operator|=
name|currently_open_derived_class
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifying_type
comment|/* It is possible for qualifying type to be a TEMPLATE_TYPE_PARM 	 or similar in a default argument value.  */
operator|&&
name|CLASS_TYPE_P
argument_list|(
name|qualifying_type
argument_list|)
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|qualifying_type
argument_list|)
condition|)
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|qualifying_type
argument_list|)
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXPR is the result of a qualified-id.  The QUALIFYING_CLASS was the    class named to the left of the "::" operator.  DONE is true if this    expression is a complete postfix-expression; it is false if this    expression is followed by '->', '[', '(', etc.  ADDRESS_P is true    iff this expression is the operand of '&'.  TEMPLATE_P is true iff    the qualified-id was of the form "A::template B".  TEMPLATE_ARG_P    is true iff this qualified name appears as a template argument.  */
end_comment

begin_function
name|tree
name|finish_qualified_id_expr
parameter_list|(
name|tree
name|qualifying_class
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|done
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bool
name|template_p
parameter_list|,
name|bool
name|template_arg_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|qualifying_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|DECL_P
argument_list|(
name|expr
argument_list|)
operator|||
name|BASELINK_P
argument_list|(
name|expr
argument_list|)
condition|)
name|mark_used
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|template_p
condition|)
name|check_template_keyword
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* If EXPR occurs as the operand of '&', use special handling that      permits a pointer-to-member.  */
if|if
condition|(
name|address_p
operator|&&
name|done
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SCOPE_REF
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build_offset_ref
argument_list|(
name|qualifying_class
argument_list|,
name|expr
argument_list|,
comment|/*address_p=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
comment|/* Within the scope of a class, turn references to non-static      members into expression of the form "this->...".  */
if|if
condition|(
name|template_arg_p
condition|)
comment|/* But, within a template argument, we do not want make the        transformation, as there is no "this" pointer.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|expr
operator|=
name|finish_non_static_data_member
argument_list|(
name|expr
argument_list|,
name|current_class_ref
argument_list|,
name|qualifying_class
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|BASELINK_P
argument_list|(
name|expr
argument_list|)
operator|&&
operator|!
name|processing_template_decl
condition|)
block|{
name|tree
name|fns
decl_stmt|;
comment|/* See if any of the functions are non-static members.  */
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If so, the expression may be relative to the current 	 class.  */
if|if
condition|(
operator|!
name|shared_member_p
argument_list|(
name|fns
argument_list|)
operator|&&
name|current_class_type
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|qualifying_class
argument_list|,
name|current_class_type
argument_list|)
condition|)
name|expr
operator|=
operator|(
name|build_class_member_access_expr
argument_list|(
name|maybe_dummy_object
argument_list|(
name|qualifying_class
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|expr
argument_list|,
name|BASELINK_ACCESS_BINFO
argument_list|(
name|expr
argument_list|)
argument_list|,
comment|/*preserve_reference=*/
name|false
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|done
condition|)
comment|/* The expression is a qualified name whose address is not 	   being taken.  */
name|expr
operator|=
name|build_offset_ref
argument_list|(
name|qualifying_class
argument_list|,
name|expr
argument_list|,
comment|/*address_p=*/
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Begin a statement-expression.  The value returned must be passed to    finish_stmt_expr.  */
end_comment

begin_function
name|tree
name|begin_stmt_expr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|push_stmt_list
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Process the final expression of a statement expression. EXPR can be    NULL, if the final expression is empty.  Return a STATEMENT_LIST    containing all the statements in the statement-expression, or    ERROR_MARK_NODE if there was an error.  */
end_comment

begin_function
name|tree
name|finish_stmt_expr_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|stmt_expr
parameter_list|)
block|{
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* If the last statement does not have "void" type, then the value      of the last statement is the value of the entire expression.  */
if|if
condition|(
name|expr
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|expr
operator|=
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|expr
operator|=
name|add_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Mark the last statement so that we can recognize it as such at 	     template-instantiation time.  */
name|EXPR_STMT_STMT_EXPR_RESULT
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Just treat this like an ordinary statement.  */
name|expr
operator|=
name|finish_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It actually has a value we need to deal with.  First, force it 	     to be an rvalue so that we won't need to build up a copy 	     constructor call later when we try to assign it to something.  */
name|expr
operator|=
name|force_rvalue
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
comment|/* Update for array-to-pointer decay.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Wrap it in a CLEANUP_POINT_EXPR and add it to the list like a 	     normal statement, but don't convert to void or actually add 	     the EXPR_STMT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|CLEANUP_POINT_EXPR
condition|)
name|expr
operator|=
name|maybe_cleanup_point_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* The type of the statement-expression is the type of the last 	 expression.  */
name|TREE_TYPE
argument_list|(
name|stmt_expr
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
return|return
name|stmt_expr
return|;
block|}
end_function

begin_comment
comment|/* Finish a statement-expression.  EXPR should be the value returned    by the previous begin_stmt_expr.  Returns an expression    representing the statement-expression.  */
end_comment

begin_function
name|tree
name|finish_stmt_expr
parameter_list|(
name|tree
name|stmt_expr
parameter_list|,
name|bool
name|has_no_scope
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|error_operand_p
argument_list|(
name|stmt_expr
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt_expr
argument_list|)
operator|==
name|STATEMENT_LIST
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|stmt_expr
argument_list|)
expr_stmt|;
name|result
operator|=
name|pop_stmt_list
argument_list|(
name|stmt_expr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|result
operator|=
name|build_min
argument_list|(
name|STMT_EXPR
argument_list|,
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|STMT_EXPR_NO_SCOPE
argument_list|(
name|result
argument_list|)
operator|=
name|has_no_scope
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Wrap the statement-expression in a TARGET_EXPR so that the 	 temporary object created by the final expression is destroyed at 	 the end of the full-expression containing the 	 statement-expression.  */
name|result
operator|=
name|force_target_expr
argument_list|(
name|type
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Perform Koenig lookup.  FN is the postfix-expression representing    the function (or functions) to call; ARGS are the arguments to the    call.  Returns the functions to be considered by overload    resolution.  */
end_comment

begin_function
name|tree
name|perform_koenig_lookup
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|tree
name|identifier
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|functions
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Find the name of the overloaded function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|identifier
operator|=
name|fn
expr_stmt|;
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|functions
operator|=
name|fn
expr_stmt|;
name|identifier
operator|=
name|DECL_NAME
argument_list|(
name|get_first_fn
argument_list|(
name|functions
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|functions
operator|=
name|fn
expr_stmt|;
name|identifier
operator|=
name|DECL_NAME
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* A call to a namespace-scope function using an unqualified name.       Do Koenig lookup -- unless any of the arguments are      type-dependent.  */
if|if
condition|(
operator|!
name|any_type_dependent_arguments_p
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|fn
operator|=
name|lookup_arg_dependent
argument_list|(
name|identifier
argument_list|,
name|functions
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
comment|/* The unqualified name could not be resolved.  */
name|fn
operator|=
name|unqualified_fn_lookup_error
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
block|}
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Generate an expression for `FN (ARGS)'.     If DISALLOW_VIRTUAL is true, the call to FN will be not generated    as a virtual call, even if FN is virtual.  (This flag is set when    encountering an expression where the function name is explicitly    qualified.  For example a call to `X::f' never generates a virtual    call.)     Returns code for the call.  */
end_comment

begin_function
name|tree
name|finish_call_expr
parameter_list|(
name|tree
name|fn
parameter_list|,
name|tree
name|args
parameter_list|,
name|bool
name|disallow_virtual
parameter_list|,
name|bool
name|koenig_p
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
name|tree
name|orig_fn
decl_stmt|;
name|tree
name|orig_args
decl_stmt|;
if|if
condition|(
name|fn
operator|==
name|error_mark_node
operator|||
name|args
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* ARGS should be a list of arguments.  */
name|gcc_assert
argument_list|(
operator|!
name|args
operator|||
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|==
name|TREE_LIST
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TYPE_P
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|orig_fn
operator|=
name|fn
expr_stmt|;
name|orig_args
operator|=
name|args
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|fn
argument_list|)
operator|||
name|any_type_dependent_arguments_p
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|result
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|KOENIG_LOOKUP_P
argument_list|(
name|result
argument_list|)
operator|=
name|koenig_p
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|!=
name|PSEUDO_DTOR_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
operator|!=
name|unknown_type_node
condition|)
name|fn
operator|=
name|build_non_dependent_expr
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|args
operator|=
name|build_non_dependent_args
argument_list|(
name|orig_args
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|baselink_for_fns
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|object
decl_stmt|;
comment|/* A call to a member function.  From [over.call.func]:  	   If the keyword this is in scope and refers to the class of 	   that member function, or a derived class thereof, then the 	   function call is transformed into a qualified function call 	   using (*this) as the postfix-expression to the left of the 	   . operator.... [Otherwise] a contrived object of type T 	   becomes the implied object argument.  	This paragraph is unclear about this situation:  	  struct A { void f(); }; 	  struct B : public A {}; 	  struct C : public A { void g() { B::f(); }};  	In particular, for `B::f', this paragraph does not make clear 	whether "the class of that member function" refers to `A' or 	to `B'.  We believe it refers to `B'.  */
if|if
condition|(
name|current_class_type
operator|&&
name|DERIVED_FROM_P
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BASELINK_ACCESS_BINFO
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|current_class_type
argument_list|)
operator|&&
name|current_class_ref
condition|)
name|object
operator|=
name|maybe_dummy_object
argument_list|(
name|BINFO_TYPE
argument_list|(
name|BASELINK_ACCESS_BINFO
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|representative_fn
decl_stmt|;
name|representative_fn
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|representative_fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|representative_fn
operator|=
name|TREE_OPERAND
argument_list|(
name|representative_fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|representative_fn
operator|=
name|get_first_fn
argument_list|(
name|representative_fn
argument_list|)
expr_stmt|;
name|object
operator|=
name|build_dummy_object
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|representative_fn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|object
argument_list|)
condition|)
return|return
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|orig_fn
argument_list|,
name|orig_args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
name|object
operator|=
name|build_non_dependent_expr
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_new_method_call
argument_list|(
name|object
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
name|disallow_virtual
condition|?
name|LOOKUP_NONVIRTUAL
else|:
literal|0
operator|)
argument_list|,
comment|/*fn_p=*/
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If the function is an overloaded builtin, resolve it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fn
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|||
name|DECL_BUILT_IN_CLASS
argument_list|(
name|fn
argument_list|)
operator|==
name|BUILT_IN_MD
operator|)
condition|)
name|result
operator|=
name|resolve_overloaded_builtin
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
comment|/* A call to a namespace-scope function.  */
name|result
operator|=
name|build_new_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|,
name|koenig_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|PSEUDO_DTOR_EXPR
condition|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"arguments to destructor are not allowed"
argument_list|)
expr_stmt|;
comment|/* Mark the pseudo-destructor call as having side-effects so 	 that we do not issue warnings about its use.  */
name|result
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
comment|/* If the "function" is really an object of class type, it might        have an overloaded `operator ()'.  */
name|result
operator|=
name|build_new_op
argument_list|(
name|CALL_EXPR
argument_list|,
name|LOOKUP_NORMAL
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*overloaded_p=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
comment|/* A call where the function is unknown.  */
name|result
operator|=
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|result
operator|=
name|build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|orig_fn
argument_list|,
name|orig_args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|KOENIG_LOOKUP_P
argument_list|(
name|result
argument_list|)
operator|=
name|koenig_p
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a call to a postfix increment or decrement or EXPR.  (Which    is indicated by CODE, which should be POSTINCREMENT_EXPR or    POSTDECREMENT_EXPR.)  */
end_comment

begin_function
name|tree
name|finish_increment_expr
parameter_list|(
name|tree
name|expr
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|)
block|{
return|return
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a use of `this'.  Returns an expression for `this'.  */
end_comment

begin_function
name|tree
name|finish_this_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|current_class_ptr
condition|)
block|{
name|result
operator|=
name|current_class_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_STATIC_FUNCTION_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<this%> is unavailable for static member functions"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current_function_decl
condition|)
name|error
argument_list|(
literal|"invalid use of %<this%> in non-member function"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid use of %<this%> at top level"
argument_list|)
expr_stmt|;
name|result
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a pseudo-destructor expression.  If SCOPE is NULL, the    expression was of the form `OBJECT.~DESTRUCTOR' where DESTRUCTOR is    the TYPE for the type given.  If SCOPE is non-NULL, the expression    was of the form `OBJECT.SCOPE::~DESTRUCTOR'.  */
end_comment

begin_function
name|tree
name|finish_pseudo_destructor_expr
parameter_list|(
name|tree
name|object
parameter_list|,
name|tree
name|scope
parameter_list|,
name|tree
name|destructor
parameter_list|)
block|{
if|if
condition|(
name|destructor
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|destructor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"invalid qualifying scope in pseudo-destructor name"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|scope
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|&&
operator|!
name|check_dtor_name
argument_list|(
name|scope
argument_list|,
name|destructor
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"qualified type %qT does not match destructor name ~%qT"
argument_list|,
name|scope
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* [expr.pseudo] says both:  	   The type designated by the pseudo-destructor-name shall be 	   the same as the object type.  	 and:  	   The cv-unqualified versions of the object type and of the 	   type designated by the pseudo-destructor-name shall be the 	   same type.  	 We implement the more generous second sentence, since that is 	 what most other compilers do.  */
if|if
condition|(
operator|!
name|same_type_ignoring_top_level_qualifiers_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|,
name|destructor
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE is not of type %qT"
argument_list|,
name|object
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
return|return
name|build3
argument_list|(
name|PSEUDO_DTOR_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|object
argument_list|,
name|scope
argument_list|,
name|destructor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression of the form CODE EXPR.  */
end_comment

begin_function
name|tree
name|finish_unary_op_expr
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|result
init|=
name|build_x_unary_op
argument_list|(
name|code
argument_list|,
name|expr
argument_list|)
decl_stmt|;
comment|/* Inside a template, build_x_unary_op does not fold the      expression. So check whether the result is folded before      setting TREE_NEGATED_INT.  */
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|result
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|&&
name|INT_CST_LT
argument_list|(
name|result
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
comment|/* RESULT may be a cached INTEGER_CST, so we must copy it before 	 setting TREE_NEGATED_INT.  */
name|result
operator|=
name|copy_node
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|TREE_NEGATED_INT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_OVERFLOW_P
argument_list|(
name|result
argument_list|)
operator|&&
operator|!
name|TREE_OVERFLOW_P
argument_list|(
name|expr
argument_list|)
condition|)
name|overflow_warning
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Finish a compound-literal expression.  TYPE is the type to which    the INITIALIZER_LIST is being cast.  */
end_comment

begin_decl_stmt
name|tree
name|finish_compound_literal
argument_list|(
name|tree
name|type
argument_list|,
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|initializer_list
argument_list|)
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|compound_literal
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_OBJ_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"compound literal of non-object type %qT"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Build a CONSTRUCTOR for the INITIALIZER_LIST.  */
name|compound_literal
operator|=
name|build_constructor
argument_list|(
name|NULL_TREE
argument_list|,
name|initializer_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|compound_literal
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Mark the expression as a compound literal.  */
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|compound_literal
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|compound_literal
return|;
block|}
comment|/* Create a temporary variable to represent the compound literal.  */
name|var
operator|=
name|create_temporary_var
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_function_decl
condition|)
block|{
comment|/* If this compound-literal appears outside of a function, then 	 the corresponding variable has static storage duration, just 	 like the variable in whose initializer it appears.  */
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The variable has internal linkage, since there is no need to 	 reference it from another translation unit.  */
name|TREE_PUBLIC
argument_list|(
name|var
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* It must have a name, so that the name mangler can mangle it.  */
name|DECL_NAME
argument_list|(
name|var
argument_list|)
operator|=
name|make_anon_name
argument_list|()
expr_stmt|;
block|}
comment|/* We must call pushdecl, since the gimplifier complains if the      variable has not been declared via a BIND_EXPR.  */
name|pushdecl
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Initialize the variable as we would any other variable with a      brace-enclosed initializer.  */
name|cp_finish_decl
argument_list|(
name|var
argument_list|,
name|compound_literal
argument_list|,
comment|/*init_const_expr_p=*/
name|false
argument_list|,
comment|/*asmspec_tree=*/
name|NULL_TREE
argument_list|,
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
return|return
name|var
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Return the declaration for the function-name variable indicated by    ID.  */
end_comment

begin_function
name|tree
name|finish_fname
parameter_list|(
name|tree
name|id
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|fname_decl
argument_list|(
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
condition|)
name|decl
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Finish a translation unit.  */
end_comment

begin_function
name|void
name|finish_translation_unit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* In case there were missing closebraces,      get us back to the global binding level.  */
name|pop_everything
argument_list|()
expr_stmt|;
while|while
condition|(
name|current_namespace
operator|!=
name|global_namespace
condition|)
name|pop_namespace
argument_list|()
expr_stmt|;
comment|/* Do file scope __FUNCTION__ et al.  */
name|finish_fname_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a template type parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_type_parm
parameter_list|(
name|tree
name|aggr
parameter_list|,
name|tree
name|identifier
parameter_list|)
block|{
if|if
condition|(
name|aggr
operator|!=
name|class_type_node
condition|)
block|{
name|pedwarn
argument_list|(
literal|"template type parameters must use the keyword %<class%> or %<typename%>"
argument_list|)
expr_stmt|;
name|aggr
operator|=
name|class_type_node
expr_stmt|;
block|}
return|return
name|build_tree_list
argument_list|(
name|aggr
argument_list|,
name|identifier
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish a template template parameter, specified as AGGR IDENTIFIER.    Returns the parameter.  */
end_comment

begin_function
name|tree
name|finish_template_template_parm
parameter_list|(
name|tree
name|aggr
parameter_list|,
name|tree
name|identifier
parameter_list|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|tmpl
init|=
name|build_lang_decl
argument_list|(
name|TEMPLATE_DECL
argument_list|,
name|identifier
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
operator|=
name|current_template_parms
expr_stmt|;
name|DECL_TEMPLATE_RESULT
argument_list|(
name|tmpl
argument_list|)
operator|=
name|decl
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|end_template_decl
argument_list|()
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_TEMPLATE_PARMS
argument_list|(
name|tmpl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|finish_template_type_parm
argument_list|(
name|aggr
argument_list|,
name|tmpl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARGUMENT is the default-argument value for a template template    parameter.  If ARGUMENT is invalid, issue error messages and return    the ERROR_MARK_NODE.  Otherwise, ARGUMENT itself is returned.  */
end_comment

begin_function
name|tree
name|check_template_template_default_arg
parameter_list|(
name|tree
name|argument
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|TEMPLATE_TEMPLATE_PARM
operator|&&
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|!=
name|UNBOUND_CLASS_TEMPLATE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|argument
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"invalid use of type %qT as a default value for a template "
literal|"template-parameter"
argument_list|,
name|TREE_TYPE
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid default argument for a template template parameter"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|argument
return|;
block|}
end_function

begin_comment
comment|/* Begin a class definition, as indicated by T.  */
end_comment

begin_function
name|tree
name|begin_class_definition
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|processing_template_parmlist
condition|)
block|{
name|error
argument_list|(
literal|"definition of %q#T inside template parameter list"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* A non-implicit typename comes from code like:         template<typename T> struct A { 	 template<typename U> struct A<T>::B ...       This is erroneous.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPENAME_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"invalid definition of qualified type %qT"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|error_mark_node
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|make_anon_name
argument_list|()
argument_list|,
name|t
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|)
expr_stmt|;
block|}
comment|/* Update the location of the decl.  */
name|DECL_SOURCE_LOCATION
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|input_location
expr_stmt|;
if|if
condition|(
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|make_aggr_type
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
comment|/*tag_scope=*/
name|ts_current
argument_list|)
expr_stmt|;
block|}
name|maybe_process_partial_specialization
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pushclass
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_BEING_DEFINED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|cplus_decl_attributes
argument_list|(
operator|&
name|t
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pack_struct
condition|)
block|{
name|tree
name|v
decl_stmt|;
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even though the type is being defined for the first time 	 here, there might have been a forward declaration, so there 	 might be cv-qualified variants of T.  */
for|for
control|(
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
init|;
name|v
condition|;
name|v
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|v
argument_list|)
control|)
name|TYPE_PACKED
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Reset the interface data, at the earliest possible      moment, as it might have been set via a class foo;      before.  */
if|if
condition|(
operator|!
name|TYPE_ANONYMOUS_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|struct
name|c_fileinfo
modifier|*
name|finfo
init|=
name|get_fileinfo
argument_list|(
name|input_filename
argument_list|)
decl_stmt|;
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|t
argument_list|)
operator|=
name|finfo
operator|->
name|interface_only
expr_stmt|;
name|SET_CLASSTYPE_INTERFACE_UNKNOWN_X
argument_list|(
name|t
argument_list|,
name|finfo
operator|->
name|interface_unknown
argument_list|)
expr_stmt|;
block|}
name|reset_specialization
argument_list|()
expr_stmt|;
comment|/* Make a declaration for this class in its own scope.  */
name|build_self_reference
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Finish the member declaration given by DECL.  */
end_comment

begin_function
name|void
name|finish_member_declaration
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|decl
operator|==
name|void_type_node
condition|)
comment|/* The COMPONENT was a friend, not a member, and so there's        nothing for us to do.  */
return|return;
comment|/* We should see only one DECL at a time.  */
name|gcc_assert
argument_list|(
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Set up access control for DECL.  */
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_private_node
operator|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_access_specifier
operator|==
name|access_protected_node
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
block|{
name|TREE_PRIVATE
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_PROTECTED
argument_list|(
name|DECL_TEMPLATE_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the DECL as a member of the current class.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_class_type
expr_stmt|;
comment|/* [dcl.link]       A C language linkage is ignored for the names of class members      and the member function type of class member functions.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_LANGUAGE
argument_list|(
name|decl
argument_list|)
operator|==
name|lang_c
condition|)
name|SET_DECL_LANGUAGE
argument_list|(
name|decl
argument_list|,
name|lang_cplusplus
argument_list|)
expr_stmt|;
comment|/* Put functions on the TYPE_METHODS list and everything else on the      TYPE_FIELDS list.  Note that these are built up in reverse order.      We reverse them (to obtain declaration order) in finish_struct.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* We also need to add this function to the 	 CLASSTYPE_METHOD_VEC.  */
if|if
condition|(
name|add_method
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_METHODS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enter the DECL into the scope of the class.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|USING_DECL
operator|&&
operator|!
name|DECL_DEPENDENT_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|pushdecl_class_level
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields 	 go at the beginning.  The reason is that lookup_field_1 	 searches the list in order, and we want a field name to 	 override a type name so that the "struct stat hack" will 	 work.  In particular:  	   struct S { enum E { }; int E } s; 	   s.E = 3;  	 is valid.  In addition, the FIELD_DECLs must be maintained in 	 declaration order so that class layout works as expected. 	 However, we don't need that order until class layout, so we 	 save a little time by putting FIELD_DECLs on in reverse order 	 here, and then reversing them in finish_struct_1.  (We could 	 also keep a pointer to the correct insertion points in the 	 list.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|chainon
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|current_class_type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
name|maybe_add_class_template_decl_list
argument_list|(
name|current_class_type
argument_list|,
name|decl
argument_list|,
comment|/*friend_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pch_file
condition|)
name|note_decl_for_pch
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DECL has been declared while we are building a PCH file.  Perform    actions that we might normally undertake lazily, but which can be    performed now so that they do not have to be performed in    translation units which include the PCH file.  */
end_comment

begin_function
name|void
name|note_decl_for_pch
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|pch_file
argument_list|)
expr_stmt|;
comment|/* There's a good chance that we'll have to mangle names at some      point, even if only for emission in debugging information.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|!
name|processing_template_decl
condition|)
name|mangle_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing a complete template declaration.  The PARMS are    the template parameters.  */
end_comment

begin_function
name|void
name|finish_template_decl
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
if|if
condition|(
name|parms
condition|)
name|end_template_decl
argument_list|()
expr_stmt|;
else|else
name|end_specialization
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing a template-id (which names a type) of the form    NAME< ARGS>.  Return the TYPE_DECL for the type named by the    template-id.  If ENTERING_SCOPE is nonzero we are about to enter    the scope of template-id indicated.  */
end_comment

begin_function
name|tree
name|finish_template_type
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|entering_scope
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|lookup_template_class
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|entering_scope
argument_list|,
name|tf_warning_or_error
operator||
name|tf_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|!=
name|error_mark_node
condition|)
name|decl
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Finish processing a BASE_CLASS with the indicated ACCESS_SPECIFIER.    Return a TREE_LIST containing the ACCESS_SPECIFIER and the    BASE_CLASS, or NULL_TREE if an error occurred.  The    ACCESS_SPECIFIER is one of    access_{default,public,protected_private}_node.  For a virtual base    we set TREE_TYPE.  */
end_comment

begin_function
name|tree
name|finish_base_specifier
parameter_list|(
name|tree
name|base
parameter_list|,
name|tree
name|access
parameter_list|,
name|bool
name|virtual_p
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"invalid base-class specification"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_aggr_type
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
condition|)
name|result
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cp_type_quals
argument_list|(
name|base
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"base class %qT has cv qualifiers"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|build_tree_list
argument_list|(
name|access
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtual_p
condition|)
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Issue a diagnostic that NAME cannot be found in SCOPE.  DECL is    what we found when we tried to do the lookup.  */
end_comment

begin_function
name|void
name|qualified_name_lookup_error
parameter_list|(
name|tree
name|scope
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|scope
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* We already complained.  */
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|error
argument_list|(
literal|"incomplete type %qT used in nested name specifier"
argument_list|,
name|scope
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|error
argument_list|(
literal|"reference to %<%T::%D%> is ambiguous"
argument_list|,
name|scope
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"%qD is not a member of %qT"
argument_list|,
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|!=
name|global_namespace
condition|)
name|error
argument_list|(
literal|"%qD is not a member of %qD"
argument_list|,
name|name
argument_list|,
name|scope
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%<::%D%> has not been declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If FNS is a member function, a set of member functions, or a    template-id referring to one or more member functions, return a    BASELINK for FNS, incorporating the current access context.    Otherwise, return FNS unchanged.  */
end_comment

begin_function
name|tree
name|baselink_for_fns
parameter_list|(
name|tree
name|fns
parameter_list|)
block|{
name|tree
name|fn
decl_stmt|;
name|tree
name|cl
decl_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
operator|||
name|error_operand_p
argument_list|(
name|fns
argument_list|)
condition|)
return|return
name|fns
return|;
name|fn
operator|=
name|fns
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|fn
operator|=
name|TREE_OPERAND
argument_list|(
name|fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fn
operator|=
name|get_first_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|fn
argument_list|)
condition|)
return|return
name|fns
return|;
name|cl
operator|=
name|currently_open_derived_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cl
condition|)
name|cl
operator|=
name|DECL_CONTEXT
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|cl
operator|=
name|TYPE_BINFO
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
name|build_baselink
argument_list|(
name|cl
argument_list|,
name|cl
argument_list|,
name|fns
argument_list|,
comment|/*optype=*/
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ID_EXPRESSION is a representation of parsed, but unprocessed,    id-expression.  (See cp_parser_id_expression for details.)  SCOPE,    if non-NULL, is the type or namespace used to explicitly qualify    ID_EXPRESSION.  DECL is the entity to which that name has been    resolved.     *CONSTANT_EXPRESSION_P is true if we are presently parsing a    constant-expression.  In that case, *NON_CONSTANT_EXPRESSION_P will    be set to true if this expression isn't permitted in a    constant-expression, but it is otherwise not set by this function.    *ALLOW_NON_CONSTANT_EXPRESSION_P is true if we are parsing a    constant-expression, but a non-constant expression is also    permissible.     DONE is true if this expression is a complete postfix-expression;    it is false if this expression is followed by '->', '[', '(', etc.    ADDRESS_P is true iff this expression is the operand of '&'.    TEMPLATE_P is true iff the qualified-id was of the form    "A::template B".  TEMPLATE_ARG_P is true iff this qualified name    appears as a template argument.     If an error occurs, and it is the kind of error that might cause    the parser to abort a tentative parse, *ERROR_MSG is filled in.  It    is the caller's responsibility to issue the message.  *ERROR_MSG    will be a string with static storage duration, so the caller need    not "free" it.     Return an expression for the entity, after issuing appropriate    diagnostics.  This function is also responsible for transforming a    reference to a non-static member into a COMPONENT_REF that makes    the use of "this" explicit.     Upon return, *IDK will be filled in appropriately.  */
end_comment

begin_function
name|tree
name|finish_id_expression
parameter_list|(
name|tree
name|id_expression
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|scope
parameter_list|,
name|cp_id_kind
modifier|*
name|idk
parameter_list|,
name|bool
name|integral_constant_expression_p
parameter_list|,
name|bool
name|allow_non_integral_constant_expression_p
parameter_list|,
name|bool
modifier|*
name|non_integral_constant_expression_p
parameter_list|,
name|bool
name|template_p
parameter_list|,
name|bool
name|done
parameter_list|,
name|bool
name|address_p
parameter_list|,
name|bool
name|template_arg_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error_msg
parameter_list|)
block|{
comment|/* Initialize the output parameters.  */
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
operator|*
name|error_msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|id_expression
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* If we have a template-id, then no further lookup is      required.  If the template-id was for a template-class, we      will sometimes have a TYPE_DECL at this point.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
empty_stmt|;
comment|/* Look up the name.  */
else|else
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Name lookup failed.  */
if|if
condition|(
name|scope
operator|&&
operator|(
operator|!
name|TYPE_P
argument_list|(
name|scope
argument_list|)
operator|||
operator|(
operator|!
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|IDENTIFIER_TYPENAME_P
argument_list|(
name|id_expression
argument_list|)
operator|&&
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|id_expression
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* If the qualifying type is non-dependent (and the name 		 does not name a conversion operator to a dependent 		 type), issue an error.  */
name|qualified_name_lookup_error
argument_list|(
name|scope
argument_list|,
name|id_expression
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scope
condition|)
block|{
comment|/* It may be resolved via Koenig lookup.  */
operator|*
name|idk
operator|=
name|CP_ID_KIND_UNQUALIFIED
expr_stmt|;
return|return
name|id_expression
return|;
block|}
else|else
name|decl
operator|=
name|id_expression
expr_stmt|;
block|}
comment|/* If DECL is a variable that would be out of scope under 	 ANSI/ISO rules, but in scope in the ARM, name lookup 	 will succeed.  Issue a diagnostic here.  */
else|else
name|decl
operator|=
name|check_for_out_of_scope_variable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Remember that the name was used in the definition of 	 the current class so that we can check later to see if 	 the meaning would have been different after the class 	 was entirely defined.  */
if|if
condition|(
operator|!
name|scope
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
name|maybe_note_name_used_in_class
argument_list|(
name|id_expression
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Disallow uses of local variables from containing functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
operator|&&
name|context
operator|!=
name|current_function_decl
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|?
literal|"use of %<auto%> variable from containing function"
else|:
literal|"use of parameter from containing function"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"  %q+#D declared here"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
block|}
block|}
comment|/* If we didn't find anything, or what we found was a type,      then this wasn't really an id-expression.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
operator|!
name|DECL_FUNCTION_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
operator|*
name|error_msg
operator|=
literal|"missing template arguments"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
operator|*
name|error_msg
operator|=
literal|"expected primary-expression"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the name resolved to a template parameter, there is no      need to look it up again later.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
operator|&&
name|DECL_TEMPLATE_PARM_P
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
block|{
name|tree
name|r
decl_stmt|;
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_PARM_INDEX
condition|)
name|decl
operator|=
name|TEMPLATE_PARM_DECL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|r
operator|=
name|convert_from_reference
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|integral_constant_expression_p
operator|&&
operator|!
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|INTEGRAL_OR_ENUMERATION_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|allow_non_integral_constant_expression_p
condition|)
name|error
argument_list|(
literal|"template parameter %qD of type %qT is not allowed in "
literal|"an integral constant expression because it is not of "
literal|"integral or enumeration type"
argument_list|,
name|decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/* Similarly, we resolve enumeration constants to their      underlying values.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
operator|*
name|idk
operator|=
name|CP_ID_KIND_NONE
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|used_types_insert
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
return|;
block|}
return|return
name|decl
return|;
block|}
else|else
block|{
name|bool
name|dependent_p
decl_stmt|;
comment|/* If the declaration was explicitly qualified indicate 	 that.  The semantics of `A::f(3)' are different than 	 `f(3)' if `f' is virtual.  */
operator|*
name|idk
operator|=
operator|(
name|scope
condition|?
name|CP_ID_KIND_QUALIFIED
else|:
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|?
name|CP_ID_KIND_TEMPLATE_ID
else|:
name|CP_ID_KIND_UNQUALIFIED
operator|)
operator|)
expr_stmt|;
comment|/* [temp.dep.expr]  	 An id-expression is type-dependent if it contains an 	 identifier that was declared with a dependent type.  	 The standard is not very specific about an id-expression that 	 names a set of overloaded functions.  What if some of them 	 have dependent types and some of them do not?  Presumably, 	 such a name should be treated as a dependent name.  */
comment|/* Assume the name is not dependent.  */
name|dependent_p
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
comment|/* No names are dependent outside a template.  */
empty_stmt|;
comment|/* A template-id where the name of the template was not resolved 	 is definitely dependent.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|)
condition|)
name|dependent_p
operator|=
name|true
expr_stmt|;
comment|/* For anything except an overloaded function, just check its 	 type.  */
elseif|else
if|if
condition|(
operator|!
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
name|dependent_p
operator|=
name|dependent_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a set of overloaded functions, check each of the 	 functions.  */
else|else
block|{
name|tree
name|fns
init|=
name|decl
decl_stmt|;
if|if
condition|(
name|BASELINK_P
argument_list|(
name|fns
argument_list|)
condition|)
name|fns
operator|=
name|BASELINK_FUNCTIONS
argument_list|(
name|fns
argument_list|)
expr_stmt|;
comment|/* For a template-id, check to see if the template 	     arguments are dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fns
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
block|{
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|dependent_p
operator|=
name|any_dependent_template_arguments_p
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* The functions are those referred to by the 		 template-id.  */
name|fns
operator|=
name|TREE_OPERAND
argument_list|(
name|fns
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no dependent template arguments, go through 	     the overloaded functions.  */
while|while
condition|(
name|fns
operator|&&
operator|!
name|dependent_p
condition|)
block|{
name|tree
name|fn
init|=
name|OVL_CURRENT
argument_list|(
name|fns
argument_list|)
decl_stmt|;
comment|/* Member functions of dependent classes are 		 dependent.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|type_dependent_expression_p
argument_list|(
name|fn
argument_list|)
condition|)
name|dependent_p
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fn
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|dependent_template_p
argument_list|(
name|fn
argument_list|)
condition|)
name|dependent_p
operator|=
name|true
expr_stmt|;
name|fns
operator|=
name|OVL_NEXT
argument_list|(
name|fns
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the name was dependent on a template parameter, we will 	 resolve the name at instantiation time.  */
if|if
condition|(
name|dependent_p
condition|)
block|{
comment|/* Create a SCOPE_REF for qualified names, if the scope is 	     dependent.  */
if|if
condition|(
name|scope
condition|)
block|{
comment|/* Since this name was dependent, the expression isn't 		 constant -- yet.  No error is issued because it might 		 be constant when things are instantiated.  */
if|if
condition|(
name|integral_constant_expression_p
condition|)
operator|*
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
block|{
if|if
condition|(
name|address_p
operator|&&
name|done
condition|)
name|decl
operator|=
name|finish_qualified_id_expr
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
name|done
argument_list|,
name|address_p
argument_list|,
name|template_p
argument_list|,
name|template_arg_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dependent_type_p
argument_list|(
name|scope
argument_list|)
condition|)
name|decl
operator|=
name|build_qualified_name
argument_list|(
comment|/*type=*/
name|NULL_TREE
argument_list|,
name|scope
argument_list|,
name|id_expression
argument_list|,
name|template_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|build_qualified_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|scope
argument_list|,
name|id_expression
argument_list|,
name|template_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* A TEMPLATE_ID already contains all the information we 	     need.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id_expression
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
return|return
name|id_expression
return|;
operator|*
name|idk
operator|=
name|CP_ID_KIND_UNQUALIFIED_DEPENDENT
expr_stmt|;
comment|/* If we found a variable, then name lookup during the 	     instantiation will always resolve to the same VAR_DECL 	     (or an instantiation thereof).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
return|return
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
return|;
comment|/* The same is true for FIELD_DECL, but we also need to 	     make sure that the syntax is correct.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Since SCOPE is NULL here, this is an unqualified name. 		 Access checking has been performed during name lookup 		 already.  Turn off checking to avoid duplicate errors.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|decl
operator|=
name|finish_non_static_data_member
argument_list|(
name|decl
argument_list|,
name|current_class_ref
argument_list|,
comment|/*qualifying_scope=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
return|return
name|id_expression
return|;
block|}
comment|/* Only certain kinds of names are allowed in constant 	 expression.  Enumerators and template parameters have already 	 been handled above.  */
if|if
condition|(
name|integral_constant_expression_p
operator|&&
operator|!
name|DECL_INTEGRAL_CONSTANT_VAR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|builtin_valid_in_constant_expr_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|allow_non_integral_constant_expression_p
condition|)
block|{
name|error
argument_list|(
literal|"%qD cannot appear in a constant-expression"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
operator|*
name|non_integral_constant_expression_p
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
name|error
argument_list|(
literal|"use of namespace %qD as expression"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_CLASS_TEMPLATE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use of class template %qT as expression"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* Ambiguous reference to base members.  */
name|error
argument_list|(
literal|"request for member %qD is ambiguous in "
literal|"multiple inheritance lattice"
argument_list|,
name|id_expression
argument_list|)
expr_stmt|;
name|print_candidates
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* Mark variable-like entities as used.  Functions are similarly 	 marked either below or after overload resolution.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
condition|)
block|{
name|decl
operator|=
operator|(
name|adjust_result_of_qualified_name_lookup
argument_list|(
name|decl
argument_list|,
name|scope
argument_list|,
name|current_class_type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|mark_used
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|||
name|BASELINK_P
argument_list|(
name|decl
argument_list|)
condition|)
name|decl
operator|=
name|finish_qualified_id_expr
argument_list|(
name|scope
argument_list|,
name|decl
argument_list|,
name|done
argument_list|,
name|address_p
argument_list|,
name|template_p
argument_list|,
name|template_arg_p
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|r
init|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|r
operator|=
name|build_qualified_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
argument_list|,
name|scope
argument_list|,
name|decl
argument_list|,
name|template_p
argument_list|)
expr_stmt|;
name|decl
operator|=
name|r
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Since SCOPE is NULL here, this is an unqualified name. 	     Access checking has been performed during name lookup 	     already.  Turn off checking to avoid duplicate errors.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|decl
operator|=
name|finish_non_static_data_member
argument_list|(
name|decl
argument_list|,
name|current_class_ref
argument_list|,
comment|/*qualifying_scope=*/
name|NULL_TREE
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|first_fn
decl_stmt|;
name|first_fn
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|first_fn
argument_list|)
operator|==
name|TEMPLATE_ID_EXPR
condition|)
name|first_fn
operator|=
name|TREE_OPERAND
argument_list|(
name|first_fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first_fn
operator|=
name|get_first_fn
argument_list|(
name|first_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|first_fn
argument_list|)
operator|==
name|TEMPLATE_DECL
condition|)
name|first_fn
operator|=
name|DECL_TEMPLATE_RESULT
argument_list|(
name|first_fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_overloaded_fn
argument_list|(
name|decl
argument_list|)
condition|)
name|mark_used
argument_list|(
name|first_fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|template_arg_p
operator|&&
name|TREE_CODE
argument_list|(
name|first_fn
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_MEMBER_P
argument_list|(
name|first_fn
argument_list|)
operator|&&
operator|!
name|shared_member_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* A set of member functions.  */
name|decl
operator|=
name|maybe_dummy_object
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|first_fn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|finish_class_member_access_expr
argument_list|(
name|decl
argument_list|,
name|id_expression
argument_list|,
comment|/*template_p=*/
name|false
argument_list|)
return|;
block|}
name|decl
operator|=
name|baselink_for_fns
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NONLOCAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CLASS_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_class_type
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|path
operator|=
name|currently_open_derived_class
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|perform_or_defer_access_check
argument_list|(
name|TYPE_BINFO
argument_list|(
name|path
argument_list|)
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|convert_from_reference
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_deprecated_use
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Implement the __typeof keyword: Return the type of EXPR, suitable for    use as a type-specifier.  */
end_comment

begin_function
name|tree
name|finish_typeof
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|type
operator|=
name|make_aggr_type
argument_list|(
name|TYPEOF_TYPE
argument_list|)
expr_stmt|;
name|TYPEOF_TYPE_EXPR
argument_list|(
name|type
argument_list|)
operator|=
name|expr
expr_stmt|;
return|return
name|type
return|;
block|}
name|type
operator|=
name|unlowered_expr_type
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
name|type
operator|==
name|unknown_type_node
condition|)
block|{
name|error
argument_list|(
literal|"type of %qE is unknown"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Perform C++-specific checks for __builtin_offsetof before calling    fold_offsetof.  */
end_comment

begin_function
name|tree
name|finish_offsetof
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PSEUDO_DTOR_EXPR
condition|)
block|{
name|error
argument_list|(
literal|"cannot apply %<offsetof%> to destructor %<~%T%>"
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|UNKNOWN_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"cannot apply %<offsetof%> to member function %qD"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|fold_offsetof
argument_list|(
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called from expand_body via walk_tree.  Replace all AGGR_INIT_EXPRs    with equivalent CALL_EXPRs.  */
end_comment

begin_function
specifier|static
name|tree
name|simplify_aggr_init_exprs_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We don't need to walk into types; there's nothing in a type that      needs simplification.  (And, furthermore, there are places we      actively don't want to go.  For example, we don't want to wander      into the default arguments for a FUNCTION_DECL that appears in a      CALL_EXPR.)  */
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
block|{
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Only AGGR_INIT_EXPRs are interesting.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|!=
name|AGGR_INIT_EXPR
condition|)
return|return
name|NULL_TREE
return|;
name|simplify_aggr_init_expr
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Replace the AGGR_INIT_EXPR at *TP with an equivalent CALL_EXPR.  This    function is broken out from the above for the benefit of the tree-ssa    project.  */
end_comment

begin_function
name|void
name|simplify_aggr_init_expr
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|)
block|{
name|tree
name|aggr_init_expr
init|=
operator|*
name|tp
decl_stmt|;
comment|/* Form an appropriate CALL_EXPR.  */
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|slot
init|=
name|TREE_OPERAND
argument_list|(
name|aggr_init_expr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|slot
argument_list|)
decl_stmt|;
name|tree
name|call_expr
decl_stmt|;
enum|enum
name|style_t
block|{
name|ctor
block|,
name|arg
block|,
name|pcc
block|}
name|style
enum|;
if|if
condition|(
name|AGGR_INIT_VIA_CTOR_P
argument_list|(
name|aggr_init_expr
argument_list|)
condition|)
name|style
operator|=
name|ctor
expr_stmt|;
ifdef|#
directive|ifdef
name|PCC_STATIC_STRUCT_RETURN
elseif|else
if|if
condition|(
literal|1
condition|)
name|style
operator|=
name|pcc
expr_stmt|;
endif|#
directive|endif
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|style
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|==
name|ctor
condition|)
block|{
comment|/* Replace the first argument to the ctor with the address of the 	 slot.  */
name|tree
name|addr
decl_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|cxx_mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|addr
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|addr
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|call_expr
operator|=
name|build3
argument_list|(
name|CALL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|fn
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|arg
condition|)
block|{
comment|/* Just mark it addressable here, and leave the rest to 	 expand_call{,_inline}.  */
name|cxx_mark_addressable
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
name|call_expr
argument_list|)
operator|=
name|true
expr_stmt|;
name|call_expr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|call_expr
argument_list|)
argument_list|,
name|slot
argument_list|,
name|call_expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|style
operator|==
name|pcc
condition|)
block|{
comment|/* If we're using the non-reentrant PCC calling convention, then we 	 need to copy the returned value out of the static buffer into the 	 SLOT.  */
name|push_deferring_access_checks
argument_list|(
name|dk_no_check
argument_list|)
expr_stmt|;
name|call_expr
operator|=
name|build_aggr_init
argument_list|(
name|slot
argument_list|,
name|call_expr
argument_list|,
name|DIRECT_BIND
operator||
name|LOOKUP_ONLYCONVERTING
argument_list|)
expr_stmt|;
name|pop_deferring_access_checks
argument_list|()
expr_stmt|;
name|call_expr
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|slot
argument_list|)
argument_list|,
name|call_expr
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
operator|*
name|tp
operator|=
name|call_expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit all thunks to FN that should be emitted when FN is emitted.  */
end_comment

begin_function
specifier|static
name|void
name|emit_associated_thunks
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
comment|/* When we use vcall offsets, we emit thunks with the virtual      functions to which they thunk. The whole point of vcall offsets      is so that you can know statically the entire set of thunks that      will ever be needed for a given virtual function, thereby      enabling you to output all the thunks with the function itself.  */
if|if
condition|(
name|DECL_VIRTUAL_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|tree
name|thunk
decl_stmt|;
for|for
control|(
name|thunk
operator|=
name|DECL_THUNKS
argument_list|(
name|fn
argument_list|)
init|;
name|thunk
condition|;
name|thunk
operator|=
name|TREE_CHAIN
argument_list|(
name|thunk
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|THUNK_ALIAS
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|use_thunk
argument_list|(
name|thunk
argument_list|,
comment|/*emit_p=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_RESULT_THUNK_P
argument_list|(
name|thunk
argument_list|)
condition|)
block|{
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
init|;
name|probe
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
name|use_thunk
argument_list|(
name|probe
argument_list|,
comment|/*emit_p=*/
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|gcc_assert
argument_list|(
operator|!
name|DECL_THUNKS
argument_list|(
name|thunk
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate RTL for FN.  */
end_comment

begin_function
name|void
name|expand_body
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
name|tree
name|saved_function
decl_stmt|;
comment|/* Compute the appropriate object-file linkage for inline      functions.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|import_export_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If FN is external, then there's no point in generating RTL for      it.  This situation can arise with an inline function under      `-fexternal-templates'; we instantiate the function, even though      we're not planning on emitting it, in case we get a chance to      inline it.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
condition|)
return|return;
comment|/* ??? When is this needed?  */
name|saved_function
operator|=
name|current_function_decl
expr_stmt|;
comment|/* Emit any thunks that should be emitted at the same time as FN.  */
name|emit_associated_thunks
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* This function is only called from cgraph, or recursively from      emit_associated_thunks.  In neither case should we be currently      generating trees for a function.  */
name|gcc_assert
argument_list|(
name|function_depth
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tree_rest_of_compilation
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|saved_function
expr_stmt|;
if|if
condition|(
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* If this is a clone, go through the other clones now and mark 	 their parameters used.  We have to do that here, as we don't 	 know whether any particular clone will be expanded, and 	 therefore cannot pick one arbitrarily.  */
name|tree
name|probe
decl_stmt|;
for|for
control|(
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|DECL_CLONED_FUNCTION
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|probe
operator|&&
name|DECL_CLONED_FUNCTION_P
argument_list|(
name|probe
argument_list|)
condition|;
name|probe
operator|=
name|TREE_CHAIN
argument_list|(
name|probe
argument_list|)
control|)
block|{
name|tree
name|parms
decl_stmt|;
for|for
control|(
name|parms
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|probe
argument_list|)
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
name|TREE_USED
argument_list|(
name|parms
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate RTL for FN.  */
end_comment

begin_function
name|void
name|expand_or_defer_fn
parameter_list|(
name|tree
name|fn
parameter_list|)
block|{
comment|/* When the parser calls us after finishing the body of a template      function, we don't really want to expand the body.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
comment|/* Normally, collection only occurs in rest_of_compilation.  So, 	 if we don't collect here, we never collect junk generated 	 during the processing of templates until we hit a 	 non-template function.  It's not safe to do this inside a 	 nested class, though, as the parser may have local state that 	 is not a GC root.  */
if|if
condition|(
operator|!
name|function_depth
condition|)
name|ggc_collect
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fn
argument_list|)
argument_list|,
name|simplify_aggr_init_exprs_r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is a constructor or destructor body, we have to clone      it.  */
if|if
condition|(
name|maybe_clone_body
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* We don't want to process FN again, so pretend we've written 	 it out, even though we haven't.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If this function is marked with the constructor attribute, add it      to the list of functions to be called along with constructors      from static duration objects.  */
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fn
argument_list|)
condition|)
name|static_ctors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
comment|/* If this function is marked with the destructor attribute, add it      to the list of functions to be called along with destructors from      static duration objects.  */
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fn
argument_list|)
condition|)
name|static_dtors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fn
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
comment|/* We make a decision about linkage for these functions at the end      of the compilation.  Until that point, we do not want the back      end to output them -- but we do want it to see the bodies of      these functions so that it can inline them as appropriate.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
operator|||
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INTERFACE_KNOWN
argument_list|(
name|fn
argument_list|)
condition|)
comment|/* We've already made a decision as to how this function will 	   be handled.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|at_eof
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_NOT_REALLY_EXTERN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|note_vague_linkage_fn
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* A non-template inline function with external linkage will 	     always be COMDAT.  As we must eventually determine the 	     linkage of all functions, and as that causes writes to 	     the data mapped in from the PCH file, it's advantageous 	     to mark the functions at this point.  */
if|if
condition|(
operator|!
name|DECL_IMPLICIT_INSTANTIATION
argument_list|(
name|fn
argument_list|)
condition|)
block|{
comment|/* This function must have external linkage, as 		 otherwise DECL_INTERFACE_KNOWN would have been 		 set.  */
name|gcc_assert
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|comdat_linkage
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|DECL_INTERFACE_KNOWN
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|import_export_decl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* If the user wants us to keep all inline functions, then mark 	 this function as needed so that finish_file will make sure to 	 output it later.  */
if|if
condition|(
name|flag_keep_inline_functions
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|mark_needed
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* There's no reason to do any of the work here if we're only doing      semantic analysis; this code just generates RTL.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
name|function_depth
operator|++
expr_stmt|;
comment|/* Expand or defer, at the whim of the compilation unit manager.  */
name|cgraph_finalize_function
argument_list|(
name|fn
argument_list|,
name|function_depth
operator|>
literal|1
argument_list|)
expr_stmt|;
name|function_depth
operator|--
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|nrv_data
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|htab_t
name|visited
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper function for walk_tree, used by finalize_nrv below.  */
end_comment

begin_function
specifier|static
name|tree
name|finalize_nrv_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|nrv_data
modifier|*
name|dp
init|=
operator|(
expr|struct
name|nrv_data
operator|*
operator|)
name|data
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* No need to walk into types.  There wouldn't be any need to walk into      non-statements, except that we have to consider STMT_EXPRs.  */
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
comment|/* Change all returns to just refer to the RESULT_DECL; this is a nop,      but differs from using NULL_TREE in that it indicates that we care      about the value of the RESULT_DECL.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
literal|0
argument_list|)
operator|=
name|dp
operator|->
name|result
expr_stmt|;
comment|/* Change all cleanups for the NRV to only run when an exception is      thrown.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|CLEANUP_STMT
operator|&&
name|CLEANUP_DECL
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|dp
operator|->
name|var
condition|)
name|CLEANUP_EH_ONLY
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Replace the DECL_EXPR for the NRV with an initialization of the      RESULT_DECL, if needed.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|DECL_EXPR
operator|&&
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|dp
operator|->
name|var
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|dp
operator|->
name|var
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|dp
operator|->
name|var
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|init
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dp
operator|->
name|result
argument_list|,
name|DECL_INITIAL
argument_list|(
name|dp
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|dp
operator|->
name|var
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
name|init
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
name|SET_EXPR_LOCUS
argument_list|(
name|init
argument_list|,
name|EXPR_LOCUS
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|init
expr_stmt|;
block|}
comment|/* And replace all uses of the NRV with the RESULT_DECL.  */
elseif|else
if|if
condition|(
operator|*
name|tp
operator|==
name|dp
operator|->
name|var
condition|)
operator|*
name|tp
operator|=
name|dp
operator|->
name|result
expr_stmt|;
comment|/* Avoid walking into the same tree more than once.  Unfortunately, we      can't just use walk_tree_without duplicates because it would only call      us for the first occurrence of dp->var in the function body.  */
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|dp
operator|->
name|visited
argument_list|,
operator|*
name|tp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|slot
operator|=
operator|*
name|tp
expr_stmt|;
comment|/* Keep iterating.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Called from finish_function to implement the named return value    optimization by overriding all the RETURN_EXPRs and pertinent    CLEANUP_STMTs and replacing all occurrences of VAR with RESULT, the    RESULT_DECL for the function.  */
end_comment

begin_function
name|void
name|finalize_nrv
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|tree
name|var
parameter_list|,
name|tree
name|result
parameter_list|)
block|{
name|struct
name|nrv_data
name|data
decl_stmt|;
comment|/* Copy debugging information from VAR to RESULT.  */
name|DECL_NAME
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_ARTIFICIAL
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_IGNORED_P
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|result
argument_list|)
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Don't forget that we take its address.  */
name|TREE_ADDRESSABLE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_ADDRESSABLE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|data
operator|.
name|var
operator|=
name|var
expr_stmt|;
name|data
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|data
operator|.
name|visited
operator|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|finalize_nrv_r
argument_list|,
operator|&
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|data
operator|.
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For all elements of CLAUSES, validate them vs OpenMP constraints.    Remove any elements from the list that are invalid.  */
end_comment

begin_function
name|tree
name|finish_omp_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|)
block|{
name|bitmap_head
name|generic_head
decl_stmt|,
name|firstprivate_head
decl_stmt|,
name|lastprivate_head
decl_stmt|;
name|tree
name|c
decl_stmt|,
name|t
decl_stmt|,
modifier|*
name|pc
init|=
operator|&
name|clauses
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bitmap_obstack_initialize
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|generic_head
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
name|bitmap_initialize
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
operator|&
name|bitmap_default_obstack
argument_list|)
expr_stmt|;
for|for
control|(
name|pc
operator|=
operator|&
name|clauses
operator|,
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
operator|*
name|pc
control|)
block|{
name|bool
name|remove
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_SHARED
case|:
name|name
operator|=
literal|"shared"
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_PRIVATE
case|:
name|name
operator|=
literal|"private"
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|name
operator|=
literal|"reduction"
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
name|name
operator|=
literal|"copyprivate"
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
case|case
name|OMP_CLAUSE_COPYIN
case|:
name|name
operator|=
literal|"copyin"
expr_stmt|;
goto|goto
name|check_dup_generic
goto|;
name|check_dup_generic
label|:
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
break|break;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD is not a variable in clause %qs"
argument_list|,
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%qE is not a variable in clause %qs"
argument_list|,
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qD appears more than once in data clauses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
else|else
name|bitmap_set_bit
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
break|break;
name|error
argument_list|(
literal|"%qE is not a variable in clause %<firstprivate%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE appears more than once in data clauses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
else|else
name|bitmap_set_bit
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|processing_template_decl
condition|)
break|break;
name|error
argument_list|(
literal|"%qE is not a variable in clause %<lastprivate%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmap_bit_p
argument_list|(
operator|&
name|generic_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE appears more than once in data clauses"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
else|else
name|bitmap_set_bit
argument_list|(
operator|&
name|lastprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_IF
case|:
name|t
operator|=
name|OMP_CLAUSE_IF_EXPR
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|t
operator|=
name|maybe_convert_cond
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
name|remove
operator|=
name|true
expr_stmt|;
name|OMP_CLAUSE_IF_EXPR
argument_list|(
name|c
argument_list|)
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
name|t
operator|=
name|OMP_CLAUSE_NUM_THREADS_EXPR
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
name|remove
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|type_dependent_expression_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"num_threads expression must be integral"
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
name|t
operator|=
name|OMP_CLAUSE_SCHEDULE_CHUNK_EXPR
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
name|remove
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|type_dependent_expression_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"schedule chunk size expression must be integral"
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
operator|*
name|pc
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|pc
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pc
operator|=
operator|&
name|clauses
operator|,
name|c
operator|=
name|clauses
init|;
name|c
condition|;
name|c
operator|=
operator|*
name|pc
control|)
block|{
name|enum
name|tree_code
name|c_kind
init|=
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|bool
name|remove
init|=
name|false
decl_stmt|;
name|bool
name|need_complete_non_reference
init|=
name|false
decl_stmt|;
name|bool
name|need_default_ctor
init|=
name|false
decl_stmt|;
name|bool
name|need_copy_ctor
init|=
name|false
decl_stmt|;
name|bool
name|need_copy_assignment
init|=
name|false
decl_stmt|;
name|bool
name|need_implicitly_determined
init|=
name|false
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|inner_type
decl_stmt|;
switch|switch
condition|(
name|c_kind
condition|)
block|{
case|case
name|OMP_CLAUSE_SHARED
case|:
name|name
operator|=
literal|"shared"
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_PRIVATE
case|:
name|name
operator|=
literal|"private"
expr_stmt|;
name|need_complete_non_reference
operator|=
name|true
expr_stmt|;
name|need_default_ctor
operator|=
name|true
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
name|name
operator|=
literal|"firstprivate"
expr_stmt|;
name|need_complete_non_reference
operator|=
name|true
expr_stmt|;
name|need_copy_ctor
operator|=
name|true
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
name|name
operator|=
literal|"lastprivate"
expr_stmt|;
name|need_complete_non_reference
operator|=
name|true
expr_stmt|;
name|need_copy_assignment
operator|=
name|true
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|name
operator|=
literal|"reduction"
expr_stmt|;
name|need_implicitly_determined
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
name|name
operator|=
literal|"copyprivate"
expr_stmt|;
name|need_copy_assignment
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_COPYIN
case|:
name|name
operator|=
literal|"copyin"
expr_stmt|;
name|need_copy_assignment
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|pc
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|t
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|processing_template_decl
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|pc
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c_kind
condition|)
block|{
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
operator|&
name|firstprivate_head
argument_list|,
name|DECL_UID
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|need_default_ctor
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE has invalid type for %<reduction%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|tree_code
name|r_code
init|=
name|OMP_CLAUSE_REDUCTION_CODE
argument_list|(
name|c
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|r_code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"%qE has invalid type for %<reduction(%s)%>"
argument_list|,
name|t
argument_list|,
name|operator_name_info
index|[
name|r_code
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OMP_CLAUSE_COPYIN
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE must be %<threadprivate%> for %<copyin%>"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|need_complete_non_reference
condition|)
block|{
name|t
operator|=
name|require_complete_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
name|remove
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%qE has reference type for %qs"
argument_list|,
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_implicitly_determined
condition|)
block|{
specifier|const
name|char
modifier|*
name|share_name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|t
argument_list|)
condition|)
name|share_name
operator|=
literal|"threadprivate"
expr_stmt|;
else|else
switch|switch
condition|(
name|cxx_omp_predetermined_sharing
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
case|:
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_SHARED
case|:
name|share_name
operator|=
literal|"shared"
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_PRIVATE
case|:
name|share_name
operator|=
literal|"private"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|share_name
condition|)
block|{
name|error
argument_list|(
literal|"%qE is predetermined %qs for %qs"
argument_list|,
name|t
argument_list|,
name|share_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* We're interested in the base element, not arrays.  */
name|inner_type
operator|=
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|inner_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|inner_type
argument_list|)
expr_stmt|;
comment|/* Check for special function availability by building a call to one. 	 Save the results, because later we won't be in the right context 	 for making these queries.  */
if|if
condition|(
name|CLASS_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|&&
operator|(
name|need_default_ctor
operator|||
name|need_copy_ctor
operator|||
name|need_copy_assignment
operator|)
operator|&&
operator|!
name|type_dependent_expression_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|int
name|save_errorcount
init|=
name|errorcount
decl_stmt|;
name|tree
name|info
decl_stmt|;
comment|/* Always allocate 3 elements for simplicity.  These are the 	     function decls for the ctor, dtor, and assignment op. 	     This layout is known to the three lang hooks, 	     cxx_omp_clause_default_init, cxx_omp_clause_copy_init, 	     and cxx_omp_clause_assign_op.  */
name|info
operator|=
name|make_tree_vec
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|CP_OMP_CLAUSE_INFO
argument_list|(
name|c
argument_list|)
operator|=
name|info
expr_stmt|;
if|if
condition|(
name|need_default_ctor
operator|||
operator|(
name|need_copy_ctor
operator|&&
operator|!
name|TYPE_HAS_TRIVIAL_INIT_REF
argument_list|(
name|inner_type
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|need_default_ctor
condition|)
name|t
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|t
operator|=
name|build_int_cst
argument_list|(
name|build_pointer_type
argument_list|(
name|inner_type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|inner_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_tree_list
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build_special_member_call
argument_list|(
name|NULL_TREE
argument_list|,
name|complete_ctor_identifier
argument_list|,
name|t
argument_list|,
name|inner_type
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|info
argument_list|,
literal|0
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|need_default_ctor
operator|||
name|need_copy_ctor
operator|)
operator|&&
name|TYPE_HAS_NONTRIVIAL_DESTRUCTOR
argument_list|(
name|inner_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build_int_cst
argument_list|(
name|build_pointer_type
argument_list|(
name|inner_type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|inner_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_special_member_call
argument_list|(
name|t
argument_list|,
name|complete_dtor_identifier
argument_list|,
name|NULL
argument_list|,
name|inner_type
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|need_copy_assignment
operator|&&
operator|!
name|TYPE_HAS_TRIVIAL_ASSIGN_REF
argument_list|(
name|inner_type
argument_list|)
condition|)
block|{
name|t
operator|=
name|build_int_cst
argument_list|(
name|build_pointer_type
argument_list|(
name|inner_type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|inner_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_special_member_call
argument_list|(
name|t
argument_list|,
name|ansi_assopname
argument_list|(
name|NOP_EXPR
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|)
argument_list|,
name|inner_type
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
comment|/* We'll have called convert_from_reference on the call, which 		 may well have added an indirect_ref.  It's unneeded here, 		 and in the way, so kill it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|info
argument_list|,
literal|2
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|errorcount
operator|!=
name|save_errorcount
condition|)
name|remove
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
operator|*
name|pc
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|pc
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|bitmap_obstack_release
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|clauses
return|;
block|}
end_function

begin_comment
comment|/* For all variables in the tree_list VARS, mark them as thread local.  */
end_comment

begin_function
name|void
name|finish_omp_threadprivate
parameter_list|(
name|tree
name|vars
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Mark every variable in VARS to be assigned thread local storage.  */
for|for
control|(
name|t
operator|=
name|vars
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|v
init|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* If V had already been marked threadprivate, it doesn't matter 	 whether it had been used prior to this point.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|v
argument_list|)
operator|&&
operator|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|v
argument_list|)
operator|==
name|NULL
operator|||
operator|!
name|CP_DECL_THREADPRIVATE_P
argument_list|(
name|v
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"%qE declared %<threadprivate%> after first use"
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|v
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
literal|"automatic variable %qE cannot be %<threadprivate%>"
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%<threadprivate%> %qE has incomplete type"
argument_list|,
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|v
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|CP_DECL_CONTEXT
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%<threadprivate%> %qE is not file, namespace "
literal|"or block scope variable"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Allocate a LANG_SPECIFIC structure for V, if needed.  */
if|if
condition|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|v
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|retrofit_lang_decl
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* Make sure that DECL_DISCRIMINATOR_P continues to be true 		 after the allocation of the lang_decl structure.  */
if|if
condition|(
name|DECL_DISCRIMINATOR_P
argument_list|(
name|v
argument_list|)
condition|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|v
argument_list|)
operator|->
name|decl_flags
operator|.
name|u2sel
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|DECL_TLS_MODEL
argument_list|(
name|v
argument_list|)
operator|=
name|decl_default_tls_model
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* If rtl has been already set for this var, call 		 make_decl_rtl once again, so that encode_section_info 		 has a chance to look at the new decl flags.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|v
argument_list|)
condition|)
name|make_decl_rtl
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|CP_DECL_THREADPRIVATE_P
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Build an OpenMP structured block.  */
end_comment

begin_function
name|tree
name|begin_omp_structured_block
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|do_pushlevel
argument_list|(
name|sk_omp
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|finish_omp_structured_block
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
return|return
name|do_poplevel
argument_list|(
name|block
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similarly, except force the retention of the BLOCK.  */
end_comment

begin_function
name|tree
name|begin_omp_parallel
parameter_list|(
name|void
parameter_list|)
block|{
name|keep_next_level
argument_list|(
name|true
argument_list|)
expr_stmt|;
return|return
name|begin_omp_structured_block
argument_list|()
return|;
block|}
end_function

begin_function
name|tree
name|finish_omp_parallel
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|body
operator|=
name|finish_omp_structured_block
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|make_node
argument_list|(
name|OMP_PARALLEL
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|stmt
argument_list|)
operator|=
name|clauses
expr_stmt|;
name|OMP_PARALLEL_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|body
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build and validate an OMP_FOR statement.  CLAUSES, BODY, COND, INCR    are directly for their associated operands in the statement.  DECL    and INIT are a combo; if DECL is NULL then INIT ought to be a    MODIFY_EXPR, and the DECL should be extracted.  PRE_BODY are    optional statements that need to go before the loop into its    sk_omp scope.  */
end_comment

begin_function
name|tree
name|finish_omp_for
parameter_list|(
name|location_t
name|locus
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|incr
parameter_list|,
name|tree
name|body
parameter_list|,
name|tree
name|pre_body
parameter_list|)
block|{
if|if
condition|(
name|decl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|init
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODOP_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|decl
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"expected iteration declaration or initialization"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|type_dependent_expression_p
argument_list|(
name|decl
argument_list|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|init
argument_list|)
operator|||
operator|(
name|cond
operator|&&
name|type_dependent_expression_p
argument_list|(
name|cond
argument_list|)
operator|)
operator|||
operator|(
name|incr
operator|&&
name|type_dependent_expression_p
argument_list|(
name|incr
argument_list|)
operator|)
condition|)
block|{
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
name|cond
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%Hmissing controlling predicate"
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|incr
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%Hmissing increment expression"
argument_list|,
operator|&
name|locus
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stmt
operator|=
name|make_node
argument_list|(
name|OMP_FOR
argument_list|)
expr_stmt|;
comment|/* This is really just a place-holder.  We'll be decomposing this 	 again and going through the build_modify_expr path below when 	 we instantiate the thing.  */
name|init
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_FOR_INIT
argument_list|(
name|stmt
argument_list|)
operator|=
name|init
expr_stmt|;
name|OMP_FOR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
name|OMP_FOR_INCR
argument_list|(
name|stmt
argument_list|)
operator|=
name|incr
expr_stmt|;
name|OMP_FOR_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|body
expr_stmt|;
name|OMP_FOR_PRE_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|pre_body
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|locus
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|stmt
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"expected iteration declaration or initialization"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|pre_body
operator|==
name|NULL
operator|||
name|IS_EMPTY_STMT
argument_list|(
name|pre_body
argument_list|)
condition|)
name|pre_body
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|processing_template_decl
condition|)
block|{
name|add_stmt
argument_list|(
name|pre_body
argument_list|)
expr_stmt|;
name|pre_body
operator|=
name|NULL
expr_stmt|;
block|}
name|init
operator|=
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
expr_stmt|;
return|return
name|c_finish_omp_for
argument_list|(
name|locus
argument_list|,
name|decl
argument_list|,
name|init
argument_list|,
name|cond
argument_list|,
name|incr
argument_list|,
name|body
argument_list|,
name|pre_body
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|finish_omp_atomic
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|orig_lhs
decl_stmt|;
name|tree
name|orig_rhs
decl_stmt|;
name|bool
name|dependent_p
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|orig_lhs
operator|=
name|lhs
expr_stmt|;
name|orig_rhs
operator|=
name|rhs
expr_stmt|;
name|dependent_p
operator|=
name|false
expr_stmt|;
name|stmt
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Even in a template, we can detect invalid uses of the atomic      pragma if neither LHS nor RHS is type-dependent.  */
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|dependent_p
operator|=
operator|(
name|type_dependent_expression_p
argument_list|(
name|lhs
argument_list|)
operator|||
name|type_dependent_expression_p
argument_list|(
name|rhs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|dependent_p
condition|)
block|{
name|lhs
operator|=
name|build_non_dependent_expr
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|build_non_dependent_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|dependent_p
condition|)
block|{
name|stmt
operator|=
name|c_finish_omp_atomic
argument_list|(
name|code
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|==
name|error_mark_node
condition|)
return|return;
block|}
if|if
condition|(
name|processing_template_decl
condition|)
block|{
name|stmt
operator|=
name|build2
argument_list|(
name|OMP_ATOMIC
argument_list|,
name|void_type_node
argument_list|,
name|orig_lhs
argument_list|,
name|orig_rhs
argument_list|)
expr_stmt|;
name|OMP_ATOMIC_DEPENDENT_P
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|OMP_ATOMIC_CODE
argument_list|(
name|stmt
argument_list|)
operator|=
name|code
expr_stmt|;
block|}
name|add_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_omp_barrier
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fn
init|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_BARRIER
index|]
decl_stmt|;
name|tree
name|stmt
init|=
name|finish_call_expr
argument_list|(
name|fn
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|finish_expr_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_omp_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fn
init|=
name|built_in_decls
index|[
name|BUILT_IN_SYNCHRONIZE
index|]
decl_stmt|;
name|tree
name|stmt
init|=
name|finish_call_expr
argument_list|(
name|fn
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|finish_expr_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* True if OpenMP sharing attribute of DECL is predetermined.  */
end_comment

begin_function
name|enum
name|omp_clause_default_kind
name|cxx_omp_predetermined_sharing
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|enum
name|omp_clause_default_kind
name|kind
decl_stmt|;
name|kind
operator|=
name|c_omp_predetermined_sharing
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
condition|)
return|return
name|kind
return|;
comment|/* Static data members are predetermined as shared.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|ctx
init|=
name|CP_DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|ctx
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|ctx
argument_list|)
condition|)
return|return
name|OMP_CLAUSE_DEFAULT_SHARED
return|;
block|}
return|return
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_cp_semantics
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_include
include|#
directive|include
file|"gt-cp-semantics.h"
end_include

end_unit

