begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic SSA value propagation engine.    Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"vec.h"
end_include

begin_comment
comment|/* This file implements a generic value propagation engine based on    the same propagation used by the SSA-CCP algorithm [1].     Propagation is performed by simulating the execution of every    statement that produces the value being propagated.  Simulation    proceeds as follows:     1- Initially, all edges of the CFG are marked not executable and       the CFG worklist is seeded with all the statements in the entry       basic block (block 0).     2- Every statement S is simulated with a call to the call-back       function SSA_PROP_VISIT_STMT.  This evaluation may produce 3       results:        	SSA_PROP_NOT_INTERESTING: Statement S produces nothing of 	    interest and does not affect any of the work lists.  	SSA_PROP_VARYING: The value produced by S cannot be determined 	    at compile time.  Further simulation of S is not required. 	    If S is a conditional jump, all the outgoing edges for the 	    block are considered executable and added to the work 	    list.  	SSA_PROP_INTERESTING: S produces a value that can be computed 	    at compile time.  Its result can be propagated into the 	    statements that feed from S.  Furthermore, if S is a 	    conditional jump, only the edge known to be taken is added 	    to the work list.  Edges that are known not to execute are 	    never simulated.     3- PHI nodes are simulated with a call to SSA_PROP_VISIT_PHI.  The       return value from SSA_PROP_VISIT_PHI has the same semantics as       described in #2.     4- Three work lists are kept.  Statements are only added to these       lists if they produce one of SSA_PROP_INTERESTING or       SSA_PROP_VARYING.     	CFG_BLOCKS contains the list of blocks to be simulated. 	    Blocks are added to this list if their incoming edges are 	    found executable.  	VARYING_SSA_EDGES contains the list of statements that feed 	    from statements that produce an SSA_PROP_VARYING result. 	    These are simulated first to speed up processing.  	INTERESTING_SSA_EDGES contains the list of statements that 	    feed from statements that produce an SSA_PROP_INTERESTING 	    result.     5- Simulation terminates when all three work lists are drained.     Before calling ssa_propagate, it is important to clear    DONT_SIMULATE_AGAIN for all the statements in the program that    should be simulated.  This initialization allows an implementation    to specify which statements should never be simulated.     It is also important to compute def-use information before calling    ssa_propagate.     References:       [1] Constant propagation with conditional branches,          Wegman and Zadeck, ACM TOPLAS 13(2):181-210.       [2] Building an Optimizing Compiler, 	 Robert Morgan, Butterworth-Heinemann, 1998, Section 8.9.       [3] Advanced Compiler Design and Implementation, 	 Steven Muchnick, Morgan Kaufmann, 1997, Section 12.6  */
end_comment

begin_comment
comment|/* Function pointers used to parameterize the propagation engine.  */
end_comment

begin_decl_stmt
specifier|static
name|ssa_prop_visit_stmt_fn
name|ssa_prop_visit_stmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ssa_prop_visit_phi_fn
name|ssa_prop_visit_phi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use the TREE_DEPRECATED bitflag to mark statements that have been    added to one of the SSA edges worklists.  This flag is used to    avoid visiting statements unnecessarily when draining an SSA edge    worklist.  If while simulating a basic block, we find a statement with    STMT_IN_SSA_EDGE_WORKLIST set, we clear it to prevent SSA edge    processing from visiting it again.  */
end_comment

begin_define
define|#
directive|define
name|STMT_IN_SSA_EDGE_WORKLIST
parameter_list|(
name|T
parameter_list|)
value|TREE_DEPRECATED (T)
end_define

begin_comment
comment|/* A bitmap to keep track of executable blocks in the CFG.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|executable_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of control flow edges on the worklist.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|)
operator|*
name|cfg_blocks
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cfg_blocks_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cfg_blocks_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cfg_blocks_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
name|bb_in_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Worklist of SSA edges which will need reexamination as their    definition has changed.  SSA edges are def-use edges in the SSA    web.  For each D-U edge, we store the target statement or PHI node    U.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|interesting_ssa_edges
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Identical to INTERESTING_SSA_EDGES.  For performance reasons, the    list of SSA edges is split into two.  One contains all SSA edges    who need to be reexamined because their lattice value changed to    varying (this worklist), and the other contains all other SSA edges    to be reexamined (INTERESTING_SSA_EDGES).     Since most values in the program are VARYING, the ideal situation    is to move them to that lattice value as quickly as possible.    Thus, it doesn't make sense to process any other type of lattice    value until all VARYING values are propagated fully, which is one    thing using the VARYING worklist achieves.  In addition, if we    don't use a separate worklist for VARYING edges, we end up with    situations where lattice values move from    UNDEFINED->INTERESTING->VARYING instead of UNDEFINED->VARYING.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|varying_ssa_edges
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return true if the block worklist empty.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|cfg_blocks_empty_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cfg_blocks_num
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a basic block to the worklist.  The block must not be already    in the worklist, and it must not be the ENTRY or EXIT block.  */
end_comment

begin_function
specifier|static
name|void
name|cfg_blocks_add
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|bool
name|head
init|=
name|false
decl_stmt|;
name|gcc_assert
argument_list|(
name|bb
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
name|bb
operator|!=
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TEST_BIT
argument_list|(
name|bb_in_list
argument_list|,
name|bb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_blocks_empty_p
argument_list|()
condition|)
block|{
name|cfg_blocks_tail
operator|=
name|cfg_blocks_head
operator|=
literal|0
expr_stmt|;
name|cfg_blocks_num
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cfg_blocks_num
operator|++
expr_stmt|;
if|if
condition|(
name|cfg_blocks_num
operator|>
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|)
condition|)
block|{
comment|/* We have to grow the array now.  Adjust to queue to occupy 	     the full space of the original array.  We do not need to 	     initialize the newly allocated portion of the array 	     because we keep track of CFG_BLOCKS_HEAD and 	     CFG_BLOCKS_HEAD.  */
name|cfg_blocks_tail
operator|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|)
expr_stmt|;
name|cfg_blocks_head
operator|=
literal|0
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|cfg_blocks
argument_list|,
literal|2
operator|*
name|cfg_blocks_tail
argument_list|)
expr_stmt|;
block|}
comment|/* Minor optimization: we prefer to see blocks with more 	 predecessors later, because there is more of a chance that 	 the incoming edges will be executable.  */
elseif|else
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|>=
name|EDGE_COUNT
argument_list|(
name|VEC_index
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|,
name|cfg_blocks_head
argument_list|)
operator|->
name|preds
argument_list|)
condition|)
name|cfg_blocks_tail
operator|=
operator|(
operator|(
name|cfg_blocks_tail
operator|+
literal|1
operator|)
operator|%
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cfg_blocks_head
operator|==
literal|0
condition|)
name|cfg_blocks_head
operator|=
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|)
expr_stmt|;
operator|--
name|cfg_blocks_head
expr_stmt|;
name|head
operator|=
name|true
expr_stmt|;
block|}
block|}
name|VEC_replace
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|,
name|head
condition|?
name|cfg_blocks_head
else|:
name|cfg_blocks_tail
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|bb_in_list
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a block from the worklist.  */
end_comment

begin_function
specifier|static
name|basic_block
name|cfg_blocks_get
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|bb
operator|=
name|VEC_index
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|,
name|cfg_blocks_head
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|cfg_blocks_empty_p
argument_list|()
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|cfg_blocks_head
operator|=
operator|(
operator|(
name|cfg_blocks_head
operator|+
literal|1
operator|)
operator|%
name|VEC_length
argument_list|(
name|basic_block
argument_list|,
name|cfg_blocks
argument_list|)
operator|)
expr_stmt|;
operator|--
name|cfg_blocks_num
expr_stmt|;
name|RESET_BIT
argument_list|(
name|bb_in_list
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* We have just defined a new value for VAR.  If IS_VARYING is true,    add all immediate uses of VAR to VARYING_SSA_EDGES, otherwise add    them to INTERESTING_SSA_EDGES.  */
end_comment

begin_function
specifier|static
name|void
name|add_ssa_edge
parameter_list|(
name|tree
name|var
parameter_list|,
name|bool
name|is_varying
parameter_list|)
block|{
name|imm_use_iterator
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|iter
argument_list|,
argument|var
argument_list|)
block|{
name|tree
name|use_stmt
init|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DONT_SIMULATE_AGAIN
argument_list|(
name|use_stmt
argument_list|)
operator|&&
operator|!
name|STMT_IN_SSA_EDGE_WORKLIST
argument_list|(
name|use_stmt
argument_list|)
condition|)
block|{
name|STMT_IN_SSA_EDGE_WORKLIST
argument_list|(
name|use_stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_varying
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|varying_ssa_edges
argument_list|,
name|use_stmt
argument_list|)
expr_stmt|;
else|else
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|interesting_ssa_edges
argument_list|,
name|use_stmt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add edge E to the control flow worklist.  */
end_comment

begin_function
specifier|static
name|void
name|add_control_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return;
comment|/* If the edge had already been executed, skip it.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EXECUTABLE
condition|)
return|return;
name|e
operator|->
name|flags
operator||=
name|EDGE_EXECUTABLE
expr_stmt|;
comment|/* If the block is already in the list, we're done.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|bb_in_list
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
return|return;
name|cfg_blocks_add
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Adding Destination of edge (%d -> %d) to worklist\n\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simulate the execution of STMT and update the work lists accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|simulate_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|enum
name|ssa_prop_result
name|val
init|=
name|SSA_PROP_NOT_INTERESTING
decl_stmt|;
name|edge
name|taken_edge
init|=
name|NULL
decl_stmt|;
name|tree
name|output_name
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Don't bother visiting statements that are already      considered varying by the propagator.  */
if|if
condition|(
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|val
operator|=
name|ssa_prop_visit_phi
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|output_name
operator|=
name|PHI_RESULT
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|ssa_prop_visit_stmt
argument_list|(
name|stmt
argument_list|,
operator|&
name|taken_edge
argument_list|,
operator|&
name|output_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|SSA_PROP_VARYING
condition|)
block|{
name|DONT_SIMULATE_AGAIN
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If the statement produced a new varying value, add the SSA 	 edges coming out of OUTPUT_NAME.  */
if|if
condition|(
name|output_name
condition|)
name|add_ssa_edge
argument_list|(
name|output_name
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If STMT transfers control out of its basic block, add 	 all outgoing edges to the work list.  */
if|if
condition|(
name|stmt_ends_bb_p
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|add_control_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|SSA_PROP_INTERESTING
condition|)
block|{
comment|/* If the statement produced new value, add the SSA edges coming 	 out of OUTPUT_NAME.  */
if|if
condition|(
name|output_name
condition|)
name|add_ssa_edge
argument_list|(
name|output_name
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If we know which edge is going to be taken out of this block, 	 add it to the CFG work list.  */
if|if
condition|(
name|taken_edge
condition|)
name|add_control_edge
argument_list|(
name|taken_edge
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process an SSA edge worklist.  WORKLIST is the SSA edge worklist to    drain.  This pops statements off the given WORKLIST and processes    them until there are no more statements on WORKLIST.    We take a pointer to WORKLIST because it may be reallocated when an    SSA edge is added to it in simulate_stmt.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|process_ssa_edge_worklist
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
operator|*
name|worklist
argument_list|)
block|{
comment|/* Drain the entire worklist.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
operator|*
name|worklist
argument_list|)
operator|>
literal|0
condition|)
block|{
name|basic_block
name|bb
decl_stmt|;
comment|/* Pull the statement to simulate off the worklist.  */
name|tree
name|stmt
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
operator|*
name|worklist
argument_list|)
decl_stmt|;
comment|/* If this statement was already visited by simulate_block, then 	 we don't need to visit it again here.  */
if|if
condition|(
operator|!
name|STMT_IN_SSA_EDGE_WORKLIST
argument_list|(
name|stmt
argument_list|)
condition|)
continue|continue;
comment|/* STMT is no longer in a worklist.  */
name|STMT_IN_SSA_EDGE_WORKLIST
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nSimulating statement (from ssa_edges): "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* PHI nodes are always visited, regardless of whether or not 	 the destination block is executable.  Otherwise, visit the 	 statement only if its block is marked executable.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
operator|||
name|TEST_BIT
argument_list|(
name|executable_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
name|simulate_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Simulate the execution of BLOCK.  Evaluate the statement associated    with each variable reference inside the block.  */
end_comment

begin_function
specifier|static
name|void
name|simulate_block
parameter_list|(
name|basic_block
name|block
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
comment|/* There is nothing to do for the exit block.  */
if|if
condition|(
name|block
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nSimulating block %d\n"
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Always simulate PHI nodes, even if we have simulated this block      before.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|block
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|simulate_stmt
argument_list|(
name|phi
argument_list|)
expr_stmt|;
comment|/* If this is the first time we've simulated this block, then we      must simulate each of its statements.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|executable_blocks
argument_list|,
name|block
operator|->
name|index
argument_list|)
condition|)
block|{
name|block_stmt_iterator
name|j
decl_stmt|;
name|unsigned
name|int
name|normal_edge_count
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|normal_edge
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Note that we have simulated this block.  */
name|SET_BIT
argument_list|(
name|executable_blocks
argument_list|,
name|block
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bsi_start
argument_list|(
name|block
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|j
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|j
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|/* If this statement is already in the worklist then 	     "cancel" it.  The reevaluation implied by the worklist 	     entry will produce the same value we generate here and 	     thus reevaluating it again from the worklist is 	     pointless.  */
if|if
condition|(
name|STMT_IN_SSA_EDGE_WORKLIST
argument_list|(
name|stmt
argument_list|)
condition|)
name|STMT_IN_SSA_EDGE_WORKLIST
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
name|simulate_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
comment|/* We can not predict when abnormal edges will be executed, so 	 once a block is considered executable, we consider any 	 outgoing abnormal edges as executable.  	 At the same time, if this block has only one successor that is 	 reached by non-abnormal edges, then add that successor to the 	 worklist.  */
name|normal_edge_count
operator|=
literal|0
expr_stmt|;
name|normal_edge
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|block->succs
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|add_control_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|normal_edge_count
operator|++
expr_stmt|;
name|normal_edge
operator|=
name|e
expr_stmt|;
block|}
block|}
if|if
condition|(
name|normal_edge_count
operator|==
literal|1
condition|)
name|add_control_edge
argument_list|(
name|normal_edge
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize local data structures and work lists.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_prop_init
parameter_list|(
name|void
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* Worklists of SSA edges.  */
name|interesting_ssa_edges
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|varying_ssa_edges
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|executable_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|executable_blocks
argument_list|)
expr_stmt|;
name|bb_in_list
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|bb_in_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|dump_immediate_uses
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|cfg_blocks
operator|=
name|VEC_alloc
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|VEC_safe_grow
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|cfg_blocks
argument_list|,
literal|20
argument_list|)
expr_stmt|;
comment|/* Initialize the values for every SSA_NAME.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_ssa_names
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ssa_name
argument_list|(
name|i
argument_list|)
condition|)
name|SSA_NAME_VALUE
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Initially assume that every edge in the CFG is not executable.      (including the edges coming out of ENTRY_BLOCK_PTR).  */
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|si
decl_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
name|STMT_IN_SSA_EDGE_WORKLIST
argument_list|(
name|bsi_stmt
argument_list|(
name|si
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_EXECUTABLE
expr_stmt|;
block|}
comment|/* Seed the algorithm by adding the successors of the entry block to the      edge worklist.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
name|add_control_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free allocated storage.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_prop_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|interesting_ssa_edges
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|varying_ssa_edges
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|basic_block
argument_list|,
name|heap
argument_list|,
name|cfg_blocks
argument_list|)
expr_stmt|;
name|cfg_blocks
operator|=
name|NULL
expr_stmt|;
name|sbitmap_free
argument_list|(
name|bb_in_list
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|executable_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the main expression from statement STMT.  */
end_comment

begin_function
name|tree
name|get_rhs
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stmt
operator|||
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|stmt
return|;
comment|/* FALLTHRU */
case|case
name|MODIFY_EXPR
case|:
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|stmt
return|;
case|case
name|COND_EXPR
case|:
return|return
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
return|;
case|case
name|SWITCH_EXPR
case|:
return|return
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
return|;
case|case
name|GOTO_EXPR
case|:
return|return
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
return|;
case|case
name|LABEL_EXPR
case|:
return|return
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
return|;
default|default:
return|return
name|stmt
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set the main expression of *STMT_P to EXPR.  If EXPR is not a valid    GIMPLE expression no changes are done and the function returns    false.  */
end_comment

begin_function
name|bool
name|set_rhs
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|,
name|op
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
comment|/* Verify the constant folded result is valid gimple.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_binary
condition|)
block|{
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_unary
condition|)
block|{
if|if
condition|(
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARRAY_REF
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPOUND_EXPR
operator|||
name|code
operator|==
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|stmt
argument_list|)
operator|&&
name|EXPR_P
argument_list|(
name|expr
argument_list|)
operator|&&
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|expr
argument_list|,
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|expr
expr_stmt|;
break|break;
block|}
name|stmt
operator|=
name|op
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|MODIFY_EXPR
case|:
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|stmt
operator|=
name|op
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|expr
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
if|if
condition|(
operator|!
name|is_gimple_condexpr
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|false
return|;
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|SWITCH_COND
argument_list|(
name|stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
name|GOTO_DESTINATION
argument_list|(
name|stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
name|LABEL_EXPR_LABEL
argument_list|(
name|stmt
argument_list|)
operator|=
name|expr
expr_stmt|;
break|break;
default|default:
comment|/* Replace the whole statement with EXPR.  If EXPR has no side 	 effects, then replace *STMT_P with an empty statement.  */
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
operator|*
name|stmt_p
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|?
name|expr
else|:
name|build_empty_stmt
argument_list|()
expr_stmt|;
operator|(
operator|*
name|stmt_p
operator|)
operator|->
name|common
operator|.
name|ann
operator|=
operator|(
name|tree_ann_t
operator|)
name|ann
expr_stmt|;
if|if
condition|(
name|in_ssa_p
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* Fix all the SSA_NAMEs created by *STMT_P to point to its new 	     replacement.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|var
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
operator|=
operator|*
name|stmt_p
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Entry point to the propagation engine.     VISIT_STMT is called for every statement visited.    VISIT_PHI is called for every PHI node visited.  */
end_comment

begin_function
name|void
name|ssa_propagate
parameter_list|(
name|ssa_prop_visit_stmt_fn
name|visit_stmt
parameter_list|,
name|ssa_prop_visit_phi_fn
name|visit_phi
parameter_list|)
block|{
name|ssa_prop_visit_stmt
operator|=
name|visit_stmt
expr_stmt|;
name|ssa_prop_visit_phi
operator|=
name|visit_phi
expr_stmt|;
name|ssa_prop_init
argument_list|()
expr_stmt|;
comment|/* Iterate until the worklists are empty.  */
while|while
condition|(
operator|!
name|cfg_blocks_empty_p
argument_list|()
operator|||
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|interesting_ssa_edges
argument_list|)
operator|>
literal|0
operator|||
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|varying_ssa_edges
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cfg_blocks_empty_p
argument_list|()
condition|)
block|{
comment|/* Pull the next block to simulate off the worklist.  */
name|basic_block
name|dest_block
init|=
name|cfg_blocks_get
argument_list|()
decl_stmt|;
name|simulate_block
argument_list|(
name|dest_block
argument_list|)
expr_stmt|;
block|}
comment|/* In order to move things to varying as quickly as 	 possible,process the VARYING_SSA_EDGES worklist first.  */
name|process_ssa_edge_worklist
argument_list|(
operator|&
name|varying_ssa_edges
argument_list|)
expr_stmt|;
comment|/* Now process the INTERESTING_SSA_EDGES worklist.  */
name|process_ssa_edge_worklist
argument_list|(
operator|&
name|interesting_ssa_edges
argument_list|)
expr_stmt|;
block|}
name|ssa_prop_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the first V_MAY_DEF or V_MUST_DEF operand for STMT.  */
end_comment

begin_function
name|tree
name|first_vdef
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|op
decl_stmt|;
comment|/* Simply return the first operand we arrive at.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
return|return
operator|(
name|op
operator|)
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if STMT is of the form 'LHS = mem_ref', where 'mem_ref'    is a non-volatile pointer dereference, a structure reference or a    reference to a single _DECL.  Ignore volatile memory references    because they are not interesting for the optimizers.  */
end_comment

begin_function
name|bool
name|stmt_makes_single_load
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|rhs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMAYDEF
operator||
name|SSA_OP_VUSE
argument_list|)
condition|)
return|return
name|false
return|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|rhs
argument_list|)
operator|&&
operator|(
name|DECL_P
argument_list|(
name|rhs
argument_list|)
operator|||
name|REFERENCE_CLASS_P
argument_list|(
name|rhs
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if STMT is of the form 'mem_ref = RHS', where 'mem_ref'    is a non-volatile pointer dereference, a structure reference or a    reference to a single _DECL.  Ignore volatile memory references    because they are not interesting for the optimizers.  */
end_comment

begin_function
name|bool
name|stmt_makes_single_store
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ZERO_SSA_OPERANDS
argument_list|(
name|stmt
argument_list|,
name|SSA_OP_VMAYDEF
operator||
name|SSA_OP_VMUSTDEF
argument_list|)
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|lhs
argument_list|)
operator|&&
operator|(
name|DECL_P
argument_list|(
name|lhs
argument_list|)
operator|||
name|REFERENCE_CLASS_P
argument_list|(
name|lhs
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If STMT makes a single memory load and all the virtual use operands    have the same value in array VALUES, return it.  Otherwise, return    NULL.  */
end_comment

begin_function
name|prop_value_t
modifier|*
name|get_value_loaded_by
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|prop_value_t
modifier|*
name|values
parameter_list|)
block|{
name|ssa_op_iter
name|i
decl_stmt|;
name|tree
name|vuse
decl_stmt|;
name|prop_value_t
modifier|*
name|prev_val
init|=
name|NULL
decl_stmt|;
name|prop_value_t
modifier|*
name|val
init|=
name|NULL
decl_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|vuse
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_VIRTUAL_USES
argument_list|)
block|{
name|val
operator|=
operator|&
name|values
index|[
name|SSA_NAME_VERSION
argument_list|(
name|vuse
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|prev_val
operator|&&
name|prev_val
operator|->
name|value
operator|!=
name|val
operator|->
name|value
condition|)
return|return
name|NULL
return|;
name|prev_val
operator|=
name|val
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Propagation statistics.  */
end_comment

begin_struct
struct|struct
name|prop_stats_d
block|{
name|long
name|num_const_prop
decl_stmt|;
name|long
name|num_copy_prop
decl_stmt|;
name|long
name|num_pred_folded
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|prop_stats_d
name|prop_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Replace USE references in statement STMT with the values stored in    PROP_VALUE. Return true if at least one reference was replaced.  If    REPLACED_ADDRESSES_P is given, it will be set to true if an address    constant was replaced.  */
end_comment

begin_function
name|bool
name|replace_uses_in
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
modifier|*
name|replaced_addresses_p
parameter_list|,
name|prop_value_t
modifier|*
name|prop_value
parameter_list|)
block|{
name|bool
name|replaced
init|=
name|false
decl_stmt|;
name|use_operand_p
name|use
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|tuse
init|=
name|USE_FROM_PTR
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|prop_value
index|[
name|SSA_NAME_VERSION
argument_list|(
name|tuse
argument_list|)
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|tuse
operator|||
name|val
operator|==
name|NULL_TREE
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
operator|&&
operator|!
name|may_propagate_copy_into_asm
argument_list|(
name|tuse
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|may_propagate_copy
argument_list|(
name|tuse
argument_list|,
name|val
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|prop_stats
operator|.
name|num_const_prop
operator|++
expr_stmt|;
else|else
name|prop_stats
operator|.
name|num_copy_prop
operator|++
expr_stmt|;
name|propagate_value
argument_list|(
name|use
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|replaced
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tuse
argument_list|)
argument_list|)
operator|&&
name|replaced_addresses_p
condition|)
operator|*
name|replaced_addresses_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|replaced
return|;
block|}
end_function

begin_comment
comment|/* Replace the VUSE references in statement STMT with the values    stored in PROP_VALUE.  Return true if a reference was replaced.  If    REPLACED_ADDRESSES_P is given, it will be set to true if an address    constant was replaced.     Replacing VUSE operands is slightly more complex than replacing    regular USEs.  We are only interested in two types of replacements    here:        1- If the value to be replaced is a constant or an SSA name for a       GIMPLE register, then we are making a copy/constant propagation       from a memory store.  For instance,        	# a_3 = V_MAY_DEF<a_2> 	a.b = x_1; 	...  	# VUSE<a_3> 	y_4 = a.b;        This replacement is only possible iff STMT is an assignment       whose RHS is identical to the LHS of the statement that created       the VUSE(s) that we are replacing.  Otherwise, we may do the       wrong replacement:        	# a_3 = V_MAY_DEF<a_2> 	# b_5 = V_MAY_DEF<b_4> 	*p = 10; 	... 	# VUSE<b_5> 	x_8 = b;        Even though 'b_5' acquires the value '10' during propagation,       there is no way for the propagator to tell whether the       replacement is correct in every reached use, because values are       computed at definition sites.  Therefore, when doing final       substitution of propagated values, we have to check each use       site.  Since the RHS of STMT ('b') is different from the LHS of       the originating statement ('*p'), we cannot replace 'b' with       '10'.        Similarly, when merging values from PHI node arguments,       propagators need to take care not to merge the same values       stored in different locations:       		if (...) 		  # a_3 = V_MAY_DEF<a_2> 		  a.b = 3; 		else 		  # a_4 = V_MAY_DEF<a_2> 		  a.c = 3; 		# a_5 = PHI<a_3, a_4>        It would be wrong to propagate '3' into 'a_5' because that       operation merges two stores to different memory locations.      2- If the value to be replaced is an SSA name for a virtual       register, then we simply replace each VUSE operand with its       value from PROP_VALUE.  This is the same replacement done by       replace_uses_in.  */
end_comment

begin_function
specifier|static
name|bool
name|replace_vuses_in
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|bool
modifier|*
name|replaced_addresses_p
parameter_list|,
name|prop_value_t
modifier|*
name|prop_value
parameter_list|)
block|{
name|bool
name|replaced
init|=
name|false
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|vuse
decl_stmt|;
if|if
condition|(
name|stmt_makes_single_load
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* If STMT is an assignment whose RHS is a single memory load, 	 see if we are trying to propagate a constant or a GIMPLE 	 register (case #1 above).  */
name|prop_value_t
modifier|*
name|val
init|=
name|get_value_loaded_by
argument_list|(
name|stmt
argument_list|,
name|prop_value
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|&&
name|val
operator|->
name|value
operator|&&
operator|(
name|is_gimple_reg
argument_list|(
name|val
operator|->
name|value
argument_list|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|val
operator|->
name|value
argument_list|)
operator|)
operator|&&
name|simple_cst_equal
argument_list|(
name|rhs
argument_list|,
name|val
operator|->
name|mem_ref
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* If we are replacing a constant address, inform our 	     caller.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
operator|->
name|value
argument_list|)
operator|!=
name|SSA_NAME
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|replaced_addresses_p
condition|)
operator|*
name|replaced_addresses_p
operator|=
name|true
expr_stmt|;
comment|/* We can only perform the substitution if the load is done 	     from the same memory location as the original store. 	     Since we already know that there are no intervening 	     stores between DEF_STMT and STMT, we only need to check 	     that the RHS of STMT is the same as the memory reference 	     propagated together with the value.  */
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|=
name|val
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
operator|->
name|value
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|prop_stats
operator|.
name|num_const_prop
operator|++
expr_stmt|;
else|else
name|prop_stats
operator|.
name|num_copy_prop
operator|++
expr_stmt|;
comment|/* Since we have replaced the whole RHS of STMT, there 	     is no point in checking the other VUSEs, as they will 	     all have the same value.  */
return|return
name|true
return|;
block|}
block|}
comment|/* Otherwise, the values for every VUSE operand must be other      SSA_NAMEs that can be propagated into STMT.  */
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|vuse
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_USES
argument_list|)
block|{
name|tree
name|var
init|=
name|USE_FROM_PTR
argument_list|(
name|vuse
argument_list|)
decl_stmt|;
name|tree
name|val
init|=
name|prop_value
index|[
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL_TREE
operator|||
name|var
operator|==
name|val
condition|)
continue|continue;
comment|/* Constants and copies propagated between real and virtual 	 operands are only possible in the cases handled above.  They 	 should be ignored in any other context.  */
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|val
argument_list|)
operator|||
name|is_gimple_reg
argument_list|(
name|val
argument_list|)
condition|)
continue|continue;
name|propagate_value
argument_list|(
name|vuse
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|prop_stats
operator|.
name|num_copy_prop
operator|++
expr_stmt|;
name|replaced
operator|=
name|true
expr_stmt|;
block|}
return|return
name|replaced
return|;
block|}
end_function

begin_comment
comment|/* Replace propagated values into all the arguments for PHI using the    values from PROP_VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|replace_phi_args_in
parameter_list|(
name|tree
name|phi
parameter_list|,
name|prop_value_t
modifier|*
name|prop_value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|replaced
init|=
name|false
decl_stmt|;
name|tree
name|prev_phi
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|prev_phi
operator|=
name|unshare_expr
argument_list|(
name|phi
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|val
init|=
name|prop_value
index|[
name|SSA_NAME_VERSION
argument_list|(
name|arg
argument_list|)
index|]
operator|.
name|value
decl_stmt|;
if|if
condition|(
name|val
operator|&&
name|val
operator|!=
name|arg
operator|&&
name|may_propagate_copy
argument_list|(
name|arg
argument_list|,
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|prop_stats
operator|.
name|num_const_prop
operator|++
expr_stmt|;
else|else
name|prop_stats
operator|.
name|num_copy_prop
operator|++
expr_stmt|;
name|propagate_value
argument_list|(
name|PHI_ARG_DEF_PTR
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|replaced
operator|=
name|true
expr_stmt|;
comment|/* If we propagated a copy and this argument flows 		 through an abnormal edge, update the replacement 		 accordingly.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|replaced
operator|&&
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Folded PHI node: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|prev_phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"           into: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If STMT has a predicate whose value can be computed using the value    range information computed by VRP, compute its value and return true.    Otherwise, return false.  */
end_comment

begin_function
specifier|static
name|bool
name|fold_predicate_in
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|tree
modifier|*
name|pred_p
init|=
name|NULL
decl_stmt|;
name|bool
name|modify_expr_p
init|=
name|false
decl_stmt|;
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|COMPARISON_CLASS_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|modify_expr_p
operator|=
name|true
expr_stmt|;
name|pred_p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|pred_p
operator|=
operator|&
name|COND_EXPR_COND
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
else|else
return|return
name|false
return|;
name|val
operator|=
name|vrp_evaluate_conditional
argument_list|(
operator|*
name|pred_p
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|modify_expr_p
condition|)
name|val
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|pred_p
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Folding predicate "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
operator|*
name|pred_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" to "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|prop_stats
operator|.
name|num_pred_folded
operator|++
expr_stmt|;
operator|*
name|pred_p
operator|=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Perform final substitution and folding of propagated values.     PROP_VALUE[I] contains the single value that should be substituted    at every use of SSA name N_I.  If PROP_VALUE is NULL, no values are    substituted.     If USE_RANGES_P is true, statements that contain predicate    expressions are evaluated with a call to vrp_evaluate_conditional.    This will only give meaningful results when called from tree-vrp.c    (the information used by vrp_evaluate_conditional is built by the    VRP pass).  */
end_comment

begin_function
name|void
name|substitute_and_fold
parameter_list|(
name|prop_value_t
modifier|*
name|prop_value
parameter_list|,
name|bool
name|use_ranges_p
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|prop_value
operator|==
name|NULL
operator|&&
operator|!
name|use_ranges_p
condition|)
return|return;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nSubstituing values and folding statements\n\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|prop_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Substitute values in every statement of every basic block.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
name|tree
name|phi
decl_stmt|;
comment|/* Propagate known values into PHI nodes.  */
if|if
condition|(
name|prop_value
condition|)
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|replace_phi_args_in
argument_list|(
name|phi
argument_list|,
name|prop_value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|bool
name|replaced_address
decl_stmt|,
name|did_replace
decl_stmt|;
name|tree
name|prev_stmt
init|=
name|NULL
decl_stmt|;
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Ignore ASSERT_EXPRs.  They are used by VRP to generate 	     range information for names and they are discarded 	     afterwards.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASSERT_EXPR
condition|)
continue|continue;
comment|/* Replace the statement with its folded version and mark it 	     folded.  */
name|did_replace
operator|=
name|false
expr_stmt|;
name|replaced_address
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|prev_stmt
operator|=
name|unshare_expr
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If we have range information, see if we can fold 	     predicate expressions.  */
if|if
condition|(
name|use_ranges_p
condition|)
name|did_replace
operator|=
name|fold_predicate_in
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_value
condition|)
block|{
comment|/* Only replace real uses if we couldn't fold the 		 statement using value range information (value range 		 information is not collected on virtuals, so we only 		 need to check this for real uses).  */
if|if
condition|(
operator|!
name|did_replace
condition|)
name|did_replace
operator||=
name|replace_uses_in
argument_list|(
name|stmt
argument_list|,
operator|&
name|replaced_address
argument_list|,
name|prop_value
argument_list|)
expr_stmt|;
name|did_replace
operator||=
name|replace_vuses_in
argument_list|(
name|stmt
argument_list|,
operator|&
name|replaced_address
argument_list|,
name|prop_value
argument_list|)
expr_stmt|;
block|}
comment|/* If we made a replacement, fold and cleanup the statement.  */
if|if
condition|(
name|did_replace
condition|)
block|{
name|tree
name|old_stmt
init|=
name|stmt
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|fold_stmt
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* If we folded a builtin function, we'll likely 		 need to rename VDEFs.  */
name|mark_new_vars_to_rename
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* If we cleaned up EH information from the statement,                  remove EH edges.  */
if|if
condition|(
name|maybe_clean_or_replace_eh_stmt
argument_list|(
name|old_stmt
argument_list|,
name|stmt
argument_list|)
condition|)
name|tree_purge_dead_eh_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|get_rhs
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Folded statement: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|prev_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"            into: "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Some statements may be simplified using ranges.  For 	     example, division may be replaced by shifts, modulo 	     replaced with bitwise and, etc.   Do this after  	     substituting constants, folding, etc so that we're 	     presented with a fully propagated, canonicalized 	     statement.  */
if|if
condition|(
name|use_ranges_p
condition|)
name|simplify_stmt_using_ranges
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Constants propagated: %6ld\n"
argument_list|,
name|prop_stats
operator|.
name|num_const_prop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Copies propagated:    %6ld\n"
argument_list|,
name|prop_stats
operator|.
name|num_copy_prop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Predicates folded:    %6ld\n"
argument_list|,
name|prop_stats
operator|.
name|num_pred_folded
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-ssa-propagate.h"
end_include

end_unit

