begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Sign extension elimination optimization for GNU compiler.    Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Leehod Baruch<leehod@il.ibm.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free -Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Problem description: -------------------- In order to support 32bit computations on a 64bit machine, sign extension instructions are generated to ensure the correctness of the computation. A possible policy (as currently implemented) is to generate a sign extension right after each 32bit computation. Depending on the instruction set of the architecture, some of these sign extension instructions may be redundant. There are two cases in which the extension may be redundant:  Case1: The instruction that uses the 64bit operands that are sign extended has a dual mode that works with 32bit operands. For example:    int32 a, b;    a = ....	       -->	a = ....   a = sign extend a    -->   b = ....	       -->	b = ....   b = sign extend a    --> 		       -->   cmpd a, b	       -->	cmpw a, b  //half word compare  Case2: The instruction that defines the 64bit operand (which is later sign extended) has a dual mode that defines and sign-extends simultaneously a 32bit operand.  For example:    int32 a;    ld a		     -->   lwa a   // load half word and sign extend   a = sign extend a  --> 		     -->   return a	     -->   return a   General idea for solution: -------------------------- First, try to merge the sign extension with the instruction that defines the source of the extension and (separately) with the instructions that uses the extended result.  By doing this, both cases of redundancies (as described above) will be eliminated.  Then, use partial redundancy elimination to place the non redundant ones at optimal placements.   Implementation by example: -------------------------- Note: The instruction stream is not changed till the last phase.  Phase 0: Initial code, as currently generated by gcc.  			 def1		def3 			 se1	 def2	 se3 			  | \	  |	/ | 			  |  \	  |    /  | 			  |   \	  |   /	  | 			  |    \  |  /	  | 			  |	\ | /	  | 			  |	 \|/	  | 			use1	use2	 use3 					 use4 def1 + se1: set ((reg:SI 10) (..def1rhs..)) set ((reg:DI 100) (sign_extend:DI (reg:SI 10)))  def2: set ((reg:DI 100) (const_int 7))  def3 + se3: set ((reg:SI 20) (..def3rhs..)) set ((reg:DI 100) (sign_extend:DI (reg:SI 20)))  use1: set ((reg:CC...) (compare:CC (reg:DI 100) (...)))  use2, use3, use4: set ((...) (reg:DI 100))  Phase 1: Propagate extensions to uses.  			 def1		def3 			 se1	 def2	 se3 			  | \	  |	/ | 			  |  \	  |    /  | 			  |   \	  |   /	  | 			  |    \  |  /	  | 			  |	\ | /	  | 			  |	 \|/	  | 			 se	 se	 se 			use1	use2	 use3 					 se 					 use4  From here, all of the subregs are lowpart !  def1, def2, def3: No change.  use1: set ((reg:DI 100) (sign_extend:DI ((subreg:SI (reg:DI 100))))) set ((reg:CC...) (compare:CC (reg:DI 100) (...)))  use2, use3, use4: set ((reg:DI 100) (sign_extend:DI ((subreg:SI (reg:DI 100))))) set ((...) (reg:DI 100))   Phase 2: Merge and eliminate locally redundant extensions.   			*def1	 def2	*def3 		  [se removed]	  se	 se3 			  | \	  |	/ | 			  |  \	  |    /  | 			  |   \	  |   /	  | 			  |    \  |  /	  | 			  |	\ | /	  | 			  |	 \|/	  | 		  [se removed]	 se	  se 			*use1	use2	 use3 				      [se removed] 					 use4  The instructions that were changed at this phase are marked with asterisk.  *def1: Merge failed.        Remove the sign extension instruction, modify def1 and        insert a move instruction to assure to correctness of the code. set ((subreg:SI (reg:DI 100)) (..def1rhs..)) set ((reg:SI 10) (subreg:SI (reg:DI 100)))  def2 + se: There is no need for merge. 	   Def2 is not changed but a sign extension instruction is  	   created. set ((reg:DI 100) (const_int 7)) set ((reg:DI 100) (sign_extend:DI ((subreg:SI (reg:DI 100)))))  *def3 + se3: Merge succeeded. set ((reg:DI 100) (sign_extend:DI (..def3rhs..))) set ((reg:SI 20) (reg:DI 100)) set ((reg:DI 100) (sign_extend:DI (reg:SI 20))) (The extension instruction is the original one).  *use1: Merge succeeded.  Remove the sign extension instruction. set ((reg:CC...)      (compare:CC (subreg:SI (reg:DI 100)) (...)))  use2, use3: Merge failed.  No change.  use4: The extension is locally redundant, therefore it is eliminated        at this point.   Phase 3: Eliminate globally redundant extensions.  Following the LCM output:  			 def1	 def2	 def3 				  se	 se3 			  | \	  |	/ | 			  |  \	  |    /  | 			  |   se  |   /	  | 			  |    \  |  /	  | 			  |	\ | /	  | 			  |	 \|/	  | 				[ses removed] 			 use1	use2	 use3 					 use4  se: set ((reg:DI 100) (sign_extend:DI ((subreg:SI (reg:DI 100)))))  se3: set ((reg:DI 100) (sign_extend:DI (reg:SI 20)))   Phase 4: Commit changes to the insn stream.      def1		   def3			*def1	 def2	*def3     se1	   def2	   se3		    [se removed]       [se removed]     | \	    |	  / |			  | \	  |	/ |     |  \    |	 /  |	   ------>	  |  \	  |    /  |     |	\   |	/   |	   ------>	  |   se  |   /	  |     |	 \  |  /    |			  |    \  |  /	  |     |	  \ | /	    |			  |	\ | /	  |     |	   \|/	    |			  |	 \|/	  |    use1	   use2	   use3			 *use1	 use2	 use3 		   use4					 use4  The instructions that were changed during the whole optimization are marked with asterisk.  The result:  def1 + se1: [  set ((reg:SI 10) (..def1rhs..))		     ]	 - Deleted [  set ((reg:DI 100) (sign_extend:DI (reg:SI 10)))   ]	 - Deleted set ((subreg:SI (reg:DI 100)) (..def3rhs..))		 - Inserted set ((reg:SI 10) (subreg:SI (reg:DI 100)))		 - Inserted  def2: set ((reg:DI 100) (const_int 7))			 - No change  def3 + se3: [  set ((reg:SI 20) (..def3rhs..))		     ]	 - Deleted [  set ((reg:DI 100) (sign_extend:DI (reg:SI 20)))   ]	 - Deleted set ((reg:DI 100) (sign_extend:DI (..def3rhs..)))	 - Inserted set ((reg:SI 20) (reg:DI 100))				 - Inserted  use1: [  set ((reg:CC...) (compare:CC (reg:DI 100) (...))) ]	 - Deleted set ((reg:CC...)					 - Inserted      (compare:CC (subreg:SI (reg:DI 100)) (...)))  use2, use3, use4: set ((...) (reg:DI 100))				 - No change  se:							 - Inserted set ((reg:DI 100) (sign_extend:DI ((subreg:SI (reg:DI 100)))))  Note: Most of the simple move instructions that were inserted will be       trivially dead and therefore eliminated.  The implementation outline: --------------------------- Some definitions:    A web is RELEVANT if at the end of phase 1, his leader's      relevancy is {ZERO, SIGN}_EXTENDED_DEF.  The source_mode of      the web is the source_mode of his leader.    A definition is a candidate for the optimization if it is part      of a RELEVANT web and his local source_mode is not narrower      then the source_mode of its web.    A use is a candidate for the optimization if it is part of a      RELEVANT web.    A simple explicit extension is a single set instruction that      extends a register (or a subregister) to a register (or      subregister).    A complex explicit extension is an explicit extension instruction      that is not simple.    A def extension is a simple explicit extension that is      also a candidate for the optimization.  This extension is part      of the instruction stream, it is not generated by this      optimization.    A use extension is a simple explicit extension that is generated      and stored for candidate use during this optimization.  It is      not emitted to the instruction stream till the last phase of      the optimization.    A reference is an instruction that satisfy at least on of these      criteria:      - It contains a definition with EXTENDED_DEF relevancy in a RELEVANT web.      - It is followed by a def extension.      - It contains a candidate use.  Phase 1: Propagate extensions to uses.   In this phase, we find candidate extensions for the optimization   and we generate (but not emit) proper extensions "right before the   uses".    a. Build a DF object.   b. Traverse over all the instructions that contains a definition      and set their local relevancy and local source_mode like this:      - If the instruction is a simple explicit extension instruction,        mark it as {ZERO, SIGN}_EXTENDED_DEF according to the extension        type and mark its source_mode to be the mode of the quantity        that is been extended.      - Otherwise, If the instruction has an implicit extension,        which means that its high part is an extension of its low part,        or if it is a complicated explicit extension, mark it as        EXTENDED_DEF and set its source_mode to be the narrowest        mode that is been extended in the instruction.   c. Traverse over all the instructions that contains a use and set      their local relevancy to RELEVANT_USE (except for few corner      cases).   d. Produce the web.  During union of two entries, update the      relevancy and source_mode of the leader.  There are two major      guide lines for this update:      - If one of the entries is NOT_RELEVANT, mark the leader        NOT_RELEVANT.      - If one is ZERO_EXTENDED_DEF and the other is SIGN_EXTENDED_DEF        (or vice versa) mark the leader as NOT_RELEVANT.  We don't        handle this kind of mixed webs.      (For more details about this update process,       see see_update_leader_extra_info ()).   e. Generate uses extensions according to the relevancy and      source_mode of the webs.  Phase 2: Merge and eliminate locally redundant extensions.   In this phase, we try to merge def extensions and use   extensions with their references, and eliminate redundant extensions   in the same basic block.    Traverse over all the references.  Do this in basic block number and   luid number forward order.   For each reference do:     a. Peephole optimization - try to merge it with all its        def extensions and use extensions in the following        order:        - Try to merge only the def extensions, one by one.        - Try to merge only the use extensions, one by one.        - Try to merge any couple of use extensions simultaneously.        - Try to merge any def extension with one or two uses 	 extensions simultaneously.     b. Handle each EXTENDED_DEF in it as if it was already merged with        an extension.    During the merge process we save the following data for each   register in each basic block:     a. The first instruction that defines the register in the basic        block.     b. The last instruction that defines the register in the basic        block.     c. The first extension of this register before the first        instruction that defines it in the basic block.     c. The first extension of this register after the last        instruction that defines it in the basic block.   This data will help us eliminate (or more precisely, not generate)   locally redundant extensions, and will be useful in the next stage.    While merging extensions with their reference there are 4 possible   situations:     a. A use extension was merged with the reference:        Delete the extension instruction and save the merged reference        for phase 4.  (For details, see see_use_extension_merged ())     b. A use extension failed to be merged with the reference:        If there is already such an extension in the same basic block        and it is not dead at this point, delete the unmerged extension        (it is locally redundant), otherwise properly update the above        basic block data.        (For details, see see_merge_one_use_extension ())     c. A def extension was merged with the reference:        Mark this extension as a merged_def extension and properly        update the above basic block data.        (For details, see see_merge_one_def_extension ())     d. A def extension failed to be merged with the reference:        Replace the definition of the NARROWmode register in the        reference with the proper subreg of WIDEmode register and save        the result as a merged reference.  Also, properly update the        the above basic block data.        (For details, see see_def_extension_not_merged ())  Phase 3: Eliminate globally redundant extensions. In this phase, we set the bit vectors input of the edge based LCM using the recorded data on the registers in each basic block. We also save pointers for all the anticipatable and available occurrences of the relevant extensions.  Then we run the LCM.    a. Initialize the comp, antloc, kill bit vectors to zero and the      transp bit vector to ones.    b. Traverse over all the references.  Do this in basic block number      and luid number forward order.  For each reference:      - Go over all its use extensions.  For each such extension - 	 If it is not dead from the beginning of the basic block SET 	   the antloc bit of the current extension in the current 	   basic block bits. 	 If it is not dead till the end of the basic block SET the 	   comp bit of the current extension in the current basic 	   block bits.      - Go over all its def extensions that were merged with        it.  For each such extension - 	 If it is not dead till the end of the basic block SET the   	   comp bit of the current extension in the current basic 	   block bits. 	 RESET the proper transp and kill bits.      - Go over all its def extensions that were not merged        with it.  For each such extension - 	 RESET the transp bit and SET the kill bit of the current 	 extension in the current basic block bits.    c. Run the edge based LCM.  Phase 4: Commit changes to the insn stream. This is the only phase that actually changes the instruction stream. Up to this point the optimization could be aborted at any time. Here we insert extensions at their best placements and delete the redundant ones according to the output of the LCM.  We also replace some of the instructions according to the second phase merges results.    a. Use the pre_delete_map (from the output of the LCM) in order to      delete redundant extensions.  This will prevent them from been      emitted in the first place.    b. Insert extensions on edges where needed according to      pre_insert_map and edge_list (from the output of the LCM).    c. For each reference do-      - Emit all the uses extensions that were not deleted until now,        right before the reference.      - Delete all the merged and unmerged def extensions from        the instruction stream.      - Replace the reference with the merged one, if exist.  The implementation consists of four data structures: - Data structure I   Purpose: To handle the relevancy of the uses, definitions and webs.   Relevant structures: web_entry (from df.h), see_entry_extra_info.   Details: This is a disjoint-set data structure.  Most of its functions are 	   implemented in web.c.  Each definition and use in the code are 	   elements.  A web_entry structure is allocated for each element to 	   hold the element's relevancy and source_mode.  The union rules are 	   defined in see_update_leader_extra_info (). - Data structure II   Purpose: To store references and their extensions (uses and defs) 	   and to enable traverse over these references according to basic 	   block order.   Relevant structure: see_ref_s.   Details: This data structure consists of an array of splay trees.  One splay 	   tree for each basic block.  The splay tree nodes are references and 	   the keys are the luids of the references. 	   A see_ref_s structure is allocated for each reference.  It holds the 	   reference itself, its def and uses extensions and later the merged 	   version of the reference. 	   Using this data structure we can traverse over all the references of 	   a basic block and their extensions in forward order. - Data structure III.   Purpose: To store local properties of registers for each basic block. 	   This data will later help us build the LCM sbitmap_vectors 	   input.   Relevant structure: see_register_properties.   Details: This data structure consists of an array of hash tables.  One hash 	   for each basic block.  The hash node are a register properties 	   and the keys are the numbers of the registers. 	   A see_register_properties structure is allocated for each register 	   that we might be interested in its properties. 	   Using this data structure we can easily find the properties of a 	   register in a specific basic block.  This is necessary for locally 	   redundancy elimination and for setting up the LCM input. - Data structure IV.   Purpose: To store the extensions that are candidate for PRE and their 	   anticipatable and available occurrences.   Relevant structure: see_occr, see_pre_extension_expr.   Details: This data structure is a hash tables.  Its nodes are the extensions 	   that are candidate for PRE. 	   A see_pre_extension_expr structure is allocated for each candidate 	   extension.  It holds a copy of the extension and a linked list of all 	   the anticipatable and available occurrences of it. 	   We use this data structure when we read the output of the LCM.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/* Used to classify defs and uses according to relevancy.  */
end_comment

begin_enum
enum|enum
name|entry_type
block|{
name|NOT_RELEVANT
block|,
name|SIGN_EXTENDED_DEF
block|,
name|ZERO_EXTENDED_DEF
block|,
name|EXTENDED_DEF
block|,
name|RELEVANT_USE
block|}
enum|;
end_enum

begin_comment
comment|/* Used to classify extensions in relevant webs.  */
end_comment

begin_enum
enum|enum
name|extension_type
block|{
name|DEF_EXTENSION
block|,
name|EXPLICIT_DEF_EXTENSION
block|,
name|IMPLICIT_DEF_EXTENSION
block|,
name|USE_EXTENSION
block|}
enum|;
end_enum

begin_comment
comment|/* Global data structures and flags.  */
end_comment

begin_comment
comment|/* This structure will be assigned for each web_entry structure (defined    in df.h).  It is placed in the extra_info field of a web_entry and holds the    relevancy and source mode of the web_entry.  */
end_comment

begin_struct
struct|struct
name|see_entry_extra_info
block|{
comment|/* The relevancy of the ref.  */
name|enum
name|entry_type
name|relevancy
decl_stmt|;
comment|/* The relevancy of the ref.      This field is updated only once - when this structure is created.  */
name|enum
name|entry_type
name|local_relevancy
decl_stmt|;
comment|/* The source register mode.  */
name|enum
name|machine_mode
name|source_mode
decl_stmt|;
comment|/* This field is used only if the relevancy is ZERO/SIGN_EXTENDED_DEF.      It is updated only once when this structure is created.  */
name|enum
name|machine_mode
name|local_source_mode
decl_stmt|;
comment|/* This field is used only if the relevancy is EXTENDED_DEF.      It holds the narrowest mode that is sign extended.  */
name|enum
name|machine_mode
name|source_mode_signed
decl_stmt|;
comment|/* This field is used only if the relevancy is EXTENDED_DEF.      It holds the narrowest mode that is zero extended.  */
name|enum
name|machine_mode
name|source_mode_unsigned
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* There is one such structure for every reference.  It stores the reference    itself as well as its extensions (uses and definitions).    Used as the value in splay_tree see_bb_splay_ar[].  */
end_comment

begin_struct
struct|struct
name|see_ref_s
block|{
comment|/* The luid of the insn.  */
name|unsigned
name|int
name|luid
decl_stmt|;
comment|/* The insn of the ref.  */
name|rtx
name|insn
decl_stmt|;
comment|/* The merged insn that was formed from the reference's insn and extensions.      If all merges failed, it remains NULL.  */
name|rtx
name|merged_insn
decl_stmt|;
comment|/* The def extensions of the reference that were not merged with      it.  */
name|htab_t
name|unmerged_def_se_hash
decl_stmt|;
comment|/* The def extensions of the reference that were merged with      it.  Implicit extensions of the reference will be stored here too.  */
name|htab_t
name|merged_def_se_hash
decl_stmt|;
comment|/* The uses extensions of reference.  */
name|htab_t
name|use_se_hash
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* There is one such structure for every relevant extended register in a    specific basic block.  This data will help us build the LCM sbitmap_vectors    input.  */
end_comment

begin_struct
struct|struct
name|see_register_properties
block|{
comment|/* The register number.  */
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* The last luid of the reference that defines this register in this basic      block.  */
name|int
name|last_def
decl_stmt|;
comment|/* The luid of the reference that has the first extension of this register      that appears before any definition in this basic block.  */
name|int
name|first_se_before_any_def
decl_stmt|;
comment|/* The luid of the reference that has the first extension of this register      that appears after the last definition in this basic block.  */
name|int
name|first_se_after_last_def
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Occurrence of an expression.    There must be at most one available occurrence and at most one anticipatable    occurrence per basic block.  */
end_comment

begin_struct
struct|struct
name|see_occr
block|{
comment|/* Next occurrence of this expression.  */
name|struct
name|see_occr
modifier|*
name|next
decl_stmt|;
comment|/* The insn that computes the expression.  */
name|rtx
name|insn
decl_stmt|;
name|int
name|block_num
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* There is one such structure for every relevant extension expression.    It holds a copy of this extension instruction as well as a linked lists of    pointers to all the antic and avail occurrences of it.  */
end_comment

begin_struct
struct|struct
name|see_pre_extension_expr
block|{
comment|/* A copy of the extension instruction.  */
name|rtx
name|se_insn
decl_stmt|;
comment|/* Index in the available expression bitmaps.  */
name|int
name|bitmap_index
decl_stmt|;
comment|/* List of anticipatable occurrences in basic blocks in the function.      An "anticipatable occurrence" is the first occurrence in the basic block,      the operands are not modified in the basic block prior to the occurrence      and the output is not used between the start of the block and the      occurrence.  */
name|struct
name|see_occr
modifier|*
name|antic_occr
decl_stmt|;
comment|/* List of available occurrence in basic blocks in the function.      An "available occurrence" is the last occurrence in the basic block and      the operands are not modified by following statements in the basic block      [including this insn].  */
name|struct
name|see_occr
modifier|*
name|avail_occr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper structure for the note_uses and see_replace_src functions.  */
end_comment

begin_struct
struct|struct
name|see_replace_data
block|{
name|rtx
name|from
decl_stmt|;
name|rtx
name|to
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper structure for the note_uses and see_mentioned_reg functions.  */
end_comment

begin_struct
struct|struct
name|see_mentioned_reg_data
block|{
name|rtx
name|reg
decl_stmt|;
name|bool
name|mentioned
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A data flow object that will be created once and used throughout the    optimization.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df
modifier|*
name|df
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of web_entries.  The i'th definition in the df object is associated    with def_entry[i]  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|web_entry
modifier|*
name|def_entry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of web_entries.  The i'th use in the df object is associated with    use_entry[i]  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|web_entry
modifier|*
name|use_entry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of splay_trees.    see_bb_splay_ar[i] refers to the splay tree of the i'th basic block.    The splay tree will hold see_ref_s structures.  The key is the luid    of the insn.  This way we can traverse over the references of each basic    block in forward or backward order.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
modifier|*
name|see_bb_splay_ar
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of hashes.    see_bb_hash_ar[i] refers to the hash of the i'th basic block.    The hash will hold see_register_properties structure.  The key is regno.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
modifier|*
name|see_bb_hash_ar
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table that holds a copy of all the extensions.  The key is the right    hand side of the se_insn field.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|see_pre_extension_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local LCM properties of expressions.  */
end_comment

begin_comment
comment|/* Nonzero for expressions that are transparent in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are computed (available) in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|comp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are locally anticipatable in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|antloc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are locally killed in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|ae_kill
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which should be inserted on a specific edge.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_insert_map
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which should be deleted in a specific block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_delete_map
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the edge_list returned by pre_edge_lcm.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|edge_list
modifier|*
name|edge_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the last basic block at the beginning of the optimization.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the number of uses at the beginning of the optimization.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|uses_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records the number of definitions at the beginning of the optimization.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|defs_num
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENTRY_EI
parameter_list|(
name|ENTRY
parameter_list|)
value|((struct see_entry_extra_info *) (ENTRY)->extra_info)
end_define

begin_escape
end_escape

begin_comment
comment|/* Functions implementation.  */
end_comment

begin_comment
comment|/*  Verifies that EXTENSION's pattern is this:      set (reg/subreg reg1) (sign/zero_extend:WIDEmode (reg/subreg reg2))      If it doesn't have the expected pattern return NULL.     Otherwise, if RETURN_DEST_REG is set, return reg1 else return reg2.  */
end_comment

begin_function
specifier|static
name|rtx
name|see_get_extension_reg
parameter_list|(
name|rtx
name|extension
parameter_list|,
name|bool
name|return_dest_reg
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|rhs
decl_stmt|,
name|lhs
decl_stmt|;
name|rtx
name|reg1
init|=
name|NULL
decl_stmt|;
name|rtx
name|reg2
init|=
name|NULL
decl_stmt|;
comment|/* Parallel pattern for extension not supported for the moment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|extension
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
name|NULL
return|;
name|set
operator|=
name|single_set
argument_list|(
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|NULL
return|;
name|lhs
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|lhs
argument_list|)
condition|)
name|reg1
operator|=
name|lhs
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
argument_list|)
condition|)
name|reg1
operator|=
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|SIGN_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|ZERO_EXTEND
condition|)
return|return
name|NULL
return|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|rhs
argument_list|)
condition|)
name|reg2
operator|=
name|rhs
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
name|reg2
operator|=
name|SUBREG_REG
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
if|if
condition|(
name|return_dest_reg
condition|)
return|return
name|reg1
return|;
return|return
name|reg2
return|;
block|}
end_function

begin_comment
comment|/*  Verifies that EXTENSION's pattern is this:      set (reg/subreg reg1) (sign/zero_extend: (...expr...)      If it doesn't have the expected pattern return UNKNOWN.     Otherwise, set SOURCE_MODE to be the mode of the extended expr and return     the rtx code of the extension.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|see_get_extension_data
parameter_list|(
name|rtx
name|extension
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|source_mode
parameter_list|)
block|{
name|rtx
name|rhs
decl_stmt|,
name|lhs
decl_stmt|,
name|set
decl_stmt|;
if|if
condition|(
operator|!
name|extension
operator|||
operator|!
name|INSN_P
argument_list|(
name|extension
argument_list|)
condition|)
return|return
name|UNKNOWN
return|;
comment|/* Parallel pattern for extension not supported for the moment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|extension
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
name|NOT_RELEVANT
return|;
name|set
operator|=
name|single_set
argument_list|(
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|NOT_RELEVANT
return|;
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Don't handle extensions to something other then register or      subregister.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|lhs
argument_list|)
operator|&&
operator|!
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|UNKNOWN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|SIGN_EXTEND
operator|&&
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|ZERO_EXTEND
condition|)
return|return
name|UNKNOWN
return|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|UNKNOWN
return|;
operator|*
name|source_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
return|return
name|SIGN_EXTEND
return|;
return|return
name|ZERO_EXTEND
return|;
block|}
end_function

begin_comment
comment|/* Generate instruction with the pattern:    set ((reg r) (sign/zero_extend (subreg:mode (reg r))))    (the register r on both sides of the set is the same register).    And recognize it.    If the recognition failed, this is very bad, return NULL (This will abort    the entire optimization).    Otherwise, return the generated instruction.  */
end_comment

begin_function
specifier|static
name|rtx
name|see_gen_normalized_extension
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|enum
name|rtx_code
name|extension_code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|subreg
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|extension
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|reg
operator|||
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
operator|||
operator|(
name|extension_code
operator|!=
name|SIGN_EXTEND
operator|&&
name|extension_code
operator|!=
name|ZERO_EXTEND
operator|)
condition|)
return|return
name|NULL
return|;
name|subreg
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|mode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension_code
operator|==
name|SIGN_EXTEND
condition|)
name|extension
operator|=
name|gen_rtx_SIGN_EXTEND
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|subreg
argument_list|)
expr_stmt|;
else|else
name|extension
operator|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|subreg
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|extension
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|insn_invalid_p
argument_list|(
name|insn
argument_list|)
condition|)
comment|/* Recognition failed, this is very bad for this optimization.        Abort the optimization.  */
return|return
name|NULL
return|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Hashes and splay_trees related functions implementation.  */
end_comment

begin_comment
comment|/* Helper functions for the pre_extension hash.    This kind of hash will hold see_pre_extension_expr structures.     The key is the right hand side of the se_insn field.    Note that the se_insn is an expression that looks like:     set ((reg:WIDEmode r1) (sign_extend:WIDEmode 			   (subreg:NARROWmode (reg:WIDEmode r2))))  */
end_comment

begin_comment
comment|/* Return TRUE if P1 has the same value in its rhs as P2.    Otherwise, return FALSE.    P1 and P2 are see_pre_extension_expr structures.  */
end_comment

begin_function
specifier|static
name|int
name|eq_descriptor_pre_extension
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|see_pre_extension_expr
modifier|*
name|extension1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|see_pre_extension_expr
modifier|*
name|extension2
init|=
name|p2
decl_stmt|;
name|rtx
name|set1
init|=
name|single_set
argument_list|(
name|extension1
operator|->
name|se_insn
argument_list|)
decl_stmt|;
name|rtx
name|set2
init|=
name|single_set
argument_list|(
name|extension2
operator|->
name|se_insn
argument_list|)
decl_stmt|;
name|rtx
name|rhs1
decl_stmt|,
name|rhs2
decl_stmt|;
name|gcc_assert
argument_list|(
name|set1
operator|&&
name|set2
argument_list|)
expr_stmt|;
name|rhs1
operator|=
name|SET_SRC
argument_list|(
name|set1
argument_list|)
expr_stmt|;
name|rhs2
operator|=
name|SET_SRC
argument_list|(
name|set2
argument_list|)
expr_stmt|;
return|return
name|rtx_equal_p
argument_list|(
name|rhs1
argument_list|,
name|rhs2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* P is a see_pre_extension_expr struct, use the RHS of the se_insn field.    Note that the RHS is an expression that looks like this:    (sign_extend:WIDEmode (subreg:NARROWmode (reg:WIDEmode r)))  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_descriptor_pre_extension
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|see_pre_extension_expr
modifier|*
name|extension
init|=
name|p
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|extension
operator|->
name|se_insn
argument_list|)
decl_stmt|;
name|rtx
name|rhs
decl_stmt|;
name|gcc_assert
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|hash_rtx
argument_list|(
name|rhs
argument_list|,
name|GET_MODE
argument_list|(
name|rhs
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free the allocated memory of the current see_pre_extension_expr struct.        It frees the two linked list of the occurrences structures.  */
end_comment

begin_function
specifier|static
name|void
name|hash_del_pre_extension
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|see_pre_extension_expr
modifier|*
name|extension
init|=
name|p
decl_stmt|;
name|struct
name|see_occr
modifier|*
name|curr_occr
init|=
name|extension
operator|->
name|antic_occr
decl_stmt|;
name|struct
name|see_occr
modifier|*
name|next_occr
init|=
name|NULL
decl_stmt|;
comment|/*  Free the linked list of the anticipatable occurrences.  */
while|while
condition|(
name|curr_occr
condition|)
block|{
name|next_occr
operator|=
name|curr_occr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|curr_occr
argument_list|)
expr_stmt|;
name|curr_occr
operator|=
name|next_occr
expr_stmt|;
block|}
comment|/*  Free the linked list of the available occurrences.  */
name|curr_occr
operator|=
name|extension
operator|->
name|avail_occr
expr_stmt|;
while|while
condition|(
name|curr_occr
condition|)
block|{
name|next_occr
operator|=
name|curr_occr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|curr_occr
argument_list|)
expr_stmt|;
name|curr_occr
operator|=
name|next_occr
expr_stmt|;
block|}
comment|/* Free the see_pre_extension_expr structure itself.  */
name|free
argument_list|(
name|extension
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper functions for the register_properties hash.    This kind of hash will hold see_register_properties structures.     The value of the key is the regno field of the structure.  */
end_comment

begin_comment
comment|/* Return TRUE if P1 has the same value in the regno field as P2.    Otherwise, return FALSE.    Where P1 and P2 are see_register_properties structures.  */
end_comment

begin_function
specifier|static
name|int
name|eq_descriptor_properties
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|see_register_properties
modifier|*
name|curr_prop1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|see_register_properties
modifier|*
name|curr_prop2
init|=
name|p2
decl_stmt|;
return|return
name|curr_prop1
operator|->
name|regno
operator|==
name|curr_prop2
operator|->
name|regno
return|;
block|}
end_function

begin_comment
comment|/* P is a see_register_properties struct, use the register number in the    regno field.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_descriptor_properties
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|see_register_properties
modifier|*
name|curr_prop
init|=
name|p
decl_stmt|;
return|return
name|curr_prop
operator|->
name|regno
return|;
block|}
end_function

begin_comment
comment|/* Free the allocated memory of the current see_register_properties struct.  */
end_comment

begin_function
specifier|static
name|void
name|hash_del_properties
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|see_register_properties
modifier|*
name|curr_prop
init|=
name|p
decl_stmt|;
name|free
argument_list|(
name|curr_prop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper functions for an extension hash.    This kind of hash will hold insns that look like:     set ((reg:WIDEmode r1) (sign_extend:WIDEmode 			   (subreg:NARROWmode (reg:WIDEmode r2))))    or    set ((reg:WIDEmode r1) (sign_extend:WIDEmode (reg:NARROWmode r2)))     The value of the key is (REGNO (reg:WIDEmode r1))    It is possible to search this hash in two ways:    1.  By a register rtx. The Value that is been compared to the keys is the        REGNO of it.    2.  By an insn with the above pattern. The Value that is been compared to        the keys is the REGNO of the reg on the lhs.  */
end_comment

begin_comment
comment|/* Return TRUE if P1 has the same value as P2.  Otherwise, return FALSE.    Where P1 is an insn and P2 is an insn or a register.  */
end_comment

begin_function
specifier|static
name|int
name|eq_descriptor_extension
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|rtx
name|insn
init|=
operator|(
name|rtx
operator|)
name|p1
decl_stmt|;
specifier|const
name|rtx
name|element
init|=
operator|(
name|rtx
operator|)
name|p2
decl_stmt|;
name|rtx
name|set1
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dest_reg1
decl_stmt|;
name|rtx
name|set2
init|=
name|NULL
decl_stmt|;
name|rtx
name|dest_reg2
init|=
name|NULL
decl_stmt|;
name|gcc_assert
argument_list|(
name|set1
operator|&&
name|element
operator|&&
operator|(
name|REG_P
argument_list|(
name|element
argument_list|)
operator|||
name|INSN_P
argument_list|(
name|element
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dest_reg1
operator|=
name|SET_DEST
argument_list|(
name|set1
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|set2
operator|=
name|single_set
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|dest_reg2
operator|=
name|SET_DEST
argument_list|(
name|set2
argument_list|)
expr_stmt|;
block|}
else|else
name|dest_reg2
operator|=
name|element
expr_stmt|;
return|return
name|REGNO
argument_list|(
name|dest_reg1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest_reg2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If P is an insn, use the register number of its lhs    otherwise, P is a register, use its number.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_descriptor_extension
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|rtx
name|r
init|=
operator|(
name|rtx
operator|)
name|p
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|lhs
decl_stmt|;
if|if
condition|(
name|r
operator|&&
name|REG_P
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|REGNO
argument_list|(
name|r
argument_list|)
return|;
name|gcc_assert
argument_list|(
name|r
operator|&&
name|INSN_P
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|REGNO
argument_list|(
name|lhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for a see_bb_splay_ar[i] splay tree.    It frees all the allocated memory of a struct see_ref_s pointer.     VALUE is the value of a splay tree node.  */
end_comment

begin_function
specifier|static
name|void
name|see_free_ref_s
parameter_list|(
name|splay_tree_value
name|value
parameter_list|)
block|{
name|struct
name|see_ref_s
modifier|*
name|ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|ref_s
operator|->
name|unmerged_def_se_hash
condition|)
name|htab_delete
argument_list|(
name|ref_s
operator|->
name|unmerged_def_se_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_s
operator|->
name|merged_def_se_hash
condition|)
name|htab_delete
argument_list|(
name|ref_s
operator|->
name|merged_def_se_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref_s
operator|->
name|use_se_hash
condition|)
name|htab_delete
argument_list|(
name|ref_s
operator|->
name|use_se_hash
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref_s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rest of the implementation.  */
end_comment

begin_comment
comment|/* Search the extension hash for a suitable entry for EXTENSION.    TYPE is the type of EXTENSION (USE_EXTENSION or DEF_EXTENSION).     If TYPE is DEF_EXTENSION we need to normalize EXTENSION before searching the    extension hash.     If a suitable entry was found, return the slot.  Otherwise, store EXTENSION    in the hash and return NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|see_pre_extension_expr
modifier|*
name|see_seek_pre_extension_expr
parameter_list|(
name|rtx
name|extension
parameter_list|,
name|enum
name|extension_type
name|type
parameter_list|)
block|{
name|struct
name|see_pre_extension_expr
modifier|*
modifier|*
name|slot_pre_exp
decl_stmt|,
name|temp_pre_exp
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|extension
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|extension_code
decl_stmt|;
name|enum
name|machine_mode
name|source_extension_mode
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|DEF_EXTENSION
condition|)
block|{
name|extension_code
operator|=
name|see_get_extension_data
argument_list|(
name|extension
argument_list|,
operator|&
name|source_extension_mode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|extension_code
operator|!=
name|UNKNOWN
argument_list|)
expr_stmt|;
name|extension
operator|=
name|see_gen_normalized_extension
argument_list|(
name|dest_extension_reg
argument_list|,
name|extension_code
argument_list|,
name|source_extension_mode
argument_list|)
expr_stmt|;
block|}
name|temp_pre_exp
operator|.
name|se_insn
operator|=
name|extension
expr_stmt|;
name|slot_pre_exp
operator|=
operator|(
expr|struct
name|see_pre_extension_expr
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|see_pre_extension_hash
argument_list|,
operator|&
name|temp_pre_exp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot_pre_exp
operator|==
name|NULL
condition|)
comment|/* This is the first time this extension instruction is encountered.  Store        it in the hash.  */
block|{
operator|(
operator|*
name|slot_pre_exp
operator|)
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_pre_extension_expr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|slot_pre_exp
operator|)
operator|->
name|se_insn
operator|=
name|extension
expr_stmt|;
operator|(
operator|*
name|slot_pre_exp
operator|)
operator|->
name|bitmap_index
operator|=
operator|(
name|htab_elements
argument_list|(
name|see_pre_extension_hash
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|(
operator|*
name|slot_pre_exp
operator|)
operator|->
name|antic_occr
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|slot_pre_exp
operator|)
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|*
name|slot_pre_exp
return|;
block|}
end_function

begin_comment
comment|/* This function defines how to update the extra_info of the web_entry.     FIRST is the pointer of the extra_info of the first web_entry.    SECOND is the pointer of the extra_info of the second web_entry.    The first web_entry will be the predecessor (leader) of the second web_entry    after the union.        Return true if FIRST and SECOND points to the same web entry structure and     nothing is done.  Otherwise, return false.  */
end_comment

begin_function
specifier|static
name|bool
name|see_update_leader_extra_info
parameter_list|(
name|struct
name|web_entry
modifier|*
name|first
parameter_list|,
name|struct
name|web_entry
modifier|*
name|second
parameter_list|)
block|{
name|struct
name|see_entry_extra_info
modifier|*
name|first_ei
decl_stmt|,
modifier|*
name|second_ei
decl_stmt|;
name|first
operator|=
name|unionfind_root
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|second
operator|=
name|unionfind_root
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|unionfind_union
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
condition|)
return|return
name|true
return|;
name|first_ei
operator|=
operator|(
expr|struct
name|see_entry_extra_info
operator|*
operator|)
name|first
operator|->
name|extra_info
expr_stmt|;
name|second_ei
operator|=
operator|(
expr|struct
name|see_entry_extra_info
operator|*
operator|)
name|second
operator|->
name|extra_info
expr_stmt|;
name|gcc_assert
argument_list|(
name|first_ei
operator|&&
name|second_ei
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_ei
operator|->
name|relevancy
operator|==
name|NOT_RELEVANT
condition|)
block|{
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|first_ei
operator|->
name|relevancy
condition|)
block|{
case|case
name|NOT_RELEVANT
case|:
break|break;
case|case
name|RELEVANT_USE
case|:
switch|switch
condition|(
name|second_ei
operator|->
name|relevancy
condition|)
block|{
case|case
name|RELEVANT_USE
case|:
break|break;
case|case
name|EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|second_ei
operator|->
name|relevancy
expr_stmt|;
name|first_ei
operator|->
name|source_mode_signed
operator|=
name|second_ei
operator|->
name|source_mode_signed
expr_stmt|;
name|first_ei
operator|->
name|source_mode_unsigned
operator|=
name|second_ei
operator|->
name|source_mode_unsigned
expr_stmt|;
break|break;
case|case
name|SIGN_EXTENDED_DEF
case|:
case|case
name|ZERO_EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|second_ei
operator|->
name|relevancy
expr_stmt|;
name|first_ei
operator|->
name|source_mode
operator|=
name|second_ei
operator|->
name|source_mode
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|SIGN_EXTENDED_DEF
case|:
switch|switch
condition|(
name|second_ei
operator|->
name|relevancy
condition|)
block|{
case|case
name|SIGN_EXTENDED_DEF
case|:
comment|/* The mode of the root should be the wider one in this case.  */
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode
operator|>
name|second_ei
operator|->
name|source_mode
operator|)
condition|?
name|first_ei
operator|->
name|source_mode
else|:
name|second_ei
operator|->
name|source_mode
expr_stmt|;
break|break;
case|case
name|RELEVANT_USE
case|:
break|break;
case|case
name|ZERO_EXTENDED_DEF
case|:
comment|/* Don't mix webs with zero extend and sign extend.  */
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
break|break;
case|case
name|EXTENDED_DEF
case|:
if|if
condition|(
name|second_ei
operator|->
name|source_mode_signed
operator|==
name|MAX_MACHINE_MODE
condition|)
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
else|else
comment|/* The mode of the root should be the wider one in this case.  */
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode
operator|>
name|second_ei
operator|->
name|source_mode_signed
operator|)
condition|?
name|first_ei
operator|->
name|source_mode
else|:
name|second_ei
operator|->
name|source_mode_signed
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* This case is similar to the previous one, with little changes.  */
case|case
name|ZERO_EXTENDED_DEF
case|:
switch|switch
condition|(
name|second_ei
operator|->
name|relevancy
condition|)
block|{
case|case
name|SIGN_EXTENDED_DEF
case|:
comment|/* Don't mix webs with zero extend and sign extend.  */
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
break|break;
case|case
name|RELEVANT_USE
case|:
break|break;
case|case
name|ZERO_EXTENDED_DEF
case|:
comment|/* The mode of the root should be the wider one in this case.  */
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode
operator|>
name|second_ei
operator|->
name|source_mode
operator|)
condition|?
name|first_ei
operator|->
name|source_mode
else|:
name|second_ei
operator|->
name|source_mode
expr_stmt|;
break|break;
case|case
name|EXTENDED_DEF
case|:
if|if
condition|(
name|second_ei
operator|->
name|source_mode_unsigned
operator|==
name|MAX_MACHINE_MODE
condition|)
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
else|else
comment|/* The mode of the root should be the wider one in this case.  */
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode
operator|>
name|second_ei
operator|->
name|source_mode_unsigned
operator|)
condition|?
name|first_ei
operator|->
name|source_mode
else|:
name|second_ei
operator|->
name|source_mode_unsigned
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EXTENDED_DEF
case|:
if|if
condition|(
name|first_ei
operator|->
name|source_mode_signed
operator|!=
name|MAX_MACHINE_MODE
operator|&&
name|first_ei
operator|->
name|source_mode_unsigned
operator|!=
name|MAX_MACHINE_MODE
condition|)
block|{
switch|switch
condition|(
name|second_ei
operator|->
name|relevancy
condition|)
block|{
case|case
name|SIGN_EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|SIGN_EXTENDED_DEF
expr_stmt|;
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_signed
operator|>
name|second_ei
operator|->
name|source_mode
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_signed
else|:
name|second_ei
operator|->
name|source_mode
expr_stmt|;
break|break;
case|case
name|RELEVANT_USE
case|:
break|break;
case|case
name|ZERO_EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|ZERO_EXTENDED_DEF
expr_stmt|;
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_unsigned
operator|>
name|second_ei
operator|->
name|source_mode
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_unsigned
else|:
name|second_ei
operator|->
name|source_mode
expr_stmt|;
break|break;
case|case
name|EXTENDED_DEF
case|:
if|if
condition|(
name|second_ei
operator|->
name|source_mode_unsigned
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|first_ei
operator|->
name|source_mode_unsigned
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_unsigned
operator|>
name|second_ei
operator|->
name|source_mode_unsigned
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_unsigned
else|:
name|second_ei
operator|->
name|source_mode_unsigned
expr_stmt|;
if|if
condition|(
name|second_ei
operator|->
name|source_mode_signed
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|first_ei
operator|->
name|source_mode_signed
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_signed
operator|>
name|second_ei
operator|->
name|source_mode_signed
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_signed
else|:
name|second_ei
operator|->
name|source_mode_signed
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|first_ei
operator|->
name|source_mode_signed
operator|==
name|MAX_MACHINE_MODE
condition|)
block|{
name|gcc_assert
argument_list|(
name|first_ei
operator|->
name|source_mode_unsigned
operator|!=
name|MAX_MACHINE_MODE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|second_ei
operator|->
name|relevancy
condition|)
block|{
case|case
name|SIGN_EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
break|break;
case|case
name|RELEVANT_USE
case|:
break|break;
case|case
name|ZERO_EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|ZERO_EXTENDED_DEF
expr_stmt|;
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_unsigned
operator|>
name|second_ei
operator|->
name|source_mode
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_unsigned
else|:
name|second_ei
operator|->
name|source_mode
expr_stmt|;
break|break;
case|case
name|EXTENDED_DEF
case|:
if|if
condition|(
name|second_ei
operator|->
name|source_mode_unsigned
operator|==
name|MAX_MACHINE_MODE
condition|)
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
else|else
name|first_ei
operator|->
name|source_mode_unsigned
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_unsigned
operator|>
name|second_ei
operator|->
name|source_mode_unsigned
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_unsigned
else|:
name|second_ei
operator|->
name|source_mode_unsigned
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|first_ei
operator|->
name|source_mode_unsigned
operator|==
name|MAX_MACHINE_MODE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|first_ei
operator|->
name|source_mode_signed
operator|!=
name|MAX_MACHINE_MODE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|second_ei
operator|->
name|relevancy
condition|)
block|{
case|case
name|SIGN_EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|SIGN_EXTENDED_DEF
expr_stmt|;
name|first_ei
operator|->
name|source_mode
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_signed
operator|>
name|second_ei
operator|->
name|source_mode
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_signed
else|:
name|second_ei
operator|->
name|source_mode
expr_stmt|;
break|break;
case|case
name|RELEVANT_USE
case|:
break|break;
case|case
name|ZERO_EXTENDED_DEF
case|:
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
break|break;
case|case
name|EXTENDED_DEF
case|:
if|if
condition|(
name|second_ei
operator|->
name|source_mode_signed
operator|==
name|MAX_MACHINE_MODE
condition|)
name|first_ei
operator|->
name|relevancy
operator|=
name|NOT_RELEVANT
expr_stmt|;
else|else
name|first_ei
operator|->
name|source_mode_signed
operator|=
operator|(
name|first_ei
operator|->
name|source_mode_signed
operator|>
name|second_ei
operator|->
name|source_mode_signed
operator|)
condition|?
name|first_ei
operator|->
name|source_mode_signed
else|:
name|second_ei
operator|->
name|source_mode_signed
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* Unknown patern type.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Free global data structures.  */
end_comment

begin_function
specifier|static
name|void
name|see_free_data_structures
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* Free the bitmap vectors.  */
if|if
condition|(
name|transp
condition|)
block|{
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|transp
operator|=
name|NULL
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|=
name|NULL
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|antloc
argument_list|)
expr_stmt|;
name|antloc
operator|=
name|NULL
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
name|ae_kill
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pre_insert_map
condition|)
block|{
name|sbitmap_vector_free
argument_list|(
name|pre_insert_map
argument_list|)
expr_stmt|;
name|pre_insert_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pre_delete_map
condition|)
block|{
name|sbitmap_vector_free
argument_list|(
name|pre_delete_map
argument_list|)
expr_stmt|;
name|pre_delete_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|edge_list
condition|)
block|{
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|edge_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  Free the extension hash.  */
name|htab_delete
argument_list|(
name|see_pre_extension_hash
argument_list|)
expr_stmt|;
comment|/*  Free the array of hashes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|see_bb_hash_ar
index|[
name|i
index|]
condition|)
name|htab_delete
argument_list|(
name|see_bb_hash_ar
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|see_bb_hash_ar
argument_list|)
expr_stmt|;
comment|/*  Free the array of splay trees.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|see_bb_splay_ar
index|[
name|i
index|]
condition|)
name|splay_tree_delete
argument_list|(
name|see_bb_splay_ar
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|see_bb_splay_ar
argument_list|)
expr_stmt|;
comment|/*  Free the array of web entries and their extra info field.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|defs_num
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|def_entry
index|[
name|j
index|]
operator|.
name|extra_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def_entry
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|uses_num
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|use_entry
index|[
name|j
index|]
operator|.
name|extra_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|use_entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize global data structures and variables.  */
end_comment

begin_function
specifier|static
name|void
name|see_initialize_data_structures
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Build the df object. */
name|df
operator|=
name|df_init
argument_list|(
name|DF_HARD_REGS
operator||
name|DF_EQUIV_NOTES
operator||
name|DF_SUBREGS
argument_list|)
expr_stmt|;
name|df_rd_add_problem
argument_list|(
name|df
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_chain_add_problem
argument_list|(
name|df
argument_list|,
name|DF_DU_CHAIN
operator||
name|DF_UD_CHAIN
argument_list|)
expr_stmt|;
name|df_analyze
argument_list|(
name|df
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|df_dump
argument_list|(
name|df
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
comment|/* Record the last basic block at the beginning of the optimization.  */
name|last_bb
operator|=
name|last_basic_block
expr_stmt|;
comment|/* Record the number of uses at the beginning of the optimization.  */
name|uses_num
operator|=
name|DF_USES_SIZE
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/* Record the number of definitions at the beginning of the optimization.  */
name|defs_num
operator|=
name|DF_DEFS_SIZE
argument_list|(
name|df
argument_list|)
expr_stmt|;
comment|/*  Allocate web entries array for the union-find data structure.  */
name|def_entry
operator|=
name|xcalloc
argument_list|(
name|defs_num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|web_entry
argument_list|)
argument_list|)
expr_stmt|;
name|use_entry
operator|=
name|xcalloc
argument_list|(
name|uses_num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|web_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Allocate an array of splay trees.       One splay tree for each basic block.  */
name|see_bb_splay_ar
operator|=
name|xcalloc
argument_list|(
name|last_bb
argument_list|,
sizeof|sizeof
argument_list|(
name|splay_tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Allocate an array of hashes.       One hash for each basic block.  */
name|see_bb_hash_ar
operator|=
name|xcalloc
argument_list|(
name|last_bb
argument_list|,
sizeof|sizeof
argument_list|(
name|htab_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Allocate the extension hash.  It will hold the extensions that we want       to PRE.  */
name|see_pre_extension_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_pre_extension
argument_list|,
name|eq_descriptor_pre_extension
argument_list|,
name|hash_del_pre_extension
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function called by note_uses to check if a register is used in a    subexpressions.     X is a pointer to the subexpression and DATA is a pointer to a    see_mentioned_reg_data structure that contains the register to look for and    a place for the result.  */
end_comment

begin_function
specifier|static
name|void
name|see_mentioned_reg
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|see_mentioned_reg_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|see_mentioned_reg_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|d
operator|->
name|reg
argument_list|,
operator|*
name|x
argument_list|)
condition|)
name|d
operator|->
name|mentioned
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We don't want to merge a use extension with a reference if the extended    register is used only in a simple move instruction.  We also don't want to    merge a def extension with a reference if the source register of the    extension is defined only in a simple move in the reference.     REF is the reference instruction.    EXTENSION is the use extension or def extension instruction.    TYPE is the type of the extension (use or def).     Return true if the reference is complicated enough, so we would like to merge    it with the extension.  Otherwise, return false.  */
end_comment

begin_function
specifier|static
name|bool
name|see_want_to_be_merged_with_extension
parameter_list|(
name|rtx
name|ref
parameter_list|,
name|rtx
name|extension
parameter_list|,
name|enum
name|extension_type
name|type
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|extension
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|source_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|extension
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|struct
name|see_mentioned_reg_data
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|sub
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|sub
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This is a simple move SET.  */
if|if
condition|(
name|type
operator|==
name|DEF_EXTENSION
operator|&&
name|reg_mentioned_p
argument_list|(
name|source_extension_reg
argument_list|,
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* This is not a simple move SET. 		 Check if it uses the source of the extension.  */
if|if
condition|(
name|type
operator|==
name|USE_EXTENSION
condition|)
block|{
name|d
operator|.
name|reg
operator|=
name|dest_extension_reg
expr_stmt|;
name|d
operator|.
name|mentioned
operator|=
name|false
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|sub
argument_list|,
name|see_mentioned_reg
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|mentioned
condition|)
return|return
name|true
return|;
block|}
block|}
block|}
if|if
condition|(
name|type
operator|==
name|USE_EXTENSION
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
comment|/* This is a simple move SET.  */
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Print the register number of the current see_register_properties    structure.     This is a subroutine of see_main called via htab_traverse.    SLOT contains the current see_register_properties structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_print_register_properties
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|see_register_properties
modifier|*
name|prop
init|=
operator|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Property found for register %d\n"
argument_list|,
name|prop
operator|->
name|regno
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print the extension instruction of the current see_register_properties    structure.     This is a subroutine of see_main called via htab_traverse.    SLOT contains the current see_pre_extension_expr structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_print_pre_extension_expr
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|see_pre_extension_expr
modifier|*
name|pre_extension
init|=
operator|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|pre_extension
operator|&&
name|pre_extension
operator|->
name|se_insn
operator|&&
name|INSN_P
argument_list|(
name|pre_extension
operator|->
name|se_insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Index %d for:\n"
argument_list|,
name|pre_extension
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|pre_extension
operator|->
name|se_insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Phase 4 implementation: Commit changes to the insn stream.  */
end_comment

begin_comment
comment|/* Delete the merged def extension.     This is a subroutine of see_commit_ref_changes called via htab_traverse.     SLOT contains the current def extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_delete_merged_def_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Deleting merged def extension:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|def_se
argument_list|)
condition|)
comment|/* This def extension is an implicit one.  No need to delete it since        it is not in the insn stream.  */
return|return
literal|1
return|;
name|delete_insn
argument_list|(
name|def_se
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Delete the unmerged def extension.     This is a subroutine of see_commit_ref_changes called via htab_traverse.     SLOT contains the current def extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_delete_unmerged_def_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Deleting unmerged def extension:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|def_se
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Emit the non-redundant use extension to the instruction stream.     This is a subroutine of see_commit_ref_changes called via htab_traverse.     SLOT contains the current use extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_emit_use_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|rtx
name|use_se
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|use_se
argument_list|)
condition|)
comment|/* This use extension was previously removed according to the lcm        output.  */
return|return
literal|1
return|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Inserting use extension:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|use_se
argument_list|)
expr_stmt|;
block|}
name|add_insn_before
argument_list|(
name|use_se
argument_list|,
name|curr_ref_s
operator|->
name|insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* For each relevant reference:    a. Emit the non-redundant use extensions.    b. Delete the def extensions.    c. Replace the original reference with the merged one (if exists) and add the       move instructions that were generated.     This is a subroutine of see_commit_changes called via splay_tree_foreach.     STN is the current node in the see_bb_splay_ar[i] splay tree.  It holds a    see_ref_s structure.  */
end_comment

begin_function
specifier|static
name|int
name|see_commit_ref_changes
parameter_list|(
name|splay_tree_node
name|stn
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|htab_t
name|use_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|use_se_hash
decl_stmt|;
name|htab_t
name|unmerged_def_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|unmerged_def_se_hash
decl_stmt|;
name|htab_t
name|merged_def_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|merged_def_se_hash
decl_stmt|;
name|rtx
name|ref
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|insn
decl_stmt|;
name|rtx
name|merged_ref
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|merged_insn
decl_stmt|;
comment|/* Emit the non-redundant use extensions.  */
if|if
condition|(
name|use_se_hash
condition|)
name|htab_traverse_noresize
argument_list|(
name|use_se_hash
argument_list|,
name|see_emit_use_extension
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete the def extensions.  */
if|if
condition|(
name|unmerged_def_se_hash
condition|)
name|htab_traverse
argument_list|(
name|unmerged_def_se_hash
argument_list|,
name|see_delete_unmerged_def_extension
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_def_se_hash
condition|)
name|htab_traverse
argument_list|(
name|merged_def_se_hash
argument_list|,
name|see_delete_merged_def_extension
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the original reference with the merged one (if exists) and add the      move instructions that were generated.  */
if|if
condition|(
name|merged_ref
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Replacing orig reference:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"With merged reference:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|merged_ref
argument_list|)
expr_stmt|;
block|}
name|emit_insn_after
argument_list|(
name|merged_ref
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
comment|/* Continue to the next reference.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Insert partially redundant expressions on edges to make the expressions fully    redundant.     INDEX_MAP is a mapping of an index to an expression.    Return true if an instruction was inserted on an edge.    Otherwise, return false.  */
end_comment

begin_function
specifier|static
name|bool
name|see_pre_insert_extensions
parameter_list|(
name|struct
name|see_pre_extension_expr
modifier|*
modifier|*
name|index_map
parameter_list|)
block|{
name|int
name|num_edges
init|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
decl_stmt|;
name|int
name|set_size
init|=
name|pre_insert_map
index|[
literal|0
index|]
operator|->
name|size
decl_stmt|;
name|size_t
name|pre_extension_num
init|=
name|htab_elements
argument_list|(
name|see_pre_extension_hash
argument_list|)
decl_stmt|;
name|int
name|did_insert
init|=
literal|0
decl_stmt|;
name|int
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|num_edges
condition|;
name|e
operator|++
control|)
block|{
name|int
name|indx
decl_stmt|;
name|basic_block
name|bb
init|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indx
operator|=
literal|0
init|;
name|i
operator|<
name|set_size
condition|;
name|i
operator|++
operator|,
name|indx
operator|+=
name|SBITMAP_ELT_BITS
control|)
block|{
name|SBITMAP_ELT_TYPE
name|insert
init|=
name|pre_insert_map
index|[
name|e
index|]
operator|->
name|elms
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
name|indx
init|;
name|insert
operator|&&
name|j
operator|<
operator|(
name|int
operator|)
name|pre_extension_num
condition|;
name|j
operator|++
operator|,
name|insert
operator|>>=
literal|1
control|)
if|if
condition|(
name|insert
operator|&
literal|1
condition|)
block|{
name|struct
name|see_pre_extension_expr
modifier|*
name|expr
init|=
name|index_map
index|[
name|j
index|]
decl_stmt|;
name|int
name|idx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
name|rtx
name|se_insn
init|=
name|NULL
decl_stmt|;
name|edge
name|eg
init|=
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|PATTERN
argument_list|(
name|expr
operator|->
name|se_insn
argument_list|)
argument_list|)
expr_stmt|;
name|se_insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|eg
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|rtx
name|new_insn
init|=
name|NULL
decl_stmt|;
name|new_insn
operator|=
name|insert_insn_end_bb_new
argument_list|(
name|se_insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_insn
operator|&&
name|INSN_P
argument_list|(
name|new_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"PRE: end of bb %d, insn %d, "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INSN_UID
argument_list|(
name|new_insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"inserting expression %d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|insert_insn_on_edge
argument_list|(
name|se_insn
argument_list|,
name|eg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"PRE: edge (%d,%d), "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"inserting expression %d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
name|did_insert
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|did_insert
return|;
block|}
end_function

begin_comment
comment|/* Since all the redundant extensions must be anticipatable, they must be a use    extensions.  Mark them as deleted.  This will prevent them from been emitted    in the first place.     This is a subroutine of see_commit_changes called via htab_traverse.     SLOT contains the current see_pre_extension_expr structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_pre_delete_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|see_pre_extension_expr
modifier|*
name|expr
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_occr
modifier|*
name|occr
decl_stmt|;
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_delete_map
index|[
name|occr
operator|->
name|block_num
index|]
argument_list|,
name|indx
argument_list|)
condition|)
block|{
comment|/* Mark as deleted.  */
name|INSN_DELETED_P
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Redundant extension deleted:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|occr
operator|->
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create the index_map mapping of an index to an expression.     This is a subroutine of see_commit_changes called via htab_traverse.     SLOT contains the current see_pre_extension_expr structure pointer.    B a pointer to see_pre_extension_expr structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_map_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|see_pre_extension_expr
modifier|*
name|expr
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_pre_extension_expr
modifier|*
modifier|*
name|index_map
init|=
operator|(
expr|struct
name|see_pre_extension_expr
operator|*
operator|*
operator|)
name|b
decl_stmt|;
name|index_map
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Phase 4 top level function.    In this phase we finally change the instruction stream.    Here we insert extensions at their best placements and delete the    redundant ones according to the output of the LCM.  We also replace    some of the instructions according to phase 2 merges results.  */
end_comment

begin_function
specifier|static
name|void
name|see_commit_changes
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|see_pre_extension_expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
name|size_t
name|pre_extension_num
init|=
name|htab_elements
argument_list|(
name|see_pre_extension_hash
argument_list|)
decl_stmt|;
name|bool
name|did_insert
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|index_map
operator|=
name|xcalloc
argument_list|(
name|pre_extension_num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|see_pre_extension_expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"* Phase 4: Commit changes to the insn stream.  *\n"
argument_list|)
expr_stmt|;
comment|/* Produce a mapping of all the pre_extensions.  */
name|htab_traverse
argument_list|(
name|see_pre_extension_hash
argument_list|,
name|see_map_extension
argument_list|,
operator|(
name|PTR
operator|)
name|index_map
argument_list|)
expr_stmt|;
comment|/* Delete redundant extension.  This will prevent them from been emitted in      the first place.  */
name|htab_traverse
argument_list|(
name|see_pre_extension_hash
argument_list|,
name|see_pre_delete_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* At this point, we must free the DF object, since the number of basic blocks      may change.  */
name|df_finish
argument_list|(
name|df
argument_list|)
expr_stmt|;
name|df
operator|=
name|NULL
expr_stmt|;
comment|/* Insert extensions on edges, according to the LCM result.  */
name|did_insert
operator|=
name|see_pre_insert_extensions
argument_list|(
name|index_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_insert
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
comment|/* Commit the rest of the changes.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|see_bb_splay_ar
index|[
name|i
index|]
condition|)
block|{
comment|/* Traverse over all the references in the basic block in forward 	     order.  */
name|splay_tree_foreach
argument_list|(
name|see_bb_splay_ar
index|[
name|i
index|]
argument_list|,
name|see_commit_ref_changes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|index_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Phase 3 implementation: Eliminate globally redundant extensions.  */
end_comment

begin_comment
comment|/* Analyze the properties of a merged def extension for the LCM and record avail    occurrences.     This is a subroutine of see_analyze_ref_local_prop called    via htab_traverse.     SLOT contains the current def extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_analyze_merged_def_local_prop
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|ref
init|=
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|struct
name|see_pre_extension_expr
modifier|*
name|extension_expr
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|int
name|bb_num
init|=
name|BLOCK_NUM
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|htab_t
name|curr_bb_hash
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
name|curr_prop
decl_stmt|,
modifier|*
modifier|*
name|slot_prop
decl_stmt|;
name|struct
name|see_register_properties
name|temp_prop
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|see_occr
modifier|*
name|curr_occr
init|=
name|NULL
decl_stmt|;
name|struct
name|see_occr
modifier|*
name|tmp_occr
init|=
name|NULL
decl_stmt|;
name|extension_expr
operator|=
name|see_seek_pre_extension_expr
argument_list|(
name|def_se
argument_list|,
name|DEF_EXTENSION
argument_list|)
expr_stmt|;
comment|/* The extension_expr must be found.  */
name|gcc_assert
argument_list|(
name|extension_expr
argument_list|)
expr_stmt|;
name|curr_bb_hash
operator|=
name|see_bb_hash_ar
index|[
name|bb_num
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_bb_hash
argument_list|)
expr_stmt|;
name|temp_prop
operator|.
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|slot_prop
operator|=
operator|(
expr|struct
name|see_register_properties
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|curr_bb_hash
argument_list|,
operator|&
name|temp_prop
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|curr_prop
operator|=
operator|*
name|slot_prop
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_prop
argument_list|)
expr_stmt|;
name|indx
operator|=
name|extension_expr
operator|->
name|bitmap_index
expr_stmt|;
comment|/* Reset the transparency bit.  */
name|RESET_BIT
argument_list|(
name|transp
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* Reset the killed bit.  */
name|RESET_BIT
argument_list|(
name|ae_kill
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_prop
operator|->
name|first_se_after_last_def
operator|==
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|ref
argument_list|)
condition|)
block|{
comment|/* Set the available bit.  */
name|SET_BIT
argument_list|(
name|comp
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* Record the available occurrence.  */
name|curr_occr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_occr
argument_list|)
argument_list|)
expr_stmt|;
name|curr_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr_occr
operator|->
name|insn
operator|=
name|def_se
expr_stmt|;
name|curr_occr
operator|->
name|block_num
operator|=
name|bb_num
expr_stmt|;
name|tmp_occr
operator|=
name|extension_expr
operator|->
name|avail_occr
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_occr
condition|)
name|extension_expr
operator|->
name|avail_occr
operator|=
name|curr_occr
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tmp_occr
operator|->
name|next
condition|)
name|tmp_occr
operator|=
name|tmp_occr
operator|->
name|next
expr_stmt|;
name|tmp_occr
operator|->
name|next
operator|=
name|curr_occr
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Analyze the properties of a unmerged def extension for the LCM.     This is a subroutine of see_analyze_ref_local_prop called    via htab_traverse.     SLOT contains the current def extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_analyze_unmerged_def_local_prop
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|ref
init|=
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|struct
name|see_pre_extension_expr
modifier|*
name|extension_expr
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|int
name|bb_num
init|=
name|BLOCK_NUM
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|htab_t
name|curr_bb_hash
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
name|curr_prop
decl_stmt|,
modifier|*
modifier|*
name|slot_prop
decl_stmt|;
name|struct
name|see_register_properties
name|temp_prop
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|extension_expr
operator|=
name|see_seek_pre_extension_expr
argument_list|(
name|def_se
argument_list|,
name|DEF_EXTENSION
argument_list|)
expr_stmt|;
comment|/* The extension_expr must be found.  */
name|gcc_assert
argument_list|(
name|extension_expr
argument_list|)
expr_stmt|;
name|curr_bb_hash
operator|=
name|see_bb_hash_ar
index|[
name|bb_num
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_bb_hash
argument_list|)
expr_stmt|;
name|temp_prop
operator|.
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|slot_prop
operator|=
operator|(
expr|struct
name|see_register_properties
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|curr_bb_hash
argument_list|,
operator|&
name|temp_prop
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|curr_prop
operator|=
operator|*
name|slot_prop
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_prop
argument_list|)
expr_stmt|;
name|indx
operator|=
name|extension_expr
operator|->
name|bitmap_index
expr_stmt|;
comment|/* Reset the transparency bit.  */
name|RESET_BIT
argument_list|(
name|transp
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* Set the killed bit.  */
name|SET_BIT
argument_list|(
name|ae_kill
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Analyze the properties of a use extension for the LCM and record anic and    avail occurrences.     This is a subroutine of see_analyze_ref_local_prop called    via htab_traverse.     SLOT contains the current use extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_analyze_use_local_prop
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|use_se
init|=
operator|*
name|slot
decl_stmt|;
name|rtx
name|ref
init|=
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|use_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|see_pre_extension_expr
modifier|*
name|extension_expr
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
name|curr_prop
decl_stmt|,
modifier|*
modifier|*
name|slot_prop
decl_stmt|;
name|struct
name|see_register_properties
name|temp_prop
decl_stmt|;
name|struct
name|see_occr
modifier|*
name|curr_occr
init|=
name|NULL
decl_stmt|;
name|struct
name|see_occr
modifier|*
name|tmp_occr
init|=
name|NULL
decl_stmt|;
name|htab_t
name|curr_bb_hash
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|int
name|bb_num
init|=
name|BLOCK_NUM
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|extension_expr
operator|=
name|see_seek_pre_extension_expr
argument_list|(
name|use_se
argument_list|,
name|USE_EXTENSION
argument_list|)
expr_stmt|;
comment|/* The extension_expr must be found.  */
name|gcc_assert
argument_list|(
name|extension_expr
argument_list|)
expr_stmt|;
name|curr_bb_hash
operator|=
name|see_bb_hash_ar
index|[
name|bb_num
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_bb_hash
argument_list|)
expr_stmt|;
name|temp_prop
operator|.
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|slot_prop
operator|=
operator|(
expr|struct
name|see_register_properties
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|curr_bb_hash
argument_list|,
operator|&
name|temp_prop
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|curr_prop
operator|=
operator|*
name|slot_prop
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_prop
argument_list|)
expr_stmt|;
name|indx
operator|=
name|extension_expr
operator|->
name|bitmap_index
expr_stmt|;
if|if
condition|(
name|curr_prop
operator|->
name|first_se_before_any_def
operator|==
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|ref
argument_list|)
condition|)
block|{
comment|/* Set the anticipatable bit.  */
name|SET_BIT
argument_list|(
name|antloc
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* Record the anticipatable occurrence.  */
name|curr_occr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_occr
argument_list|)
argument_list|)
expr_stmt|;
name|curr_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr_occr
operator|->
name|insn
operator|=
name|use_se
expr_stmt|;
name|curr_occr
operator|->
name|block_num
operator|=
name|bb_num
expr_stmt|;
name|tmp_occr
operator|=
name|extension_expr
operator|->
name|antic_occr
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_occr
condition|)
name|extension_expr
operator|->
name|antic_occr
operator|=
name|curr_occr
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tmp_occr
operator|->
name|next
condition|)
name|tmp_occr
operator|=
name|tmp_occr
operator|->
name|next
expr_stmt|;
name|tmp_occr
operator|->
name|next
operator|=
name|curr_occr
expr_stmt|;
block|}
if|if
condition|(
name|curr_prop
operator|->
name|last_def
operator|<
literal|0
condition|)
block|{
comment|/* Set the available bit.  */
name|SET_BIT
argument_list|(
name|comp
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* Record the available occurrence.  */
name|curr_occr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_occr
argument_list|)
argument_list|)
expr_stmt|;
name|curr_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr_occr
operator|->
name|insn
operator|=
name|use_se
expr_stmt|;
name|curr_occr
operator|->
name|block_num
operator|=
name|bb_num
expr_stmt|;
name|tmp_occr
operator|=
name|extension_expr
operator|->
name|avail_occr
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_occr
condition|)
name|extension_expr
operator|->
name|avail_occr
operator|=
name|curr_occr
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tmp_occr
operator|->
name|next
condition|)
name|tmp_occr
operator|=
name|tmp_occr
operator|->
name|next
expr_stmt|;
name|tmp_occr
operator|->
name|next
operator|=
name|curr_occr
expr_stmt|;
block|}
block|}
comment|/* Note: there is no need to reset the killed bit since it must be zero at 	 this point.  */
block|}
elseif|else
if|if
condition|(
name|curr_prop
operator|->
name|first_se_after_last_def
operator|==
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|ref
argument_list|)
condition|)
block|{
comment|/* Set the available bit.  */
name|SET_BIT
argument_list|(
name|comp
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* Reset the killed bit.  */
name|RESET_BIT
argument_list|(
name|ae_kill
index|[
name|bb_num
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* Record the available occurrence.  */
name|curr_occr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_occr
argument_list|)
argument_list|)
expr_stmt|;
name|curr_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr_occr
operator|->
name|insn
operator|=
name|use_se
expr_stmt|;
name|curr_occr
operator|->
name|block_num
operator|=
name|bb_num
expr_stmt|;
name|tmp_occr
operator|=
name|extension_expr
operator|->
name|avail_occr
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_occr
condition|)
name|extension_expr
operator|->
name|avail_occr
operator|=
name|curr_occr
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tmp_occr
operator|->
name|next
condition|)
name|tmp_occr
operator|=
name|tmp_occr
operator|->
name|next
expr_stmt|;
name|tmp_occr
operator|->
name|next
operator|=
name|curr_occr
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Here we traverse over all the merged and unmerged extensions of the reference    and analyze their properties for the LCM.     This is a subroutine of see_execute_LCM called via splay_tree_foreach.     STN is the current node in the see_bb_splay_ar[i] splay tree.  It holds a    see_ref_s structure.  */
end_comment

begin_function
specifier|static
name|int
name|see_analyze_ref_local_prop
parameter_list|(
name|splay_tree_node
name|stn
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|htab_t
name|use_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|use_se_hash
decl_stmt|;
name|htab_t
name|unmerged_def_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|unmerged_def_se_hash
decl_stmt|;
name|htab_t
name|merged_def_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|merged_def_se_hash
decl_stmt|;
comment|/* Analyze use extensions that were not merged with the reference.  */
if|if
condition|(
name|use_se_hash
condition|)
name|htab_traverse_noresize
argument_list|(
name|use_se_hash
argument_list|,
name|see_analyze_use_local_prop
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Analyze def extensions that were not merged with the reference.  */
if|if
condition|(
name|unmerged_def_se_hash
condition|)
name|htab_traverse
argument_list|(
name|unmerged_def_se_hash
argument_list|,
name|see_analyze_unmerged_def_local_prop
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Analyze def extensions that were merged with the reference.  */
if|if
condition|(
name|merged_def_se_hash
condition|)
name|htab_traverse
argument_list|(
name|merged_def_se_hash
argument_list|,
name|see_analyze_merged_def_local_prop
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Continue to the next definition.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Phase 3 top level function.    In this phase, we set the input bit vectors of the LCM according to data    gathered in phase 2.    Then we run the edge based LCM.  */
end_comment

begin_function
specifier|static
name|void
name|see_execute_LCM
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|pre_extension_num
init|=
name|htab_elements
argument_list|(
name|see_pre_extension_hash
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"* Phase 3: Eliminate globally redundant extensions.  *\n"
argument_list|)
expr_stmt|;
comment|/* Initialize the global sbitmap vectors.  */
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_bb
argument_list|,
name|pre_extension_num
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_bb
argument_list|,
name|pre_extension_num
argument_list|)
expr_stmt|;
name|antloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_bb
argument_list|,
name|pre_extension_num
argument_list|)
expr_stmt|;
name|ae_kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_bb
argument_list|,
name|pre_extension_num
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|transp
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|comp
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|antloc
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|last_bb
argument_list|)
expr_stmt|;
comment|/* Traverse over all the splay trees of the basic blocks.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|see_bb_splay_ar
index|[
name|i
index|]
condition|)
block|{
comment|/* Traverse over all the references in the basic block in forward 	     order.  */
name|splay_tree_foreach
argument_list|(
name|see_bb_splay_ar
index|[
name|i
index|]
argument_list|,
name|see_analyze_ref_local_prop
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add fake exit edges before running the lcm.  */
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
comment|/* Run the LCM.  */
name|edge_list
operator|=
name|pre_edge_lcm
argument_list|(
name|pre_extension_num
argument_list|,
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
name|ae_kill
argument_list|,
operator|&
name|pre_insert_map
argument_list|,
operator|&
name|pre_delete_map
argument_list|)
expr_stmt|;
comment|/* Remove the fake edges.  */
name|remove_fake_exit_edges
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Phase 2 implementation: Merge and eliminate locally redundant extensions.  */
end_comment

begin_comment
comment|/* In this function we set the register properties for the register that is    defined and extended in the reference.    The properties are defined in see_register_properties structure which is    allocated per basic block and per register.    Later the extension is inserted into the see_pre_extension_hash for the next    phase of the optimization.     This is a subroutine of see_handle_extensions_for_one_ref called    via htab_traverse.     SLOT contains the current def extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_set_prop_merged_def
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|htab_t
name|curr_bb_hash
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
name|curr_prop
init|=
name|NULL
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
modifier|*
name|slot_prop
decl_stmt|;
name|struct
name|see_register_properties
name|temp_prop
decl_stmt|;
name|int
name|ref_luid
init|=
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|curr_bb_hash
operator|=
name|see_bb_hash_ar
index|[
name|BLOCK_NUM
argument_list|(
name|curr_ref_s
operator|->
name|insn
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curr_bb_hash
condition|)
block|{
comment|/* The hash doesn't exist yet.  Create it.  */
name|curr_bb_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_properties
argument_list|,
name|eq_descriptor_properties
argument_list|,
name|hash_del_properties
argument_list|)
expr_stmt|;
name|see_bb_hash_ar
index|[
name|BLOCK_NUM
argument_list|(
name|curr_ref_s
operator|->
name|insn
argument_list|)
index|]
operator|=
name|curr_bb_hash
expr_stmt|;
block|}
comment|/* Find the right register properties in the right basic block.  */
name|temp_prop
operator|.
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|slot_prop
operator|=
operator|(
expr|struct
name|see_register_properties
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|curr_bb_hash
argument_list|,
operator|&
name|temp_prop
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot_prop
operator|&&
operator|*
name|slot_prop
operator|!=
name|NULL
condition|)
block|{
comment|/* Property already exists.  */
name|curr_prop
operator|=
operator|*
name|slot_prop
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_prop
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|last_def
operator|=
name|ref_luid
expr_stmt|;
name|curr_prop
operator|->
name|first_se_after_last_def
operator|=
name|ref_luid
expr_stmt|;
block|}
else|else
block|{
comment|/* Property doesn't exist yet.  */
name|curr_prop
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_register_properties
argument_list|)
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|last_def
operator|=
name|ref_luid
expr_stmt|;
name|curr_prop
operator|->
name|first_se_before_any_def
operator|=
operator|-
literal|1
expr_stmt|;
name|curr_prop
operator|->
name|first_se_after_last_def
operator|=
name|ref_luid
expr_stmt|;
operator|*
name|slot_prop
operator|=
name|curr_prop
expr_stmt|;
block|}
comment|/* Insert the def_se into see_pre_extension_hash if it isn't already      there.  */
name|see_seek_pre_extension_expr
argument_list|(
name|def_se
argument_list|,
name|DEF_EXTENSION
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* In this function we set the register properties for the register that is    defined but not extended in the reference.    The properties are defined in see_register_properties structure which is    allocated per basic block and per register.    Later the extension is inserted into the see_pre_extension_hash for the next    phase of the optimization.     This is a subroutine of see_handle_extensions_for_one_ref called    via htab_traverse.     SLOT contains the current def extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_set_prop_unmerged_def
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|htab_t
name|curr_bb_hash
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
name|curr_prop
init|=
name|NULL
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
modifier|*
name|slot_prop
decl_stmt|;
name|struct
name|see_register_properties
name|temp_prop
decl_stmt|;
name|int
name|ref_luid
init|=
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|curr_bb_hash
operator|=
name|see_bb_hash_ar
index|[
name|BLOCK_NUM
argument_list|(
name|curr_ref_s
operator|->
name|insn
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curr_bb_hash
condition|)
block|{
comment|/* The hash doesn't exist yet.  Create it.  */
name|curr_bb_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_properties
argument_list|,
name|eq_descriptor_properties
argument_list|,
name|hash_del_properties
argument_list|)
expr_stmt|;
name|see_bb_hash_ar
index|[
name|BLOCK_NUM
argument_list|(
name|curr_ref_s
operator|->
name|insn
argument_list|)
index|]
operator|=
name|curr_bb_hash
expr_stmt|;
block|}
comment|/* Find the right register properties in the right basic block.  */
name|temp_prop
operator|.
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|slot_prop
operator|=
operator|(
expr|struct
name|see_register_properties
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|curr_bb_hash
argument_list|,
operator|&
name|temp_prop
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot_prop
operator|&&
operator|*
name|slot_prop
operator|!=
name|NULL
condition|)
block|{
comment|/* Property already exists.  */
name|curr_prop
operator|=
operator|*
name|slot_prop
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_prop
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|last_def
operator|=
name|ref_luid
expr_stmt|;
name|curr_prop
operator|->
name|first_se_after_last_def
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Property doesn't exist yet.  */
name|curr_prop
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_register_properties
argument_list|)
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|last_def
operator|=
name|ref_luid
expr_stmt|;
name|curr_prop
operator|->
name|first_se_before_any_def
operator|=
operator|-
literal|1
expr_stmt|;
name|curr_prop
operator|->
name|first_se_after_last_def
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|slot_prop
operator|=
name|curr_prop
expr_stmt|;
block|}
comment|/* Insert the def_se into see_pre_extension_hash if it isn't already      there.  */
name|see_seek_pre_extension_expr
argument_list|(
name|def_se
argument_list|,
name|DEF_EXTENSION
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* In this function we set the register properties for the register that is used    in the reference.    The properties are defined in see_register_properties structure which is    allocated per basic block and per register.    When a redundant use extension is found it is removed from the hash of the    reference.    If the extension is non redundant it is inserted into the    see_pre_extension_hash for the next phase of the optimization.     This is a subroutine of see_handle_extensions_for_one_ref called    via htab_traverse.     SLOT contains the current use extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_set_prop_unmerged_use
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|rtx
name|use_se
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|insn
init|=
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|use_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|htab_t
name|curr_bb_hash
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
name|curr_prop
init|=
name|NULL
decl_stmt|;
name|struct
name|see_register_properties
modifier|*
modifier|*
name|slot_prop
decl_stmt|;
name|struct
name|see_register_properties
name|temp_prop
decl_stmt|;
name|bool
name|locally_redundant
init|=
name|false
decl_stmt|;
name|int
name|ref_luid
init|=
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|curr_bb_hash
operator|=
name|see_bb_hash_ar
index|[
name|BLOCK_NUM
argument_list|(
name|curr_ref_s
operator|->
name|insn
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curr_bb_hash
condition|)
block|{
comment|/* The hash doesn't exist yet.  Create it.  */
name|curr_bb_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_properties
argument_list|,
name|eq_descriptor_properties
argument_list|,
name|hash_del_properties
argument_list|)
expr_stmt|;
name|see_bb_hash_ar
index|[
name|BLOCK_NUM
argument_list|(
name|curr_ref_s
operator|->
name|insn
argument_list|)
index|]
operator|=
name|curr_bb_hash
expr_stmt|;
block|}
comment|/* Find the right register properties in the right basic block.  */
name|temp_prop
operator|.
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|slot_prop
operator|=
operator|(
expr|struct
name|see_register_properties
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|curr_bb_hash
argument_list|,
operator|&
name|temp_prop
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot_prop
operator|&&
operator|*
name|slot_prop
operator|!=
name|NULL
condition|)
block|{
comment|/* Property already exists.  */
name|curr_prop
operator|=
operator|*
name|slot_prop
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_prop
operator|->
name|regno
operator|==
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_prop
operator|->
name|last_def
operator|<
literal|0
operator|&&
name|curr_prop
operator|->
name|first_se_before_any_def
operator|<
literal|0
condition|)
name|curr_prop
operator|->
name|first_se_before_any_def
operator|=
name|ref_luid
expr_stmt|;
elseif|else
if|if
condition|(
name|curr_prop
operator|->
name|last_def
operator|<
literal|0
operator|&&
name|curr_prop
operator|->
name|first_se_before_any_def
operator|>=
literal|0
condition|)
block|{
comment|/* In this case the extension is locally redundant.  */
name|htab_clear_slot
argument_list|(
name|curr_ref_s
operator|->
name|use_se_hash
argument_list|,
operator|(
name|PTR
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
name|locally_redundant
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curr_prop
operator|->
name|last_def
operator|>=
literal|0
operator|&&
name|curr_prop
operator|->
name|first_se_after_last_def
operator|<
literal|0
condition|)
name|curr_prop
operator|->
name|first_se_after_last_def
operator|=
name|ref_luid
expr_stmt|;
elseif|else
if|if
condition|(
name|curr_prop
operator|->
name|last_def
operator|>=
literal|0
operator|&&
name|curr_prop
operator|->
name|first_se_after_last_def
operator|>=
literal|0
condition|)
block|{
comment|/* In this case the extension is locally redundant.  */
name|htab_clear_slot
argument_list|(
name|curr_ref_s
operator|->
name|use_se_hash
argument_list|,
operator|(
name|PTR
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
name|locally_redundant
operator|=
name|true
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Property doesn't exist yet.  Create a new one.  */
name|curr_prop
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_register_properties
argument_list|)
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|regno
operator|=
name|REGNO
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|curr_prop
operator|->
name|last_def
operator|=
operator|-
literal|1
expr_stmt|;
name|curr_prop
operator|->
name|first_se_before_any_def
operator|=
name|ref_luid
expr_stmt|;
name|curr_prop
operator|->
name|first_se_after_last_def
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|slot_prop
operator|=
name|curr_prop
expr_stmt|;
block|}
comment|/* Insert the use_se into see_pre_extension_hash if it isn't already      there.  */
if|if
condition|(
operator|!
name|locally_redundant
condition|)
name|see_seek_pre_extension_expr
argument_list|(
name|use_se
argument_list|,
name|USE_EXTENSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|locally_redundant
operator|&&
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Locally redundant extension:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|use_se
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Print an extension instruction.     This is a subroutine of see_handle_extensions_for_one_ref called    via htab_traverse.    SLOT contains the extension instruction.  */
end_comment

begin_function
specifier|static
name|int
name|see_print_one_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
name|gcc_assert
argument_list|(
name|def_se
operator|&&
name|INSN_P
argument_list|(
name|def_se
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Function called by note_uses to replace used subexpressions.     X is a pointer to the subexpression and DATA is a pointer to a    see_replace_data structure that contains the data for the replacement.  */
end_comment

begin_function
specifier|static
name|void
name|see_replace_src
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|see_replace_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|see_replace_data
operator|*
operator|)
name|data
decl_stmt|;
operator|*
name|x
operator|=
name|replace_rtx
argument_list|(
operator|*
name|x
argument_list|,
name|d
operator|->
name|from
argument_list|,
name|d
operator|->
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At this point the pattern is expected to be:     ref:	    set (dest_reg) (rhs)    def_se:  set (dest_extension_reg) (sign/zero_extend (source_extension_reg))     The merge of these two instructions didn't succeed.     We try to generate the pattern:    set (subreg (dest_extension_reg)) (rhs)     We do this in 4 steps:    a. Replace every use of dest_reg with a new pseudo register.    b. Replace every instance of dest_reg with the subreg.    c. Replace every use of the new pseudo register back to dest_reg.    d. Try to recognize and simplify.     If the manipulation failed, leave the original ref but try to generate and    recognize a simple move instruction:    set (subreg (dest_extension_reg)) (dest_reg)    This move instruction will be emitted right after the ref to the instruction    stream and assure the correctness of the code after def_se will be removed.     CURR_REF_S is the current reference.    DEF_SE is the extension that couldn't be merged.  */
end_comment

begin_function
specifier|static
name|void
name|see_def_extension_not_merged
parameter_list|(
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
parameter_list|,
name|rtx
name|def_se
parameter_list|)
block|{
name|struct
name|see_replace_data
name|d
decl_stmt|;
comment|/* If the original insn was already merged with an extension before,      take the merged one.  */
name|rtx
name|ref
init|=
operator|(
name|curr_ref_s
operator|->
name|merged_insn
operator|)
condition|?
name|curr_ref_s
operator|->
name|merged_insn
else|:
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|rtx
name|merged_ref_next
init|=
operator|(
name|curr_ref_s
operator|->
name|merged_insn
operator|)
condition|?
name|NEXT_INSN
argument_list|(
name|curr_ref_s
operator|->
name|merged_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|rtx
name|ref_copy
init|=
name|copy_rtx
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|source_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|move_insn
init|=
name|NULL
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|rhs
decl_stmt|;
name|rtx
name|dest_reg
decl_stmt|,
name|dest_real_reg
decl_stmt|;
name|rtx
name|new_pseudo_reg
decl_stmt|,
name|subreg
decl_stmt|;
name|enum
name|machine_mode
name|source_extension_mode
init|=
name|GET_MODE
argument_list|(
name|source_extension_reg
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|dest_mode
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|def_se
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|ZERO_EXTEND
argument_list|)
expr_stmt|;
name|dest_reg
operator|=
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|dest_reg
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|dest_reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest_reg
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dest_real_reg
operator|=
name|REG_P
argument_list|(
name|dest_reg
argument_list|)
condition|?
name|dest_reg
else|:
name|SUBREG_REG
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|dest_mode
operator|=
name|GET_MODE
argument_list|(
name|dest_reg
argument_list|)
expr_stmt|;
name|subreg
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|dest_mode
argument_list|,
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|new_pseudo_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|source_extension_mode
argument_list|)
expr_stmt|;
comment|/* Step a: Replace every use of dest_real_reg with a new pseudo register.  */
name|d
operator|.
name|from
operator|=
name|dest_real_reg
expr_stmt|;
name|d
operator|.
name|to
operator|=
name|new_pseudo_reg
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|ref_copy
argument_list|)
argument_list|,
name|see_replace_src
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
comment|/* Step b: Replace every instance of dest_reg with the subreg.  */
name|ref_copy
operator|=
name|replace_rtx
argument_list|(
name|ref_copy
argument_list|,
name|dest_reg
argument_list|,
name|subreg
argument_list|)
expr_stmt|;
comment|/* Step c: Replace every use of the new pseudo register back to      dest_real_reg.  */
name|d
operator|.
name|from
operator|=
name|new_pseudo_reg
expr_stmt|;
name|d
operator|.
name|to
operator|=
name|dest_real_reg
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|ref_copy
argument_list|)
argument_list|,
name|see_replace_src
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|ref
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|ref_copy
argument_list|)
argument_list|)
operator|||
name|insn_invalid_p
argument_list|(
name|ref_copy
argument_list|)
condition|)
block|{
comment|/* The manipulation failed.  */
comment|/* Create a new copy.  */
name|ref_copy
operator|=
name|copy_rtx
argument_list|(
name|ref
argument_list|)
expr_stmt|;
comment|/* Create a simple move instruction that will replace the def_se.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|subreg
argument_list|,
name|dest_reg
argument_list|)
expr_stmt|;
name|move_insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Link the manipulated instruction to the newly created move instruction 	 and to the former created move instructions.  */
name|PREV_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|move_insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|move_insn
argument_list|)
operator|=
name|ref_copy
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|move_insn
argument_list|)
operator|=
name|merged_ref_next
expr_stmt|;
if|if
condition|(
name|merged_ref_next
operator|!=
name|NULL_RTX
condition|)
name|PREV_INSN
argument_list|(
name|merged_ref_next
argument_list|)
operator|=
name|move_insn
expr_stmt|;
name|curr_ref_s
operator|->
name|merged_insn
operator|=
name|ref_copy
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Following def merge failure a move "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"insn was added after the ref.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original ref:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Move insn that was added:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|move_insn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* The manipulation succeeded.  Store the new manipulated reference.  */
comment|/* Try to simplify the new manipulated insn.  */
name|validate_simplify_insn
argument_list|(
name|ref_copy
argument_list|)
expr_stmt|;
comment|/* Create a simple move instruction to assure the correctness of the code.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest_reg
argument_list|,
name|subreg
argument_list|)
expr_stmt|;
name|move_insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Link the manipulated instruction to the newly created move instruction and      to the former created move instructions.  */
name|PREV_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|move_insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|move_insn
argument_list|)
operator|=
name|ref_copy
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|move_insn
argument_list|)
operator|=
name|merged_ref_next
expr_stmt|;
if|if
condition|(
name|merged_ref_next
operator|!=
name|NULL_RTX
condition|)
name|PREV_INSN
argument_list|(
name|merged_ref_next
argument_list|)
operator|=
name|move_insn
expr_stmt|;
name|curr_ref_s
operator|->
name|merged_insn
operator|=
name|ref_copy
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Following merge failure the ref was transformed!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original ref:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Transformed ref:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref_copy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Move insn that was added:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|move_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge the reference instruction (ref) with the current use extension.     use_se extends a NARROWmode register to a WIDEmode register.    ref uses the WIDEmode register.     The pattern we try to merge is this:    use_se: set (dest_extension_reg) (sign/zero_extend (source_extension_reg))    ref:	   use (dest_extension_reg)     where dest_extension_reg and source_extension_reg can be subregs.     The merge is done by generating, simplifying and recognizing the pattern:    use (sign/zero_extend (source_extension_reg))     If ref is too simple (according to see_want_to_be_merged_with_extension ())    we don't try to merge it with use_se and we continue as if the merge failed.     This is a subroutine of see_handle_extensions_for_one_ref called    via htab_traverse.    SLOT contains the current use extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_merge_one_use_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|use_se
init|=
operator|*
name|slot
decl_stmt|;
name|rtx
name|ref
init|=
operator|(
name|curr_ref_s
operator|->
name|merged_insn
operator|)
condition|?
name|curr_ref_s
operator|->
name|merged_insn
else|:
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|rtx
name|merged_ref_next
init|=
operator|(
name|curr_ref_s
operator|->
name|merged_insn
operator|)
condition|?
name|NEXT_INSN
argument_list|(
name|curr_ref_s
operator|->
name|merged_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|rtx
name|ref_copy
init|=
name|copy_rtx
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|extension_set
init|=
name|single_set
argument_list|(
name|use_se
argument_list|)
decl_stmt|;
name|rtx
name|extension_rhs
init|=
name|NULL
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|use_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|NULL
decl_stmt|;
name|rtx
name|simplified_note
init|=
name|NULL
decl_stmt|;
name|gcc_assert
argument_list|(
name|use_se
operator|&&
name|curr_ref_s
operator|&&
name|extension_set
argument_list|)
expr_stmt|;
name|extension_rhs
operator|=
name|SET_SRC
argument_list|(
name|extension_set
argument_list|)
expr_stmt|;
comment|/* In REG_EQUIV and REG_EQUAL notes that mention the register we need to      replace the uses of the dest_extension_reg with the rhs of the extension      instruction.  This is necessary since there might not be an extension in      the path between the definition and the note when this optimization is      over.  */
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|ref_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|simplified_note
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_extension_reg
argument_list|,
name|extension_rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|simplified_note
argument_list|)
condition|)
comment|/* Replacement failed.  Remove the note.  */
name|remove_note
argument_list|(
name|ref_copy
argument_list|,
name|note
argument_list|)
expr_stmt|;
else|else
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|simplified_note
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|see_want_to_be_merged_with_extension
argument_list|(
name|ref
argument_list|,
name|use_se
argument_list|,
name|USE_EXTENSION
argument_list|)
condition|)
block|{
comment|/* The use in the reference is too simple.  Don't try to merge.  */
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Use merge skipped!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original instructions:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|use_se
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
comment|/* Don't remove the current use_se from the use_se_hash and continue to 	 the next extension.  */
return|return
literal|1
return|;
block|}
name|validate_replace_src_group
argument_list|(
name|dest_extension_reg
argument_list|,
name|extension_rhs
argument_list|,
name|ref_copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_changes_pending
argument_list|()
condition|)
comment|/* In this case this is not a real use (the only use is/was in the notes        list).  Remove the use extension from the hash.  This will prevent it        from been emitted in the first place.  */
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Use extension not necessary before:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
name|htab_clear_slot
argument_list|(
name|curr_ref_s
operator|->
name|use_se_hash
argument_list|,
operator|(
name|PTR
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|merged_ref_next
expr_stmt|;
if|if
condition|(
name|merged_ref_next
operator|!=
name|NULL_RTX
condition|)
name|PREV_INSN
argument_list|(
name|merged_ref_next
argument_list|)
operator|=
name|ref_copy
expr_stmt|;
name|curr_ref_s
operator|->
name|merged_insn
operator|=
name|ref_copy
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
block|{
comment|/* The merge failed.  */
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Use merge failed!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original instructions:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|use_se
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
comment|/* Don't remove the current use_se from the use_se_hash and continue to 	 the next extension.  */
return|return
literal|1
return|;
block|}
comment|/* The merge succeeded!  */
comment|/* Try to simplify the new merged insn.  */
name|validate_simplify_insn
argument_list|(
name|ref_copy
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|merged_ref_next
expr_stmt|;
if|if
condition|(
name|merged_ref_next
operator|!=
name|NULL_RTX
condition|)
name|PREV_INSN
argument_list|(
name|merged_ref_next
argument_list|)
operator|=
name|ref_copy
expr_stmt|;
name|curr_ref_s
operator|->
name|merged_insn
operator|=
name|ref_copy
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Use merge succeeded!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original instructions:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|use_se
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Merged instruction:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref_copy
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the current use_se from the use_se_hash.  This will prevent it from      been emitted in the first place.  */
name|htab_clear_slot
argument_list|(
name|curr_ref_s
operator|->
name|use_se_hash
argument_list|,
operator|(
name|PTR
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Merge the reference instruction (ref) with the extension that follows it    in the same basic block (def_se).    ref sets a NARROWmode register and def_se extends it to WIDEmode register.     The pattern we try to merge is this:    ref:	   set (dest_reg) (rhs)    def_se: set (dest_extension_reg) (sign/zero_extend (source_extension_reg))     where dest_reg and source_extension_reg can both be subregs (together)    and (REGNO (dest_reg) == REGNO (source_extension_reg))     The merge is done by generating, simplifying and recognizing the pattern:    set (dest_extension_reg) (sign/zero_extend (rhs))    If ref is a parallel instruction we just replace the relevant set in it.     If ref is too simple (according to see_want_to_be_merged_with_extension ())    we don't try to merge it with def_se and we continue as if the merge failed.     This is a subroutine of see_handle_extensions_for_one_ref called    via htab_traverse.     SLOT contains the current def extension instruction.    B is the see_ref_s structure pointer.  */
end_comment

begin_function
specifier|static
name|int
name|see_merge_one_def_extension
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|see_ref_s
modifier|*
name|curr_ref_s
init|=
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
name|b
decl_stmt|;
name|rtx
name|def_se
init|=
operator|*
name|slot
decl_stmt|;
comment|/* If the original insn was already merged with an extension before,      take the merged one.  */
name|rtx
name|ref
init|=
operator|(
name|curr_ref_s
operator|->
name|merged_insn
operator|)
condition|?
name|curr_ref_s
operator|->
name|merged_insn
else|:
name|curr_ref_s
operator|->
name|insn
decl_stmt|;
name|rtx
name|merged_ref_next
init|=
operator|(
name|curr_ref_s
operator|->
name|merged_insn
operator|)
condition|?
name|NEXT_INSN
argument_list|(
name|curr_ref_s
operator|->
name|merged_insn
argument_list|)
else|:
name|NULL_RTX
decl_stmt|;
name|rtx
name|ref_copy
init|=
name|copy_rtx
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|rtx
name|new_set
init|=
name|NULL
decl_stmt|;
name|rtx
name|source_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|dest_extension_reg
init|=
name|see_get_extension_reg
argument_list|(
name|def_se
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|move_insn
decl_stmt|,
modifier|*
name|rtx_slot
decl_stmt|,
name|subreg
decl_stmt|;
name|rtx
name|temp_extension
init|=
name|NULL
decl_stmt|;
name|rtx
name|simplified_temp_extension
init|=
name|NULL
decl_stmt|;
name|rtx
modifier|*
name|pat
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|rtx_code
name|extension_code
decl_stmt|;
name|enum
name|machine_mode
name|source_extension_mode
decl_stmt|;
name|enum
name|machine_mode
name|source_mode
decl_stmt|;
name|enum
name|machine_mode
name|dest_extension_mode
decl_stmt|;
name|bool
name|merge_success
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|def_se
operator|&&
name|INSN_P
argument_list|(
name|def_se
argument_list|)
operator|&&
name|curr_ref_s
operator|&&
name|ref
operator|&&
name|INSN_P
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|see_want_to_be_merged_with_extension
argument_list|(
name|ref
argument_list|,
name|def_se
argument_list|,
name|DEF_EXTENSION
argument_list|)
condition|)
block|{
comment|/* The definition in the reference is too simple.  Don't try to merge.  */
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Def merge skipped!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original instructions:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
block|}
name|see_def_extension_not_merged
argument_list|(
name|curr_ref_s
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
comment|/* Continue to the next extension.  */
return|return
literal|1
return|;
block|}
name|extension_code
operator|=
name|see_get_extension_data
argument_list|(
name|def_se
argument_list|,
operator|&
name|source_mode
argument_list|)
expr_stmt|;
comment|/* Try to merge and simplify the extension.  */
name|source_extension_mode
operator|=
name|GET_MODE
argument_list|(
name|source_extension_reg
argument_list|)
expr_stmt|;
name|dest_extension_mode
operator|=
name|GET_MODE
argument_list|(
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|pat
operator|=
operator|&
name|PATTERN
argument_list|(
name|ref_copy
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
operator|*
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|bool
name|need_to_apply_change
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
operator|*
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
modifier|*
name|sub
init|=
operator|&
name|XVECEXP
argument_list|(
operator|*
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|sub
argument_list|)
operator|==
name|SET
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
operator|*
name|sub
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|sub
argument_list|)
argument_list|)
operator|==
name|source_mode
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|sub
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|sub
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|source_extension_reg
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|sub
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|sub
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|sub
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|source_extension_reg
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|orig_src
init|=
name|SET_SRC
argument_list|(
operator|*
name|sub
argument_list|)
decl_stmt|;
if|if
condition|(
name|extension_code
operator|==
name|SIGN_EXTEND
condition|)
name|temp_extension
operator|=
name|gen_rtx_SIGN_EXTEND
argument_list|(
name|dest_extension_mode
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
else|else
name|temp_extension
operator|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|dest_extension_mode
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
name|simplified_temp_extension
operator|=
name|simplify_rtx
argument_list|(
name|temp_extension
argument_list|)
expr_stmt|;
name|temp_extension
operator|=
operator|(
name|simplified_temp_extension
operator|)
condition|?
name|simplified_temp_extension
else|:
name|temp_extension
expr_stmt|;
name|new_set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest_extension_reg
argument_list|,
name|temp_extension
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|ref_copy
argument_list|,
name|sub
argument_list|,
name|new_set
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|need_to_apply_change
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_to_apply_change
condition|)
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
name|merge_success
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SET
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
operator|==
name|source_mode
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|source_extension_reg
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|source_extension_reg
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|orig_src
init|=
name|SET_SRC
argument_list|(
operator|*
name|pat
argument_list|)
decl_stmt|;
if|if
condition|(
name|extension_code
operator|==
name|SIGN_EXTEND
condition|)
name|temp_extension
operator|=
name|gen_rtx_SIGN_EXTEND
argument_list|(
name|dest_extension_mode
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
else|else
name|temp_extension
operator|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|dest_extension_mode
argument_list|,
name|orig_src
argument_list|)
expr_stmt|;
name|simplified_temp_extension
operator|=
name|simplify_rtx
argument_list|(
name|temp_extension
argument_list|)
expr_stmt|;
name|temp_extension
operator|=
operator|(
name|simplified_temp_extension
operator|)
condition|?
name|simplified_temp_extension
else|:
name|temp_extension
expr_stmt|;
name|new_set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest_extension_reg
argument_list|,
name|temp_extension
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|ref_copy
argument_list|,
name|pat
argument_list|,
name|new_set
argument_list|,
literal|0
argument_list|)
condition|)
name|merge_success
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|merge_success
condition|)
block|{
comment|/* The merge failed.  */
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Def merge failed!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original instructions:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
block|}
name|see_def_extension_not_merged
argument_list|(
name|curr_ref_s
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
comment|/* Continue to the next extension.  */
return|return
literal|1
return|;
block|}
comment|/* The merge succeeded!  */
comment|/* Create a simple move instruction to assure the correctness of the code.  */
name|subreg
operator|=
name|gen_lowpart_SUBREG
argument_list|(
name|source_extension_mode
argument_list|,
name|dest_extension_reg
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|source_extension_reg
argument_list|,
name|subreg
argument_list|)
expr_stmt|;
name|move_insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Link the merged instruction to the newly created move instruction and      to the former created move instructions.  */
name|PREV_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|ref_copy
argument_list|)
operator|=
name|move_insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|move_insn
argument_list|)
operator|=
name|ref_copy
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|move_insn
argument_list|)
operator|=
name|merged_ref_next
expr_stmt|;
if|if
condition|(
name|merged_ref_next
operator|!=
name|NULL_RTX
condition|)
name|PREV_INSN
argument_list|(
name|merged_ref_next
argument_list|)
operator|=
name|move_insn
expr_stmt|;
name|curr_ref_s
operator|->
name|merged_insn
operator|=
name|ref_copy
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Def merge succeeded!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Original instructions:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|def_se
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Merged instruction:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref_copy
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Move instruction that was added:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|move_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the current def_se from the unmerged_def_se_hash and insert it to      the merged_def_se_hash.  */
name|htab_clear_slot
argument_list|(
name|curr_ref_s
operator|->
name|unmerged_def_se_hash
argument_list|,
operator|(
name|PTR
operator|*
operator|)
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curr_ref_s
operator|->
name|merged_def_se_hash
condition|)
name|curr_ref_s
operator|->
name|merged_def_se_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_extension
argument_list|,
name|eq_descriptor_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rtx_slot
operator|=
operator|(
name|rtx
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|curr_ref_s
operator|->
name|merged_def_se_hash
argument_list|,
name|dest_extension_reg
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|rtx_slot
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|rtx_slot
operator|=
name|def_se
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Try to eliminate extensions in this order:    a. Try to merge only the def extensions, one by one.    b. Try to merge only the use extensions, one by one.     TODO:    Try to merge any couple of use extensions simultaneously.    Try to merge any def extension with one or two uses extensions    simultaneously.     After all the merges are done, update the register properties for the basic    block and eliminate locally redundant use extensions.     This is a subroutine of see_merge_and_eliminate_extensions called    via splay_tree_foreach.    STN is the current node in the see_bb_splay_ar[i] splay tree.  It holds a    see_ref_s structure.  */
end_comment

begin_function
specifier|static
name|int
name|see_handle_extensions_for_one_ref
parameter_list|(
name|splay_tree_node
name|stn
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|htab_t
name|use_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|use_se_hash
decl_stmt|;
name|htab_t
name|unmerged_def_se_hash
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|unmerged_def_se_hash
decl_stmt|;
name|htab_t
name|merged_def_se_hash
decl_stmt|;
name|rtx
name|ref
init|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|insn
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Handling ref:\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|dump_file
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
comment|/* a. Try to eliminate only def extensions, one by one.  */
if|if
condition|(
name|unmerged_def_se_hash
condition|)
name|htab_traverse_noresize
argument_list|(
name|unmerged_def_se_hash
argument_list|,
name|see_merge_one_def_extension
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_se_hash
condition|)
comment|/* b. Try to eliminate only use extensions, one by one.  */
name|htab_traverse_noresize
argument_list|(
name|use_se_hash
argument_list|,
name|see_merge_one_use_extension
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|merged_def_se_hash
operator|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|merged_def_se_hash
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"The hashes of the current reference:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmerged_def_se_hash
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"unmerged_def_se_hash:\n"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|unmerged_def_se_hash
argument_list|,
name|see_print_one_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merged_def_se_hash
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"merged_def_se_hash:\n"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|merged_def_se_hash
argument_list|,
name|see_print_one_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_se_hash
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"use_se_hash:\n"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|use_se_hash
argument_list|,
name|see_print_one_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now that all the merges are done, update the register properties of the      basic block and eliminate locally redundant extensions.      It is important that we first traverse the use extensions hash and      afterwards the def extensions hashes.  */
if|if
condition|(
name|use_se_hash
condition|)
name|htab_traverse_noresize
argument_list|(
name|use_se_hash
argument_list|,
name|see_set_prop_unmerged_use
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmerged_def_se_hash
condition|)
name|htab_traverse
argument_list|(
name|unmerged_def_se_hash
argument_list|,
name|see_set_prop_unmerged_def
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_def_se_hash
condition|)
name|htab_traverse
argument_list|(
name|merged_def_se_hash
argument_list|,
name|see_set_prop_merged_def
argument_list|,
call|(
name|PTR
call|)
argument_list|(
name|stn
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Continue to the next definition.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Phase 2 top level function.    In this phase, we try to merge def extensions and use extensions with their    references, and eliminate redundant extensions in the same basic block.      We also gather information for the next phases.  */
end_comment

begin_function
specifier|static
name|void
name|see_merge_and_eliminate_extensions
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"* Phase 2: Merge and eliminate locally redundant extensions.  *\n"
argument_list|)
expr_stmt|;
comment|/* Traverse over all the splay trees of the basic blocks.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|see_bb_splay_ar
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Handling references for bb %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Traverse over all the references in the basic block in forward 	     order.  */
name|splay_tree_foreach
argument_list|(
name|see_bb_splay_ar
index|[
name|i
index|]
argument_list|,
name|see_handle_extensions_for_one_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Phase 1 implementation: Propagate extensions to uses.  */
end_comment

begin_comment
comment|/* Insert REF_INSN into the splay tree of its basic block.    SE_INSN is the extension to store in the proper hash according to TYPE.     Return true if everything went well.    Otherwise, return false (this will cause the optimization to be aborted).  */
end_comment

begin_function
specifier|static
name|bool
name|see_store_reference_and_extension
parameter_list|(
name|rtx
name|ref_insn
parameter_list|,
name|rtx
name|se_insn
parameter_list|,
name|enum
name|extension_type
name|type
parameter_list|)
block|{
name|rtx
modifier|*
name|rtx_slot
decl_stmt|;
name|int
name|curr_bb_num
decl_stmt|;
name|splay_tree_node
name|stn
init|=
name|NULL
decl_stmt|;
name|htab_t
name|se_hash
init|=
name|NULL
decl_stmt|;
name|struct
name|see_ref_s
modifier|*
name|ref_s
init|=
name|NULL
decl_stmt|;
comment|/* Check the arguments.  */
name|gcc_assert
argument_list|(
name|ref_insn
operator|&&
name|se_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|see_bb_splay_ar
condition|)
return|return
name|false
return|;
name|curr_bb_num
operator|=
name|BLOCK_NUM
argument_list|(
name|ref_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|curr_bb_num
operator|<
name|last_bb
operator|&&
name|curr_bb_num
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* Insert the reference to the splay tree of its basic block.  */
if|if
condition|(
operator|!
name|see_bb_splay_ar
index|[
name|curr_bb_num
index|]
condition|)
comment|/* The splay tree for this block doesn't exist yet, create it.  */
name|see_bb_splay_ar
index|[
name|curr_bb_num
index|]
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
name|NULL
argument_list|,
name|see_free_ref_s
argument_list|)
expr_stmt|;
else|else
comment|/* Splay tree already exists, check if the current reference is already        in it.  */
block|{
name|stn
operator|=
name|splay_tree_lookup
argument_list|(
name|see_bb_splay_ar
index|[
name|curr_bb_num
index|]
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|ref_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stn
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EXPLICIT_DEF_EXTENSION
case|:
name|se_hash
operator|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|unmerged_def_se_hash
expr_stmt|;
if|if
condition|(
operator|!
name|se_hash
condition|)
block|{
name|se_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_extension
argument_list|,
name|eq_descriptor_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|unmerged_def_se_hash
operator|=
name|se_hash
expr_stmt|;
block|}
break|break;
case|case
name|IMPLICIT_DEF_EXTENSION
case|:
name|se_hash
operator|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|merged_def_se_hash
expr_stmt|;
if|if
condition|(
operator|!
name|se_hash
condition|)
block|{
name|se_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_extension
argument_list|,
name|eq_descriptor_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|merged_def_se_hash
operator|=
name|se_hash
expr_stmt|;
block|}
break|break;
case|case
name|USE_EXTENSION
case|:
name|se_hash
operator|=
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|use_se_hash
expr_stmt|;
if|if
condition|(
operator|!
name|se_hash
condition|)
block|{
name|se_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_extension
argument_list|,
name|eq_descriptor_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|see_ref_s
operator|*
operator|)
operator|(
name|stn
operator|->
name|value
operator|)
operator|)
operator|->
name|use_se_hash
operator|=
name|se_hash
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Initialize a new see_ref_s structure and insert it to the splay      tree.  */
if|if
condition|(
operator|!
name|stn
condition|)
block|{
name|ref_s
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_ref_s
argument_list|)
argument_list|)
expr_stmt|;
name|ref_s
operator|->
name|luid
operator|=
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|ref_insn
argument_list|)
expr_stmt|;
name|ref_s
operator|->
name|insn
operator|=
name|ref_insn
expr_stmt|;
name|ref_s
operator|->
name|merged_insn
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize the hashes.  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|EXPLICIT_DEF_EXTENSION
case|:
name|ref_s
operator|->
name|unmerged_def_se_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_extension
argument_list|,
name|eq_descriptor_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|se_hash
operator|=
name|ref_s
operator|->
name|unmerged_def_se_hash
expr_stmt|;
name|ref_s
operator|->
name|merged_def_se_hash
operator|=
name|NULL
expr_stmt|;
name|ref_s
operator|->
name|use_se_hash
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IMPLICIT_DEF_EXTENSION
case|:
name|ref_s
operator|->
name|merged_def_se_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_extension
argument_list|,
name|eq_descriptor_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|se_hash
operator|=
name|ref_s
operator|->
name|merged_def_se_hash
expr_stmt|;
name|ref_s
operator|->
name|unmerged_def_se_hash
operator|=
name|NULL
expr_stmt|;
name|ref_s
operator|->
name|use_se_hash
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|USE_EXTENSION
case|:
name|ref_s
operator|->
name|use_se_hash
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_descriptor_extension
argument_list|,
name|eq_descriptor_extension
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|se_hash
operator|=
name|ref_s
operator|->
name|use_se_hash
expr_stmt|;
name|ref_s
operator|->
name|unmerged_def_se_hash
operator|=
name|NULL
expr_stmt|;
name|ref_s
operator|->
name|merged_def_se_hash
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Insert the new extension instruction into the correct se_hash of the      current reference.  */
name|rtx_slot
operator|=
operator|(
name|rtx
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|se_hash
argument_list|,
name|se_insn
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rtx_slot
operator|!=
name|NULL
condition|)
block|{
name|gcc_assert
argument_list|(
name|type
operator|==
name|USE_EXTENSION
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
operator|*
name|rtx_slot
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|se_insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|rtx_slot
operator|=
name|se_insn
expr_stmt|;
comment|/* If this is a new reference, insert it into the splay_tree.  */
if|if
condition|(
operator|!
name|stn
condition|)
name|splay_tree_insert
argument_list|(
name|see_bb_splay_ar
index|[
name|curr_bb_num
index|]
argument_list|,
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|ref_insn
argument_list|)
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|ref_s
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Go over all the defs, for each relevant definition (defined below) store its    instruction as a reference.     A definition is relevant if its root has    ((entry_type == SIGN_EXTENDED_DEF) || (entry_type == ZERO_EXTENDED_DEF)) and    his source_mode is not narrower then the the roots source_mode.     Return the number of relevant defs or negative number if something bad had    happened and the optimization should be aborted.  */
end_comment

begin_function
specifier|static
name|int
name|see_handle_relevant_defs
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|NULL
decl_stmt|;
name|rtx
name|se_insn
init|=
name|NULL
decl_stmt|;
name|rtx
name|reg
init|=
name|NULL
decl_stmt|;
name|rtx
name|ref_insn
init|=
name|NULL
decl_stmt|;
name|struct
name|web_entry
modifier|*
name|root_entry
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|num_relevant_defs
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|extension_code
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defs_num
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|DF_REF_INSN
argument_list|(
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DF_REF_REAL_REG
argument_list|(
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|root_entry
operator|=
name|unionfind_root
argument_list|(
operator|&
name|def_entry
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|relevancy
operator|!=
name|SIGN_EXTENDED_DEF
operator|&&
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|relevancy
operator|!=
name|ZERO_EXTENDED_DEF
condition|)
comment|/* The current web is not relevant.  Continue to the next def.  */
continue|continue;
if|if
condition|(
name|root_entry
operator|->
name|reg
condition|)
comment|/* It isn't possible to have two different register for the same 	   web.  */
name|gcc_assert
argument_list|(
name|rtx_equal_p
argument_list|(
name|root_entry
operator|->
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|root_entry
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
comment|/* The current definition is an EXTENDED_DEF or a definition that its 	 source_mode is narrower then its web's source_mode. 	 This means that we need to generate the implicit extension explicitly 	 and store it in the current reference's merged_def_se_hash.  */
if|if
condition|(
name|ENTRY_EI
argument_list|(
operator|&
name|def_entry
index|[
name|i
index|]
argument_list|)
operator|->
name|local_relevancy
operator|==
name|EXTENDED_DEF
operator|||
operator|(
name|ENTRY_EI
argument_list|(
operator|&
name|def_entry
index|[
name|i
index|]
argument_list|)
operator|->
name|local_source_mode
operator|<
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|source_mode
operator|)
condition|)
block|{
name|num_relevant_defs
operator|++
expr_stmt|;
if|if
condition|(
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|relevancy
operator|==
name|SIGN_EXTENDED_DEF
condition|)
name|extension_code
operator|=
name|SIGN_EXTEND
expr_stmt|;
else|else
name|extension_code
operator|=
name|ZERO_EXTEND
expr_stmt|;
name|se_insn
operator|=
name|see_gen_normalized_extension
argument_list|(
name|reg
argument_list|,
name|extension_code
argument_list|,
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|source_mode
argument_list|)
expr_stmt|;
comment|/* This is a dummy extension, mark it as deleted.  */
name|INSN_DELETED_P
argument_list|(
name|se_insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|see_store_reference_and_extension
argument_list|(
name|insn
argument_list|,
name|se_insn
argument_list|,
name|IMPLICIT_DEF_EXTENSION
argument_list|)
condition|)
comment|/* Something bad happened.  Abort the optimization.  */
return|return
operator|-
literal|1
return|;
continue|continue;
block|}
name|ref_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|BLOCK_NUM
argument_list|(
name|ref_insn
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|num_relevant_defs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|see_store_reference_and_extension
argument_list|(
name|ref_insn
argument_list|,
name|insn
argument_list|,
name|EXPLICIT_DEF_EXTENSION
argument_list|)
condition|)
comment|/* Something bad happened.  Abort the optimization.  */
return|return
operator|-
literal|1
return|;
block|}
return|return
name|num_relevant_defs
return|;
block|}
end_function

begin_comment
comment|/* Go over all the uses, for each use in relevant web store its instruction as    a reference and generate an extension before it.     Return the number of relevant uses or negative number if something bad had    happened and the optimization should be aborted.  */
end_comment

begin_function
specifier|static
name|int
name|see_handle_relevant_uses
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|NULL
decl_stmt|;
name|rtx
name|reg
init|=
name|NULL
decl_stmt|;
name|struct
name|web_entry
modifier|*
name|root_entry
init|=
name|NULL
decl_stmt|;
name|rtx
name|se_insn
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|num_relevant_uses
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|extension_code
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uses_num
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|DF_REF_INSN
argument_list|(
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DF_REF_REAL_REG
argument_list|(
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|root_entry
operator|=
name|unionfind_root
argument_list|(
operator|&
name|use_entry
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|relevancy
operator|!=
name|SIGN_EXTENDED_DEF
operator|&&
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|relevancy
operator|!=
name|ZERO_EXTENDED_DEF
condition|)
comment|/* The current web is not relevant.  Continue to the next use.  */
continue|continue;
if|if
condition|(
name|root_entry
operator|->
name|reg
condition|)
comment|/* It isn't possible to have two different register for the same 	   web.  */
name|gcc_assert
argument_list|(
name|rtx_equal_p
argument_list|(
name|root_entry
operator|->
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|root_entry
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
comment|/* Generate the use extension.  */
if|if
condition|(
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|relevancy
operator|==
name|SIGN_EXTENDED_DEF
condition|)
name|extension_code
operator|=
name|SIGN_EXTEND
expr_stmt|;
else|else
name|extension_code
operator|=
name|ZERO_EXTEND
expr_stmt|;
name|se_insn
operator|=
name|see_gen_normalized_extension
argument_list|(
name|reg
argument_list|,
name|extension_code
argument_list|,
name|ENTRY_EI
argument_list|(
name|root_entry
argument_list|)
operator|->
name|source_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|se_insn
condition|)
comment|/* This is very bad, abort the transformation.  */
return|return
operator|-
literal|1
return|;
name|num_relevant_uses
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|see_store_reference_and_extension
argument_list|(
name|insn
argument_list|,
name|se_insn
argument_list|,
name|USE_EXTENSION
argument_list|)
condition|)
comment|/* Something bad happened.  Abort the optimization.  */
return|return
operator|-
literal|1
return|;
block|}
return|return
name|num_relevant_uses
return|;
block|}
end_function

begin_comment
comment|/* Updates the relevancy of all the uses.    The information of the i'th use is stored in use_entry[i].    Currently all the uses are relevant for the optimization except for uses that    are in LIBCALL or RETVAL instructions.  */
end_comment

begin_function
specifier|static
name|void
name|see_update_uses_relevancy
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|NULL
decl_stmt|;
name|rtx
name|reg
init|=
name|NULL
decl_stmt|;
name|struct
name|see_entry_extra_info
modifier|*
name|curr_entry_extra_info
decl_stmt|;
name|enum
name|entry_type
name|et
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|df
operator|||
operator|!
name|use_entry
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uses_num
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|DF_REF_INSN
argument_list|(
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DF_REF_REAL_REG
argument_list|(
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|et
operator|=
name|RELEVANT_USE
expr_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|et
operator|=
name|NOT_RELEVANT
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|et
operator|=
name|NOT_RELEVANT
expr_stmt|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|et
operator|=
name|NOT_RELEVANT
expr_stmt|;
block|}
else|else
name|et
operator|=
name|NOT_RELEVANT
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"u%i insn %i reg %i "
argument_list|,
name|i
argument_list|,
operator|(
name|insn
condition|?
name|INSN_UID
argument_list|(
name|insn
argument_list|)
else|:
operator|-
literal|1
operator|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|==
name|NOT_RELEVANT
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"NOT RELEVANT \n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"RELEVANT USE \n"
argument_list|)
expr_stmt|;
block|}
name|curr_entry_extra_info
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_entry_extra_info
argument_list|)
argument_list|)
expr_stmt|;
name|curr_entry_extra_info
operator|->
name|relevancy
operator|=
name|et
expr_stmt|;
name|curr_entry_extra_info
operator|->
name|local_relevancy
operator|=
name|et
expr_stmt|;
name|use_entry
index|[
name|i
index|]
operator|.
name|extra_info
operator|=
name|curr_entry_extra_info
expr_stmt|;
name|use_entry
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|use_entry
index|[
name|i
index|]
operator|.
name|pred
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A definition in a candidate for this optimization only if its pattern is    recognized as relevant in this function.    INSN is the instruction to be recognized.  -  If this is the pattern of a common sign extension after definition:    PREV_INSN (INSN):	def (reg:NARROWmode r)    INSN:		set ((reg:WIDEmode r')    			     (sign_extend:WIDEmode (reg:NARROWmode r)))    return SIGN_EXTENDED_DEF and set SOURCE_MODE to NARROWmode.  -  If this is the pattern of a common zero extension after definition:    PREV_INSN (INSN):	def (reg:NARROWmode r)    INSN:		set ((reg:WIDEmode r')    			     (zero_extend:WIDEmode (reg:NARROWmode r)))    return ZERO_EXTENDED_DEF and set SOURCE_MODE to NARROWmode.  -  Otherwise,     For the pattern:    INSN:  set ((reg:WIDEmode r) (sign_extend:WIDEmode (...expr...)))    return EXTENDED_DEF and set SOURCE_MODE to the mode of expr.     For the pattern:    INSN:  set ((reg:WIDEmode r) (zero_extend:WIDEmode (...expr...)))    return EXTENDED_DEF and set SOURCE_MODE_UNSIGNED to the mode of expr.     For the pattern:    INSN:  set ((reg:WIDEmode r) (CONST_INT (...)))    return EXTENDED_DEF and set SOURCE_MODE(_UNSIGNED) to the narrowest mode that    is implicitly sign(zero) extended to WIDEmode in the INSN.  -  FIXME: Extensions that are not adjacent to their definition and EXTENDED_DEF    that is part of a PARALLEL instruction are not handled.    These restriction can be relaxed.  */
end_comment

begin_function
specifier|static
name|enum
name|entry_type
name|see_analyze_one_def
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|source_mode
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|source_mode_unsigned
parameter_list|)
block|{
name|enum
name|rtx_code
name|extension_code
decl_stmt|;
name|rtx
name|rhs
init|=
name|NULL
decl_stmt|;
name|rtx
name|lhs
init|=
name|NULL
decl_stmt|;
name|rtx
name|set
init|=
name|NULL
decl_stmt|;
name|rtx
name|source_register
init|=
name|NULL
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|NULL
decl_stmt|;
name|rtx
name|next_insn
init|=
name|NULL
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|next_source_mode
decl_stmt|;
name|HOST_WIDE_INT
name|val
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|val2
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|*
name|source_mode
operator|=
name|MAX_MACHINE_MODE
expr_stmt|;
operator|*
name|source_mode_unsigned
operator|=
name|MAX_MACHINE_MODE
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|NOT_RELEVANT
return|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NOT_RELEVANT
return|;
name|extension_code
operator|=
name|see_get_extension_data
argument_list|(
name|insn
argument_list|,
name|source_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|extension_code
condition|)
block|{
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|source_register
operator|=
name|see_get_extension_reg
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: This restriction can be relaxed.  The only thing that is 	 important is that the reference would be inside the same basic block 	 as the extension.  */
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_insn
operator|||
operator|!
name|INSN_P
argument_list|(
name|prev_insn
argument_list|)
condition|)
return|return
name|NOT_RELEVANT
return|;
if|if
condition|(
operator|!
name|reg_set_between_p
argument_list|(
name|source_register
argument_list|,
name|PREV_INSN
argument_list|(
name|prev_insn
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|NOT_RELEVANT
return|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|prev_insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
name|NOT_RELEVANT
return|;
if|if
condition|(
name|find_reg_note
argument_list|(
name|prev_insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
name|NOT_RELEVANT
return|;
comment|/* If we can't use copy_rtx on the reference it can't be a reference.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|NOT_RELEVANT
return|;
comment|/* Now, check if this extension is a reference itself.  If so, it is not 	 relevant.  Handling this extension as relevant would make things much 	 more complicated.  */
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_insn
operator|&&
name|INSN_P
argument_list|(
name|next_insn
argument_list|)
operator|&&
operator|(
name|see_get_extension_data
argument_list|(
name|next_insn
argument_list|,
operator|&
name|next_source_mode
argument_list|)
operator|!=
name|NOT_RELEVANT
operator|)
condition|)
block|{
name|rtx
name|curr_dest_register
init|=
name|see_get_extension_reg
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|next_source_register
init|=
name|see_get_extension_reg
argument_list|(
name|next_insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|curr_dest_register
argument_list|)
operator|==
name|REGNO
argument_list|(
name|next_source_register
argument_list|)
condition|)
return|return
name|NOT_RELEVANT
return|;
block|}
if|if
condition|(
name|extension_code
operator|==
name|SIGN_EXTEND
condition|)
return|return
name|SIGN_EXTENDED_DEF
return|;
else|else
return|return
name|ZERO_EXTENDED_DEF
return|;
case|case
name|UNKNOWN
case|:
comment|/* This may still be an EXTENDED_DEF.  */
comment|/* FIXME: This restriction can be relaxed.  It is possible to handle 	 PARALLEL insns too.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|NOT_RELEVANT
return|;
name|rhs
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Don't handle extensions to something other then register or 	 subregister.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|lhs
argument_list|)
operator|&&
operator|!
name|SUBREG_REG
argument_list|(
name|lhs
argument_list|)
condition|)
return|return
name|NOT_RELEVANT
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|SIGN_EXTEND
case|:
operator|*
name|source_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|source_mode_unsigned
operator|=
name|MAX_MACHINE_MODE
expr_stmt|;
return|return
name|EXTENDED_DEF
return|;
case|case
name|ZERO_EXTEND
case|:
operator|*
name|source_mode
operator|=
name|MAX_MACHINE_MODE
expr_stmt|;
operator|*
name|source_mode_unsigned
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXTENDED_DEF
return|;
case|case
name|CONST_INT
case|:
name|val
operator|=
name|INTVAL
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
comment|/* Find the narrowest mode, val could fit into.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|val2
operator|=
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|val2
operator|==
name|val
operator|&&
operator|*
name|source_mode
operator|==
name|MAX_MACHINE_MODE
condition|)
operator|*
name|source_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|(
name|val
operator|&
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
operator|)
operator|&&
operator|*
name|source_mode_unsigned
operator|==
name|MAX_MACHINE_MODE
condition|)
operator|*
name|source_mode_unsigned
operator|=
name|mode
expr_stmt|;
if|if
condition|(
operator|*
name|source_mode
operator|!=
name|MAX_MACHINE_MODE
operator|&&
operator|*
name|source_mode_unsigned
operator|!=
name|MAX_MACHINE_MODE
condition|)
return|return
name|EXTENDED_DEF
return|;
block|}
if|if
condition|(
operator|*
name|source_mode
operator|!=
name|MAX_MACHINE_MODE
operator|||
operator|*
name|source_mode_unsigned
operator|!=
name|MAX_MACHINE_MODE
condition|)
return|return
name|EXTENDED_DEF
return|;
return|return
name|NOT_RELEVANT
return|;
default|default:
return|return
name|NOT_RELEVANT
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Updates the relevancy and source_mode of all the definitions.    The information of the i'th definition is stored in def_entry[i].  */
end_comment

begin_function
specifier|static
name|void
name|see_update_defs_relevancy
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|see_entry_extra_info
modifier|*
name|curr_entry_extra_info
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|rtx
name|insn
init|=
name|NULL
decl_stmt|;
name|rtx
name|reg
init|=
name|NULL
decl_stmt|;
name|enum
name|entry_type
name|et
decl_stmt|;
name|enum
name|machine_mode
name|source_mode
decl_stmt|;
name|enum
name|machine_mode
name|source_mode_unsigned
decl_stmt|;
if|if
condition|(
operator|!
name|df
operator|||
operator|!
name|def_entry
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defs_num
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|DF_REF_INSN
argument_list|(
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|DF_REF_REAL_REG
argument_list|(
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|et
operator|=
name|see_analyze_one_def
argument_list|(
name|insn
argument_list|,
operator|&
name|source_mode
argument_list|,
operator|&
name|source_mode_unsigned
argument_list|)
expr_stmt|;
name|curr_entry_extra_info
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|see_entry_extra_info
argument_list|)
argument_list|)
expr_stmt|;
name|curr_entry_extra_info
operator|->
name|relevancy
operator|=
name|et
expr_stmt|;
name|curr_entry_extra_info
operator|->
name|local_relevancy
operator|=
name|et
expr_stmt|;
if|if
condition|(
name|et
operator|!=
name|EXTENDED_DEF
condition|)
block|{
name|curr_entry_extra_info
operator|->
name|source_mode
operator|=
name|source_mode
expr_stmt|;
name|curr_entry_extra_info
operator|->
name|local_source_mode
operator|=
name|source_mode
expr_stmt|;
block|}
else|else
block|{
name|curr_entry_extra_info
operator|->
name|source_mode_signed
operator|=
name|source_mode
expr_stmt|;
name|curr_entry_extra_info
operator|->
name|source_mode_unsigned
operator|=
name|source_mode_unsigned
expr_stmt|;
block|}
name|def_entry
index|[
name|i
index|]
operator|.
name|extra_info
operator|=
name|curr_entry_extra_info
expr_stmt|;
name|def_entry
index|[
name|i
index|]
operator|.
name|reg
operator|=
name|NULL
expr_stmt|;
name|def_entry
index|[
name|i
index|]
operator|.
name|pred
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|et
operator|==
name|NOT_RELEVANT
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"d%i insn %i reg %i "
argument_list|,
name|i
argument_list|,
operator|(
name|insn
condition|?
name|INSN_UID
argument_list|(
name|insn
argument_list|)
else|:
operator|-
literal|1
operator|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"NOT RELEVANT \n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"d%i insn %i reg %i "
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"RELEVANT - "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|SIGN_EXTENDED_DEF
case|:
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"SIGN_EXTENDED_DEF, source_mode = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|source_mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTENDED_DEF
case|:
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"ZERO_EXTENDED_DEF, source_mode = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|source_mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXTENDED_DEF
case|:
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"EXTENDED_DEF, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_mode
operator|!=
name|MAX_MACHINE_MODE
operator|&&
name|source_mode_unsigned
operator|!=
name|MAX_MACHINE_MODE
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"positive const, "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"source_mode_signed = %s, "
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|source_mode
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"source_mode_unsigned = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|source_mode_unsigned
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source_mode
operator|!=
name|MAX_MACHINE_MODE
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"source_mode_signed = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|source_mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"source_mode_unsigned = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|source_mode_unsigned
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default :
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Phase 1 top level function.    In this phase the relevancy of all the definitions and uses are checked,    later the webs are produces and the extensions are generated.    These extensions are not emitted yet into the insns stream.     returns true if at list one relevant web was found and there were no    problems, otherwise return false.  */
end_comment

begin_function
specifier|static
name|bool
name|see_propagate_extensions_to_uses
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|num_relevant_uses
decl_stmt|;
name|int
name|num_relevant_defs
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"* Phase 1: Propagate extensions to uses.  *\n"
argument_list|)
expr_stmt|;
comment|/* Update the relevancy of references using the DF object.  */
name|see_update_defs_relevancy
argument_list|()
expr_stmt|;
name|see_update_uses_relevancy
argument_list|()
expr_stmt|;
comment|/* Produce the webs and update the extra_info of the root.      In general, a web is relevant if all its definitions and uses are relevant      and there is at least one definition that was marked as SIGN_EXTENDED_DEF      or ZERO_EXTENDED_DEF.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uses_num
condition|;
name|i
operator|++
control|)
name|union_defs
argument_list|(
name|df
argument_list|,
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
argument_list|,
name|def_entry
argument_list|,
name|use_entry
argument_list|,
name|see_update_leader_extra_info
argument_list|)
expr_stmt|;
comment|/* Generate use extensions for references and insert these      references to see_bb_splay_ar data structure.    */
name|num_relevant_uses
operator|=
name|see_handle_relevant_uses
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_relevant_uses
operator|<
literal|0
condition|)
return|return
name|false
return|;
comment|/* Store the def extensions in their references structures and insert these      references to see_bb_splay_ar data structure.    */
name|num_relevant_defs
operator|=
name|see_handle_relevant_defs
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_relevant_defs
operator|<
literal|0
condition|)
return|return
name|false
return|;
return|return
name|num_relevant_uses
operator|>
literal|0
operator|||
name|num_relevant_defs
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Main entry point for the sign extension elimination optimization.  */
end_comment

begin_function
specifier|static
name|void
name|see_main
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|cont
init|=
name|false
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Initialize global data structures.  */
name|see_initialize_data_structures
argument_list|()
expr_stmt|;
comment|/* Phase 1: Propagate extensions to uses.  */
name|cont
operator|=
name|see_propagate_extensions_to_uses
argument_list|()
expr_stmt|;
if|if
condition|(
name|cont
condition|)
block|{
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Phase 2: Merge and eliminate locally redundant extensions.  */
name|see_merge_and_eliminate_extensions
argument_list|()
expr_stmt|;
comment|/* Phase 3: Eliminate globally redundant extensions.  */
name|see_execute_LCM
argument_list|()
expr_stmt|;
comment|/* Phase 4: Commit changes to the insn stream.  */
name|see_commit_changes
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
comment|/* For debug purpose only.  */
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"see_pre_extension_hash:\n"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|see_pre_extension_hash
argument_list|,
name|see_print_pre_extension_expr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_bb
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|see_bb_hash_ar
index|[
name|i
index|]
condition|)
comment|/* Traverse over all the references in the basic block in 		   forward order.  */
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Searching register properties in bb %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|see_bb_hash_ar
index|[
name|i
index|]
argument_list|,
name|see_print_register_properties
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Free global data structures.  */
name|see_free_data_structures
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bool
name|gate_handle_see
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|optimize
operator|>
literal|1
operator|&&
name|flag_see
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_see
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|no_new_pseudos_bcp
init|=
name|no_new_pseudos
decl_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
name|see_main
argument_list|()
expr_stmt|;
name|no_new_pseudos
operator|=
name|no_new_pseudos_bcp
expr_stmt|;
name|delete_trivially_dead_insns
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|update_life_info_in_dirty_blocks
argument_list|(
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
operator|(
name|PROP_DEATH_NOTES
operator|)
argument_list|)
expr_stmt|;
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
name|reg_scan
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_see
init|=
block|{
literal|"see"
block|,
comment|/* name */
name|gate_handle_see
block|,
comment|/* gate */
name|rest_of_handle_see
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_SEE
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|'u'
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

