begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Calculate branch probabilities, and basic block execution counts.    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.    Contributed by James E. Wilson, UC Berkeley/Cygnus Support;    based on some ideas from Dain Samples of UC Berkeley.    Further mangling by Bob Manson, Cygnus Support.    Converted to use trees by Dale Johannesen, Apple Computer.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Generate basic block profile instrumentation and auxiliary files.    Tree-based version.  See profile.c for overview.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"value-prof.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|gcov_type_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|tree_interval_profiler_fn
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|tree_pow2_profiler_fn
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|tree_one_value_profiler_fn
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Do initialization work for the edge profiler.  */
end_comment

begin_function
specifier|static
name|void
name|tree_init_edge_profiler
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|interval_profiler_fn_type
decl_stmt|;
name|tree
name|pow2_profiler_fn_type
decl_stmt|;
name|tree
name|one_value_profiler_fn_type
decl_stmt|;
name|tree
name|gcov_type_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|gcov_type_node
condition|)
block|{
name|gcov_type_node
operator|=
name|get_gcov_type
argument_list|()
expr_stmt|;
name|gcov_type_ptr
operator|=
name|build_pointer_type
argument_list|(
name|gcov_type_node
argument_list|)
expr_stmt|;
comment|/* void (*) (gcov_type *, gcov_type, int, unsigned)  */
name|interval_profiler_fn_type
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|gcov_type_ptr
argument_list|,
name|gcov_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tree_interval_profiler_fn
operator|=
name|build_fn_decl
argument_list|(
literal|"__gcov_interval_profiler"
argument_list|,
name|interval_profiler_fn_type
argument_list|)
expr_stmt|;
comment|/* void (*) (gcov_type *, gcov_type)  */
name|pow2_profiler_fn_type
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|gcov_type_ptr
argument_list|,
name|gcov_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tree_pow2_profiler_fn
operator|=
name|build_fn_decl
argument_list|(
literal|"__gcov_pow2_profiler"
argument_list|,
name|pow2_profiler_fn_type
argument_list|)
expr_stmt|;
comment|/* void (*) (gcov_type *, gcov_type)  */
name|one_value_profiler_fn_type
operator|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|gcov_type_ptr
argument_list|,
name|gcov_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tree_one_value_profiler_fn
operator|=
name|build_fn_decl
argument_list|(
literal|"__gcov_one_value_profiler"
argument_list|,
name|one_value_profiler_fn_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output instructions as GIMPLE trees to increment the edge     execution count, and insert them on E.  We rely on     bsi_insert_on_edge to preserve the order.  */
end_comment

begin_function
specifier|static
name|void
name|tree_gen_edge_profiler
parameter_list|(
name|int
name|edgeno
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|tree
name|tmp1
init|=
name|create_tmp_var
argument_list|(
name|gcov_type_node
argument_list|,
literal|"PROF"
argument_list|)
decl_stmt|;
name|tree
name|tmp2
init|=
name|create_tmp_var
argument_list|(
name|gcov_type_node
argument_list|,
literal|"PROF"
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|tree_coverage_counter_ref
argument_list|(
name|GCOV_COUNTER_ARCS
argument_list|,
name|edgeno
argument_list|)
decl_stmt|;
name|tree
name|stmt1
init|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|gcov_type_node
argument_list|,
name|tmp1
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|tree
name|stmt2
init|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|gcov_type_node
argument_list|,
name|tmp2
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|gcov_type_node
argument_list|,
name|tmp1
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|stmt3
init|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|gcov_type_node
argument_list|,
name|ref
argument_list|,
name|tmp2
argument_list|)
decl_stmt|;
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|stmt1
argument_list|)
expr_stmt|;
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|stmt2
argument_list|)
expr_stmt|;
name|bsi_insert_on_edge
argument_list|(
name|e
argument_list|,
name|stmt3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emits code to get VALUE to instrument at BSI, and returns the    variable containing the value.  */
end_comment

begin_function
specifier|static
name|tree
name|prepare_instrumented_value
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|histogram_value
name|value
parameter_list|)
block|{
name|tree
name|val
init|=
name|value
operator|->
name|hvalue
operator|.
name|value
decl_stmt|;
return|return
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|fold_convert
argument_list|(
name|gcov_type_node
argument_list|,
name|val
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Output instructions as GIMPLE trees to increment the interval histogram     counter.  VALUE is the expression whose value is profiled.  TAG is the     tag of the section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|void
name|tree_gen_interval_profiler
parameter_list|(
name|histogram_value
name|value
parameter_list|,
name|unsigned
name|tag
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|value
operator|->
name|hvalue
operator|.
name|stmt
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|tree_coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
argument_list|)
decl_stmt|,
name|ref_ptr
decl_stmt|;
name|tree
name|args
decl_stmt|,
name|call
decl_stmt|,
name|val
decl_stmt|;
name|tree
name|start
init|=
name|build_int_cst_type
argument_list|(
name|integer_type_node
argument_list|,
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|int_start
argument_list|)
decl_stmt|;
name|tree
name|steps
init|=
name|build_int_cst_type
argument_list|(
name|unsigned_type_node
argument_list|,
name|value
operator|->
name|hdata
operator|.
name|intvl
operator|.
name|steps
argument_list|)
decl_stmt|;
name|ref_ptr
operator|=
name|force_gimple_operand_bsi
argument_list|(
operator|&
name|bsi
argument_list|,
name|build_addr
argument_list|(
name|ref
argument_list|,
name|current_function_decl
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|val
operator|=
name|prepare_instrumented_value
argument_list|(
operator|&
name|bsi
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ref_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|start
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|steps
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|tree_interval_profiler_fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|call
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output instructions as GIMPLE trees to increment the power of two histogram     counter.  VALUE is the expression whose value is profiled.  TAG is the tag     of the section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|void
name|tree_gen_pow2_profiler
parameter_list|(
name|histogram_value
name|value
parameter_list|,
name|unsigned
name|tag
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|value
operator|->
name|hvalue
operator|.
name|stmt
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|tree_coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
argument_list|)
decl_stmt|,
name|ref_ptr
decl_stmt|;
name|tree
name|args
decl_stmt|,
name|call
decl_stmt|,
name|val
decl_stmt|;
name|ref_ptr
operator|=
name|force_gimple_operand_bsi
argument_list|(
operator|&
name|bsi
argument_list|,
name|build_addr
argument_list|(
name|ref
argument_list|,
name|current_function_decl
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|val
operator|=
name|prepare_instrumented_value
argument_list|(
operator|&
name|bsi
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ref_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|tree_pow2_profiler_fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|call
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output instructions as GIMPLE trees for code to find the most common value.    VALUE is the expression whose value is profiled.  TAG is the tag of the    section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|void
name|tree_gen_one_value_profiler
parameter_list|(
name|histogram_value
name|value
parameter_list|,
name|unsigned
name|tag
parameter_list|,
name|unsigned
name|base
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|value
operator|->
name|hvalue
operator|.
name|stmt
decl_stmt|;
name|block_stmt_iterator
name|bsi
init|=
name|bsi_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|tree_coverage_counter_ref
argument_list|(
name|tag
argument_list|,
name|base
argument_list|)
decl_stmt|,
name|ref_ptr
decl_stmt|;
name|tree
name|args
decl_stmt|,
name|call
decl_stmt|,
name|val
decl_stmt|;
name|ref_ptr
operator|=
name|force_gimple_operand_bsi
argument_list|(
operator|&
name|bsi
argument_list|,
name|build_addr
argument_list|(
name|ref
argument_list|,
name|current_function_decl
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|val
operator|=
name|prepare_instrumented_value
argument_list|(
operator|&
name|bsi
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ref_ptr
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|val
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|call
operator|=
name|build_function_call_expr
argument_list|(
name|tree_one_value_profiler_fn
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|bsi
argument_list|,
name|call
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output instructions as GIMPLE trees for code to find the most common value     of a difference between two evaluations of an expression.    VALUE is the expression whose value is profiled.  TAG is the tag of the    section for counters, BASE is offset of the counter position.  */
end_comment

begin_function
specifier|static
name|void
name|tree_gen_const_delta_profiler
parameter_list|(
name|histogram_value
name|value
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|tag
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|base
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* FIXME implement this.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|internal_error
argument_list|(
literal|"unimplemented functionality"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if tree-based profiling is in effect, else 0.    If it is, set up hooks for tree-based profiling.    Gate for pass_tree_profile.  */
end_comment

begin_function
specifier|static
name|bool
name|do_tree_profiling
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|profile_arc_flag
operator|||
name|flag_test_coverage
operator|||
name|flag_branch_probabilities
condition|)
block|{
name|tree_register_profile_hooks
argument_list|()
expr_stmt|;
name|tree_register_value_prof_hooks
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|tree_profiling
parameter_list|(
name|void
parameter_list|)
block|{
name|branch_prob
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_branch_probabilities
operator|&&
name|flag_profile_values
operator|&&
name|flag_value_profile_transformations
condition|)
name|value_profile_transformations
argument_list|()
expr_stmt|;
comment|/* The above could hose dominator info.  Currently there is      none coming in, this is a safety valve.  It should be      easy to adjust it, if and when there is some.  */
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_tree_profile
init|=
block|{
literal|"tree_profile"
block|,
comment|/* name */
name|do_tree_profiling
block|,
comment|/* gate */
name|tree_profiling
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_BRANCH_PROB
block|,
comment|/* tv_id */
name|PROP_gimple_leh
operator||
name|PROP_cfg
block|,
comment|/* properties_required */
name|PROP_gimple_leh
operator||
name|PROP_cfg
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if tree-based profiling is in effect, else 0.    If it is, set up hooks for tree-based profiling.    Gate for pass_tree_profile.  */
end_comment

begin_function
specifier|static
name|bool
name|do_early_tree_profiling
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|do_tree_profiling
argument_list|()
operator|&&
operator|(
operator|!
name|flag_unit_at_a_time
operator|||
operator|!
name|optimize
operator|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_early_tree_profile
init|=
block|{
literal|"early_tree_profile"
block|,
comment|/* name */
name|do_early_tree_profiling
block|,
comment|/* gate */
name|tree_profiling
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_BRANCH_PROB
block|,
comment|/* tv_id */
name|PROP_gimple_leh
operator||
name|PROP_cfg
block|,
comment|/* properties_required */
name|PROP_gimple_leh
operator||
name|PROP_cfg
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_verify_stmts
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|profile_hooks
name|tree_profile_hooks
init|=
block|{
name|tree_init_edge_profiler
block|,
comment|/* init_edge_profiler */
name|tree_gen_edge_profiler
block|,
comment|/* gen_edge_profiler */
name|tree_gen_interval_profiler
block|,
comment|/* gen_interval_profiler */
name|tree_gen_pow2_profiler
block|,
comment|/* gen_pow2_profiler */
name|tree_gen_one_value_profiler
block|,
comment|/* gen_one_value_profiler */
name|tree_gen_const_delta_profiler
comment|/* gen_const_delta_profiler */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gt-tree-profile.h"
end_include

end_unit

