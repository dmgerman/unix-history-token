begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Utilities for ipa analysis.    Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Kenneth Zadeck<zadeck@naturalbridge.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"ipa-utils.h"
end_include

begin_include
include|#
directive|include
file|"ipa-reference.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Debugging function for postorder and inorder code. NOTE is a string    that is printed before the nodes are printed.  ORDER is an array of    cgraph_nodes that has COUNT useful nodes in it.  */
end_comment

begin_function
name|void
name|ipa_utils_print_order
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|char
modifier|*
name|note
parameter_list|,
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\n ordered call graph: %s\n"
argument_list|,
name|note
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|dump_cgraph_node
argument_list|(
name|dump_file
argument_list|,
name|order
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|searchc_env
block|{
name|struct
name|cgraph_node
modifier|*
modifier|*
name|stack
decl_stmt|;
name|int
name|stack_size
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|order_pos
decl_stmt|;
name|splay_tree
name|nodes_marked_new
decl_stmt|;
name|bool
name|reduce
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is an implementation of Tarjan's strongly connected region    finder as reprinted in Aho Hopcraft and Ullman's The Design and    Analysis of Computer Programs (1975) pages 192-193.  This version    has been customized for cgraph_nodes.  The env parameter is because    it is recursive and there are no nested functions here.  This    function should only be called from itself or    ipa_utils_reduced_inorder.  ENV is a stack env and would be    unnecessary if C had nested functions.  V is the node to start    searching from.  */
end_comment

begin_function
specifier|static
name|void
name|searchc
parameter_list|(
name|struct
name|searchc_env
modifier|*
name|env
parameter_list|,
name|struct
name|cgraph_node
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|cgraph_edge
modifier|*
name|edge
decl_stmt|;
name|struct
name|ipa_dfs_info
modifier|*
name|v_info
init|=
name|v
operator|->
name|aux
decl_stmt|;
comment|/* mark node as old */
name|v_info
operator|->
name|new
operator|=
name|false
expr_stmt|;
name|splay_tree_remove
argument_list|(
name|env
operator|->
name|nodes_marked_new
argument_list|,
name|v
operator|->
name|uid
argument_list|)
expr_stmt|;
name|v_info
operator|->
name|dfn_number
operator|=
name|env
operator|->
name|count
expr_stmt|;
name|v_info
operator|->
name|low_link
operator|=
name|env
operator|->
name|count
expr_stmt|;
name|env
operator|->
name|count
operator|++
expr_stmt|;
name|env
operator|->
name|stack
index|[
operator|(
name|env
operator|->
name|stack_size
operator|)
operator|++
index|]
operator|=
name|v
expr_stmt|;
name|v_info
operator|->
name|on_stack
operator|=
name|true
expr_stmt|;
for|for
control|(
name|edge
operator|=
name|v
operator|->
name|callees
init|;
name|edge
condition|;
name|edge
operator|=
name|edge
operator|->
name|next_callee
control|)
block|{
name|struct
name|ipa_dfs_info
modifier|*
name|w_info
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|w
init|=
name|edge
operator|->
name|callee
decl_stmt|;
comment|/* Bypass the clones and only look at the master node.  Skip 	 external and other bogus nodes.  */
name|w
operator|=
name|cgraph_master_clone
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|&&
name|w
operator|->
name|aux
condition|)
block|{
name|w_info
operator|=
name|w
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|w_info
operator|->
name|new
condition|)
block|{
name|searchc
argument_list|(
name|env
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|v_info
operator|->
name|low_link
operator|=
operator|(
name|v_info
operator|->
name|low_link
operator|<
name|w_info
operator|->
name|low_link
operator|)
condition|?
name|v_info
operator|->
name|low_link
else|:
name|w_info
operator|->
name|low_link
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|w_info
operator|->
name|dfn_number
operator|<
name|v_info
operator|->
name|dfn_number
operator|)
operator|&&
operator|(
name|w_info
operator|->
name|on_stack
operator|)
condition|)
name|v_info
operator|->
name|low_link
operator|=
operator|(
name|w_info
operator|->
name|dfn_number
operator|<
name|v_info
operator|->
name|low_link
operator|)
condition|?
name|w_info
operator|->
name|dfn_number
else|:
name|v_info
operator|->
name|low_link
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v_info
operator|->
name|low_link
operator|==
name|v_info
operator|->
name|dfn_number
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|x
decl_stmt|;
name|struct
name|ipa_dfs_info
modifier|*
name|x_info
decl_stmt|;
do|do
block|{
name|x
operator|=
name|env
operator|->
name|stack
index|[
operator|--
operator|(
name|env
operator|->
name|stack_size
operator|)
index|]
expr_stmt|;
name|x_info
operator|=
name|x
operator|->
name|aux
expr_stmt|;
name|x_info
operator|->
name|on_stack
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|env
operator|->
name|reduce
condition|)
block|{
name|x_info
operator|->
name|next_cycle
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|x
expr_stmt|;
block|}
else|else
name|env
operator|->
name|result
index|[
name|env
operator|->
name|order_pos
operator|++
index|]
operator|=
name|x
expr_stmt|;
block|}
do|while
condition|(
name|v
operator|!=
name|x
condition|)
do|;
if|if
condition|(
name|env
operator|->
name|reduce
condition|)
name|env
operator|->
name|result
index|[
name|env
operator|->
name|order_pos
operator|++
index|]
operator|=
name|v
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Topsort the call graph by caller relation.  Put the result in ORDER.     The REDUCE flag is true if you want the cycles reduced to single    nodes.  Only consider nodes that have the output bit set. */
end_comment

begin_function
name|int
name|ipa_utils_reduced_inorder
parameter_list|(
name|struct
name|cgraph_node
modifier|*
modifier|*
name|order
parameter_list|,
name|bool
name|reduce
parameter_list|,
name|bool
name|allow_overwritable
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|searchc_env
name|env
decl_stmt|;
name|splay_tree_node
name|result
decl_stmt|;
name|env
operator|.
name|stack
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|cgraph_node
operator|*
argument_list|,
name|cgraph_n_nodes
argument_list|)
expr_stmt|;
name|env
operator|.
name|stack_size
operator|=
literal|0
expr_stmt|;
name|env
operator|.
name|result
operator|=
name|order
expr_stmt|;
name|env
operator|.
name|order_pos
operator|=
literal|0
expr_stmt|;
name|env
operator|.
name|nodes_marked_new
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|env
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|env
operator|.
name|reduce
operator|=
name|reduce
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|node
operator|->
name|analyzed
operator|)
operator|&&
operator|(
name|cgraph_is_master_clone
argument_list|(
name|node
argument_list|)
operator|||
operator|(
name|allow_overwritable
operator|&&
operator|(
name|cgraph_function_body_availability
argument_list|(
name|node
argument_list|)
operator|==
name|AVAIL_OVERWRITABLE
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Reuse the info if it is already there.  */
name|struct
name|ipa_dfs_info
modifier|*
name|info
init|=
name|node
operator|->
name|aux
decl_stmt|;
if|if
condition|(
operator|!
name|info
condition|)
name|info
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipa_dfs_info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|new
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|on_stack
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|next_cycle
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|aux
operator|=
name|info
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|env
operator|.
name|nodes_marked_new
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|node
operator|->
name|uid
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|node
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|splay_tree_min
argument_list|(
name|env
operator|.
name|nodes_marked_new
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
name|node
operator|=
operator|(
expr|struct
name|cgraph_node
operator|*
operator|)
name|result
operator|->
name|value
expr_stmt|;
name|searchc
argument_list|(
operator|&
name|env
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|result
operator|=
name|splay_tree_min
argument_list|(
name|env
operator|.
name|nodes_marked_new
argument_list|)
expr_stmt|;
block|}
name|splay_tree_delete
argument_list|(
name|env
operator|.
name|nodes_marked_new
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|env
operator|.
name|stack
argument_list|)
expr_stmt|;
return|return
name|env
operator|.
name|order_pos
return|;
block|}
end_function

begin_comment
comment|/* Given a memory reference T, will return the variable at the bottom    of the access.  Unlike get_base_address, this will recurse thru    INDIRECT_REFS.  */
end_comment

begin_function
name|tree
name|get_base_var
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|EXC_PTR_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FILTER_EXPR
operator|)
condition|)
return|return
name|t
return|;
while|while
condition|(
operator|!
name|SSA_VAR_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|LABEL_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

end_unit

