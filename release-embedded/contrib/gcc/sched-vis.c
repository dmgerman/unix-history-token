begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction scheduling pass.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,    and currently maintained by, Jim Wilson (wilson@cygnus.com)  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|safe_concat
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_exp
parameter_list|(
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_value
parameter_list|(
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_pattern
parameter_list|(
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BUF_LEN
value|2048
end_define

begin_function
specifier|static
name|char
modifier|*
name|safe_concat
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|cur
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|buf
operator|+
name|BUF_LEN
operator|-
literal|2
decl_stmt|;
comment|/* Leave room for null.  */
name|int
name|c
decl_stmt|;
if|if
condition|(
name|cur
operator|>
name|end
condition|)
block|{
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
return|return
name|end
return|;
block|}
while|while
condition|(
name|cur
operator|<
name|end
operator|&&
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|cur
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|cur
operator|=
literal|'\0'
expr_stmt|;
return|return
name|cur
return|;
block|}
end_function

begin_comment
comment|/* This recognizes rtx, I classified as expressions.  These are always    represent some action on values or results of other expression, that    may be stored in objects representing values.  */
end_comment

begin_function
specifier|static
name|void
name|print_exp
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|tmp
index|[
name|BUF_LEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|st
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fun
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|rtx
name|op
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|st
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|op
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|"+"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LO_SUM
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"+low("
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|=
literal|")"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPARE
case|:
name|fun
operator|=
literal|"cmp"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"-"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"*"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"/"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fun
operator|=
literal|"udiv"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"%"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fun
operator|=
literal|"umod"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|fun
operator|=
literal|"smin"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|fun
operator|=
literal|"smax"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMIN
case|:
name|fun
operator|=
literal|"umin"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMAX
case|:
name|fun
operator|=
literal|"umax"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"!"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"&"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"|"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"^"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|" 0>>"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">>"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<-<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">->"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|fun
operator|=
literal|"abs"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQRT
case|:
name|fun
operator|=
literal|"sqrt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FFS
case|:
name|fun
operator|=
literal|"ffs"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"=="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"!="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fun
operator|=
literal|"gtu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fun
operator|=
literal|"ltu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|">="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fun
operator|=
literal|"geu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"<="
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fun
operator|=
literal|"leu"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTRACT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"sign_extract"
else|:
literal|"sxt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTRACT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"zero_extract"
else|:
literal|"zxt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGN_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"sign_extend"
else|:
literal|"sxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"zero_extend"
else|:
literal|"zxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXTEND
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float_extend"
else|:
literal|"fxn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNCATE
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"trunc"
else|:
literal|"trn"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_TRUNCATE
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float_trunc"
else|:
literal|"ftr"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"float"
else|:
literal|"flt"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FLOAT
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"uns_float"
else|:
literal|"ufl"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIX
case|:
name|fun
operator|=
literal|"fix"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED_FIX
case|:
name|fun
operator|=
operator|(
name|verbose
operator|)
condition|?
literal|"uns_fix"
else|:
literal|"ufx"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"--"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"++"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"--"
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|"++"
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"call "
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|st
index|[
literal|1
index|]
operator|=
literal|" argc:"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|st
index|[
literal|0
index|]
operator|=
literal|"{("
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
literal|")?"
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|=
literal|":"
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|st
index|[
literal|3
index|]
operator|=
literal|"}"
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|fun
operator|=
literal|"trap_if"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|TRAP_CONDITION
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREFETCH
case|:
name|fun
operator|=
literal|"prefetch"
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"unspec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC_VOLATILE
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"/v"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|tmp
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|","
expr_stmt|;
block|}
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* If (verbose) debug_rtx (x);  */
name|st
index|[
literal|0
index|]
operator|=
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Print this as a function?  */
if|if
condition|(
name|fun
condition|)
block|{
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|fun
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|st
index|[
name|i
index|]
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|st
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|fun
operator|&&
name|i
operator|!=
literal|0
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|tmp
argument_list|,
name|op
index|[
name|i
index|]
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fun
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print_exp */
end_comment

begin_comment
comment|/* Prints rtxes, I customarily classified as values.  They're constants,    registers, labels, symbols and memory accesses.  */
end_comment

begin_function
specifier|static
name|void
name|print_value
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|t
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|real_to_decimal
argument_list|(
name|t
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"<"
name|HOST_WIDE_INT_PRINT_HEX
literal|","
name|HOST_WIDE_INT_PRINT_HEX
literal|">"
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"L%d"
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"const("
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HIGH
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"high("
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|c
init|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"r%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
operator|&&
operator|!
name|current_sched_info
endif|#
directive|endif
condition|)
block|{
name|sprintf
argument_list|(
name|t
argument_list|,
literal|":%s"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"#%d"
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCRATCH
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"scratch"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CC0
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"cc0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PC
case|:
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"pc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_exp
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|cur
operator|=
name|safe_concat
argument_list|(
name|buf
argument_list|,
name|cur
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* print_value */
end_comment

begin_comment
comment|/* The next step in insn detalization, its pattern recognition.  */
end_comment

begin_function
specifier|static
name|void
name|print_pattern
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|t1
index|[
name|BUF_LEN
index|]
decl_stmt|,
name|t2
index|[
name|BUF_LEN
index|]
decl_stmt|,
name|t3
index|[
name|BUF_LEN
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|t2
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"return"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|print_exp
argument_list|(
name|buf
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOBBER
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"clobber %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|USE
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"use %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXEC
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NE
operator|&&
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
name|print_value
argument_list|(
name|t1
argument_list|,
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|EQ
operator|&&
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|t1
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|print_value
argument_list|(
name|t1
operator|+
literal|1
argument_list|,
name|XEXP
argument_list|(
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
else|else
name|print_value
argument_list|(
name|t1
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%s) %s"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SEQUENCE
case|:
comment|/* Should never see SEQUENCE codes until after reorg.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|ASM_INPUT
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"asm {%s}"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_VEC
case|:
break|break;
case|case
name|ADDR_DIFF_VEC
case|:
name|print_value
argument_list|(
name|buf
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRAP_IF
case|:
name|print_value
argument_list|(
name|t1
argument_list|,
name|TRAP_CONDITION
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"trap_if %s"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"unspec{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC_VOLATILE
case|:
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"unspec/v{"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|print_pattern
argument_list|(
name|t2
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t3
argument_list|,
literal|"%s%s;"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|t1
argument_list|,
name|t3
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s}"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|print_value
argument_list|(
name|buf
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* print_pattern */
end_comment

begin_comment
comment|/* This is the main function in rtl visualization mechanism. It    accepts an rtx and tries to recognize it as an insn, then prints it    properly in human readable form, resembling assembler mnemonics.    For every insn it prints its UID and BB the insn belongs too.    (Probably the last "option" should be extended somehow, since it    depends now on sched.c inner variables ...)  */
end_comment

begin_function
name|void
name|print_insn
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|char
name|t
index|[
name|BUF_LEN
index|]
decl_stmt|;
name|rtx
name|insn
init|=
name|x
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|print_pattern
argument_list|(
name|t
argument_list|,
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|verbose
operator|&&
name|current_sched_info
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" %4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|print_pattern
argument_list|(
name|t
argument_list|,
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|verbose
operator|&&
name|current_sched_info
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: jump %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" %4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
name|x
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_pattern
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|t
argument_list|,
literal|"call<...>"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|verbose
operator|&&
name|current_sched_info
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %s"
argument_list|,
call|(
modifier|*
name|current_sched_info
operator|->
name|print_insn
call|)
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" %4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"L%d:"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"i%4d: barrier"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE
case|:
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
operator|>
literal|0
condition|)
block|{
name|expanded_location
name|xloc
decl_stmt|;
name|NOTE_EXPANDED_LOCATION
argument_list|(
name|xloc
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" %4d note \"%s\" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|xloc
operator|.
name|file
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" %4d %s"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_NOTE_INSN_NAME
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"i%4d<What %s?>"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* print_insn */
end_comment

begin_comment
comment|/* Emit a slim dump of X (an insn) to the file F, including any register    note attached to the instruction.  */
end_comment

begin_function
name|void
name|dump_insn_slim
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|char
name|t
index|[
name|BUF_LEN
operator|+
literal|32
index|]
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|print_insn
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|x
argument_list|)
operator|&&
name|REG_NOTES
argument_list|(
name|x
argument_list|)
condition|)
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|x
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|print_value
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"      %s: %s\n"
argument_list|,
name|GET_REG_NOTE_NAME
argument_list|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a slim dump of X (an insn) to stderr.  */
end_comment

begin_function
name|void
name|debug_insn_slim
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|dump_insn_slim
argument_list|(
name|stderr
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Provide a slim dump the instruction chain starting at FIRST to F, honoring    the dump flags given in FLAGS.  Currently, TDF_BLOCKS and TDF_DETAILS    include more information on the basic blocks.  */
end_comment

begin_function
name|void
name|print_rtl_slim_with_bb
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|rtx
name|first
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|basic_block
name|current_bb
init|=
name|NULL
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|NULL
operator|!=
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|TDF_BLOCKS
operator|)
operator|&&
operator|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|)
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|current_bb
condition|)
block|{
name|current_bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dump_bb_info
argument_list|(
name|current_bb
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|flags
argument_list|,
literal|";; "
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|dump_insn_slim
argument_list|(
name|f
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|TDF_BLOCKS
operator|)
operator|&&
name|current_bb
operator|&&
name|insn
operator|==
name|BB_END
argument_list|(
name|current_bb
argument_list|)
condition|)
block|{
name|dump_bb_info
argument_list|(
name|current_bb
argument_list|,
name|false
argument_list|,
name|true
argument_list|,
name|flags
argument_list|,
literal|";; "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|current_bb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

