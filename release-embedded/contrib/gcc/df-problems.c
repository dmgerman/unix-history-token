begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Standard problems for dataflow support routines.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Originally contributed by Michael P. Hayes               (m.hayes@elec.canterbury.ac.nz, mhayes@redhat.com)    Major rewrite contributed by Danny Berlin (dberlin@dberlin.org)              and Kenneth Zadeck (zadeck@naturalbridge.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"df.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|REG_DEAD_DEBUGGING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DF_SPARSE_THRESHOLD
value|32
end_define

begin_decl_stmt
specifier|static
name|bitmap
name|seen_in_block
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap
name|seen_in_insn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|df_ri_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    Public functions access functions for the dataflow problems. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Create a du or ud chain from SRC to DST and link it into SRC.   */
end_comment

begin_function
name|struct
name|df_link
modifier|*
name|df_chain_create
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df_ref
modifier|*
name|src
parameter_list|,
name|struct
name|df_ref
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|df_link
modifier|*
name|head
init|=
name|DF_REF_CHAIN
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|struct
name|df_link
modifier|*
name|link
init|=
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
decl_stmt|;
empty_stmt|;
name|DF_REF_CHAIN
argument_list|(
name|src
argument_list|)
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|link
operator|->
name|ref
operator|=
name|dst
expr_stmt|;
return|return
name|link
return|;
block|}
end_function

begin_comment
comment|/* Delete a du or ud chain for REF.  If LINK is NULL, delete all    chains for ref and check to see if the reverse chains can also be    deleted.  If LINK is not NULL it must be a link off of ref.  In    this case, the other end is not deleted.  */
end_comment

begin_function
name|void
name|df_chain_unlink
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df_ref
modifier|*
name|ref
parameter_list|,
name|struct
name|df_link
modifier|*
name|link
parameter_list|)
block|{
name|struct
name|df_link
modifier|*
name|chain
init|=
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|link
condition|)
block|{
comment|/* Link was the first element in the chain.  */
if|if
condition|(
name|chain
operator|==
name|link
condition|)
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
operator|=
name|link
operator|->
name|next
expr_stmt|;
else|else
block|{
comment|/* Link is an internal element in the chain.  */
name|struct
name|df_link
modifier|*
name|prev
init|=
name|chain
decl_stmt|;
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|chain
operator|==
name|link
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|prev
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
name|pool_free
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If chain is NULL here, it was because of a recursive call 	 when the other flavor of chains was not built.  Just run thru 	 the entire chain calling the other side and then deleting the 	 link.  */
while|while
condition|(
name|chain
condition|)
block|{
name|struct
name|df_link
modifier|*
name|next
init|=
name|chain
operator|->
name|next
decl_stmt|;
comment|/* Delete the other side if it exists.  */
name|df_chain_unlink
argument_list|(
name|dflow
argument_list|,
name|chain
operator|->
name|ref
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy the du or ud chain starting at FROM_REF and attach it to    TO_REF.  */
end_comment

begin_function
name|void
name|df_chain_copy
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df_ref
modifier|*
name|to_ref
parameter_list|,
name|struct
name|df_link
modifier|*
name|from_ref
parameter_list|)
block|{
while|while
condition|(
name|from_ref
condition|)
block|{
name|df_chain_create
argument_list|(
name|dflow
argument_list|,
name|to_ref
argument_list|,
name|from_ref
operator|->
name|ref
argument_list|)
expr_stmt|;
name|from_ref
operator|=
name|from_ref
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the live in set for BB no matter what problem happens to be    defined.  */
end_comment

begin_function
name|bitmap
name|df_get_live_in
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|df
operator|->
name|problems_by_index
index|[
name|DF_LR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|problems_by_index
index|[
name|DF_UREC
index|]
condition|)
return|return
name|DF_RA_LIVE_IN
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
return|;
elseif|else
if|if
condition|(
name|df
operator|->
name|problems_by_index
index|[
name|DF_UR
index|]
condition|)
return|return
name|DF_LIVE_IN
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
return|;
else|else
return|return
name|DF_UPWARD_LIVE_IN
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the live out set for BB no matter what problem happens to be    defined.  */
end_comment

begin_function
name|bitmap
name|df_get_live_out
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|df
operator|->
name|problems_by_index
index|[
name|DF_LR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|problems_by_index
index|[
name|DF_UREC
index|]
condition|)
return|return
name|DF_RA_LIVE_OUT
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
return|;
elseif|else
if|if
condition|(
name|df
operator|->
name|problems_by_index
index|[
name|DF_UR
index|]
condition|)
return|return
name|DF_LIVE_OUT
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
return|;
else|else
return|return
name|DF_UPWARD_LIVE_OUT
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------    Utility functions. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Generic versions to get the void* version of the block info.  Only    used inside the problem instance vectors.  */
end_comment

begin_comment
comment|/* Grow the bb_info array.  */
end_comment

begin_function
name|void
name|df_grow_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|unsigned
name|int
name|new_size
init|=
name|last_basic_block
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|block_info_size
operator|<
name|new_size
condition|)
block|{
name|new_size
operator|+=
name|new_size
operator|/
literal|4
expr_stmt|;
name|dflow
operator|->
name|block_info
operator|=
name|xrealloc
argument_list|(
name|dflow
operator|->
name|block_info
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dflow
operator|->
name|block_info
operator|+
name|dflow
operator|->
name|block_info_size
argument_list|,
literal|0
argument_list|,
operator|(
name|new_size
operator|-
name|dflow
operator|->
name|block_info_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info_size
operator|=
name|new_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump a def-use or use-def chain for REF to FILE.  */
end_comment

begin_function
name|void
name|df_chain_dump
parameter_list|(
name|struct
name|df_link
modifier|*
name|link
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d(bb %d insn %d) "
argument_list|,
name|DF_REF_REG_DEF_P
argument_list|(
name|link
operator|->
name|ref
argument_list|)
condition|?
literal|'d'
else|:
literal|'u'
argument_list|,
name|DF_REF_ID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|link
operator|->
name|ref
argument_list|)
argument_list|,
name|DF_REF_INSN
argument_list|(
name|link
operator|->
name|ref
argument_list|)
condition|?
name|DF_REF_INSN_UID
argument_list|(
name|link
operator|->
name|ref
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print some basic block info as part of df_dump.  */
end_comment

begin_function
name|void
name|df_print_bb_index
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"( "
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|basic_block
name|pred
init|=
name|e
operator|->
name|src
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|pred
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")->[%d]->( "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|basic_block
name|succ
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d "
argument_list|,
name|succ
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a bitmap for REGNO from the cache MAPS.  The bitmap is to    contain COUNT bits starting at START.  These bitmaps are not to be    changed since there is a cache of them.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bitmap
name|df_ref_bitmap
parameter_list|(
name|bitmap
modifier|*
name|maps
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|bitmap
name|ids
init|=
name|maps
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ids
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|end
init|=
name|start
operator|+
name|count
decl_stmt|;
empty_stmt|;
name|ids
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|maps
index|[
name|regno
index|]
operator|=
name|ids
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|ids
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|ids
return|;
block|}
end_function

begin_comment
comment|/* Make sure that the seen_in_insn and seen_in_block sbitmaps are set    up correctly. */
end_comment

begin_function
specifier|static
name|void
name|df_set_seen
parameter_list|(
name|void
parameter_list|)
block|{
name|seen_in_block
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|seen_in_insn
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|df_unset_seen
parameter_list|(
name|void
parameter_list|)
block|{
name|BITMAP_FREE
argument_list|(
name|seen_in_block
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|seen_in_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    REACHING USES     Find the locations in the function where each use site for a pseudo    can reach backwards.  In and out bitvectors are built for each basic    block.  The id field in the ref is used to index into these sets.    See df.h for details.  ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* This problem plays a large number of games for the sake of    efficiency.          1) The order of the bits in the bitvectors.  After the scanning    phase, all of the uses are sorted.  All of the uses for the reg 0    are first, followed by all uses for reg 1 and so on.        2) There are two kill sets, one if the number of uses is less or    equal to DF_SPARSE_THRESHOLD and another if it is greater.<= : There is a bitmap for each register, uses_sites[N], that is    built on demand.  This bitvector contains a 1 for each use or reg    N.> : One level of indirection is used to keep from generating long    strings of 1 bits in the kill sets.  Bitvectors that are indexed    by the regnum are used to represent that there is a killing def    for the register.  The confluence and transfer functions use    these along with the bitmap_clear_range call to remove ranges of    bits without actually generating a knockout vector.     The kill and sparse_kill and the dense_invalidated_by_call and    sparse_invalidated_by call both play this game.  */
end_comment

begin_comment
comment|/* Private data used to compute the solution for this problem.  These    data structures are not accessible outside of this module.  */
end_comment

begin_struct
struct|struct
name|df_ru_problem_data
block|{
name|bitmap
modifier|*
name|use_sites
decl_stmt|;
comment|/* Bitmap of uses for each pseudo.  */
name|unsigned
name|int
name|use_sites_size
decl_stmt|;
comment|/* Size of use_sites.  */
comment|/* The set of defs to regs invalidated by call.  */
name|bitmap
name|sparse_invalidated_by_call
decl_stmt|;
comment|/* The set of defs to regs invalidated by call for ru.  */
name|bitmap
name|dense_invalidated_by_call
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get basic block info.  */
end_comment

begin_function
name|struct
name|df_ru_bb_info
modifier|*
name|df_ru_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|df_ru_bb_info
operator|*
operator|)
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
parameter_list|)
block|{
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
operator|=
name|bb_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_free_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|vbb_info
parameter_list|)
block|{
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_ru_bb_info
operator|*
operator|)
name|vbb_info
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate or reset bitmaps for DFLOW blocks. The solution bits are    not touched unless the block is new.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|reg_size
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_pool
condition|)
name|dflow
operator|->
name|block_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_ru_block pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_ru_bb_info
argument_list|)
argument_list|,
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem_data
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|df_ru_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_ru_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|problem_data
operator|->
name|use_sites_size
condition|;
name|i
operator|++
control|)
block|{
name|bitmap
name|bm
init|=
name|problem_data
operator|->
name|use_sites
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bm
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bm
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|use_sites
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|problem_data
operator|->
name|use_sites_size
operator|<
name|reg_size
condition|)
block|{
name|problem_data
operator|->
name|use_sites
operator|=
name|xrealloc
argument_list|(
name|problem_data
operator|->
name|use_sites
argument_list|,
name|reg_size
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|problem_data
operator|->
name|use_sites
operator|+
name|problem_data
operator|->
name|use_sites_size
argument_list|,
literal|0
argument_list|,
operator|(
name|reg_size
operator|-
name|problem_data
operator|->
name|use_sites_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|use_sites_size
operator|=
name|reg_size
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|problem_data
operator|->
name|sparse_invalidated_by_call
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|problem_data
operator|->
name|dense_invalidated_by_call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|df_ru_problem_data
modifier|*
name|problem_data
init|=
name|XNEW
argument_list|(
expr|struct
name|df_ru_problem_data
argument_list|)
decl_stmt|;
name|dflow
operator|->
name|problem_data
operator|=
name|problem_data
expr_stmt|;
name|problem_data
operator|->
name|use_sites
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|use_sites_size
operator|=
name|reg_size
expr_stmt|;
name|problem_data
operator|->
name|sparse_invalidated_by_call
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|dense_invalidated_by_call
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
comment|/* Because of the clustering of all def sites for the same pseudo,      we have to process all of the blocks before doing the      analysis.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_ru_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_ru_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|kill
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|sparse_kill
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|gen
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|in
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|out
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a list of DEFs for df_ru_bb_local_compute.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_bb_local_compute_process_def
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
parameter_list|,
name|struct
name|df_ref
modifier|*
name|def
parameter_list|,
name|enum
name|df_ref_flags
name|top_flag
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
while|while
condition|(
name|def
condition|)
block|{
if|if
condition|(
operator|(
name|top_flag
operator|==
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|)
comment|/* If the def is to only part of the reg, it is as if it did 	     not happen, since some of the bits may get thru.  */
operator|&&
operator|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|begin
init|=
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
decl_stmt|;
name|unsigned
name|int
name|n_uses
init|=
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
condition|)
block|{
comment|/* The first def for regno in the insn, causes the kill 		 info to be generated.  Do not modify the gen set 		 because the only values in it are the uses from here 		 to the top of the block and this def does not effect 		 them.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_insn
argument_list|,
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|n_uses
operator|>
name|DF_SPARSE_THRESHOLD
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|df_ru_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_ru_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|bitmap
name|uses
init|=
name|df_ref_bitmap
argument_list|(
name|problem_data
operator|->
name|use_sites
argument_list|,
name|regno
argument_list|,
name|begin
argument_list|,
name|n_uses
argument_list|)
decl_stmt|;
name|bitmap_ior_into
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|,
name|uses
argument_list|)
expr_stmt|;
block|}
block|}
name|bitmap_set_bit
argument_list|(
name|seen_in_insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
name|def
operator|=
name|def
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a list of USEs for df_ru_bb_local_compute.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_bb_local_compute_process_use
parameter_list|(
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
parameter_list|,
name|struct
name|df_ref
modifier|*
name|use
parameter_list|,
name|enum
name|df_ref_flags
name|top_flag
parameter_list|)
block|{
while|while
condition|(
name|use
condition|)
block|{
if|if
condition|(
name|top_flag
operator|==
operator|(
name|DF_REF_FLAGS
argument_list|(
name|use
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
condition|)
block|{
comment|/* Add use to set of gens in this BB unless we have seen a 	     def in a previous instruction.  */
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|DF_REF_ID
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|use
operator|=
name|use
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute local reaching use (upward exposed use) info for basic    block BB.  USE_INFO->REGS[R] caches the set of uses for register R.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_bb_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Set when a def for regno is seen.  */
name|bitmap_clear
argument_list|(
name|seen_in_block
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EH_USES
comment|/* Variables defined in the prolog that are used by the exception      handler.  */
name|df_ru_bb_local_compute_process_use
argument_list|(
name|bb_info
argument_list|,
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
argument_list|,
name|DF_REF_AT_TOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|df_ru_bb_local_compute_process_def
argument_list|(
name|dflow
argument_list|,
name|bb_info
argument_list|,
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
argument_list|,
name|DF_REF_AT_TOP
argument_list|)
expr_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|df_ru_bb_local_compute_process_use
argument_list|(
name|bb_info
argument_list|,
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_ru_bb_local_compute_process_def
argument_list|(
name|dflow
argument_list|,
name|bb_info
argument_list|,
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|seen_in_block
argument_list|,
name|seen_in_insn
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Process the hardware registers that are always live.  */
name|df_ru_bb_local_compute_process_use
argument_list|(
name|bb_info
argument_list|,
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|df_ru_bb_local_compute_process_def
argument_list|(
name|dflow
argument_list|,
name|bb_info
argument_list|,
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local reaching use (upward exposed use) info for each basic    block within BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|,
name|bitmap
name|rescan_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|struct
name|df_ru_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_ru_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|bitmap
name|sparse_invalidated
init|=
name|problem_data
operator|->
name|sparse_invalidated_by_call
decl_stmt|;
name|bitmap
name|dense_invalidated
init|=
name|problem_data
operator|->
name|dense_invalidated_by_call
decl_stmt|;
name|df_set_seen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|df
operator|->
name|use_info
operator|.
name|refs_organized
condition|)
name|df_reorganize_refs
argument_list|(
operator|&
name|df
operator|->
name|use_info
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_ru_bb_local_compute
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the knockout bit vectors to be applied across EH_EDGES.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|df_invalidated_by_call
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_reg_info
modifier|*
name|reg_info
init|=
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_info
operator|->
name|n_refs
operator|>
name|DF_SPARSE_THRESHOLD
condition|)
name|bitmap_set_bit
argument_list|(
name|sparse_invalidated
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|bitmap
name|defs
init|=
name|df_ref_bitmap
argument_list|(
name|problem_data
operator|->
name|use_sites
argument_list|,
name|regno
argument_list|,
name|reg_info
operator|->
name|begin
argument_list|,
name|reg_info
operator|->
name|n_refs
argument_list|)
decl_stmt|;
name|bitmap_ior_into
argument_list|(
name|dense_invalidated
argument_list|,
name|defs
argument_list|)
expr_stmt|;
block|}
block|}
name|df_unset_seen
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the solution bit vectors for problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_init_solution
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|in
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Out of target gets or of in of source.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_confluence_n
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|bitmap
name|op1
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
operator|->
name|out
decl_stmt|;
name|bitmap
name|op2
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|->
name|in
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
name|struct
name|df_ru_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_ru_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|bitmap
name|sparse_invalidated
init|=
name|problem_data
operator|->
name|sparse_invalidated_by_call
decl_stmt|;
name|bitmap
name|dense_invalidated
init|=
name|problem_data
operator|->
name|dense_invalidated_by_call
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|bitmap
name|tmp
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|tmp
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|bitmap_and_compl_into
argument_list|(
name|tmp
argument_list|,
name|dense_invalidated
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|sparse_invalidated
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap_clear_range
argument_list|(
name|tmp
argument_list|,
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
block|}
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer function.  */
end_comment

begin_function
specifier|static
name|bool
name|df_ru_transfer_function
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap
name|in
init|=
name|bb_info
operator|->
name|in
decl_stmt|;
name|bitmap
name|out
init|=
name|bb_info
operator|->
name|out
decl_stmt|;
name|bitmap
name|gen
init|=
name|bb_info
operator|->
name|gen
decl_stmt|;
name|bitmap
name|kill
init|=
name|bb_info
operator|->
name|kill
decl_stmt|;
name|bitmap
name|sparse_kill
init|=
name|bb_info
operator|->
name|sparse_kill
decl_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|sparse_kill
argument_list|)
condition|)
return|return
name|bitmap_ior_and_compl
argument_list|(
name|in
argument_list|,
name|gen
argument_list|,
name|out
argument_list|,
name|kill
argument_list|)
return|;
else|else
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|bitmap
name|tmp
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|tmp
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|sparse_kill
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap_clear_range
argument_list|(
name|tmp
argument_list|,
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
block|}
name|bitmap_and_compl_into
argument_list|(
name|tmp
argument_list|,
name|kill
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|tmp
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|changed
operator|=
operator|!
name|bitmap_equal_p
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|in
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
block|}
end_function

begin_comment
comment|/* Free all storage associated with the problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|df_ru_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_ru_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
if|if
condition|(
name|problem_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dflow
operator|->
name|block_info_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|problem_data
operator|->
name|use_sites_size
condition|;
name|i
operator|++
control|)
block|{
name|bitmap
name|bm
init|=
name|problem_data
operator|->
name|use_sites
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bm
condition|)
name|BITMAP_FREE
argument_list|(
name|bm
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|problem_data
operator|->
name|use_sites
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|problem_data
operator|->
name|sparse_invalidated_by_call
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|problem_data
operator|->
name|dense_invalidated_by_call
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|block_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|problem_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ru_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|df_ru_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_ru_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|unsigned
name|int
name|m
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_info
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reaching uses:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  sparse invalidated \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|problem_data
operator|->
name|sparse_invalidated_by_call
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  dense invalidated \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|problem_data
operator|->
name|dense_invalidated_by_call
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|m
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d[%d,%d] "
argument_list|,
name|regno
argument_list|,
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_USE_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|df_ru_bb_info
modifier|*
name|bb_info
init|=
name|df_ru_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|df_print_bb_index
argument_list|(
name|bb
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  in  \t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  gen \t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  kill\t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  out \t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All of the information associated with every instance of the problem.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_RU
init|=
block|{
name|DF_RU
block|,
comment|/* Problem id.  */
name|DF_BACKWARD
block|,
comment|/* Direction.  */
name|df_ru_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|NULL
block|,
comment|/* Reset global information.  */
name|df_ru_free_bb_info
block|,
comment|/* Free basic block info.  */
name|df_ru_local_compute
block|,
comment|/* Local compute function.  */
name|df_ru_init_solution
block|,
comment|/* Init the solution specific data.  */
name|df_iterative_dataflow
block|,
comment|/* Iterative solver.  */
name|NULL
block|,
comment|/* Confluence operator 0.  */
name|df_ru_confluence_n
block|,
comment|/* Confluence operator n.  */
name|df_ru_transfer_function
block|,
comment|/* Transfer function.  */
name|NULL
block|,
comment|/* Finalize function.  */
name|df_ru_free
block|,
comment|/* Free all of the problem information.  */
name|df_ru_dump
block|,
comment|/* Debugging.  */
name|NULL
block|,
comment|/* Dependent problem.  */
literal|0
comment|/* Changeable flags.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_ru_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_RU
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    REACHING DEFINITIONS     Find the locations in the function where each definition site for a    pseudo reaches.  In and out bitvectors are built for each basic    block.  The id field in the ref is used to index into these sets.    See df.h for details.    ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* See the comment at the top of the Reaching Uses problem for how the    uses are represented in the kill sets. The same games are played    here for the defs.  */
end_comment

begin_comment
comment|/* Private data used to compute the solution for this problem.  These    data structures are not accessible outside of this module.  */
end_comment

begin_struct
struct|struct
name|df_rd_problem_data
block|{
comment|/* If the number of defs for regnum N is less than      DF_SPARSE_THRESHOLD, uses_sites[N] contains a mask of the all of      the defs of reg N indexed by the id in the ref structure.  If      there are more than DF_SPARSE_THRESHOLD defs for regnum N a      different mechanism is used to mask the def.  */
name|bitmap
modifier|*
name|def_sites
decl_stmt|;
comment|/* Bitmap of defs for each pseudo.  */
name|unsigned
name|int
name|def_sites_size
decl_stmt|;
comment|/* Size of def_sites.  */
comment|/* The set of defs to regs invalidated by call.  */
name|bitmap
name|sparse_invalidated_by_call
decl_stmt|;
comment|/* The set of defs to regs invalidate by call for rd.  */
name|bitmap
name|dense_invalidated_by_call
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get basic block info.  */
end_comment

begin_function
name|struct
name|df_rd_bb_info
modifier|*
name|df_rd_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|df_rd_bb_info
operator|*
operator|)
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
parameter_list|)
block|{
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
operator|=
name|bb_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_free_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|vbb_info
parameter_list|)
block|{
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_rd_bb_info
operator|*
operator|)
name|vbb_info
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate or reset bitmaps for DFLOW blocks. The solution bits are    not touched unless the block is new.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|reg_size
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_pool
condition|)
name|dflow
operator|->
name|block_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_rd_block pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_rd_bb_info
argument_list|)
argument_list|,
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|problem_data
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|df_rd_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_rd_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|problem_data
operator|->
name|def_sites_size
condition|;
name|i
operator|++
control|)
block|{
name|bitmap
name|bm
init|=
name|problem_data
operator|->
name|def_sites
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bm
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bm
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|def_sites
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|problem_data
operator|->
name|def_sites_size
operator|<
name|reg_size
condition|)
block|{
name|problem_data
operator|->
name|def_sites
operator|=
name|xrealloc
argument_list|(
name|problem_data
operator|->
name|def_sites
argument_list|,
name|reg_size
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|problem_data
operator|->
name|def_sites
operator|+
name|problem_data
operator|->
name|def_sites_size
argument_list|,
literal|0
argument_list|,
operator|(
name|reg_size
operator|-
name|problem_data
operator|->
name|def_sites_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|def_sites_size
operator|=
name|reg_size
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|problem_data
operator|->
name|sparse_invalidated_by_call
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|problem_data
operator|->
name|dense_invalidated_by_call
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|df_rd_problem_data
modifier|*
name|problem_data
init|=
name|XNEW
argument_list|(
expr|struct
name|df_rd_problem_data
argument_list|)
decl_stmt|;
name|dflow
operator|->
name|problem_data
operator|=
name|problem_data
expr_stmt|;
name|problem_data
operator|->
name|def_sites
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|def_sites_size
operator|=
name|reg_size
expr_stmt|;
name|problem_data
operator|->
name|sparse_invalidated_by_call
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|dense_invalidated_by_call
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
comment|/* Because of the clustering of all use sites for the same pseudo,      we have to process all of the blocks before doing the      analysis.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_rd_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_rd_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|kill
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|sparse_kill
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|gen
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|in
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|out
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a list of DEFs for df_rd_bb_local_compute.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_bb_local_compute_process_def
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
parameter_list|,
name|struct
name|df_ref
modifier|*
name|def
parameter_list|,
name|enum
name|df_ref_flags
name|top_flag
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
while|while
condition|(
name|def
condition|)
block|{
if|if
condition|(
name|top_flag
operator|==
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|begin
init|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
decl_stmt|;
name|unsigned
name|int
name|n_defs
init|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
decl_stmt|;
comment|/* Only the last def(s) for a regno in the block has any 	     effect.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
condition|)
block|{
comment|/* The first def for regno in insn gets to knock out the 		 defs from other instructions.  */
if|if
condition|(
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_insn
argument_list|,
name|regno
argument_list|)
operator|)
comment|/* If the def is to only part of the reg, it does 		     not kill the other defs that reach here.  */
operator|&&
operator|(
operator|!
operator|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
operator|||
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_MAY_CLOBBER
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|n_defs
operator|>
name|DF_SPARSE_THRESHOLD
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|bitmap_clear_range
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|begin
argument_list|,
name|n_defs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|df_rd_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_rd_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|bitmap
name|defs
init|=
name|df_ref_bitmap
argument_list|(
name|problem_data
operator|->
name|def_sites
argument_list|,
name|regno
argument_list|,
name|begin
argument_list|,
name|n_defs
argument_list|)
decl_stmt|;
name|bitmap_ior_into
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|,
name|defs
argument_list|)
expr_stmt|;
name|bitmap_and_compl_into
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|defs
argument_list|)
expr_stmt|;
block|}
block|}
name|bitmap_set_bit
argument_list|(
name|seen_in_insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* All defs for regno in the instruction may be put into 		 the gen set.  */
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
operator|(
name|DF_REF_MUST_CLOBBER
operator||
name|DF_REF_MAY_CLOBBER
operator|)
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|DF_REF_ID
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|def
operator|=
name|def
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute local reaching def info for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_bb_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_block
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_insn
argument_list|)
expr_stmt|;
name|df_rd_bb_local_compute_process_def
argument_list|(
name|dflow
argument_list|,
name|bb_info
argument_list|,
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|df_rd_bb_local_compute_process_def
argument_list|(
name|dflow
argument_list|,
name|bb_info
argument_list|,
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This complex dance with the two bitmaps is required because 	 instructions can assign twice to the same pseudo.  This 	 generally happens with calls that will have one def for the 	 result and another def for the clobber.  If only one vector 	 is used and the clobber goes first, the result will be 	 lost.  */
name|bitmap_ior_into
argument_list|(
name|seen_in_block
argument_list|,
name|seen_in_insn
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Process the artificial defs at the top of the block last since we      are going backwards through the block and these are logically at      the start.  */
name|df_rd_bb_local_compute_process_def
argument_list|(
name|dflow
argument_list|,
name|bb_info
argument_list|,
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
argument_list|,
name|DF_REF_AT_TOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local reaching def info for each basic block within BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|,
name|bitmap
name|rescan_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|struct
name|df_rd_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_rd_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|bitmap
name|sparse_invalidated
init|=
name|problem_data
operator|->
name|sparse_invalidated_by_call
decl_stmt|;
name|bitmap
name|dense_invalidated
init|=
name|problem_data
operator|->
name|dense_invalidated_by_call
decl_stmt|;
name|df_set_seen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|df
operator|->
name|def_info
operator|.
name|refs_organized
condition|)
name|df_reorganize_refs
argument_list|(
operator|&
name|df
operator|->
name|def_info
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_rd_bb_local_compute
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the knockout bit vectors to be applied across EH_EDGES.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|df_invalidated_by_call
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_reg_info
modifier|*
name|reg_info
init|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_info
operator|->
name|n_refs
operator|>
name|DF_SPARSE_THRESHOLD
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|sparse_invalidated
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bitmap
name|defs
init|=
name|df_ref_bitmap
argument_list|(
name|problem_data
operator|->
name|def_sites
argument_list|,
name|regno
argument_list|,
name|reg_info
operator|->
name|begin
argument_list|,
name|reg_info
operator|->
name|n_refs
argument_list|)
decl_stmt|;
name|bitmap_ior_into
argument_list|(
name|dense_invalidated
argument_list|,
name|defs
argument_list|)
expr_stmt|;
block|}
block|}
name|df_unset_seen
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the solution bit vectors for problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_init_solution
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In of target gets or of out of source.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_confluence_n
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|bitmap
name|op1
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|->
name|in
decl_stmt|;
name|bitmap
name|op2
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
operator|->
name|out
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
name|struct
name|df_rd_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_rd_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|bitmap
name|sparse_invalidated
init|=
name|problem_data
operator|->
name|sparse_invalidated_by_call
decl_stmt|;
name|bitmap
name|dense_invalidated
init|=
name|problem_data
operator|->
name|dense_invalidated_by_call
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|bitmap
name|tmp
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|tmp
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|bitmap_and_compl_into
argument_list|(
name|tmp
argument_list|,
name|dense_invalidated
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|sparse_invalidated
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap_clear_range
argument_list|(
name|tmp
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
block|}
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer function.  */
end_comment

begin_function
specifier|static
name|bool
name|df_rd_transfer_function
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap
name|in
init|=
name|bb_info
operator|->
name|in
decl_stmt|;
name|bitmap
name|out
init|=
name|bb_info
operator|->
name|out
decl_stmt|;
name|bitmap
name|gen
init|=
name|bb_info
operator|->
name|gen
decl_stmt|;
name|bitmap
name|kill
init|=
name|bb_info
operator|->
name|kill
decl_stmt|;
name|bitmap
name|sparse_kill
init|=
name|bb_info
operator|->
name|sparse_kill
decl_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|sparse_kill
argument_list|)
condition|)
return|return
name|bitmap_ior_and_compl
argument_list|(
name|out
argument_list|,
name|gen
argument_list|,
name|in
argument_list|,
name|kill
argument_list|)
return|;
else|else
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|bitmap
name|tmp
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|tmp
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|sparse_kill
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap_clear_range
argument_list|(
name|tmp
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
block|}
name|bitmap_and_compl_into
argument_list|(
name|tmp
argument_list|,
name|kill
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|tmp
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|changed
operator|=
operator|!
name|bitmap_equal_p
argument_list|(
name|tmp
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|out
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
block|}
end_function

begin_comment
comment|/* Free all storage associated with the problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|df_rd_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_rd_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
if|if
condition|(
name|problem_data
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dflow
operator|->
name|block_info_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|sparse_kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|problem_data
operator|->
name|def_sites_size
condition|;
name|i
operator|++
control|)
block|{
name|bitmap
name|bm
init|=
name|problem_data
operator|->
name|def_sites
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bm
condition|)
name|BITMAP_FREE
argument_list|(
name|bm
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|problem_data
operator|->
name|def_sites
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|problem_data
operator|->
name|sparse_invalidated_by_call
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|problem_data
operator|->
name|dense_invalidated_by_call
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|block_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|problem_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|df_rd_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|struct
name|df_rd_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_rd_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|unsigned
name|int
name|m
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_info
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reaching defs:\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  sparse invalidated \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|problem_data
operator|->
name|sparse_invalidated_by_call
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  dense invalidated \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|problem_data
operator|->
name|dense_invalidated_by_call
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|m
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d[%d,%d] "
argument_list|,
name|regno
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|regno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|df_rd_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|df_print_bb_index
argument_list|(
name|bb
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  in  \t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  gen \t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  kill\t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  out \t(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|bitmap_count_bits
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All of the information associated with every instance of the problem.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_RD
init|=
block|{
name|DF_RD
block|,
comment|/* Problem id.  */
name|DF_FORWARD
block|,
comment|/* Direction.  */
name|df_rd_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|NULL
block|,
comment|/* Reset global information.  */
name|df_rd_free_bb_info
block|,
comment|/* Free basic block info.  */
name|df_rd_local_compute
block|,
comment|/* Local compute function.  */
name|df_rd_init_solution
block|,
comment|/* Init the solution specific data.  */
name|df_iterative_dataflow
block|,
comment|/* Iterative solver.  */
name|NULL
block|,
comment|/* Confluence operator 0.  */
name|df_rd_confluence_n
block|,
comment|/* Confluence operator n.  */
name|df_rd_transfer_function
block|,
comment|/* Transfer function.  */
name|NULL
block|,
comment|/* Finalize function.  */
name|df_rd_free
block|,
comment|/* Free all of the problem information.  */
name|df_rd_dump
block|,
comment|/* Debugging.  */
name|NULL
block|,
comment|/* Dependent problem.  */
literal|0
comment|/* Changeable flags.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_rd_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_RD
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    LIVE REGISTERS     Find the locations in the function where any use of a pseudo can    reach in the backwards direction.  In and out bitvectors are built    for each basic block.  The regnum is used to index into these sets.    See df.h for details.    ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Get basic block info.  */
end_comment

begin_function
name|struct
name|df_lr_bb_info
modifier|*
name|df_lr_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|df_lr_bb_info
operator|*
operator|)
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
parameter_list|)
block|{
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
operator|=
name|bb_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_free_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|vbb_info
parameter_list|)
block|{
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_lr_bb_info
operator|*
operator|)
name|vbb_info
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|use
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|def
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate or reset bitmaps for DFLOW blocks. The solution bits are    not touched unless the block is new.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_pool
condition|)
name|dflow
operator|->
name|block_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_lr_block pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_lr_bb_info
argument_list|)
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_rescan
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|def
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|use
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_lr_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_lr_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|use
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|def
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|in
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|out
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute local live register info for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_bb_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
comment|/* Process the registers set in an exception handler.  */
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
operator|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|def
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
block|}
comment|/* Process the hardware registers that are always live.  */
for|for
control|(
name|use
operator|=
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
comment|/* Add use to set of uses in this BB.  */
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|use
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|==
literal|0
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
block|{
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|dregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
operator|(
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|bitmap_bit_p
argument_list|(
name|df
operator|->
name|exit_block_uses
argument_list|,
name|dregno
argument_list|)
operator|&&
operator|!
name|refers_to_regno_p
argument_list|(
name|dregno
argument_list|,
name|dregno
operator|+
literal|1
argument_list|,
name|current_function_return_rtx
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* If the def is to only part of the reg, it does 		     not kill the other defs that reach here.  */
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|def
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
block|{
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|DF_INSN_CONTAINS_ASM
argument_list|(
name|df
argument_list|,
name|insn
argument_list|)
operator|&&
name|dregno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|end
init|=
name|dregno
operator|+
name|hard_regno_nregs
index|[
name|dregno
index|]
index|[
name|GET_MODE
argument_list|(
name|DF_REF_REG
argument_list|(
name|def
argument_list|)
argument_list|)
index|]
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dregno
init|;
name|i
operator|<=
name|end
condition|;
operator|++
name|i
control|)
name|regs_asm_clobbered
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the def is to only part of the reg, it does 		     not kill the other defs that reach here.  */
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|def
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|use
operator|=
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
comment|/* Add use to set of uses in this BB.  */
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process the registers set in an exception handler.  */
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|&&
operator|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|def
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EH_USES
comment|/* Process the uses that are live into an exception handler.  */
for|for
control|(
name|use
operator|=
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
comment|/* Add use to set of uses in this BB.  */
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|use
argument_list|)
operator|&
name|DF_REF_AT_TOP
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Compute local live register info for each basic block within BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|,
name|bitmap
name|rescan_blocks
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Assume that the stack pointer is unchanging if alloca hasn't      been used.  */
if|if
condition|(
name|bitmap_equal_p
argument_list|(
name|all_blocks
argument_list|,
name|rescan_blocks
argument_list|)
condition|)
name|memset
argument_list|(
name|regs_asm_clobbered
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|regs_asm_clobbered
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|df
operator|->
name|hardware_regs_used
argument_list|)
expr_stmt|;
comment|/* The all-important stack pointer must always be live.  */
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|hardware_regs_used
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Before reload, there are a few registers that must be forced      live everywhere -- which might not already be the case for      blocks within infinite loops.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
comment|/* Any reference to any pseudo before reload is a potential 	 reference of the frame pointer.  */
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|hardware_regs_used
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Pseudos with argument area equivalences may require 	 reloading via the argument pointer.  */
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|hardware_regs_used
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Any constant, or pseudo with constant equivalences, may 	 require reloading from memory using the pic register.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|bitmap_set_bit
argument_list|(
name|df
operator|->
name|hardware_regs_used
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|rescan_blocks
argument_list|,
name|EXIT_BLOCK
argument_list|)
condition|)
block|{
comment|/* The exit block is special for this problem and its bits are 	 computed from thin air.  */
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|EXIT_BLOCK
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|use
argument_list|,
name|df
operator|->
name|exit_block_uses
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|rescan_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|bb_index
operator|==
name|EXIT_BLOCK
condition|)
continue|continue;
name|df_lr_bb_local_compute
argument_list|(
name|dflow
argument_list|,
name|df
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the solution vectors.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_init
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|in
argument_list|,
name|bb_info
operator|->
name|use
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Confluence function that processes infinite loops.  This might be a    noreturn function that throws.  And even if it isn't, getting the    unwind info right helps debugging.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_confluence_0
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bitmap
name|op1
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
operator|->
name|out
decl_stmt|;
if|if
condition|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|bitmap_copy
argument_list|(
name|op1
argument_list|,
name|df
operator|->
name|hardware_regs_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Confluence function that ignores fake edges.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_confluence_n
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|bitmap
name|op1
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
operator|->
name|out
decl_stmt|;
name|bitmap
name|op2
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|->
name|in
decl_stmt|;
comment|/* Call-clobbered registers die across exception and call edges.  */
comment|/* ??? Abnormal call edges ignored for the moment, as this gets      confused by sibling call edges, which crashes reg-stack.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
name|bitmap_ior_and_compl_into
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|,
name|df_invalidated_by_call
argument_list|)
expr_stmt|;
else|else
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|dflow
operator|->
name|df
operator|->
name|hardware_regs_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer function.  */
end_comment

begin_function
specifier|static
name|bool
name|df_lr_transfer_function
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap
name|in
init|=
name|bb_info
operator|->
name|in
decl_stmt|;
name|bitmap
name|out
init|=
name|bb_info
operator|->
name|out
decl_stmt|;
name|bitmap
name|use
init|=
name|bb_info
operator|->
name|use
decl_stmt|;
name|bitmap
name|def
init|=
name|bb_info
operator|->
name|def
decl_stmt|;
return|return
name|bitmap_ior_and_compl
argument_list|(
name|in
argument_list|,
name|use
argument_list|,
name|out
argument_list|,
name|def
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free all storage associated with the problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
if|if
condition|(
name|dflow
operator|->
name|block_info
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dflow
operator|->
name|block_info_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|use
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|def
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|block_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dflow
operator|->
name|problem_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|df_lr_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_info
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Live Registers:\n"
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|df_lr_bb_info
modifier|*
name|bb_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|df_print_bb_index
argument_list|(
name|bb
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  in  \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  use \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|use
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  def \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|def
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  out \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All of the information associated with every instance of the problem.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_LR
init|=
block|{
name|DF_LR
block|,
comment|/* Problem id.  */
name|DF_BACKWARD
block|,
comment|/* Direction.  */
name|df_lr_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|NULL
block|,
comment|/* Reset global information.  */
name|df_lr_free_bb_info
block|,
comment|/* Free basic block info.  */
name|df_lr_local_compute
block|,
comment|/* Local compute function.  */
name|df_lr_init
block|,
comment|/* Init the solution specific data.  */
name|df_iterative_dataflow
block|,
comment|/* Iterative solver.  */
name|df_lr_confluence_0
block|,
comment|/* Confluence operator 0.  */
name|df_lr_confluence_n
block|,
comment|/* Confluence operator n.  */
name|df_lr_transfer_function
block|,
comment|/* Transfer function.  */
name|NULL
block|,
comment|/* Finalize function.  */
name|df_lr_free
block|,
comment|/* Free all of the problem information.  */
name|df_lr_dump
block|,
comment|/* Debugging.  */
name|NULL
block|,
comment|/* Dependent problem.  */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_lr_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_LR
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    UNINITIALIZED REGISTERS     Find the set of uses for registers that are reachable from the entry    block without passing thru a definition.  In and out bitvectors are built    for each basic block.  The regnum is used to index into these sets.    See df.h for details. ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Get basic block info.  */
end_comment

begin_function
name|struct
name|df_ur_bb_info
modifier|*
name|df_ur_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|df_ur_bb_info
operator|*
operator|)
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
parameter_list|)
block|{
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
operator|=
name|bb_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_free_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|vbb_info
parameter_list|)
block|{
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_ur_bb_info
operator|*
operator|)
name|vbb_info
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate or reset bitmaps for DFLOW blocks. The solution bits are    not touched unless the block is new.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_pool
condition|)
name|dflow
operator|->
name|block_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_ur_block pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_ur_bb_info
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_rescan
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_ur_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_ur_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|kill
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|gen
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|in
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|out
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute local uninitialized register info for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_bb_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_block
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
comment|/* Only the last def counts.  */
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|seen_in_insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
operator|(
name|DF_REF_MUST_CLOBBER
operator||
name|DF_REF_MAY_CLOBBER
operator|)
condition|)
block|{
comment|/* Only must clobbers for the entire reg destroy the 		     value.  */
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_MUST_CLOBBER
operator|)
operator|&&
operator|(
operator|!
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
name|bitmap_ior_into
argument_list|(
name|seen_in_block
argument_list|,
name|seen_in_insn
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|seen_in_insn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|seen_in_block
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute local uninitialized register info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bitmap
name|rescan_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|df_set_seen
argument_list|()
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|rescan_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_ur_bb_local_compute
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
name|df_unset_seen
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the solution vectors.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_init
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Or in the stack regs, hard regs and early clobber regs into the the    ur_in sets of all of the blocks.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_local_finalize
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|dataflow
modifier|*
name|lr_dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_LR
index|]
decl_stmt|;
name|bitmap
name|tmp
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_lr_bb_info
modifier|*
name|bb_lr_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|lr_dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
comment|/* No register may reach a location where it is not used.  Thus 	 we trim the rr result to the places where it is used.  */
name|bitmap_and_into
argument_list|(
name|bb_info
operator|->
name|in
argument_list|,
name|bb_lr_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|bb_lr_info
operator|->
name|out
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Hard registers may still stick in the ur_out set, but not 	 be in the ur_in set, if their only mention was in a call 	 in this block.  This is because a call kills in the lr 	 problem but does not kill in the ur problem.  To clean 	 this up, we execute the transfer function on the lr_in 	 set and then use that to knock bits out of ur_out.  */
name|bitmap_ior_and_compl
argument_list|(
name|tmp
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|,
name|bb_lr_info
operator|->
name|in
argument_list|,
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Confluence function that ignores fake edges.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_confluence_n
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|bitmap
name|op1
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|->
name|in
decl_stmt|;
name|bitmap
name|op2
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
operator|->
name|out
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
return|return;
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer function.  */
end_comment

begin_function
specifier|static
name|bool
name|df_ur_transfer_function
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap
name|in
init|=
name|bb_info
operator|->
name|in
decl_stmt|;
name|bitmap
name|out
init|=
name|bb_info
operator|->
name|out
decl_stmt|;
name|bitmap
name|gen
init|=
name|bb_info
operator|->
name|gen
decl_stmt|;
name|bitmap
name|kill
init|=
name|bb_info
operator|->
name|kill
decl_stmt|;
return|return
name|bitmap_ior_and_compl
argument_list|(
name|out
argument_list|,
name|gen
argument_list|,
name|in
argument_list|,
name|kill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free all storage associated with the problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
if|if
condition|(
name|dflow
operator|->
name|block_info
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dflow
operator|->
name|block_info_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|block_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ur_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_info
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Undefined regs:\n"
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|df_ur_bb_info
modifier|*
name|bb_info
init|=
name|df_ur_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|df_print_bb_index
argument_list|(
name|bb
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  in  \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  gen \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  kill\t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  out \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All of the information associated with every instance of the problem.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_UR
init|=
block|{
name|DF_UR
block|,
comment|/* Problem id.  */
name|DF_FORWARD
block|,
comment|/* Direction.  */
name|df_ur_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|NULL
block|,
comment|/* Reset global information.  */
name|df_ur_free_bb_info
block|,
comment|/* Free basic block info.  */
name|df_ur_local_compute
block|,
comment|/* Local compute function.  */
name|df_ur_init
block|,
comment|/* Init the solution specific data.  */
name|df_iterative_dataflow
block|,
comment|/* Iterative solver.  */
name|NULL
block|,
comment|/* Confluence operator 0.  */
name|df_ur_confluence_n
block|,
comment|/* Confluence operator n.  */
name|df_ur_transfer_function
block|,
comment|/* Transfer function.  */
name|df_ur_local_finalize
block|,
comment|/* Finalize function.  */
name|df_ur_free
block|,
comment|/* Free all of the problem information.  */
name|df_ur_dump
block|,
comment|/* Debugging.  */
name|df_lr_add_problem
block|,
comment|/* Dependent problem.  */
literal|0
comment|/* Changeable flags.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_ur_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_UR
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    UNINITIALIZED REGISTERS WITH EARLYCLOBBER     Find the set of uses for registers that are reachable from the entry    block without passing thru a definition.  In and out bitvectors are built    for each basic block.  The regnum is used to index into these sets.    See df.h for details.     This is a variant of the UR problem above that has a lot of special    features just for the register allocation phase.  This problem    should go a away if someone would fix the interference graph.     ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Private data used to compute the solution for this problem.  These    data structures are not accessible outside of this module.  */
end_comment

begin_struct
struct|struct
name|df_urec_problem_data
block|{
name|bool
name|earlyclobbers_found
decl_stmt|;
comment|/* True if any instruction contains an 				   earlyclobber.  */
ifdef|#
directive|ifdef
name|STACK_REGS
name|bitmap
name|stack_regs
decl_stmt|;
comment|/* Registers that may be allocated to a STACK_REGS.  */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Get basic block info.  */
end_comment

begin_function
name|struct
name|df_urec_bb_info
modifier|*
name|df_urec_get_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
expr|struct
name|df_urec_bb_info
operator|*
operator|)
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_set_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
parameter_list|)
block|{
name|dflow
operator|->
name|block_info
index|[
name|index
index|]
operator|=
name|bb_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_free_bb_info
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|vbb_info
parameter_list|)
block|{
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_urec_bb_info
operator|*
operator|)
name|vbb_info
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|earlyclobber
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate or reset bitmaps for DFLOW blocks. The solution bits are    not touched unless the block is new.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|df_urec_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_urec_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_pool
condition|)
name|dflow
operator|->
name|block_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_urec_block pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_urec_bb_info
argument_list|)
argument_list|,
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|problem_data
condition|)
block|{
name|problem_data
operator|=
name|XNEW
argument_list|(
expr|struct
name|df_urec_problem_data
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|problem_data
operator|=
name|problem_data
expr_stmt|;
block|}
name|problem_data
operator|->
name|earlyclobbers_found
operator|=
name|false
expr_stmt|;
name|df_grow_bb_info
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_rescan
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|earlyclobber
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bb_info
operator|=
operator|(
expr|struct
name|df_urec_bb_info
operator|*
operator|)
name|pool_alloc
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|df_urec_set_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|kill
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|gen
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|in
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|out
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bb_info
operator|->
name|earlyclobber
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The function modifies local info for register REG being changed in    SETTER.  DATA is used to pass the current basic block info.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_mark_reg_change
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|endregno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_urec_bb_info
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return;
name|endregno
operator|=
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|endregno
operator|+=
name|hard_regno_nregs
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|bitmap_clear_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Classes of registers which could be early clobbered in the current    insn.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|earlyclobber_regclass
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This function finds and stores register classes that could be early    clobbered in INSN.  If any earlyclobber classes are found, the function    returns TRUE, in all other cases it returns FALSE.  */
end_comment

begin_function
specifier|static
name|bool
name|df_urec_check_earlyclobber
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|opno
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|VEC_truncate
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
name|bool
name|amp_p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|recog_data
operator|.
name|constraints
index|[
name|opno
index|]
decl_stmt|;
name|class
operator|=
name|NO_REGS
expr_stmt|;
name|amp_p
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'!'
case|:
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'m'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'V'
case|:
case|case
literal|'o'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'s'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'X'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* These don't say anything we care about.  */
break|break;
case|case
literal|'&'
case|:
name|amp_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
case|case
literal|','
case|:
if|if
condition|(
name|amp_p
operator|&&
name|class
operator|!=
name|NO_REGS
condition|)
block|{
name|int
name|rc
decl_stmt|;
name|found
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rc
operator|==
operator|(
name|int
operator|)
name|class
condition|)
goto|goto
name|found_rc
goto|;
block|}
comment|/* We use VEC_quick_push here because 		     earlyclobber_regclass holds no more than 		     N_REG_CLASSES elements. */
name|VEC_quick_push
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
operator|(
name|int
operator|)
name|class
argument_list|)
expr_stmt|;
name|found_rc
label|:
empty_stmt|;
block|}
name|amp_p
operator|=
name|false
expr_stmt|;
name|class
operator|=
name|NO_REGS
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|class
operator|=
name|GENERAL_REGS
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|REG_CLASS_FROM_CONSTRAINT
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|+=
name|CONSTRAINT_LEN
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* The function checks that pseudo-register *X has a class    intersecting with the class of pseudo-register could be early    clobbered in the same insn.     This function is a no-op if earlyclobber_regclass is empty.      Reload can assign the same hard register to uninitialized    pseudo-register and early clobbered pseudo-register in an insn if    the pseudo-register is used first time in given BB and not lived at    the BB start.  To prevent this we don't change life information for    such pseudo-registers.  */
end_comment

begin_function
specifier|static
name|int
name|df_urec_mark_reg_use_for_earlyclobber
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|reg_class
name|pref_class
decl_stmt|,
name|alt_class
decl_stmt|;
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
operator|(
expr|struct
name|df_urec_bb_info
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
operator|*
name|x
argument_list|)
operator|&&
name|REGNO
argument_list|(
operator|*
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|rc
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
operator|*
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|,
name|regno
argument_list|)
operator|||
name|bitmap_bit_p
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
name|pref_class
operator|=
name|reg_preferred_class
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|alt_class
operator|=
name|reg_alternate_class
argument_list|(
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|int
argument_list|,
name|earlyclobber_regclass
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_classes_intersect_p
argument_list|(
name|rc
argument_list|,
name|pref_class
argument_list|)
operator|||
operator|(
name|rc
operator|!=
name|NO_REGS
operator|&&
name|reg_classes_intersect_p
argument_list|(
name|rc
argument_list|,
name|alt_class
argument_list|)
operator|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|earlyclobber
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function processes all pseudo-registers in *X with the aid of    previous function.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_mark_reg_use_for_earlyclobber_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|for_each_rtx
argument_list|(
name|x
argument_list|,
name|df_urec_mark_reg_use_for_earlyclobber
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute local uninitialized register info for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_bb_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|df_urec_mark_reg_change
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|df_urec_check_earlyclobber
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|struct
name|df_urec_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_urec_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|problem_data
operator|->
name|earlyclobbers_found
operator|=
name|true
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|df_urec_mark_reg_use_for_earlyclobber_1
argument_list|,
name|bb_info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute local uninitialized register info.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_local_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bitmap
name|rescan_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
name|int
name|i
decl_stmt|;
name|HARD_REG_SET
name|zero
decl_stmt|,
name|stack_hard_regs
decl_stmt|,
name|used
decl_stmt|;
name|struct
name|df_urec_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_urec_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
comment|/* Any register that MAY be allocated to a register stack (like the      387) is treated poorly.  Each such register is marked as being      live everywhere.  This keeps the register allocator and the      subsequent passes from doing anything useful with these values.       FIXME: This seems like an incredibly poor idea.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|stack_hard_regs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|stack_hard_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|problem_data
operator|->
name|stack_regs
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|stack_hard_regs
argument_list|)
expr_stmt|;
name|GO_IF_HARD_REG_EQUAL
argument_list|(
name|used
argument_list|,
name|zero
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|problem_data
operator|->
name|stack_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|skip
label|:
empty_stmt|;
block|}
endif|#
directive|endif
comment|/* We know that earlyclobber_regclass holds no more than     N_REG_CLASSES elements.  See df_urec_check_earlyclobber.  */
name|earlyclobber_regclass
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|N_REG_CLASSES
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|rescan_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_urec_bb_local_compute
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|earlyclobber_regclass
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the solution vectors.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_init
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Or in the stack regs, hard regs and early clobber regs into the the    ur_in sets of all of the blocks.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_local_finalize
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|dataflow
modifier|*
name|lr_dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_LR
index|]
decl_stmt|;
name|bitmap
name|tmp
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|struct
name|df_urec_problem_data
modifier|*
name|problem_data
init|=
operator|(
expr|struct
name|df_urec_problem_data
operator|*
operator|)
name|dflow
operator|->
name|problem_data
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_lr_bb_info
modifier|*
name|bb_lr_info
init|=
name|df_lr_get_bb_info
argument_list|(
name|lr_dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_index
operator|!=
name|ENTRY_BLOCK
operator|&&
name|bb_index
operator|!=
name|EXIT_BLOCK
condition|)
block|{
if|if
condition|(
name|problem_data
operator|->
name|earlyclobbers_found
condition|)
name|bitmap_ior_into
argument_list|(
name|bb_info
operator|->
name|in
argument_list|,
name|bb_info
operator|->
name|earlyclobber
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
comment|/* We can not use the same stack register for uninitialized 	     pseudo-register and another living pseudo-register 	     because if the uninitialized pseudo-register dies, 	     subsequent pass reg-stack will be confused (it will 	     believe that the other register dies).  */
name|bitmap_ior_into
argument_list|(
name|bb_info
operator|->
name|in
argument_list|,
name|problem_data
operator|->
name|stack_regs
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|problem_data
operator|->
name|stack_regs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* No register may reach a location where it is not used.  Thus 	 we trim the rr result to the places where it is used.  */
name|bitmap_and_into
argument_list|(
name|bb_info
operator|->
name|in
argument_list|,
name|bb_lr_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|bb_lr_info
operator|->
name|out
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Hard registers may still stick in the ur_out set, but not 	 be in the ur_in set, if their only mention was in a call 	 in this block.  This is because a call kills in the lr 	 problem but does not kill in the rr problem.  To clean 	 this up, we execute the transfer function on the lr_in 	 set and then use that to knock bits out of ur_out.  */
name|bitmap_ior_and_compl
argument_list|(
name|tmp
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|,
name|bb_lr_info
operator|->
name|in
argument_list|,
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|bitmap_and_into
argument_list|(
name|bb_info
operator|->
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|STACK_REGS
name|BITMAP_FREE
argument_list|(
name|problem_data
operator|->
name|stack_regs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Confluence function that ignores fake edges.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_confluence_n
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|bitmap
name|op1
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
operator|->
name|in
decl_stmt|;
name|bitmap
name|op2
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
operator|->
name|out
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
return|return;
name|bitmap_ior_into
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transfer function.  */
end_comment

begin_function
specifier|static
name|bool
name|df_urec_transfer_function
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|bitmap
name|in
init|=
name|bb_info
operator|->
name|in
decl_stmt|;
name|bitmap
name|out
init|=
name|bb_info
operator|->
name|out
decl_stmt|;
name|bitmap
name|gen
init|=
name|bb_info
operator|->
name|gen
decl_stmt|;
name|bitmap
name|kill
init|=
name|bb_info
operator|->
name|kill
decl_stmt|;
return|return
name|bitmap_ior_and_compl
argument_list|(
name|out
argument_list|,
name|gen
argument_list|,
name|in
argument_list|,
name|kill
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free all storage associated with the problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
if|if
condition|(
name|dflow
operator|->
name|block_info
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dflow
operator|->
name|block_info_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb_info
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bb_info
operator|->
name|earlyclobber
argument_list|)
expr_stmt|;
block|}
block|}
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_info_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|block_info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
operator|->
name|problem_data
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|df_urec_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|!
name|dflow
operator|->
name|block_info
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Undefined regs:\n"
argument_list|)
expr_stmt|;
name|FOR_ALL_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|struct
name|df_urec_bb_info
modifier|*
name|bb_info
init|=
name|df_urec_get_bb_info
argument_list|(
name|dflow
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|df_print_bb_index
argument_list|(
name|bb
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bb_info
operator|->
name|in
condition|)
continue|continue;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  in  \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  gen \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|gen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  kill\t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|kill
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  ec\t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|earlyclobber
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  out \t"
argument_list|)
expr_stmt|;
name|dump_bitmap
argument_list|(
name|file
argument_list|,
name|bb_info
operator|->
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All of the information associated with every instance of the problem.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_UREC
init|=
block|{
name|DF_UREC
block|,
comment|/* Problem id.  */
name|DF_FORWARD
block|,
comment|/* Direction.  */
name|df_urec_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|NULL
block|,
comment|/* Reset global information.  */
name|df_urec_free_bb_info
block|,
comment|/* Free basic block info.  */
name|df_urec_local_compute
block|,
comment|/* Local compute function.  */
name|df_urec_init
block|,
comment|/* Init the solution specific data.  */
name|df_iterative_dataflow
block|,
comment|/* Iterative solver.  */
name|NULL
block|,
comment|/* Confluence operator 0.  */
name|df_urec_confluence_n
block|,
comment|/* Confluence operator n.  */
name|df_urec_transfer_function
block|,
comment|/* Transfer function.  */
name|df_urec_local_finalize
block|,
comment|/* Finalize function.  */
name|df_urec_free
block|,
comment|/* Free all of the problem information.  */
name|df_urec_dump
block|,
comment|/* Debugging.  */
name|df_lr_add_problem
block|,
comment|/* Dependent problem.  */
literal|0
comment|/* Changeable flags.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_urec_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_UREC
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------------    CREATE DEF_USE (DU) and / or USE_DEF (UD) CHAINS     Link either the defs to the uses and / or the uses to the defs.     These problems are set up like the other dataflow problems so that    they nicely fit into the framework.  They are much simpler and only    involve a single traversal of instructions and an examination of    the reaching defs information (the dependent problem). ----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Create def-use or use-def chains.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Wholesale destruction of the old chains.  */
if|if
condition|(
name|dflow
operator|->
name|block_pool
condition|)
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"df_chain_chain_block pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|df_link
argument_list|)
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_DU_CHAIN
condition|)
block|{
if|if
condition|(
operator|!
name|df
operator|->
name|def_info
operator|.
name|refs_organized
condition|)
name|df_reorganize_refs
argument_list|(
operator|&
name|df
operator|->
name|def_info
argument_list|)
expr_stmt|;
comment|/* Clear out the pointers from the refs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DF_DEFS_SIZE
argument_list|(
name|df
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
init|=
name|df
operator|->
name|def_info
operator|.
name|refs
index|[
name|i
index|]
decl_stmt|;
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_UD_CHAIN
condition|)
block|{
if|if
condition|(
operator|!
name|df
operator|->
name|use_info
operator|.
name|refs_organized
condition|)
name|df_reorganize_refs
argument_list|(
operator|&
name|df
operator|->
name|use_info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DF_USES_SIZE
argument_list|(
name|df
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
init|=
name|df
operator|->
name|use_info
operator|.
name|refs
index|[
name|i
index|]
decl_stmt|;
name|DF_REF_CHAIN
argument_list|(
name|ref
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Reset all def_use and use_def chains in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_insn_reset
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|df_insn_info
modifier|*
name|insn_info
init|=
name|NULL
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
name|uid
operator|<
name|df
operator|->
name|insns_size
condition|)
name|insn_info
operator|=
name|DF_INSN_UID_GET
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_info
condition|)
block|{
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_DU_CHAIN
condition|)
block|{
name|ref
operator|=
name|insn_info
operator|->
name|defs
expr_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|ref
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_UD_CHAIN
condition|)
block|{
name|ref
operator|=
name|insn_info
operator|->
name|uses
expr_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
name|ref
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Reset all def_use and use_def chains in basic block.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_bb_reset
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
comment|/* Some one deleted the basic block out from under us.  */
if|if
condition|(
operator|!
name|bb
condition|)
return|return;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Record defs within INSN.  */
name|df_chain_insn_reset
argument_list|(
name|dflow
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get rid of any chains in artificial uses or defs.  */
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_DU_CHAIN
condition|)
block|{
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
while|while
condition|(
name|def
condition|)
block|{
name|def
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|def
operator|=
name|def
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_UD_CHAIN
condition|)
block|{
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
name|use
operator|=
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
while|while
condition|(
name|use
condition|)
block|{
name|use
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|use
operator|=
name|use
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Reset all of the chains when the set of basic blocks changes.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_reset
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_clear
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_clear
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_chain_bb_reset
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|dflow
operator|->
name|block_pool
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the chains for a list of USEs.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_create_bb_process_use
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|local_rd
parameter_list|,
name|struct
name|df_ref
modifier|*
name|use
parameter_list|,
name|enum
name|df_ref_flags
name|top_flag
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|def_index
decl_stmt|;
while|while
condition|(
name|use
condition|)
block|{
comment|/* Do not want to go through this for an uninitialized var.  */
name|unsigned
name|int
name|uregno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|uregno
argument_list|)
operator|->
name|n_refs
decl_stmt|;
if|if
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|top_flag
operator|==
operator|(
name|DF_REF_FLAGS
argument_list|(
name|use
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
condition|)
block|{
name|unsigned
name|int
name|first_index
init|=
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|uregno
argument_list|)
operator|->
name|begin
decl_stmt|;
name|unsigned
name|int
name|last_index
init|=
name|first_index
operator|+
name|count
operator|-
literal|1
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|local_rd
argument_list|,
argument|first_index
argument_list|,
argument|def_index
argument_list|,
argument|bi
argument_list|)
block|{
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
if|if
condition|(
name|def_index
operator|>
name|last_index
condition|)
break|break;
name|def
operator|=
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|def_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_DU_CHAIN
condition|)
name|df_chain_create
argument_list|(
name|dflow
argument_list|,
name|def
argument_list|,
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_UD_CHAIN
condition|)
name|df_chain_create
argument_list|(
name|dflow
argument_list|,
name|use
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|use
operator|=
name|use
operator|->
name|next_ref
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reset the storage pool that the def-use or use-def chains have been    allocated in. We do not need to re adjust the pointers in the refs,    these have already been clean out.*/
end_comment

begin_comment
comment|/* Create chains from reaching defs bitmaps for basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_create_bb
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|struct
name|dataflow
modifier|*
name|rd_dflow
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|struct
name|df_rd_bb_info
modifier|*
name|bb_info
init|=
name|df_rd_get_bb_info
argument_list|(
name|rd_dflow
argument_list|,
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|bitmap
name|cpy
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|bitmap_copy
argument_list|(
name|cpy
argument_list|,
name|bb_info
operator|->
name|in
argument_list|)
expr_stmt|;
comment|/* Since we are going forwards, process the artificial uses first      then the artificial defs second.  */
ifdef|#
directive|ifdef
name|EH_USES
comment|/* Create the chains for the artificial uses from the EH_USES at the      beginning of the block.  */
name|df_chain_create_bb_process_use
argument_list|(
name|dflow
argument_list|,
name|cpy
argument_list|,
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb
operator|->
name|index
argument_list|)
argument_list|,
name|DF_REF_AT_TOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
condition|)
block|{
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
condition|)
name|bitmap_clear_range
argument_list|(
name|cpy
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|dregno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|dregno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|cpy
argument_list|,
name|DF_REF_ID
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Process the regular instructions next.  */
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Now scan the uses and link them up with the defs that remain 	 in the cpy vector.  */
name|df_chain_create_bb_process_use
argument_list|(
name|dflow
argument_list|,
name|cpy
argument_list|,
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Since we are going forwards, process the defs second.  This          pass only changes the bits in cpy.  */
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
block|{
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
condition|)
name|bitmap_clear_range
argument_list|(
name|cpy
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|dregno
argument_list|)
operator|->
name|begin
argument_list|,
name|DF_REG_DEF_GET
argument_list|(
name|df
argument_list|,
name|dregno
argument_list|)
operator|->
name|n_refs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
operator|(
name|DF_REF_MUST_CLOBBER
operator||
name|DF_REF_MAY_CLOBBER
operator|)
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|cpy
argument_list|,
name|DF_REF_ID
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create the chains for the artificial uses of the hard registers      at the end of the block.  */
name|df_chain_create_bb_process_use
argument_list|(
name|dflow
argument_list|,
name|cpy
argument_list|,
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb
operator|->
name|index
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create def-use chains from reaching use bitmaps for basic blocks    in BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_finalize
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|struct
name|dataflow
modifier|*
name|rd_dflow
init|=
name|df
operator|->
name|problems_by_index
index|[
name|DF_RD
index|]
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|all_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_chain_create_bb
argument_list|(
name|dflow
argument_list|,
name|rd_dflow
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free all storage associated with the problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_chain_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|free_alloc_pool
argument_list|(
name|dflow
operator|->
name|block_pool
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|df_chains_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_DU_CHAIN
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Def-use chains:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|df
operator|->
name|def_info
operator|.
name|bitmap_size
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|df_ref
modifier|*
name|def
init|=
name|DF_DEFS_GET
argument_list|(
name|df
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"d%d bb %d luid %d insn %d reg %d "
argument_list|,
name|j
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|def
argument_list|)
argument_list|,
name|DF_REF_INSN
argument_list|(
name|def
argument_list|)
condition|?
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|def
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|DF_REF_INSN
argument_list|(
name|def
argument_list|)
condition|?
name|DF_REF_INSN_UID
argument_list|(
name|def
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|flags
operator|&
name|DF_REF_READ_WRITE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"read/write "
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|DF_REF_CHAIN
argument_list|(
name|def
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_UD_CHAIN
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Use-def chains:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|df
operator|->
name|use_info
operator|.
name|bitmap_size
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|df_ref
modifier|*
name|use
init|=
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|use
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"u%d bb %d luid %d insn %d reg %d "
argument_list|,
name|j
argument_list|,
name|DF_REF_BBNO
argument_list|(
name|use
argument_list|)
argument_list|,
name|DF_REF_INSN
argument_list|(
name|use
argument_list|)
condition|?
name|DF_INSN_LUID
argument_list|(
name|df
argument_list|,
name|DF_REF_INSN
argument_list|(
name|use
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|DF_REF_INSN
argument_list|(
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|j
argument_list|)
argument_list|)
condition|?
name|DF_REF_INSN_UID
argument_list|(
name|DF_USES_GET
argument_list|(
name|df
argument_list|,
name|j
argument_list|)
argument_list|)
else|:
operator|-
literal|1
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|->
name|flags
operator|&
name|DF_REF_READ_WRITE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"read/write "
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|->
name|flags
operator|&
name|DF_REF_STRIPPED
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"stripped "
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
operator|->
name|flags
operator|&
name|DF_REF_IN_NOTE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"note "
argument_list|)
expr_stmt|;
name|df_chain_dump
argument_list|(
name|DF_REF_CHAIN
argument_list|(
name|use
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_CHAIN
init|=
block|{
name|DF_CHAIN
block|,
comment|/* Problem id.  */
name|DF_NONE
block|,
comment|/* Direction.  */
name|df_chain_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|df_chain_reset
block|,
comment|/* Reset global information.  */
name|NULL
block|,
comment|/* Free basic block info.  */
name|NULL
block|,
comment|/* Local compute function.  */
name|NULL
block|,
comment|/* Init the solution specific data.  */
name|NULL
block|,
comment|/* Iterative solver.  */
name|NULL
block|,
comment|/* Confluence operator 0.  */
name|NULL
block|,
comment|/* Confluence operator n.  */
name|NULL
block|,
comment|/* Transfer function.  */
name|df_chain_finalize
block|,
comment|/* Finalize function.  */
name|df_chain_free
block|,
comment|/* Free all of the problem information.  */
name|df_chains_dump
block|,
comment|/* Debugging.  */
name|df_rd_add_problem
block|,
comment|/* Dependent problem.  */
literal|0
comment|/* Changeable flags.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_chain_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_CHAIN
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------    REGISTER INFORMATION     This pass properly computes REG_DEAD and REG_UNUSED notes.     If the DF_RI_LIFE flag is set the following vectors containing    information about register usage are properly set: REG_N_REFS,    REG_N_DEATHS, REG_N_SETS, REG_LIVE_LENGTH, REG_N_CALLS_CROSSED,    REG_N_THROWING_CALLS_CROSSED and REG_BASIC_BLOCK.     ----------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
end_ifdef

begin_function
specifier|static
name|void
name|print_note
parameter_list|(
name|char
modifier|*
name|prefix
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|note
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %d "
argument_list|,
name|prefix
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|stderr
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate the lifetime information.  */
end_comment

begin_function
specifier|static
name|void
name|df_ri_alloc
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|blocks_to_rescan
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Reset all the data we'll collect.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|=
name|DF_REG_DEF_COUNT
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|=
name|DF_REG_USE_COUNT
argument_list|(
name|df
argument_list|,
name|i
argument_list|)
operator|+
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_THROWING_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_FREQ
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* After reg-stack, the x86 floating point stack regs are difficult to    analyze because of all of the pushes, pops and rotations.  Thus, we    just leave the notes alone. */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|df_ignore_stack_reg
parameter_list|(
name|int
name|regno
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|STACK_REGS
return|return
operator|(
name|regstack_completed
operator|&&
name|IN_RANGE
argument_list|(
name|regno
argument_list|,
name|FIRST_STACK_REG
argument_list|,
name|LAST_STACK_REG
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
name|false
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Remove all of the REG_DEAD or REG_UNUSED notes from INSN.  */
end_comment

begin_function
specifier|static
name|void
name|df_kill_notes
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|rtx
modifier|*
name|pprev
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|link
init|=
operator|*
name|pprev
decl_stmt|;
while|while
condition|(
name|link
condition|)
block|{
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
name|REG_DEAD
case|:
if|if
condition|(
name|flags
operator|&
name|DF_RI_LIFE
condition|)
if|if
condition|(
name|df_ignore_stack_reg
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|++
expr_stmt|;
comment|/* Fallthru */
case|case
name|REG_UNUSED
case|:
if|if
condition|(
operator|!
name|df_ignore_stack_reg
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|print_note
argument_list|(
literal|"deleting: "
argument_list|,
name|insn
argument_list|,
name|link
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_EXPR_LIST_node
argument_list|(
name|link
argument_list|)
expr_stmt|;
operator|*
name|pprev
operator|=
name|link
operator|=
name|next
expr_stmt|;
block|}
break|break;
default|default:
name|pprev
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|link
operator|=
operator|*
name|pprev
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set the REG_UNUSED notes for the multiword hardreg defs in INSN    based on the bits in LIVE.  Do not generate notes for registers in    artificial uses.  DO_NOT_GEN is updated so that REG_DEAD notes are    not generated if the reg is both read and written by the    instruction. */
end_comment

begin_function
specifier|static
name|void
name|df_set_unused_notes_for_mw
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|df_mw_hardreg
modifier|*
name|mws
parameter_list|,
name|bitmap
name|live
parameter_list|,
name|bitmap
name|do_not_gen
parameter_list|,
name|bitmap
name|artificial_uses
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bool
name|all_dead
init|=
name|true
decl_stmt|;
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mw unused looking at %d\n"
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|df_ref_debug
argument_list|(
name|regs
operator|->
name|ref
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|regs
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
operator|)
operator|||
name|bitmap_bit_p
argument_list|(
name|artificial_uses
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|all_dead
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|regs
operator|=
name|regs
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|all_dead
condition|)
block|{
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
operator|*
name|DF_REF_LOC
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|print_note
argument_list|(
literal|"adding 1: "
argument_list|,
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bitmap_set_bit
argument_list|(
name|do_not_gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Only do this if the value is totally dead.  */
if|if
condition|(
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|REG_N_DEATHS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
while|while
condition|(
name|regs
condition|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
init|=
name|regs
operator|->
name|ref
decl_stmt|;
name|regno
operator|=
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|artificial_uses
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|print_note
argument_list|(
literal|"adding 2: "
argument_list|,
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bitmap_set_bit
argument_list|(
name|do_not_gen
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regs
operator|=
name|regs
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set the REG_DEAD notes for the multiword hardreg use in INSN based    on the bits in LIVE.  DO_NOT_GEN is used to keep REG_DEAD notes    from being set if the instruction both reads and writes the    register.  */
end_comment

begin_function
specifier|static
name|void
name|df_set_dead_notes_for_mw
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|df_mw_hardreg
modifier|*
name|mws
parameter_list|,
name|bitmap
name|live
parameter_list|,
name|bitmap
name|do_not_gen
parameter_list|,
name|bitmap
name|artificial_uses
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|bool
name|all_dead
init|=
name|true
decl_stmt|;
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mw looking at %d\n"
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
argument_list|)
expr_stmt|;
name|df_ref_debug
argument_list|(
name|regs
operator|->
name|ref
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|regs
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
operator|)
operator|||
name|bitmap_bit_p
argument_list|(
name|artificial_uses
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|all_dead
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|regs
operator|=
name|regs
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|all_dead
condition|)
block|{
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|do_not_gen
argument_list|,
name|regno
argument_list|)
condition|)
block|{
comment|/* Add a dead note for the entire multi word register.  */
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
operator|*
name|DF_REF_LOC
argument_list|(
name|regs
operator|->
name|ref
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|print_note
argument_list|(
literal|"adding 1: "
argument_list|,
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
while|while
condition|(
name|regs
condition|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
init|=
name|regs
operator|->
name|ref
decl_stmt|;
name|regno
operator|=
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|regs
operator|=
name|regs
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|df_link
modifier|*
name|regs
init|=
name|mws
operator|->
name|regs
decl_stmt|;
while|while
condition|(
name|regs
condition|)
block|{
name|struct
name|df_ref
modifier|*
name|ref
init|=
name|regs
operator|->
name|ref
decl_stmt|;
name|regno
operator|=
name|DF_REF_REGNO
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|artificial_uses
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|do_not_gen
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|regno_reg_rtx
index|[
name|regno
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DF_RI_LIFE
condition|)
name|REG_N_DEATHS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|print_note
argument_list|(
literal|"adding 2: "
argument_list|,
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|regs
operator|=
name|regs
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create a REG_UNUSED note if necessary for DEF in INSN updating LIVE    and DO_NOT_GEN.  Do not generate notes for registers in artificial    uses.  */
end_comment

begin_function
specifier|static
name|void
name|df_create_unused_note
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|struct
name|df_ref
modifier|*
name|def
parameter_list|,
name|bitmap
name|live
parameter_list|,
name|bitmap
name|do_not_gen
parameter_list|,
name|bitmap
name|artificial_uses
parameter_list|,
name|bitmap
name|local_live
parameter_list|,
name|bitmap
name|local_processed
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|luid
parameter_list|)
block|{
name|unsigned
name|int
name|dregno
init|=
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  regular looking at def "
argument_list|)
expr_stmt|;
name|df_ref_debug
argument_list|(
name|def
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|dregno
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
comment|/* If we have seen this regno, then it has already been 	     processed correctly with the per insn increment.  If we 	     have not seen it we need to add the length from here to 	     the end of the block to the live length.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|local_processed
argument_list|,
name|dregno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
condition|)
name|bitmap_clear_bit
argument_list|(
name|local_live
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bitmap_set_bit
argument_list|(
name|local_processed
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|dregno
argument_list|)
operator|+=
name|luid
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_MW_HARDREG
operator|)
operator|)
operator|&&
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|artificial_uses
argument_list|,
name|dregno
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|df_ignore_stack_reg
argument_list|(
name|dregno
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|GET_CODE
argument_list|(
operator|*
name|DF_REF_LOC
argument_list|(
name|def
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
operator|*
name|DF_REF_LOC
argument_list|(
name|def
argument_list|)
argument_list|)
else|:
operator|*
name|DF_REF_LOC
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|print_note
argument_list|(
literal|"adding 3: "
argument_list|,
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|REG_N_DEATHS
argument_list|(
name|dregno
argument_list|)
operator|++
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|dregno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DF_RI_LIFE
operator|)
operator|&&
operator|(
name|dregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|REG_FREQ
argument_list|(
name|dregno
argument_list|)
operator|+=
name|REG_FREQ_FROM_BB
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|dregno
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|dregno
argument_list|)
operator|=
name|bb
operator|->
name|index
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|dregno
argument_list|)
operator|!=
name|bb
operator|->
name|index
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|dregno
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
operator|(
name|DF_REF_MUST_CLOBBER
operator|+
name|DF_REF_MAY_CLOBBER
operator|)
operator|)
condition|)
name|bitmap_set_bit
argument_list|(
name|do_not_gen
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
comment|/* Kill this register if it is not a subreg store.  */
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_PARTIAL
operator|)
condition|)
name|bitmap_clear_bit
argument_list|(
name|live
argument_list|,
name|dregno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recompute the REG_DEAD and REG_UNUSED notes and compute register    info: lifetime, bb, and number of defs and uses for basic block    BB.  The three bitvectors are scratch regs used here.  */
end_comment

begin_function
specifier|static
name|void
name|df_ri_bb_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|unsigned
name|int
name|bb_index
parameter_list|,
name|bitmap
name|live
parameter_list|,
name|bitmap
name|do_not_gen
parameter_list|,
name|bitmap
name|artificial_uses
parameter_list|,
name|bitmap
name|local_live
parameter_list|,
name|bitmap
name|local_processed
parameter_list|,
name|bitmap
name|setjumps_crossed
parameter_list|)
block|{
name|struct
name|df
modifier|*
name|df
init|=
name|dflow
operator|->
name|df
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|def
decl_stmt|;
name|struct
name|df_ref
modifier|*
name|use
decl_stmt|;
name|int
name|luid
init|=
literal|0
decl_stmt|;
name|bitmap_copy
argument_list|(
name|live
argument_list|,
name|df_get_live_out
argument_list|(
name|df
argument_list|,
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|artificial_uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
comment|/* Process the regs live at the end of the block.  Mark them as 	 not local to any one basic block.  */
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
block|}
comment|/* Process the artificial defs and uses at the bottom of the block      to begin processing.  */
for|for
control|(
name|def
operator|=
name|df_get_artificial_defs
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|==
literal|0
condition|)
name|bitmap_clear_bit
argument_list|(
name|live
argument_list|,
name|DF_REF_REGNO
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|use
operator|=
name|df_get_artificial_uses
argument_list|(
name|df
argument_list|,
name|bb_index
argument_list|)
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
if|if
condition|(
operator|(
name|DF_REF_FLAGS
argument_list|(
name|use
argument_list|)
operator|&
name|DF_REF_AT_TOP
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Notes are not generated for any of the artificial registers 	   at the bottom of the block.  */
name|bitmap_set_bit
argument_list|(
name|artificial_uses
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|FOR_BB_INSNS_REVERSE
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
name|unsigned
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|df_mw_hardreg
modifier|*
name|mws
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
comment|/* Increment the live_length for all of the registers that 	     are are referenced in this block and live at this 	     particular point.  */
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|local_live
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
name|luid
operator|++
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|do_not_gen
argument_list|)
expr_stmt|;
name|df_kill_notes
argument_list|(
name|insn
argument_list|,
name|dflow
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* Process the defs.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|bool
name|can_throw
init|=
name|can_throw_internal
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|bool
name|set_jump
init|=
operator|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|can_throw
condition|)
name|REG_N_THROWING_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
comment|/* We have a problem with any pseudoreg that lives 		     across the setjmp.  ANSI says that if a user 		     variable does not change in value between the 		     setjmp and the longjmp, then the longjmp 		     preserves it.  This includes longjmp from a place 		     where the pseudo appears dead.  (In principle, 		     the value still exists if it is in scope.)  If 		     the pseudo goes in a hard reg, some other value 		     may occupy that hard reg where this pseudo is 		     dead, thus clobbering the pseudo.  Conclusion: 		     such a pseudo must not go in a hard reg.  */
if|if
condition|(
name|set_jump
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|bitmap_set_bit
argument_list|(
name|setjumps_crossed
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We only care about real sets for calls.  Clobbers only 	     may clobber and cannot be depended on.  */
for|for
control|(
name|mws
operator|=
name|DF_INSN_UID_MWS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|mws
condition|;
name|mws
operator|=
name|mws
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|mws
operator|->
name|type
operator|==
name|DF_REF_REG_DEF
operator|)
operator|&&
operator|!
name|df_ignore_stack_reg
argument_list|(
name|REGNO
argument_list|(
name|mws
operator|->
name|mw_reg
argument_list|)
argument_list|)
condition|)
name|df_set_unused_notes_for_mw
argument_list|(
name|insn
argument_list|,
name|mws
argument_list|,
name|live
argument_list|,
name|do_not_gen
argument_list|,
name|artificial_uses
argument_list|,
name|dflow
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* All of the defs except the return value are some sort of 	     clobber.  This code is for the return.  */
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
if|if
condition|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|def
argument_list|)
operator|&
operator|(
name|DF_REF_MUST_CLOBBER
operator||
name|DF_REF_MAY_CLOBBER
operator|)
operator|)
condition|)
name|df_create_unused_note
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|,
name|def
argument_list|,
name|live
argument_list|,
name|do_not_gen
argument_list|,
name|artificial_uses
argument_list|,
name|local_live
argument_list|,
name|local_processed
argument_list|,
name|dflow
operator|->
name|flags
argument_list|,
name|luid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Regular insn.  */
for|for
control|(
name|mws
operator|=
name|DF_INSN_UID_MWS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|mws
condition|;
name|mws
operator|=
name|mws
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mws
operator|->
name|type
operator|==
name|DF_REF_REG_DEF
condition|)
name|df_set_unused_notes_for_mw
argument_list|(
name|insn
argument_list|,
name|mws
argument_list|,
name|live
argument_list|,
name|do_not_gen
argument_list|,
name|artificial_uses
argument_list|,
name|dflow
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|def
operator|=
name|DF_INSN_UID_DEFS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next_ref
control|)
name|df_create_unused_note
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|,
name|def
argument_list|,
name|live
argument_list|,
name|do_not_gen
argument_list|,
name|artificial_uses
argument_list|,
name|local_live
argument_list|,
name|local_processed
argument_list|,
name|dflow
operator|->
name|flags
argument_list|,
name|luid
argument_list|)
expr_stmt|;
block|}
comment|/* Process the uses.  */
for|for
control|(
name|mws
operator|=
name|DF_INSN_UID_MWS
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|mws
condition|;
name|mws
operator|=
name|mws
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|mws
operator|->
name|type
operator|!=
name|DF_REF_REG_DEF
operator|)
operator|&&
operator|!
name|df_ignore_stack_reg
argument_list|(
name|REGNO
argument_list|(
name|mws
operator|->
name|mw_reg
argument_list|)
argument_list|)
condition|)
name|df_set_dead_notes_for_mw
argument_list|(
name|insn
argument_list|,
name|mws
argument_list|,
name|live
argument_list|,
name|do_not_gen
argument_list|,
name|artificial_uses
argument_list|,
name|dflow
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|use
operator|=
name|DF_INSN_UID_USES
argument_list|(
name|df
argument_list|,
name|uid
argument_list|)
init|;
name|use
condition|;
name|use
operator|=
name|use
operator|->
name|next_ref
control|)
block|{
name|unsigned
name|int
name|uregno
init|=
name|DF_REF_REGNO
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
operator|)
operator|&&
operator|(
name|uregno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|REG_FREQ
argument_list|(
name|uregno
argument_list|)
operator|+=
name|REG_FREQ_FROM_BB
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|uregno
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|uregno
argument_list|)
operator|=
name|bb
operator|->
name|index
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|uregno
argument_list|)
operator|!=
name|bb
operator|->
name|index
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|uregno
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  regular looking at use "
argument_list|)
expr_stmt|;
name|df_ref_debug
argument_list|(
name|use
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|live
argument_list|,
name|uregno
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|use
argument_list|)
operator|&
name|DF_REF_MW_HARDREG
operator|)
operator|)
operator|&&
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|do_not_gen
argument_list|,
name|uregno
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|bitmap_bit_p
argument_list|(
name|artificial_uses
argument_list|,
name|uregno
argument_list|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|DF_REF_FLAGS
argument_list|(
name|use
argument_list|)
operator|&
name|DF_REF_READ_WRITE
operator|)
operator|)
operator|&&
operator|(
operator|!
name|df_ignore_stack_reg
argument_list|(
name|uregno
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|reg
init|=
name|GET_CODE
argument_list|(
operator|*
name|DF_REF_LOC
argument_list|(
name|use
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
operator|*
name|DF_REF_LOC
argument_list|(
name|use
argument_list|)
argument_list|)
else|:
operator|*
name|DF_REF_LOC
argument_list|(
name|use
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|note
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
name|REG_N_DEATHS
argument_list|(
name|uregno
argument_list|)
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|print_note
argument_list|(
literal|"adding 4: "
argument_list|,
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* This register is now live.  */
name|bitmap_set_bit
argument_list|(
name|live
argument_list|,
name|uregno
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
comment|/* If we have seen this regno, then it has already 		     been processed correctly with the per insn 		     increment.  If we have not seen it we set the bit 		     so that begins to get processed locally.  Note 		     that we don't even get here if the variable was 		     live at the end of the block since just a ref 		     inside the block does not effect the 		     calculations.  */
name|REG_LIVE_LENGTH
argument_list|(
name|uregno
argument_list|)
operator|++
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|local_live
argument_list|,
name|uregno
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|local_processed
argument_list|,
name|uregno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
comment|/* Add the length of the block to all of the registers that were 	 not referenced, but still live in this block.  */
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|bitmap_and_compl_into
argument_list|(
name|live
argument_list|,
name|local_processed
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|+=
name|luid
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|local_processed
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|local_live
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute register info: lifetime, bb, and number of defs and uses.  */
end_comment

begin_function
specifier|static
name|void
name|df_ri_compute
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|bitmap
name|all_blocks
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bitmap
name|blocks_to_scan
parameter_list|)
block|{
name|unsigned
name|int
name|bb_index
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap
name|live
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap
name|do_not_gen
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap
name|artificial_uses
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bitmap
name|local_live
init|=
name|NULL
decl_stmt|;
name|bitmap
name|local_processed
init|=
name|NULL
decl_stmt|;
name|bitmap
name|setjumps_crossed
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|local_live
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|local_processed
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|setjumps_crossed
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REG_DEAD_DEBUGGING
name|df_lr_dump
argument_list|(
name|dflow
operator|->
name|df
operator|->
name|problems_by_index
index|[
name|DF_LR
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|print_rtl_with_bb
argument_list|(
name|stderr
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_scan
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|df_ri_bb_compute
argument_list|(
name|dflow
argument_list|,
name|bb_index
argument_list|,
name|live
argument_list|,
name|do_not_gen
argument_list|,
name|artificial_uses
argument_list|,
name|local_live
argument_list|,
name|local_processed
argument_list|,
name|setjumps_crossed
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|live
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|do_not_gen
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|artificial_uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* See the setjump comment in df_ri_bb_compute.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|setjumps_crossed
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|bi
argument_list|)
block|{
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|local_live
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|local_processed
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|setjumps_crossed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free all storage associated with the problem.  */
end_comment

begin_function
specifier|static
name|void
name|df_ri_free
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|)
block|{
name|free
argument_list|(
name|dflow
operator|->
name|problem_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dflow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|df_ri_dump
parameter_list|(
name|struct
name|dataflow
modifier|*
name|dflow
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|print_rtl_with_bb
argument_list|(
name|file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflow
operator|->
name|flags
operator|&
name|DF_RI_LIFE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Register info:\n"
argument_list|)
expr_stmt|;
name|dump_flow_info
argument_list|(
name|file
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* All of the information associated every instance of the problem.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|df_problem
name|problem_RI
init|=
block|{
name|DF_RI
block|,
comment|/* Problem id.  */
name|DF_NONE
block|,
comment|/* Direction.  */
name|df_ri_alloc
block|,
comment|/* Allocate the problem specific data.  */
name|NULL
block|,
comment|/* Reset global information.  */
name|NULL
block|,
comment|/* Free basic block info.  */
name|df_ri_compute
block|,
comment|/* Local compute function.  */
name|NULL
block|,
comment|/* Init the solution specific data.  */
name|NULL
block|,
comment|/* Iterative solver.  */
name|NULL
block|,
comment|/* Confluence operator 0.  */
name|NULL
block|,
comment|/* Confluence operator n.  */
name|NULL
block|,
comment|/* Transfer function.  */
name|NULL
block|,
comment|/* Finalize function.  */
name|df_ri_free
block|,
comment|/* Free all of the problem information.  */
name|df_ri_dump
block|,
comment|/* Debugging.  */
comment|/* Technically this is only dependent on the live registers problem      but it will produce information if built one of uninitialized      register problems (UR, UREC) is also run.  */
name|df_lr_add_problem
block|,
comment|/* Dependent problem.  */
literal|0
comment|/* Changeable flags.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new DATAFLOW instance and add it to an existing instance    of DF.  The returned structure is what is used to get at the    solution.  */
end_comment

begin_function
name|struct
name|dataflow
modifier|*
name|df_ri_add_problem
parameter_list|(
name|struct
name|df
modifier|*
name|df
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|df_add_problem
argument_list|(
name|df
argument_list|,
operator|&
name|problem_RI
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

end_unit

