begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree lowering pass.  This pass gimplifies the tree representation built    by the C-based front ends.  The structure of gimplified, or    language-independent, trees is dictated by the grammar described in this    file.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Lowering of expressions contributed by Sebastian Pop<s.pop@laposte.net>    Re-written to support lowering of whole function trees, documentation    and miscellaneous cleanups by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"c-pretty-print.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_comment
comment|/*  The gimplification pass converts the language-dependent trees     (ld-trees) emitted by the parser into language-independent trees     (li-trees) that are the target of SSA analysis and transformations.      Language-independent trees are based on the SIMPLE intermediate     representation used in the McCAT compiler framework:      "Designing the McCAT Compiler Based on a Family of Structured     Intermediate Representations,"     L. Hendren, C. Donawa, M. Emami, G. Gao, Justiani, and B. Sridharan,     Proceedings of the 5th International Workshop on Languages and     Compilers for Parallel Computing, no. 757 in Lecture Notes in     Computer Science, New Haven, Connecticut, pp. 406-420,     Springer-Verlag, August 3-5, 1992.      http://www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html      Basically, we walk down gimplifying the nodes that we encounter.  As we     walk back up, we check that they fit our constraints, and copy them     into temporaries if not.  */
end_comment

begin_comment
comment|/* Gimplification of statement trees.  */
end_comment

begin_comment
comment|/* Convert the tree representation of FNDECL from C frontend trees to    GENERIC.  */
end_comment

begin_function
name|void
name|c_genericize
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|FILE
modifier|*
name|dump_orig
decl_stmt|;
name|int
name|local_dump_flags
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|cgn
decl_stmt|;
comment|/* Dump the C-specific tree IR.  */
name|dump_orig
operator|=
name|dump_begin
argument_list|(
name|TDI_original
argument_list|,
operator|&
name|local_dump_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_orig
condition|)
block|{
name|fprintf
argument_list|(
name|dump_orig
argument_list|,
literal|"\n;; Function %s"
argument_list|,
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|fndecl
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_orig
argument_list|,
literal|" (%s)\n"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_orig
argument_list|,
literal|";; enabled by -%s\n"
argument_list|,
name|dump_flag_name
argument_list|(
name|TDI_original
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_orig
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_dump_flags
operator|&
name|TDF_RAW
condition|)
name|dump_node
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|TDF_SLIM
operator||
name|local_dump_flags
argument_list|,
name|dump_orig
argument_list|)
expr_stmt|;
else|else
name|print_c_tree
argument_list|(
name|dump_orig
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_orig
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_original
argument_list|,
name|dump_orig
argument_list|)
expr_stmt|;
block|}
comment|/* Go ahead and gimplify for now.  */
name|gimplify_function_tree
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Dump the genericized tree IR.  */
name|dump_function
argument_list|(
name|TDI_generic
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Genericize all nested functions now.  We do things in this order so      that items like VLA sizes are expanded properly in the context of      the correct function.  */
name|cgn
operator|=
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
for|for
control|(
name|cgn
operator|=
name|cgn
operator|->
name|nested
init|;
name|cgn
condition|;
name|cgn
operator|=
name|cgn
operator|->
name|next_nested
control|)
name|c_genericize
argument_list|(
name|cgn
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_block_to_enclosing
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|enclosing
decl_stmt|;
for|for
control|(
name|enclosing
operator|=
name|gimple_current_bind_expr
argument_list|()
init|;
name|enclosing
condition|;
name|enclosing
operator|=
name|TREE_CHAIN
argument_list|(
name|enclosing
argument_list|)
control|)
if|if
condition|(
name|BIND_EXPR_BLOCK
argument_list|(
name|enclosing
argument_list|)
condition|)
break|break;
name|enclosing
operator|=
name|BIND_EXPR_BLOCK
argument_list|(
name|enclosing
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|enclosing
argument_list|)
operator|=
name|chainon
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|enclosing
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Genericize a scope by creating a new BIND_EXPR.    BLOCK is either a BLOCK representing the scope or a chain of _DECLs.      In the latter case, we need to create a new BLOCK and add it to the      BLOCK_SUBBLOCKS of the enclosing block.    BODY is a chain of C _STMT nodes for the contents of the scope, to be      genericized.  */
end_comment

begin_function
name|tree
name|c_build_bind_expr
parameter_list|(
name|tree
name|block
parameter_list|,
name|tree
name|body
parameter_list|)
block|{
name|tree
name|decls
decl_stmt|,
name|bind
decl_stmt|;
if|if
condition|(
name|block
operator|==
name|NULL_TREE
condition|)
name|decls
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|block
argument_list|)
operator|==
name|BLOCK
condition|)
name|decls
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
block|{
name|decls
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decls
argument_list|)
condition|)
name|block
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|add_block_to_enclosing
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|body
condition|)
name|body
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
if|if
condition|(
name|decls
operator|||
name|block
condition|)
block|{
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decls
argument_list|,
name|body
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|bind
operator|=
name|body
expr_stmt|;
return|return
name|bind
return|;
block|}
end_function

begin_comment
comment|/* Gimplification of expression trees.  */
end_comment

begin_comment
comment|/* Gimplify a C99 compound literal expression.  This just means adding    the DECL_EXPR before the current statement and using its anonymous    decl instead.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_compound_literal_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|decl_s
init|=
name|COMPOUND_LITERAL_EXPR_DECL_STMT
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|DECL_EXPR_DECL
argument_list|(
name|decl_s
argument_list|)
decl_stmt|;
comment|/* This decl isn't mentioned in the enclosing block, so add it to the      list of temps.  FIXME it seems a bit of a kludge to say that      anonymous artificial vars aren't pushed, but everything else is.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|!
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|decl
argument_list|)
condition|)
name|gimple_add_tmp_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|decl_s
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|decl
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* Do C-specific gimplification.  Args are as for gimplify_expr.  */
end_comment

begin_function
name|int
name|c_gimplify_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|DECL_EXPR
case|:
comment|/* This is handled mostly by gimplify.c, but we have to deal with 	 not warning about int x = x; as it is a GCC extension to turn off 	 this warning but only if warn_init_self is zero.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|==
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|)
operator|&&
operator|!
name|warn_init_self
condition|)
name|TREE_NO_WARNING
argument_list|(
name|DECL_EXPR_DECL
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|GS_UNHANDLED
return|;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
return|return
name|gimplify_compound_literal_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
return|;
default|default:
return|return
name|GS_UNHANDLED
return|;
block|}
block|}
end_function

end_unit

