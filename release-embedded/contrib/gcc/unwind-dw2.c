begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF2 exception handling and frame unwind runtime interface routines.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combined    executable.)     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__USING_SJLJ_EXCEPTIONS__
end_ifdef

begin_define
define|#
directive|define
name|NO_SIZE_OF_ENCODED_VALUE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"unwind-pe.h"
end_include

begin_include
include|#
directive|include
file|"unwind-dw2-fde.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_include
include|#
directive|include
file|"unwind-dw2.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__USING_SJLJ_EXCEPTIONS__
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
end_ifndef

begin_define
define|#
directive|define
name|STACK_GROWS_DOWNWARD
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|STACK_GROWS_DOWNWARD
end_undef

begin_define
define|#
directive|define
name|STACK_GROWS_DOWNWARD
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Dwarf frame registers used for pre gcc 3.0 compiled glibc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PRE_GCC3_DWARF_FRAME_REGISTERS
end_ifndef

begin_define
define|#
directive|define
name|PRE_GCC3_DWARF_FRAME_REGISTERS
value|DWARF_FRAME_REGISTERS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_REG_TO_UNWIND_COLUMN
end_ifndef

begin_define
define|#
directive|define
name|DWARF_REG_TO_UNWIND_COLUMN
parameter_list|(
name|REGNO
parameter_list|)
value|(REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the register and unwind state for a particular frame.  This    provides the information necessary to unwind up past a frame and return    to its caller.  */
end_comment

begin_struct
struct|struct
name|_Unwind_Context
block|{
name|void
modifier|*
name|reg
index|[
name|DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
name|void
modifier|*
name|cfa
decl_stmt|;
name|void
modifier|*
name|ra
decl_stmt|;
name|void
modifier|*
name|lsda
decl_stmt|;
name|struct
name|dwarf_eh_bases
name|bases
decl_stmt|;
comment|/* Signal frame context.  */
define|#
directive|define
name|SIGNAL_FRAME_BIT
value|((~(_Unwind_Word) 0>> 1) + 1)
comment|/* Context which has version/args_size/by_value fields.  */
define|#
directive|define
name|EXTENDED_CONTEXT_BIT
value|((~(_Unwind_Word) 0>> 2) + 1)
name|_Unwind_Word
name|flags
decl_stmt|;
comment|/* 0 for now, can be increased when further fields are added to      struct _Unwind_Context.  */
name|_Unwind_Word
name|version
decl_stmt|;
name|_Unwind_Word
name|args_size
decl_stmt|;
name|char
name|by_value
index|[
name|DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Byte size of every register managed by these routines.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|dwarf_reg_size_table
index|[
name|DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Read unaligned data from the instruction buffer.  */
end_comment

begin_union
union|union
name|unaligned
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|unsigned
name|u2
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|HI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|u4
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|u8
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|DI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s2
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|HI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s4
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|SI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|signed
name|s8
name|__attribute__
argument_list|(
operator|(
name|mode
argument_list|(
name|DI
argument_list|)
operator|)
argument_list|)
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
union|;
end_union

begin_function_decl
specifier|static
name|void
name|uw_update_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|_Unwind_FrameState
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|_Unwind_Reason_Code
name|uw_frame_state_for
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|_Unwind_FrameState
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|read_pointer
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_1u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_1s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|signed
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_2u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|u2
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_2s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|s2
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|read_4u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|u4
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|read_4s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|s4
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|read_8u
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|u8
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|read_8s
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|union
name|unaligned
modifier|*
name|up
init|=
name|p
decl_stmt|;
return|return
name|up
operator|->
name|s8
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|inline
name|_Unwind_Word
name|_Unwind_IsSignalFrame
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|context
operator|->
name|flags
operator|&
name|SIGNAL_FRAME_BIT
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|_Unwind_SetSignalFrame
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
condition|)
name|context
operator|->
name|flags
operator||=
name|SIGNAL_FRAME_BIT
expr_stmt|;
else|else
name|context
operator|->
name|flags
operator|&=
operator|~
name|SIGNAL_FRAME_BIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|_Unwind_Word
name|_Unwind_IsExtendedContext
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|flags
operator|&
name|EXTENDED_CONTEXT_BIT
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the value of register INDEX as saved in CONTEXT.  */
end_comment

begin_function
specifier|inline
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|DWARF_ZERO_REG
if|if
condition|(
name|index
operator|==
name|DWARF_ZERO_REG
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|index
operator|=
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|index
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|dwarf_reg_size_table
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dwarf_reg_size_table
index|[
name|index
index|]
expr_stmt|;
name|ptr
operator|=
name|context
operator|->
name|reg
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|_Unwind_IsExtendedContext
argument_list|(
name|context
argument_list|)
operator|&&
name|context
operator|->
name|by_value
index|[
name|index
index|]
condition|)
return|return
operator|(
name|_Unwind_Word
operator|)
operator|(
name|_Unwind_Internal_Ptr
operator|)
name|ptr
return|;
comment|/* This will segfault if the register hasn't been saved.  */
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Ptr
argument_list|)
condition|)
return|return
operator|*
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|ptr
return|;
else|else
block|{
name|gcc_assert
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Word
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
operator|(
name|_Unwind_Word
operator|*
operator|)
name|ptr
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|_Unwind_GetPtr
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the value of the CFA as saved in CONTEXT.  */
end_comment

begin_function
name|_Unwind_Word
name|_Unwind_GetCFA
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|cfa
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */
end_comment

begin_function
specifier|inline
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|_Unwind_Word
name|val
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|index
operator|=
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|index
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|dwarf_reg_size_table
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|dwarf_reg_size_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|_Unwind_IsExtendedContext
argument_list|(
name|context
argument_list|)
operator|&&
name|context
operator|->
name|by_value
index|[
name|index
index|]
condition|)
block|{
name|context
operator|->
name|reg
index|[
name|index
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Internal_Ptr
operator|)
name|val
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|context
operator|->
name|reg
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Ptr
argument_list|)
condition|)
operator|*
operator|(
name|_Unwind_Ptr
operator|*
operator|)
name|ptr
operator|=
name|val
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Word
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|_Unwind_Word
operator|*
operator|)
name|ptr
operator|=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the pointer to a register INDEX as saved in CONTEXT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|_Unwind_GetGRPtr
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|index
operator|=
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|_Unwind_IsExtendedContext
argument_list|(
name|context
argument_list|)
operator|&&
name|context
operator|->
name|by_value
index|[
name|index
index|]
condition|)
return|return
operator|&
name|context
operator|->
name|reg
index|[
name|index
index|]
return|;
return|return
name|context
operator|->
name|reg
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set the pointer to a register INDEX as saved in CONTEXT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_Unwind_SetGRPtr
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|index
operator|=
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|_Unwind_IsExtendedContext
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|->
name|by_value
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|index
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Overwrite the saved value for register INDEX in CONTEXT with VAL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|_Unwind_SetGRValue
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|_Unwind_Word
name|val
parameter_list|)
block|{
name|index
operator|=
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|index
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|dwarf_reg_size_table
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dwarf_reg_size_table
index|[
name|index
index|]
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Ptr
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|by_value
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|index
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Internal_Ptr
operator|)
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if register INDEX is stored by value rather than    by reference.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|_Unwind_GRByValue
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|index
operator|=
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|context
operator|->
name|by_value
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the return address for CONTEXT.  */
end_comment

begin_function
specifier|inline
name|_Unwind_Ptr
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|ra
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the return address and flag whether that IP is before    or after first not yet fully executed instruction.  */
end_comment

begin_function
specifier|inline
name|_Unwind_Ptr
name|_Unwind_GetIPInfo
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
modifier|*
name|ip_before_insn
parameter_list|)
block|{
operator|*
name|ip_before_insn
operator|=
name|_Unwind_IsSignalFrame
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|ra
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the return address for CONTEXT with VAL.  */
end_comment

begin_function
specifier|inline
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_Ptr
name|val
parameter_list|)
block|{
name|context
operator|->
name|ra
operator|=
operator|(
name|void
operator|*
operator|)
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|lsda
return|;
block|}
end_function

begin_function
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|bases
operator|.
name|func
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|_Unwind_FindEnclosingFunction
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|dwarf_eh_bases
name|bases
decl_stmt|;
specifier|const
name|struct
name|dwarf_fde
modifier|*
name|fde
init|=
name|_Unwind_Find_FDE
argument_list|(
name|pc
operator|-
literal|1
argument_list|,
operator|&
name|bases
argument_list|)
decl_stmt|;
if|if
condition|(
name|fde
condition|)
return|return
name|bases
operator|.
name|func
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__ia64__
end_ifndef

begin_function
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|bases
operator|.
name|dbase
return|;
block|}
end_function

begin_function
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|bases
operator|.
name|tbase
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MD_UNWIND_SUPPORT
end_ifdef

begin_include
include|#
directive|include
include|MD_UNWIND_SUPPORT
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Extract any interesting information from the CIE for the translation    unit F belongs to.  Return a pointer to the byte after the augmentation,    or NULL if we encountered an undecipherable augmentation.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|extract_cie_info
parameter_list|(
specifier|const
name|struct
name|dwarf_cie
modifier|*
name|cie
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|aug
init|=
name|cie
operator|->
name|augmentation
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|aug
operator|+
name|strlen
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|aug
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|_Unwind_Word
name|utmp
decl_stmt|;
comment|/* g++ v2 "eh" has pointer immediately following augmentation string,      so it must be handled first.  */
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|aug
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
name|fs
operator|->
name|eh_ptr
operator|=
name|read_pointer
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|aug
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Immediately following the augmentation are the code and      data alignment and return address column.  */
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|fs
operator|->
name|code_align
argument_list|)
expr_stmt|;
name|p
operator|=
name|read_sleb128
argument_list|(
name|p
argument_list|,
operator|&
name|fs
operator|->
name|data_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|cie
operator|->
name|version
operator|==
literal|1
condition|)
name|fs
operator|->
name|retaddr_column
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|fs
operator|->
name|retaddr_column
argument_list|)
expr_stmt|;
name|fs
operator|->
name|lsda_encoding
operator|=
name|DW_EH_PE_omit
expr_stmt|;
comment|/* If the augmentation starts with 'z', then a uleb128 immediately      follows containing the length of the augmentation field following      the size.  */
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
name|p
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|p
operator|+
name|utmp
expr_stmt|;
name|fs
operator|->
name|saw_z
operator|=
literal|1
expr_stmt|;
operator|++
name|aug
expr_stmt|;
block|}
comment|/* Iterate over recognized augmentation subsequences.  */
while|while
condition|(
operator|*
name|aug
operator|!=
literal|'\0'
condition|)
block|{
comment|/* "L" indicates a byte showing how the LSDA pointer is encoded.  */
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|fs
operator|->
name|lsda_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|aug
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* "R" indicates a byte indicating how FDE addresses are encoded.  */
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'R'
condition|)
block|{
name|fs
operator|->
name|fde_encoding
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|aug
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* "P" indicates a personality routine in the CIE augmentation.  */
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
name|_Unwind_Ptr
name|personality
decl_stmt|;
name|p
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
operator|*
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|personality
argument_list|)
expr_stmt|;
name|fs
operator|->
name|personality
operator|=
operator|(
name|_Unwind_Personality_Fn
operator|)
name|personality
expr_stmt|;
name|aug
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* "S" indicates a signal frame.  */
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
block|{
name|fs
operator|->
name|signal_frame
operator|=
literal|1
expr_stmt|;
name|aug
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Otherwise we have an unknown augmentation string. 	 Bail unless we saw a 'z' prefix.  */
else|else
return|return
name|ret
return|;
block|}
return|return
name|ret
condition|?
name|ret
else|:
name|p
return|;
block|}
end_function

begin_comment
comment|/* Decode a DW_OP stack program.  Return the top of stack.  Push INITIAL    onto the stack to start.  */
end_comment

begin_function
specifier|static
name|_Unwind_Word
name|execute_stack_op
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|op_ptr
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|op_end
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_Word
name|initial
parameter_list|)
block|{
name|_Unwind_Word
name|stack
index|[
literal|64
index|]
decl_stmt|;
comment|/* ??? Assume this is enough.  */
name|int
name|stack_elt
decl_stmt|;
name|stack
index|[
literal|0
index|]
operator|=
name|initial
expr_stmt|;
name|stack_elt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|op_ptr
operator|<
name|op_end
condition|)
block|{
name|enum
name|dwarf_location_atom
name|op
init|=
operator|*
name|op_ptr
operator|++
decl_stmt|;
name|_Unwind_Word
name|result
decl_stmt|,
name|reg
decl_stmt|,
name|utmp
decl_stmt|;
name|_Unwind_Sword
name|offset
decl_stmt|,
name|stmp
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
name|result
operator|=
name|op
operator|-
name|DW_OP_lit0
expr_stmt|;
break|break;
case|case
name|DW_OP_addr
case|:
name|result
operator|=
operator|(
name|_Unwind_Word
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|read_pointer
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|result
operator|=
name|read_1u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|result
operator|=
name|read_1s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|result
operator|=
name|read_2u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|result
operator|=
name|read_2s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|result
operator|=
name|read_4u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|result
operator|=
name|read_4s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
name|result
operator|=
name|read_8u
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_const8s
case|:
name|result
operator|=
name|read_8s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
name|result
operator|=
name|stmp
expr_stmt|;
break|break;
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|op
operator|-
name|DW_OP_reg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|op
operator|-
name|DW_OP_breg0
argument_list|)
operator|+
name|offset
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|op_ptr
operator|=
name|read_sleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|result
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|reg
argument_list|)
operator|+
name|offset
expr_stmt|;
break|break;
case|case
name|DW_OP_dup
case|:
name|gcc_assert
argument_list|(
name|stack_elt
argument_list|)
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_drop
case|:
name|gcc_assert
argument_list|(
name|stack_elt
argument_list|)
expr_stmt|;
name|stack_elt
operator|-=
literal|1
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_pick
case|:
name|offset
operator|=
operator|*
name|op_ptr
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|offset
operator|<
name|stack_elt
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
operator|-
name|offset
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_over
case|:
name|gcc_assert
argument_list|(
name|stack_elt
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_swap
case|:
block|{
name|_Unwind_Word
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|stack_elt
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|t
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
operator|=
name|t
expr_stmt|;
goto|goto
name|no_push
goto|;
block|}
case|case
name|DW_OP_rot
case|:
block|{
name|_Unwind_Word
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|gcc_assert
argument_list|(
name|stack_elt
operator|>=
literal|3
argument_list|)
expr_stmt|;
name|t1
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
expr_stmt|;
name|t2
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
expr_stmt|;
name|t3
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|3
index|]
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
operator|=
name|t2
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
operator|=
name|t3
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|3
index|]
operator|=
name|t1
expr_stmt|;
goto|goto
name|no_push
goto|;
block|}
case|case
name|DW_OP_deref
case|:
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_abs
case|:
case|case
name|DW_OP_neg
case|:
case|case
name|DW_OP_not
case|:
case|case
name|DW_OP_plus_uconst
case|:
comment|/* Unary operations.  */
name|gcc_assert
argument_list|(
name|stack_elt
argument_list|)
expr_stmt|;
name|stack_elt
operator|-=
literal|1
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_deref
case|:
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|read_pointer
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_deref_size
case|:
block|{
name|void
modifier|*
name|ptr
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|result
decl_stmt|;
switch|switch
condition|(
operator|*
name|op_ptr
operator|++
condition|)
block|{
case|case
literal|1
case|:
name|result
operator|=
name|read_1u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator|=
name|read_2u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|result
operator|=
name|read_4u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|result
operator|=
name|read_8u
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_OP_abs
case|:
if|if
condition|(
operator|(
name|_Unwind_Sword
operator|)
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_neg
case|:
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_not
case|:
name|result
operator|=
operator|~
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|op_ptr
operator|=
name|read_uleb128
argument_list|(
name|op_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|result
operator|+=
name|utmp
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_and
case|:
case|case
name|DW_OP_div
case|:
case|case
name|DW_OP_minus
case|:
case|case
name|DW_OP_mod
case|:
case|case
name|DW_OP_mul
case|:
case|case
name|DW_OP_or
case|:
case|case
name|DW_OP_plus
case|:
case|case
name|DW_OP_shl
case|:
case|case
name|DW_OP_shr
case|:
case|case
name|DW_OP_shra
case|:
case|case
name|DW_OP_xor
case|:
case|case
name|DW_OP_le
case|:
case|case
name|DW_OP_ge
case|:
case|case
name|DW_OP_eq
case|:
case|case
name|DW_OP_lt
case|:
case|case
name|DW_OP_gt
case|:
case|case
name|DW_OP_ne
case|:
block|{
comment|/* Binary operations.  */
name|_Unwind_Word
name|first
decl_stmt|,
name|second
decl_stmt|;
name|gcc_assert
argument_list|(
name|stack_elt
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|stack_elt
operator|-=
literal|2
expr_stmt|;
name|second
operator|=
name|stack
index|[
name|stack_elt
index|]
expr_stmt|;
name|first
operator|=
name|stack
index|[
name|stack_elt
operator|+
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_and
case|:
name|result
operator|=
name|second
operator|&
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_div
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|second
operator|/
operator|(
name|_Unwind_Sword
operator|)
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_minus
case|:
name|result
operator|=
name|second
operator|-
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_mod
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|second
operator|%
operator|(
name|_Unwind_Sword
operator|)
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_mul
case|:
name|result
operator|=
name|second
operator|*
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_or
case|:
name|result
operator|=
name|second
operator||
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|result
operator|=
name|second
operator|+
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shl
case|:
name|result
operator|=
name|second
operator|<<
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shr
case|:
name|result
operator|=
name|second
operator|>>
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shra
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|second
operator|>>
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_xor
case|:
name|result
operator|=
name|second
operator|^
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_le
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|<=
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_ge
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|>=
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_eq
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|==
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_lt
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|<
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_gt
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|>
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_ne
case|:
name|result
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|first
operator|!=
operator|(
name|_Unwind_Sword
operator|)
name|second
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_OP_skip
case|:
name|offset
operator|=
name|read_2s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
name|op_ptr
operator|+=
name|offset
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_bra
case|:
name|gcc_assert
argument_list|(
name|stack_elt
argument_list|)
expr_stmt|;
name|stack_elt
operator|-=
literal|1
expr_stmt|;
name|offset
operator|=
name|read_2s
argument_list|(
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|stack
index|[
name|stack_elt
index|]
operator|!=
literal|0
condition|)
name|op_ptr
operator|+=
name|offset
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_nop
case|:
goto|goto
name|no_push
goto|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Most things push a result value.  */
name|gcc_assert
argument_list|(
operator|(
name|size_t
operator|)
name|stack_elt
operator|<
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|++
index|]
operator|=
name|result
expr_stmt|;
name|no_push
label|:
empty_stmt|;
block|}
comment|/* We were executing this program to get a value.  It should be      at top of stack.  */
name|gcc_assert
argument_list|(
name|stack_elt
argument_list|)
expr_stmt|;
name|stack_elt
operator|-=
literal|1
expr_stmt|;
return|return
name|stack
index|[
name|stack_elt
index|]
return|;
block|}
end_function

begin_comment
comment|/* Decode DWARF 2 call frame information. Takes pointers the    instruction sequence to decode, current register information and    CIE info, and the PC range to evaluate.  */
end_comment

begin_function
specifier|static
name|void
name|execute_cfa_program
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|insn_ptr
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|insn_end
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|frame_state_reg_info
modifier|*
name|unused_rs
init|=
name|NULL
decl_stmt|;
comment|/* Don't allow remember/restore between CIE and FDE programs.  */
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* The comparison with the return address uses< rather than<= because      we are only interested in the effects of code before the call; for a      noreturn function, the return address may point to unrelated code with      a different stack configuration that we are not interested in.  We      assume that the call itself is unwind info-neutral; if not, or if      there are delay instructions that adjust the stack, these must be      reflected at the point immediately before the call insn.      In signal frames, return address is after last completed instruction,      so we add 1 to return address to make the comparison<=.  */
while|while
condition|(
name|insn_ptr
operator|<
name|insn_end
operator|&&
name|fs
operator|->
name|pc
operator|<
name|context
operator|->
name|ra
operator|+
name|_Unwind_IsSignalFrame
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|unsigned
name|char
name|insn
init|=
operator|*
name|insn_ptr
operator|++
decl_stmt|;
name|_Unwind_Word
name|reg
decl_stmt|,
name|utmp
decl_stmt|;
name|_Unwind_Sword
name|offset
decl_stmt|,
name|stmp
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_advance_loc
condition|)
name|fs
operator|->
name|pc
operator|+=
operator|(
name|insn
operator|&
literal|0x3f
operator|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_offset
condition|)
block|{
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xc0
operator|)
operator|==
name|DW_CFA_restore
condition|)
block|{
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_UNSAVED
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|insn
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
block|{
name|_Unwind_Ptr
name|pc
decl_stmt|;
name|insn_ptr
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|fde_encoding
argument_list|,
name|insn_ptr
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
name|fs
operator|->
name|pc
operator|=
operator|(
name|void
operator|*
operator|)
name|pc
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_1u
argument_list|(
name|insn_ptr
argument_list|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_2u
argument_list|(
name|insn_ptr
argument_list|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_4u
argument_list|(
name|insn_ptr
argument_list|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
name|insn_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
comment|/* FIXME, this is wrong; the CIE might have said that the 	     register was saved somewhere.  */
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_UNSAVED
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_UNSAVED
expr_stmt|;
break|break;
case|case
name|DW_CFA_nop
case|:
break|break;
case|case
name|DW_CFA_register
case|:
block|{
name|_Unwind_Word
name|reg2
decl_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg2
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_REG
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|reg
operator|=
name|reg2
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_remember_state
case|:
block|{
name|struct
name|frame_state_reg_info
modifier|*
name|new_rs
decl_stmt|;
if|if
condition|(
name|unused_rs
condition|)
block|{
name|new_rs
operator|=
name|unused_rs
expr_stmt|;
name|unused_rs
operator|=
name|unused_rs
operator|->
name|prev
expr_stmt|;
block|}
else|else
name|new_rs
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state_reg_info
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_rs
operator|=
name|fs
operator|->
name|regs
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|new_rs
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_restore_state
case|:
block|{
name|struct
name|frame_state_reg_info
modifier|*
name|old_rs
init|=
name|fs
operator|->
name|regs
operator|.
name|prev
decl_stmt|;
name|fs
operator|->
name|regs
operator|=
operator|*
name|old_rs
expr_stmt|;
name|old_rs
operator|->
name|prev
operator|=
name|unused_rs
expr_stmt|;
name|unused_rs
operator|=
name|old_rs
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|utmp
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|utmp
expr_stmt|;
comment|/* cfa_how deliberately not set.  */
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|fs
operator|->
name|cfa_exp
operator|=
name|insn_ptr
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_EXP
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|insn_ptr
operator|+=
name|utmp
expr_stmt|;
break|break;
case|case
name|DW_CFA_expression
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_EXP
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|exp
operator|=
name|insn_ptr
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|insn_ptr
operator|+=
name|utmp
expr_stmt|;
break|break;
comment|/* Dwarf3.  */
case|case
name|DW_CFA_offset_extended_sf
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|stmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|*=
name|fs
operator|->
name|data_align
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|fs
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|*=
name|fs
operator|->
name|data_align
expr_stmt|;
comment|/* cfa_how deliberately not set.  */
break|break;
case|case
name|DW_CFA_val_offset
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_Unwind_Sword
operator|)
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_VAL_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_val_offset_sf
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_sleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|stmp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|stmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_VAL_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_val_expression
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_VAL_EXP
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|exp
operator|=
name|insn_ptr
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|insn_ptr
operator|+=
name|utmp
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
comment|/* ??? Hardcoded for SPARC register window configuration.  */
for|for
control|(
name|reg
operator|=
literal|16
init|;
name|reg
operator|<
literal|32
condition|;
operator|++
name|reg
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|reg
operator|-
literal|16
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|context
operator|->
name|args_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
comment|/* Obsoleted by DW_CFA_offset_extended_sf, but used by 	     older PowerPC code.  */
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|insn_ptr
operator|=
name|read_uleb128
argument_list|(
name|insn_ptr
argument_list|,
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|_Unwind_Word
operator|)
name|utmp
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|DWARF_REG_TO_UNWIND_COLUMN
argument_list|(
name|reg
argument_list|)
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for    its caller and decode it into FS.  This function also sets the    args_size and lsda members of CONTEXT, as they are really information    about the caller's frame.  */
end_comment

begin_function
specifier|static
name|_Unwind_Reason_Code
name|uw_frame_state_for
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
specifier|const
name|struct
name|dwarf_fde
modifier|*
name|fde
decl_stmt|;
specifier|const
name|struct
name|dwarf_cie
modifier|*
name|cie
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|aug
decl_stmt|,
modifier|*
name|insn
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|memset
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|args_size
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|lsda
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|ra
operator|==
literal|0
condition|)
return|return
name|_URC_END_OF_STACK
return|;
name|fde
operator|=
name|_Unwind_Find_FDE
argument_list|(
name|context
operator|->
name|ra
operator|+
name|_Unwind_IsSignalFrame
argument_list|(
name|context
argument_list|)
operator|-
literal|1
argument_list|,
operator|&
name|context
operator|->
name|bases
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|MD_FALLBACK_FRAME_STATE_FOR
comment|/* Couldn't find frame unwind info for this function.  Try a 	 target-specific fallback mechanism.  This will necessarily 	 not provide a personality routine or LSDA.  */
return|return
name|MD_FALLBACK_FRAME_STATE_FOR
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
return|;
else|#
directive|else
return|return
name|_URC_END_OF_STACK
return|;
endif|#
directive|endif
block|}
name|fs
operator|->
name|pc
operator|=
name|context
operator|->
name|bases
operator|.
name|func
expr_stmt|;
name|cie
operator|=
name|get_cie
argument_list|(
name|fde
argument_list|)
expr_stmt|;
name|insn
operator|=
name|extract_cie_info
argument_list|(
name|cie
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
comment|/* CIE contained unknown augmentation.  */
return|return
name|_URC_FATAL_PHASE1_ERROR
return|;
comment|/* First decode all the insns in the CIE.  */
name|end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|next_fde
argument_list|(
operator|(
expr|struct
name|dwarf_fde
operator|*
operator|)
name|cie
argument_list|)
expr_stmt|;
name|execute_cfa_program
argument_list|(
name|insn
argument_list|,
name|end
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* Locate augmentation for the fde.  */
name|aug
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fde
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fde
argument_list|)
expr_stmt|;
name|aug
operator|+=
literal|2
operator|*
name|size_of_encoded_value
argument_list|(
name|fs
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|saw_z
condition|)
block|{
name|_Unwind_Word
name|i
decl_stmt|;
name|aug
operator|=
name|read_uleb128
argument_list|(
name|aug
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|insn
operator|=
name|aug
operator|+
name|i
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|lsda_encoding
operator|!=
name|DW_EH_PE_omit
condition|)
block|{
name|_Unwind_Ptr
name|lsda
decl_stmt|;
name|aug
operator|=
name|read_encoded_value
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|lsda_encoding
argument_list|,
name|aug
argument_list|,
operator|&
name|lsda
argument_list|)
expr_stmt|;
name|context
operator|->
name|lsda
operator|=
operator|(
name|void
operator|*
operator|)
name|lsda
expr_stmt|;
block|}
comment|/* Then the insns in the FDE up to our target PC.  */
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
name|insn
operator|=
name|aug
expr_stmt|;
name|end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|next_fde
argument_list|(
name|fde
argument_list|)
expr_stmt|;
name|execute_cfa_program
argument_list|(
name|insn
argument_list|,
name|end
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
name|frame_state
block|{
name|void
modifier|*
name|cfa
decl_stmt|;
name|void
modifier|*
name|eh_ptr
decl_stmt|;
name|long
name|cfa_offset
decl_stmt|;
name|long
name|args_size
decl_stmt|;
name|long
name|reg_or_offset
index|[
name|PRE_GCC3_DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|short
name|cfa_reg
decl_stmt|;
name|unsigned
name|short
name|retaddr_column
decl_stmt|;
name|char
name|saved
index|[
name|PRE_GCC3_DWARF_FRAME_REGISTERS
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|frame_state
typedef|;
end_typedef

begin_function_decl
name|struct
name|frame_state
modifier|*
name|__frame_state_for
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|frame_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called from pre-G++ 3.0 __throw to find the registers to restore for    a given PC_TARGET.  The caller should allocate a local variable of    `struct frame_state' and pass its address to STATE_IN.  */
end_comment

begin_function
name|struct
name|frame_state
modifier|*
name|__frame_state_for
parameter_list|(
name|void
modifier|*
name|pc_target
parameter_list|,
name|struct
name|frame_state
modifier|*
name|state_in
parameter_list|)
block|{
name|struct
name|_Unwind_Context
name|context
decl_stmt|;
name|_Unwind_FrameState
name|fs
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_Unwind_Context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|flags
operator|=
name|EXTENDED_CONTEXT_BIT
expr_stmt|;
name|context
operator|.
name|ra
operator|=
name|pc_target
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|uw_frame_state_for
argument_list|(
operator|&
name|context
argument_list|,
operator|&
name|fs
argument_list|)
operator|!=
name|_URC_NO_REASON
condition|)
return|return
literal|0
return|;
comment|/* We have no way to pass a location expression for the CFA to our      caller.  It wouldn't understand it anyway.  */
if|if
condition|(
name|fs
operator|.
name|cfa_how
operator|==
name|CFA_EXP
condition|)
return|return
literal|0
return|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|PRE_GCC3_DWARF_FRAME_REGISTERS
operator|+
literal|1
condition|;
name|reg
operator|++
control|)
block|{
name|state_in
operator|->
name|saved
index|[
name|reg
index|]
operator|=
name|fs
operator|.
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
expr_stmt|;
switch|switch
condition|(
name|state_in
operator|->
name|saved
index|[
name|reg
index|]
condition|)
block|{
case|case
name|REG_SAVED_REG
case|:
name|state_in
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|=
name|fs
operator|.
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|reg
expr_stmt|;
break|break;
case|case
name|REG_SAVED_OFFSET
case|:
name|state_in
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|=
name|fs
operator|.
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
expr_stmt|;
break|break;
default|default:
name|state_in
operator|->
name|reg_or_offset
index|[
name|reg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|state_in
operator|->
name|cfa_offset
operator|=
name|fs
operator|.
name|cfa_offset
expr_stmt|;
name|state_in
operator|->
name|cfa_reg
operator|=
name|fs
operator|.
name|cfa_reg
expr_stmt|;
name|state_in
operator|->
name|retaddr_column
operator|=
name|fs
operator|.
name|retaddr_column
expr_stmt|;
name|state_in
operator|->
name|args_size
operator|=
name|context
operator|.
name|args_size
expr_stmt|;
name|state_in
operator|->
name|eh_ptr
operator|=
name|fs
operator|.
name|eh_ptr
expr_stmt|;
return|return
name|state_in
return|;
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
union|union
block|{
name|_Unwind_Ptr
name|ptr
decl_stmt|;
name|_Unwind_Word
name|word
decl_stmt|;
block|}
name|_Unwind_SpTmp
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|void
name|_Unwind_SetSpColumn
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|cfa
parameter_list|,
name|_Unwind_SpTmp
modifier|*
name|tmp_sp
parameter_list|)
block|{
name|int
name|size
init|=
name|dwarf_reg_size_table
index|[
name|__builtin_dwarf_sp_column
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Ptr
argument_list|)
condition|)
name|tmp_sp
operator|->
name|ptr
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|cfa
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Word
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_sp
operator|->
name|word
operator|=
operator|(
name|_Unwind_Ptr
operator|)
name|cfa
expr_stmt|;
block|}
name|_Unwind_SetGRPtr
argument_list|(
name|context
argument_list|,
name|__builtin_dwarf_sp_column
argument_list|()
argument_list|,
name|tmp_sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uw_update_context_1
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|_Unwind_Context
name|orig_context
init|=
operator|*
name|context
decl_stmt|;
name|void
modifier|*
name|cfa
decl_stmt|;
name|long
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
comment|/* Special handling here: Many machines do not use a frame pointer,      and track the CFA only through offsets from the stack pointer from      one frame to the next.  In this case, the stack pointer is never      stored, so it has no saved address in the context.  What we do      have is the CFA from the previous stack frame.       In very special situations (such as unwind info for signal return),      there may be location expressions that use the stack pointer as well.       Do this conditionally for one frame.  This allows the unwind info      for one frame to save a copy of the stack pointer from the previous      frame, and be able to use much easier CFA mechanisms to do it.      Always zap the saved stack pointer value for the next frame; carrying      the value over from one frame to another doesn't make sense.  */
name|_Unwind_SpTmp
name|tmp_sp
decl_stmt|;
if|if
condition|(
operator|!
name|_Unwind_GetGRPtr
argument_list|(
operator|&
name|orig_context
argument_list|,
name|__builtin_dwarf_sp_column
argument_list|()
argument_list|)
condition|)
name|_Unwind_SetSpColumn
argument_list|(
operator|&
name|orig_context
argument_list|,
name|context
operator|->
name|cfa
argument_list|,
operator|&
name|tmp_sp
argument_list|)
expr_stmt|;
name|_Unwind_SetGRPtr
argument_list|(
name|context
argument_list|,
name|__builtin_dwarf_sp_column
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute this frame's CFA.  */
switch|switch
condition|(
name|fs
operator|->
name|cfa_how
condition|)
block|{
case|case
name|CFA_REG_OFFSET
case|:
name|cfa
operator|=
name|_Unwind_GetPtr
argument_list|(
operator|&
name|orig_context
argument_list|,
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|cfa
operator|+=
name|fs
operator|->
name|cfa_offset
expr_stmt|;
break|break;
case|case
name|CFA_EXP
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|exp
init|=
name|fs
operator|->
name|cfa_exp
decl_stmt|;
name|_Unwind_Word
name|len
decl_stmt|;
name|exp
operator|=
name|read_uleb128
argument_list|(
name|exp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|cfa
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|_Unwind_Ptr
operator|)
name|execute_stack_op
argument_list|(
name|exp
argument_list|,
name|exp
operator|+
name|len
argument_list|,
operator|&
name|orig_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|context
operator|->
name|cfa
operator|=
name|cfa
expr_stmt|;
comment|/* Compute the addresses of all registers saved in this frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DWARF_FRAME_REGISTERS
operator|+
literal|1
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
condition|)
block|{
case|case
name|REG_UNSAVED
case|:
break|break;
case|case
name|REG_SAVED_OFFSET
case|:
name|_Unwind_SetGRPtr
argument_list|(
name|context
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|cfa
operator|+
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_SAVED_REG
case|:
if|if
condition|(
name|_Unwind_GRByValue
argument_list|(
operator|&
name|orig_context
argument_list|,
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
argument_list|)
condition|)
name|_Unwind_SetGRValue
argument_list|(
name|context
argument_list|,
name|i
argument_list|,
name|_Unwind_GetGR
argument_list|(
operator|&
name|orig_context
argument_list|,
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|_Unwind_SetGRPtr
argument_list|(
name|context
argument_list|,
name|i
argument_list|,
name|_Unwind_GetGRPtr
argument_list|(
operator|&
name|orig_context
argument_list|,
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_SAVED_EXP
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|exp
init|=
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|exp
decl_stmt|;
name|_Unwind_Word
name|len
decl_stmt|;
name|_Unwind_Ptr
name|val
decl_stmt|;
name|exp
operator|=
name|read_uleb128
argument_list|(
name|exp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|execute_stack_op
argument_list|(
name|exp
argument_list|,
name|exp
operator|+
name|len
argument_list|,
operator|&
name|orig_context
argument_list|,
operator|(
name|_Unwind_Ptr
operator|)
name|cfa
argument_list|)
expr_stmt|;
name|_Unwind_SetGRPtr
argument_list|(
name|context
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_SAVED_VAL_OFFSET
case|:
name|_Unwind_SetGRValue
argument_list|(
name|context
argument_list|,
name|i
argument_list|,
call|(
name|_Unwind_Internal_Ptr
call|)
argument_list|(
name|cfa
operator|+
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_SAVED_VAL_EXP
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|exp
init|=
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|exp
decl_stmt|;
name|_Unwind_Word
name|len
decl_stmt|;
name|_Unwind_Ptr
name|val
decl_stmt|;
name|exp
operator|=
name|read_uleb128
argument_list|(
name|exp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|execute_stack_op
argument_list|(
name|exp
argument_list|,
name|exp
operator|+
name|len
argument_list|,
operator|&
name|orig_context
argument_list|,
operator|(
name|_Unwind_Ptr
operator|)
name|cfa
argument_list|)
expr_stmt|;
name|_Unwind_SetGRValue
argument_list|(
name|context
argument_list|,
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|_Unwind_SetSignalFrame
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|signal_frame
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MD_FROB_UPDATE_CONTEXT
name|MD_FROB_UPDATE_CONTEXT
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* CONTEXT describes the unwind state for a frame, and FS describes the FDE    of its caller.  Update CONTEXT to refer to the caller as well.  Note    that the args_size and lsda members are not updated here, but later in    uw_frame_state_for.  */
end_comment

begin_function
specifier|static
name|void
name|uw_update_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|uw_update_context_1
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* Compute the return address now, since the return address column      can change from frame to frame.  */
name|context
operator|->
name|ra
operator|=
name|__builtin_extract_return_addr
argument_list|(
name|_Unwind_GetPtr
argument_list|(
name|context
argument_list|,
name|fs
operator|->
name|retaddr_column
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uw_advance_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|uw_update_context
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in CONTEXT for top-of-stack.  The only valid registers at this    level will be the return address and the CFA.  */
end_comment

begin_define
define|#
directive|define
name|uw_init_context
parameter_list|(
name|CONTEXT
parameter_list|)
define|\
value|do									   \     {									   \
comment|/* Do any necessary initialization to access arbitrary stack frames. \ 	 On the SPARC, this means flushing the register windows.  */
value|\       __builtin_unwind_init ();						   \       uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (),		   \ 			 __builtin_return_address (0));			   \     }									   \   while (0)
end_define

begin_function
specifier|static
specifier|inline
name|void
name|init_dwarf_reg_size_table
parameter_list|(
name|void
parameter_list|)
block|{
name|__builtin_init_dwarf_reg_size_table
argument_list|(
name|dwarf_reg_size_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uw_init_context_1
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|outer_cfa
parameter_list|,
name|void
modifier|*
name|outer_ra
parameter_list|)
block|{
name|void
modifier|*
name|ra
init|=
name|__builtin_extract_return_addr
argument_list|(
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|_Unwind_FrameState
name|fs
decl_stmt|;
name|_Unwind_SpTmp
name|sp_slot
decl_stmt|;
name|_Unwind_Reason_Code
name|code
decl_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_Unwind_Context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|ra
operator|=
name|ra
expr_stmt|;
name|context
operator|->
name|flags
operator|=
name|EXTENDED_CONTEXT_BIT
expr_stmt|;
name|code
operator|=
name|uw_frame_state_for
argument_list|(
name|context
argument_list|,
operator|&
name|fs
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|code
operator|==
name|_URC_NO_REASON
argument_list|)
expr_stmt|;
if|#
directive|if
name|__GTHREADS
block|{
specifier|static
name|__gthread_once_t
name|once_regsizes
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
if|if
condition|(
name|__gthread_once
argument_list|(
operator|&
name|once_regsizes
argument_list|,
name|init_dwarf_reg_size_table
argument_list|)
operator|!=
literal|0
operator|||
name|dwarf_reg_size_table
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|init_dwarf_reg_size_table
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|dwarf_reg_size_table
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|init_dwarf_reg_size_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Force the frame state to use the known cfa value.  */
name|_Unwind_SetSpColumn
argument_list|(
name|context
argument_list|,
name|outer_cfa
argument_list|,
operator|&
name|sp_slot
argument_list|)
expr_stmt|;
name|fs
operator|.
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
name|fs
operator|.
name|cfa_reg
operator|=
name|__builtin_dwarf_sp_column
argument_list|()
expr_stmt|;
name|fs
operator|.
name|cfa_offset
operator|=
literal|0
expr_stmt|;
name|uw_update_context_1
argument_list|(
name|context
argument_list|,
operator|&
name|fs
argument_list|)
expr_stmt|;
comment|/* If the return address column was saved in a register in the      initialization context, then we can't see it in the given      call frame data.  So have the initialization context tell us.  */
name|context
operator|->
name|ra
operator|=
name|__builtin_extract_return_addr
argument_list|(
name|outer_ra
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install TARGET into CURRENT so that we can return to it.  This is a    macro because __builtin_eh_return must be invoked in the context of    our caller.  */
end_comment

begin_define
define|#
directive|define
name|uw_install_context
parameter_list|(
name|CURRENT
parameter_list|,
name|TARGET
parameter_list|)
define|\
value|do									 \     {									 \       long offset = uw_install_context_1 ((CURRENT), (TARGET));		 \       void *handler = __builtin_frob_return_addr ((TARGET)->ra);	 \       __builtin_eh_return (offset, handler);				 \     }									 \   while (0)
end_define

begin_function
specifier|static
name|long
name|uw_install_context_1
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|current
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
name|target
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
name|_Unwind_SpTmp
name|sp_slot
decl_stmt|;
comment|/* If the target frame does not have a saved stack pointer,      then set up the target's CFA.  */
if|if
condition|(
operator|!
name|_Unwind_GetGRPtr
argument_list|(
name|target
argument_list|,
name|__builtin_dwarf_sp_column
argument_list|()
argument_list|)
condition|)
name|_Unwind_SetSpColumn
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|cfa
argument_list|,
operator|&
name|sp_slot
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DWARF_FRAME_REGISTERS
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|c
init|=
name|current
operator|->
name|reg
index|[
name|i
index|]
decl_stmt|;
name|void
modifier|*
name|t
init|=
name|target
operator|->
name|reg
index|[
name|i
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|current
operator|->
name|by_value
index|[
name|i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|by_value
index|[
name|i
index|]
operator|&&
name|c
condition|)
block|{
name|_Unwind_Word
name|w
decl_stmt|;
name|_Unwind_Ptr
name|p
decl_stmt|;
if|if
condition|(
name|dwarf_reg_size_table
index|[
name|i
index|]
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Word
argument_list|)
condition|)
block|{
name|w
operator|=
operator|(
name|_Unwind_Internal_Ptr
operator|)
name|t
expr_stmt|;
name|memcpy
argument_list|(
name|c
argument_list|,
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|_Unwind_Word
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|dwarf_reg_size_table
index|[
name|i
index|]
operator|==
sizeof|sizeof
argument_list|(
name|_Unwind_Ptr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|_Unwind_Internal_Ptr
operator|)
name|t
expr_stmt|;
name|memcpy
argument_list|(
name|c
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|_Unwind_Ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|&&
name|c
operator|&&
name|t
operator|!=
name|c
condition|)
name|memcpy
argument_list|(
name|c
argument_list|,
name|t
argument_list|,
name|dwarf_reg_size_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If the current frame doesn't have a saved stack pointer, then we      need to rely on EH_RETURN_STACKADJ_RTX to get our target stack      pointer value reloaded.  */
if|if
condition|(
operator|!
name|_Unwind_GetGRPtr
argument_list|(
name|current
argument_list|,
name|__builtin_dwarf_sp_column
argument_list|()
argument_list|)
condition|)
block|{
name|void
modifier|*
name|target_cfa
decl_stmt|;
name|target_cfa
operator|=
name|_Unwind_GetPtr
argument_list|(
name|target
argument_list|,
name|__builtin_dwarf_sp_column
argument_list|()
argument_list|)
expr_stmt|;
comment|/* We adjust SP by the difference between CURRENT and TARGET's CFA.  */
if|if
condition|(
name|STACK_GROWS_DOWNWARD
condition|)
return|return
name|target_cfa
operator|-
name|current
operator|->
name|cfa
operator|+
name|target
operator|->
name|args_size
return|;
else|else
return|return
name|current
operator|->
name|cfa
operator|-
name|target_cfa
operator|-
name|target
operator|->
name|args_size
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|_Unwind_Ptr
name|uw_identify_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"unwind.inc"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_GAS_SYMVER
argument_list|)
operator|&&
name|defined
argument_list|(
name|SHARED
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LIBUNWIND_EXCEPTIONS
argument_list|)
end_if

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_Backtrace
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_DeleteException
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_FindEnclosingFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_ForcedUnwind
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetDataRelBase
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetTextRelBase
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetCFA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetGR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetIP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetLanguageSpecificData
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetRegionStart
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_RaiseException
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_Resume
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_Resume_or_Rethrow
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_SetGR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_SetIP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USING_SJLJ_EXCEPTIONS */
end_comment

end_unit

