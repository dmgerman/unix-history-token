begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert RTL to assembler code and output it, for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This is the final pass of the compiler.    It looks at the rtl code for a function and outputs assembler code.     Call `final_start_function' to output the assembler code for function entry,    `final' to output assembler code for some RTL code,    `final_end_function' to output assembler code for function exit.    If a function is compiled in several pieces, each piece is    output separately with `final'.     Some optimizations are also done at this level.    Move instructions that were made unnecessary by good register allocation    are detected and omitted from the output.  (Though most of these    are removed by the last jump pass.)     Instructions to set the condition codes are omitted when it can be    seen that the condition codes already had the desired values.     In some cases it is sufficient if the inherited condition codes    have related values, but this may require the following insn    (the one that tests the condition codes) to be modified.     The code for the function prologue and epilogue are generated    directly in assembler by the target functions function_prologue and    function_epilogue.  Those instructions never exist as rtl.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"coverage.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_comment
comment|/* Needed for external data 				   declarations for e.g. AIX 4.x.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we aren't using cc0, CC_STATUS_INIT shouldn't exist.  So define a    null default for it to save conditionalization later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC_STATUS_INIT
end_ifndef

begin_define
define|#
directive|define
name|CC_STATUS_INIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Is the given character a logical line separator for the assembler?  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IS_ASM_LOGICAL_LINE_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|IS_ASM_LOGICAL_LINE_SEPARATOR
parameter_list|(
name|C
parameter_list|)
value|((C) == ';')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|JUMP_TABLES_IN_TEXT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|JUMP_TABLES_IN_TEXT_SECTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bitflags used by final_scan_insn.  */
end_comment

begin_define
define|#
directive|define
name|SEEN_BB
value|1
end_define

begin_define
define|#
directive|define
name|SEEN_NOTE
value|2
end_define

begin_define
define|#
directive|define
name|SEEN_EMITTED
value|4
end_define

begin_comment
comment|/* Last insn processed by final_scan_insn.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|debug_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|current_output_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last NOTE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest line number in current block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|high_block_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|high_function_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename of last NOTE.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|last_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to force emission of a line note before the next insn.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|force_source_line
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|int
name|length_unit_log
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is defined in insn-attrtab.c.  */
end_comment

begin_comment
comment|/* Nonzero while outputting an `asm' with operands.    This means that inconsistencies are the user's fault, so don't die.    The precise value is the insn being output, to pass to error_for_asm.  */
end_comment

begin_decl_stmt
name|rtx
name|this_is_asm_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands of this insn, for an `asm' with operands.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|insn_noperands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare optimization flag.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_ignored_compare
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign a unique number to each insn that is output.    This can be used to generate unique local labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* This variable contains machine-dependent flags (defined in tm.h)    set and examined by output routines    that describe how to interpret the condition codes properly.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During output of an insn, this contains a copy of cc_status    from before the insn.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_prev_status
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by hardware reg number, is 1 if that register is ever    used in the current function.     In life_analysis, or in stupid_life_analysis, this is set    up to record the hard regs used explicitly.  Reload adds    in the hard regs used for holding pseudo regs.  Final uses    it to generate the code in the function prologue and epilogue    to save and restore registers as needed.  */
end_comment

begin_decl_stmt
name|char
name|regs_ever_live
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like regs_ever_live, but 1 if a reg is set or clobbered from an asm.    Unlike regs_ever_live, elements of this array corresponding to    eliminable regs like the frame pointer are set if an asm sets them.  */
end_comment

begin_decl_stmt
name|char
name|regs_asm_clobbered
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means current function must be given a frame pointer.    Initialized in function.c to 0.  Set only in reload1.c as per    the needs of the function.  */
end_comment

begin_decl_stmt
name|int
name|frame_pointer_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of unmatched NOTE_INSN_BLOCK_BEG notes we have seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|block_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if have enabled APP processing of our assembler output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|app_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are outputting an insn sequence, this contains the sequence rtx.    Zero otherwise.  */
end_comment

begin_decl_stmt
name|rtx
name|final_sequence
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
end_ifdef

begin_comment
comment|/* Number of the assembler dialect to use, starting at 0.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dialect_number
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
end_ifdef

begin_comment
comment|/* Nonnull if the insn currently being emitted was a COND_EXEC pattern.  */
end_comment

begin_decl_stmt
name|rtx
name|current_insn_predicate
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_function_decl
specifier|static
name|int
name|asm_insn_count
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|profile_function
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|profile_after_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|notice_source_line
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|walk_alter_subreg
parameter_list|(
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_asm_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_alternate_entry_point
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_mem_expr_from_op
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_asm_operand_names
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_operand
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_function_decl
specifier|static
name|void
name|leaf_renumber_regs
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_function_decl
specifier|static
name|int
name|alter_cond
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ADDR_VEC_ALIGN
end_ifndef

begin_function_decl
specifier|static
name|int
name|final_addr_vec_align
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_function_decl
specifier|static
name|int
name|align_fuzz
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Initialize data in final at the beginning of a compilation.  */
end_comment

begin_function
name|void
name|init_final
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|app_on
operator|=
literal|0
expr_stmt|;
name|final_sequence
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
name|dialect_number
operator|=
name|ASSEMBLER_DIALECT
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Default target function prologue and epilogue assembler output.     If not overridden for epilogue code, then the function body itself    contains return instructions wherever needed.  */
end_comment

begin_function
name|void
name|default_function_pro_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Default target hook that outputs nothing to a stream.  */
end_comment

begin_function
name|void
name|no_asm_to_stream
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Enable APP processing of subsequent output.    Used before the output from an `asm' statement.  */
end_comment

begin_function
name|void
name|app_enable
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_ON
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable APP processing of subsequent output.    Called from varasm.c before most kinds of output.  */
end_comment

begin_function
name|void
name|app_disable
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of slots filled in the current    delayed branch sequence (we don't count the insn needing the    delay slot).   Zero if not in a delayed branch sequence.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_function
name|int
name|dbr_sequence_length
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|final_sequence
operator|!=
literal|0
condition|)
return|return
name|XVECLEN
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The next two pages contain routines used to compute the length of an insn    and to shorten branches.  */
end_comment

begin_comment
comment|/* Arrays for insn lengths, and addresses.  The latter is referenced by    `insn_current_length'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_lengths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|varray_type
name|insn_addresses_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max uid for which the above arrays are valid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_lengths_max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of insn being processed.  Used by `insn_current_length'.  */
end_comment

begin_decl_stmt
name|int
name|insn_current_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of insn being processed in previous iteration.  */
end_comment

begin_decl_stmt
name|int
name|insn_last_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* known invariant alignment of insn being processed.  */
end_comment

begin_decl_stmt
name|int
name|insn_current_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After shorten_branches, for any insn, uid_align[INSN_UID (insn)]    gives the next following alignment insn that increases the known    alignment, or NULL_RTX if there is no such insn.    For any alignment obtained this way, we can again index uid_align with    its uid to obtain the next following align that in turn increases the    alignment, till we reach NULL_RTX; the sequence obtained this way    for each insn we'll call the alignment chain of this insn in the following    comments.  */
end_comment

begin_struct
struct|struct
name|label_alignment
block|{
name|short
name|alignment
decl_stmt|;
name|short
name|max_skip
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|uid_align
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_shuid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|label_alignment
modifier|*
name|label_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate that branch shortening hasn't yet been done.  */
end_comment

begin_function
name|void
name|init_insn_lengths
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|uid_shuid
condition|)
block|{
name|free
argument_list|(
name|uid_shuid
argument_list|)
expr_stmt|;
name|uid_shuid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insn_lengths
condition|)
block|{
name|free
argument_list|(
name|insn_lengths
argument_list|)
expr_stmt|;
name|insn_lengths
operator|=
literal|0
expr_stmt|;
name|insn_lengths_max_uid
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|INSN_ADDRESSES_FREE
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uid_align
condition|)
block|{
name|free
argument_list|(
name|uid_align
argument_list|)
expr_stmt|;
name|uid_align
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Obtain the current length of an insn.  If branch shortening has been done,    get its actual length.  Otherwise, use FALLBACK_FN to calculate the    length.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|get_attr_length_1
argument_list|(
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
argument_list|,
name|int
argument_list|(
argument|*fallback_fn
argument_list|)
operator|(
name|rtx
operator|)
name|ATTRIBUTE_UNUSED
argument_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|rtx
name|body
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insn_lengths_max_uid
operator|>
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|insn_lengths
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
return|;
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
case|case
name|CODE_LABEL
case|:
return|return
literal|0
return|;
case|case
name|CALL_INSN
case|:
name|length
operator|=
name|fallback_fn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
comment|/* Alignment is machine-dependent and should be handled by 	       ADDR_VEC_ALIGN.  */
block|}
else|else
name|length
operator|=
name|fallback_fn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
name|length
operator|=
name|asm_insn_count
argument_list|(
name|body
argument_list|)
operator|*
name|fallback_fn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|length
operator|+=
name|get_attr_length
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|fallback_fn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|length
return|;
else|#
directive|else
comment|/* not HAVE_ATTR_length */
return|return
literal|0
return|;
define|#
directive|define
name|insn_default_length
value|0
define|#
directive|define
name|insn_min_length
value|0
endif|#
directive|endif
comment|/* not HAVE_ATTR_length */
block|}
end_decl_stmt

begin_comment
comment|/* Obtain the current length of an insn.  If branch shortening has been done,    get its actual length.  Otherwise, get its maximum length.  */
end_comment

begin_function
name|int
name|get_attr_length
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|get_attr_length_1
argument_list|(
name|insn
argument_list|,
name|insn_default_length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Obtain the current length of an insn.  If branch shortening has been done,    get its actual length.  Otherwise, get its minimum length.  */
end_comment

begin_function
name|int
name|get_attr_min_length
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|get_attr_length_1
argument_list|(
name|insn
argument_list|,
name|insn_min_length
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code to handle alignment inside shorten_branches.  */
end_comment

begin_comment
comment|/* Here is an explanation how the algorithm in align_fuzz can give    proper results:     Call a sequence of instructions beginning with alignment point X    and continuing until the next alignment point `block X'.  When `X'    is used in an expression, it means the alignment value of the    alignment point.     Call the distance between the start of the first insn of block X, and    the end of the last insn of block X `IX', for the `inner size of X'.    This is clearly the sum of the instruction lengths.     Likewise with the next alignment-delimited block following X, which we    shall call block Y.     Call the distance between the start of the first insn of block X, and    the start of the first insn of block Y `OX', for the `outer size of X'.     The estimated padding is then OX - IX.     OX can be safely estimated as             if (X>= Y)                    OX = round_up(IX, Y)            else                    OX = round_up(IX, X) + Y - X     Clearly est(IX)>= real(IX), because that only depends on the    instruction lengths, and those being overestimated is a given.     Clearly round_up(foo, Z)>= round_up(bar, Z) if foo>= bar, so    we needn't worry about that when thinking about OX.     When X>= Y, the alignment provided by Y adds no uncertainty factor    for branch ranges starting before X, so we can just round what we have.    But when X< Y, we don't know anything about the, so to speak,    `middle bits', so we have to assume the worst when aligning up from an    address mod X to one mod Y, which is Y - X.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN
parameter_list|(
name|LABEL
parameter_list|)
value|align_labels_log
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN_MAX_SKIP
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN_MAX_SKIP
value|align_labels_max_skip
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOOP_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|LOOP_ALIGN
parameter_list|(
name|LABEL
parameter_list|)
value|align_loops_log
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOOP_ALIGN_MAX_SKIP
end_ifndef

begin_define
define|#
directive|define
name|LOOP_ALIGN_MAX_SKIP
value|align_loops_max_skip
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN_AFTER_BARRIER
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN_AFTER_BARRIER
parameter_list|(
name|LABEL
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|JUMP_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|JUMP_ALIGN
parameter_list|(
name|LABEL
parameter_list|)
value|align_jumps_log
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|JUMP_ALIGN_MAX_SKIP
end_ifndef

begin_define
define|#
directive|define
name|JUMP_ALIGN_MAX_SKIP
value|align_jumps_max_skip
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ADDR_VEC_ALIGN
end_ifndef

begin_function
specifier|static
name|int
name|final_addr_vec_align
parameter_list|(
name|rtx
name|addr_vec
parameter_list|)
block|{
name|int
name|align
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|PATTERN
argument_list|(
name|addr_vec
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|align
operator|>
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|exact_log2
argument_list|(
name|align
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ADDR_VEC_ALIGN
parameter_list|(
name|ADDR_VEC
parameter_list|)
value|final_addr_vec_align (ADDR_VEC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_LENGTH_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|INSN_LENGTH_ALIGNMENT
parameter_list|(
name|INSN
parameter_list|)
value|length_unit_log
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INSN_SHUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_shuid[INSN_UID (INSN)])
end_define

begin_decl_stmt
specifier|static
name|int
name|min_labelno
decl_stmt|,
name|max_labelno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LABEL_TO_ALIGNMENT
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|(label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].alignment)
end_define

begin_define
define|#
directive|define
name|LABEL_TO_MAX_SKIP
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|(label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].max_skip)
end_define

begin_comment
comment|/* For the benefit of port specific code do this also as a function.  */
end_comment

begin_function
name|int
name|label_to_alignment
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
return|return
name|LABEL_TO_ALIGNMENT
argument_list|(
name|label
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_comment
comment|/* The differences in addresses    between a branch and its target might grow or shrink depending on    the alignment the start insn of the range (the branch for a forward    branch or the label for a backward branch) starts out on; if these    differences are used naively, they can even oscillate infinitely.    We therefore want to compute a 'worst case' address difference that    is independent of the alignment the start insn of the range end    up on, and that is at least as large as the actual difference.    The function align_fuzz calculates the amount we have to add to the    naively computed difference, by traversing the part of the alignment    chain of the start insn of the range that is in front of the end insn    of the range, and considering for each alignment the maximum amount    that it might contribute to a size increase.     For casesi tables, we also want to know worst case minimum amounts of    address difference, in case a machine description wants to introduce    some common offset that is added to all offsets in a table.    For this purpose, align_fuzz with a growth argument of 0 computes the    appropriate adjustment.  */
end_comment

begin_comment
comment|/* Compute the maximum delta by which the difference of the addresses of    START and END might grow / shrink due to a different address for start    which changes the size of alignment insns between START and END.    KNOWN_ALIGN_LOG is the alignment known for START.    GROWTH should be ~0 if the objective is to compute potential code size    increase, and 0 if the objective is to compute potential shrink.    The return value is undefined for any other value of GROWTH.  */
end_comment

begin_function
specifier|static
name|int
name|align_fuzz
parameter_list|(
name|rtx
name|start
parameter_list|,
name|rtx
name|end
parameter_list|,
name|int
name|known_align_log
parameter_list|,
name|unsigned
name|int
name|growth
parameter_list|)
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|rtx
name|align_label
decl_stmt|;
name|int
name|known_align
init|=
literal|1
operator|<<
name|known_align_log
decl_stmt|;
name|int
name|end_shuid
init|=
name|INSN_SHUID
argument_list|(
name|end
argument_list|)
decl_stmt|;
name|int
name|fuzz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|align_label
operator|=
name|uid_align
index|[
name|uid
index|]
init|;
name|align_label
condition|;
name|align_label
operator|=
name|uid_align
index|[
name|uid
index|]
control|)
block|{
name|int
name|align_addr
decl_stmt|,
name|new_align
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|align_label
argument_list|)
expr_stmt|;
name|align_addr
operator|=
name|INSN_ADDRESSES
argument_list|(
name|uid
argument_list|)
operator|-
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
if|if
condition|(
name|uid_shuid
index|[
name|uid
index|]
operator|>
name|end_shuid
condition|)
break|break;
name|known_align_log
operator|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|align_label
argument_list|)
expr_stmt|;
name|new_align
operator|=
literal|1
operator|<<
name|known_align_log
expr_stmt|;
if|if
condition|(
name|new_align
operator|<
name|known_align
condition|)
continue|continue;
name|fuzz
operator|+=
operator|(
operator|-
name|align_addr
operator|^
name|growth
operator|)
operator|&
operator|(
name|new_align
operator|-
name|known_align
operator|)
expr_stmt|;
name|known_align
operator|=
name|new_align
expr_stmt|;
block|}
return|return
name|fuzz
return|;
block|}
end_function

begin_comment
comment|/* Compute a worst-case reference address of a branch so that it    can be safely used in the presence of aligned labels.  Since the    size of the branch itself is unknown, the size of the branch is    not included in the range.  I.e. for a forward branch, the reference    address is the end address of the branch as known from the previous    branch shortening pass, minus a value to account for possible size    increase due to alignment.  For a backward branch, it is the start    address of the branch as known from the current pass, plus a value    to account for possible size increase due to alignment.    NB.: Therefore, the maximum offset allowed for backward branches needs    to exclude the branch size.  */
end_comment

begin_function
name|int
name|insn_current_reference_address
parameter_list|(
name|rtx
name|branch
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|seq_uid
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_ADDRESSES_SET_P
argument_list|()
condition|)
return|return
literal|0
return|;
name|seq
operator|=
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|branch
argument_list|)
argument_list|)
expr_stmt|;
name|seq_uid
operator|=
name|INSN_UID
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|branch
argument_list|)
condition|)
comment|/* This can happen for example on the PA; the objective is to know the        offset to address something in front of the start of the function.        Thus, we can treat it like a backward branch.        We assume here that FUNCTION_BOUNDARY / BITS_PER_UNIT is larger than        any alignment we'd encounter, so we skip the call to align_fuzz.  */
return|return
name|insn_current_address
return|;
name|dest
operator|=
name|JUMP_LABEL
argument_list|(
name|branch
argument_list|)
expr_stmt|;
comment|/* BRANCH has no proper alignment chain set, so use SEQ.      BRANCH also has no INSN_SHUID.  */
if|if
condition|(
name|INSN_SHUID
argument_list|(
name|seq
argument_list|)
operator|<
name|INSN_SHUID
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Forward branch.  */
return|return
operator|(
name|insn_last_address
operator|+
name|insn_lengths
index|[
name|seq_uid
index|]
operator|-
name|align_fuzz
argument_list|(
name|seq
argument_list|,
name|dest
argument_list|,
name|length_unit_log
argument_list|,
operator|~
literal|0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* Backward branch.  */
return|return
operator|(
name|insn_current_address
operator|+
name|align_fuzz
argument_list|(
name|dest
argument_list|,
name|seq
argument_list|,
name|length_unit_log
argument_list|,
operator|~
literal|0
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ATTR_length */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Compute branch alignments based on frequency information in the    CFG.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|compute_alignments
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|log
decl_stmt|,
name|max_skip
decl_stmt|,
name|max_log
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|label_align
condition|)
block|{
name|free
argument_list|(
name|label_align
argument_list|)
expr_stmt|;
name|label_align
operator|=
literal|0
expr_stmt|;
block|}
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|label_align
operator|=
name|XCNEWVEC
argument_list|(
expr|struct
name|label_alignment
argument_list|,
name|max_labelno
operator|-
name|min_labelno
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If not optimizing or optimizing for size, don't assign any alignments.  */
if|if
condition|(
operator|!
name|optimize
operator|||
name|optimize_size
condition|)
return|return
literal|0
return|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|label
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|int
name|fallthru_frequency
init|=
literal|0
decl_stmt|,
name|branch_frequency
init|=
literal|0
decl_stmt|,
name|has_fallthru
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|LABEL_P
argument_list|(
name|label
argument_list|)
operator|||
name|probably_never_executed_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
name|max_log
operator|=
name|LABEL_ALIGN
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|max_skip
operator|=
name|LABEL_ALIGN_MAX_SKIP
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|has_fallthru
operator|=
literal|1
operator|,
name|fallthru_frequency
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
name|branch_frequency
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* There are two purposes to align block with no fallthru incoming edge: 	 1) to avoid fetch stalls when branch destination is near cache boundary 	 2) to improve cache efficiency in case the previous block is not executed 	    (so it does not need to be in the cache).  	 We to catch first case, we align frequently executed blocks. 	 To catch the second, we align blocks that are executed more frequently 	 than the predecessor and the predecessor is likely to not be executed 	 when function is called.  */
if|if
condition|(
operator|!
name|has_fallthru
operator|&&
operator|(
name|branch_frequency
operator|>
name|BB_FREQ_MAX
operator|/
literal|10
operator|||
operator|(
name|bb
operator|->
name|frequency
operator|>
name|bb
operator|->
name|prev_bb
operator|->
name|frequency
operator|*
literal|10
operator|&&
operator|(
name|bb
operator|->
name|prev_bb
operator|->
name|frequency
operator|<=
name|ENTRY_BLOCK_PTR
operator|->
name|frequency
operator|/
literal|2
operator|)
operator|)
operator|)
condition|)
block|{
name|log
operator|=
name|JUMP_ALIGN
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|JUMP_ALIGN_MAX_SKIP
expr_stmt|;
block|}
block|}
comment|/* In case block is frequent and reached mostly by non-fallthru edge, 	 align it.  It is most likely a first block of loop.  */
if|if
condition|(
name|has_fallthru
operator|&&
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
operator|&&
name|branch_frequency
operator|+
name|fallthru_frequency
operator|>
name|BB_FREQ_MAX
operator|/
literal|10
operator|&&
name|branch_frequency
operator|>
name|fallthru_frequency
operator|*
literal|2
condition|)
block|{
name|log
operator|=
name|LOOP_ALIGN
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LOOP_ALIGN_MAX_SKIP
expr_stmt|;
block|}
block|}
name|LABEL_TO_ALIGNMENT
argument_list|(
name|label
argument_list|)
operator|=
name|max_log
expr_stmt|;
name|LABEL_TO_MAX_SKIP
argument_list|(
name|label
argument_list|)
operator|=
name|max_skip
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_compute_alignments
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|compute_alignments
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Make a pass over all insns and compute their actual lengths by shortening    any branches of variable length if possible.  */
end_comment

begin_comment
comment|/* shorten_branches might be called multiple times:  for example, the SH    port splits out-of-range conditional branches in MACHINE_DEPENDENT_REORG.    In order to do this, it needs proper length information, which it obtains    by calling shorten_branches.  This cannot be collapsed with    shorten_branches itself into a single pass unless we also want to integrate    reorg.c, since the branch splitting exposes new instructions with delay    slots.  */
end_comment

begin_function
name|void
name|shorten_branches
parameter_list|(
name|rtx
name|first
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|max_log
decl_stmt|;
name|int
name|max_skip
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
define|#
directive|define
name|MAX_CODE_ALIGN
value|16
name|rtx
name|seq
decl_stmt|;
name|int
name|something_changed
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|varying_length
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|rtx
name|align_tab
index|[
name|MAX_CODE_ALIGN
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* Compute maximum UID and allocate label_align / uid_shuid.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
comment|/* Free uid_shuid before reallocating it.  */
name|free
argument_list|(
name|uid_shuid
argument_list|)
expr_stmt|;
name|uid_shuid
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_labelno
operator|!=
name|max_label_num
argument_list|()
condition|)
block|{
name|int
name|old
init|=
name|max_labelno
decl_stmt|;
name|int
name|n_labels
decl_stmt|;
name|int
name|n_old_labels
decl_stmt|;
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|n_labels
operator|=
name|max_labelno
operator|-
name|min_labelno
operator|+
literal|1
expr_stmt|;
name|n_old_labels
operator|=
name|old
operator|-
name|min_labelno
operator|+
literal|1
expr_stmt|;
name|label_align
operator|=
name|xrealloc
argument_list|(
name|label_align
argument_list|,
name|n_labels
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|label_alignment
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Range of labels grows monotonically in the function.  Failing here          means that the initialization of array got lost.  */
name|gcc_assert
argument_list|(
name|n_old_labels
operator|<=
name|n_labels
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|label_align
operator|+
name|n_old_labels
argument_list|,
literal|0
argument_list|,
operator|(
name|n_labels
operator|-
name|n_old_labels
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|label_alignment
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize label_align and set up uid_shuid to be strictly      monotonically rising with insn order.  */
comment|/* We use max_log here to keep track of the maximum alignment we want to      impose on the next CODE_LABEL (or the current one if we are processing      the CODE_LABEL itself).  */
name|max_log
operator|=
literal|0
expr_stmt|;
name|max_skip
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
operator|,
name|i
operator|=
literal|1
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|log
decl_stmt|;
name|INSN_SHUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|next
decl_stmt|;
comment|/* Merge in alignments computed by compute_alignments.  */
name|log
operator|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LABEL_TO_MAX_SKIP
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|log
operator|=
name|LABEL_ALIGN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LABEL_ALIGN_MAX_SKIP
expr_stmt|;
block|}
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* ADDR_VECs only take room if read-only data goes into the text 	     section.  */
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
operator|||
name|readonly_data_section
operator|==
name|text_section
condition|)
if|if
condition|(
name|next
operator|&&
name|JUMP_P
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|rtx
name|nextbody
init|=
name|PATTERN
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|log
operator|=
name|ADDR_VEC_ALIGN
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LABEL_ALIGN_MAX_SKIP
expr_stmt|;
block|}
block|}
block|}
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
operator|=
name|max_log
expr_stmt|;
name|LABEL_TO_MAX_SKIP
argument_list|(
name|insn
argument_list|)
operator|=
name|max_skip
expr_stmt|;
name|max_log
operator|=
literal|0
expr_stmt|;
name|max_skip
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|label
decl_stmt|;
for|for
control|(
name|label
operator|=
name|insn
init|;
name|label
operator|&&
operator|!
name|INSN_P
argument_list|(
name|label
argument_list|)
condition|;
name|label
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|LABEL_P
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|log
operator|=
name|LABEL_ALIGN_AFTER_BARRIER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
comment|/* Allocate the rest of the arrays.  */
name|insn_lengths
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
name|insn_lengths_max_uid
operator|=
name|max_uid
expr_stmt|;
comment|/* Syntax errors can lead to labels being outside of the main insn stream.      Initialize insn_addresses, so that we get reproducible results.  */
name|INSN_ADDRESSES_ALLOC
argument_list|(
name|max_uid
argument_list|)
expr_stmt|;
name|varying_length
operator|=
name|XCNEWVEC
argument_list|(
name|char
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
comment|/* Initialize uid_align.  We scan instructions      from end to start, and keep in align_tab[n] the last seen insn      that does an alignment of at least n+1, i.e. the successor      in the alignment chain for an insn that does / has a known      alignment of n.  */
name|uid_align
operator|=
name|XCNEWVEC
argument_list|(
name|rtx
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MAX_CODE_ALIGN
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|align_tab
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|seq
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|seq
condition|;
name|seq
operator|=
name|PREV_INSN
argument_list|(
name|seq
argument_list|)
control|)
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|seq
argument_list|)
decl_stmt|;
name|int
name|log
decl_stmt|;
name|log
operator|=
operator|(
name|LABEL_P
argument_list|(
name|seq
argument_list|)
condition|?
name|LABEL_TO_ALIGNMENT
argument_list|(
name|seq
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|uid_align
index|[
name|uid
index|]
operator|=
name|align_tab
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|log
condition|)
block|{
comment|/* Found an alignment label.  */
name|uid_align
index|[
name|uid
index|]
operator|=
name|align_tab
index|[
name|log
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|log
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|align_tab
index|[
name|i
index|]
operator|=
name|seq
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CASE_VECTOR_SHORTEN_MODE
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Look for ADDR_DIFF_VECs, and initialize their minimum and maximum          label fields.  */
name|int
name|min_shuid
init|=
name|INSN_SHUID
argument_list|(
name|get_insns
argument_list|()
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|max_shuid
init|=
name|INSN_SHUID
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|rel
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|min_lab
init|=
name|NULL_RTX
decl_stmt|,
name|max_lab
init|=
name|NULL_RTX
decl_stmt|,
name|pat
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|,
name|insn_shuid
decl_stmt|;
name|int
name|min_align
decl_stmt|;
name|addr_diff_vec_flags
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|len
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|min_align
operator|=
name|MAX_CODE_ALIGN
expr_stmt|;
for|for
control|(
name|min
operator|=
name|max_shuid
operator|,
name|max
operator|=
name|min_shuid
operator|,
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|shuid
init|=
name|INSN_SHUID
argument_list|(
name|lab
argument_list|)
decl_stmt|;
if|if
condition|(
name|shuid
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|shuid
expr_stmt|;
name|min_lab
operator|=
name|lab
expr_stmt|;
block|}
if|if
condition|(
name|shuid
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|shuid
expr_stmt|;
name|max_lab
operator|=
name|lab
expr_stmt|;
block|}
if|if
condition|(
name|min_align
operator|>
name|LABEL_TO_ALIGNMENT
argument_list|(
name|lab
argument_list|)
condition|)
name|min_align
operator|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|min_lab
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|3
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|max_lab
argument_list|)
expr_stmt|;
name|insn_shuid
operator|=
name|INSN_SHUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|rel
operator|=
name|INSN_SHUID
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|.
name|min_align
operator|=
name|min_align
expr_stmt|;
name|flags
operator|.
name|base_after_vec
operator|=
name|rel
operator|>
name|insn_shuid
expr_stmt|;
name|flags
operator|.
name|min_after_vec
operator|=
name|min
operator|>
name|insn_shuid
expr_stmt|;
name|flags
operator|.
name|max_after_vec
operator|=
name|max
operator|>
name|insn_shuid
expr_stmt|;
name|flags
operator|.
name|min_after_base
operator|=
name|min
operator|>
name|rel
expr_stmt|;
name|flags
operator|.
name|max_after_base
operator|=
name|max
operator|>
name|rel
expr_stmt|;
name|ADDR_DIFF_VEC_FLAGS
argument_list|(
name|pat
argument_list|)
operator|=
name|flags
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CASE_VECTOR_SHORTEN_MODE */
comment|/* Compute initial lengths, addresses, and varying flags for each insn.  */
for|for
control|(
name|insn_current_address
operator|=
literal|0
operator|,
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
operator|,
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|log
init|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
condition|)
block|{
name|int
name|align
init|=
literal|1
operator|<<
name|log
decl_stmt|;
name|int
name|new_address
init|=
operator|(
name|insn_current_address
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|-
name|align
decl_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|new_address
operator|-
name|insn_current_address
expr_stmt|;
block|}
block|}
name|INSN_ADDRESSES
argument_list|(
name|uid
argument_list|)
operator|=
name|insn_current_address
operator|+
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|||
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
operator|||
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
comment|/* This only takes room if read-only data goes into the text 	     section.  */
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
operator|||
name|readonly_data_section
operator|==
name|text_section
condition|)
name|insn_lengths
index|[
name|uid
index|]
operator|=
operator|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Alignment is handled by ADDR_VEC_ALIGN.  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|asm_insn_count
argument_list|(
name|body
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|const_delay_slots
decl_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|const_delay_slots
operator|=
name|const_num_delay_slots
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|const_delay_slots
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Inside a delay slot sequence, we do not do any branch shortening 	     if the shortening could change the number of delay slots 	     of the branch.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|inner_insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|inner_uid
init|=
name|INSN_UID
argument_list|(
name|inner_insn
argument_list|)
decl_stmt|;
name|int
name|inner_length
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|inner_length
operator|=
operator|(
name|asm_insn_count
argument_list|(
name|PATTERN
argument_list|(
name|inner_insn
argument_list|)
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|inner_insn
argument_list|)
operator|)
expr_stmt|;
else|else
name|inner_length
operator|=
name|insn_default_length
argument_list|(
name|inner_insn
argument_list|)
expr_stmt|;
name|insn_lengths
index|[
name|inner_uid
index|]
operator|=
name|inner_length
expr_stmt|;
if|if
condition|(
name|const_delay_slots
condition|)
block|{
if|if
condition|(
operator|(
name|varying_length
index|[
name|inner_uid
index|]
operator|=
name|insn_variable_length_p
argument_list|(
name|inner_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|varying_length
index|[
name|uid
index|]
operator|=
literal|1
expr_stmt|;
name|INSN_ADDRESSES
argument_list|(
name|inner_uid
argument_list|)
operator|=
operator|(
name|insn_current_address
operator|+
name|insn_lengths
index|[
name|uid
index|]
operator|)
expr_stmt|;
block|}
else|else
name|varying_length
index|[
name|inner_uid
index|]
operator|=
literal|0
expr_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|+=
name|inner_length
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|varying_length
index|[
name|uid
index|]
operator|=
name|insn_variable_length_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If needed, do any adjustment.  */
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|insn_lengths
index|[
name|uid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_lengths
index|[
name|uid
index|]
operator|<
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"negative insn length"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Now loop over all the insns finding varying length insns.  For each,      get the current insn length.  If it has changed, reflect the change.      When nothing changes for a full pass, we are done.  */
while|while
condition|(
name|something_changed
condition|)
block|{
name|something_changed
operator|=
literal|0
expr_stmt|;
name|insn_current_align
operator|=
name|MAX_CODE_ALIGN
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|insn_current_address
operator|=
literal|0
operator|,
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|new_length
decl_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|int
name|tmp_length
decl_stmt|;
endif|#
directive|endif
name|int
name|length_align
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|int
name|log
init|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|>
name|insn_current_align
condition|)
block|{
name|int
name|align
init|=
literal|1
operator|<<
name|log
decl_stmt|;
name|int
name|new_address
init|=
operator|(
name|insn_current_address
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|-
name|align
decl_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|new_address
operator|-
name|insn_current_address
expr_stmt|;
name|insn_current_align
operator|=
name|log
expr_stmt|;
name|insn_current_address
operator|=
name|new_address
expr_stmt|;
block|}
else|else
name|insn_lengths
index|[
name|uid
index|]
operator|=
literal|0
expr_stmt|;
name|INSN_ADDRESSES
argument_list|(
name|uid
argument_list|)
operator|=
name|insn_current_address
expr_stmt|;
continue|continue;
block|}
name|length_align
operator|=
name|INSN_LENGTH_ALIGNMENT
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|length_align
operator|<
name|insn_current_align
condition|)
name|insn_current_align
operator|=
name|length_align
expr_stmt|;
name|insn_last_address
operator|=
name|INSN_ADDRESSES
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|INSN_ADDRESSES
argument_list|(
name|uid
argument_list|)
operator|=
name|insn_current_address
expr_stmt|;
ifdef|#
directive|ifdef
name|CASE_VECTOR_SHORTEN_MODE
if|if
condition|(
name|optimize
operator|&&
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|old_length
init|=
name|insn_lengths
index|[
name|uid
index|]
decl_stmt|;
name|rtx
name|rel_lab
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|min_lab
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|max_lab
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|rel_addr
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|rel_lab
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|min_addr
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|min_lab
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|max_addr
init|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|max_lab
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|int
name|rel_align
init|=
literal|0
decl_stmt|;
name|addr_diff_vec_flags
name|flags
decl_stmt|;
comment|/* Avoid automatic aggregate initialization.  */
name|flags
operator|=
name|ADDR_DIFF_VEC_FLAGS
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* Try to find a known alignment for rel_lab.  */
for|for
control|(
name|prev
operator|=
name|rel_lab
init|;
name|prev
operator|&&
operator|!
name|insn_lengths
index|[
name|INSN_UID
argument_list|(
name|prev
argument_list|)
index|]
operator|&&
operator|!
operator|(
name|varying_length
index|[
name|INSN_UID
argument_list|(
name|prev
argument_list|)
index|]
operator|&
literal|1
operator|)
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|varying_length
index|[
name|INSN_UID
argument_list|(
name|prev
argument_list|)
index|]
operator|&
literal|2
condition|)
block|{
name|rel_align
operator|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|prev
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* See the comment on addr_diff_vec_flags in rtl.h for the 		 meaning of the flags values.  base: REL_LAB   vec: INSN  */
comment|/* Anything after INSN has still addresses from the last 		 pass; adjust these so that they reflect our current 		 estimate for this pass.  */
if|if
condition|(
name|flags
operator|.
name|base_after_vec
condition|)
name|rel_addr
operator|+=
name|insn_current_address
operator|-
name|insn_last_address
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|min_after_vec
condition|)
name|min_addr
operator|+=
name|insn_current_address
operator|-
name|insn_last_address
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|max_after_vec
condition|)
name|max_addr
operator|+=
name|insn_current_address
operator|-
name|insn_last_address
expr_stmt|;
comment|/* We want to know the worst case, i.e. lowest possible value 		 for the offset of MIN_LAB.  If MIN_LAB is after REL_LAB, 		 its offset is positive, and we have to be wary of code shrink; 		 otherwise, it is negative, and we have to be vary of code 		 size increase.  */
if|if
condition|(
name|flags
operator|.
name|min_after_base
condition|)
block|{
comment|/* If INSN is between REL_LAB and MIN_LAB, the size 		     changes we are about to make can change the alignment 		     within the observed offset, therefore we have to break 		     it up into two parts that are independent.  */
if|if
condition|(
operator|!
name|flags
operator|.
name|base_after_vec
operator|&&
name|flags
operator|.
name|min_after_vec
condition|)
block|{
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|insn
argument_list|,
name|rel_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|min_lab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|min_lab
argument_list|,
name|rel_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|base_after_vec
operator|&&
operator|!
name|flags
operator|.
name|min_after_vec
condition|)
block|{
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|min_lab
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|min_lab
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise, determine the highest lowest possible value 		 for the offset of MAX_LAB.  */
if|if
condition|(
name|flags
operator|.
name|max_after_base
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|.
name|base_after_vec
operator|&&
name|flags
operator|.
name|max_after_vec
condition|)
block|{
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|insn
argument_list|,
name|rel_align
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|max_lab
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|max_lab
argument_list|,
name|rel_align
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|base_after_vec
operator|&&
operator|!
name|flags
operator|.
name|max_after_vec
condition|)
block|{
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|max_lab
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|max_lab
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|body
argument_list|,
name|CASE_VECTOR_SHORTEN_MODE
argument_list|(
name|min_addr
operator|-
name|rel_addr
argument_list|,
name|max_addr
operator|-
name|rel_addr
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
operator|||
name|readonly_data_section
operator|==
name|text_section
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
operator|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
if|if
condition|(
name|insn_lengths
index|[
name|uid
index|]
operator|!=
name|old_length
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* CASE_VECTOR_SHORTEN_MODE */
if|if
condition|(
operator|!
operator|(
name|varying_length
index|[
name|uid
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|inner_insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|inner_uid
init|=
name|INSN_UID
argument_list|(
name|inner_insn
argument_list|)
decl_stmt|;
name|INSN_ADDRESSES
argument_list|(
name|inner_uid
argument_list|)
operator|=
name|insn_current_address
expr_stmt|;
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|inner_uid
index|]
expr_stmt|;
block|}
block|}
else|else
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|new_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|inner_insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|inner_uid
init|=
name|INSN_UID
argument_list|(
name|inner_insn
argument_list|)
decl_stmt|;
name|int
name|inner_length
decl_stmt|;
name|INSN_ADDRESSES
argument_list|(
name|inner_uid
argument_list|)
operator|=
name|insn_current_address
expr_stmt|;
comment|/* insn_current_length returns 0 for insns with a 		     non-varying length.  */
if|if
condition|(
operator|!
name|varying_length
index|[
name|inner_uid
index|]
condition|)
name|inner_length
operator|=
name|insn_lengths
index|[
name|inner_uid
index|]
expr_stmt|;
else|else
name|inner_length
operator|=
name|insn_current_length
argument_list|(
name|inner_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_length
operator|!=
name|insn_lengths
index|[
name|inner_uid
index|]
condition|)
block|{
name|insn_lengths
index|[
name|inner_uid
index|]
operator|=
name|inner_length
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|inner_uid
index|]
expr_stmt|;
name|new_length
operator|+=
name|inner_length
expr_stmt|;
block|}
block|}
else|else
block|{
name|new_length
operator|=
name|insn_current_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_current_address
operator|+=
name|new_length
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
comment|/* If needed, do any adjustment.  */
name|tmp_length
operator|=
name|new_length
expr_stmt|;
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|new_length
argument_list|)
expr_stmt|;
name|insn_current_address
operator|+=
operator|(
name|new_length
operator|-
name|tmp_length
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|new_length
operator|!=
name|insn_lengths
index|[
name|uid
index|]
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|new_length
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* For a non-optimizing compile, do only a single pass.  */
if|if
condition|(
operator|!
name|optimize
condition|)
break|break;
block|}
name|free
argument_list|(
name|varying_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_ATTR_length */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_comment
comment|/* Given the body of an INSN known to be generated by an ASM statement, return    the number of machine instructions likely to be generated for this insn.    This is used to compute its length.  */
end_comment

begin_function
specifier|static
name|int
name|asm_insn_count
parameter_list|(
name|rtx
name|body
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
condition|)
name|template
operator|=
name|XSTR
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|template
operator|=
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|template
condition|;
name|template
operator|++
control|)
if|if
condition|(
name|IS_ASM_LOGICAL_LINE_SEPARATOR
argument_list|(
operator|*
name|template
argument_list|)
operator|||
operator|*
name|template
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for the start of a function,    and initialize some of the variables in this file    for the new function.  The label for the function and associated    assembler pseudo-ops have already been output in `assemble_start_function'.     FIRST is the first insn of the rtl for the function being compiled.    FILE is the file to write assembler code to.    OPTIMIZE is nonzero if we should eliminate redundant      test and compare insns.  */
end_comment

begin_function
name|void
name|final_start_function
parameter_list|(
name|rtx
name|first
name|ATTRIBUTE_UNUSED
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|optimize
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|block_depth
operator|=
literal|0
expr_stmt|;
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
name|last_filename
operator|=
name|locator_file
argument_list|(
name|prologue_locator
argument_list|)
expr_stmt|;
name|last_linenum
operator|=
name|locator_line
argument_list|(
name|prologue_locator
argument_list|)
expr_stmt|;
name|high_block_linenum
operator|=
name|high_function_linenum
operator|=
name|last_linenum
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|begin_prologue
call|)
argument_list|(
name|last_linenum
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|TARGET_UNWIND_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|!=
name|DWARF2_DEBUG
operator|&&
name|write_symbols
operator|!=
name|VMS_AND_DWARF2_DEBUG
condition|)
name|dwarf2out_begin_prologue
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs
argument_list|(
name|first
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The Sun386i and perhaps other machines don't work right      if the profiling code comes after the prologue.  */
ifdef|#
directive|ifdef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|current_function_profile
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROFILE_BEFORE_PROLOGUE */
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|NULL_RTX
argument_list|,
name|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If debugging, assign block numbers to all of the blocks in this      function.  */
if|if
condition|(
name|write_symbols
condition|)
block|{
name|reemit_insn_block_notes
argument_list|()
expr_stmt|;
name|number_blocks
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* We never actually put out begin/end notes for the top-level 	 block in the function.  But, conceptually, that block is 	 always needed.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|warn_frame_larger_than
operator|&&
name|get_frame_size
argument_list|()
operator|>
name|frame_larger_than_size
condition|)
block|{
comment|/* Issue a warning */
name|warning
argument_list|(
name|OPT_Wframe_larger_than_
argument_list|,
literal|"the frame size of %wd bytes is larger than %wd bytes"
argument_list|,
name|get_frame_size
argument_list|()
argument_list|,
name|frame_larger_than_size
argument_list|)
expr_stmt|;
block|}
comment|/* First output the function prologue: code to set up the stack frame.  */
name|targetm
operator|.
name|asm_out
operator|.
name|function_prologue
argument_list|(
name|file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the machine represents the prologue as RTL, the profiling code must      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */
ifdef|#
directive|ifdef
name|HAVE_prologue
if|if
condition|(
operator|!
name|HAVE_prologue
condition|)
endif|#
directive|endif
name|profile_after_prologue
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|profile_after_prologue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|current_function_profile
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not PROFILE_BEFORE_PROLOGUE */
block|}
end_function

begin_function
specifier|static
name|void
name|profile_function
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
define|#
directive|define
name|NO_PROFILE_COUNTERS
value|0
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
name|int
name|sval
init|=
name|current_function_returns_struct
decl_stmt|;
name|rtx
name|svrtx
init|=
name|targetm
operator|.
name|calls
operator|.
name|struct_value_rtx
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
operator|||
name|defined
argument_list|(
name|STATIC_CHAIN_REGNUM
argument_list|)
name|int
name|cxt
init|=
name|cfun
operator|->
name|static_chain_decl
operator|!=
name|NULL
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ASM_OUTPUT_REG_PUSH */
if|if
condition|(
operator|!
name|NO_PROFILE_COUNTERS
condition|)
block|{
name|int
name|align
init|=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|LONG_TYPE_SIZE
argument_list|)
decl_stmt|;
name|switch_to_section
argument_list|(
name|data_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"LP"
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|LONG_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
name|align
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|sval
operator|&&
name|svrtx
operator|!=
name|NULL_RTX
operator|&&
name|REG_P
argument_list|(
name|svrtx
argument_list|)
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|REGNO
argument_list|(
name|svrtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
block|{
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|FUNCTION_PROFILER
argument_list|(
name|file
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
block|{
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|sval
operator|&&
name|svrtx
operator|!=
name|NULL_RTX
operator|&&
name|REG_P
argument_list|(
name|svrtx
argument_list|)
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|REGNO
argument_list|(
name|svrtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output assembler code for the end of a function.    For clarity, args are same as those of `final_start_function'    even though not all of them are needed.  */
end_comment

begin_function
name|void
name|final_end_function
parameter_list|(
name|void
parameter_list|)
block|{
name|app_disable
argument_list|()
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|end_function
call|)
argument_list|(
name|high_function_linenum
argument_list|)
expr_stmt|;
comment|/* Finally, output the function epilogue:      code to restore the stack frame and return to the caller.  */
name|targetm
operator|.
name|asm_out
operator|.
name|function_epilogue
argument_list|(
name|asm_out_file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
comment|/* And debug output.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|end_epilogue
call|)
argument_list|(
name|last_linenum
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|!=
name|DWARF2_DEBUG
operator|&&
name|write_symbols
operator|!=
name|VMS_AND_DWARF2_DEBUG
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_end_epilogue
argument_list|(
name|last_linenum
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for some insns: all or part of a function.    For description of args, see `final_start_function', above.  */
end_comment

begin_function
name|void
name|final
parameter_list|(
name|rtx
name|first
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|optimize
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
name|int
name|seen
init|=
literal|0
decl_stmt|;
name|last_ignored_compare
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
comment|/* When producing SDB debugging info, delete troublesome line number      notes from inlined functions in other files as well as duplicate      line number notes.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
block|{
name|rtx
name|last
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|last
operator|!=
literal|0
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
operator|&&
name|NOTE_SOURCE_LOCATION
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_LOCATION
argument_list|(
name|last
argument_list|)
else|#
directive|else
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|last
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|last
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Use delete_note.  */
continue|continue;
block|}
name|last
operator|=
name|insn
expr_stmt|;
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
comment|/* Find largest UID.  */
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If CC tracking across branches is enabled, record the insn which 	 jumps to each branch only reached from one place.  */
if|if
condition|(
name|optimize
operator|&&
name|JUMP_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|lab
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|lab
operator|&&
name|LABEL_NUSES
argument_list|(
name|lab
argument_list|)
operator|==
literal|1
condition|)
block|{
name|LABEL_REFS
argument_list|(
name|lab
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|init_recog
argument_list|()
expr_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Output the insns.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
if|if
condition|(
operator|(
name|unsigned
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|INSN_ADDRESSES_SIZE
argument_list|()
condition|)
block|{
comment|/* This can be triggered by bugs elsewhere in the compiler if 	     new insns are created after init_insn_lengths is called.  */
name|gcc_assert
argument_list|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|insn_current_address
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|insn_current_address
operator|=
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_ATTR_length */
name|insn
operator|=
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
name|optimize
argument_list|,
literal|0
argument_list|,
operator|&
name|seen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|const
name|char
modifier|*
name|get_insn_template
parameter_list|(
name|int
name|code
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
switch|switch
condition|(
name|insn_data
index|[
name|code
index|]
operator|.
name|output_format
condition|)
block|{
case|case
name|INSN_OUTPUT_FORMAT_SINGLE
case|:
return|return
name|insn_data
index|[
name|code
index|]
operator|.
name|output
operator|.
name|single
return|;
case|case
name|INSN_OUTPUT_FORMAT_MULTI
case|:
return|return
name|insn_data
index|[
name|code
index|]
operator|.
name|output
operator|.
name|multi
index|[
name|which_alternative
index|]
return|;
case|case
name|INSN_OUTPUT_FORMAT_FUNCTION
case|:
name|gcc_assert
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|insn_data
index|[
name|code
index|]
operator|.
name|output
operator|.
name|function
operator|)
operator|(
name|recog_data
operator|.
name|operand
operator|,
name|insn
operator|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit the appropriate declaration for an alternate-entry-point    symbol represented by INSN, to FILE.  INSN is a CODE_LABEL with    LABEL_KIND != LABEL_NORMAL.     The case fall-through in this function is intentional.  */
end_comment

begin_function
specifier|static
name|void
name|output_alternate_entry_point
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|LABEL_KIND
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|LABEL_WEAK_ENTRY
case|:
ifdef|#
directive|ifdef
name|ASM_WEAKEN_LABEL
name|ASM_WEAKEN_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|LABEL_GLOBAL_ENTRY
case|:
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
case|case
name|LABEL_STATIC_ENTRY
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_TYPE_DIRECTIVE
name|ASM_OUTPUT_TYPE_DIRECTIVE
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_NORMAL
case|:
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The final scan for one insn, INSN.    Args are same as in `final', except that INSN    is the insn being scanned.    Value returned is the next insn to be scanned.     NOPEEPHOLES is the flag to disallow peephole processing (currently    used for within delayed branch sequence output).     SEEN is used to track the end of the prologue, for emitting    debug information.  We force the emission of a line note after    both NOTE_INSN_PROLOGUE_END and NOTE_INSN_FUNCTION_BEG, or    at the beginning of the second basic block, whichever comes    first.  */
end_comment

begin_function
name|rtx
name|final_scan_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|optimize
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|nopeepholes
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|seen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|set
decl_stmt|;
endif|#
directive|endif
name|rtx
name|next
decl_stmt|;
name|insn_counter
operator|++
expr_stmt|;
comment|/* Ignore deleted insns.  These can occur when we split insns (due to a      template of "#") while not optimizing.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
switch|switch
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE_INSN_DELETED
case|:
case|case
name|NOTE_INSN_FUNCTION_END
case|:
case|case
name|NOTE_INSN_REPEATED_LINE_NUMBER
case|:
case|case
name|NOTE_INSN_EXPECTED_VALUE
case|:
break|break;
case|case
name|NOTE_INSN_SWITCH_TEXT_SECTIONS
case|:
name|in_cold_section_p
operator|=
operator|!
name|in_cold_section_p
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|switch_text_section
call|)
argument_list|()
expr_stmt|;
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BASIC_BLOCK
case|:
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
name|targetm
operator|.
name|asm_out
operator|.
name|unwind_emit
argument_list|(
name|asm_out_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s basic block %d\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|NOTE_BASIC_BLOCK
argument_list|(
name|insn
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|seen
operator|&
operator|(
name|SEEN_EMITTED
operator||
name|SEEN_BB
operator|)
operator|)
operator|==
name|SEEN_BB
condition|)
block|{
operator|*
name|seen
operator||=
name|SEEN_EMITTED
expr_stmt|;
name|force_source_line
operator|=
name|true
expr_stmt|;
block|}
else|else
operator|*
name|seen
operator||=
name|SEEN_BB
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_BEG
case|:
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LEHB"
argument_list|,
name|NOTE_EH_HANDLER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_EH_REGION_END
case|:
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LEHE"
argument_list|,
name|NOTE_EH_HANDLER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_PROLOGUE_END
case|:
name|targetm
operator|.
name|asm_out
operator|.
name|function_end_prologue
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|profile_after_prologue
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|seen
operator|&
operator|(
name|SEEN_EMITTED
operator||
name|SEEN_NOTE
operator|)
operator|)
operator|==
name|SEEN_NOTE
condition|)
block|{
operator|*
name|seen
operator||=
name|SEEN_EMITTED
expr_stmt|;
name|force_source_line
operator|=
name|true
expr_stmt|;
block|}
else|else
operator|*
name|seen
operator||=
name|SEEN_NOTE
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_EPILOGUE_BEG
case|:
name|targetm
operator|.
name|asm_out
operator|.
name|function_begin_epilogue
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_FUNCTION_BEG
case|:
name|app_disable
argument_list|()
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|end_prologue
call|)
argument_list|(
name|last_linenum
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|seen
operator|&
operator|(
name|SEEN_EMITTED
operator||
name|SEEN_NOTE
operator|)
operator|)
operator|==
name|SEEN_NOTE
condition|)
block|{
operator|*
name|seen
operator||=
name|SEEN_EMITTED
expr_stmt|;
name|force_source_line
operator|=
name|true
expr_stmt|;
block|}
else|else
operator|*
name|seen
operator||=
name|SEEN_NOTE
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_BLOCK_BEG
case|:
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_DEBUG
condition|)
block|{
name|int
name|n
init|=
name|BLOCK_NUMBER
argument_list|(
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|app_disable
argument_list|()
expr_stmt|;
operator|++
name|block_depth
expr_stmt|;
name|high_block_linenum
operator|=
name|last_linenum
expr_stmt|;
comment|/* Output debugging info about the symbol-block beginning.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|begin_block
call|)
argument_list|(
name|last_linenum
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Mark this block as output.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NOTE_INSN_BLOCK_END
case|:
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_DEBUG
condition|)
block|{
name|int
name|n
init|=
name|BLOCK_NUMBER
argument_list|(
name|NOTE_BLOCK
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|app_disable
argument_list|()
expr_stmt|;
comment|/* End of a symbol-block.  */
operator|--
name|block_depth
expr_stmt|;
name|gcc_assert
argument_list|(
name|block_depth
operator|>=
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|end_block
call|)
argument_list|(
name|high_block_linenum
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOTE_INSN_DELETED_LABEL
case|:
comment|/* Emit the label.  We may have deleted the CODE_LABEL because 	     the label could be proved to be unreachable, though still 	     referenced (in the form of having its address taken.  */
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOTE_INSN_VAR_LOCATION
case|:
call|(
modifier|*
name|debug_hooks
operator|->
name|var_location
call|)
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|gcc_assert
argument_list|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|BARRIER
case|:
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|insn
argument_list|,
name|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CODE_LABEL
case|:
comment|/* The target port might emit labels in the output function for 	 some insn, e.g. sh.c output_branchy_insn.  */
if|if
condition|(
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<=
name|max_labelno
condition|)
block|{
name|int
name|align
init|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|int
name|max_skip
init|=
name|LABEL_TO_MAX_SKIP
argument_list|(
name|insn
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|align
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|ASM_OUTPUT_MAX_SKIP_ALIGN
argument_list|(
name|file
argument_list|,
name|align
argument_list|,
name|max_skip
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGN_WITH_NOP
name|ASM_OUTPUT_ALIGN_WITH_NOP
argument_list|(
name|file
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
name|CC_STATUS_INIT
expr_stmt|;
comment|/* If this label is reached from only one place, set the condition 	 codes from the instruction just before the branch.  */
comment|/* Disabled because some insns set cc_status in the C output code 	 and NOTICE_UPDATE_CC alone can set incorrect status.  */
if|if
condition|(
literal|0
comment|/* optimize&& LABEL_NUSES (insn) == 1*/
condition|)
block|{
name|rtx
name|jump
init|=
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|barrier
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
comment|/* If the LABEL_REFS field of this label has been set to point 	     at a branch, the predecessor of the branch is a regular 	     insn, and that branch is the only way to reach this label, 	     set the condition codes based on the branch and its 	     predecessor.  */
if|if
condition|(
name|barrier
operator|&&
name|BARRIER_P
argument_list|(
name|barrier
argument_list|)
operator|&&
name|jump
operator|&&
name|JUMP_P
argument_list|(
name|jump
argument_list|)
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|jump
argument_list|)
operator|)
operator|&&
name|NONJUMP_INSN_P
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|label
call|)
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|JUMP_P
argument_list|(
name|next
argument_list|)
condition|)
block|{
name|rtx
name|nextbody
init|=
name|PATTERN
argument_list|(
name|next
argument_list|)
decl_stmt|;
comment|/* If this label is followed by a jump-table, 	     make sure we put the label in the read-only section.  Also 	     possibly write the label and jump table together.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_VEC
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|)
comment|/* In this case, the case vector is being moved by the 		 target, so don't output the label at all.  Leave that 		 to the back end macros.  */
else|#
directive|else
if|if
condition|(
operator|!
name|JUMP_TABLES_IN_TEXT_SECTION
condition|)
block|{
name|int
name|log_align
decl_stmt|;
name|switch_to_section
argument_list|(
name|targetm
operator|.
name|asm_out
operator|.
name|function_rodata_section
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDR_VEC_ALIGN
name|log_align
operator|=
name|ADDR_VEC_ALIGN
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
name|log_align
operator|=
name|exact_log2
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|log_align
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|LABEL_ALT_ENTRY_P
argument_list|(
name|insn
argument_list|)
condition|)
name|output_alternate_entry_point
argument_list|(
name|file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* Reset this early so it is correct for ASM statements.  */
name|current_insn_predicate
operator|=
name|NULL_RTX
expr_stmt|;
endif|#
directive|endif
comment|/* An INSN, JUMP_INSN or CALL_INSN. 	   First check for special kinds that recog doesn't recognize.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
comment|/* These are just declarations.  */
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
ifdef|#
directive|ifdef
name|HAVE_cc0
block|{
comment|/* If there is a REG_CC_SETTER note on this insn, it means that 	     the setting of the condition code was done in the delay slot 	     of the insn that branched here.  So recover the cc status 	     from the insn that set it.  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Detect insns that are really jump-tables 	   and output them as such.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_VEC
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|)
operator|)
name|int
name|vlen
decl_stmt|,
name|idx
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|JUMP_TABLES_IN_TEXT_SECTION
condition|)
name|switch_to_section
argument_list|(
name|targetm
operator|.
name|asm_out
operator|.
name|function_rodata_section
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_VEC
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC
name|ASM_OUTPUT_ADDR_VEC
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_DIFF_VEC
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
name|vlen
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_ELT
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_DIFF_ELT
name|ASM_OUTPUT_ADDR_DIFF_ELT
argument_list|(
name|file
argument_list|,
name|body
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_END
name|ASM_OUTPUT_CASE_END
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Output this line note if it is the first or the last line 	   note in a row.  */
if|if
condition|(
name|notice_source_line
argument_list|(
name|insn
argument_list|)
condition|)
block|{
call|(
modifier|*
name|debug_hooks
operator|->
name|source_line
call|)
argument_list|(
name|last_linenum
argument_list|,
name|last_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
condition|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
name|XSTR
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_ON
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Detect `asm' construct with operands.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|int
name|noperands
init|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|ops
init|=
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Get out the operand values.  */
name|string
operator|=
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|ops
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Inhibit dieing on what would otherwise be compiler bugs.  */
name|insn_noperands
operator|=
name|noperands
expr_stmt|;
name|this_is_asm_operands
operator|=
name|insn
expr_stmt|;
ifdef|#
directive|ifdef
name|FINAL_PRESCAN_INSN
name|FINAL_PRESCAN_INSN
argument_list|(
name|insn
argument_list|,
name|ops
argument_list|,
name|insn_noperands
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Output the insn using them.  */
if|if
condition|(
name|string
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_ON
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|string
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* A delayed-branch sequence */
name|int
name|i
decl_stmt|;
name|final_sequence
operator|=
name|body
expr_stmt|;
comment|/* Record the delay slots' frame information before the branch. 	       This is needed for delayed calls: see execute_cfa_program().  */
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|dwarf2out_frame_debug
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The first insn in this SEQUENCE might be a JUMP_INSN that will 	       force the restoration of a comparison that was previously 	       thought unnecessary.  If that happens, cancel this sequence 	       and cause that insn to be restored.  */
name|next
operator|=
name|final_scan_insn
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|final_sequence
operator|=
literal|0
expr_stmt|;
return|return
name|next
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We loop in case any instruction in a delay slot gets 		   split.  */
do|do
name|insn
operator|=
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|seen
argument_list|)
expr_stmt|;
do|while
condition|(
name|insn
operator|!=
name|next
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|DBR_OUTPUT_SEQEND
name|DBR_OUTPUT_SEQEND
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|final_sequence
operator|=
literal|0
expr_stmt|;
comment|/* If the insn requiring the delay slot was a CALL_INSN, the 	       insns in the delay slot are actually executed before the 	       called function.  Hence we don't preserve any CC-setting 	       actions in these insns and the CC must be marked as being 	       clobbered by the function.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
break|break;
block|}
comment|/* We have a real machine instruction as rtl.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Check for redundant test and compare instructions 	   (when the condition codes are already set up as desired). 	   This is done only when optimizing; if not optimizing, 	   it should be possible for the user to alter a variable 	   with the debugger in between statements 	   and the next statement should reexamine the variable 	   to compute the condition codes.  */
if|if
condition|(
name|optimize
condition|)
block|{
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
name|insn
operator|!=
name|last_ignored_compare
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|alter_subreg
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|alter_subreg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|alter_subreg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc_status
operator|.
name|value1
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
operator|||
operator|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't delete insn if it has an addressing side-effect.  */
if|if
condition|(
operator|!
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
comment|/* or if anything in it is volatile.  */
operator|&&
operator|!
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We don't really delete the insn; just ignore it.  */
name|last_ignored_compare
operator|=
name|insn
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this is a conditional branch, maybe modify it 	   if the cc's are in a nonstandard state 	   so that it accomplishes the same thing that it would 	   do straightforwardly if the cc's were set up normally.  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|COMPARISON_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
comment|/* This function may alter the contents of its argument 	       and clear some of the cc_status.flags bits. 	       It may also return 1 meaning condition now always true 	       or -1 meaning condition now always false 	       or 2 meaning condition nontrivial but altered.  */
name|int
name|result
init|=
name|alter_cond
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If condition now has fixed value, replace the IF_THEN_ELSE 	       with its then-operand or its else-operand.  */
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* The jump is now either unconditional or a no-op. 	       If it has become a no-op, don't try to output it. 	       (It would not be recognized.)  */
if|if
condition|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
comment|/* Replace (set (pc) (return)) with (return).  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|body
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* Rerecognize the instruction if it has changed.  */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make same adjustments to instructions that examine the 	   condition codes without jumping and instructions that 	   handle conditional moves (if this machine has either one).  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|set
operator|!=
literal|0
condition|)
block|{
name|rtx
name|cond_rtx
decl_stmt|,
name|then_rtx
decl_stmt|,
name|else_rtx
decl_stmt|;
if|if
condition|(
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|cond_rtx
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|then_rtx
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|else_rtx
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cond_rtx
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|then_rtx
operator|=
name|const_true_rtx
expr_stmt|;
name|else_rtx
operator|=
name|const0_rtx
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond_rtx
argument_list|)
condition|)
block|{
case|case
name|GTU
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GE
case|:
case|case
name|LEU
case|:
case|case
name|LE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|cond_rtx
argument_list|,
literal|0
argument_list|)
operator|!=
name|cc0_rtx
condition|)
break|break;
name|result
operator|=
name|alter_cond
argument_list|(
name|cond_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|then_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|else_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
literal|2
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_peephole
comment|/* Do machine-specific peephole optimizations if desired.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_peephole
operator|&&
operator|!
name|nopeepholes
condition|)
block|{
name|rtx
name|next
init|=
name|peephole
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* When peepholing, if there were notes within the peephole, 	       emit them before the peephole.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|next
operator|!=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|,
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|note
operator|!=
name|next
condition|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
control|)
name|final_scan_insn
argument_list|(
name|note
argument_list|,
name|file
argument_list|,
name|optimize
argument_list|,
name|nopeepholes
argument_list|,
name|seen
argument_list|)
expr_stmt|;
comment|/* Put the notes in the proper position for a later 		   rescan.  For example, the SH target can do this 		   when generating a far jump in a delayed branch 		   sequence.  */
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
comment|/* PEEPHOLE might have changed this.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Try to recognize the instruction. 	   If successful, verify that the operands satisfy the 	   constraints for the instruction.  Crash if they don't, 	   since `reload' should have changed them so that they do.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|cleanup_subreg_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Dump the insn in the assembly for debugging.  */
if|if
condition|(
name|flag_dump_rtl_in_asm
condition|)
block|{
name|print_rtx_head
operator|=
name|ASM_COMMENT_START
expr_stmt|;
name|print_rtl_single
argument_list|(
name|asm_out_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|print_rtx_head
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|constrain_operands_cached
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Some target machines need to prescan each insn before 	   it is output.  */
ifdef|#
directive|ifdef
name|FINAL_PRESCAN_INSN
name|FINAL_PRESCAN_INSN
argument_list|(
name|insn
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|,
name|recog_data
operator|.
name|n_operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|current_insn_predicate
operator|=
name|COND_EXEC_TEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
comment|/* Update `cc_status' for this instruction. 	   The instruction's output routine may change it further. 	   If the output routine for a jump insn needs to depend 	   on the cc status, it should look at cc_prev_status.  */
name|NOTICE_UPDATE_CC
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_output_insn
operator|=
name|debug_insn
operator|=
name|insn
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|insn
argument_list|,
name|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Find the proper template for this insn.  */
name|template
operator|=
name|get_insn_template
argument_list|(
name|insn_code_number
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the C code returns 0, it means that it is a jump insn 	   which follows a deleted test insn, and that test insn 	   needs to be reinserted.  */
if|if
condition|(
name|template
operator|==
literal|0
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
name|gcc_assert
argument_list|(
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|==
name|last_ignored_compare
argument_list|)
expr_stmt|;
comment|/* We have already processed the notes between the setter and 	       the user.  Make sure we don't process them again, this is 	       particularly important if one of the notes is a block 	       scope note or an EH note.  */
for|for
control|(
name|prev
operator|=
name|insn
init|;
name|prev
operator|!=
name|last_ignored_compare
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
block|{
if|if
condition|(
name|NOTE_P
argument_list|(
name|prev
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
comment|/* Use delete_note.  */
block|}
return|return
name|prev
return|;
block|}
comment|/* If the template is the string "#", it means that this insn must 	   be split.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|template
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|rtx
name|new
init|=
name|try_split
argument_list|(
name|body
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we didn't split the insn, go away.  */
if|if
condition|(
name|new
operator|==
name|insn
operator|&&
name|PATTERN
argument_list|(
name|new
argument_list|)
operator|==
name|body
condition|)
name|fatal_insn
argument_list|(
literal|"could not split insn"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
comment|/* This instruction should have been split in shorten_branches, 	       to ensure that we would have valid length info for the 	       splitees.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|new
return|;
block|}
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
comment|/* ??? This will put the directives in the wrong place if 	   get_insn_template outputs assembly directly.  However calling it 	   before get_insn_template breaks if the insns is split.  */
name|targetm
operator|.
name|asm_out
operator|.
name|unwind_emit
argument_list|(
name|asm_out_file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Output assembler code from the template.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_data
operator|.
name|operand
argument_list|)
expr_stmt|;
comment|/* If necessary, report the effect that the instruction has on 	   the unwind info.   We've already done this for delay slots 	   and call instructions.  */
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
if|if
condition|(
name|final_sequence
operator|==
literal|0
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
operator|&&
operator|!
name|ACCUMULATE_OUTGOING_ARGS
endif|#
directive|endif
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|insn
argument_list|,
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_output_insn
operator|=
name|debug_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return whether a source line note needs to be emitted before INSN.  */
end_comment

begin_function
specifier|static
name|bool
name|notice_source_line
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|insn_file
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|linenum
init|=
name|insn_line
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|filename
operator|&&
operator|(
name|force_source_line
operator|||
name|filename
operator|!=
name|last_filename
operator|||
name|last_linenum
operator|!=
name|linenum
operator|)
condition|)
block|{
name|force_source_line
operator|=
name|false
expr_stmt|;
name|last_filename
operator|=
name|filename
expr_stmt|;
name|last_linenum
operator|=
name|linenum
expr_stmt|;
name|high_block_linenum
operator|=
name|MAX
argument_list|(
name|last_linenum
argument_list|,
name|high_block_linenum
argument_list|)
expr_stmt|;
name|high_function_linenum
operator|=
name|MAX
argument_list|(
name|last_linenum
argument_list|,
name|high_function_linenum
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each operand in INSN, simplify (subreg (reg)) so that it refers    directly to the desired hard register.  */
end_comment

begin_function
name|void
name|cleanup_subreg_operands
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
comment|/* The following test cannot use recog_data.operand when testing 	 for a SUBREG: the underlying object might have been changed 	 already if we are inside a match_operator expression that 	 matches the else clause.  Instead we test the underlying 	 expression directly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MULT
operator|||
name|MEM_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|walk_alter_subreg
argument_list|(
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|MULT
operator|||
name|MEM_P
argument_list|(
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|)
condition|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|walk_alter_subreg
argument_list|(
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If X is a SUBREG, replace it with a REG or a MEM,    based on the thing it is a subreg of.  */
end_comment

begin_function
name|rtx
name|alter_subreg
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
name|rtx
name|y
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* simplify_subreg does not remove subreg from volatile references.      We are required to.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* For paradoxical subregs on big-endian machines, SUBREG_BYTE 	 contains 0 instead of the proper offset.  See simplify_subreg.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|difference
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|offset
operator|+=
operator|(
name|difference
operator|/
name|UNITS_PER_WORD
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|+=
name|difference
operator|%
name|UNITS_PER_WORD
expr_stmt|;
block|}
operator|*
name|xp
operator|=
name|adjust_address
argument_list|(
name|y
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|new
init|=
name|simplify_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
literal|0
condition|)
operator|*
name|xp
operator|=
name|new
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
comment|/* Simplify_subreg can't handle some REG cases, but we have to.  */
name|unsigned
name|int
name|regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
operator|*
name|xp
operator|=
name|gen_rtx_REG_offset
argument_list|(
name|y
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|regno
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|*
name|xp
return|;
block|}
end_function

begin_comment
comment|/* Do alter_subreg on all the SUBREGs contained in X.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_alter_subreg
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
case|case
name|AND
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
case|case
name|ZERO_EXTEND
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
return|return
name|alter_subreg
argument_list|(
name|xp
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
operator|*
name|xp
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Given BODY, the body of a jump instruction, alter the jump condition    as required by the bits that are set in cc_status.flags.    Not all of the bits there can be handled at this level in all cases.     The value is normally 0.    1 means that the condition has become always true.    -1 means that the condition has become always false.    2 means that COND has been altered.  */
end_comment

begin_function
specifier|static
name|int
name|alter_cond
parameter_list|(
name|rtx
name|cond
parameter_list|)
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_REVERSED
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_INVERTED
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_POSITIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_NEGATIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
operator|(
name|CC_Z_IN_NOT_N
operator||
name|CC_Z_IN_N
operator|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|NE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|GE
else|:
name|LT
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|LT
else|:
name|GE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_SIGNED
condition|)
comment|/* The flags are valid if signed condition operators are converted        to unsigned.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Report inconsistency between the assembler template and the operands.    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */
end_comment

begin_function
name|void
name|output_operand_lossage
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|fmt_string
decl_stmt|;
name|char
modifier|*
name|new_message
decl_stmt|;
specifier|const
name|char
modifier|*
name|pfx_str
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|pfx_str
operator|=
name|this_is_asm_operands
condition|?
name|_
argument_list|(
literal|"invalid 'asm': "
argument_list|)
else|:
literal|"output_operand: "
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|fmt_string
argument_list|,
literal|"%s%s"
argument_list|,
name|pfx_str
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|new_message
argument_list|,
name|fmt_string
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_asm_operands
condition|)
name|error_for_asm
argument_list|(
name|this_is_asm_operands
argument_list|,
literal|"%s"
argument_list|,
name|new_message
argument_list|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
literal|"%s"
argument_list|,
name|new_message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fmt_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_message
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output of assembler code from a template, and its subroutines.  */
end_comment

begin_comment
comment|/* Annotate the assembly with a comment describing the pattern and    alternative used.  */
end_comment

begin_function
specifier|static
name|void
name|output_asm_name
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug_insn
condition|)
block|{
name|int
name|num
init|=
name|INSN_CODE
argument_list|(
name|debug_insn
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %d\t%s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|INSN_UID
argument_list|(
name|debug_insn
argument_list|)
argument_list|,
name|insn_data
index|[
name|num
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_data
index|[
name|num
index|]
operator|.
name|n_alternatives
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"/%d"
argument_list|,
name|which_alternative
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t[length = %d]"
argument_list|,
name|get_attr_length
argument_list|(
name|debug_insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Clear this so only the first assembler insn 	 of any rtl insn will get the special comment for -dp.  */
name|debug_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If OP is a REG or MEM and we can find a MEM_EXPR corresponding to it    or its address, return that expr .  Set *PADDRESSP to 1 if the expr    corresponds to the address of the object and 0 if to the object.  */
end_comment

begin_function
specifier|static
name|tree
name|get_mem_expr_from_op
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
modifier|*
name|paddressp
parameter_list|)
block|{
name|tree
name|expr
decl_stmt|;
name|int
name|inner_addressp
decl_stmt|;
operator|*
name|paddressp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|REG_EXPR
argument_list|(
name|op
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_EXPR
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|MEM_EXPR
argument_list|(
name|op
argument_list|)
return|;
comment|/* Otherwise we have an address, so indicate it and look at the address.  */
operator|*
name|paddressp
operator|=
literal|1
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First check if we have a decl for the address, then look at the right side      if it is a PLUS.  Otherwise, strip off arithmetic and keep looking.      But don't allow the address to itself be indirect.  */
if|if
condition|(
operator|(
name|expr
operator|=
name|get_mem_expr_from_op
argument_list|(
name|op
argument_list|,
operator|&
name|inner_addressp
argument_list|)
operator|)
operator|&&
operator|!
name|inner_addressp
condition|)
return|return
name|expr
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|expr
operator|=
name|get_mem_expr_from_op
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|inner_addressp
argument_list|)
operator|)
condition|)
return|return
name|expr
return|;
while|while
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|RTX_UNARY
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|RTX_BIN_ARITH
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|get_mem_expr_from_op
argument_list|(
name|op
argument_list|,
operator|&
name|inner_addressp
argument_list|)
expr_stmt|;
return|return
name|inner_addressp
condition|?
literal|0
else|:
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Output operand names for assembler instructions.  OPERANDS is the    operand vector, OPORDER is the order to write the operands, and NOPS    is the number of operands to write.  */
end_comment

begin_function
specifier|static
name|void
name|output_asm_operand_names
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
modifier|*
name|oporder
parameter_list|,
name|int
name|nops
parameter_list|)
block|{
name|int
name|wrote
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|int
name|addressp
decl_stmt|;
name|rtx
name|op
init|=
name|operands
index|[
name|oporder
index|[
name|i
index|]
index|]
decl_stmt|;
name|tree
name|expr
init|=
name|get_mem_expr_from_op
argument_list|(
name|op
argument_list|,
operator|&
name|addressp
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%c%s"
argument_list|,
name|wrote
condition|?
literal|','
else|:
literal|'\t'
argument_list|,
name|wrote
condition|?
literal|""
else|:
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|wrote
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s"
argument_list|,
name|addressp
condition|?
literal|"*"
else|:
literal|""
argument_list|)
expr_stmt|;
name|print_mem_expr
argument_list|(
name|asm_out_file
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|wrote
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
operator|&&
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|op
argument_list|)
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" tmp%i"
argument_list|,
name|ORIGINAL_REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output text from TEMPLATE to the assembler output file,    obeying %-directions to substitute operands taken from    the vector OPERANDS.     %N (for N a digit) means print operand N in usual manner.    %lN means require operand N to be a CODE_LABEL or LABEL_REF       and print the label name with no punctuation.    %cN means require operand N to be a constant       and print the constant expression with no punctuation.    %aN means expect operand N to be a memory address       (not a memory reference!) and print a reference       to that address.    %nN means expect operand N to be a constant       and print a constant expression for minus the value       of the operand, with no other punctuation.  */
end_comment

begin_function
name|void
name|output_asm_insn
parameter_list|(
specifier|const
name|char
modifier|*
name|template
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
name|int
name|dialect
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|oporder
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|opoutput
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|ops
init|=
literal|0
decl_stmt|;
comment|/* An insn may return a null string template      in a case where no assembler code is needed.  */
if|if
condition|(
operator|*
name|template
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
name|opoutput
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|opoutput
argument_list|)
expr_stmt|;
name|p
operator|=
name|template
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|flag_verbose_asm
condition|)
name|output_asm_operand_names
argument_list|(
name|operands
argument_list|,
name|oporder
argument_list|,
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_print_asm_name
condition|)
name|output_asm_name
argument_list|()
expr_stmt|;
name|ops
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|opoutput
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|opoutput
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|'\t'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
case|case
literal|'{'
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dialect
condition|)
name|output_operand_lossage
argument_list|(
literal|"nested assembly dialect alternatives"
argument_list|)
expr_stmt|;
else|else
name|dialect
operator|=
literal|1
expr_stmt|;
comment|/* If we want the first dialect, do nothing.  Otherwise, skip 	     DIALECT_NUMBER of strings ending with '|'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dialect_number
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'}'
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'|'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|output_operand_lossage
argument_list|(
literal|"unterminated assembly dialect alternative"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|dialect
condition|)
block|{
comment|/* Skip to close brace.  */
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"unterminated assembly dialect alternative"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
do|;
name|dialect
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
operator|!
name|dialect
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dialect
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'%'
case|:
comment|/* %% outputs a single %.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* %= outputs a number which is unique to each insn in the entire 	   compilation.  This is useful for making local labels that are 	   referred to more than once in a given insn.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%d"
argument_list|,
name|insn_counter
argument_list|)
expr_stmt|;
block|}
comment|/* % followed by a letter and some digits 	   outputs an operand in a special way depending on the letter. 	   Letters `acln' are implemented directly. 	   Other letters are passed to `output_operand' so that 	   the PRINT_OPERAND macro can define them.  */
elseif|else
if|if
condition|(
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|int
name|letter
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|unsigned
name|long
name|opnum
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|opnum
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|endptr
operator|==
name|p
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number missing "
literal|"after %%-letter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_is_asm_operands
operator|&&
name|opnum
operator|>=
name|insn_noperands
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'l'
condition|)
name|output_asm_label
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'a'
condition|)
name|output_address
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|)
condition|)
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|opnum
index|]
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|opnum
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|,
name|letter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opoutput
index|[
name|opnum
index|]
condition|)
name|oporder
index|[
name|ops
operator|++
index|]
operator|=
name|opnum
expr_stmt|;
name|opoutput
index|[
name|opnum
index|]
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|endptr
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
comment|/* % followed by a digit outputs an operand the default way.  */
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|opnum
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|opnum
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_asm_operands
operator|&&
name|opnum
operator|>=
name|insn_noperands
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|opnum
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opoutput
index|[
name|opnum
index|]
condition|)
name|oporder
index|[
name|ops
operator|++
index|]
operator|=
name|opnum
expr_stmt|;
name|opoutput
index|[
name|opnum
index|]
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|endptr
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
block|}
comment|/* % followed by punctuation: output something for that 	   punctuation character alone, with no operand. 	   The PRINT_OPERAND macro decides what is actually done.  */
ifdef|#
directive|ifdef
name|PRINT_OPERAND_PUNCT_VALID_P
elseif|else
if|if
condition|(
name|PRINT_OPERAND_PUNCT_VALID_P
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|output_operand
argument_list|(
name|NULL_RTX
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%-code"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the variable names for operands, if we know them.  */
if|if
condition|(
name|flag_verbose_asm
condition|)
name|output_asm_operand_names
argument_list|(
name|operands
argument_list|,
name|oporder
argument_list|,
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_print_asm_name
condition|)
name|output_asm_name
argument_list|()
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */
end_comment

begin_function
name|void
name|output_asm_label
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|NOTE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"'%%l' operand isn't a label"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print operand X using machine-dependent assembler syntax.    The macro PRINT_OPERAND is defined just to control this function.    CODE is a non-digit that preceded the operand-number in the % spec,    such as 'z' if the spec was `%z3'.  CODE is 0 if there was no char    between the % and the digits.    When CODE is a non-letter, X is 0.     The meanings of the letters are machine-dependent and controlled    by PRINT_OPERAND.  */
end_comment

begin_function
specifier|static
name|void
name|output_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|alter_subreg
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
comment|/* X must not be a pseudo reg.  */
name|gcc_assert
argument_list|(
operator|!
name|x
operator|||
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a memory reference operand for address X    using machine-dependent assembler syntax.    The macro PRINT_OPERAND_ADDRESS exists just to control this function.  */
end_comment

begin_function
name|void
name|output_address
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|walk_alter_subreg
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|PRINT_OPERAND_ADDRESS
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.    Addition and subtraction are the only arithmetic    that may appear in these expressions.  */
end_comment

begin_function
name|void
name|output_addr_const
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|restart
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
condition|)
name|mark_decl_referenced
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SYMBOL_REF
name|ASM_OUTPUT_SYMBOL_REF
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LABEL_REF
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_LABEL_REF
name|ASM_OUTPUT_LABEL_REF
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is one word and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear last (eg masm).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* Avoid outputting things like x-x or x+5-x, 	 since some assemblers can't handle that.  */
name|x
operator|=
name|simplify_subtraction
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
goto|goto
name|restart
goto|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs
argument_list|(
name|targetm
operator|.
name|asm_out
operator|.
name|open_paren
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|targetm
operator|.
name|asm_out
operator|.
name|close_paren
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|SUBREG
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|OUTPUT_ADDR_CONST_EXTRA
name|OUTPUT_ADDR_CONST_EXTRA
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|fail
argument_list|)
expr_stmt|;
break|break;
name|fail
label|:
endif|#
directive|endif
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A poor man's fprintf, with the added features of %I, %R, %L, and %U.    %R prints the value of REGISTER_PREFIX.    %L prints the value of LOCAL_LABEL_PREFIX.    %U prints the value of USER_LABEL_PREFIX.    %I prints the value of IMMEDIATE_PREFIX.    %O runs ASM_OUTPUT_OPCODE to transform what follows in the string.    Also supported are %d, %i, %u, %x, %X, %o, %c, %s and %%.     We handle alternate assembler dialects here, just like output_asm_insn.  */
end_comment

begin_function
name|void
name|asm_fprintf
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
name|c
decl_stmt|;
name|va_list
name|argptr
decl_stmt|;
name|va_start
argument_list|(
name|argptr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
case|case
literal|'{'
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* If we want the first dialect, do nothing.  Otherwise, skip 	     DIALECT_NUMBER of strings ending with '|'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dialect_number
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'|'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* Skip to close brace.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
break|break;
case|case
literal|'}'
case|:
break|break;
endif|#
directive|endif
case|case
literal|'%'
case|:
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|strchr
argument_list|(
literal|"-+ #0"
argument_list|,
name|c
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'o'
case|:
case|case
literal|'c'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* This is a prefix to the 'd', 'i', 'u', 'x', 'X', and 	       'o' cases, but we do not check for those cases.  It 	       means that the value is a HOST_WIDE_INT, which may be 	       either `long' or `long long'.  */
name|memcpy
argument_list|(
name|q
argument_list|,
name|HOST_WIDE_INT_PRINT
argument_list|,
name|strlen
argument_list|(
name|HOST_WIDE_INT_PRINT
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|+=
name|strlen
argument_list|(
name|HOST_WIDE_INT_PRINT
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LONG_LONG
if|if
condition|(
operator|*
name|p
operator|==
literal|'l'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
argument|argptr
argument_list|,
argument|long long
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'R'
case|:
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'I'
case|:
ifdef|#
directive|ifdef
name|IMMEDIATE_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|IMMEDIATE_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'L'
case|:
ifdef|#
directive|ifdef
name|LOCAL_LABEL_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|LOCAL_LABEL_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'U'
case|:
name|fputs
argument_list|(
name|user_label_prefix
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ASM_FPRINTF_EXTENSIONS
comment|/* Uppercase letters are reserved for general use by asm_fprintf 	       and so are not available to target specific code.  In order to 	       prevent the ASM_FPRINTF_EXTENSIONS macro from using them then, 	       they are defined here.  As they get turned into real extensions 	       to asm_fprintf they should be removed from this list.  */
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
break|break;
name|ASM_FPRINTF_EXTENSIONS
argument_list|(
argument|file
argument_list|,
argument|argptr
argument_list|,
argument|p
argument_list|)
endif|#
directive|endif
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split up a CONST_DOUBLE or integer constant rtx    into two rtx's for single words,    storing in *FIRST the word that comes first in memory in the target    and in *SECOND the other.  */
end_comment

begin_function
name|void
name|split_double
parameter_list|(
name|rtx
name|value
parameter_list|,
name|rtx
modifier|*
name|first
parameter_list|,
name|rtx
modifier|*
name|second
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
operator|(
literal|2
operator|*
name|BITS_PER_WORD
operator|)
condition|)
block|{
comment|/* In this case the CONST_INT holds both target words. 	     Extract the bits from it into two word-sized pieces. 	     Sign extend each half to HOST_WIDE_INT.  */
name|unsigned
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|,
name|sign_bit
decl_stmt|,
name|sign_extend
decl_stmt|;
comment|/* Set sign_bit to the most significant bit of a word.  */
name|sign_bit
operator|=
literal|1
expr_stmt|;
name|sign_bit
operator|<<=
name|BITS_PER_WORD
operator|-
literal|1
expr_stmt|;
comment|/* Set mask so that all bits of the word are set.  We could 	     have used 1<< BITS_PER_WORD instead of basing the 	     calculation on sign_bit.  However, on machines where 	     HOST_BITS_PER_WIDE_INT == BITS_PER_WORD, it could cause a 	     compiler warning, even though the code would never be 	     executed.  */
name|mask
operator|=
name|sign_bit
operator|<<
literal|1
expr_stmt|;
name|mask
operator|--
expr_stmt|;
comment|/* Set sign_extend as any remaining bits.  */
name|sign_extend
operator|=
operator|~
name|mask
expr_stmt|;
comment|/* Pick the lower word and sign-extend it.  */
name|low
operator|=
name|INTVAL
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|low
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|low
operator|&
name|sign_bit
condition|)
name|low
operator||=
name|sign_extend
expr_stmt|;
comment|/* Pick the higher word, shifted to the least significant 	     bits, and sign-extend it.  */
name|high
operator|=
name|INTVAL
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|high
operator|>>=
name|BITS_PER_WORD
operator|-
literal|1
expr_stmt|;
name|high
operator|>>=
literal|1
expr_stmt|;
name|high
operator|&=
name|mask
expr_stmt|;
if|if
condition|(
name|high
operator|&
name|sign_bit
condition|)
name|high
operator||=
name|sign_extend
expr_stmt|;
comment|/* Store the words in the target machine order.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|high
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|low
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|high
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The rule for using CONST_INT for a wider mode 	     is that we regard the value as signed. 	     So sign-extend it.  */
name|rtx
name|high
init|=
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|high
expr_stmt|;
operator|*
name|second
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|value
expr_stmt|;
operator|*
name|second
operator|=
name|high
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|second
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|value
expr_stmt|;
operator|*
name|second
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
comment|/* This is the old way we did CONST_DOUBLE integers.  */
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
comment|/* In an integer, the words are defined as most and least significant. 	 So order them by the target's convention.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Note, this converts the REAL_VALUE_TYPE to the target's 	 format, splits up the floating point double and outputs 	 exactly 32 bits of it into each of l[0] and l[1] -- 	 not necessarily BITS_PER_WORD bits.  */
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* If 32 bits is an entire word for the target, but not for the host, 	 then sign-extend on the host so that the number will look the same 	 way on the host that it would on the target.  See for instance 	 simplify_unary_operation.  The #if is needed to avoid compiler 	 warnings.  */
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>
literal|32
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_LONG
operator|&&
name|BITS_PER_WORD
operator|==
literal|32
condition|)
block|{
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|&
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
name|l
index|[
literal|0
index|]
operator||=
operator|(
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|l
index|[
literal|1
index|]
operator|&
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
name|l
index|[
literal|1
index|]
operator||=
operator|(
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if this function has no function calls.  */
end_comment

begin_function
name|int
name|leaf_function_p
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
if|if
condition|(
name|current_function_profile
operator|||
name|profile_arc_flag
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|CALL_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|link
operator|=
name|current_function_epilogue_delay_list
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|CALL_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if branch is a forward branch.    Uses insn_shuid array, so it works only in the final pass.  May be used by    output templates to customary add branch prediction hints.  */
end_comment

begin_function
name|int
name|final_forward_branch_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|insn_id
decl_stmt|,
name|label_id
decl_stmt|;
name|gcc_assert
argument_list|(
name|uid_shuid
argument_list|)
expr_stmt|;
name|insn_id
operator|=
name|INSN_SHUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|label_id
operator|=
name|INSN_SHUID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We've hit some insns that does not have id information available.  */
name|gcc_assert
argument_list|(
name|insn_id
operator|&&
name|label_id
argument_list|)
expr_stmt|;
return|return
name|insn_id
operator|<
name|label_id
return|;
block|}
end_function

begin_comment
comment|/* On some machines, a function with no call insns    can run faster if it doesn't create its own register window.    When output, the leaf function should use only the "output"    registers.  Ordinarily, the function would be compiled to use    the "input" registers to find its arguments; it is a candidate    for leaf treatment if it uses only the "input" registers.    Leaf function treatment means renumbering so the function    uses the "output" registers instead.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_comment
comment|/* Return 1 if this function uses only the registers that can be    safely renumbered.  */
end_comment

begin_function
name|int
name|only_leaf_regs_used
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|permitted_reg_in_leaf_functions
init|=
name|LEAF_REGISTERS
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|permitted_reg_in_leaf_functions
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_function_uses_pic_offset_table
operator|&&
name|pic_offset_table_rtx
operator|!=
literal|0
operator|&&
name|REG_P
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|&&
operator|!
name|permitted_reg_in_leaf_functions
index|[
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Scan all instructions and renumber all registers into those    available in leaf functions.  */
end_comment

begin_function
specifier|static
name|void
name|leaf_renumber_regs
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Renumber only the actual patterns.      The reg-notes can contain frame pointer refs,      and renumbering them could crash, and should not be needed.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan IN_RTX and its subexpressions, and renumber all regs into those    available in leaf functions.  */
end_comment

begin_function
name|void
name|leaf_renumber_regs_insn
parameter_list|(
name|rtx
name|in_rtx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|in_rtx
operator|==
literal|0
condition|)
return|return;
comment|/* Renumber all input-registers into output-registers.      renumbered_regs would be 1 for an output-register;      they  */
if|if
condition|(
name|REG_P
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
name|int
name|newreg
decl_stmt|;
comment|/* Don't renumber the same reg twice.  */
if|if
condition|(
name|in_rtx
operator|->
name|used
condition|)
return|return;
name|newreg
operator|=
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
expr_stmt|;
comment|/* Don't try to renumber pseudo regs.  It is possible for a pseudo reg 	 to reach here as part of a REG_NOTE.  */
if|if
condition|(
name|newreg
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|in_rtx
operator|->
name|used
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|newreg
operator|=
name|LEAF_REG_REMAP
argument_list|(
name|newreg
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|newreg
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|regs_ever_live
index|[
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|regs_ever_live
index|[
name|newreg
index|]
operator|=
literal|1
expr_stmt|;
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
operator|=
name|newreg
expr_stmt|;
name|in_rtx
operator|->
name|used
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|in_rtx
argument_list|)
condition|)
block|{
comment|/* Inside a SEQUENCE, we find insns. 	 Renumber just the patterns of these insns, 	 just as we do for the top-level insns.  */
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|leaf_renumber_regs_insn
argument_list|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|NULL
operator|!=
name|XVEC
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|leaf_renumber_regs_insn
argument_list|(
name|XVECEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
case|case
literal|'0'
case|:
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'n'
case|:
case|case
literal|'u'
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When -gused is used, emit debug info for only used symbols. But in    addition to the standard intercepted debug_hooks there are some direct    calls into this file, i.e., dbxout_symbol, dbxout_parms, and dbxout_reg_params.    Those routines may also be called from a higher level intercepted routine. So    to prevent recording data for an inner call to one of these for an intercept,    we maintain an intercept nesting counter (debug_nesting). We only save the    intercepted arguments if the nesting is 1.  */
end_comment

begin_decl_stmt
name|int
name|debug_nesting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|symbol_queue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|symbol_queue_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbol_queue_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate the symbols for any queued up type symbols we encountered    while generating the type info for some originally used symbol.    This might generate additional entries in the queue.  Only when    the nesting depth goes to 0 is this routine called.  */
end_comment

begin_function
name|void
name|debug_flush_symbol_queue
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Make sure that additionally queued items are not flushed      prematurely.  */
operator|++
name|debug_nesting
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symbol_queue_index
condition|;
operator|++
name|i
control|)
block|{
comment|/* If we pushed queued symbols then such symbols must be          output no matter what anyone else says.  Specifically,          we need to make sure dbxout_symbol() thinks the symbol was          used and also we need to override TYPE_DECL_SUPPRESS_DEBUG          which may be set for outside reasons.  */
name|int
name|saved_tree_used
init|=
name|TREE_USED
argument_list|(
name|symbol_queue
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|int
name|saved_suppress_debug
init|=
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|symbol_queue
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|TREE_USED
argument_list|(
name|symbol_queue
index|[
name|i
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|symbol_queue
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
name|dbxout_symbol
argument_list|(
name|symbol_queue
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_USED
argument_list|(
name|symbol_queue
index|[
name|i
index|]
argument_list|)
operator|=
name|saved_tree_used
expr_stmt|;
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|symbol_queue
index|[
name|i
index|]
argument_list|)
operator|=
name|saved_suppress_debug
expr_stmt|;
block|}
name|symbol_queue_index
operator|=
literal|0
expr_stmt|;
operator|--
name|debug_nesting
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Queue a type symbol needed as part of the definition of a decl    symbol.  These symbols are generated when debug_flush_symbol_queue()    is called.  */
end_comment

begin_function
name|void
name|debug_queue_symbol
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|symbol_queue_index
operator|>=
name|symbol_queue_size
condition|)
block|{
name|symbol_queue_size
operator|+=
literal|10
expr_stmt|;
name|symbol_queue
operator|=
name|xrealloc
argument_list|(
name|symbol_queue
argument_list|,
name|symbol_queue_size
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|symbol_queue
index|[
name|symbol_queue_index
operator|++
index|]
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free symbol queue.  */
end_comment

begin_function
name|void
name|debug_free_queue
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|symbol_queue
condition|)
block|{
name|free
argument_list|(
name|symbol_queue
argument_list|)
expr_stmt|;
name|symbol_queue
operator|=
name|NULL
expr_stmt|;
name|symbol_queue_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turn the RTL into assembly.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_final
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnname
decl_stmt|;
comment|/* Get the function's name, as described by its RTL.  This may be      different from the DECL_NAME name used in the source file.  */
name|x
operator|=
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|MEM_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_start_function
argument_list|(
name|current_function_decl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|asm_out_file
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
comment|/* ??? The IA-64 ".handlerdata" directive must be issued before      the ".endp" directive that closes the procedure descriptor.  */
name|output_function_exception_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|assemble_end_function
argument_list|(
name|current_function_decl
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TARGET_UNWIND_INFO
comment|/* Otherwise, it feels unclean to switch sections in the middle.  */
name|output_function_exception_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|user_defined_section_attribute
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|quiet_flag
condition|)
name|fflush
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Release all memory allocated by flow.  */
name|free_basic_block_vars
argument_list|()
expr_stmt|;
comment|/* Write DBX symbols if requested.  */
comment|/* Note that for those inline functions where we don't initially      know for certain that we will be generating an out-of-line copy,      the first invocation of this routine (rest_of_compilation) will      skip over this code by doing a `goto exit_rest_of_compilation;'.      Later on, wrapup_global_declarations will (indirectly) call      rest_of_compilation again for those inline functions that need      to have out-of-line copies generated.  During that call, we      *will* be routed past here.  */
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
call|(
modifier|*
name|debug_hooks
operator|->
name|function_decl
call|)
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_final
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rest_of_handle_final
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_FINAL
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_ggc_collect
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_handle_shorten_branches
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Shorten branches.  */
name|shorten_branches
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_shorten_branches
init|=
block|{
literal|"shorten"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rest_of_handle_shorten_branches
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_FINAL
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|rest_of_clean_state
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
comment|/* It is very important to decompose the RTL instruction chain here:      debug information keeps pointing into CODE_LABEL insns inside the function      body.  If these remain pointing to the other insns, we end up preserving      whole RTL chain and attached detailed debug info in memory.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* In case the function was not output,      don't leave any temporary anonymous types      queued up for sdb output.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_types
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|epilogue_completed
operator|=
literal|0
expr_stmt|;
name|flow2_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
name|regstack_completed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Clear out the insn_length contents now that they are no      longer valid.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
comment|/* Show no temporary slots allocated.  */
name|init_temp_slots
argument_list|()
expr_stmt|;
name|free_basic_block_vars
argument_list|()
expr_stmt|;
name|free_bb_for_insn
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|int
name|pref
init|=
name|cfun
operator|->
name|preferred_stack_boundary
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|stack_alignment_needed
operator|>
name|cfun
operator|->
name|preferred_stack_boundary
condition|)
name|pref
operator|=
name|cfun
operator|->
name|stack_alignment_needed
expr_stmt|;
name|cgraph_rtl_info
argument_list|(
name|current_function_decl
argument_list|)
operator|->
name|preferred_incoming_stack_boundary
operator|=
name|pref
expr_stmt|;
block|}
comment|/* Make sure volatile mem refs aren't considered valid operands for      arithmetic insns.  We must call this here if this is a nested inline      function, since the above code leaves us in the init_recog state,      and the function context push/pop code does not save/restore volatile_ok.       ??? Maybe it isn't necessary for expand_start_function to call this      anymore if we do it here?  */
name|init_recog_no_volatile
argument_list|()
expr_stmt|;
comment|/* We're done with this function.  Free up memory if we can.  */
name|free_after_parsing
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|free_after_compilation
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_clean_state
init|=
block|{
name|NULL
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rest_of_clean_state
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_FINAL
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
name|PROP_rtl
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

