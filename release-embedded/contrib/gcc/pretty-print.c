begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Various declarations for language-independent pretty-print subroutines.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@integrable-solutions.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_undef
undef|#
directive|undef
name|FLOAT
end_undef

begin_comment
comment|/* This is for hpux. They should change hpux.  */
end_comment

begin_undef
undef|#
directive|undef
name|FFS
end_undef

begin_comment
comment|/* Some systems define this in param.h.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"pretty-print.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* A pointer to the formatted diagnostic message.  */
end_comment

begin_define
define|#
directive|define
name|pp_formatted_text_data
parameter_list|(
name|PP
parameter_list|)
define|\
value|((const char *) obstack_base (pp_base (PP)->buffer->obstack))
end_define

begin_comment
comment|/* Format an integer given by va_arg (ARG, type-specifier T) where    type-specifier is a precision modifier as indicated by PREC.  F is    a string used to construct the appropriate format-specifier.  */
end_comment

begin_define
define|#
directive|define
name|pp_integer_with_precision
parameter_list|(
name|PP
parameter_list|,
name|ARG
parameter_list|,
name|PREC
parameter_list|,
name|T
parameter_list|,
name|F
parameter_list|)
define|\
value|do                                                         \     switch (PREC)                                            \       {                                                      \       case 0:                                                \         pp_scalar (PP, "%" F, va_arg (ARG, T));              \         break;                                               \                                                              \       case 1:                                                \         pp_scalar (PP, "%l" F, va_arg (ARG, long T));        \         break;                                               \                                                              \       case 2:                                                \         pp_scalar (PP, "%ll" F, va_arg (ARG, long long T));  \         break;                                               \                                                              \       default:                                               \         break;                                               \       }                                                      \   while (0)
end_define

begin_comment
comment|/* Subroutine of pp_set_maximum_length.  Set up PRETTY-PRINTER's    internal maximum characters per line.  */
end_comment

begin_function
specifier|static
name|void
name|pp_set_real_maximum_length
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
comment|/* If we're told not to wrap lines then do the obvious thing.  In case      we'll emit prefix only once per message, it is appropriate      not to increase unnecessarily the line-length cut-off.  */
if|if
condition|(
operator|!
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
operator|||
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
operator|||
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
operator|==
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
condition|)
name|pp
operator|->
name|maximum_length
operator|=
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|prefix_length
init|=
name|pp
operator|->
name|prefix
condition|?
name|strlen
argument_list|(
name|pp
operator|->
name|prefix
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* If the prefix is ridiculously too long, output at least          32 characters.  */
if|if
condition|(
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|-
name|prefix_length
operator|<
literal|32
condition|)
name|pp
operator|->
name|maximum_length
operator|=
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|+
literal|32
expr_stmt|;
else|else
name|pp
operator|->
name|maximum_length
operator|=
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear PRETTY-PRINTER's output state.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_clear_state
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp
operator|->
name|emitted_prefix
operator|=
name|false
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the formatted text of PRETTY-PRINTER onto the attached stream.  */
end_comment

begin_function
name|void
name|pp_write_text_to_stream
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
init|=
name|pp_formatted_text
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|text
argument_list|,
name|pp
operator|->
name|buffer
operator|->
name|stream
argument_list|)
expr_stmt|;
name|pp_clear_output_area
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrap a text delimited by START and END into PRETTY-PRINTER.  */
end_comment

begin_function
specifier|static
name|void
name|pp_wrap_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|bool
name|wrapping_line
init|=
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
decl_stmt|;
while|while
condition|(
name|start
operator|!=
name|end
condition|)
block|{
comment|/* Dump anything bordered by whitespaces.  */
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
operator|!
name|ISBLANK
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|wrapping_line
operator|&&
name|p
operator|-
name|start
operator|>=
name|pp_remaining_character_count_for_line
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_append_text
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|start
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
name|ISBLANK
argument_list|(
operator|*
name|start
argument_list|)
condition|)
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|'\n'
condition|)
block|{
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|++
name|start
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Same as pp_wrap_text but wrap text only when in line-wrapping mode.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_maybe_wrap_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_wrap_text
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|else
name|pp_append_text
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append to the output area of PRETTY-PRINTER a string specified by its    STARTing character and LENGTH.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pp_append_r
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|obstack_grow
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert enough spaces into the output area of PRETTY-PRINTER to bring    the column position to the current indentation level, assuming that a    newline has just been written to the buffer.  */
end_comment

begin_function
name|void
name|pp_base_indent
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|n
init|=
name|pp_indentation
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following format specifiers are recognized as being client independent:    %d, %i: (signed) integer in base ten.    %u: unsigned integer in base ten.    %o: unsigned integer in base eight.    %x: unsigned integer in base sixteen.    %ld, %li, %lo, %lu, %lx: long versions of the above.    %lld, %lli, %llo, %llu, %llx: long long versions.    %wd, %wi, %wo, %wu, %wx: HOST_WIDE_INT versions.    %c: character.    %s: string.    %p: pointer.    %m: strerror(text->err_no) - does not consume a value from args_ptr.    %%: '%'.    %<: opening quote.    %>: closing quote.    %': apostrophe (should only be used in untranslated messages;        translations should use appropriate punctuation directly).    %.*s: a substring the length of which is specified by an argument 	 integer.    %Ns: likewise, but length specified as constant in the format string.    %H: location_t.    %J: a decl tree, from which DECL_SOURCE_LOCATION will be recorded.    Flag 'q': quote formatted text (must come immediately after '%').     Arguments can be used sequentially, or through %N$ resp. *N$    notation Nth argument after the format string.  If %N$ / *N$    notation is used, it must be used for all arguments, except %m, %%,    %<, %> and %', which may not have a number, as they do not consume    an argument.  When %M$.*N$s is used, M must be N + 1.  (This may    also be written %M$.*s, provided N is not otherwise used.)  The    format string must have conversion specifiers with argument numbers    1 up to highest argument; each argument may only be used once.    A format string can have at most 30 arguments.  */
end_comment

begin_comment
comment|/* Formatting phases 1 and 2: render TEXT->format_spec plus    TEXT->args_ptr into a series of chunks in PP->buffer->args[].    Phase 3 is in pp_base_format_text.  */
end_comment

begin_function
name|void
name|pp_base_format
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|)
block|{
name|output_buffer
modifier|*
name|buffer
init|=
name|pp
operator|->
name|buffer
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|struct
name|chunk_info
modifier|*
name|new_chunk_array
decl_stmt|;
name|unsigned
name|int
name|curarg
init|=
literal|0
decl_stmt|,
name|chunk
init|=
literal|0
decl_stmt|,
name|argno
decl_stmt|;
name|pp_wrapping_mode_t
name|old_wrapping_mode
decl_stmt|;
name|bool
name|any_unnumbered
init|=
name|false
decl_stmt|,
name|any_numbered
init|=
name|false
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|formatters
index|[
name|PP_NL_ARGMAX
index|]
decl_stmt|;
comment|/* Allocate a new chunk structure.  */
name|new_chunk_array
operator|=
name|XOBNEW
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
expr|struct
name|chunk_info
argument_list|)
expr_stmt|;
name|new_chunk_array
operator|->
name|prev
operator|=
name|buffer
operator|->
name|cur_chunk_array
expr_stmt|;
name|buffer
operator|->
name|cur_chunk_array
operator|=
name|new_chunk_array
expr_stmt|;
name|args
operator|=
name|new_chunk_array
operator|->
name|args
expr_stmt|;
comment|/* Formatting phase 1: split up TEXT->format_spec into chunks in      PP->buffer->args[].  Even-numbered chunks are to be output      verbatim, odd-numbered chunks are format specifiers.      %m, %%, %<, %>, and %' are replaced with the appropriate text at      this point.  */
name|memset
argument_list|(
name|formatters
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|formatters
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|text
operator|->
name|format_spec
init|;
operator|*
name|p
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'%'
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'\0'
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
literal|'%'
case|:
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
name|obstack_grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
name|open_quote
argument_list|,
name|strlen
argument_list|(
name|open_quote
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
case|case
literal|'\''
case|:
name|obstack_grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
name|close_quote
argument_list|,
name|strlen
argument_list|(
name|close_quote
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'m'
case|:
block|{
specifier|const
name|char
modifier|*
name|errstr
init|=
name|xstrerror
argument_list|(
name|text
operator|->
name|err_no
argument_list|)
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
name|errstr
argument_list|,
name|strlen
argument_list|(
name|errstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
continue|continue;
default|default:
comment|/* Handled in phase 2.  Terminate the plain chunk here.  */
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|chunk
operator|<
name|PP_NL_ARGMAX
operator|*
literal|2
argument_list|)
expr_stmt|;
name|args
index|[
name|chunk
operator|++
index|]
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|argno
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|end
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|p
operator|==
literal|'$'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|any_numbered
operator|=
name|true
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|any_unnumbered
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argno
operator|=
name|curarg
operator|++
expr_stmt|;
name|any_unnumbered
operator|=
name|true
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|any_numbered
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|argno
operator|<
name|PP_NL_ARGMAX
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|formatters
index|[
name|argno
index|]
argument_list|)
expr_stmt|;
name|formatters
index|[
name|argno
index|]
operator|=
operator|&
name|args
index|[
name|chunk
index|]
expr_stmt|;
do|do
block|{
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|strchr
argument_list|(
literal|"qwl+#"
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
do|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* We handle '%.Ns' and '%.*s' or '%M$.*N$s' 	     (where M == N + 1).  */
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
do|do
block|{
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
do|;
name|gcc_assert
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'s'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|*
name|p
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|int
name|argno2
init|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
operator|-
literal|1
decl_stmt|;
name|p
operator|=
name|end
expr_stmt|;
name|gcc_assert
argument_list|(
name|argno2
operator|==
name|argno
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|any_unnumbered
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|p
operator|==
literal|'$'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|formatters
index|[
name|argno2
index|]
operator|=
name|formatters
index|[
name|argno
index|]
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|!
name|any_numbered
argument_list|)
expr_stmt|;
name|formatters
index|[
name|argno
operator|+
literal|1
index|]
operator|=
name|formatters
index|[
name|argno
index|]
expr_stmt|;
name|curarg
operator|++
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|*
name|p
operator|==
literal|'s'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|chunk
operator|<
name|PP_NL_ARGMAX
operator|*
literal|2
argument_list|)
expr_stmt|;
name|args
index|[
name|chunk
operator|++
index|]
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|chunk
operator|<
name|PP_NL_ARGMAX
operator|*
literal|2
argument_list|)
expr_stmt|;
name|args
index|[
name|chunk
operator|++
index|]
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|args
index|[
name|chunk
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set output to the argument obstack, and switch line-wrapping and      prefixing off.  */
name|buffer
operator|->
name|obstack
operator|=
operator|&
name|buffer
operator|->
name|chunk_obstack
expr_stmt|;
name|old_wrapping_mode
operator|=
name|pp_set_verbatim_wrapping
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Second phase.  Replace each formatter with the formatted text it      corresponds to.  */
for|for
control|(
name|argno
operator|=
literal|0
init|;
name|formatters
index|[
name|argno
index|]
condition|;
name|argno
operator|++
control|)
block|{
name|int
name|precision
init|=
literal|0
decl_stmt|;
name|bool
name|wide
init|=
name|false
decl_stmt|;
name|bool
name|plus
init|=
name|false
decl_stmt|;
name|bool
name|hash
init|=
name|false
decl_stmt|;
name|bool
name|quote
init|=
name|false
decl_stmt|;
comment|/* We do not attempt to enforce any ordering on the modifier 	 characters.  */
for|for
control|(
name|p
operator|=
operator|*
name|formatters
index|[
name|argno
index|]
init|;
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'q'
case|:
name|gcc_assert
argument_list|(
operator|!
name|quote
argument_list|)
expr_stmt|;
name|quote
operator|=
name|true
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
name|gcc_assert
argument_list|(
operator|!
name|plus
argument_list|)
expr_stmt|;
name|plus
operator|=
name|true
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|gcc_assert
argument_list|(
operator|!
name|hash
argument_list|)
expr_stmt|;
name|hash
operator|=
name|true
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|gcc_assert
argument_list|(
operator|!
name|wide
argument_list|)
expr_stmt|;
name|wide
operator|=
name|true
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
comment|/* We don't support precision beyond that of "long long".  */
name|gcc_assert
argument_list|(
name|precision
operator|<
literal|2
argument_list|)
expr_stmt|;
name|precision
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|gcc_assert
argument_list|(
operator|!
name|wide
operator|||
name|precision
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
condition|)
name|pp_string
argument_list|(
name|pp
argument_list|,
name|open_quote
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'c'
case|:
name|pp_character
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_wide_integer
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|int
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_scalar
argument_list|(
name|pp
argument_list|,
literal|"%"
name|HOST_WIDE_INT_PRINT
literal|"o"
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|unsigned
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pp_pointer
argument_list|(
name|pp
argument_list|,
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_scalar
argument_list|(
name|pp
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|unsigned
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|wide
condition|)
name|pp_scalar
argument_list|(
name|pp
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|va_arg
argument_list|(
argument|*text->args_ptr
argument_list|,
argument|unsigned HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_integer_with_precision
argument_list|(
name|pp
argument_list|,
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|precision
argument_list|,
name|unsigned
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
block|{
name|location_t
modifier|*
name|locus
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|location_t
operator|*
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|text
operator|->
name|locus
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|text
operator|->
name|locus
operator|=
operator|*
name|locus
expr_stmt|;
block|}
break|break;
case|case
literal|'J'
case|:
block|{
name|tree
name|t
init|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|text
operator|->
name|locus
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|text
operator|->
name|locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* We handle '%.Ns' and '%.*s' or '%M$.*N$s' 	       (where M == N + 1).  The format string should be verified 	       already from the first phase.  */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|n
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p
operator|=
name|end
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|p
operator|==
literal|'s'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
operator|*
name|p
operator|==
literal|'*'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|p
operator|==
literal|'s'
argument_list|)
expr_stmt|;
name|n
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* This consumes a second entry in the formatters array.  */
name|gcc_assert
argument_list|(
name|formatters
index|[
name|argno
index|]
operator|==
name|formatters
index|[
name|argno
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|argno
operator|++
expr_stmt|;
block|}
name|s
operator|=
name|va_arg
argument_list|(
operator|*
name|text
operator|->
name|args_ptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|pp_append_text
argument_list|(
name|pp
argument_list|,
name|s
argument_list|,
name|s
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|bool
name|ok
decl_stmt|;
name|gcc_assert
argument_list|(
name|pp_format_decoder
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|pp_format_decoder
argument_list|(
name|pp
argument_list|)
argument_list|(
name|pp
argument_list|,
name|text
argument_list|,
name|p
argument_list|,
name|precision
argument_list|,
name|wide
argument_list|,
name|plus
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quote
condition|)
name|pp_string
argument_list|(
name|pp
argument_list|,
name|close_quote
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|formatters
index|[
name|argno
index|]
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
for|for
control|(
init|;
name|argno
operator|<
name|PP_NL_ARGMAX
condition|;
name|argno
operator|++
control|)
name|gcc_assert
argument_list|(
operator|!
name|formatters
index|[
name|argno
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Revert to normal obstack and wrapping mode.  */
name|buffer
operator|->
name|obstack
operator|=
operator|&
name|buffer
operator|->
name|formatted_obstack
expr_stmt|;
name|buffer
operator|->
name|line_length
operator|=
literal|0
expr_stmt|;
name|pp_wrapping_mode
argument_list|(
name|pp
argument_list|)
operator|=
name|old_wrapping_mode
expr_stmt|;
name|pp_clear_state
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Format of a message pointed to by TEXT.  */
end_comment

begin_function
name|void
name|pp_base_output_formatted_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|unsigned
name|int
name|chunk
decl_stmt|;
name|output_buffer
modifier|*
name|buffer
init|=
name|pp_buffer
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|struct
name|chunk_info
modifier|*
name|chunk_array
init|=
name|buffer
operator|->
name|cur_chunk_array
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args
init|=
name|chunk_array
operator|->
name|args
decl_stmt|;
name|gcc_assert
argument_list|(
name|buffer
operator|->
name|obstack
operator|==
operator|&
name|buffer
operator|->
name|formatted_obstack
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|buffer
operator|->
name|line_length
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* This is a third phase, first 2 phases done in pp_base_format_args.      Now we actually print it.  */
for|for
control|(
name|chunk
operator|=
literal|0
init|;
name|args
index|[
name|chunk
index|]
condition|;
name|chunk
operator|++
control|)
name|pp_string
argument_list|(
name|pp
argument_list|,
name|args
index|[
name|chunk
index|]
argument_list|)
expr_stmt|;
comment|/* Deallocate the chunk structure and everything after it (i.e. the      associated series of formatted strings).  */
name|buffer
operator|->
name|cur_chunk_array
operator|=
name|chunk_array
operator|->
name|prev
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|buffer
operator|->
name|chunk_obstack
argument_list|,
name|chunk_array
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper subroutine of output_verbatim and verbatim. Do the appropriate    settings needed by BUFFER for a verbatim formatting.  */
end_comment

begin_function
name|void
name|pp_base_format_verbatim
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|text_info
modifier|*
name|text
parameter_list|)
block|{
comment|/* Set verbatim mode.  */
name|pp_wrapping_mode_t
name|oldmode
init|=
name|pp_set_verbatim_wrapping
argument_list|(
name|pp
argument_list|)
decl_stmt|;
comment|/* Do the actual formatting.  */
name|pp_format
argument_list|(
name|pp
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|pp_output_formatted_text
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Restore previous settings.  */
name|pp_wrapping_mode
argument_list|(
name|pp
argument_list|)
operator|=
name|oldmode
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush the content of BUFFER onto the attached stream.  */
end_comment

begin_function
name|void
name|pp_base_flush
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_write_text_to_stream
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_clear_state
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|pp
operator|->
name|buffer
operator|->
name|stream
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|stream
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets the number of maximum characters per line PRETTY-PRINTER can    output in line-wrapping mode.  A LENGTH value 0 suppresses    line-wrapping.  */
end_comment

begin_function
name|void
name|pp_base_set_line_maximum_length
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|=
name|length
expr_stmt|;
name|pp_set_real_maximum_length
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear PRETTY-PRINTER output area text info.  */
end_comment

begin_function
name|void
name|pp_base_clear_output_area
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|obstack_free
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
name|obstack_base
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set PREFIX for PRETTY-PRINTER.  */
end_comment

begin_function
name|void
name|pp_base_set_prefix
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|pp
operator|->
name|prefix
operator|=
name|prefix
expr_stmt|;
name|pp_set_real_maximum_length
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|emitted_prefix
operator|=
name|false
expr_stmt|;
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free PRETTY-PRINTER's prefix, a previously malloc()'d string.  */
end_comment

begin_function
name|void
name|pp_base_destroy_prefix
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|->
name|prefix
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|pp
operator|->
name|prefix
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out PRETTY-PRINTER's prefix.  */
end_comment

begin_function
name|void
name|pp_base_emit_prefix
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
if|if
condition|(
name|pp
operator|->
name|prefix
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
condition|)
block|{
default|default:
case|case
name|DIAGNOSTICS_SHOW_PREFIX_NEVER
case|:
break|break;
case|case
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
case|:
if|if
condition|(
name|pp
operator|->
name|emitted_prefix
condition|)
block|{
name|pp_base_indent
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
name|pp_indentation
argument_list|(
name|pp
argument_list|)
operator|+=
literal|3
expr_stmt|;
comment|/* Fall through.  */
case|case
name|DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE
case|:
block|{
name|int
name|prefix_length
init|=
name|strlen
argument_list|(
name|pp
operator|->
name|prefix
argument_list|)
decl_stmt|;
name|pp_append_r
argument_list|(
name|pp
argument_list|,
name|pp
operator|->
name|prefix
argument_list|,
name|prefix_length
argument_list|)
expr_stmt|;
name|pp
operator|->
name|emitted_prefix
operator|=
name|true
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Construct a PRETTY-PRINTER with PREFIX and of MAXIMUM_LENGTH    characters per line.  */
end_comment

begin_function
name|void
name|pp_construct
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|maximum_length
parameter_list|)
block|{
name|memset
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pretty_printer
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|=
name|XCNEW
argument_list|(
name|output_buffer
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|chunk_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|pp
operator|->
name|buffer
operator|->
name|formatted_obstack
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|obstack
operator|=
operator|&
name|pp
operator|->
name|buffer
operator|->
name|formatted_obstack
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|stream
operator|=
name|stderr
expr_stmt|;
name|pp_line_cutoff
argument_list|(
name|pp
argument_list|)
operator|=
name|maximum_length
expr_stmt|;
name|pp_prefixing_rule
argument_list|(
name|pp
argument_list|)
operator|=
name|DIAGNOSTICS_SHOW_PREFIX_ONCE
expr_stmt|;
name|pp_set_prefix
argument_list|(
name|pp
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a string delimited by START and END to the output area of    PRETTY-PRINTER.  No line wrapping is done.  However, if beginning a    new line then emit PRETTY-PRINTER's prefix and skip any leading    whitespace if appropriate.  The caller must ensure that it is    safe to do so.  */
end_comment

begin_function
name|void
name|pp_base_append_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
comment|/* Emit prefix and skip whitespace if we're starting a new line.  */
if|if
condition|(
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|==
literal|0
condition|)
block|{
name|pp_emit_prefix
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
condition|)
while|while
condition|(
name|start
operator|!=
name|end
operator|&&
operator|*
name|start
operator|==
literal|' '
condition|)
operator|++
name|start
expr_stmt|;
block|}
name|pp_append_r
argument_list|(
name|pp
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finishes constructing a NULL-terminated character string representing    the PRETTY-PRINTED text.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pp_base_formatted_text
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|obstack_1grow
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
return|return
name|pp_formatted_text_data
argument_list|(
name|pp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Return a pointer to the last character emitted in PRETTY-PRINTER's     output area.  A NULL pointer means no character available.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pp_base_last_position_in_text
parameter_list|(
specifier|const
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|obstack
modifier|*
name|text
init|=
name|pp
operator|->
name|buffer
operator|->
name|obstack
decl_stmt|;
if|if
condition|(
name|obstack_base
argument_list|(
name|text
argument_list|)
operator|!=
name|obstack_next_free
argument_list|(
name|text
argument_list|)
condition|)
name|p
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|obstack_next_free
argument_list|(
name|text
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of characters PRETTY-PRINTER can accept to    make a full line.  Meaningful only in line-wrapping mode.  */
end_comment

begin_function
name|int
name|pp_base_remaining_character_count_for_line
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
return|return
name|pp
operator|->
name|maximum_length
operator|-
name|pp
operator|->
name|buffer
operator|->
name|line_length
return|;
block|}
end_function

begin_comment
comment|/* Format a message into BUFFER a la printf.  */
end_comment

begin_function
name|void
name|pp_printf
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|text
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|msg
expr_stmt|;
name|text
operator|.
name|locus
operator|=
name|NULL
expr_stmt|;
name|pp_format
argument_list|(
name|pp
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|pp_output_formatted_text
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output MESSAGE verbatim into BUFFER.  */
end_comment

begin_function
name|void
name|pp_verbatim
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|text_info
name|text
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|text
operator|.
name|err_no
operator|=
name|errno
expr_stmt|;
name|text
operator|.
name|args_ptr
operator|=
operator|&
name|ap
expr_stmt|;
name|text
operator|.
name|format_spec
operator|=
name|msg
expr_stmt|;
name|text
operator|.
name|locus
operator|=
name|NULL
expr_stmt|;
name|pp_format_verbatim
argument_list|(
name|pp
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Have PRETTY-PRINTER start a new line.  */
end_comment

begin_function
name|void
name|pp_base_newline
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|obstack_1grow
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|pp
operator|->
name|buffer
operator|->
name|line_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Have PRETTY-PRINTER add a CHARACTER.  */
end_comment

begin_function
name|void
name|pp_base_character
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|pp_is_wrapping_line
argument_list|(
name|pp
argument_list|)
operator|&&
name|pp_remaining_character_count_for_line
argument_list|(
name|pp
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
return|return;
block|}
name|obstack_1grow
argument_list|(
name|pp
operator|->
name|buffer
operator|->
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|++
name|pp
operator|->
name|buffer
operator|->
name|line_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a STRING to the output area of PRETTY-PRINTER; the STRING may    be line-wrapped if in appropriate mode.  */
end_comment

begin_function
name|void
name|pp_base_string
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|pp_maybe_wrap_text
argument_list|(
name|pp
argument_list|,
name|str
argument_list|,
name|str
operator|+
operator|(
name|str
condition|?
name|strlen
argument_list|(
name|str
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Maybe print out a whitespace if needed.  */
end_comment

begin_function
name|void
name|pp_base_maybe_space
parameter_list|(
name|pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
if|if
condition|(
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|!=
name|pp_none
condition|)
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
block|}
end_function

end_unit

