begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory address lowering and addressing mode selection.    Copyright (C) 2004 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Utility functions for manipulation with TARGET_MEM_REFs -- tree expressions    that directly map to addressing modes of the target.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* TODO -- handling of symbols (according to Richard Hendersons    comments, http://gcc.gnu.org/ml/gcc-patches/2005-04/msg00949.html):        There are at least 5 different kinds of symbols that we can run up against:       (1) binds_local_p, small data area.      (2) binds_local_p, eg local statics      (3) !binds_local_p, eg global variables      (4) thread local, local_exec      (5) thread local, !local_exec     Now, (1) won't appear often in an array context, but it certainly can.    All you have to do is set -GN high enough, or explicitly mark any    random object __attribute__((section (".sdata"))).     All of these affect whether or not a symbol is in fact a valid address.    The only one tested here is (3).  And that result may very well    be incorrect for (4) or (5).     An incorrect result here does not cause incorrect results out the    back end, because the expander in expr.c validizes the address.  However    it would be nice to improve the handling here in order to produce more    precise results.  */
end_comment

begin_comment
comment|/* A "template" for memory address, used to determine whether the address is    valid for mode.  */
end_comment

begin_decl_stmt
name|struct
name|mem_addr_template
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|ref
decl_stmt|;
comment|/* The template.  */
name|rtx
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|step_p
decl_stmt|;
comment|/* The point in template where the step should be 				   filled in.  */
name|rtx
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
operator|)
argument_list|)
name|off_p
decl_stmt|;
comment|/* The point in template where the offset should 				   be filled in.  */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* The templates.  Each of the five bits of the index corresponds to one    component of TARGET_MEM_REF being present, see TEMPL_IDX.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|mem_addr_template
name|templates
index|[
literal|32
index|]
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|TEMPL_IDX
parameter_list|(
name|SYMBOL
parameter_list|,
name|BASE
parameter_list|,
name|INDEX
parameter_list|,
name|STEP
parameter_list|,
name|OFFSET
parameter_list|)
define|\
value|(((SYMBOL != 0)<< 4) \    | ((BASE != 0)<< 3) \    | ((INDEX != 0)<< 2) \    | ((STEP != 0)<< 1) \    | (OFFSET != 0))
end_define

begin_comment
comment|/* Stores address for memory reference with parameters SYMBOL, BASE, INDEX,    STEP and OFFSET to *ADDR.  Stores pointers to where step is placed to    *STEP_P and offset to *OFFSET_P.  */
end_comment

begin_function
specifier|static
name|void
name|gen_addr_rtx
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|rtx
name|base
parameter_list|,
name|rtx
name|index
parameter_list|,
name|rtx
name|step
parameter_list|,
name|rtx
name|offset
parameter_list|,
name|rtx
modifier|*
name|addr
parameter_list|,
name|rtx
modifier|*
modifier|*
name|step_p
parameter_list|,
name|rtx
modifier|*
modifier|*
name|offset_p
parameter_list|)
block|{
name|rtx
name|act_elem
decl_stmt|;
operator|*
name|addr
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|step_p
condition|)
operator|*
name|step_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|offset_p
condition|)
operator|*
name|offset_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
name|act_elem
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|act_elem
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|act_elem
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_p
condition|)
operator|*
name|step_p
operator|=
operator|&
name|XEXP
argument_list|(
name|act_elem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|addr
operator|=
name|act_elem
expr_stmt|;
block|}
if|if
condition|(
name|base
condition|)
block|{
if|if
condition|(
operator|*
name|addr
condition|)
operator|*
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
operator|*
name|addr
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|else
operator|*
name|addr
operator|=
name|base
expr_stmt|;
block|}
if|if
condition|(
name|symbol
condition|)
block|{
name|act_elem
operator|=
name|symbol
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|act_elem
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|act_elem
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_p
condition|)
operator|*
name|offset_p
operator|=
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|act_elem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|addr
condition|)
operator|*
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
operator|*
name|addr
argument_list|,
name|act_elem
argument_list|)
expr_stmt|;
else|else
operator|*
name|addr
operator|=
name|act_elem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
operator|*
name|addr
condition|)
block|{
operator|*
name|addr
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
operator|*
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_p
condition|)
operator|*
name|offset_p
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|addr
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|offset_p
condition|)
operator|*
name|offset_p
operator|=
name|addr
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|addr
condition|)
operator|*
name|addr
operator|=
name|const0_rtx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns address for TARGET_MEM_REF with parameters given by ADDR.    If REALLY_EXPAND is false, just make fake registers instead     of really expanding the operands, and perform the expansion in-place    by using one of the "templates".  */
end_comment

begin_function
name|rtx
name|addr_for_mem_ref
parameter_list|(
name|struct
name|mem_address
modifier|*
name|addr
parameter_list|,
name|bool
name|really_expand
parameter_list|)
block|{
name|rtx
name|address
decl_stmt|,
name|sym
decl_stmt|,
name|bse
decl_stmt|,
name|idx
decl_stmt|,
name|st
decl_stmt|,
name|off
decl_stmt|;
specifier|static
name|bool
name|templates_initialized
init|=
name|false
decl_stmt|;
name|struct
name|mem_addr_template
modifier|*
name|templ
decl_stmt|;
if|if
condition|(
name|addr
operator|->
name|step
operator|&&
operator|!
name|integer_onep
argument_list|(
name|addr
operator|->
name|step
argument_list|)
condition|)
name|st
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|addr
operator|->
name|step
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|addr
operator|->
name|step
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|st
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|offset
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|addr
operator|->
name|offset
argument_list|)
condition|)
name|off
operator|=
name|immed_double_const
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|addr
operator|->
name|offset
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|addr
operator|->
name|offset
argument_list|)
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|off
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|!
name|really_expand
condition|)
block|{
comment|/* Reuse the templates for addresses, so that we do not waste memory.  */
if|if
condition|(
operator|!
name|templates_initialized
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|templates_initialized
operator|=
name|true
expr_stmt|;
name|sym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
literal|"test_symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|bse
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
name|idx
operator|=
name|gen_raw_REG
argument_list|(
name|Pmode
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|gen_addr_rtx
argument_list|(
operator|(
name|i
operator|&
literal|16
condition|?
name|sym
else|:
name|NULL_RTX
operator|)
argument_list|,
operator|(
name|i
operator|&
literal|8
condition|?
name|bse
else|:
name|NULL_RTX
operator|)
argument_list|,
operator|(
name|i
operator|&
literal|4
condition|?
name|idx
else|:
name|NULL_RTX
operator|)
argument_list|,
operator|(
name|i
operator|&
literal|2
condition|?
name|const0_rtx
else|:
name|NULL_RTX
operator|)
argument_list|,
operator|(
name|i
operator|&
literal|1
condition|?
name|const0_rtx
else|:
name|NULL_RTX
operator|)
argument_list|,
operator|&
name|templates
index|[
name|i
index|]
operator|.
name|ref
argument_list|,
operator|&
name|templates
index|[
name|i
index|]
operator|.
name|step_p
argument_list|,
operator|&
name|templates
index|[
name|i
index|]
operator|.
name|off_p
argument_list|)
expr_stmt|;
block|}
name|templ
operator|=
name|templates
operator|+
name|TEMPL_IDX
argument_list|(
name|addr
operator|->
name|symbol
argument_list|,
name|addr
operator|->
name|base
argument_list|,
name|addr
operator|->
name|index
argument_list|,
name|st
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
condition|)
operator|*
name|templ
operator|->
name|step_p
operator|=
name|st
expr_stmt|;
if|if
condition|(
name|off
condition|)
operator|*
name|templ
operator|->
name|off_p
operator|=
name|off
expr_stmt|;
return|return
name|templ
operator|->
name|ref
return|;
block|}
comment|/* Otherwise really expand the expressions.  */
name|sym
operator|=
operator|(
name|addr
operator|->
name|symbol
condition|?
name|expand_expr
argument_list|(
name|build_addr
argument_list|(
name|addr
operator|->
name|symbol
argument_list|,
name|current_function_decl
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
name|bse
operator|=
operator|(
name|addr
operator|->
name|base
condition|?
name|expand_expr
argument_list|(
name|addr
operator|->
name|base
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
name|idx
operator|=
operator|(
name|addr
operator|->
name|index
condition|?
name|expand_expr
argument_list|(
name|addr
operator|->
name|index
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
else|:
name|NULL_RTX
operator|)
expr_stmt|;
name|gen_addr_rtx
argument_list|(
name|sym
argument_list|,
name|bse
argument_list|,
name|idx
argument_list|,
name|st
argument_list|,
name|off
argument_list|,
operator|&
name|address
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|address
return|;
block|}
end_function

begin_comment
comment|/* Returns address of MEM_REF in TYPE.  */
end_comment

begin_function
name|tree
name|tree_mem_ref_addr
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|mem_ref
parameter_list|)
block|{
name|tree
name|addr
decl_stmt|;
name|tree
name|act_elem
decl_stmt|;
name|tree
name|step
init|=
name|TMR_STEP
argument_list|(
name|mem_ref
argument_list|)
decl_stmt|,
name|offset
init|=
name|TMR_OFFSET
argument_list|(
name|mem_ref
argument_list|)
decl_stmt|;
name|tree
name|sym
init|=
name|TMR_SYMBOL
argument_list|(
name|mem_ref
argument_list|)
decl_stmt|,
name|base
init|=
name|TMR_BASE
argument_list|(
name|mem_ref
argument_list|)
decl_stmt|;
name|tree
name|addr_base
init|=
name|NULL_TREE
decl_stmt|,
name|addr_off
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|sym
condition|)
name|addr_base
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|build_addr
argument_list|(
name|sym
argument_list|,
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|base
argument_list|)
argument_list|)
condition|)
block|{
name|addr_base
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|act_elem
operator|=
name|TMR_INDEX
argument_list|(
name|mem_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|act_elem
condition|)
block|{
if|if
condition|(
name|step
condition|)
name|act_elem
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|act_elem
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|addr_off
operator|=
name|act_elem
expr_stmt|;
block|}
name|act_elem
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|act_elem
condition|)
block|{
if|if
condition|(
name|addr_off
condition|)
name|addr_off
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|addr_off
argument_list|,
name|act_elem
argument_list|)
expr_stmt|;
else|else
name|addr_off
operator|=
name|act_elem
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zero_p
argument_list|(
name|offset
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr_off
condition|)
name|addr_off
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|addr_off
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|addr_off
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|addr_off
condition|)
block|{
name|addr
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|addr_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_base
condition|)
name|addr
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|addr_base
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr_base
condition|)
name|addr
operator|=
name|addr_base
expr_stmt|;
else|else
name|addr
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Returns true if a memory reference in MODE and with parameters given by    ADDR is valid on the current target.  */
end_comment

begin_function
specifier|static
name|bool
name|valid_mem_ref_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|struct
name|mem_address
modifier|*
name|addr
parameter_list|)
block|{
name|rtx
name|address
decl_stmt|;
name|address
operator|=
name|addr_for_mem_ref
argument_list|(
name|addr
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|address
condition|)
return|return
name|false
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|address
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether a TARGET_MEM_REF with type TYPE and parameters given by ADDR    is valid on the current target and if so, creates and returns the    TARGET_MEM_REF.  */
end_comment

begin_function
specifier|static
name|tree
name|create_mem_ref_raw
parameter_list|(
name|tree
name|type
parameter_list|,
name|struct
name|mem_address
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|valid_mem_ref_p
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|addr
operator|->
name|step
operator|&&
name|integer_onep
argument_list|(
name|addr
operator|->
name|step
argument_list|)
condition|)
name|addr
operator|->
name|step
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|offset
operator|&&
name|zero_p
argument_list|(
name|addr
operator|->
name|offset
argument_list|)
condition|)
name|addr
operator|->
name|offset
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|build7
argument_list|(
name|TARGET_MEM_REF
argument_list|,
name|type
argument_list|,
name|addr
operator|->
name|symbol
argument_list|,
name|addr
operator|->
name|base
argument_list|,
name|addr
operator|->
name|index
argument_list|,
name|addr
operator|->
name|step
argument_list|,
name|addr
operator|->
name|offset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if OBJ is an object whose address is a link time constant.  */
end_comment

begin_function
specifier|static
name|bool
name|fixed_address_object_p
parameter_list|(
name|tree
name|obj
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|obj
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|obj
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|obj
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove M-th element from COMB.  */
end_comment

begin_function
specifier|static
name|void
name|aff_combination_remove_elt
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|comb
parameter_list|,
name|unsigned
name|m
parameter_list|)
block|{
name|comb
operator|->
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|m
operator|<=
name|comb
operator|->
name|n
condition|)
block|{
name|comb
operator|->
name|coefs
index|[
name|m
index|]
operator|=
name|comb
operator|->
name|coefs
index|[
name|comb
operator|->
name|n
index|]
expr_stmt|;
name|comb
operator|->
name|elts
index|[
name|m
index|]
operator|=
name|comb
operator|->
name|elts
index|[
name|comb
operator|->
name|n
index|]
expr_stmt|;
block|}
if|if
condition|(
name|comb
operator|->
name|rest
condition|)
block|{
name|comb
operator|->
name|coefs
index|[
name|comb
operator|->
name|n
index|]
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|elts
index|[
name|comb
operator|->
name|n
index|]
operator|=
name|comb
operator|->
name|rest
expr_stmt|;
name|comb
operator|->
name|rest
operator|=
name|NULL_TREE
expr_stmt|;
name|comb
operator|->
name|n
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If ADDR contains an address of object that is a link time constant,    move it to PARTS->symbol.  */
end_comment

begin_function
specifier|static
name|void
name|move_fixed_address_to_symbol
parameter_list|(
name|struct
name|mem_address
modifier|*
name|parts
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr
operator|->
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|->
name|coefs
index|[
name|i
index|]
operator|!=
literal|1
condition|)
continue|continue;
name|val
operator|=
name|addr
operator|->
name|elts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|fixed_address_object_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|addr
operator|->
name|n
condition|)
return|return;
name|parts
operator|->
name|symbol
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aff_combination_remove_elt
argument_list|(
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If ADDR contains an address of a dereferenced pointer, move it to    PARTS->base.  */
end_comment

begin_function
specifier|static
name|void
name|move_pointer_to_base
parameter_list|(
name|struct
name|mem_address
modifier|*
name|parts
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|tree
name|val
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr
operator|->
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|->
name|coefs
index|[
name|i
index|]
operator|!=
literal|1
condition|)
continue|continue;
name|val
operator|=
name|addr
operator|->
name|elts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|addr
operator|->
name|n
condition|)
return|return;
name|parts
operator|->
name|base
operator|=
name|val
expr_stmt|;
name|aff_combination_remove_elt
argument_list|(
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds ELT to PARTS.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_parts
parameter_list|(
name|struct
name|mem_address
modifier|*
name|parts
parameter_list|,
name|tree
name|elt
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|parts
operator|->
name|index
condition|)
block|{
name|parts
operator|->
name|index
operator|=
name|elt
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|parts
operator|->
name|base
condition|)
block|{
name|parts
operator|->
name|base
operator|=
name|elt
expr_stmt|;
return|return;
block|}
comment|/* Add ELT to base.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|parts
operator|->
name|base
argument_list|)
expr_stmt|;
name|parts
operator|->
name|base
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|parts
operator|->
name|base
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finds the most expensive multiplication in ADDR that can be    expressed in an addressing mode and move the corresponding    element(s) to PARTS.  */
end_comment

begin_function
specifier|static
name|void
name|most_expensive_mult_to_index
parameter_list|(
name|struct
name|mem_address
modifier|*
name|parts
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|best_mult
init|=
literal|0
decl_stmt|;
name|unsigned
name|best_mult_cost
init|=
literal|0
decl_stmt|,
name|acost
decl_stmt|;
name|tree
name|mult_elt
init|=
name|NULL_TREE
decl_stmt|,
name|elt
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr
operator|->
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|->
name|coefs
index|[
name|i
index|]
operator|==
literal|1
operator|||
operator|!
name|multiplier_allowed_in_address_p
argument_list|(
name|addr
operator|->
name|coefs
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|acost
operator|=
name|multiply_by_cost
argument_list|(
name|addr
operator|->
name|coefs
index|[
name|i
index|]
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|acost
operator|>
name|best_mult_cost
condition|)
block|{
name|best_mult_cost
operator|=
name|acost
expr_stmt|;
name|best_mult
operator|=
name|addr
operator|->
name|coefs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|best_mult
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|addr
operator|->
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|->
name|coefs
index|[
name|i
index|]
operator|!=
name|best_mult
condition|)
block|{
name|addr
operator|->
name|coefs
index|[
name|j
index|]
operator|=
name|addr
operator|->
name|coefs
index|[
name|i
index|]
expr_stmt|;
name|addr
operator|->
name|elts
index|[
name|j
index|]
operator|=
name|addr
operator|->
name|elts
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
continue|continue;
block|}
name|elt
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|addr
operator|->
name|elts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mult_elt
condition|)
name|mult_elt
operator|=
name|elt
expr_stmt|;
else|else
name|mult_elt
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|mult_elt
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
name|addr
operator|->
name|n
operator|=
name|j
expr_stmt|;
name|parts
operator|->
name|index
operator|=
name|mult_elt
expr_stmt|;
name|parts
operator|->
name|step
operator|=
name|build_int_cst_type
argument_list|(
name|sizetype
argument_list|,
name|best_mult
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Splits address ADDR into PARTS.        TODO -- be more clever about the distribution of the elements of ADDR    to PARTS.  Some architectures do not support anything but single    register in address, possibly with a small integer offset; while    create_mem_ref will simplify the address to an acceptable shape    later, it would be a small bit more efficient to know that asking    for complicated addressing modes is useless.  */
end_comment

begin_function
specifier|static
name|void
name|addr_to_parts
parameter_list|(
name|struct
name|affine_tree_combination
modifier|*
name|addr
parameter_list|,
name|struct
name|mem_address
modifier|*
name|parts
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|tree
name|part
decl_stmt|;
name|parts
operator|->
name|symbol
operator|=
name|NULL_TREE
expr_stmt|;
name|parts
operator|->
name|base
operator|=
name|NULL_TREE
expr_stmt|;
name|parts
operator|->
name|index
operator|=
name|NULL_TREE
expr_stmt|;
name|parts
operator|->
name|step
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|offset
condition|)
name|parts
operator|->
name|offset
operator|=
name|build_int_cst_type
argument_list|(
name|sizetype
argument_list|,
name|addr
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|parts
operator|->
name|offset
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Try to find a symbol.  */
name|move_fixed_address_to_symbol
argument_list|(
name|parts
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* First move the most expensive feasible multiplication      to index.  */
name|most_expensive_mult_to_index
argument_list|(
name|parts
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Try to find a base of the reference.  Since at the moment      there is no reliable way how to distinguish between pointer and its      offset, this is just a guess.  */
if|if
condition|(
operator|!
name|parts
operator|->
name|symbol
condition|)
name|move_pointer_to_base
argument_list|(
name|parts
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Then try to process the remaining elements.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr
operator|->
name|n
condition|;
name|i
operator|++
control|)
block|{
name|part
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|addr
operator|->
name|elts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|coefs
index|[
name|i
index|]
operator|!=
literal|1
condition|)
name|part
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|part
argument_list|,
name|build_int_cst_type
argument_list|(
name|sizetype
argument_list|,
name|addr
operator|->
name|coefs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|add_to_parts
argument_list|(
name|parts
argument_list|,
name|part
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|->
name|rest
condition|)
name|add_to_parts
argument_list|(
name|parts
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|addr
operator|->
name|rest
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force the PARTS to register.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_mem_ref_parts
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|struct
name|mem_address
modifier|*
name|parts
parameter_list|)
block|{
if|if
condition|(
name|parts
operator|->
name|base
condition|)
name|parts
operator|->
name|base
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|parts
operator|->
name|base
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|->
name|index
condition|)
name|parts
operator|->
name|index
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|parts
operator|->
name|index
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates and returns a TARGET_MEM_REF for address ADDR.  If necessary    computations are emitted in front of BSI.  TYPE is the mode    of created memory reference.  */
end_comment

begin_function
name|tree
name|create_mem_ref
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|type
parameter_list|,
name|struct
name|affine_tree_combination
modifier|*
name|addr
parameter_list|)
block|{
name|tree
name|mem_ref
decl_stmt|,
name|tmp
decl_stmt|;
name|tree
name|addr_type
init|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
decl_stmt|,
name|atype
decl_stmt|;
name|struct
name|mem_address
name|parts
decl_stmt|;
name|addr_to_parts
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
name|gimplify_mem_ref_parts
argument_list|(
name|bsi
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
name|mem_ref
operator|=
name|create_mem_ref_raw
argument_list|(
name|type
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_ref
condition|)
return|return
name|mem_ref
return|;
comment|/* The expression is too complicated.  Try making it simpler.  */
if|if
condition|(
name|parts
operator|.
name|step
operator|&&
operator|!
name|integer_onep
argument_list|(
name|parts
operator|.
name|step
argument_list|)
condition|)
block|{
comment|/* Move the multiplication to index.  */
name|gcc_assert
argument_list|(
name|parts
operator|.
name|index
argument_list|)
expr_stmt|;
name|parts
operator|.
name|index
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|parts
operator|.
name|index
argument_list|,
name|parts
operator|.
name|step
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|parts
operator|.
name|step
operator|=
name|NULL_TREE
expr_stmt|;
name|mem_ref
operator|=
name|create_mem_ref_raw
argument_list|(
name|type
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_ref
condition|)
return|return
name|mem_ref
return|;
block|}
if|if
condition|(
name|parts
operator|.
name|symbol
condition|)
block|{
name|tmp
operator|=
name|fold_convert
argument_list|(
name|addr_type
argument_list|,
name|build_addr
argument_list|(
name|parts
operator|.
name|symbol
argument_list|,
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the symbol to base, eventually forcing it to register.  */
if|if
condition|(
name|parts
operator|.
name|base
condition|)
block|{
if|if
condition|(
name|parts
operator|.
name|index
condition|)
name|parts
operator|.
name|base
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|addr_type
argument_list|,
name|fold_convert
argument_list|(
name|addr_type
argument_list|,
name|parts
operator|.
name|base
argument_list|)
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
else|else
block|{
name|parts
operator|.
name|index
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|parts
operator|.
name|base
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
name|parts
operator|.
name|base
operator|=
name|tmp
expr_stmt|;
name|parts
operator|.
name|symbol
operator|=
name|NULL_TREE
expr_stmt|;
name|mem_ref
operator|=
name|create_mem_ref_raw
argument_list|(
name|type
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_ref
condition|)
return|return
name|mem_ref
return|;
block|}
if|if
condition|(
name|parts
operator|.
name|index
condition|)
block|{
comment|/* Add index to base.  */
if|if
condition|(
name|parts
operator|.
name|base
condition|)
block|{
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|parts
operator|.
name|base
argument_list|)
expr_stmt|;
name|parts
operator|.
name|base
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|atype
argument_list|,
name|parts
operator|.
name|base
argument_list|,
name|fold_convert
argument_list|(
name|atype
argument_list|,
name|parts
operator|.
name|index
argument_list|)
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|parts
operator|.
name|base
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|parts
operator|.
name|index
operator|=
name|NULL_TREE
expr_stmt|;
name|mem_ref
operator|=
name|create_mem_ref_raw
argument_list|(
name|type
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_ref
condition|)
return|return
name|mem_ref
return|;
block|}
if|if
condition|(
name|parts
operator|.
name|offset
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|parts
operator|.
name|offset
argument_list|)
condition|)
block|{
comment|/* Try adding offset to base.  */
if|if
condition|(
name|parts
operator|.
name|base
condition|)
block|{
name|atype
operator|=
name|TREE_TYPE
argument_list|(
name|parts
operator|.
name|base
argument_list|)
expr_stmt|;
name|parts
operator|.
name|base
operator|=
name|force_gimple_operand_bsi
argument_list|(
name|bsi
argument_list|,
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|atype
argument_list|,
name|parts
operator|.
name|base
argument_list|,
name|fold_convert
argument_list|(
name|atype
argument_list|,
name|parts
operator|.
name|offset
argument_list|)
argument_list|)
argument_list|,
name|true
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
name|parts
operator|.
name|base
operator|=
name|parts
operator|.
name|offset
expr_stmt|;
name|parts
operator|.
name|offset
operator|=
name|NULL_TREE
expr_stmt|;
name|mem_ref
operator|=
name|create_mem_ref_raw
argument_list|(
name|type
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_ref
condition|)
return|return
name|mem_ref
return|;
block|}
comment|/* Verify that the address is in the simplest possible shape      (only a register).  If we cannot create such a memory reference,      something is really wrong.  */
name|gcc_assert
argument_list|(
name|parts
operator|.
name|symbol
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|parts
operator|.
name|index
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|parts
operator|.
name|step
operator|||
name|integer_onep
argument_list|(
name|parts
operator|.
name|step
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|parts
operator|.
name|offset
operator|||
name|integer_zerop
argument_list|(
name|parts
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copies components of the address from OP to ADDR.  */
end_comment

begin_function
name|void
name|get_address_description
parameter_list|(
name|tree
name|op
parameter_list|,
name|struct
name|mem_address
modifier|*
name|addr
parameter_list|)
block|{
name|addr
operator|->
name|symbol
operator|=
name|TMR_SYMBOL
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|addr
operator|->
name|base
operator|=
name|TMR_BASE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|addr
operator|->
name|index
operator|=
name|TMR_INDEX
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|addr
operator|->
name|step
operator|=
name|TMR_STEP
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|addr
operator|->
name|offset
operator|=
name|TMR_OFFSET
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copies the additional information attached to target_mem_ref FROM to TO.  */
end_comment

begin_function
name|void
name|copy_mem_ref_info
parameter_list|(
name|tree
name|to
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
comment|/* Copy the annotation, to preserve the aliasing information.  */
name|TMR_TAG
argument_list|(
name|to
argument_list|)
operator|=
name|TMR_TAG
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* And the info about the original reference.  */
name|TMR_ORIGINAL
argument_list|(
name|to
argument_list|)
operator|=
name|TMR_ORIGINAL
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move constants in target_mem_ref REF to offset.  Returns the new target    mem ref if anything changes, NULL_TREE otherwise.  */
end_comment

begin_function
name|tree
name|maybe_fold_tmr
parameter_list|(
name|tree
name|ref
parameter_list|)
block|{
name|struct
name|mem_address
name|addr
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|tree
name|ret
decl_stmt|,
name|off
decl_stmt|;
name|get_address_description
argument_list|(
name|ref
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|base
operator|&&
name|TREE_CODE
argument_list|(
name|addr
operator|.
name|base
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|addr
operator|.
name|offset
condition|)
name|addr
operator|.
name|offset
operator|=
name|fold_binary_to_constant
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|addr
operator|.
name|offset
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|addr
operator|.
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|.
name|offset
operator|=
name|addr
operator|.
name|base
expr_stmt|;
name|addr
operator|.
name|base
operator|=
name|NULL_TREE
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|.
name|index
operator|&&
name|TREE_CODE
argument_list|(
name|addr
operator|.
name|index
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|off
operator|=
name|addr
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|step
condition|)
block|{
name|off
operator|=
name|fold_binary_to_constant
argument_list|(
name|MULT_EXPR
argument_list|,
name|sizetype
argument_list|,
name|off
argument_list|,
name|addr
operator|.
name|step
argument_list|)
expr_stmt|;
name|addr
operator|.
name|step
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|.
name|offset
condition|)
block|{
name|addr
operator|.
name|offset
operator|=
name|fold_binary_to_constant
argument_list|(
name|PLUS_EXPR
argument_list|,
name|sizetype
argument_list|,
name|addr
operator|.
name|offset
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
else|else
name|addr
operator|.
name|offset
operator|=
name|off
expr_stmt|;
name|addr
operator|.
name|index
operator|=
name|NULL_TREE
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|changed
condition|)
return|return
name|NULL_TREE
return|;
name|ret
operator|=
name|create_mem_ref_raw
argument_list|(
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL_TREE
return|;
name|copy_mem_ref_info
argument_list|(
name|ret
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Dump PARTS to FILE.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_mem_address
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|mem_address
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dump_mem_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|mem_address
modifier|*
name|parts
parameter_list|)
block|{
if|if
condition|(
name|parts
operator|->
name|symbol
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"symbol: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|parts
operator|->
name|symbol
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parts
operator|->
name|base
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"base: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|parts
operator|->
name|base
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parts
operator|->
name|index
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"index: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|parts
operator|->
name|index
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parts
operator|->
name|step
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"step: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|parts
operator|->
name|step
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parts
operator|->
name|offset
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"offset: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|parts
operator|->
name|offset
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-ssa-address.h"
end_include

end_unit

