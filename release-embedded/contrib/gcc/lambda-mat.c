begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Integer matrix math routines    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dberlin@dberlin.org>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"lambda.h"
end_include

begin_function_decl
specifier|static
name|void
name|lambda_matrix_get_column
parameter_list|(
name|lambda_matrix
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|lambda_vector
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate a matrix of M rows x  N cols.  */
end_comment

begin_function
name|lambda_matrix
name|lambda_matrix_new
parameter_list|(
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|lambda_matrix
name|mat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mat
operator|=
name|ggc_alloc
argument_list|(
name|m
operator|*
sizeof|sizeof
argument_list|(
name|lambda_vector
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|i
index|]
operator|=
name|lambda_vector_new
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|mat
return|;
block|}
end_function

begin_comment
comment|/* Copy the elements of M x N matrix MAT1 to MAT2.  */
end_comment

begin_function
name|void
name|lambda_matrix_copy
parameter_list|(
name|lambda_matrix
name|mat1
parameter_list|,
name|lambda_matrix
name|mat2
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|lambda_vector_copy
argument_list|(
name|mat1
index|[
name|i
index|]
argument_list|,
name|mat2
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the N x N identity matrix in MAT.  */
end_comment

begin_function
name|void
name|lambda_matrix_id
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
name|mat
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|i
operator|==
name|j
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if MAT is the identity matrix of SIZE */
end_comment

begin_function
name|bool
name|lambda_matrix_id_p
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
condition|)
block|{
if|if
condition|(
name|mat
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|1
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|mat
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Negate the elements of the M x N matrix MAT1 and store it in MAT2.  */
end_comment

begin_function
name|void
name|lambda_matrix_negate
parameter_list|(
name|lambda_matrix
name|mat1
parameter_list|,
name|lambda_matrix
name|mat2
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|lambda_vector_negate
argument_list|(
name|mat1
index|[
name|i
index|]
argument_list|,
name|mat2
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take the transpose of matrix MAT1 and store it in MAT2.    MAT1 is an M x N matrix, so MAT2 must be N x M.  */
end_comment

begin_function
name|void
name|lambda_matrix_transpose
parameter_list|(
name|lambda_matrix
name|mat1
parameter_list|,
name|lambda_matrix
name|mat2
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|m
condition|;
name|j
operator|++
control|)
name|mat2
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|mat1
index|[
name|j
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add two M x N matrices together: MAT3 = MAT1+MAT2.  */
end_comment

begin_function
name|void
name|lambda_matrix_add
parameter_list|(
name|lambda_matrix
name|mat1
parameter_list|,
name|lambda_matrix
name|mat2
parameter_list|,
name|lambda_matrix
name|mat3
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|lambda_vector_add
argument_list|(
name|mat1
index|[
name|i
index|]
argument_list|,
name|mat2
index|[
name|i
index|]
argument_list|,
name|mat3
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MAT3 = CONST1 * MAT1 + CONST2 * MAT2.  All matrices are M x N.  */
end_comment

begin_function
name|void
name|lambda_matrix_add_mc
parameter_list|(
name|lambda_matrix
name|mat1
parameter_list|,
name|int
name|const1
parameter_list|,
name|lambda_matrix
name|mat2
parameter_list|,
name|int
name|const2
parameter_list|,
name|lambda_matrix
name|mat3
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|lambda_vector_add_mc
argument_list|(
name|mat1
index|[
name|i
index|]
argument_list|,
name|const1
argument_list|,
name|mat2
index|[
name|i
index|]
argument_list|,
name|const2
argument_list|,
name|mat3
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiply two matrices: MAT3 = MAT1 * MAT2.    MAT1 is an M x R matrix, and MAT2 is R x N.  The resulting MAT2    must therefore be M x N.  */
end_comment

begin_function
name|void
name|lambda_matrix_mult
parameter_list|(
name|lambda_matrix
name|mat1
parameter_list|,
name|lambda_matrix
name|mat2
parameter_list|,
name|lambda_matrix
name|mat3
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|r
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|mat3
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|r
condition|;
name|k
operator|++
control|)
name|mat3
index|[
name|i
index|]
index|[
name|j
index|]
operator|+=
name|mat1
index|[
name|i
index|]
index|[
name|k
index|]
operator|*
name|mat2
index|[
name|k
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get column COL from the matrix MAT and store it in VEC.  MAT has    N rows, so the length of VEC must be N.  */
end_comment

begin_function
specifier|static
name|void
name|lambda_matrix_get_column
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|col
parameter_list|,
name|lambda_vector
name|vec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|vec
index|[
name|i
index|]
operator|=
name|mat
index|[
name|i
index|]
index|[
name|col
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete rows r1 to r2 (not including r2).  */
end_comment

begin_function
name|void
name|lambda_matrix_delete_rows
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|dist
decl_stmt|;
name|dist
operator|=
name|to
operator|-
name|from
expr_stmt|;
for|for
control|(
name|i
operator|=
name|to
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|i
operator|-
name|dist
index|]
operator|=
name|mat
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rows
operator|-
name|dist
init|;
name|i
operator|<
name|rows
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap rows R1 and R2 in matrix MAT.  */
end_comment

begin_function
name|void
name|lambda_matrix_row_exchange
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|r1
parameter_list|,
name|int
name|r2
parameter_list|)
block|{
name|lambda_vector
name|row
decl_stmt|;
name|row
operator|=
name|mat
index|[
name|r1
index|]
expr_stmt|;
name|mat
index|[
name|r1
index|]
operator|=
name|mat
index|[
name|r2
index|]
expr_stmt|;
name|mat
index|[
name|r2
index|]
operator|=
name|row
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a multiple of row R1 of matrix MAT with N columns to row R2:    R2 = R2 + CONST1 * R1.  */
end_comment

begin_function
name|void
name|lambda_matrix_row_add
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|r1
parameter_list|,
name|int
name|r2
parameter_list|,
name|int
name|const1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|const1
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|r2
index|]
index|[
name|i
index|]
operator|+=
name|const1
operator|*
name|mat
index|[
name|r1
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Negate row R1 of matrix MAT which has N columns.  */
end_comment

begin_function
name|void
name|lambda_matrix_row_negate
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|r1
parameter_list|)
block|{
name|lambda_vector_negate
argument_list|(
name|mat
index|[
name|r1
index|]
argument_list|,
name|mat
index|[
name|r1
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiply row R1 of matrix MAT with N columns by CONST1.  */
end_comment

begin_function
name|void
name|lambda_matrix_row_mc
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|r1
parameter_list|,
name|int
name|const1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|r1
index|]
index|[
name|i
index|]
operator|*=
name|const1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exchange COL1 and COL2 in matrix MAT. M is the number of rows.  */
end_comment

begin_function
name|void
name|lambda_matrix_col_exchange
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|col1
parameter_list|,
name|int
name|col2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|tmp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|mat
index|[
name|i
index|]
index|[
name|col1
index|]
expr_stmt|;
name|mat
index|[
name|i
index|]
index|[
name|col1
index|]
operator|=
name|mat
index|[
name|i
index|]
index|[
name|col2
index|]
expr_stmt|;
name|mat
index|[
name|i
index|]
index|[
name|col2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a multiple of column C1 of matrix MAT with M rows to column C2:    C2 = C2 + CONST1 * C1.  */
end_comment

begin_function
name|void
name|lambda_matrix_col_add
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|c1
parameter_list|,
name|int
name|c2
parameter_list|,
name|int
name|const1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|const1
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|i
index|]
index|[
name|c2
index|]
operator|+=
name|const1
operator|*
name|mat
index|[
name|i
index|]
index|[
name|c1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Negate column C1 of matrix MAT which has M rows.  */
end_comment

begin_function
name|void
name|lambda_matrix_col_negate
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|c1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|i
index|]
index|[
name|c1
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiply column C1 of matrix MAT with M rows by CONST1.  */
end_comment

begin_function
name|void
name|lambda_matrix_col_mc
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|c1
parameter_list|,
name|int
name|const1
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|mat
index|[
name|i
index|]
index|[
name|c1
index|]
operator|*=
name|const1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the inverse of the N x N matrix MAT and store it in INV.     We don't _really_ compute the inverse of MAT.  Instead we compute    det(MAT)*inv(MAT), and we return det(MAT) to the caller as the function    result.  This is necessary to preserve accuracy, because we are dealing    with integer matrices here.     The algorithm used here is a column based Gauss-Jordan elimination on MAT    and the identity matrix in parallel.  The inverse is the result of applying    the same operations on the identity matrix that reduce MAT to the identity    matrix.     When MAT is a 2 x 2 matrix, we don't go through the whole process, because    it is easily inverted by inspection and it is a very common case.  */
end_comment

begin_function_decl
specifier|static
name|int
name|lambda_matrix_inverse_hard
parameter_list|(
name|lambda_matrix
parameter_list|,
name|lambda_matrix
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|lambda_matrix_inverse
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|lambda_matrix
name|inv
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|2
condition|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|det
decl_stmt|;
name|a
operator|=
name|mat
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|=
name|mat
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|=
name|mat
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|d
operator|=
name|mat
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|inv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|d
expr_stmt|;
name|inv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|c
expr_stmt|;
name|inv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|b
expr_stmt|;
name|inv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|a
expr_stmt|;
name|det
operator|=
operator|(
name|a
operator|*
name|d
operator|-
name|b
operator|*
name|c
operator|)
expr_stmt|;
if|if
condition|(
name|det
operator|<
literal|0
condition|)
block|{
name|det
operator|*=
operator|-
literal|1
expr_stmt|;
name|inv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|inv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|inv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
name|inv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|det
return|;
block|}
else|else
return|return
name|lambda_matrix_inverse_hard
argument_list|(
name|mat
argument_list|,
name|inv
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If MAT is not a special case, invert it the hard way.  */
end_comment

begin_function
specifier|static
name|int
name|lambda_matrix_inverse_hard
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|lambda_matrix
name|inv
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|lambda_vector
name|row
decl_stmt|;
name|lambda_matrix
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|determinant
decl_stmt|;
name|temp
operator|=
name|lambda_matrix_new
argument_list|(
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lambda_matrix_copy
argument_list|(
name|mat
argument_list|,
name|temp
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lambda_matrix_id
argument_list|(
name|inv
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Reduce TEMP to a lower triangular form, applying the same operations on      INV which starts as the identity matrix.  N is the number of rows and      columns.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|row
operator|=
name|temp
index|[
name|j
index|]
expr_stmt|;
comment|/* Make every element in the current row positive.  */
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|row
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|lambda_matrix_col_negate
argument_list|(
name|temp
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lambda_matrix_col_negate
argument_list|(
name|inv
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Sweep the upper triangle.  Stop when only the diagonal element in the 	 current row is nonzero.  */
while|while
condition|(
name|lambda_vector_first_nz
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|<
name|n
condition|)
block|{
name|int
name|min_col
init|=
name|lambda_vector_min_nz
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|lambda_matrix_col_exchange
argument_list|(
name|temp
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|min_col
argument_list|)
expr_stmt|;
name|lambda_matrix_col_exchange
argument_list|(
name|inv
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|min_col
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|+
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|factor
decl_stmt|;
name|factor
operator|=
operator|-
literal|1
operator|*
name|row
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|row
index|[
name|j
index|]
operator|!=
literal|1
condition|)
name|factor
operator|/=
name|row
index|[
name|j
index|]
expr_stmt|;
name|lambda_matrix_col_add
argument_list|(
name|temp
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|lambda_matrix_col_add
argument_list|(
name|inv
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reduce TEMP from a lower triangular to the identity matrix.  Also compute      the determinant, which now is simply the product of the elements on the      diagonal of TEMP.  If one of these elements is 0, the matrix has 0 as an      eigenvalue so it is singular and hence not invertible.  */
name|determinant
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|n
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|diagonal
decl_stmt|;
name|row
operator|=
name|temp
index|[
name|j
index|]
expr_stmt|;
name|diagonal
operator|=
name|row
index|[
name|j
index|]
expr_stmt|;
comment|/* The matrix must not be singular.  */
name|gcc_assert
argument_list|(
name|diagonal
argument_list|)
expr_stmt|;
name|determinant
operator|=
name|determinant
operator|*
name|diagonal
expr_stmt|;
comment|/* If the diagonal is not 1, then multiply the each row by the          diagonal so that the middle number is now 1, rather than a          rational.  */
if|if
condition|(
name|diagonal
operator|!=
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|lambda_matrix_col_mc
argument_list|(
name|inv
argument_list|,
name|n
argument_list|,
name|i
argument_list|,
name|diagonal
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|+
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|lambda_matrix_col_mc
argument_list|(
name|inv
argument_list|,
name|n
argument_list|,
name|i
argument_list|,
name|diagonal
argument_list|)
expr_stmt|;
name|row
index|[
name|j
index|]
operator|=
name|diagonal
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Sweep the lower triangle column wise.  */
for|for
control|(
name|i
operator|=
name|j
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|row
index|[
name|i
index|]
condition|)
block|{
name|int
name|factor
init|=
operator|-
name|row
index|[
name|i
index|]
decl_stmt|;
name|lambda_matrix_col_add
argument_list|(
name|temp
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|lambda_matrix_col_add
argument_list|(
name|inv
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|determinant
return|;
block|}
end_function

begin_comment
comment|/* Decompose a N x N matrix MAT to a product of a lower triangular H    and a unimodular U matrix such that MAT = H.U.  N is the size of    the rows of MAT.  */
end_comment

begin_function
name|void
name|lambda_matrix_hermite
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|n
parameter_list|,
name|lambda_matrix
name|H
parameter_list|,
name|lambda_matrix
name|U
parameter_list|)
block|{
name|lambda_vector
name|row
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|factor
decl_stmt|,
name|minimum_col
decl_stmt|;
name|lambda_matrix_copy
argument_list|(
name|mat
argument_list|,
name|H
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lambda_matrix_id
argument_list|(
name|U
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|row
operator|=
name|H
index|[
name|j
index|]
expr_stmt|;
comment|/* Make every element of H[j][j..n] positive.  */
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|row
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|lambda_matrix_col_negate
argument_list|(
name|H
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lambda_vector_negate
argument_list|(
name|U
index|[
name|i
index|]
argument_list|,
name|U
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Stop when only the diagonal element is nonzero.  */
while|while
condition|(
name|lambda_vector_first_nz
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|<
name|n
condition|)
block|{
name|minimum_col
operator|=
name|lambda_vector_min_nz
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|lambda_matrix_col_exchange
argument_list|(
name|H
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|minimum_col
argument_list|)
expr_stmt|;
name|lambda_matrix_row_exchange
argument_list|(
name|U
argument_list|,
name|j
argument_list|,
name|minimum_col
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|+
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|factor
operator|=
name|row
index|[
name|i
index|]
operator|/
name|row
index|[
name|j
index|]
expr_stmt|;
name|lambda_matrix_col_add
argument_list|(
name|H
argument_list|,
name|n
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
operator|-
literal|1
operator|*
name|factor
argument_list|)
expr_stmt|;
name|lambda_matrix_row_add
argument_list|(
name|U
argument_list|,
name|n
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|factor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given an M x N integer matrix A, this function determines an M x    M unimodular matrix U, and an M x N echelon matrix S such that    "U.A = S".  This decomposition is also known as "right Hermite".        Ref: Algorithm 2.1 page 33 in "Loop Transformations for    Restructuring Compilers" Utpal Banerjee.  */
end_comment

begin_function
name|void
name|lambda_matrix_right_hermite
parameter_list|(
name|lambda_matrix
name|A
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|,
name|lambda_matrix
name|S
parameter_list|,
name|lambda_matrix
name|U
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
init|=
literal|0
decl_stmt|;
name|lambda_matrix_copy
argument_list|(
name|A
argument_list|,
name|S
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lambda_matrix_id
argument_list|(
name|U
argument_list|,
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lambda_vector_first_nz
argument_list|(
name|S
index|[
name|j
index|]
argument_list|,
name|m
argument_list|,
name|i0
argument_list|)
operator|<
name|m
condition|)
block|{
operator|++
name|i0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|1
init|;
name|i
operator|>=
name|i0
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
name|S
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|sigma
decl_stmt|,
name|factor
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|a
operator|=
name|S
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
expr_stmt|;
name|b
operator|=
name|S
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|sigma
operator|=
operator|(
name|a
operator|*
name|b
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|a
operator|=
name|abs
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|abs
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|factor
operator|=
name|sigma
operator|*
operator|(
name|a
operator|/
name|b
operator|)
expr_stmt|;
name|lambda_matrix_row_add
argument_list|(
name|S
argument_list|,
name|n
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|,
operator|-
name|factor
argument_list|)
expr_stmt|;
name|lambda_matrix_row_exchange
argument_list|(
name|S
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lambda_matrix_row_add
argument_list|(
name|U
argument_list|,
name|m
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|,
operator|-
name|factor
argument_list|)
expr_stmt|;
name|lambda_matrix_row_exchange
argument_list|(
name|U
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given an M x N integer matrix A, this function determines an M x M    unimodular matrix V, and an M x N echelon matrix S such that "A =    V.S".  This decomposition is also known as "left Hermite".        Ref: Algorithm 2.2 page 36 in "Loop Transformations for    Restructuring Compilers" Utpal Banerjee.  */
end_comment

begin_function
name|void
name|lambda_matrix_left_hermite
parameter_list|(
name|lambda_matrix
name|A
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|,
name|lambda_matrix
name|S
parameter_list|,
name|lambda_matrix
name|V
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i0
init|=
literal|0
decl_stmt|;
name|lambda_matrix_copy
argument_list|(
name|A
argument_list|,
name|S
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lambda_matrix_id
argument_list|(
name|V
argument_list|,
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|lambda_vector_first_nz
argument_list|(
name|S
index|[
name|j
index|]
argument_list|,
name|m
argument_list|,
name|i0
argument_list|)
operator|<
name|m
condition|)
block|{
operator|++
name|i0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|-
literal|1
init|;
name|i
operator|>=
name|i0
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
name|S
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|sigma
decl_stmt|,
name|factor
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|a
operator|=
name|S
index|[
name|i
operator|-
literal|1
index|]
index|[
name|j
index|]
expr_stmt|;
name|b
operator|=
name|S
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|sigma
operator|=
operator|(
name|a
operator|*
name|b
operator|<
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|a
operator|=
name|abs
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|abs
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|factor
operator|=
name|sigma
operator|*
operator|(
name|a
operator|/
name|b
operator|)
expr_stmt|;
name|lambda_matrix_row_add
argument_list|(
name|S
argument_list|,
name|n
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|,
operator|-
name|factor
argument_list|)
expr_stmt|;
name|lambda_matrix_row_exchange
argument_list|(
name|S
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lambda_matrix_col_add
argument_list|(
name|V
argument_list|,
name|m
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|factor
argument_list|)
expr_stmt|;
name|lambda_matrix_col_exchange
argument_list|(
name|V
argument_list|,
name|m
argument_list|,
name|i
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* When it exists, return the first nonzero row in MAT after row    STARTROW.  Otherwise return rowsize.  */
end_comment

begin_function
name|int
name|lambda_matrix_first_nz_vec
parameter_list|(
name|lambda_matrix
name|mat
parameter_list|,
name|int
name|rowsize
parameter_list|,
name|int
name|colsize
parameter_list|,
name|int
name|startrow
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
for|for
control|(
name|j
operator|=
name|startrow
init|;
operator|(
name|j
operator|<
name|rowsize
operator|)
operator|&&
operator|!
name|found
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mat
index|[
name|j
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lambda_vector_first_nz
argument_list|(
name|mat
index|[
name|j
index|]
argument_list|,
name|colsize
argument_list|,
name|startrow
argument_list|)
operator|<
name|colsize
operator|)
condition|)
name|found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
name|j
operator|-
literal|1
return|;
return|return
name|rowsize
return|;
block|}
end_function

begin_comment
comment|/* Calculate the projection of E sub k to the null space of B.  */
end_comment

begin_function
name|void
name|lambda_matrix_project_to_null
parameter_list|(
name|lambda_matrix
name|B
parameter_list|,
name|int
name|rowsize
parameter_list|,
name|int
name|colsize
parameter_list|,
name|int
name|k
parameter_list|,
name|lambda_vector
name|x
parameter_list|)
block|{
name|lambda_matrix
name|M1
decl_stmt|,
name|M2
decl_stmt|,
name|M3
decl_stmt|,
name|I
decl_stmt|;
name|int
name|determinant
decl_stmt|;
comment|/* Compute c(I-B^T inv(B B^T) B) e sub k.  */
comment|/* M1 is the transpose of B.  */
name|M1
operator|=
name|lambda_matrix_new
argument_list|(
name|colsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|lambda_matrix_transpose
argument_list|(
name|B
argument_list|,
name|M1
argument_list|,
name|rowsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
comment|/* M2 = B * B^T */
name|M2
operator|=
name|lambda_matrix_new
argument_list|(
name|colsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|lambda_matrix_mult
argument_list|(
name|B
argument_list|,
name|M1
argument_list|,
name|M2
argument_list|,
name|rowsize
argument_list|,
name|colsize
argument_list|,
name|rowsize
argument_list|)
expr_stmt|;
comment|/* M3 = inv(M2) */
name|M3
operator|=
name|lambda_matrix_new
argument_list|(
name|colsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|determinant
operator|=
name|lambda_matrix_inverse
argument_list|(
name|M2
argument_list|,
name|M3
argument_list|,
name|rowsize
argument_list|)
expr_stmt|;
comment|/* M2 = B^T (inv(B B^T)) */
name|lambda_matrix_mult
argument_list|(
name|M1
argument_list|,
name|M3
argument_list|,
name|M2
argument_list|,
name|colsize
argument_list|,
name|rowsize
argument_list|,
name|rowsize
argument_list|)
expr_stmt|;
comment|/* M1 = B^T (inv(B B^T)) B */
name|lambda_matrix_mult
argument_list|(
name|M2
argument_list|,
name|B
argument_list|,
name|M1
argument_list|,
name|colsize
argument_list|,
name|rowsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|lambda_matrix_negate
argument_list|(
name|M1
argument_list|,
name|M1
argument_list|,
name|colsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|I
operator|=
name|lambda_matrix_new
argument_list|(
name|colsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|lambda_matrix_id
argument_list|(
name|I
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|lambda_matrix_add_mc
argument_list|(
name|I
argument_list|,
name|determinant
argument_list|,
name|M1
argument_list|,
literal|1
argument_list|,
name|M2
argument_list|,
name|colsize
argument_list|,
name|colsize
argument_list|)
expr_stmt|;
name|lambda_matrix_get_column
argument_list|(
name|M2
argument_list|,
name|colsize
argument_list|,
name|k
operator|-
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiply a vector VEC by a matrix MAT.    MAT is an M*N matrix, and VEC is a vector with length N.  The result    is stored in DEST which must be a vector of length M.  */
end_comment

begin_function
name|void
name|lambda_matrix_vector_mult
parameter_list|(
name|lambda_matrix
name|matrix
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|,
name|lambda_vector
name|vec
parameter_list|,
name|lambda_vector
name|dest
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lambda_vector_clear
argument_list|(
name|dest
argument_list|,
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
name|dest
index|[
name|i
index|]
operator|+=
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|*
name|vec
index|[
name|j
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out an M x N matrix MAT to OUTFILE.  */
end_comment

begin_function
name|void
name|print_lambda_matrix
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|,
name|lambda_matrix
name|matrix
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
control|)
name|print_lambda_vector
argument_list|(
name|outfile
argument_list|,
name|matrix
index|[
name|i
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

