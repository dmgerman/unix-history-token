begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Rewrite a program in Normal form into SSA.    Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Diego Novillo<dnovillo@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"domwalk.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"vecprim.h"
end_include

begin_comment
comment|/* This file builds the SSA form for a function as described in:    R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and K. Zadeck. Efficiently    Computing Static Single Assignment Form and the Control Dependence    Graph. ACM Transactions on Programming Languages and Systems,    13(4):451-490, October 1991.  */
end_comment

begin_comment
comment|/* True if the code is in ssa form.  */
end_comment

begin_decl_stmt
name|bool
name|in_ssa_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to map a variable VAR to the set of blocks that contain    definitions for VAR.  */
end_comment

begin_struct
struct|struct
name|def_blocks_d
block|{
comment|/* The variable.  */
name|tree
name|var
decl_stmt|;
comment|/* Blocks that contain definitions of VAR.  Bit I will be set if the      Ith block contains a definition of VAR.  */
name|bitmap
name|def_blocks
decl_stmt|;
comment|/* Blocks that contain a PHI node for VAR.  */
name|bitmap
name|phi_blocks
decl_stmt|;
comment|/* Blocks where VAR is live-on-entry.  Similar semantics as      DEF_BLOCKS.  */
name|bitmap
name|livein_blocks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Each entry in DEF_BLOCKS contains an element of type STRUCT    DEF_BLOCKS_D, mapping a variable VAR to a bitmap describing all the    basic blocks where VAR is defined (assigned a new value).  It also    contains a bitmap of all the blocks where VAR is live-on-entry    (i.e., there is a use of VAR in block B without a preceding    definition in B).  The live-on-entry information is used when    computing PHI pruning heuristics.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|def_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of trees used to restore the global currdefs to its original    state after completing rewriting of a block and its dominator    children.  Its elements have the following properties:     - An SSA_NAME indicates that the current definition of the      underlying variable should be set to the given SSA_NAME.     - A _DECL node indicates that the underlying variable has no      current definition.     - A NULL node is used to mark the last node associated with the      current block.     - A NULL node at the top entry is used to mark the last node      associated with the current block.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|block_defs_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set of existing SSA names being replaced by update_ssa.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|old_ssa_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of new SSA names being added by update_ssa.  Note that both    NEW_SSA_NAMES and OLD_SSA_NAMES are dense bitmaps because most of    the operations done on them are presence tests.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|new_ssa_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbols whose SSA form needs to be updated or created for the first    time.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|syms_to_rename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of SSA names that have been marked to be released after they    were registered in the replacement table.  They will be finally    released after we finish updating the SSA web.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|names_to_release
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each block, the phi nodes that need to be rewritten are stored into    these vectors.  */
end_comment

begin_typedef
typedef|typedef
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|tree_vec
expr_stmt|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|tree_vec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|tree_vec
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|tree_vec
argument_list|,
name|heap
argument_list|)
operator|*
name|phis_to_rewrite
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The bitmap of non-NULL elements of PHIS_TO_REWRITE.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|blocks_with_phis_to_rewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Growth factor for NEW_SSA_NAMES and OLD_SSA_NAMES.  These sets need    to grow as the callers to register_new_name_mapping will typically    create new names on the fly.  FIXME.  Currently set to 1/3 to avoid    frequent reallocations but still need to find a reasonable growth    strategy.  */
end_comment

begin_define
define|#
directive|define
name|NAME_SETS_GROWTH_FACTOR
value|(MAX (3, num_ssa_names / 3))
end_define

begin_comment
comment|/* Tuple used to represent replacement mappings.  */
end_comment

begin_struct
struct|struct
name|repl_map_d
block|{
name|tree
name|name
decl_stmt|;
name|bitmap
name|set
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* NEW -> OLD_SET replacement table.  If we are replacing several    existing SSA names O_1, O_2, ..., O_j with a new name N_i,    then REPL_TBL[N_i] = { O_1, O_2, ..., O_j }.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|repl_tbl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if register_new_name_mapping needs to initialize the data    structures needed by update_ssa.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|need_to_initialize_update_ssa_p
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if update_ssa needs to update virtual operands.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|need_to_update_vops_p
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics kept by update_ssa to use in the virtual mapping    heuristic.  If the number of virtual mappings is beyond certain    threshold, the updater will switch from using the mappings into    renaming the virtual symbols from scratch.  In some cases, the    large number of name mappings for virtual names causes significant    slowdowns in the PHI insertion code.  */
end_comment

begin_struct
struct|struct
name|update_ssa_stats_d
block|{
name|unsigned
name|num_virtual_mappings
decl_stmt|;
name|unsigned
name|num_total_mappings
decl_stmt|;
name|bitmap
name|virtual_symbols
decl_stmt|;
name|unsigned
name|num_virtual_symbols
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|update_ssa_stats_d
name|update_ssa_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global data to attach to the main dominator walk structure.  */
end_comment

begin_struct
struct|struct
name|mark_def_sites_global_data
block|{
comment|/* This bitmap contains the variables which are set before they      are used in a basic block.  */
name|bitmap
name|kills
decl_stmt|;
comment|/* Bitmap of names to rename.  */
name|sbitmap
name|names_to_rename
decl_stmt|;
comment|/* Set of blocks that mark_def_sites deems interesting for the      renamer to process.  */
name|sbitmap
name|interesting_blocks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information stored for SSA names.  */
end_comment

begin_struct
struct|struct
name|ssa_name_info
block|{
comment|/* The actual definition of the ssa name.  */
name|tree
name|current_def
decl_stmt|;
comment|/* This field indicates whether or not the variable may need PHI nodes.      See the enum's definition for more detailed information about the      states.  */
name|ENUM_BITFIELD
argument_list|(
argument|need_phi_state
argument_list|)
name|need_phi_state
label|:
literal|2
expr_stmt|;
comment|/* Age of this record (so that info_for_ssa_name table can be cleared      quicky); if AGE< CURRENT_INFO_FOR_SSA_NAME_AGE, then the fields      are assumed to be null.  */
name|unsigned
name|age
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The information associated with names.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ssa_name_info
modifier|*
name|ssa_name_info_p
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|ssa_name_info_p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|ssa_name_info_p
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|ssa_name_info_p
argument_list|,
name|heap
argument_list|)
operator|*
name|info_for_ssa_name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|current_info_for_ssa_name_age
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The set of blocks affected by update_ssa.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|blocks_to_update
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The main entry point to the SSA renamer (rewrite_blocks) may be    called several times to do different, but related, tasks.    Initially, we need it to rename the whole program into SSA form.    At other times, we may need it to only rename into SSA newly    exposed symbols.  Finally, we can also call it to incrementally fix    an already built SSA web.  */
end_comment

begin_enum
enum|enum
name|rewrite_mode
block|{
comment|/* Convert the whole function into SSA form.  */
name|REWRITE_ALL
block|,
comment|/* Incrementally update the SSA web by replacing existing SSA        names with new ones.  See update_ssa for details.  */
name|REWRITE_UPDATE
block|}
enum|;
end_enum

begin_comment
comment|/* Use TREE_VISITED to keep track of which statements we want to    rename.  When renaming a subset of the variables, not all    statements will be processed.  This is decided in mark_def_sites.  */
end_comment

begin_define
define|#
directive|define
name|REWRITE_THIS_STMT
parameter_list|(
name|T
parameter_list|)
value|TREE_VISITED (T)
end_define

begin_comment
comment|/* Use the unsigned flag to keep track of which statements we want to    visit when marking new definition sites.  This is slightly    different than REWRITE_THIS_STMT: it's used by update_ssa to    distinguish statements that need to have both uses and defs    processed from those that only need to have their defs processed.    Statements that define new SSA names only need to have their defs    registered, but they don't need to have their uses renamed.  */
end_comment

begin_define
define|#
directive|define
name|REGISTER_DEFS_IN_THIS_STMT
parameter_list|(
name|T
parameter_list|)
value|(T)->common.unsigned_flag
end_define

begin_comment
comment|/* Prototypes for debugging functions.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|dump_tree_ssa
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|debug_tree_ssa
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|debug_def_blocks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_tree_ssa_stats
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|debug_tree_ssa_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_update_ssa
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_update_ssa
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_names_replaced_by
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_names_replaced_by
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Get the information associated with NAME.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ssa_name_info
modifier|*
name|get_ssa_name_ann
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|unsigned
name|ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|len
init|=
name|VEC_length
argument_list|(
name|ssa_name_info_p
argument_list|,
name|info_for_ssa_name
argument_list|)
decl_stmt|;
name|struct
name|ssa_name_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|ver
operator|>=
name|len
condition|)
block|{
name|unsigned
name|new_len
init|=
name|num_ssa_names
decl_stmt|;
name|VEC_reserve
argument_list|(
name|ssa_name_info_p
argument_list|,
name|heap
argument_list|,
name|info_for_ssa_name
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|++
operator|<
name|new_len
condition|)
block|{
name|struct
name|ssa_name_info
modifier|*
name|info
init|=
name|XCNEW
argument_list|(
expr|struct
name|ssa_name_info
argument_list|)
decl_stmt|;
name|info
operator|->
name|age
operator|=
name|current_info_for_ssa_name_age
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|ssa_name_info_p
argument_list|,
name|info_for_ssa_name
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|info
operator|=
name|VEC_index
argument_list|(
name|ssa_name_info_p
argument_list|,
name|info_for_ssa_name
argument_list|,
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|age
operator|<
name|current_info_for_ssa_name_age
condition|)
block|{
name|info
operator|->
name|need_phi_state
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|current_def
operator|=
name|NULL_TREE
expr_stmt|;
name|info
operator|->
name|age
operator|=
name|current_info_for_ssa_name_age
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
end_function

begin_comment
comment|/* Clears info for ssa names.  */
end_comment

begin_function
specifier|static
name|void
name|clear_ssa_name_info
parameter_list|(
name|void
parameter_list|)
block|{
name|current_info_for_ssa_name_age
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gets phi_state field for VAR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|need_phi_state
name|get_phi_state
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|get_ssa_name_ann
argument_list|(
name|var
argument_list|)
operator|->
name|need_phi_state
return|;
else|else
return|return
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|need_phi_state
return|;
block|}
end_function

begin_comment
comment|/* Sets phi_state field for VAR to STATE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_phi_state
parameter_list|(
name|tree
name|var
parameter_list|,
name|enum
name|need_phi_state
name|state
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|get_ssa_name_ann
argument_list|(
name|var
argument_list|)
operator|->
name|need_phi_state
operator|=
name|state
expr_stmt|;
else|else
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|need_phi_state
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the current definition for VAR.  */
end_comment

begin_function
name|tree
name|get_current_def
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|get_ssa_name_ann
argument_list|(
name|var
argument_list|)
operator|->
name|current_def
return|;
else|else
return|return
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|current_def
return|;
block|}
end_function

begin_comment
comment|/* Sets current definition of VAR to DEF.  */
end_comment

begin_function
name|void
name|set_current_def
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|def
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|get_ssa_name_ann
argument_list|(
name|var
argument_list|)
operator|->
name|current_def
operator|=
name|def
expr_stmt|;
else|else
name|var_ann
argument_list|(
name|var
argument_list|)
operator|->
name|current_def
operator|=
name|def
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute global livein information given the set of blockx where    an object is locally live at the start of the block (LIVEIN)    and the set of blocks where the object is defined (DEF_BLOCKS).     Note: This routine augments the existing local livein information    to include global livein (i.e., it modifies the underlying bitmap    for LIVEIN).  */
end_comment

begin_function
name|void
name|compute_global_livein
parameter_list|(
name|bitmap
name|livein
parameter_list|,
name|bitmap
name|def_blocks
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|tos
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|tos
operator|=
name|worklist
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
operator|(
name|last_basic_block
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|livein
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
operator|*
name|tos
operator|++
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Iterate until the worklist is empty.  */
while|while
condition|(
name|tos
operator|!=
name|worklist
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
comment|/* Pull a block off the worklist.  */
name|bb
operator|=
operator|*
operator|--
name|tos
expr_stmt|;
comment|/* For each predecessor block.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|basic_block
name|pred
init|=
name|e
operator|->
name|src
decl_stmt|;
name|int
name|pred_index
init|=
name|pred
operator|->
name|index
decl_stmt|;
comment|/* None of this is necessary for the entry block.  */
if|if
condition|(
name|pred
operator|!=
name|ENTRY_BLOCK_PTR
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|livein
argument_list|,
name|pred_index
argument_list|)
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|def_blocks
argument_list|,
name|pred_index
argument_list|)
condition|)
block|{
operator|*
name|tos
operator|++
operator|=
name|pred
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|livein
argument_list|,
name|pred_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleans up the REWRITE_THIS_STMT and REGISTER_DEFS_IN_THIS_STMT flags for    all statements in basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_flags_in_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|,
name|stmt
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|REWRITE_THIS_STMT
argument_list|(
name|phi
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|phi
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
comment|/* We are going to use the operand cache API, such as 	 SET_USE, SET_DEF, and FOR_EACH_IMM_USE_FAST.  The operand 	 cache for each statement should be up-to-date.  */
name|gcc_assert
argument_list|(
operator|!
name|stmt_modified_p
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark block BB as interesting for update_ssa.  */
end_comment

begin_function
specifier|static
name|void
name|mark_block_for_update
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|blocks_to_update
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|blocks_to_update
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
return|return;
name|bitmap_set_bit
argument_list|(
name|blocks_to_update
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|initialize_flags_in_bb
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the set of blocks where variable VAR is defined and the blocks    where VAR is live on entry (livein).  If no entry is found in    DEF_BLOCKS, a new one is created and returned.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|def_blocks_d
modifier|*
name|get_def_blocks_for
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|struct
name|def_blocks_d
name|db
decl_stmt|,
modifier|*
name|db_p
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|db
operator|.
name|var
operator|=
name|var
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|def_blocks
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|db
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|db_p
operator|=
name|XNEW
argument_list|(
expr|struct
name|def_blocks_d
argument_list|)
expr_stmt|;
name|db_p
operator|->
name|var
operator|=
name|var
expr_stmt|;
name|db_p
operator|->
name|def_blocks
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|db_p
operator|->
name|phi_blocks
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|db_p
operator|->
name|livein_blocks
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|db_p
expr_stmt|;
block|}
else|else
name|db_p
operator|=
operator|(
expr|struct
name|def_blocks_d
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
return|return
name|db_p
return|;
block|}
end_function

begin_comment
comment|/* Mark block BB as the definition site for variable VAR.  PHI_P is true if    VAR is defined by a PHI node.  */
end_comment

begin_function
specifier|static
name|void
name|set_def_block
parameter_list|(
name|tree
name|var
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|bool
name|phi_p
parameter_list|)
block|{
name|struct
name|def_blocks_d
modifier|*
name|db_p
decl_stmt|;
name|enum
name|need_phi_state
name|state
decl_stmt|;
name|state
operator|=
name|get_phi_state
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|db_p
operator|=
name|get_def_blocks_for
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Set the bit corresponding to the block where VAR is defined.  */
name|bitmap_set_bit
argument_list|(
name|db_p
operator|->
name|def_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|phi_p
condition|)
name|bitmap_set_bit
argument_list|(
name|db_p
operator|->
name|phi_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Keep track of whether or not we may need to insert PHI nodes.       If we are in the UNKNOWN state, then this is the first definition      of VAR.  Additionally, we have not seen any uses of VAR yet, so      we do not need a PHI node for this variable at this time (i.e.,      transition to NEED_PHI_STATE_NO).       If we are in any other state, then we either have multiple definitions      of this variable occurring in different blocks or we saw a use of the      variable which was not dominated by the block containing the      definition(s).  In this case we may need a PHI node, so enter      state NEED_PHI_STATE_MAYBE.  */
if|if
condition|(
name|state
operator|==
name|NEED_PHI_STATE_UNKNOWN
condition|)
name|set_phi_state
argument_list|(
name|var
argument_list|,
name|NEED_PHI_STATE_NO
argument_list|)
expr_stmt|;
else|else
name|set_phi_state
argument_list|(
name|var
argument_list|,
name|NEED_PHI_STATE_MAYBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark block BB as having VAR live at the entry to BB.  */
end_comment

begin_function
specifier|static
name|void
name|set_livein_block
parameter_list|(
name|tree
name|var
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|def_blocks_d
modifier|*
name|db_p
decl_stmt|;
name|enum
name|need_phi_state
name|state
init|=
name|get_phi_state
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|db_p
operator|=
name|get_def_blocks_for
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Set the bit corresponding to the block where VAR is live in.  */
name|bitmap_set_bit
argument_list|(
name|db_p
operator|->
name|livein_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Keep track of whether or not we may need to insert PHI nodes.       If we reach here in NEED_PHI_STATE_NO, see if this use is dominated      by the single block containing the definition(s) of this variable.  If      it is, then we remain in NEED_PHI_STATE_NO, otherwise we transition to      NEED_PHI_STATE_MAYBE.  */
if|if
condition|(
name|state
operator|==
name|NEED_PHI_STATE_NO
condition|)
block|{
name|int
name|def_block_index
init|=
name|bitmap_first_set_bit
argument_list|(
name|db_p
operator|->
name|def_blocks
argument_list|)
decl_stmt|;
if|if
condition|(
name|def_block_index
operator|==
operator|-
literal|1
operator|||
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|def_block_index
argument_list|)
argument_list|)
condition|)
name|set_phi_state
argument_list|(
name|var
argument_list|,
name|NEED_PHI_STATE_MAYBE
argument_list|)
expr_stmt|;
block|}
else|else
name|set_phi_state
argument_list|(
name|var
argument_list|,
name|NEED_PHI_STATE_MAYBE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if symbol SYM is marked for renaming.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|symbol_marked_for_renaming
parameter_list|(
name|tree
name|sym
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bitmap_bit_p
argument_list|(
name|syms_to_rename
argument_list|,
name|DECL_UID
argument_list|(
name|sym
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if NAME is in OLD_SSA_NAMES.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_old_name
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|unsigned
name|ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|ver
operator|<
name|new_ssa_names
operator|->
name|n_bits
operator|&&
name|TEST_BIT
argument_list|(
name|old_ssa_names
argument_list|,
name|ver
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if NAME is in NEW_SSA_NAMES.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_new_name
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|unsigned
name|ver
init|=
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|ver
operator|<
name|new_ssa_names
operator|->
name|n_bits
operator|&&
name|TEST_BIT
argument_list|(
name|new_ssa_names
argument_list|,
name|ver
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hashing and equality functions for REPL_TBL.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|repl_map_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|htab_hash_pointer
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
operator|(
specifier|const
expr|struct
name|repl_map_d
operator|*
operator|)
name|p
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|repl_map_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|repl_map_d
operator|*
operator|)
name|p1
operator|)
operator|->
name|name
operator|==
operator|(
operator|(
specifier|const
expr|struct
name|repl_map_d
operator|*
operator|)
name|p2
operator|)
operator|->
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|repl_map_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|BITMAP_FREE
argument_list|(
operator|(
operator|(
expr|struct
name|repl_map_d
operator|*
operator|)
name|p
operator|)
operator|->
name|set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the names replaced by NEW (i.e., REPL_TBL[NEW].SET).  */
end_comment

begin_function
specifier|static
specifier|inline
name|bitmap
name|names_replaced_by
parameter_list|(
name|tree
name|new
parameter_list|)
block|{
name|struct
name|repl_map_d
name|m
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|m
operator|.
name|name
operator|=
name|new
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|repl_tbl
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|m
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
comment|/* If N was not registered in the replacement table, return NULL.  */
if|if
condition|(
name|slot
operator|==
name|NULL
operator|||
operator|*
name|slot
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|(
expr|struct
name|repl_map_d
operator|*
operator|)
operator|*
name|slot
operator|)
operator|->
name|set
return|;
block|}
end_function

begin_comment
comment|/* Add OLD to REPL_TBL[NEW].SET.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_to_repl_tbl
parameter_list|(
name|tree
name|new
parameter_list|,
name|tree
name|old
parameter_list|)
block|{
name|struct
name|repl_map_d
name|m
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|m
operator|.
name|name
operator|=
name|new
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|repl_tbl
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|m
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|mp
operator|=
name|XNEW
argument_list|(
expr|struct
name|repl_map_d
argument_list|)
expr_stmt|;
name|mp
operator|->
name|name
operator|=
name|new
expr_stmt|;
name|mp
operator|->
name|set
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|mp
expr_stmt|;
block|}
else|else
name|mp
operator|=
operator|(
expr|struct
name|repl_map_d
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|mp
operator|->
name|set
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new mapping NEW -> OLD REPL_TBL.  Every entry N_i in REPL_TBL    represents the set of names O_1 ... O_j replaced by N_i.  This is    used by update_ssa and its helpers to introduce new SSA names in an    already formed SSA web.  */
end_comment

begin_function
specifier|static
name|void
name|add_new_name_mapping
parameter_list|(
name|tree
name|new
parameter_list|,
name|tree
name|old
parameter_list|)
block|{
name|timevar_push
argument_list|(
name|TV_TREE_SSA_INCREMENTAL
argument_list|)
expr_stmt|;
comment|/* OLD and NEW must be different SSA names for the same symbol.  */
name|gcc_assert
argument_list|(
name|new
operator|!=
name|old
operator|&&
name|SSA_NAME_VAR
argument_list|(
name|new
argument_list|)
operator|==
name|SSA_NAME_VAR
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We may need to grow NEW_SSA_NAMES and OLD_SSA_NAMES because our      caller may have created new names since the set was created.  */
if|if
condition|(
name|new_ssa_names
operator|->
name|n_bits
operator|<=
name|num_ssa_names
operator|-
literal|1
condition|)
block|{
name|unsigned
name|int
name|new_sz
init|=
name|num_ssa_names
operator|+
name|NAME_SETS_GROWTH_FACTOR
decl_stmt|;
name|new_ssa_names
operator|=
name|sbitmap_resize
argument_list|(
name|new_ssa_names
argument_list|,
name|new_sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old_ssa_names
operator|=
name|sbitmap_resize
argument_list|(
name|old_ssa_names
argument_list|,
name|new_sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this mapping is for virtual names, we will need to update      virtual operands.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|new
argument_list|)
condition|)
block|{
name|tree
name|sym
decl_stmt|;
name|size_t
name|uid
decl_stmt|;
name|need_to_update_vops_p
operator|=
name|true
expr_stmt|;
comment|/* Keep counts of virtual mappings and symbols to use in the 	 virtual mapping heuristic.  If we have large numbers of 	 virtual mappings for a relatively low number of symbols, it 	 will make more sense to rename the symbols from scratch. 	 Otherwise, the insertion of PHI nodes for each of the old 	 names in these mappings will be very slow.  */
name|sym
operator|=
name|SSA_NAME_VAR
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|uid
operator|=
name|DECL_UID
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|update_ssa_stats
operator|.
name|num_virtual_mappings
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|update_ssa_stats
operator|.
name|virtual_symbols
argument_list|,
name|uid
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|update_ssa_stats
operator|.
name|virtual_symbols
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|update_ssa_stats
operator|.
name|num_virtual_symbols
operator|++
expr_stmt|;
block|}
block|}
comment|/* Update the REPL_TBL table.  */
name|add_to_repl_tbl
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* If OLD had already been registered as a new name, then all the      names that OLD replaces should also be replaced by NEW.  */
if|if
condition|(
name|is_new_name
argument_list|(
name|old
argument_list|)
condition|)
name|bitmap_ior_into
argument_list|(
name|names_replaced_by
argument_list|(
name|new
argument_list|)
argument_list|,
name|names_replaced_by
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register NEW and OLD in NEW_SSA_NAMES and OLD_SSA_NAMES,      respectively.  */
name|SET_BIT
argument_list|(
name|new_ssa_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|old_ssa_names
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update mapping counter to use in the virtual mapping heuristic.  */
name|update_ssa_stats
operator|.
name|num_total_mappings
operator|++
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_SSA_INCREMENTAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call back for walk_dominator_tree used to collect definition sites    for every variable in the function.  For every statement S in block    BB:     1- Variables defined by S in the DEFS of S are marked in the bitmap       WALK_DATA->GLOBAL_DATA->KILLS.     2- If S uses a variable VAR and there is no preceding kill of VAR,       then it is marked in the LIVEIN_BLOCKS bitmap associated with VAR.     This information is used to determine which variables are live    across block boundaries to reduce the number of PHI nodes    we create.  */
end_comment

begin_function
specifier|static
name|void
name|mark_def_sites
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|block_stmt_iterator
name|bsi
parameter_list|)
block|{
name|struct
name|mark_def_sites_global_data
modifier|*
name|gd
init|=
operator|(
expr|struct
name|mark_def_sites_global_data
operator|*
operator|)
name|walk_data
operator|->
name|global_data
decl_stmt|;
name|bitmap
name|kills
init|=
name|gd
operator|->
name|kills
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|def
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|update_stmt_if_modified
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|blocks_to_update
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If a variable is used before being set, then the variable is live      across a block boundary, so mark it live-on-entry to BB.  */
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE | SSA_OP_VUSE | SSA_OP_VMUSTKILL
argument_list|)
block|{
name|tree
name|sym
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|kills
argument_list|,
name|DECL_UID
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
name|set_livein_block
argument_list|(
name|sym
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Note that virtual definitions are irrelevant for computing KILLS      because a V_MAY_DEF does not constitute a killing definition of the      variable.  However, the operand of a virtual definitions is a use      of the variable, so it may cause the variable to be considered      live-on-entry.  */
name|FOR_EACH_SSA_MAYDEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|)
block|{
name|tree
name|sym
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|set_livein_block
argument_list|(
name|sym
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|set_def_block
argument_list|(
name|sym
argument_list|,
name|bb
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now process the defs and must-defs made by this statement.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF | SSA_OP_VMUSTDEF
argument_list|)
block|{
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
name|set_def_block
argument_list|(
name|def
argument_list|,
name|bb
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|kills
argument_list|,
name|DECL_UID
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we found the statement interesting then also mark the block BB      as interesting.  */
if|if
condition|(
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|||
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|gd
operator|->
name|interesting_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Structure used by prune_unused_phi_nodes to record bounds of the intervals    in the dfs numbering of the dominance tree.  */
end_comment

begin_struct
struct|struct
name|dom_dfsnum
block|{
comment|/* Basic block whose index this entry corresponds to.  */
name|unsigned
name|bb_index
decl_stmt|;
comment|/* The dfs number of this node.  */
name|unsigned
name|dfs_num
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compares two entries of type struct dom_dfsnum by dfs_num field.  Callback    for qsort.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_dfsnum
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|dom_dfsnum
modifier|*
name|da
init|=
name|a
decl_stmt|;
specifier|const
name|struct
name|dom_dfsnum
modifier|*
name|db
init|=
name|b
decl_stmt|;
return|return
operator|(
name|int
operator|)
name|da
operator|->
name|dfs_num
operator|-
operator|(
name|int
operator|)
name|db
operator|->
name|dfs_num
return|;
block|}
end_function

begin_comment
comment|/* Among the intervals starting at the N points specified in DEFS, find    the one that contains S, and return its bb_index.  */
end_comment

begin_function
specifier|static
name|unsigned
name|find_dfsnum_interval
parameter_list|(
name|struct
name|dom_dfsnum
modifier|*
name|defs
parameter_list|,
name|unsigned
name|n
parameter_list|,
name|unsigned
name|s
parameter_list|)
block|{
name|unsigned
name|f
init|=
literal|0
decl_stmt|,
name|t
init|=
name|n
decl_stmt|,
name|m
decl_stmt|;
while|while
condition|(
name|t
operator|>
name|f
operator|+
literal|1
condition|)
block|{
name|m
operator|=
operator|(
name|f
operator|+
name|t
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|defs
index|[
name|m
index|]
operator|.
name|dfs_num
operator|<=
name|s
condition|)
name|f
operator|=
name|m
expr_stmt|;
else|else
name|t
operator|=
name|m
expr_stmt|;
block|}
return|return
name|defs
index|[
name|f
index|]
operator|.
name|bb_index
return|;
block|}
end_function

begin_comment
comment|/* Clean bits from PHIS for phi nodes whose value cannot be used in USES.    KILLS is a bitmap of blocks where the value is defined before any use.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unused_phi_nodes
parameter_list|(
name|bitmap
name|phis
parameter_list|,
name|bitmap
name|kills
parameter_list|,
name|bitmap
name|uses
parameter_list|)
block|{
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|worklist
expr_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|b
decl_stmt|,
name|p
decl_stmt|,
name|u
decl_stmt|,
name|top
decl_stmt|;
name|bitmap
name|live_phis
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|,
name|use_bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bitmap
name|to_remove
decl_stmt|;
name|struct
name|dom_dfsnum
modifier|*
name|defs
decl_stmt|;
name|unsigned
name|n_defs
decl_stmt|,
name|adef
decl_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|uses
argument_list|)
condition|)
block|{
name|bitmap_clear
argument_list|(
name|phis
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The phi must dominate a use, or an argument of a live phi.  Also, we      do not create any phi nodes in def blocks, unless they are also livein.  */
name|to_remove
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_and_compl
argument_list|(
name|to_remove
argument_list|,
name|kills
argument_list|,
name|uses
argument_list|)
expr_stmt|;
name|bitmap_and_compl_into
argument_list|(
name|phis
argument_list|,
name|to_remove
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|phis
argument_list|)
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|to_remove
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We want to remove the unnecessary phi nodes, but we do not want to compute      liveness information, as that may be linear in the size of CFG, and if      there are lot of different variables to rewrite, this may lead to quadratic      behavior.       Instead, we basically emulate standard dce.  We put all uses to worklist,      then for each of them find the nearest def that dominates them.  If this      def is a phi node, we mark it live, and if it was not live before, we      add the predecessors of its basic block to the worklist.          To quickly locate the nearest def that dominates use, we use dfs numbering      of the dominance tree (that is already available in order to speed up      queries).  For each def, we have the interval given by the dfs number on      entry to and on exit from the corresponding subtree in the dominance tree.      The nearest dominator for a given use is the smallest of these intervals      that contains entry and exit dfs numbers for the basic block with the use.      If we store the bounds for all the uses to an array and sort it, we can      locate the nearest dominating def in logarithmic time by binary search.*/
name|bitmap_ior
argument_list|(
name|to_remove
argument_list|,
name|kills
argument_list|,
name|phis
argument_list|)
expr_stmt|;
name|n_defs
operator|=
name|bitmap_count_bits
argument_list|(
name|to_remove
argument_list|)
expr_stmt|;
name|defs
operator|=
name|XNEWVEC
argument_list|(
expr|struct
name|dom_dfsnum
argument_list|,
literal|2
operator|*
name|n_defs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|defs
index|[
literal|0
index|]
operator|.
name|bb_index
operator|=
literal|1
expr_stmt|;
name|defs
index|[
literal|0
index|]
operator|.
name|dfs_num
operator|=
literal|0
expr_stmt|;
name|adef
operator|=
literal|1
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|to_remove
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|def_bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|defs
index|[
name|adef
index|]
operator|.
name|bb_index
operator|=
name|i
expr_stmt|;
name|defs
index|[
name|adef
index|]
operator|.
name|dfs_num
operator|=
name|bb_dom_dfs_in
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|def_bb
argument_list|)
expr_stmt|;
name|defs
index|[
name|adef
operator|+
literal|1
index|]
operator|.
name|bb_index
operator|=
name|i
expr_stmt|;
name|defs
index|[
name|adef
operator|+
literal|1
index|]
operator|.
name|dfs_num
operator|=
name|bb_dom_dfs_out
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|def_bb
argument_list|)
expr_stmt|;
name|adef
operator|+=
literal|2
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|to_remove
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|adef
operator|==
literal|2
operator|*
name|n_defs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|defs
argument_list|,
name|adef
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dom_dfsnum
argument_list|)
argument_list|,
name|cmp_dfsnum
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|defs
index|[
literal|0
index|]
operator|.
name|bb_index
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* Now each DEFS entry contains the number of the basic block to that the      dfs number corresponds.  Change them to the number of basic block that      corresponds to the interval following the dfs number.  Also, for the      dfs_out numbers, increase the dfs number by one (so that it corresponds      to the start of the following interval, not to the end of the current      one).  We use WORKLIST as a stack.  */
name|worklist
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|n_defs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top
operator|=
literal|1
expr_stmt|;
name|n_defs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adef
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|defs
index|[
name|i
index|]
operator|.
name|bb_index
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|top
condition|)
block|{
comment|/* This is a closing element.  Interval corresponding to the top 	     of the stack after removing it follows.  */
name|VEC_pop
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
name|top
operator|=
name|VEC_index
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|,
name|VEC_length
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|defs
index|[
name|n_defs
index|]
operator|.
name|bb_index
operator|=
name|top
expr_stmt|;
name|defs
index|[
name|n_defs
index|]
operator|.
name|dfs_num
operator|=
name|defs
index|[
name|i
index|]
operator|.
name|dfs_num
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Opening element.  Nothing to do, just push it to the stack and move 	     it to the correct position.  */
name|defs
index|[
name|n_defs
index|]
operator|.
name|bb_index
operator|=
name|defs
index|[
name|i
index|]
operator|.
name|bb_index
expr_stmt|;
name|defs
index|[
name|n_defs
index|]
operator|.
name|dfs_num
operator|=
name|defs
index|[
name|i
index|]
operator|.
name|dfs_num
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|top
operator|=
name|b
expr_stmt|;
block|}
comment|/* If this interval starts at the same point as the previous one, cancel 	 the previous one.  */
if|if
condition|(
name|defs
index|[
name|n_defs
index|]
operator|.
name|dfs_num
operator|==
name|defs
index|[
name|n_defs
operator|-
literal|1
index|]
operator|.
name|dfs_num
condition|)
name|defs
index|[
name|n_defs
operator|-
literal|1
index|]
operator|.
name|bb_index
operator|=
name|defs
index|[
name|n_defs
index|]
operator|.
name|bb_index
expr_stmt|;
else|else
name|n_defs
operator|++
expr_stmt|;
block|}
name|VEC_pop
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_empty
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now process the uses.  */
name|live_phis
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|uses
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|VEC_empty
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|)
condition|)
block|{
name|b
operator|=
name|VEC_pop
argument_list|(
name|int
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|ENTRY_BLOCK
condition|)
continue|continue;
comment|/* If there is a phi node in USE_BB, it is made live.  Otherwise, 	 find the def that dominates the immediate dominator of USE_BB 	 (the kill in USE_BB does not dominate the use).  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|phis
argument_list|,
name|b
argument_list|)
condition|)
name|p
operator|=
name|b
expr_stmt|;
else|else
block|{
name|use_bb
operator|=
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|find_dfsnum_interval
argument_list|(
name|defs
argument_list|,
name|n_defs
argument_list|,
name|bb_dom_dfs_in
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|use_bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|phis
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
block|}
comment|/* If the phi node is already live, there is nothing to do.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|live_phis
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
comment|/* Mark the phi as live, and add the new uses to the worklist.  */
name|bitmap_set_bit
argument_list|(
name|live_phis
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|def_bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|def_bb->preds
argument_list|)
block|{
name|u
operator|=
name|e
operator|->
name|src
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|uses
argument_list|,
name|u
argument_list|)
condition|)
continue|continue;
comment|/* In case there is a kill directly in the use block, do not record 	     the use (this is also necessary for correctness, as we assume that 	     uses dominated by a def directly in their block have been filtered 	     out before).  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|kills
argument_list|,
name|u
argument_list|)
condition|)
continue|continue;
name|bitmap_set_bit
argument_list|(
name|uses
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
block|}
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|worklist
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|phis
argument_list|,
name|live_phis
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|live_phis
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a set of blocks with variable definitions (DEF_BLOCKS),    return a bitmap with all the blocks in the iterated dominance    frontier of the blocks in DEF_BLOCKS.  DFS contains dominance    frontier information as returned by compute_dominance_frontiers.        The resulting set of blocks are the potential sites where PHI nodes    are needed.  The caller is responsible from freeing the memory    allocated for the return value.  */
end_comment

begin_function
specifier|static
name|bitmap
name|find_idf
parameter_list|(
name|bitmap
name|def_blocks
parameter_list|,
name|bitmap
modifier|*
name|dfs
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|bb_index
decl_stmt|;
name|VEC
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
operator|*
name|work_stack
expr_stmt|;
name|bitmap
name|phi_insertion_points
decl_stmt|;
name|work_stack
operator|=
name|VEC_alloc
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|phi_insertion_points
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Seed the work list with all the blocks in DEF_BLOCKS.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|def_blocks
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
comment|/* We use VEC_quick_push here for speed.  This is safe because we        know that the number of definition blocks is no greater than        the number of basic blocks, which is the initial capacity of        WORK_STACK.  */
name|VEC_quick_push
argument_list|(
name|int
argument_list|,
name|work_stack
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
comment|/* Pop a block off the worklist, add every block that appears in      the original block's DF that we have not already processed to      the worklist.  Iterate until the worklist is empty.   Blocks      which are added to the worklist are potential sites for      PHI nodes.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|int
argument_list|,
name|work_stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|bb_index
operator|=
name|VEC_pop
argument_list|(
name|int
argument_list|,
name|work_stack
argument_list|)
expr_stmt|;
comment|/* Since the registration of NEW -> OLD name mappings is done 	 separately from the call to update_ssa, when updating the SSA 	 form, the basic blocks where new and/or old names are defined 	 may have disappeared by CFG cleanup calls.  In this case, 	 we may pull a non-existing block from the work stack.  */
name|gcc_assert
argument_list|(
name|bb_index
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
argument_list|)
expr_stmt|;
name|EXECUTE_IF_AND_COMPL_IN_BITMAP
argument_list|(
argument|dfs[bb_index]
argument_list|,
argument|phi_insertion_points
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
comment|/* Use a safe push because if there is a definition of VAR 	     in every basic block, then WORK_STACK may eventually have 	     more than N_BASIC_BLOCK entries.  */
name|VEC_safe_push
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|work_stack
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|phi_insertion_points
argument_list|,
name|bb_index
argument_list|)
expr_stmt|;
block|}
block|}
name|VEC_free
argument_list|(
name|int
argument_list|,
name|heap
argument_list|,
name|work_stack
argument_list|)
expr_stmt|;
return|return
name|phi_insertion_points
return|;
block|}
end_function

begin_comment
comment|/* Return the set of blocks where variable VAR is defined and the blocks    where VAR is live on entry (livein).  Return NULL, if no entry is    found in DEF_BLOCKS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|def_blocks_d
modifier|*
name|find_def_blocks_for
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|struct
name|def_blocks_d
name|dm
decl_stmt|;
name|dm
operator|.
name|var
operator|=
name|var
expr_stmt|;
return|return
operator|(
expr|struct
name|def_blocks_d
operator|*
operator|)
name|htab_find
argument_list|(
name|def_blocks
argument_list|,
operator|&
name|dm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve or create a default definition for symbol SYM.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|get_default_def_for
parameter_list|(
name|tree
name|sym
parameter_list|)
block|{
name|tree
name|ddef
init|=
name|default_def
argument_list|(
name|sym
argument_list|)
decl_stmt|;
if|if
condition|(
name|ddef
operator|==
name|NULL_TREE
condition|)
block|{
name|ddef
operator|=
name|make_ssa_name
argument_list|(
name|sym
argument_list|,
name|build_empty_stmt
argument_list|()
argument_list|)
expr_stmt|;
name|set_default_def
argument_list|(
name|sym
argument_list|,
name|ddef
argument_list|)
expr_stmt|;
block|}
return|return
name|ddef
return|;
block|}
end_function

begin_comment
comment|/* Marks phi node PHI in basic block BB for rewrite.  */
end_comment

begin_function
specifier|static
name|void
name|mark_phi_for_rewrite
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|tree
name|phi
parameter_list|)
block|{
name|tree_vec
name|phis
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|idx
init|=
name|bb
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|REWRITE_THIS_STMT
argument_list|(
name|phi
argument_list|)
condition|)
return|return;
name|REWRITE_THIS_STMT
argument_list|(
name|phi
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|blocks_with_phis_to_rewrite
condition|)
return|return;
name|bitmap_set_bit
argument_list|(
name|blocks_with_phis_to_rewrite
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|VEC_reserve
argument_list|(
name|tree_vec
argument_list|,
name|heap
argument_list|,
name|phis_to_rewrite
argument_list|,
name|last_basic_block
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|tree_vec
argument_list|,
name|phis_to_rewrite
argument_list|)
init|;
name|i
operator|<=
name|idx
condition|;
name|i
operator|++
control|)
name|VEC_quick_push
argument_list|(
name|tree_vec
argument_list|,
name|phis_to_rewrite
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|phis
operator|=
name|VEC_index
argument_list|(
name|tree_vec
argument_list|,
name|phis_to_rewrite
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phis
condition|)
name|phis
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|phis
argument_list|,
name|phi
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree_vec
argument_list|,
name|phis_to_rewrite
argument_list|,
name|idx
argument_list|,
name|phis
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert PHI nodes for variable VAR using the iterated dominance    frontier given in PHI_INSERTION_POINTS.  If UPDATE_P is true, this    function assumes that the caller is incrementally updating the SSA    form, in which case (1) VAR is assumed to be an SSA name, (2) a new    SSA name is created for VAR's symbol, and, (3) all the arguments    for the newly created PHI node are set to VAR.     PHI_INSERTION_POINTS is updated to reflect nodes that already had a    PHI node for VAR.  On exit, only the nodes that received a PHI node    for VAR will be present in PHI_INSERTION_POINTS.  */
end_comment

begin_function
specifier|static
name|void
name|insert_phi_nodes_for
parameter_list|(
name|tree
name|var
parameter_list|,
name|bitmap
name|phi_insertion_points
parameter_list|,
name|bool
name|update_p
parameter_list|)
block|{
name|unsigned
name|bb_index
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|struct
name|def_blocks_d
modifier|*
name|def_map
decl_stmt|;
name|def_map
operator|=
name|find_def_blocks_for
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|def_map
argument_list|)
expr_stmt|;
comment|/* Remove the blocks where we already have PHI nodes for VAR.  */
name|bitmap_and_compl_into
argument_list|(
name|phi_insertion_points
argument_list|,
name|def_map
operator|->
name|phi_blocks
argument_list|)
expr_stmt|;
comment|/* Remove obviously useless phi nodes.  */
name|prune_unused_phi_nodes
argument_list|(
name|phi_insertion_points
argument_list|,
name|def_map
operator|->
name|def_blocks
argument_list|,
name|def_map
operator|->
name|livein_blocks
argument_list|)
expr_stmt|;
comment|/* And insert the PHI nodes.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|phi_insertion_points
argument_list|,
literal|0
argument_list|,
argument|bb_index
argument_list|,
argument|bi
argument_list|)
block|{
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|bb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_p
condition|)
name|mark_block_for_update
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_p
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* If we are rewriting SSA names, create the LHS of the PHI 	     node by duplicating VAR.  This is useful in the case of 	     pointers, to also duplicate pointer attributes (alias 	     information, in particular).  */
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|new_lhs
decl_stmt|;
name|phi
operator|=
name|create_phi_node
argument_list|(
name|var
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|new_lhs
operator|=
name|duplicate_ssa_name
argument_list|(
name|var
argument_list|,
name|phi
argument_list|)
expr_stmt|;
name|SET_PHI_RESULT
argument_list|(
name|phi
argument_list|,
name|new_lhs
argument_list|)
expr_stmt|;
name|add_new_name_mapping
argument_list|(
name|new_lhs
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Add VAR to every argument slot of PHI.  We need VAR in 	     every argument so that rewrite_update_phi_arguments knows 	     which name is this PHI node replacing.  If VAR is a 	     symbol marked for renaming, this is not necessary, the 	     renamer will use the symbol on the LHS to get its 	     reaching definition.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|var
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|var
argument_list|)
condition|?
name|var
else|:
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|phi
operator|=
name|create_phi_node
argument_list|(
name|sym
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
comment|/* Mark this PHI node as interesting for update_ssa.  */
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|phi
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mark_phi_for_rewrite
argument_list|(
name|bb
argument_list|,
name|phi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert PHI nodes at the dominance frontier of blocks with variable    definitions.  DFS contains the dominance frontier information for    the flowgraph.  PHI nodes will only be inserted at the dominance    frontier of definition blocks for variables whose NEED_PHI_STATE    annotation is marked as ``maybe'' or ``unknown'' (computed by    mark_def_sites).  */
end_comment

begin_function
specifier|static
name|void
name|insert_phi_nodes
parameter_list|(
name|bitmap
modifier|*
name|dfs
parameter_list|)
block|{
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_INSERT_PHI_NODES
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
block|{
name|struct
name|def_blocks_d
modifier|*
name|def_map
decl_stmt|;
name|bitmap
name|idf
decl_stmt|;
name|def_map
operator|=
name|find_def_blocks_for
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_map
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|get_phi_state
argument_list|(
name|var
argument_list|)
operator|!=
name|NEED_PHI_STATE_NO
condition|)
block|{
name|idf
operator|=
name|find_idf
argument_list|(
name|def_map
operator|->
name|def_blocks
argument_list|,
name|dfs
argument_list|)
expr_stmt|;
name|insert_phi_nodes_for
argument_list|(
name|var
argument_list|,
name|idf
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|idf
argument_list|)
expr_stmt|;
block|}
block|}
name|timevar_pop
argument_list|(
name|TV_TREE_INSERT_PHI_NODES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register DEF (an SSA_NAME) to be a new definition for its underlying    variable (SSA_NAME_VAR (DEF)) and push VAR's current reaching definition    into the stack pointed to by BLOCK_DEFS_P.  */
end_comment

begin_decl_stmt
name|void
name|register_new_def
argument_list|(
name|tree
name|def
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|block_defs_p
argument_list|)
block|{
name|tree
name|var
init|=
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|tree
name|currdef
decl_stmt|;
comment|/* If this variable is set in a single basic block and all uses are      dominated by the set(s) in that single basic block, then there is      no reason to record anything for this variable in the block local      definition stacks.  Doing so just wastes time and memory.       This is the same test to prune the set of variables which may      need PHI nodes.  So we just use that information since it's already      computed and available for us to use.  */
if|if
condition|(
name|get_phi_state
argument_list|(
name|var
argument_list|)
operator|==
name|NEED_PHI_STATE_NO
condition|)
block|{
name|set_current_def
argument_list|(
name|var
argument_list|,
name|def
argument_list|)
expr_stmt|;
return|return;
block|}
name|currdef
operator|=
name|get_current_def
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is      later used by the dominator tree callbacks to restore the reaching      definitions for all the variables defined in the block after a recursive      visit to all its immediately dominated blocks.  If there is no current      reaching definition, then just record the underlying _DECL node.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|block_defs_p
argument_list|,
name|currdef
condition|?
name|currdef
else|:
name|var
argument_list|)
expr_stmt|;
comment|/* Set the current reaching definition for VAR to be DEF.  */
name|set_current_def
argument_list|(
name|var
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Perform a depth-first traversal of the dominator tree looking for    variables to rename.  BB is the block where to start searching.    Renaming is a five step process:     1- Every definition made by PHI nodes at the start of the blocks is       registered as the current definition for the corresponding variable.     2- Every statement in BB is rewritten.  USE and VUSE operands are       rewritten with their corresponding reaching definition.  DEF and       VDEF targets are registered as new definitions.           3- All the PHI nodes in successor blocks of BB are visited.  The       argument corresponding to BB is replaced with its current reaching       definition.     4- Recursively rewrite every dominator child block of BB.     5- Restore (in reverse order) the current reaching definition for every       new definition introduced in this block.  This is done so that when       we return from the recursive call, all the current reaching       definitions are restored to the names that were valid in the       dominator parent of BB.  */
end_comment

begin_comment
comment|/* SSA Rewriting Step 1.  Initialization, create a block local stack    of reaching definitions for new SSA names produced in this block    (BLOCK_DEFS).  Register new definitions for every PHI node in the    block.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_initialize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\nRenaming block #%d\n\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Mark the unwind point for this block.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|block_defs_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Step 1.  Register new definitions for every PHI node in the block.      Conceptually, all the PHI nodes are executed in parallel and each PHI      node introduces a new version for the associated variable.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|result
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|register_new_def
argument_list|(
name|result
argument_list|,
operator|&
name|block_defs_stack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the current definition for variable VAR.  If none is found,    create a new SSA name to act as the zeroth definition for VAR.  If VAR    is call clobbered and there exists a more recent definition of    GLOBAL_VAR, return the definition for GLOBAL_VAR.  This means that VAR    has been clobbered by a function call since its last assignment.  */
end_comment

begin_function
specifier|static
name|tree
name|get_reaching_def
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|tree
name|currdef_var
decl_stmt|,
name|avar
decl_stmt|;
comment|/* Lookup the current reaching definition for VAR.  */
name|currdef_var
operator|=
name|get_current_def
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* If there is no reaching definition for VAR, create and register a      default definition for it (if needed).  */
if|if
condition|(
name|currdef_var
operator|==
name|NULL_TREE
condition|)
block|{
name|avar
operator|=
name|DECL_P
argument_list|(
name|var
argument_list|)
condition|?
name|var
else|:
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|currdef_var
operator|=
name|get_default_def_for
argument_list|(
name|avar
argument_list|)
expr_stmt|;
name|set_current_def
argument_list|(
name|var
argument_list|,
name|currdef_var
argument_list|)
expr_stmt|;
block|}
comment|/* Return the current reaching definition for VAR, or the default      definition, if we had to create one.  */
return|return
name|currdef_var
return|;
block|}
end_function

begin_comment
comment|/* SSA Rewriting Step 2.  Rewrite every variable used in each statement in    the block with its immediate reaching definitions.  Update the current    definition of a variable when a new real or virtual definition is found.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|block_stmt_iterator
name|si
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
comment|/* If mark_def_sites decided that we don't need to rewrite this      statement, ignore it.  */
name|gcc_assert
argument_list|(
name|blocks_to_update
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|&&
operator|!
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Renaming statement "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Step 1.  Rewrite USES and VUSES in the statement.  */
if|if
condition|(
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_USES|SSA_OP_ALL_KILLS
argument_list|)
block|{
name|tree
name|var
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|get_reaching_def
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Step 2.  Register the statement's DEF and VDEF operands.  */
if|if
condition|(
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_ALL_DEFS
argument_list|)
block|{
name|tree
name|var
init|=
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|SET_DEF
argument_list|(
name|def_p
argument_list|,
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|register_new_def
argument_list|(
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
argument_list|,
operator|&
name|block_defs_stack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* SSA Rewriting Step 3.  Visit all the successor blocks of BB looking for    PHI nodes.  For every PHI node found, add a new argument containing the    current reaching definition for the variable and the edge through which    that definition is reaching the PHI node.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_add_phi_arguments
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|currdef
decl_stmt|;
name|currdef
operator|=
name|get_reaching_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|currdef
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called after visiting basic block BB.  Restore CURRDEFS to its    original value.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_finalize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Restore CURRDEFS to its original state.  */
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|block_defs_stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|tmp
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|block_defs_stack
argument_list|)
decl_stmt|;
name|tree
name|saved_def
decl_stmt|,
name|var
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL_TREE
condition|)
break|break;
comment|/* If we recorded an SSA_NAME, then make the SSA_NAME the current 	 definition of its underlying variable.  If we recorded anything 	 else, it must have been an _DECL node and its current reaching 	 definition must have been NULL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|saved_def
operator|=
name|tmp
expr_stmt|;
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|saved_def
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|saved_def
operator|=
name|NULL
expr_stmt|;
name|var
operator|=
name|tmp
expr_stmt|;
block|}
name|set_current_def
argument_list|(
name|var
argument_list|,
name|saved_def
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump SSA information to FILE.  */
end_comment

begin_function
name|void
name|dump_tree_ssa
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
specifier|const
name|char
modifier|*
name|funcname
init|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"SSA information for %s\n\n"
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"    "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|file
argument_list|,
name|phi_nodes
argument_list|(
name|bb
argument_list|)
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump SSA information to stderr.  */
end_comment

begin_function
name|void
name|debug_tree_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_tree_ssa
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump statistics for the hash table HTAB.  */
end_comment

begin_function
specifier|static
name|void
name|htab_statistics
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|htab_t
name|htab
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"size %ld, %ld elements, %f collision/search ratio\n"
argument_list|,
operator|(
name|long
operator|)
name|htab_size
argument_list|(
name|htab
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|htab_elements
argument_list|(
name|htab
argument_list|)
argument_list|,
name|htab_collisions
argument_list|(
name|htab
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump SSA statistics on FILE.  */
end_comment

begin_function
name|void
name|dump_tree_ssa_stats
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nHash table statistics:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"    def_blocks: "
argument_list|)
expr_stmt|;
name|htab_statistics
argument_list|(
name|file
argument_list|,
name|def_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump SSA statistics on stderr.  */
end_comment

begin_function
name|void
name|debug_tree_ssa_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_tree_ssa_stats
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hashing and equality functions for DEF_BLOCKS.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|def_blocks_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|htab_hash_pointer
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
operator|(
specifier|const
expr|struct
name|def_blocks_d
operator|*
operator|)
name|p
operator|)
operator|->
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|def_blocks_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
expr|struct
name|def_blocks_d
operator|*
operator|)
name|p1
operator|)
operator|->
name|var
operator|==
operator|(
operator|(
specifier|const
expr|struct
name|def_blocks_d
operator|*
operator|)
name|p2
operator|)
operator|->
name|var
return|;
block|}
end_function

begin_comment
comment|/* Free memory allocated by one entry in DEF_BLOCKS.  */
end_comment

begin_function
specifier|static
name|void
name|def_blocks_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|def_blocks_d
modifier|*
name|entry
init|=
operator|(
expr|struct
name|def_blocks_d
operator|*
operator|)
name|p
decl_stmt|;
name|BITMAP_FREE
argument_list|(
name|entry
operator|->
name|def_blocks
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|entry
operator|->
name|phi_blocks
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|entry
operator|->
name|livein_blocks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback for htab_traverse to dump the DEF_BLOCKS hash table.  */
end_comment

begin_function
specifier|static
name|int
name|debug_def_blocks_r
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|def_blocks_d
modifier|*
name|db_p
init|=
operator|(
expr|struct
name|def_blocks_d
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"VAR: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
name|db_p
operator|->
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|bitmap_print
argument_list|(
name|stderr
argument_list|,
name|db_p
operator|->
name|def_blocks
argument_list|,
literal|", DEF_BLOCKS: { "
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|bitmap_print
argument_list|(
name|stderr
argument_list|,
name|db_p
operator|->
name|livein_blocks
argument_list|,
literal|", LIVEIN_BLOCKS: { "
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dump the DEF_BLOCKS hash table on stderr.  */
end_comment

begin_function
name|void
name|debug_def_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_traverse
argument_list|(
name|def_blocks
argument_list|,
name|debug_def_blocks_r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register NEW_NAME to be the new reaching definition for OLD_NAME.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|register_new_update_single
parameter_list|(
name|tree
name|new_name
parameter_list|,
name|tree
name|old_name
parameter_list|)
block|{
name|tree
name|currdef
init|=
name|get_current_def
argument_list|(
name|old_name
argument_list|)
decl_stmt|;
comment|/* Push the current reaching definition into *BLOCK_DEFS_P.      This stack is later used by the dominator tree callbacks to      restore the reaching definitions for all the variables      defined in the block after a recursive visit to all its      immediately dominated blocks.  */
name|VEC_reserve
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|block_defs_stack
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|block_defs_stack
argument_list|,
name|currdef
argument_list|)
expr_stmt|;
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
name|block_defs_stack
argument_list|,
name|old_name
argument_list|)
expr_stmt|;
comment|/* Set the current reaching definition for OLD_NAME to be      NEW_NAME.  */
name|set_current_def
argument_list|(
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register NEW_NAME to be the new reaching definition for all the    names in OLD_NAMES.  Used by the incremental SSA update routines to    replace old SSA names with new ones.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|register_new_update_set
parameter_list|(
name|tree
name|new_name
parameter_list|,
name|bitmap
name|old_names
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|old_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|register_new_update_single
argument_list|(
name|new_name
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization of block data structures for the incremental SSA    update pass.  Create a block local stack of reaching definitions    for new SSA names produced in this block (BLOCK_DEFS).  Register    new definitions for every PHI node in the block.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_update_init_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|bool
name|is_abnormal_phi
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\nRegistering new PHI nodes in block #%d\n\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Mark the unwind point for this block.  */
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|block_defs_stack
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|blocks_to_update
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
return|return;
comment|/* Mark the LHS if any of the arguments flows through an abnormal      edge.  */
name|is_abnormal_phi
operator|=
name|false
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|is_abnormal_phi
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* If any of the PHI nodes is a replacement for a name in      OLD_SSA_NAMES or it's one of the names in NEW_SSA_NAMES, then      register it as a new definition for its corresponding name.  Also      register definitions for names whose underlying symbols are      marked for renaming.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|lhs
decl_stmt|,
name|lhs_sym
decl_stmt|;
if|if
condition|(
operator|!
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|phi
argument_list|)
condition|)
continue|continue;
name|lhs
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|lhs_sym
operator|=
name|SSA_NAME_VAR
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|lhs_sym
argument_list|)
condition|)
name|register_new_update_single
argument_list|(
name|lhs
argument_list|,
name|lhs_sym
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If LHS is a new name, register a new definition for all 	     the names replaced by LHS.  */
if|if
condition|(
name|is_new_name
argument_list|(
name|lhs
argument_list|)
condition|)
name|register_new_update_set
argument_list|(
name|lhs
argument_list|,
name|names_replaced_by
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If LHS is an OLD name, register it as a new definition 	     for itself.  */
if|if
condition|(
name|is_old_name
argument_list|(
name|lhs
argument_list|)
condition|)
name|register_new_update_single
argument_list|(
name|lhs
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_abnormal_phi
condition|)
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|lhs
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called after visiting block BB.  Unwind BLOCK_DEFS_STACK to restore    the current reaching definition of every name re-written in BB to    the original reaching definition before visiting BB.  This    unwinding must be done in the opposite order to what is done in    register_new_update_set.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_update_fini_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
while|while
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|block_defs_stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|var
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|block_defs_stack
argument_list|)
decl_stmt|;
name|tree
name|saved_def
decl_stmt|;
comment|/* NULL indicates the unwind stop point for this block (see 	 rewrite_update_init_block).  */
if|if
condition|(
name|var
operator|==
name|NULL
condition|)
return|return;
name|saved_def
operator|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|block_defs_stack
argument_list|)
expr_stmt|;
name|set_current_def
argument_list|(
name|var
argument_list|,
name|saved_def
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the operand pointed to by USE_P is a name in OLD_SSA_NAMES or    it is a symbol marked for renaming, replace it with USE_P's current    reaching definition.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|maybe_replace_use
parameter_list|(
name|use_operand_p
name|use_p
parameter_list|)
block|{
name|tree
name|rdef
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|use
argument_list|)
condition|?
name|use
else|:
name|SSA_NAME_VAR
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|sym
argument_list|)
condition|)
name|rdef
operator|=
name|get_reaching_def
argument_list|(
name|sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_old_name
argument_list|(
name|use
argument_list|)
condition|)
name|rdef
operator|=
name|get_reaching_def
argument_list|(
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdef
operator|&&
name|rdef
operator|!=
name|use
condition|)
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|rdef
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the operand pointed to by DEF_P is an SSA name in NEW_SSA_NAMES    or OLD_SSA_NAMES, or if it is a symbol marked for renaming,    register it as the current definition for the names replaced by    DEF_P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|maybe_register_def
parameter_list|(
name|def_operand_p
name|def_p
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
name|tree
name|def
init|=
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
decl_stmt|;
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|def
argument_list|)
condition|?
name|def
else|:
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
decl_stmt|;
comment|/* If DEF is a naked symbol that needs renaming, create a      new name for it.  */
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|sym
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
name|def
argument_list|)
condition|)
block|{
name|def
operator|=
name|make_ssa_name
argument_list|(
name|def
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|SET_DEF
argument_list|(
name|def_p
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
name|register_new_update_single
argument_list|(
name|def
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If DEF is a new name, register it as a new definition 	 for all the names replaced by DEF.  */
if|if
condition|(
name|is_new_name
argument_list|(
name|def
argument_list|)
condition|)
name|register_new_update_set
argument_list|(
name|def
argument_list|,
name|names_replaced_by
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If DEF is an old name, register DEF as a new 	 definition for itself.  */
if|if
condition|(
name|is_old_name
argument_list|(
name|def
argument_list|)
condition|)
name|register_new_update_single
argument_list|(
name|def
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update every variable used in the statement pointed-to by SI.  The    statement is assumed to be in SSA form already.  Names in    OLD_SSA_NAMES used by SI will be updated to their current reaching    definition.  Names in OLD_SSA_NAMES or NEW_SSA_NAMES defined by SI    will be registered as a new definition for their corresponding name    in OLD_SSA_NAMES.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_update_stmt
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|,
name|block_stmt_iterator
name|si
parameter_list|)
block|{
name|stmt_ann_t
name|ann
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bitmap_bit_p
argument_list|(
name|blocks_to_update
argument_list|,
name|bb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only update marked statements.  */
if|if
condition|(
operator|!
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|&&
operator|!
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Updating SSA information for statement "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Rewrite USES included in OLD_SSA_NAMES and USES whose underlying      symbol is marked for renaming.  */
if|if
condition|(
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
name|maybe_replace_use
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_to_update_vops_p
condition|)
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_USES | SSA_OP_VIRTUAL_KILLS
argument_list|)
name|maybe_replace_use
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
block|}
comment|/* Register definitions of names in NEW_SSA_NAMES and OLD_SSA_NAMES.      Also register definitions for names whose underlying symbol is      marked for renaming.  */
if|if
condition|(
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
name|maybe_register_def
argument_list|(
name|def_p
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_to_update_vops_p
condition|)
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
name|maybe_register_def
argument_list|(
name|def_p
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Replace the operand pointed to by USE_P with USE's current reaching    definition.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|replace_use
parameter_list|(
name|use_operand_p
name|use_p
parameter_list|,
name|tree
name|use
parameter_list|)
block|{
name|tree
name|rdef
init|=
name|get_reaching_def
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
name|rdef
operator|!=
name|use
condition|)
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|rdef
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Visit all the successor blocks of BB looking for PHI nodes.  For    every PHI node found, check if any of its arguments is in    OLD_SSA_NAMES.  If so, and if the argument has a current reaching    definition, replace it.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_update_phi_arguments
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|tree_vec
name|phis
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|blocks_with_phis_to_rewrite
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
condition|)
continue|continue;
name|phis
operator|=
name|VEC_index
argument_list|(
name|tree_vec
argument_list|,
name|phis_to_rewrite
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|phis
argument_list|,
name|i
argument_list|,
name|phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
decl_stmt|;
name|use_operand_p
name|arg_p
decl_stmt|;
name|gcc_assert
argument_list|(
name|REWRITE_THIS_STMT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
name|arg_p
operator|=
name|PHI_ARG_DEF_PTR_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|arg
operator|=
name|USE_FROM_PTR
argument_list|(
name|arg_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|!
name|DECL_P
argument_list|(
name|arg
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* When updating a PHI node for a recently introduced 		 symbol we may find NULL arguments.  That's why we 		 take the symbol from the LHS of the PHI node.  */
name|replace_use
argument_list|(
name|arg_p
argument_list|,
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|arg
argument_list|)
condition|?
name|arg
else|:
name|SSA_NAME_VAR
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|sym
argument_list|)
condition|)
name|replace_use
argument_list|(
name|arg_p
argument_list|,
name|sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_old_name
argument_list|(
name|arg
argument_list|)
condition|)
name|replace_use
argument_list|(
name|arg_p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|USE_FROM_PTR
argument_list|(
name|arg_p
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Rewrite the actual blocks, statements, and PHI arguments, to be in SSA    form.       ENTRY indicates the block where to start.  Every block dominated by       ENTRY will be rewritten.     WHAT indicates what actions will be taken by the renamer (see enum       rewrite_mode).     BLOCKS are the set of interesting blocks for the dominator walker       to process.  If this set is NULL, then all the nodes dominated       by ENTRY are walked.  Otherwise, blocks dominated by ENTRY that       are not present in BLOCKS are ignored.  */
end_comment

begin_function
specifier|static
name|void
name|rewrite_blocks
parameter_list|(
name|basic_block
name|entry
parameter_list|,
name|enum
name|rewrite_mode
name|what
parameter_list|,
name|sbitmap
name|blocks
parameter_list|)
block|{
name|struct
name|dom_walk_data
name|walk_data
decl_stmt|;
comment|/* Rewrite all the basic blocks in the program.  */
name|timevar_push
argument_list|(
name|TV_TREE_SSA_REWRITE_BLOCKS
argument_list|)
expr_stmt|;
comment|/* Setup callbacks for the generic dominator tree walker.  */
name|memset
argument_list|(
operator|&
name|walk_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|walk_data
argument_list|)
argument_list|)
expr_stmt|;
name|walk_data
operator|.
name|dom_direction
operator|=
name|CDI_DOMINATORS
expr_stmt|;
name|walk_data
operator|.
name|interesting_blocks
operator|=
name|blocks
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|REWRITE_UPDATE
condition|)
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|rewrite_update_init_block
expr_stmt|;
else|else
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|rewrite_initialize_block
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|REWRITE_ALL
condition|)
name|walk_data
operator|.
name|before_dom_children_walk_stmts
operator|=
name|rewrite_stmt
expr_stmt|;
elseif|else
if|if
condition|(
name|what
operator|==
name|REWRITE_UPDATE
condition|)
name|walk_data
operator|.
name|before_dom_children_walk_stmts
operator|=
name|rewrite_update_stmt
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|REWRITE_ALL
condition|)
name|walk_data
operator|.
name|before_dom_children_after_stmts
operator|=
name|rewrite_add_phi_arguments
expr_stmt|;
elseif|else
if|if
condition|(
name|what
operator|==
name|REWRITE_UPDATE
condition|)
name|walk_data
operator|.
name|before_dom_children_after_stmts
operator|=
name|rewrite_update_phi_arguments
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|REWRITE_ALL
condition|)
name|walk_data
operator|.
name|after_dom_children_after_stmts
operator|=
name|rewrite_finalize_block
expr_stmt|;
elseif|else
if|if
condition|(
name|what
operator|==
name|REWRITE_UPDATE
condition|)
name|walk_data
operator|.
name|after_dom_children_after_stmts
operator|=
name|rewrite_update_fini_block
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|block_defs_stack
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Initialize the dominator walker.  */
name|init_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* Recursively walk the dominator tree rewriting each statement in      each basic block.  */
name|walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* Finalize the dominator walker.  */
name|fini_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* Debugging dumps.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
block|{
name|dump_dfa_stats
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_blocks
condition|)
name|dump_tree_ssa_stats
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|def_blocks
condition|)
block|{
name|htab_delete
argument_list|(
name|def_blocks
argument_list|)
expr_stmt|;
name|def_blocks
operator|=
name|NULL
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|block_defs_stack
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_SSA_REWRITE_BLOCKS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Block initialization routine for mark_def_sites.  Clear the     KILLS bitmap at the start of each block.  */
end_comment

begin_function
specifier|static
name|void
name|mark_def_sites_initialize_block
parameter_list|(
name|struct
name|dom_walk_data
modifier|*
name|walk_data
parameter_list|,
name|basic_block
name|bb
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|mark_def_sites_global_data
modifier|*
name|gd
init|=
operator|(
expr|struct
name|mark_def_sites_global_data
operator|*
operator|)
name|walk_data
operator|->
name|global_data
decl_stmt|;
name|bitmap
name|kills
init|=
name|gd
operator|->
name|kills
decl_stmt|;
name|bitmap_clear
argument_list|(
name|kills
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the definition site blocks for each variable, so that we know    where the variable is actually live.     INTERESTING_BLOCKS will be filled in with all the blocks that       should be processed by the renamer.  It is assumed to be       initialized and zeroed by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|mark_def_site_blocks
parameter_list|(
name|sbitmap
name|interesting_blocks
parameter_list|)
block|{
name|struct
name|dom_walk_data
name|walk_data
decl_stmt|;
name|struct
name|mark_def_sites_global_data
name|mark_def_sites_global_data
decl_stmt|;
name|referenced_var_iterator
name|rvi
decl_stmt|;
name|tree
name|var
decl_stmt|;
comment|/* Allocate memory for the DEF_BLOCKS hash table.  */
name|def_blocks
operator|=
name|htab_create
argument_list|(
name|num_referenced_vars
argument_list|,
name|def_blocks_hash
argument_list|,
name|def_blocks_eq
argument_list|,
name|def_blocks_free
argument_list|)
expr_stmt|;
name|FOR_EACH_REFERENCED_VAR
argument_list|(
argument|var
argument_list|,
argument|rvi
argument_list|)
name|set_current_def
argument_list|(
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Setup callbacks for the generic dominator tree walker to find and      mark definition sites.  */
name|walk_data
operator|.
name|walk_stmts_backward
operator|=
name|false
expr_stmt|;
name|walk_data
operator|.
name|dom_direction
operator|=
name|CDI_DOMINATORS
expr_stmt|;
name|walk_data
operator|.
name|initialize_block_local_data
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_before_stmts
operator|=
name|mark_def_sites_initialize_block
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_walk_stmts
operator|=
name|mark_def_sites
expr_stmt|;
name|walk_data
operator|.
name|before_dom_children_after_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_before_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_walk_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|after_dom_children_after_stmts
operator|=
name|NULL
expr_stmt|;
name|walk_data
operator|.
name|interesting_blocks
operator|=
name|NULL
expr_stmt|;
comment|/* Notice that this bitmap is indexed using variable UIDs, so it must be      large enough to accommodate all the variables referenced in the      function, not just the ones we are renaming.  */
name|mark_def_sites_global_data
operator|.
name|kills
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create the set of interesting blocks that will be filled by      mark_def_sites.  */
name|mark_def_sites_global_data
operator|.
name|interesting_blocks
operator|=
name|interesting_blocks
expr_stmt|;
name|walk_data
operator|.
name|global_data
operator|=
operator|&
name|mark_def_sites_global_data
expr_stmt|;
comment|/* We do not have any local data.  */
name|walk_data
operator|.
name|block_local_data_size
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the dominator walker.  */
name|init_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* Recursively walk the dominator tree.  */
name|walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|,
name|ENTRY_BLOCK_PTR
argument_list|)
expr_stmt|;
comment|/* Finalize the dominator walker.  */
name|fini_walk_dominator_tree
argument_list|(
operator|&
name|walk_data
argument_list|)
expr_stmt|;
comment|/* We no longer need this bitmap, clear and free it.  */
name|BITMAP_FREE
argument_list|(
name|mark_def_sites_global_data
operator|.
name|kills
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Main entry point into the SSA builder.  The renaming process    proceeds in four main phases:     1- Compute dominance frontier and immediate dominators, needed to       insert PHI nodes and rename the function in dominator tree       order.     2- Find and mark all the blocks that define variables       (mark_def_site_blocks).     3- Insert PHI nodes at dominance frontiers (insert_phi_nodes).     4- Rename all the blocks (rewrite_blocks) and statements in the program.     Steps 3 and 4 are done using the dominator tree walker    (walk_dominator_tree).  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|rewrite_into_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap
modifier|*
name|dfs
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|sbitmap
name|interesting_blocks
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_SSA_OTHER
argument_list|)
expr_stmt|;
comment|/* Initialize operand data structures.  */
name|init_ssa_operands
argument_list|()
expr_stmt|;
comment|/* Initialize the set of interesting blocks.  The callback      mark_def_sites will add to this set those blocks that the renamer      should process.  */
name|interesting_blocks
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|interesting_blocks
argument_list|)
expr_stmt|;
comment|/* Initialize dominance frontier.  */
name|dfs
operator|=
operator|(
name|bitmap
operator|*
operator|)
name|xmalloc
argument_list|(
name|last_basic_block
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|dfs
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* 1- Compute dominance frontiers.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|compute_dominance_frontiers
argument_list|(
name|dfs
argument_list|)
expr_stmt|;
comment|/* 2- Find and mark definition sites.  */
name|mark_def_site_blocks
argument_list|(
name|interesting_blocks
argument_list|)
expr_stmt|;
comment|/* 3- Insert PHI nodes at dominance frontiers of definition blocks.  */
name|insert_phi_nodes
argument_list|(
name|dfs
argument_list|)
expr_stmt|;
comment|/* 4- Rename all the blocks.  */
name|rewrite_blocks
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|REWRITE_ALL
argument_list|,
name|interesting_blocks
argument_list|)
expr_stmt|;
comment|/* Free allocated memory.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|BITMAP_FREE
argument_list|(
name|dfs
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dfs
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|interesting_blocks
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_SSA_OTHER
argument_list|)
expr_stmt|;
name|in_ssa_p
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_build_ssa
init|=
block|{
literal|"ssa"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|rewrite_into_ssa
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_referenced_vars
block|,
comment|/* properties_required */
name|PROP_ssa
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_ssa
operator||
name|TODO_remove_unused_locals
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark the definition of VAR at STMT and BB as interesting for the    renamer.  BLOCKS is the set of blocks that need updating.  */
end_comment

begin_function
specifier|static
name|void
name|mark_def_interesting
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|bool
name|insert_phi_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|bitmap_bit_p
argument_list|(
name|blocks_to_update
argument_list|,
name|bb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|REGISTER_DEFS_IN_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insert_phi_p
condition|)
block|{
name|bool
name|is_phi_p
init|=
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
decl_stmt|;
name|set_def_block
argument_list|(
name|var
argument_list|,
name|bb
argument_list|,
name|is_phi_p
argument_list|)
expr_stmt|;
comment|/* If VAR is an SSA name in NEW_SSA_NAMES, this is a definition 	 site for both itself and all the old names replaced by it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|is_new_name
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bitmap
name|set
init|=
name|names_replaced_by
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|set_def_block
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|bb
argument_list|,
name|is_phi_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark the use of VAR at STMT and BB as interesting for the    renamer.  INSERT_PHI_P is true if we are going to insert new PHI    nodes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mark_use_interesting
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|bool
name|insert_phi_p
parameter_list|)
block|{
name|basic_block
name|def_bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|mark_block_for_update
argument_list|(
name|def_bb
argument_list|)
expr_stmt|;
name|mark_block_for_update
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
name|mark_phi_for_rewrite
argument_list|(
name|def_bb
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
else|else
name|REWRITE_THIS_STMT
argument_list|(
name|stmt
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If VAR has not been defined in BB, then it is live-on-entry      to BB.  Note that we cannot just use the block holding VAR's      definition because if VAR is one of the names in OLD_SSA_NAMES,      it will have several definitions (itself and all the names that      replace it).  */
if|if
condition|(
name|insert_phi_p
condition|)
block|{
name|struct
name|def_blocks_d
modifier|*
name|db_p
init|=
name|get_def_blocks_for
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|db_p
operator|->
name|def_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
name|set_livein_block
argument_list|(
name|var
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do a dominator walk starting at BB processing statements that    reference symbols in SYMS_TO_RENAME.  This is very similar to    mark_def_sites, but the scan handles statements whose operands may    already be SSA names.     If INSERT_PHI_P is true, mark those uses as live in the    corresponding block.  This is later used by the PHI placement    algorithm to make PHI pruning decisions.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_block_for_update
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bool
name|insert_phi_p
parameter_list|)
block|{
name|basic_block
name|son
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|mark_block_for_update
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Process PHI nodes marking interesting those that define or use      the symbols that we are interested in.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|tree
name|lhs_sym
decl_stmt|,
name|lhs
init|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|lhs_sym
operator|=
name|DECL_P
argument_list|(
name|lhs
argument_list|)
condition|?
name|lhs
else|:
name|SSA_NAME_VAR
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbol_marked_for_renaming
argument_list|(
name|lhs_sym
argument_list|)
condition|)
continue|continue;
name|mark_def_interesting
argument_list|(
name|lhs_sym
argument_list|,
name|phi
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
comment|/* Mark the uses in phi nodes as interesting.  It would be more correct 	 to process the arguments of the phi nodes of the successor edges of 	 BB at the end of prepare_block_for_update, however, that turns out 	 to be significantly more expensive.  Doing it here is conservatively 	 correct -- it may only cause us to believe a value to be live in a 	 block that also contains its definition, and thus insert a few more 	 phi nodes for it.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|mark_use_interesting
argument_list|(
name|lhs_sym
argument_list|,
name|phi
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the statements.  */
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
decl_stmt|;
name|ssa_op_iter
name|i
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|def_operand_p
name|def_p
decl_stmt|;
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|use
argument_list|)
condition|?
name|use
else|:
name|SSA_NAME_VAR
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|sym
argument_list|)
condition|)
name|mark_use_interesting
argument_list|(
name|use
argument_list|,
name|stmt
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|tree
name|def
init|=
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
decl_stmt|;
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|def
argument_list|)
condition|?
name|def
else|:
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|sym
argument_list|)
condition|)
name|mark_def_interesting
argument_list|(
name|def
argument_list|,
name|stmt
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_SSA_DEF_OPERAND
argument_list|(
argument|def_p
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
block|{
name|tree
name|def
init|=
name|DEF_FROM_PTR
argument_list|(
name|def_p
argument_list|)
decl_stmt|;
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|def
argument_list|)
condition|?
name|def
else|:
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|mark_use_interesting
argument_list|(
name|sym
argument_list|,
name|stmt
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
name|mark_def_interesting
argument_list|(
name|sym
argument_list|,
name|stmt
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
block|}
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|i
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
block|{
name|tree
name|use
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|tree
name|sym
init|=
name|DECL_P
argument_list|(
name|use
argument_list|)
condition|?
name|use
else|:
name|SSA_NAME_VAR
argument_list|(
name|use
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_marked_for_renaming
argument_list|(
name|sym
argument_list|)
condition|)
name|mark_use_interesting
argument_list|(
name|sym
argument_list|,
name|stmt
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now visit all the blocks dominated by BB.  */
for|for
control|(
name|son
operator|=
name|first_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
init|;
name|son
condition|;
name|son
operator|=
name|next_dom_son
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|son
argument_list|)
control|)
name|prepare_block_for_update
argument_list|(
name|son
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for prepare_names_to_update.  Mark all the use sites for    NAME as interesting.  BLOCKS and INSERT_PHI_P are as in    prepare_names_to_update.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_use_sites_for
parameter_list|(
name|tree
name|name
parameter_list|,
name|bool
name|insert_phi_p
parameter_list|)
block|{
name|use_operand_p
name|use_p
decl_stmt|;
name|imm_use_iterator
name|iter
decl_stmt|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|iter
argument_list|,
argument|name
argument_list|)
block|{
name|tree
name|stmt
init|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|int
name|ix
init|=
name|PHI_ARG_INDEX_FROM_USE
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|stmt
argument_list|,
name|ix
argument_list|)
decl_stmt|;
name|mark_use_interesting
argument_list|(
name|name
argument_list|,
name|stmt
argument_list|,
name|e
operator|->
name|src
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For regular statements, mark this as an interesting use 	     for NAME.  */
name|mark_use_interesting
argument_list|(
name|name
argument_list|,
name|stmt
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper for prepare_names_to_update.  Mark the definition site for    NAME as interesting.  BLOCKS and INSERT_PHI_P are as in    prepare_names_to_update.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_def_site_for
parameter_list|(
name|tree
name|name
parameter_list|,
name|bool
name|insert_phi_p
parameter_list|)
block|{
name|tree
name|stmt
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|gcc_assert
argument_list|(
name|names_to_release
operator|==
name|NULL
operator|||
operator|!
name|bitmap_bit_p
argument_list|(
name|names_to_release
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
condition|)
block|{
name|gcc_assert
argument_list|(
name|bb
operator|->
name|index
operator|<
name|last_basic_block
argument_list|)
expr_stmt|;
name|mark_block_for_update
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|mark_def_interesting
argument_list|(
name|name
argument_list|,
name|stmt
argument_list|,
name|bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark definition and use sites of names in NEW_SSA_NAMES and    OLD_SSA_NAMES.  INSERT_PHI_P is true if the caller wants to insert    PHI nodes for newly created names.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_names_to_update
parameter_list|(
name|bool
name|insert_phi_p
parameter_list|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
comment|/* If a name N from NEW_SSA_NAMES is also marked to be released,      remove it from NEW_SSA_NAMES so that we don't try to visit its      defining basic block (which most likely doesn't exist).  Notice      that we cannot do the same with names in OLD_SSA_NAMES because we      want to replace existing instances.  */
if|if
condition|(
name|names_to_release
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|names_to_release
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|RESET_BIT
argument_list|(
name|new_ssa_names
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* First process names in NEW_SSA_NAMES.  Otherwise, uses of old      names may be considered to be live-in on blocks that contain      definitions for their replacements.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|new_ssa_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
name|prepare_def_site_for
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
comment|/* If an old name is in NAMES_TO_RELEASE, we cannot remove it from      OLD_SSA_NAMES, but we have to ignore its definition site.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|old_ssa_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
block|{
if|if
condition|(
name|names_to_release
operator|==
name|NULL
operator|||
operator|!
name|bitmap_bit_p
argument_list|(
name|names_to_release
argument_list|,
name|i
argument_list|)
condition|)
name|prepare_def_site_for
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
name|prepare_use_sites_for
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump all the names replaced by NAME to FILE.  */
end_comment

begin_function
name|void
name|dump_names_replaced_by
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap
name|old_set
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -> { "
argument_list|)
expr_stmt|;
name|old_set
operator|=
name|names_replaced_by
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|old_set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all the names replaced by NAME to stderr.  */
end_comment

begin_function
name|void
name|debug_names_replaced_by
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|dump_names_replaced_by
argument_list|(
name|stderr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump SSA update information to FILE.  */
end_comment

begin_function
name|void
name|dump_update_ssa
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
operator|!
name|need_ssa_update_p
argument_list|()
condition|)
return|return;
if|if
condition|(
name|new_ssa_names
operator|&&
name|sbitmap_first_set_bit
argument_list|(
name|new_ssa_names
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSSA replacement table\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"N_i -> { O_1 ... O_j } means that N_i replaces "
literal|"O_1, ..., O_j\n\n"
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|new_ssa_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
name|dump_names_replaced_by
argument_list|(
name|file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Number of virtual NEW -> OLD mappings: %7u\n"
argument_list|,
name|update_ssa_stats
operator|.
name|num_virtual_mappings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Number of real NEW -> OLD mappings:    %7u\n"
argument_list|,
name|update_ssa_stats
operator|.
name|num_total_mappings
operator|-
name|update_ssa_stats
operator|.
name|num_virtual_mappings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Number of total NEW -> OLD mappings:   %7u\n"
argument_list|,
name|update_ssa_stats
operator|.
name|num_total_mappings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nNumber of virtual symbols: %u\n"
argument_list|,
name|update_ssa_stats
operator|.
name|num_virtual_symbols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|syms_to_rename
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|syms_to_rename
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\nSymbols to be put in SSA form\n\n"
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|syms_to_rename
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|referenced_var
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|names_to_release
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|names_to_release
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\nSSA names to release after updating the SSA web\n\n"
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|names_to_release
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|print_generic_expr
argument_list|(
name|file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump SSA update information to stderr.  */
end_comment

begin_function
name|void
name|debug_update_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_update_ssa
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize data structures used for incremental SSA updates.  */
end_comment

begin_function
specifier|static
name|void
name|init_update_ssa
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Reserve more space than the current number of names.  The calls to      add_new_name_mapping are typically done after creating new SSA      names, so we'll need to reallocate these arrays.  */
name|old_ssa_names
operator|=
name|sbitmap_alloc
argument_list|(
name|num_ssa_names
operator|+
name|NAME_SETS_GROWTH_FACTOR
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|old_ssa_names
argument_list|)
expr_stmt|;
name|new_ssa_names
operator|=
name|sbitmap_alloc
argument_list|(
name|num_ssa_names
operator|+
name|NAME_SETS_GROWTH_FACTOR
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|new_ssa_names
argument_list|)
expr_stmt|;
name|repl_tbl
operator|=
name|htab_create
argument_list|(
literal|20
argument_list|,
name|repl_map_hash
argument_list|,
name|repl_map_eq
argument_list|,
name|repl_map_free
argument_list|)
expr_stmt|;
name|need_to_initialize_update_ssa_p
operator|=
name|false
expr_stmt|;
name|need_to_update_vops_p
operator|=
name|false
expr_stmt|;
name|syms_to_rename
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|names_to_release
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|update_ssa_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|update_ssa_stats
argument_list|)
argument_list|)
expr_stmt|;
name|update_ssa_stats
operator|.
name|virtual_symbols
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deallocate data structures used for incremental SSA updates.  */
end_comment

begin_function
name|void
name|delete_update_ssa
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|sbitmap_free
argument_list|(
name|old_ssa_names
argument_list|)
expr_stmt|;
name|old_ssa_names
operator|=
name|NULL
expr_stmt|;
name|sbitmap_free
argument_list|(
name|new_ssa_names
argument_list|)
expr_stmt|;
name|new_ssa_names
operator|=
name|NULL
expr_stmt|;
name|htab_delete
argument_list|(
name|repl_tbl
argument_list|)
expr_stmt|;
name|repl_tbl
operator|=
name|NULL
expr_stmt|;
name|need_to_initialize_update_ssa_p
operator|=
name|true
expr_stmt|;
name|need_to_update_vops_p
operator|=
name|false
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|syms_to_rename
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|update_ssa_stats
operator|.
name|virtual_symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|names_to_release
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|names_to_release
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|release_ssa_name
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|names_to_release
argument_list|)
expr_stmt|;
block|}
name|clear_ssa_name_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new name for OLD_NAME in statement STMT and replace the    operand pointed to by DEF_P with the newly created name.  Return    the new name and register the replacement mapping<NEW, OLD> in    update_ssa's tables.  */
end_comment

begin_function
name|tree
name|create_new_def_for
parameter_list|(
name|tree
name|old_name
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|def_operand_p
name|def
parameter_list|)
block|{
name|tree
name|new_name
init|=
name|duplicate_ssa_name
argument_list|(
name|old_name
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|SET_DEF
argument_list|(
name|def
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* If needed, mark NEW_NAME as occurring in an abnormal PHI node. */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|new_name
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|register_new_name_mapping
argument_list|(
name|new_name
argument_list|,
name|old_name
argument_list|)
expr_stmt|;
comment|/* For the benefit of passes that will be updating the SSA form on      their own, set the current reaching definition of OLD_NAME to be      NEW_NAME.  */
name|set_current_def
argument_list|(
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
return|return
name|new_name
return|;
block|}
end_function

begin_comment
comment|/* Register name NEW to be a replacement for name OLD.  This function    must be called for every replacement that should be performed by    update_ssa.  */
end_comment

begin_function
name|void
name|register_new_name_mapping
parameter_list|(
name|tree
name|new
parameter_list|,
name|tree
name|old
parameter_list|)
block|{
if|if
condition|(
name|need_to_initialize_update_ssa_p
condition|)
name|init_update_ssa
argument_list|()
expr_stmt|;
name|add_new_name_mapping
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register symbol SYM to be renamed by update_ssa.  */
end_comment

begin_function
name|void
name|mark_sym_for_renaming
parameter_list|(
name|tree
name|sym
parameter_list|)
block|{
if|if
condition|(
name|need_to_initialize_update_ssa_p
condition|)
name|init_update_ssa
argument_list|()
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|syms_to_rename
argument_list|,
name|DECL_UID
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|sym
argument_list|)
condition|)
name|need_to_update_vops_p
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register all the symbols in SET to be renamed by update_ssa.  */
end_comment

begin_function
name|void
name|mark_set_for_renaming
parameter_list|(
name|bitmap
name|set
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|set
argument_list|)
condition|)
return|return;
if|if
condition|(
name|need_to_initialize_update_ssa_p
condition|)
name|init_update_ssa
argument_list|()
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|syms_to_rename
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|referenced_var
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|need_to_update_vops_p
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return true if there is any work to be done by update_ssa.  */
end_comment

begin_function
name|bool
name|need_ssa_update_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|syms_to_rename
operator|||
name|old_ssa_names
operator|||
name|new_ssa_names
return|;
block|}
end_function

begin_comment
comment|/* Return true if name N has been registered in the replacement table.  */
end_comment

begin_function
name|bool
name|name_registered_for_update_p
parameter_list|(
name|tree
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|need_ssa_update_p
argument_list|()
condition|)
return|return
name|false
return|;
return|return
name|is_new_name
argument_list|(
name|n
argument_list|)
operator|||
name|is_old_name
argument_list|(
name|n
argument_list|)
operator|||
name|symbol_marked_for_renaming
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the set of all the SSA names marked to be replaced.  */
end_comment

begin_function
name|bitmap
name|ssa_names_to_replace
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|bitmap
name|ret
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
name|ret
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|old_ssa_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
name|bitmap_set_bit
argument_list|(
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Mark NAME to be released after update_ssa has finished.  */
end_comment

begin_function
name|void
name|release_ssa_name_after_update_ssa
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|need_to_initialize_update_ssa_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|names_to_release
operator|==
name|NULL
condition|)
name|names_to_release
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|names_to_release
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert new PHI nodes to replace VAR.  DFS contains dominance    frontier information.  BLOCKS is the set of blocks to be updated.     This is slightly different than the regular PHI insertion    algorithm.  The value of UPDATE_FLAGS controls how PHI nodes for    real names (i.e., GIMPLE registers) are inserted:      - If UPDATE_FLAGS == TODO_update_ssa, we are only interested in PHI      nodes inside the region affected by the block that defines VAR      and the blocks that define all its replacements.  All these      definition blocks are stored in DEF_BLOCKS[VAR]->DEF_BLOCKS.       First, we compute the entry point to the region (ENTRY).  This is      given by the nearest common dominator to all the definition      blocks. When computing the iterated dominance frontier (IDF), any      block not strictly dominated by ENTRY is ignored.       We then call the standard PHI insertion algorithm with the pruned      IDF.     - If UPDATE_FLAGS == TODO_update_ssa_full_phi, the IDF for real      names is not pruned.  PHI nodes are inserted at every IDF block.  */
end_comment

begin_function
specifier|static
name|void
name|insert_updated_phi_nodes_for
parameter_list|(
name|tree
name|var
parameter_list|,
name|bitmap
modifier|*
name|dfs
parameter_list|,
name|bitmap
name|blocks
parameter_list|,
name|unsigned
name|update_flags
parameter_list|)
block|{
name|basic_block
name|entry
decl_stmt|;
name|struct
name|def_blocks_d
modifier|*
name|db
decl_stmt|;
name|bitmap
name|idf
decl_stmt|,
name|pruned_idf
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|#
directive|if
name|defined
name|ENABLE_CHECKING
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|gcc_assert
argument_list|(
name|is_old_name
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|symbol_marked_for_renaming
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get all the definition sites for VAR.  */
name|db
operator|=
name|find_def_blocks_for
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* No need to do anything if there were no definitions to VAR.  */
if|if
condition|(
name|db
operator|==
name|NULL
operator|||
name|bitmap_empty_p
argument_list|(
name|db
operator|->
name|def_blocks
argument_list|)
condition|)
return|return;
comment|/* Compute the initial iterated dominance frontier.  */
name|idf
operator|=
name|find_idf
argument_list|(
name|db
operator|->
name|def_blocks
argument_list|,
name|dfs
argument_list|)
expr_stmt|;
name|pruned_idf
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|update_flags
operator|==
name|TODO_update_ssa
condition|)
block|{
comment|/* If doing regular SSA updates for GIMPLE registers, we are 	     only interested in IDF blocks dominated by the nearest 	     common dominator of all the definition blocks.  */
name|entry
operator|=
name|nearest_common_dominator_for_set
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|db
operator|->
name|def_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|idf
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|!=
name|entry
operator|&&
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|,
name|entry
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|pruned_idf
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, do not prune the IDF for VAR.  */
name|gcc_assert
argument_list|(
name|update_flags
operator|==
name|TODO_update_ssa_full_phi
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|pruned_idf
argument_list|,
name|idf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise, VAR is a symbol that needs to be put into SSA form 	 for the first time, so we need to compute the full IDF for 	 it.  */
name|bitmap_copy
argument_list|(
name|pruned_idf
argument_list|,
name|idf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|pruned_idf
argument_list|)
condition|)
block|{
comment|/* Make sure that PRUNED_IDF blocks and all their feeding blocks 	 are included in the region to be updated.  The feeding blocks 	 are important to guarantee that the PHI arguments are renamed 	 properly.  */
name|bitmap_ior_into
argument_list|(
name|blocks
argument_list|,
name|pruned_idf
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|pruned_idf
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|>=
literal|0
condition|)
name|bitmap_set_bit
argument_list|(
name|blocks
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|insert_phi_nodes_for
argument_list|(
name|var
argument_list|,
name|pruned_idf
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|pruned_idf
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|idf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Heuristic to determine whether SSA name mappings for virtual names    should be discarded and their symbols rewritten from scratch.  When    there is a large number of mappings for virtual names, the    insertion of PHI nodes for the old names in the mappings takes    considerable more time than if we inserted PHI nodes for the    symbols instead.     Currently the heuristic takes these stats into account:     	- Number of mappings for virtual SSA names. 	- Number of distinct virtual symbols involved in those mappings.     If the number of virtual mappings is much larger than the number of    virtual symbols, then it will be faster to compute PHI insertion    spots for the symbols.  Even if this involves traversing the whole    CFG, which is what happens when symbols are renamed from scratch.  */
end_comment

begin_function
specifier|static
name|bool
name|switch_virtuals_to_full_rewrite_p
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|update_ssa_stats
operator|.
name|num_virtual_mappings
operator|<
operator|(
name|unsigned
operator|)
name|MIN_VIRTUAL_MAPPINGS
condition|)
return|return
name|false
return|;
if|if
condition|(
name|update_ssa_stats
operator|.
name|num_virtual_mappings
operator|>
operator|(
name|unsigned
operator|)
name|VIRTUAL_MAPPINGS_TO_SYMS_RATIO
operator|*
name|update_ssa_stats
operator|.
name|num_virtual_symbols
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Remove every virtual mapping and mark all the affected virtual    symbols for renaming.  */
end_comment

begin_function
specifier|static
name|void
name|switch_virtuals_to_full_rewrite
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nEnabled virtual name mapping heuristic.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\tNumber of virtual mappings:       %7u\n"
argument_list|,
name|update_ssa_stats
operator|.
name|num_virtual_mappings
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\tNumber of unique virtual symbols: %7u\n"
argument_list|,
name|update_ssa_stats
operator|.
name|num_virtual_symbols
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Updating FUD-chains from top of CFG will be "
literal|"faster than processing\nthe name mappings.\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Remove all virtual names from NEW_SSA_NAMES and OLD_SSA_NAMES.      Note that it is not really necessary to remove the mappings from      REPL_TBL, that would only waste time.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|new_ssa_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|RESET_BIT
argument_list|(
name|new_ssa_names
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|old_ssa_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|RESET_BIT
argument_list|(
name|old_ssa_names
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|syms_to_rename
argument_list|,
name|update_ssa_stats
operator|.
name|virtual_symbols
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a set of newly created SSA names (NEW_SSA_NAMES) and a set of    existing SSA names (OLD_SSA_NAMES), update the SSA form so that:     1- The names in OLD_SSA_NAMES dominated by the definitions of       NEW_SSA_NAMES are all re-written to be reached by the       appropriate definition from NEW_SSA_NAMES.     2- If needed, new PHI nodes are added to the iterated dominance       frontier of the blocks where each of NEW_SSA_NAMES are defined.     The mapping between OLD_SSA_NAMES and NEW_SSA_NAMES is setup by    calling register_new_name_mapping for every pair of names that the    caller wants to replace.     The caller identifies the new names that have been inserted and the    names that need to be replaced by calling register_new_name_mapping    for every pair<NEW, OLD>.  Note that the function assumes that the    new names have already been inserted in the IL.     For instance, given the following code:       1	L0:      2	x_1 = PHI (0, x_5)      3	if (x_1< 10)      4	  if (x_1> 7)      5	    y_2 = 0      6	  else      7	    y_3 = x_1 + x_7      8	  endif      9	  x_5 = x_1 + 1      10   goto L0;      11	endif     Suppose that we insert new names x_10 and x_11 (lines 4 and 8).       1	L0:      2	x_1 = PHI (0, x_5)      3	if (x_1< 10)      4	  x_10 = ...      5	  if (x_1> 7)      6	    y_2 = 0      7	  else      8	    x_11 = ...      9	    y_3 = x_1 + x_7      10	  endif      11	  x_5 = x_1 + 1      12	  goto L0;      13	endif     We want to replace all the uses of x_1 with the new definitions of    x_10 and x_11.  Note that the only uses that should be replaced are    those at lines 5, 9 and 11.  Also, the use of x_7 at line 9 should    *not* be replaced (this is why we cannot just mark symbol 'x' for    renaming).     Additionally, we may need to insert a PHI node at line 11 because    that is a merge point for x_10 and x_11.  So the use of x_1 at line    11 will be replaced with the new PHI node.  The insertion of PHI    nodes is optional.  They are not strictly necessary to preserve the    SSA form, and depending on what the caller inserted, they may not    even be useful for the optimizers.  UPDATE_FLAGS controls various    aspects of how update_ssa operates, see the documentation for    TODO_update_ssa*.  */
end_comment

begin_function
name|void
name|update_ssa
parameter_list|(
name|unsigned
name|update_flags
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|start_bb
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|sbitmap
name|tmp
decl_stmt|;
name|bool
name|insert_phi_p
decl_stmt|;
name|sbitmap_iterator
name|sbi
decl_stmt|;
if|if
condition|(
operator|!
name|need_ssa_update_p
argument_list|()
condition|)
return|return;
name|timevar_push
argument_list|(
name|TV_TREE_SSA_INCREMENTAL
argument_list|)
expr_stmt|;
name|blocks_with_phis_to_rewrite
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phis_to_rewrite
condition|)
name|phis_to_rewrite
operator|=
name|VEC_alloc
argument_list|(
name|tree_vec
argument_list|,
name|heap
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|blocks_to_update
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Ensure that the dominance information is up-to-date.  */
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
comment|/* Only one update flag should be set.  */
name|gcc_assert
argument_list|(
name|update_flags
operator|==
name|TODO_update_ssa
operator|||
name|update_flags
operator|==
name|TODO_update_ssa_no_phi
operator|||
name|update_flags
operator|==
name|TODO_update_ssa_full_phi
operator|||
name|update_flags
operator|==
name|TODO_update_ssa_only_virtuals
argument_list|)
expr_stmt|;
comment|/* If we only need to update virtuals, remove all the mappings for      real names before proceeding.  The caller is responsible for      having dealt with the name mappings before calling update_ssa.  */
if|if
condition|(
name|update_flags
operator|==
name|TODO_update_ssa_only_virtuals
condition|)
block|{
name|sbitmap_zero
argument_list|(
name|old_ssa_names
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|new_ssa_names
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|repl_tbl
argument_list|)
expr_stmt|;
block|}
name|insert_phi_p
operator|=
operator|(
name|update_flags
operator|!=
name|TODO_update_ssa_no_phi
operator|)
expr_stmt|;
if|if
condition|(
name|insert_phi_p
condition|)
block|{
comment|/* If the caller requested PHI nodes to be added, initialize 	 live-in information data structures (DEF_BLOCKS).  */
comment|/* For each SSA name N, the DEF_BLOCKS table describes where the 	 name is defined, which blocks have PHI nodes for N, and which 	 blocks have uses of N (i.e., N is live-on-entry in those 	 blocks).  */
name|def_blocks
operator|=
name|htab_create
argument_list|(
name|num_ssa_names
argument_list|,
name|def_blocks_hash
argument_list|,
name|def_blocks_eq
argument_list|,
name|def_blocks_free
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|def_blocks
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Heuristic to avoid massive slow downs when the replacement      mappings include lots of virtual names.  */
if|if
condition|(
name|insert_phi_p
operator|&&
name|switch_virtuals_to_full_rewrite_p
argument_list|()
condition|)
name|switch_virtuals_to_full_rewrite
argument_list|()
expr_stmt|;
comment|/* If there are names defined in the replacement table, prepare      definition and use sites for all the names in NEW_SSA_NAMES and      OLD_SSA_NAMES.  */
if|if
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|new_ssa_names
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|prepare_names_to_update
argument_list|(
name|insert_phi_p
argument_list|)
expr_stmt|;
comment|/* If all the names in NEW_SSA_NAMES had been marked for 	 removal, and there are no symbols to rename, then there's 	 nothing else to do.  */
if|if
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|new_ssa_names
argument_list|)
operator|<
literal|0
operator|&&
name|bitmap_empty_p
argument_list|(
name|syms_to_rename
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Next, determine the block at which to start the renaming process.  */
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|syms_to_rename
argument_list|)
condition|)
block|{
comment|/* If we have to rename some symbols from scratch, we need to 	 start the process at the root of the CFG.  FIXME, it should 	 be possible to determine the nearest block that had a 	 definition for each of the symbols that are marked for 	 updating.  For now this seems more work than it's worth.  */
name|start_bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
comment|/* Traverse the CFG looking for definitions and uses of symbols 	 in SYMS_TO_RENAME.  Mark interesting blocks and statements 	 and set local live-in information for the PHI placement 	 heuristics.  */
name|prepare_block_for_update
argument_list|(
name|start_bb
argument_list|,
name|insert_phi_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, the entry block to the region is the nearest 	 common dominator for the blocks in BLOCKS.  */
name|start_bb
operator|=
name|nearest_common_dominator_for_set
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|blocks_to_update
argument_list|)
expr_stmt|;
block|}
comment|/* If requested, insert PHI nodes at the iterated dominance frontier      of every block, creating new definitions for names in OLD_SSA_NAMES      and for symbols in SYMS_TO_RENAME.  */
if|if
condition|(
name|insert_phi_p
condition|)
block|{
name|bitmap
modifier|*
name|dfs
decl_stmt|;
comment|/* If the caller requested PHI nodes to be added, compute 	 dominance frontiers.  */
name|dfs
operator|=
name|XNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|dfs
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|compute_dominance_frontiers
argument_list|(
name|dfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbitmap_first_set_bit
argument_list|(
name|old_ssa_names
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|sbitmap_iterator
name|sbi
decl_stmt|;
comment|/* insert_update_phi_nodes_for will call add_new_name_mapping 	     when inserting new PHI nodes, so the set OLD_SSA_NAMES 	     will grow while we are traversing it (but it will not 	     gain any new members).  Copy OLD_SSA_NAMES to a temporary 	     for traversal.  */
name|sbitmap
name|tmp
init|=
name|sbitmap_alloc
argument_list|(
name|old_ssa_names
operator|->
name|n_bits
argument_list|)
decl_stmt|;
name|sbitmap_copy
argument_list|(
name|tmp
argument_list|,
name|old_ssa_names
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|tmp
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
name|insert_updated_phi_nodes_for
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|dfs
argument_list|,
name|blocks_to_update
argument_list|,
name|update_flags
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|syms_to_rename
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|insert_updated_phi_nodes_for
argument_list|(
name|referenced_var
argument_list|(
name|i
argument_list|)
argument_list|,
name|dfs
argument_list|,
name|blocks_to_update
argument_list|,
name|update_flags
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|BITMAP_FREE
argument_list|(
name|dfs
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dfs
argument_list|)
expr_stmt|;
comment|/* Insertion of PHI nodes may have added blocks to the region. 	 We need to re-compute START_BB to include the newly added 	 blocks.  */
if|if
condition|(
name|start_bb
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|start_bb
operator|=
name|nearest_common_dominator_for_set
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|blocks_to_update
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the current definition for name and symbol before renaming      the sub-graph.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|old_ssa_names
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|sbi
argument_list|)
name|set_current_def
argument_list|(
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|syms_to_rename
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|set_current_def
argument_list|(
name|referenced_var
argument_list|(
name|i
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Now start the renaming process at START_BB.  */
name|tmp
operator|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_update
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|SET_BIT
argument_list|(
name|tmp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rewrite_blocks
argument_list|(
name|start_bb
argument_list|,
name|REWRITE_UPDATE
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Debugging dumps.  */
if|if
condition|(
name|dump_file
condition|)
block|{
name|int
name|c
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|dump_update_ssa
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Incremental SSA update started at block: %d\n\n"
argument_list|,
name|start_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_update
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|c
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of blocks in CFG: %d\n"
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Number of blocks to update: %d (%3.0f%%)\n\n"
argument_list|,
name|c
argument_list|,
name|PERCENT
argument_list|(
name|c
argument_list|,
name|last_basic_block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_flags
operator|&
name|TDF_DETAILS
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Affected blocks: "
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_to_update
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%u "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Free allocated memory.  */
name|done
label|:
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|blocks_with_phis_to_rewrite
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree_vec
name|phis
init|=
name|VEC_index
argument_list|(
name|tree_vec
argument_list|,
name|phis_to_rewrite
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|phis
argument_list|)
expr_stmt|;
name|VEC_replace
argument_list|(
name|tree_vec
argument_list|,
name|phis_to_rewrite
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|blocks_with_phis_to_rewrite
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|blocks_to_update
argument_list|)
expr_stmt|;
name|delete_update_ssa
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_SSA_INCREMENTAL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

