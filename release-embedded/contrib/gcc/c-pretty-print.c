begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines common to both C and C++ pretty-printers.    Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Gabriel Dos Reis<gdr@integrable-solutions.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"c-pretty-print.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_comment
comment|/* The pretty-printer code is primarily designed to closely follow    (GNU) C and C++ grammars.  That is to be contrasted with spaghetti    codes we used to have in the past.  Following a structured    approach (preferably the official grammars) is believed to make it    much easier to add extensions and nifty pretty-printing effects that    takes expression or declaration contexts into account.  */
end_comment

begin_define
define|#
directive|define
name|pp_c_maybe_whitespace
parameter_list|(
name|PP
parameter_list|)
define|\
value|do {                                      \      if (pp_base (PP)->padding == pp_before) \        pp_c_whitespace (PP);                 \    } while (0)
end_define

begin_comment
comment|/* literal  */
end_comment

begin_function_decl
specifier|static
name|void
name|pp_c_char
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* postfix-expression  */
end_comment

begin_function_decl
specifier|static
name|void
name|pp_c_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_brace_enclosed_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_multiplicative_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_additive_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_shift_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_relational_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_equality_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_exclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_inclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_logical_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_conditional_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pp_c_assignment_expression
parameter_list|(
name|c_pretty_printer
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* declarations.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Helper functions.  */
end_comment

begin_function
name|void
name|pp_c_whitespace
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_left_paren
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_right_paren
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_left_brace
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_left_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_right_brace
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_right_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_left_bracket
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_right_bracket
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_dot
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_ampersand
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_star
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_arrow
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_arrow
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_semicolon
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_semicolon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_complement
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_complement
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pp_c_exclamation
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp_exclamation
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_none
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the external representation of CV-QUALIFIER.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_cv_qualifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|cv
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|pp_last_position_in_text
argument_list|(
name|pp
argument_list|)
decl_stmt|;
comment|/* The C programming language does not have references, but it is much      simpler to handle those here rather than going through the same      logic in the C++ pretty-printer.  */
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'&'
operator|)
condition|)
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print T using the type-cast notation '( type-name )'.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_type_cast
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_type_id
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're about to pretty-print a pointer type as indicated by T.    Output a whitespace, if needed, preparing for subsequent output.  */
end_comment

begin_function
name|void
name|pp_c_space_for_pointer_operator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|pointee
init|=
name|strip_pointer_operator
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|!=
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Declarations.  */
end_comment

begin_comment
comment|/* C++ cv-qualifiers are called type-qualifiers in C.  Print out the    cv-qualifiers of T.  If T is a declaration then it is the cv-qualifier    of its type.  Take care of possible extensions.     type-qualifier-list:        type-qualifier        type-qualifier-list type-qualifier     type-qualifier:        const        restrict                              -- C99        __restrict__                          -- GNU C        volatile    */
end_comment

begin_function
name|void
name|pp_c_type_qualifier_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|int
name|qualifiers
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|qualifiers
operator|=
name|TYPE_QUALS
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|&
name|TYPE_QUAL_CONST
condition|)
name|pp_c_cv_qualifier
argument_list|(
name|pp
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
name|pp_c_cv_qualifier
argument_list|(
name|pp
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
name|pp_c_cv_qualifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"restrict"
else|:
literal|"__restrict__"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* pointer:       * type-qualifier-list(opt)       * type-qualifier-list(opt) pointer  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_pointer
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
comment|/* It is easier to handle C++ reference types here.  */
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|pp_c_pointer
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|pp_c_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_c_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_type_qualifier_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
comment|/* ??? This node is now in GENERIC and so shouldn't be here.  But 	 we'll fix that later.  */
case|case
name|DECL_EXPR
case|:
name|pp_declaration
argument_list|(
name|pp
argument_list|,
name|DECL_EXPR_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* type-specifier:       void       char       short       int       long       float       double       signed       unsigned       _Bool                          -- C99       _Complex                       -- C99       _Imaginary                     -- C99       struct-or-union-specifier       enum-specifier       typedef-name.    GNU extensions.   simple-type-specifier:       __complex__       __vector__   */
end_comment

begin_function
name|void
name|pp_c_type_specifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<type-error>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|pp_c_tree_decl_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pp_c_type_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|t
operator|=
name|c_common_type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pp_c_type_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|!=
name|prec
condition|)
block|{
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|pp_decimal_int
argument_list|(
name|pp
argument_list|,
name|prec
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|?
literal|"<unnamed-unsigned:"
else|:
literal|"<unnamed-signed:"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"<unnamed-float:"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|pp_decimal_int
argument_list|(
name|pp
argument_list|,
name|prec
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_DECL
case|:
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|pp_id_expression
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<typedef-error>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"union"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"struct"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"enum"
argument_list|)
expr_stmt|;
else|else
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<tag-error>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|pp_id_expression
argument_list|(
name|pp
argument_list|,
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<anonymous>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* specifier-qualifier-list:       type-specifier specifier-qualifier-list-opt       type-qualifier specifier-qualifier-list-opt     Implementation note:  Because of the non-linearities in array or   function declarations, this routine prints not just the   specifier-qualifier-list of such entities or types of such entities,   but also the 'pointer' production part of their declarators.  The   remaining part is done by pp_declarator or pp_c_abstract_declarator.  */
end_comment

begin_function
name|void
name|pp_c_specifier_qualifier_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
name|pp_c_type_qualifier_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REFERENCE_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
block|{
comment|/* Get the types-specifier of this type.  */
name|tree
name|pointee
init|=
name|strip_pointer_operator
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|pointee
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|pointee
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|c_dialect_cxx
argument_list|()
condition|)
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_ptr_operator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|COMPLEX_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"_Complex"
else|:
literal|"__complex__"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|VECTOR_TYPE
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__vector__"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_simple_type_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* parameter-type-list:       parameter-list       parameter-list , ...     parameter-list:       parameter-declaration       parameter-list , parameter-declaration     parameter-declaration:       declaration-specifiers declarator       declaration-specifiers abstract-declarator(opt)   */
end_comment

begin_function
name|void
name|pp_c_parameter_type_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|bool
name|want_parm_decl
init|=
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
operator|(
name|pp
operator|->
name|flags
operator|&
name|pp_c_flag_abstract
operator|)
decl_stmt|;
name|tree
name|parms
init|=
name|want_parm_decl
condition|?
name|DECL_ARGUMENTS
argument_list|(
name|t
argument_list|)
else|:
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|==
name|void_list_node
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
else|else
block|{
name|bool
name|first
init|=
name|true
decl_stmt|;
for|for
control|(
init|;
name|parms
operator|&&
name|parms
operator|!=
name|void_list_node
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|first
operator|=
name|false
expr_stmt|;
name|pp_declaration_specifiers
argument_list|(
name|pp
argument_list|,
name|want_parm_decl
condition|?
name|parms
else|:
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_parm_decl
condition|)
name|pp_declarator
argument_list|(
name|pp
argument_list|,
name|parms
argument_list|)
expr_stmt|;
else|else
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* abstract-declarator:       pointer       pointer(opt) direct-abstract-declarator  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_abstract_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|pp_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* direct-abstract-declarator:       ( abstract-declarator )       direct-abstract-declarator(opt) [ assignment-expression(opt) ]       direct-abstract-declarator(opt) [ * ]       direct-abstract-declarator(opt) ( parameter-type-list(opt) )  */
end_comment

begin_function
name|void
name|pp_c_direct_abstract_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|POINTER_TYPE
case|:
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|pp_c_parameter_type_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|pp_c_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|maxval
init|=
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|maxval
argument_list|)
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|maxval
argument_list|,
literal|0
argument_list|)
condition|)
name|pp_wide_integer
argument_list|(
name|pp
argument_list|,
name|tree_low_cst
argument_list|(
name|maxval
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|fold
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|maxval
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_c_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_direct_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|TYPE_DECL
case|:
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* type-name:       specifier-qualifier-list  abstract-declarator(opt)  */
end_comment

begin_function
name|void
name|pp_c_type_id
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* storage-class-specifier:       typedef       extern       static       auto       register  */
end_comment

begin_function
name|void
name|pp_c_storage_class_specifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|t
argument_list|)
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"register"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"static"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* function-specifier:       inline   */
end_comment

begin_function
name|void
name|pp_c_function_specifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|t
argument_list|)
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"inline"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* declaration-specifiers:       storage-class-specifier declaration-specifiers(opt)       type-specifier declaration-specifiers(opt)       type-qualifier declaration-specifiers(opt)       function-specifier declaration-specifiers(opt)  */
end_comment

begin_function
name|void
name|pp_c_declaration_specifiers
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_storage_class_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_function_specifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_specifier_qualifier_list
argument_list|(
name|pp
argument_list|,
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|?
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
else|:
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* direct-declarator       identifier       ( declarator )       direct-declarator [ type-qualifier-list(opt) assignment-expression(opt) ]       direct-declarator [ static type-qualifier-list(opt) assignment-expression(opt)]       direct-declarator [ type-qualifier-list static assignment-expression ]       direct-declarator [ type-qualifier-list * ]       direct-declarator ( parameter-type-list )       direct-declarator ( identifier-list(opt) )  */
end_comment

begin_function
name|void
name|pp_c_direct_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|LABEL_DECL
case|:
name|pp_c_space_for_pointer_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_tree_decl_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|pp_parameter_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|pp_c_space_for_pointer_operator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_tree_decl_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp_c_base
argument_list|(
name|pp
argument_list|)
operator|->
name|flags
operator|&
name|pp_c_flag_abstract
condition|)
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|pp_parameter_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_abstract_declarator
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* declarator:       pointer(opt)  direct-declarator   */
end_comment

begin_function
name|void
name|pp_c_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|TYPE_DECL
case|:
name|pp_direct_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* declaration:       declaration-specifiers init-declarator-list(opt) ;  */
end_comment

begin_function
name|void
name|pp_c_declaration
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_declaration_specifiers
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_init_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print ATTRIBUTES using GNU C extension syntax.  */
end_comment

begin_function
name|void
name|pp_c_attributes
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
if|if
condition|(
name|attributes
operator|==
name|NULL_TREE
condition|)
return|return;
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__attribute__"
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|attributes
operator|!=
name|NULL_TREE
condition|;
name|attributes
operator|=
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
control|)
block|{
name|pp_tree_identifier
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|attributes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|attributes
argument_list|)
condition|)
name|pp_c_call_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|attributes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|attributes
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function-definition:       declaration-specifiers declarator compound-statement  */
end_comment

begin_function
name|void
name|pp_c_function_definition
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_declaration_specifiers
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expressions.  */
end_comment

begin_comment
comment|/* Print out a c-char.  This is called solely for characters which are    in the *target* execution character set.  We ought to convert them    back to the *host* execution character set before printing, but we    have no way to do this at present.  A decent compromise is to print    all characters as if they were in the host execution character set,    and not attempt to recover any named escape characters, but render    all unprintables as octal escapes.  If the host and target character    sets are the same, this produces relatively readable output.  If they    are not the same, strings may appear as gibberish, but that's okay    (in fact, it may well be what the reader wants, e.g. if they are looking    to see if conversion to the target character set happened correctly).     A special case: we need to prefix \, ", and ' with backslashes.  It is    correct to do so for the *host*'s \, ", and ', because the rest of the    file appears in the host character set.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_char
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_character
argument_list|(
name|pp
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pp_scalar
argument_list|(
name|pp
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a STRING literal.  */
end_comment

begin_function
name|void
name|pp_c_string_literal
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|TREE_STRING_POINTER
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|s
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pp_doublequote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|pp_c_char
argument_list|(
name|pp
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pp_doublequote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print an INTEGER literal.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_integer_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|i
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
name|pp_wide_integer
argument_list|(
name|pp
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|i
operator|=
name|build_int_cst_wide
argument_list|(
name|NULL_TREE
argument_list|,
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
operator|+
operator|!
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|long_integer_type_node
operator|||
name|type
operator|==
name|long_unsigned_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_long_integer_type_node
operator|||
name|type
operator|==
name|long_long_unsigned_type_node
condition|)
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"ll"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a CHARACTER literal.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_character_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|c
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|wchar_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|pp_quote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|c
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|pp_c_char
argument_list|(
name|pp
argument_list|,
name|tree_low_cst
argument_list|(
name|c
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pp_scalar
argument_list|(
name|pp
argument_list|,
literal|"\\x%x"
argument_list|,
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|pp_quote
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out a BOOLEAN literal.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_bool_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|==
name|boolean_false_node
condition|)
block|{
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_isoc99
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"_False"
argument_list|)
expr_stmt|;
else|else
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|==
name|boolean_true_node
condition|)
block|{
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_isoc99
condition|)
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"_True"
argument_list|)
expr_stmt|;
else|else
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|pp_c_integer_constant
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|else
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to print out an ENUMERATOR.  Return true on success.  Else return    false; that means the value was obtained by a cast, in which case    print out the type-id part of the cast-expression -- the casted value    is then printed by pp_c_integer_literal.  */
end_comment

begin_function
specifier|static
name|bool
name|pp_c_enumeration_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|bool
name|value_is_named
init|=
name|true
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|tree
name|value
decl_stmt|;
comment|/* Find the name of this constant.  */
for|for
control|(
name|value
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|value
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|tree_int_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|value
argument_list|)
argument_list|,
name|e
argument_list|)
condition|;
name|value
operator|=
name|TREE_CHAIN
argument_list|(
name|value
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL_TREE
condition|)
name|pp_id_expression
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Value must have been cast.  */
name|pp_c_type_cast
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|value_is_named
operator|=
name|false
expr_stmt|;
block|}
return|return
name|value_is_named
return|;
block|}
end_function

begin_comment
comment|/* Print out a REAL value as a decimal-floating-constant.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_floating_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|r
parameter_list|)
block|{
name|real_to_decimal
argument_list|(
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|,
operator|&
name|TREE_REAL_CST
argument_list|(
name|r
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pp_string
argument_list|(
name|pp
argument_list|,
name|pp_buffer
argument_list|(
name|pp
argument_list|)
operator|->
name|digit_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|==
name|float_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|==
name|long_double_type_node
condition|)
name|pp_character
argument_list|(
name|pp
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|==
name|dfloat128_type_node
condition|)
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"dl"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|==
name|dfloat64_type_node
condition|)
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"dd"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|r
argument_list|)
operator|==
name|dfloat32_type_node
condition|)
name|pp_string
argument_list|(
name|pp
argument_list|,
literal|"df"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print a compound literal expression.  GNU extensions include    vector constants.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_compound_literal
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|pp_c_type_cast
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
name|pp_c_brace_enclosed_initializer_list
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* constant:       integer-constant       floating-constant       enumeration-constant       character-constant   */
end_comment

begin_function
name|void
name|pp_c_constant
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|boolean_type_node
condition|)
name|pp_c_bool_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|pp_c_character_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|pp_c_enumeration_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
condition|)
empty_stmt|;
else|else
name|pp_c_integer_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REAL_CST
case|:
name|pp_c_floating_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|pp_c_string_literal
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Pretty-print an IDENTIFIER_NODE, preceded by whitespace is necessary.  */
end_comment

begin_function
name|void
name|pp_c_identifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|pp_c_maybe_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|padding
operator|=
name|pp_before
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print a C primary-expression.    primary-expression:       identifier       constant       string-literal       ( expression )   */
end_comment

begin_function
name|void
name|pp_c_primary_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|LABEL_DECL
case|:
name|pp_c_tree_decl_identifier
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|pp_c_tree_identifier
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERROR_MARK
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<erroneous-expression>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"<return-value>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
name|pp_c_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__builtin_memcpy"
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_primary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_initializer
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_c_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* FIXME:  Make sure we won't get into an infinie loop.  */
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out a C initializer -- also support C compound-literals.    initializer:       assignment-expression:       { initializer-list }       { initializer-list , }   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_initializer
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|pp_c_brace_enclosed_initializer_list
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init-declarator:       declarator:       declarator = initializer   */
end_comment

begin_function
name|void
name|pp_c_init_declarator
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_declarator
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* We don't want to output function definitions here.  There are handled      elsewhere (and the syntactic form is bogus anyway).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* This C++ bit is handled here because it is easier to do so. 	 In templates, the C++ parser builds a TREE_LIST for a 	 direct-initialization; the TREE_PURPOSE is the variable to 	 initialize and the TREE_VALUE is the initializer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|pp_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_initializer
argument_list|(
name|pp
argument_list|,
name|init
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* initializer-list:       designation(opt) initializer       initializer-list , designation(opt) initializer     designation:       designator-list =     designator-list:       designator       designator-list designator     designator:       [ constant-expression ]       identifier   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
block|{
name|tree
name|init
init|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|init
operator|!=
name|NULL_TREE
condition|;
name|init
operator|=
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
control|)
block|{
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
condition|)
block|{
name|pp_c_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_primary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_c_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
condition|)
name|pp_c_constant
argument_list|(
name|pp
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_initializer
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|VECTOR_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|VECTOR_CST
condition|)
name|pp_c_expression_list
argument_list|(
name|pp
argument_list|,
name|TREE_VECTOR_CST_ELTS
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|pp_c_constructor_elts
argument_list|(
name|pp
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
else|else
break|break;
return|return;
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|pp_c_constructor_elts
argument_list|(
name|pp
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPLEX_CST
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPLEX_EXPR
condition|)
block|{
specifier|const
name|bool
name|cst
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COMPLEX_CST
decl_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|cst
condition|?
name|TREE_REALPART
argument_list|(
name|e
argument_list|)
else|:
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|cst
condition|?
name|TREE_IMAGPART
argument_list|(
name|e
argument_list|)
else|:
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
return|return;
default|default:
break|break;
block|}
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pretty-print a brace-enclosed initializer-list.  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_brace_enclosed_initializer_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|l
parameter_list|)
block|{
name|pp_c_left_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_initializer_list
argument_list|(
name|pp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|pp_c_right_brace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  This is a convenient function, used to bridge gap between C and C++     grammars.      id-expression:        identifier  */
end_comment

begin_function
name|void
name|pp_c_id_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|LABEL_DECL
case|:
name|pp_c_tree_decl_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|pp_c_tree_identifier
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* postfix-expression:       primary-expression       postfix-expression [ expression ]       postfix-expression ( argument-expression-list(opt) )       postfix-expression . identifier       postfix-expression -> identifier       postfix-expression ++       postfix-expression --       ( type-name ) { initializer-list }       ( type-name ) { initializer-list , }  */
end_comment

begin_function
name|void
name|pp_c_postfix_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|?
literal|"++"
else|:
literal|"--"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_left_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_bracket
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_call_argument_list
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"isunordered"
else|:
literal|"__builtin_isunordered"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
case|case
name|ORDERED_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"!isunordered"
else|:
literal|"!__builtin_isunordered"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
case|case
name|UNLT_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"!isgreaterequal"
else|:
literal|"!__builtin_isgreaterequal"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
case|case
name|UNLE_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"!isgreater"
else|:
literal|"!__builtin_isgreater"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
case|case
name|UNGT_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"!islessequal"
else|:
literal|"!__builtin_islessequal"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
case|case
name|UNGE_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"!isless"
else|:
literal|"!__builtin_isless"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
case|case
name|UNEQ_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"!islessgreater"
else|:
literal|"!__builtin_islessgreater"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
case|case
name|LTGT_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|flag_isoc99
condition|?
literal|"islessgreater"
else|:
literal|"__builtin_islessgreater"
argument_list|)
expr_stmt|;
goto|goto
name|two_args_fun
goto|;
name|two_args_fun
label|:
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__builtin_abs"
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
block|{
name|tree
name|object
init|=
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_arrow
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|pp_c_dot
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPLEX_CST
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|COMPLEX_EXPR
case|:
name|pp_c_compound_literal
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
name|e
operator|=
name|DECL_INITIAL
argument_list|(
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CONSTRUCTOR
case|:
name|pp_initializer
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|VA_ARG_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
literal|"__builtin_va_arg"
argument_list|)
expr_stmt|;
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_type_id
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|pp_c_id_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through.  */
default|default:
name|pp_primary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out an expression-list; E is expected to be a TREE_LIST.  */
end_comment

begin_function
name|void
name|pp_c_expression_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
for|for
control|(
init|;
name|e
operator|!=
name|NULL_TREE
condition|;
name|e
operator|=
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
control|)
block|{
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_VALUE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|e
argument_list|)
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print out V, which contains the elements of a constructor.  */
end_comment

begin_decl_stmt
name|void
name|pp_c_constructor_elts
argument_list|(
name|c_pretty_printer
operator|*
name|pp
argument_list|,
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|tree
name|value
decl_stmt|;
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|v
argument_list|,
argument|ix
argument_list|,
argument|value
argument_list|)
block|{
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|!=
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|)
operator|-
literal|1
condition|)
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Print out an expression-list in parens, as in a function call.  */
end_comment

begin_function
name|void
name|pp_c_call_argument_list
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|pp_c_expression_list
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unary-expression:       postfix-expression       ++ cast-expression       -- cast-expression       unary-operator cast-expression       sizeof unary-expression       sizeof ( type-id )    unary-operator: one of       *&  + - ! ~     GNU extensions.    unary-expression:       __alignof__ unary-expression       __alignof__ ( type-id )       __real__ unary-expression       __imag__ unary-expression  */
end_comment

begin_function
name|void
name|pp_c_unary_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|PREINCREMENT_EXPR
condition|?
literal|"++"
else|:
literal|"--"
argument_list|)
expr_stmt|;
name|pp_c_unary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|CONJ_EXPR
case|:
comment|/* String literal are used by address.  */
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INDIRECT_REF
condition|)
name|pp_c_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NEGATE_EXPR
condition|)
name|pp_minus
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|BIT_NOT_EXPR
operator|||
name|code
operator|==
name|CONJ_EXPR
condition|)
name|pp_complement
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TRUTH_NOT_EXPR
condition|)
name|pp_exclamation
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|REALPART_EXPR
condition|?
literal|"__real__"
else|:
literal|"__imag__"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_unary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* cast-expression:       unary-expression       ( type-name ) cast-expression  */
end_comment

begin_function
name|void
name|pp_c_cast_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
condition|)
block|{
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
name|pp_c_type_cast
argument_list|(
name|pp
argument_list|,
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* multiplicative-expression:       cast-expression       multiplicative-expression * cast-expression       multiplicative-expression / cast-expression       multiplicative-expression % cast-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_multiplicative_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MULT_EXPR
condition|)
name|pp_c_star
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TRUNC_DIV_EXPR
condition|)
name|pp_slash
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_modulo
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* additive-expression:       multiplicative-expression       additive-expression + multiplicative-expression       additive-expression - multiplicative-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_additive_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
name|pp_plus
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
name|pp_minus
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* additive-expression:       additive-expression       shift-expression<< additive-expression       shift-expression>> additive-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_shift_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|LSHIFT_EXPR
condition|?
literal|"<<"
else|:
literal|">>"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* relational-expression:       shift-expression       relational-expression< shift-expression       relational-expression> shift-expression       relational-expression<= shift-expression       relational-expression>= shift-expression   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_relational_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
name|pp_less
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
name|pp_greater
argument_list|(
name|pp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"<="
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|">="
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* equality-expression:       relational-expression       equality-expression == relational-expression       equality-equality != relational-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_equality_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
name|code
operator|==
name|EQ_EXPR
condition|?
literal|"=="
else|:
literal|"!="
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* AND-expression:       equality-expression       AND-expression& equality-equality   */
end_comment

begin_function
specifier|static
name|void
name|pp_c_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|BIT_AND_EXPR
condition|)
block|{
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_ampersand
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* exclusive-OR-expression:      AND-expression      exclusive-OR-expression ^ AND-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_exclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|BIT_XOR_EXPR
condition|)
block|{
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_maybe_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_carret
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* inclusive-OR-expression:      exclusive-OR-expression      inclusive-OR-expression | exclusive-OR-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_inclusive_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|BIT_IOR_EXPR
condition|)
block|{
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_bar
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* logical-AND-expression:       inclusive-OR-expression       logical-AND-expression&& inclusive-OR-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_logical_and_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
block|{
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"&&"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_inclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_inclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* logical-OR-expression:       logical-AND-expression       logical-OR-expression || logical-AND-expression  */
end_comment

begin_function
name|void
name|pp_c_logical_or_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_identifier
argument_list|(
name|pp
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* conditional-expression:       logical-OR-expression       logical-OR-expression ? expression : conditional-expression  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_conditional_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_question
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_colon
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_conditional_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* assignment-expression:       conditional-expression       unary-expression assignment-operator  assignment-expression     assignment-expression: one of       =    *=    /=    %=    +=    -=>>=<<=&=    ^=    |=  */
end_comment

begin_function
specifier|static
name|void
name|pp_c_assignment_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|INIT_EXPR
condition|)
block|{
name|pp_c_unary_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_whitespace
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_equal
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_space
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_c_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pp_c_conditional_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* expression:        assignment-expression        expression , assignment-expression    Implementation note:  instead of going through the usual recursion   chain, I take the liberty of dispatching nodes to the appropriate   functions.  This makes some redundancy, but it worths it. That also   prevents a possible infinite recursion between pp_c_primary_expression ()   and pp_c_expression ().  */
end_comment

begin_function
name|void
name|pp_c_expression
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|e
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|pp_c_integer_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|pp_c_floating_constant
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING_CST
case|:
name|pp_c_string_literal
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|FIELD_DECL
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|ERROR_MARK
case|:
name|pp_primary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|CALL_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|COMPLEX_EXPR
case|:
case|case
name|VECTOR_CST
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|CONSTRUCTOR
case|:
case|case
name|COMPOUND_LITERAL_EXPR
case|:
case|case
name|VA_ARG_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONJ_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
name|pp_c_unary_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
name|pp_c_cast_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
name|pp_multiplicative_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
name|pp_c_shift_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|pp_c_relational_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|pp_c_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|pp_c_exclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|pp_c_inclusive_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|pp_c_logical_and_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|pp_c_logical_or_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
name|pp_c_equality_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|pp_conditional_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|pp_c_additive_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
name|pp_assignment_expression
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
name|pp_c_left_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pp_separate_with
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|pp_assignment_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pp_c_right_paren
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
name|pp_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|pp_postfix_expression
argument_list|(
name|pp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp_unsupported_tree
argument_list|(
name|pp
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Statements.  */
end_comment

begin_function
name|void
name|pp_c_statement
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|stmt
parameter_list|)
block|{
if|if
condition|(
name|stmt
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
condition|)
name|pp_newline_and_indent
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_generic_node
argument_list|(
name|pp_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|pp_indentation
argument_list|(
name|pp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the PRETTY-PRINTER for handling C codes.  */
end_comment

begin_function
name|void
name|pp_c_pretty_printer_init
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|)
block|{
name|pp
operator|->
name|offset_list
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|declaration
operator|=
name|pp_c_declaration
expr_stmt|;
name|pp
operator|->
name|declaration_specifiers
operator|=
name|pp_c_declaration_specifiers
expr_stmt|;
name|pp
operator|->
name|declarator
operator|=
name|pp_c_declarator
expr_stmt|;
name|pp
operator|->
name|direct_declarator
operator|=
name|pp_c_direct_declarator
expr_stmt|;
name|pp
operator|->
name|type_specifier_seq
operator|=
name|pp_c_specifier_qualifier_list
expr_stmt|;
name|pp
operator|->
name|abstract_declarator
operator|=
name|pp_c_abstract_declarator
expr_stmt|;
name|pp
operator|->
name|direct_abstract_declarator
operator|=
name|pp_c_direct_abstract_declarator
expr_stmt|;
name|pp
operator|->
name|ptr_operator
operator|=
name|pp_c_pointer
expr_stmt|;
name|pp
operator|->
name|parameter_list
operator|=
name|pp_c_parameter_type_list
expr_stmt|;
name|pp
operator|->
name|type_id
operator|=
name|pp_c_type_id
expr_stmt|;
name|pp
operator|->
name|simple_type_specifier
operator|=
name|pp_c_type_specifier
expr_stmt|;
name|pp
operator|->
name|function_specifier
operator|=
name|pp_c_function_specifier
expr_stmt|;
name|pp
operator|->
name|storage_class_specifier
operator|=
name|pp_c_storage_class_specifier
expr_stmt|;
name|pp
operator|->
name|statement
operator|=
name|pp_c_statement
expr_stmt|;
name|pp
operator|->
name|constant
operator|=
name|pp_c_constant
expr_stmt|;
name|pp
operator|->
name|id_expression
operator|=
name|pp_c_id_expression
expr_stmt|;
name|pp
operator|->
name|primary_expression
operator|=
name|pp_c_primary_expression
expr_stmt|;
name|pp
operator|->
name|postfix_expression
operator|=
name|pp_c_postfix_expression
expr_stmt|;
name|pp
operator|->
name|unary_expression
operator|=
name|pp_c_unary_expression
expr_stmt|;
name|pp
operator|->
name|initializer
operator|=
name|pp_c_initializer
expr_stmt|;
name|pp
operator|->
name|multiplicative_expression
operator|=
name|pp_c_multiplicative_expression
expr_stmt|;
name|pp
operator|->
name|conditional_expression
operator|=
name|pp_c_conditional_expression
expr_stmt|;
name|pp
operator|->
name|assignment_expression
operator|=
name|pp_c_assignment_expression
expr_stmt|;
name|pp
operator|->
name|expression
operator|=
name|pp_c_expression
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the tree T in full, on file FILE.  */
end_comment

begin_function
name|void
name|print_c_tree
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|static
name|c_pretty_printer
name|pp_rec
decl_stmt|;
specifier|static
name|bool
name|initialized
init|=
literal|0
decl_stmt|;
name|c_pretty_printer
modifier|*
name|pp
init|=
operator|&
name|pp_rec
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|pp_construct
argument_list|(
name|pp_base
argument_list|(
name|pp
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pp_c_pretty_printer_init
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_needs_newline
argument_list|(
name|pp
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
name|pp_base
argument_list|(
name|pp
argument_list|)
operator|->
name|buffer
operator|->
name|stream
operator|=
name|file
expr_stmt|;
name|pp_statement
argument_list|(
name|pp
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|pp_newline
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp_flush
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the tree T in full, on stderr.  */
end_comment

begin_function
name|void
name|debug_c_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|print_c_tree
argument_list|(
name|stderr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the DECL_NAME of T.  If T has no DECL_NAME, output a string made    up of T's memory address.  */
end_comment

begin_function
name|void
name|pp_c_tree_decl_identifier
parameter_list|(
name|c_pretty_printer
modifier|*
name|pp
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
name|char
name|xname
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|xname
argument_list|,
literal|"<U%4x>"
argument_list|,
operator|(
call|(
name|unsigned
call|)
argument_list|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|t
argument_list|)
operator|&
literal|0xffff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|xname
expr_stmt|;
block|}
name|pp_c_identifier
argument_list|(
name|pp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

