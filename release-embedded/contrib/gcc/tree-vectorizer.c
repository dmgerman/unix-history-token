begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop Vectorization    Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Contributed by Dorit Naishlos<dorit@il.ibm.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Loop Vectorization Pass.     This pass tries to vectorize loops. This first implementation focuses on    simple inner-most loops, with no conditional control flow, and a set of    simple operations which vector form can be expressed using existing    tree codes (PLUS, MULT etc).     For example, the vectorizer transforms the following simple loop:  	short a[N]; short b[N]; short c[N]; int i;  	for (i=0; i<N; i++){ 	  a[i] = b[i] + c[i]; 	}     as if it was manually vectorized by rewriting the source code into:  	typedef int __attribute__((mode(V8HI))) v8hi; 	short a[N];  short b[N]; short c[N];   int i; 	v8hi *pa = (v8hi*)a, *pb = (v8hi*)b, *pc = (v8hi*)c; 	v8hi va, vb, vc;  	for (i=0; i<N/8; i++){ 	  vb = pb[i]; 	  vc = pc[i]; 	  va = vb + vc; 	  pa[i] = va; 	}  	The main entry to this pass is vectorize_loops(), in which    the vectorizer applies a set of analyses on a given set of loops,    followed by the actual vectorization transformation for the loops that    had successfully passed the analysis phase.  	Throughout this pass we make a distinction between two types of    data: scalars (which are represented by SSA_NAMES), and memory references    ("data-refs"). These two types of data require different handling both     during analysis and transformation. The types of data-refs that the     vectorizer currently supports are ARRAY_REFS which base is an array DECL     (not a pointer), and INDIRECT_REFS through pointers; both array and pointer    accesses are required to have a  simple (consecutive) access pattern.     Analysis phase:    =============== 	The driver for the analysis phase is vect_analyze_loop_nest().    It applies a set of analyses, some of which rely on the scalar evolution     analyzer (scev) developed by Sebastian Pop.  	During the analysis phase the vectorizer records some information    per stmt in a "stmt_vec_info" struct which is attached to each stmt in the     loop, as well as general information about the loop as a whole, which is    recorded in a "loop_vec_info" struct attached to each loop.     Transformation phase:    ===================== 	The loop transformation phase scans all the stmts in the loop, and    creates a vector stmt (or a sequence of stmts) for each scalar stmt S in    the loop that needs to be vectorized. It insert the vector code sequence    just before the scalar stmt S, and records a pointer to the vector code    in STMT_VINFO_VEC_STMT (stmt_info) (stmt_info is the stmt_vec_info struct     attached to S). This pointer will be used for the vectorization of following    stmts which use the def of stmt S. Stmt S is removed if it writes to memory;    otherwise, we rely on dead code elimination for removing it.  	For example, say stmt S1 was vectorized into stmt VS1:     VS1: vb = px[i];    S1:	b = x[i];    STMT_VINFO_VEC_STMT (stmt_info (S1)) = VS1    S2:  a = b;     To vectorize stmt S2, the vectorizer first finds the stmt that defines    the operand 'b' (S1), and gets the relevant vector def 'vb' from the    vector stmt VS1 pointed to by STMT_VINFO_VEC_STMT (stmt_info (S1)). The    resulting sequence would be:     VS1: vb = px[i];    S1:	b = x[i];	STMT_VINFO_VEC_STMT (stmt_info (S1)) = VS1    VS2: va = vb;    S2:  a = b;          STMT_VINFO_VEC_STMT (stmt_info (S2)) = VS2  	Operands that are not SSA_NAMEs, are data-refs that appear in     load/store operations (like 'x[i]' in S1), and are handled differently.     Target modeling:    ================= 	Currently the only target specific information that is used is the    size of the vector (in bytes) - "UNITS_PER_SIMD_WORD". Targets that can     support different sizes of vectors, for now will need to specify one value     for "UNITS_PER_SIMD_WORD". More flexibility will be added in the future.  	Since we only vectorize operations which vector form can be    expressed using existing tree codes, to verify that an operation is    supported, the vectorizer checks the relevant optab at the relevant    machine_mode (e.g, add_optab->handlers[(int) V8HImode].insn_code). If    the value found is CODE_FOR_nothing, then there's no target support, and    we can't vectorize the stmt.     For additional information on this project see:    http://gcc.gnu.org/projects/tree-ssa/vectorization.html */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tree-vectorizer.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_comment
comment|/*************************************************************************   Simple Loop Peeling Utilities  *************************************************************************/
end_comment

begin_function_decl
specifier|static
name|struct
name|loop
modifier|*
name|slpeel_tree_duplicate_loop_to_edge_cfg
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|struct
name|loops
modifier|*
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|slpeel_update_phis_for_duplicate_loop
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|bool
name|after
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|slpeel_update_phi_nodes_for_guard1
parameter_list|(
name|edge
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|basic_block
modifier|*
parameter_list|,
name|bitmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|slpeel_update_phi_nodes_for_guard2
parameter_list|(
name|edge
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|,
name|bool
parameter_list|,
name|basic_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|edge
name|slpeel_add_loop_guard
parameter_list|(
name|basic_block
parameter_list|,
name|tree
parameter_list|,
name|basic_block
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rename_use_op
parameter_list|(
name|use_operand_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rename_variables_in_bb
parameter_list|(
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rename_variables_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************************************   General Vectorization Utilities  *************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|vect_set_dump_settings
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* vect_dump will be set to stderr or dump_file if exist.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|vect_dump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vect_verbosity_level set to an invalid value     to mark that it's uninitialized.  */
end_comment

begin_decl_stmt
name|enum
name|verbosity_levels
name|vect_verbosity_level
init|=
name|MAX_VERBOSITY_LEVEL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of loops, at the beginning of vectorization.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|vect_loops_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Loop location.  */
end_comment

begin_decl_stmt
specifier|static
name|LOC
name|vect_loop_location
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap of virtual variables to be renamed.  */
end_comment

begin_decl_stmt
name|bitmap
name|vect_vnames_to_rename
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*************************************************************************   Simple Loop Peeling Utilities    Utilities to support loop peeling for vectorization purposes.  *************************************************************************/
end_comment

begin_comment
comment|/* Renames the use *OP_P.  */
end_comment

begin_function
specifier|static
name|void
name|rename_use_op
parameter_list|(
name|use_operand_p
name|op_p
parameter_list|)
block|{
name|tree
name|new_name
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|USE_FROM_PTR
argument_list|(
name|op_p
argument_list|)
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return;
name|new_name
operator|=
name|get_current_def
argument_list|(
name|USE_FROM_PTR
argument_list|(
name|op_p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Something defined outside of the loop.  */
if|if
condition|(
operator|!
name|new_name
condition|)
return|return;
comment|/* An ordinary ssa name defined in the loop.  */
name|SET_USE
argument_list|(
name|op_p
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Renames the variables in basic block BB.  */
end_comment

begin_function
specifier|static
name|void
name|rename_variables_in_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|bb
operator|->
name|loop_father
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|stmt
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|(SSA_OP_ALL_USES | SSA_OP_ALL_KILLS)
argument_list|)
name|rename_use_op
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|rename_use_op
argument_list|(
name|PHI_ARG_DEF_PTR_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Renames variables in new generated LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|rename_variables_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
name|rename_variables_in_bb
argument_list|(
name|bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the PHI nodes of NEW_LOOP.     NEW_LOOP is a duplicate of ORIG_LOOP.    AFTER indicates whether NEW_LOOP executes before or after ORIG_LOOP:    AFTER is true if NEW_LOOP executes after ORIG_LOOP, and false if it    executes before it.  */
end_comment

begin_function
specifier|static
name|void
name|slpeel_update_phis_for_duplicate_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|orig_loop
parameter_list|,
name|struct
name|loop
modifier|*
name|new_loop
parameter_list|,
name|bool
name|after
parameter_list|)
block|{
name|tree
name|new_ssa_name
decl_stmt|;
name|tree
name|phi_new
decl_stmt|,
name|phi_orig
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|edge
name|orig_loop_latch
init|=
name|loop_latch_edge
argument_list|(
name|orig_loop
argument_list|)
decl_stmt|;
name|edge
name|orig_entry_e
init|=
name|loop_preheader_edge
argument_list|(
name|orig_loop
argument_list|)
decl_stmt|;
name|edge
name|new_loop_exit_e
init|=
name|new_loop
operator|->
name|single_exit
decl_stmt|;
name|edge
name|new_loop_entry_e
init|=
name|loop_preheader_edge
argument_list|(
name|new_loop
argument_list|)
decl_stmt|;
name|edge
name|entry_arg_e
init|=
operator|(
name|after
condition|?
name|orig_loop_latch
else|:
name|orig_entry_e
operator|)
decl_stmt|;
comment|/*      step 1. For each loop-header-phi:              Add the first phi argument for the phi in NEW_LOOP             (the one associated with the entry of NEW_LOOP)       step 2. For each loop-header-phi:              Add the second phi argument for the phi in NEW_LOOP             (the one associated with the latch of NEW_LOOP)       step 3. Update the phis in the successor block of NEW_LOOP.          case 1: NEW_LOOP was placed before ORIG_LOOP:                 The successor block of NEW_LOOP is the header of ORIG_LOOP.                 Updating the phis in the successor block can therefore be done                 along with the scanning of the loop header phis, because the                 header blocks of ORIG_LOOP and NEW_LOOP have exactly the same                 phi nodes, organized in the same order.          case 2: NEW_LOOP was placed after ORIG_LOOP:                 The successor block of NEW_LOOP is the original exit block of                  ORIG_LOOP - the phis to be updated are the loop-closed-ssa phis.                 We postpone updating these phis to a later stage (when                 loop guards are added).    */
comment|/* Scan the phis in the headers of the old and new loops      (they are organized in exactly the same order).  */
for|for
control|(
name|phi_new
operator|=
name|phi_nodes
argument_list|(
name|new_loop
operator|->
name|header
argument_list|)
operator|,
name|phi_orig
operator|=
name|phi_nodes
argument_list|(
name|orig_loop
operator|->
name|header
argument_list|)
init|;
name|phi_new
operator|&&
name|phi_orig
condition|;
name|phi_new
operator|=
name|PHI_CHAIN
argument_list|(
name|phi_new
argument_list|)
operator|,
name|phi_orig
operator|=
name|PHI_CHAIN
argument_list|(
name|phi_orig
argument_list|)
control|)
block|{
comment|/* step 1.  */
name|def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi_orig
argument_list|,
name|entry_arg_e
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi_new
argument_list|,
name|def
argument_list|,
name|new_loop_entry_e
argument_list|)
expr_stmt|;
comment|/* step 2.  */
name|def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi_orig
argument_list|,
name|orig_loop_latch
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
name|new_ssa_name
operator|=
name|get_current_def
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_ssa_name
condition|)
block|{
comment|/* This only happens if there are no definitions 	     inside the loop. use the phi_result in this case.  */
name|new_ssa_name
operator|=
name|PHI_RESULT
argument_list|(
name|phi_new
argument_list|)
expr_stmt|;
block|}
comment|/* An ordinary ssa name defined in the loop.  */
name|add_phi_arg
argument_list|(
name|phi_new
argument_list|,
name|new_ssa_name
argument_list|,
name|loop_latch_edge
argument_list|(
name|new_loop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* step 3 (case 1).  */
if|if
condition|(
operator|!
name|after
condition|)
block|{
name|gcc_assert
argument_list|(
name|new_loop_exit_e
operator|==
name|orig_entry_e
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|phi_orig
argument_list|,
name|new_loop_exit_e
operator|->
name|dest_idx
argument_list|,
name|new_ssa_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Update PHI nodes for a guard of the LOOP.     Input:    - LOOP, GUARD_EDGE: LOOP is a loop for which we added guard code that         controls whether LOOP is to be executed.  GUARD_EDGE is the edge that         originates from the guard-bb, skips LOOP and reaches the (unique) exit         bb of LOOP.  This loop-exit-bb is an empty bb with one successor.         We denote this bb NEW_MERGE_BB because before the guard code was added         it had a single predecessor (the LOOP header), and now it became a merge         point of two paths - the path that ends with the LOOP exit-edge, and         the path that ends with GUARD_EDGE.    - NEW_EXIT_BB: New basic block that is added by this function between LOOP         and NEW_MERGE_BB. It is used to place loop-closed-ssa-form exit-phis.     ===> The CFG before the guard-code was added:         LOOP_header_bb:           loop_body           if (exit_loop) goto update_bb           else           goto LOOP_header_bb         update_bb:     ==> The CFG after the guard-code was added:         guard_bb:           if (LOOP_guard_condition) goto new_merge_bb           else                      goto LOOP_header_bb         LOOP_header_bb:           loop_body           if (exit_loop_condition) goto new_merge_bb           else                     goto LOOP_header_bb         new_merge_bb:           goto update_bb         update_bb:     ==> The CFG after this function:         guard_bb:           if (LOOP_guard_condition) goto new_merge_bb           else                      goto LOOP_header_bb         LOOP_header_bb:           loop_body           if (exit_loop_condition) goto new_exit_bb           else                     goto LOOP_header_bb         new_exit_bb:         new_merge_bb:           goto update_bb         update_bb:     This function:    1. creates and updates the relevant phi nodes to account for the new       incoming edge (GUARD_EDGE) into NEW_MERGE_BB. This involves:       1.1. Create phi nodes at NEW_MERGE_BB.       1.2. Update the phi nodes at the successor of NEW_MERGE_BB (denoted            UPDATE_BB).  UPDATE_BB was the exit-bb of LOOP before NEW_MERGE_BB    2. preserves loop-closed-ssa-form by creating the required phi nodes       at the exit of LOOP (i.e, in NEW_EXIT_BB).     There are two flavors to this function:     slpeel_update_phi_nodes_for_guard1:      Here the guard controls whether we enter or skip LOOP, where LOOP is a      prolog_loop (loop1 below), and the new phis created in NEW_MERGE_BB are      for variables that have phis in the loop header.     slpeel_update_phi_nodes_for_guard2:      Here the guard controls whether we enter or skip LOOP, where LOOP is an      epilog_loop (loop2 below), and the new phis created in NEW_MERGE_BB are      for variables that have phis in the loop exit.     I.E., the overall structure is:          loop1_preheader_bb:                 guard1 (goto loop1/merg1_bb)         loop1         loop1_exit_bb:                 guard2 (goto merge1_bb/merge2_bb)         merge1_bb         loop2         loop2_exit_bb         merge2_bb         next_bb     slpeel_update_phi_nodes_for_guard1 takes care of creating phis in    loop1_exit_bb and merge1_bb. These are entry phis (phis for the vars    that have phis in loop1->header).     slpeel_update_phi_nodes_for_guard2 takes care of creating phis in    loop2_exit_bb and merge2_bb. These are exit phis (phis for the vars    that have phis in next_bb). It also adds some of these phis to    loop1_exit_bb.     slpeel_update_phi_nodes_for_guard1 is always called before    slpeel_update_phi_nodes_for_guard2. They are both needed in order    to create correct data-flow and loop-closed-ssa-form.     Generally slpeel_update_phi_nodes_for_guard1 creates phis for variables    that change between iterations of a loop (and therefore have a phi-node    at the loop entry), whereas slpeel_update_phi_nodes_for_guard2 creates    phis for variables that are used out of the loop (and therefore have     loop-closed exit phis). Some variables may be both updated between     iterations and used after the loop. This is why in loop1_exit_bb we    may need both entry_phis (created by slpeel_update_phi_nodes_for_guard1)    and exit phis (created by slpeel_update_phi_nodes_for_guard2).     - IS_NEW_LOOP: if IS_NEW_LOOP is true, then LOOP is a newly created copy of      an original loop. i.e., we have:             orig_loop            guard_bb (goto LOOP/new_merge)            new_loop<-- LOOP            new_exit            new_merge            next_bb       If IS_NEW_LOOP is false, then LOOP is an original loop, in which case we      have:             new_loop            guard_bb (goto LOOP/new_merge)            orig_loop<-- LOOP            new_exit            new_merge            next_bb       The SSA names defined in the original loop have a current      reaching definition that that records the corresponding new      ssa-name used in the new duplicated loop copy.   */
end_comment

begin_comment
comment|/* Function slpeel_update_phi_nodes_for_guard1        Input:    - GUARD_EDGE, LOOP, IS_NEW_LOOP, NEW_EXIT_BB - as explained above.    - DEFS - a bitmap of ssa names to mark new names for which we recorded             information.         In the context of the overall structure, we have:          loop1_preheader_bb:                  guard1 (goto loop1/merg1_bb) LOOP->  loop1         loop1_exit_bb:                 guard2 (goto merge1_bb/merge2_bb)         merge1_bb         loop2         loop2_exit_bb         merge2_bb         next_bb     For each name updated between loop iterations (i.e - for each name that has    an entry (loop-header) phi in LOOP) we create a new phi in:    1. merge1_bb (to account for the edge from guard1)    2. loop1_exit_bb (an exit-phi to keep LOOP in loop-closed form) */
end_comment

begin_function
specifier|static
name|void
name|slpeel_update_phi_nodes_for_guard1
parameter_list|(
name|edge
name|guard_edge
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
name|is_new_loop
parameter_list|,
name|basic_block
modifier|*
name|new_exit_bb
parameter_list|,
name|bitmap
modifier|*
name|defs
parameter_list|)
block|{
name|tree
name|orig_phi
decl_stmt|,
name|new_phi
decl_stmt|;
name|tree
name|update_phi
decl_stmt|,
name|update_phi2
decl_stmt|;
name|tree
name|guard_arg
decl_stmt|,
name|loop_arg
decl_stmt|;
name|basic_block
name|new_merge_bb
init|=
name|guard_edge
operator|->
name|dest
decl_stmt|;
name|edge
name|e
init|=
name|EDGE_SUCC
argument_list|(
name|new_merge_bb
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|basic_block
name|update_bb
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|basic_block
name|orig_bb
init|=
name|loop
operator|->
name|header
decl_stmt|;
name|edge
name|new_exit_e
decl_stmt|;
name|tree
name|current_new_name
decl_stmt|;
name|tree
name|name
decl_stmt|;
comment|/* Create new bb between loop and new_merge_bb.  */
operator|*
name|new_exit_bb
operator|=
name|split_edge
argument_list|(
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
operator|*
name|new_exit_bb
argument_list|,
name|loop
operator|->
name|outer
argument_list|)
expr_stmt|;
name|new_exit_e
operator|=
name|EDGE_SUCC
argument_list|(
operator|*
name|new_exit_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|orig_phi
operator|=
name|phi_nodes
argument_list|(
name|orig_bb
argument_list|)
operator|,
name|update_phi
operator|=
name|phi_nodes
argument_list|(
name|update_bb
argument_list|)
init|;
name|orig_phi
operator|&&
name|update_phi
condition|;
name|orig_phi
operator|=
name|PHI_CHAIN
argument_list|(
name|orig_phi
argument_list|)
operator|,
name|update_phi
operator|=
name|PHI_CHAIN
argument_list|(
name|update_phi
argument_list|)
control|)
block|{
comment|/* Virtual phi; Mark it for renaming. We actually want to call 	 mar_sym_for_renaming, but since all ssa renaming datastructures 	 are going to be freed before we get to call ssa_upate, we just 	 record this name for now in a bitmap, and will mark it for 	 renaming later.  */
name|name
operator|=
name|PHI_RESULT
argument_list|(
name|orig_phi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|vect_vnames_to_rename
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/** 1. Handle new-merge-point phis  **/
comment|/* 1.1. Generate new phi node in NEW_MERGE_BB:  */
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|orig_phi
argument_list|)
argument_list|)
argument_list|,
name|new_merge_bb
argument_list|)
expr_stmt|;
comment|/* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge             of LOOP. Set the two phi args in NEW_PHI for these edges:  */
name|loop_arg
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|orig_phi
argument_list|,
name|EDGE_SUCC
argument_list|(
name|loop
operator|->
name|latch
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|guard_arg
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|orig_phi
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|loop_arg
argument_list|,
name|new_exit_e
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|guard_arg
argument_list|,
name|guard_edge
argument_list|)
expr_stmt|;
comment|/* 1.3. Update phi in successor block.  */
name|gcc_assert
argument_list|(
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|update_phi
argument_list|,
name|e
argument_list|)
operator|==
name|loop_arg
operator|||
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|update_phi
argument_list|,
name|e
argument_list|)
operator|==
name|guard_arg
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|update_phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
name|update_phi2
operator|=
name|new_phi
expr_stmt|;
comment|/** 2. Handle loop-closed-ssa-form phis  **/
comment|/* 2.1. Generate new phi node in NEW_EXIT_BB:  */
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|orig_phi
argument_list|)
argument_list|)
argument_list|,
operator|*
name|new_exit_bb
argument_list|)
expr_stmt|;
comment|/* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|loop_arg
argument_list|,
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
comment|/* 2.3. Update phi in successor of NEW_EXIT_BB:  */
name|gcc_assert
argument_list|(
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|update_phi2
argument_list|,
name|new_exit_e
argument_list|)
operator|==
name|loop_arg
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|update_phi2
argument_list|,
name|new_exit_e
operator|->
name|dest_idx
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 2.4. Record the newly created name with set_current_def.          We want to find a name such that                 name = get_current_def (orig_loop_name)          and to set its current definition as follows:                 set_current_def (name, new_phi_name)           If LOOP is a new loop then loop_arg is already the name we're          looking for. If LOOP is the original loop, then loop_arg is          the orig_loop_name and the relevant name is recorded in its          current reaching definition.  */
if|if
condition|(
name|is_new_loop
condition|)
name|current_new_name
operator|=
name|loop_arg
expr_stmt|;
else|else
block|{
name|current_new_name
operator|=
name|get_current_def
argument_list|(
name|loop_arg
argument_list|)
expr_stmt|;
comment|/* current_def is not available only if the variable does not 	     change inside the loop, in which case we also don't care 	     about recording a current_def for it because we won't be 	     trying to create loop-exit-phis for it.  */
if|if
condition|(
operator|!
name|current_new_name
condition|)
continue|continue;
block|}
name|gcc_assert
argument_list|(
name|get_current_def
argument_list|(
name|current_new_name
argument_list|)
operator|==
name|NULL_TREE
argument_list|)
expr_stmt|;
name|set_current_def
argument_list|(
name|current_new_name
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|*
name|defs
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|current_new_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|set_phi_nodes
argument_list|(
name|new_merge_bb
argument_list|,
name|phi_reverse
argument_list|(
name|phi_nodes
argument_list|(
name|new_merge_bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function slpeel_update_phi_nodes_for_guard2     Input:    - GUARD_EDGE, LOOP, IS_NEW_LOOP, NEW_EXIT_BB - as explained above.     In the context of the overall structure, we have:          loop1_preheader_bb:                  guard1 (goto loop1/merg1_bb)         loop1         loop1_exit_bb:                  guard2 (goto merge1_bb/merge2_bb)         merge1_bb LOOP->  loop2         loop2_exit_bb         merge2_bb         next_bb     For each name used out side the loop (i.e - for each name that has an exit    phi in next_bb) we create a new phi in:    1. merge2_bb (to account for the edge from guard_bb)     2. loop2_exit_bb (an exit-phi to keep LOOP in loop-closed form)    3. guard2 bb (an exit phi to keep the preceding loop in loop-closed form),       if needed (if it wasn't handled by slpeel_update_phis_nodes_for_phi1). */
end_comment

begin_function
specifier|static
name|void
name|slpeel_update_phi_nodes_for_guard2
parameter_list|(
name|edge
name|guard_edge
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|bool
name|is_new_loop
parameter_list|,
name|basic_block
modifier|*
name|new_exit_bb
parameter_list|)
block|{
name|tree
name|orig_phi
decl_stmt|,
name|new_phi
decl_stmt|;
name|tree
name|update_phi
decl_stmt|,
name|update_phi2
decl_stmt|;
name|tree
name|guard_arg
decl_stmt|,
name|loop_arg
decl_stmt|;
name|basic_block
name|new_merge_bb
init|=
name|guard_edge
operator|->
name|dest
decl_stmt|;
name|edge
name|e
init|=
name|EDGE_SUCC
argument_list|(
name|new_merge_bb
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|basic_block
name|update_bb
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|edge
name|new_exit_e
decl_stmt|;
name|tree
name|orig_def
decl_stmt|,
name|orig_def_new_name
decl_stmt|;
name|tree
name|new_name
decl_stmt|,
name|new_name2
decl_stmt|;
name|tree
name|arg
decl_stmt|;
comment|/* Create new bb between loop and new_merge_bb.  */
operator|*
name|new_exit_bb
operator|=
name|split_edge
argument_list|(
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
operator|*
name|new_exit_bb
argument_list|,
name|loop
operator|->
name|outer
argument_list|)
expr_stmt|;
name|new_exit_e
operator|=
name|EDGE_SUCC
argument_list|(
operator|*
name|new_exit_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|update_phi
operator|=
name|phi_nodes
argument_list|(
name|update_bb
argument_list|)
init|;
name|update_phi
condition|;
name|update_phi
operator|=
name|PHI_CHAIN
argument_list|(
name|update_phi
argument_list|)
control|)
block|{
name|orig_phi
operator|=
name|update_phi
expr_stmt|;
name|orig_def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|orig_phi
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* This loop-closed-phi actually doesn't represent a use          out of the loop - the phi arg is a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|orig_def
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
name|orig_def_new_name
operator|=
name|get_current_def
argument_list|(
name|orig_def
argument_list|)
expr_stmt|;
name|arg
operator|=
name|NULL_TREE
expr_stmt|;
comment|/** 1. Handle new-merge-point phis  **/
comment|/* 1.1. Generate new phi node in NEW_MERGE_BB:  */
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|orig_phi
argument_list|)
argument_list|)
argument_list|,
name|new_merge_bb
argument_list|)
expr_stmt|;
comment|/* 1.2. NEW_MERGE_BB has two incoming edges: GUARD_EDGE and the exit-edge             of LOOP. Set the two PHI args in NEW_PHI for these edges:  */
name|new_name
operator|=
name|orig_def
expr_stmt|;
name|new_name2
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|orig_def_new_name
condition|)
block|{
name|new_name
operator|=
name|orig_def_new_name
expr_stmt|;
comment|/* Some variables have both loop-entry-phis and loop-exit-phis. 	     Such variables were given yet newer names by phis placed in 	     guard_bb by slpeel_update_phi_nodes_for_guard1. I.e: 	     new_name2 = get_current_def (get_current_def (orig_name)).  */
name|new_name2
operator|=
name|get_current_def
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_new_loop
condition|)
block|{
name|guard_arg
operator|=
name|orig_def
expr_stmt|;
name|loop_arg
operator|=
name|new_name
expr_stmt|;
block|}
else|else
block|{
name|guard_arg
operator|=
name|new_name
expr_stmt|;
name|loop_arg
operator|=
name|orig_def
expr_stmt|;
block|}
if|if
condition|(
name|new_name2
condition|)
name|guard_arg
operator|=
name|new_name2
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|loop_arg
argument_list|,
name|new_exit_e
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|guard_arg
argument_list|,
name|guard_edge
argument_list|)
expr_stmt|;
comment|/* 1.3. Update phi in successor block.  */
name|gcc_assert
argument_list|(
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|update_phi
argument_list|,
name|e
argument_list|)
operator|==
name|orig_def
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|update_phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
name|update_phi2
operator|=
name|new_phi
expr_stmt|;
comment|/** 2. Handle loop-closed-ssa-form phis  **/
comment|/* 2.1. Generate new phi node in NEW_EXIT_BB:  */
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|orig_phi
argument_list|)
argument_list|)
argument_list|,
operator|*
name|new_exit_bb
argument_list|)
expr_stmt|;
comment|/* 2.2. NEW_EXIT_BB has one incoming edge: the exit-edge of the loop.  */
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|loop_arg
argument_list|,
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
comment|/* 2.3. Update phi in successor of NEW_EXIT_BB:  */
name|gcc_assert
argument_list|(
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|update_phi2
argument_list|,
name|new_exit_e
argument_list|)
operator|==
name|loop_arg
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|update_phi2
argument_list|,
name|new_exit_e
operator|->
name|dest_idx
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/** 3. Handle loop-closed-ssa-form phis for first loop  **/
comment|/* 3.1. Find the relevant names that need an exit-phi in 	 GUARD_BB, i.e. names for which 	 slpeel_update_phi_nodes_for_guard1 had not already created a 	 phi node. This is the case for names that are used outside 	 the loop (and therefore need an exit phi) but are not updated 	 across loop iterations (and therefore don't have a 	 loop-header-phi).  	 slpeel_update_phi_nodes_for_guard1 is responsible for 	 creating loop-exit phis in GUARD_BB for names that have a 	 loop-header-phi.  When such a phi is created we also record 	 the new name in its current definition.  If this new name 	 exists, then guard_arg was set to this new name (see 1.2 	 above).  Therefore, if guard_arg is not this new name, this 	 is an indication that an exit-phi in GUARD_BB was not yet 	 created, so we take care of it here.  */
if|if
condition|(
name|guard_arg
operator|==
name|new_name2
condition|)
continue|continue;
name|arg
operator|=
name|guard_arg
expr_stmt|;
comment|/* 3.2. Generate new phi node in GUARD_BB:  */
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|orig_phi
argument_list|)
argument_list|)
argument_list|,
name|guard_edge
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* 3.3. GUARD_BB has one incoming edge:  */
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|guard_edge
operator|->
name|src
operator|->
name|preds
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|arg
argument_list|,
name|EDGE_PRED
argument_list|(
name|guard_edge
operator|->
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 3.4. Update phi in successor of GUARD_BB:  */
name|gcc_assert
argument_list|(
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|update_phi2
argument_list|,
name|guard_edge
argument_list|)
operator|==
name|guard_arg
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|update_phi2
argument_list|,
name|guard_edge
operator|->
name|dest_idx
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|set_phi_nodes
argument_list|(
name|new_merge_bb
argument_list|,
name|phi_reverse
argument_list|(
name|phi_nodes
argument_list|(
name|new_merge_bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the LOOP iterate NITERS times. This is done by adding a new IV    that starts at zero, increases by one and its limit is NITERS.     Assumption: the exit-condition of LOOP is the last stmt in the loop.  */
end_comment

begin_function
name|void
name|slpeel_make_loop_iterate_ntimes
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|niters
parameter_list|)
block|{
name|tree
name|indx_before_incr
decl_stmt|,
name|indx_after_incr
decl_stmt|,
name|cond_stmt
decl_stmt|,
name|cond
decl_stmt|;
name|tree
name|orig_cond
decl_stmt|;
name|edge
name|exit_edge
init|=
name|loop
operator|->
name|single_exit
decl_stmt|;
name|block_stmt_iterator
name|loop_cond_bsi
decl_stmt|;
name|block_stmt_iterator
name|incr_bsi
decl_stmt|;
name|bool
name|insert_after
decl_stmt|;
name|tree
name|begin_label
init|=
name|tree_block_label
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
decl_stmt|;
name|tree
name|exit_label
init|=
name|tree_block_label
argument_list|(
name|loop
operator|->
name|single_exit
operator|->
name|dest
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|step
init|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|then_label
decl_stmt|;
name|tree
name|else_label
decl_stmt|;
name|LOC
name|loop_loc
decl_stmt|;
name|orig_cond
operator|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|orig_cond
argument_list|)
expr_stmt|;
name|loop_cond_bsi
operator|=
name|bsi_for_stmt
argument_list|(
name|orig_cond
argument_list|)
expr_stmt|;
name|standard_iv_increment_position
argument_list|(
name|loop
argument_list|,
operator|&
name|incr_bsi
argument_list|,
operator|&
name|insert_after
argument_list|)
expr_stmt|;
name|create_iv
argument_list|(
name|init
argument_list|,
name|step
argument_list|,
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
operator|&
name|incr_bsi
argument_list|,
name|insert_after
argument_list|,
operator|&
name|indx_before_incr
argument_list|,
operator|&
name|indx_after_incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_edge
operator|->
name|flags
operator|&
name|EDGE_TRUE_VALUE
condition|)
comment|/* 'then' edge exits the loop.  */
block|{
name|cond
operator|=
name|build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|indx_after_incr
argument_list|,
name|niters
argument_list|)
expr_stmt|;
name|then_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|exit_label
argument_list|)
expr_stmt|;
name|else_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 'then' edge loops back.  */
block|{
name|cond
operator|=
name|build2
argument_list|(
name|LT_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|indx_after_incr
argument_list|,
name|niters
argument_list|)
expr_stmt|;
name|then_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
name|else_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|exit_label
argument_list|)
expr_stmt|;
block|}
name|cond_stmt
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|orig_cond
argument_list|)
argument_list|,
name|cond
argument_list|,
name|then_label
argument_list|,
name|else_label
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|loop_cond_bsi
argument_list|,
name|cond_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Remove old loop exit test:  */
name|bsi_remove
argument_list|(
operator|&
name|loop_cond_bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|loop_loc
operator|=
name|find_loop_location
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
if|if
condition|(
name|loop_loc
operator|!=
name|UNKNOWN_LOC
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nloop at %s:%d: "
argument_list|,
name|LOC_FILE
argument_list|(
name|loop_loc
argument_list|)
argument_list|,
name|LOC_LINE
argument_list|(
name|loop_loc
argument_list|)
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|cond_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|loop
operator|->
name|nb_iterations
operator|=
name|niters
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given LOOP this function generates a new copy of it and puts it     on E which is either the entry or exit of LOOP.  */
end_comment

begin_function
specifier|static
name|struct
name|loop
modifier|*
name|slpeel_tree_duplicate_loop_to_edge_cfg
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|new_loop
decl_stmt|;
name|basic_block
modifier|*
name|new_bbs
decl_stmt|,
modifier|*
name|bbs
decl_stmt|;
name|bool
name|at_exit
decl_stmt|;
name|bool
name|was_imm_dom
decl_stmt|;
name|basic_block
name|exit_dest
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|phi_arg
decl_stmt|;
name|at_exit
operator|=
operator|(
name|e
operator|==
name|loop
operator|->
name|single_exit
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|at_exit
operator|&&
name|e
operator|!=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
condition|)
return|return
name|NULL
return|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check whether duplication is possible.  */
if|if
condition|(
operator|!
name|can_copy_bbs_p
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Generate new loop structure.  */
name|new_loop
operator|=
name|duplicate_loop
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|loop
operator|->
name|outer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_loop
condition|)
block|{
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|exit_dest
operator|=
name|loop
operator|->
name|single_exit
operator|->
name|dest
expr_stmt|;
name|was_imm_dom
operator|=
operator|(
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|exit_dest
argument_list|)
operator|==
name|loop
operator|->
name|header
condition|?
name|true
else|:
name|false
operator|)
expr_stmt|;
name|new_bbs
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|)
expr_stmt|;
name|copy_bbs
argument_list|(
name|bbs
argument_list|,
name|loop
operator|->
name|num_nodes
argument_list|,
name|new_bbs
argument_list|,
operator|&
name|loop
operator|->
name|single_exit
argument_list|,
literal|1
argument_list|,
operator|&
name|new_loop
operator|->
name|single_exit
argument_list|,
name|NULL
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* Duplicating phi args at exit bbs as coming       also from exit of duplicated loop.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|exit_dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|phi_arg
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|phi_arg
condition|)
block|{
name|edge
name|new_loop_exit_edge
decl_stmt|;
if|if
condition|(
name|EDGE_SUCC
argument_list|(
name|new_loop
operator|->
name|header
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
operator|==
name|new_loop
operator|->
name|latch
condition|)
name|new_loop_exit_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|new_loop
operator|->
name|header
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|new_loop_exit_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|new_loop
operator|->
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|phi_arg
argument_list|,
name|new_loop_exit_edge
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|at_exit
condition|)
comment|/* Add the loop copy at exit.  */
block|{
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|new_loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_loop
operator|->
name|header
argument_list|,
name|e
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_imm_dom
condition|)
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|exit_dest
argument_list|,
name|new_loop
operator|->
name|header
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Add the copy at entry.  */
block|{
name|edge
name|new_exit_e
decl_stmt|;
name|edge
name|entry_e
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|basic_block
name|preheader
init|=
name|entry_e
operator|->
name|src
decl_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|new_loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|new_loop
operator|->
name|header
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
argument_list|)
condition|)
name|new_exit_e
operator|=
name|EDGE_SUCC
argument_list|(
name|new_loop
operator|->
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|new_exit_e
operator|=
name|EDGE_SUCC
argument_list|(
name|new_loop
operator|->
name|header
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|new_exit_e
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|header
argument_list|,
name|new_exit_e
operator|->
name|src
argument_list|)
expr_stmt|;
comment|/* We have to add phi args to the loop->header here as coming  	 from new_exit_e edge.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|loop
operator|->
name|header
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|phi_arg
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|entry_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|phi_arg
condition|)
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|phi_arg
argument_list|,
name|new_exit_e
argument_list|)
expr_stmt|;
block|}
name|redirect_edge_and_branch_force
argument_list|(
name|entry_e
argument_list|,
name|new_loop
operator|->
name|header
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_loop
operator|->
name|header
argument_list|,
name|preheader
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|new_bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
return|return
name|new_loop
return|;
block|}
end_function

begin_comment
comment|/* Given the condition statement COND, put it as the last statement    of GUARD_BB; EXIT_BB is the basic block to skip the loop;    Assumes that this is the single exit of the guarded loop.      Returns the skip edge.  */
end_comment

begin_function
specifier|static
name|edge
name|slpeel_add_loop_guard
parameter_list|(
name|basic_block
name|guard_bb
parameter_list|,
name|tree
name|cond
parameter_list|,
name|basic_block
name|exit_bb
parameter_list|,
name|basic_block
name|dom_bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge
name|new_e
decl_stmt|,
name|enter_e
decl_stmt|;
name|tree
name|cond_stmt
decl_stmt|,
name|then_label
decl_stmt|,
name|else_label
decl_stmt|;
name|enter_e
operator|=
name|EDGE_SUCC
argument_list|(
name|guard_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enter_e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
name|enter_e
operator|->
name|flags
operator||=
name|EDGE_FALSE_VALUE
expr_stmt|;
name|bsi
operator|=
name|bsi_last
argument_list|(
name|guard_bb
argument_list|)
expr_stmt|;
name|then_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|exit_bb
argument_list|)
argument_list|)
expr_stmt|;
name|else_label
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tree_block_label
argument_list|(
name|enter_e
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|cond_stmt
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|then_label
argument_list|,
name|else_label
argument_list|)
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|bsi
argument_list|,
name|cond_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
comment|/* Add new edge to connect guard block to the merge/loop-exit block.  */
name|new_e
operator|=
name|make_edge
argument_list|(
name|guard_bb
argument_list|,
name|exit_bb
argument_list|,
name|EDGE_TRUE_VALUE
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|exit_bb
argument_list|,
name|dom_bb
argument_list|)
expr_stmt|;
return|return
name|new_e
return|;
block|}
end_function

begin_comment
comment|/* This function verifies that the following restrictions apply to LOOP:    (1) it is innermost    (2) it consists of exactly 2 basic blocks - header, and an empty latch.    (3) it is single entry, single exit    (4) its exit condition is the last stmt in the header    (5) E is the entry/exit edge of LOOP.  */
end_comment

begin_function
name|bool
name|slpeel_can_duplicate_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|edge
name|exit_e
init|=
name|loop
operator|->
name|single_exit
decl_stmt|;
name|edge
name|entry_e
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|tree
name|orig_cond
init|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|block_stmt_iterator
name|loop_exit_bsi
init|=
name|bsi_last
argument_list|(
name|exit_e
operator|->
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_ssa_update_p
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
name|loop
operator|->
name|inner
comment|/* All loops have an outer scope; the only case loop->outer is NULL is for          the function itself.  */
operator|||
operator|!
name|loop
operator|->
name|outer
operator|||
name|loop
operator|->
name|num_nodes
operator|!=
literal|2
operator|||
operator|!
name|empty_block_p
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
operator|||
operator|!
name|loop
operator|->
name|single_exit
comment|/* Verify that new loop exit condition can be trivially modified.  */
operator|||
operator|(
operator|!
name|orig_cond
operator|||
name|orig_cond
operator|!=
name|bsi_stmt
argument_list|(
name|loop_exit_bsi
argument_list|)
operator|)
operator|||
operator|(
name|e
operator|!=
name|exit_e
operator|&&
name|e
operator|!=
name|entry_e
operator|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function
name|void
name|slpeel_verify_cfg_after_peeling
parameter_list|(
name|struct
name|loop
modifier|*
name|first_loop
parameter_list|,
name|struct
name|loop
modifier|*
name|second_loop
parameter_list|)
block|{
name|basic_block
name|loop1_exit_bb
init|=
name|first_loop
operator|->
name|single_exit
operator|->
name|dest
decl_stmt|;
name|basic_block
name|loop2_entry_bb
init|=
name|loop_preheader_edge
argument_list|(
name|second_loop
argument_list|)
operator|->
name|src
decl_stmt|;
name|basic_block
name|loop1_entry_bb
init|=
name|loop_preheader_edge
argument_list|(
name|first_loop
argument_list|)
operator|->
name|src
decl_stmt|;
comment|/* A guard that controls whether the second_loop is to be executed or skipped      is placed in first_loop->exit.  first_loopt->exit therefore has two      successors - one is the preheader of second_loop, and the other is a bb      after second_loop.    */
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|loop1_exit_bb
operator|->
name|succs
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* 1. Verify that one of the successors of first_loopt->exit is the preheader         of second_loop.  */
comment|/* The preheader of new_loop is expected to have two predecessors:      first_loop->exit and the block that precedes first_loop.  */
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|loop2_entry_bb
operator|->
name|preds
argument_list|)
operator|==
literal|2
operator|&&
operator|(
operator|(
name|EDGE_PRED
argument_list|(
name|loop2_entry_bb
argument_list|,
literal|0
argument_list|)
operator|->
name|src
operator|==
name|loop1_exit_bb
operator|&&
name|EDGE_PRED
argument_list|(
name|loop2_entry_bb
argument_list|,
literal|1
argument_list|)
operator|->
name|src
operator|==
name|loop1_entry_bb
operator|)
operator|||
operator|(
name|EDGE_PRED
argument_list|(
name|loop2_entry_bb
argument_list|,
literal|1
argument_list|)
operator|->
name|src
operator|==
name|loop1_exit_bb
operator|&&
name|EDGE_PRED
argument_list|(
name|loop2_entry_bb
argument_list|,
literal|0
argument_list|)
operator|->
name|src
operator|==
name|loop1_entry_bb
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Verify that the other successor of first_loopt->exit is after the      second_loop.  */
comment|/* TODO */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function slpeel_tree_peel_loop_to_edge.     Peel the first (last) iterations of LOOP into a new prolog (epilog) loop    that is placed on the entry (exit) edge E of LOOP. After this transformation    we have two loops one after the other - first-loop iterates FIRST_NITERS    times, and second-loop iterates the remainder NITERS - FIRST_NITERS times.     Input:    - LOOP: the loop to be peeled.    - E: the exit or entry edge of LOOP.         If it is the entry edge, we peel the first iterations of LOOP. In this         case first-loop is LOOP, and second-loop is the newly created loop.         If it is the exit edge, we peel the last iterations of LOOP. In this         case, first-loop is the newly created loop, and second-loop is LOOP.    - NITERS: the number of iterations that LOOP iterates.    - FIRST_NITERS: the number of iterations that the first-loop should iterate.    - UPDATE_FIRST_LOOP_COUNT:  specified whether this function is responsible         for updating the loop bound of the first-loop to FIRST_NITERS.  If it         is false, the caller of this function may want to take care of this         (this can be useful if we don't want new stmts added to first-loop).     Output:    The function returns a pointer to the new loop-copy, or NULL if it failed    to perform the transformation.     The function generates two if-then-else guards: one before the first loop,    and the other before the second loop:    The first guard is:      if (FIRST_NITERS == 0) then skip the first loop,      and go directly to the second loop.    The second guard is:      if (FIRST_NITERS == NITERS) then skip the second loop.     FORNOW only simple loops are supported (see slpeel_can_duplicate_loop_p).    FORNOW the resulting code will not be in loop-closed-ssa form. */
end_comment

begin_function
name|struct
name|loop
modifier|*
name|slpeel_tree_peel_loop_to_edge
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|edge
name|e
parameter_list|,
name|tree
name|first_niters
parameter_list|,
name|tree
name|niters
parameter_list|,
name|bool
name|update_first_loop_count
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|new_loop
init|=
name|NULL
decl_stmt|,
modifier|*
name|first_loop
decl_stmt|,
modifier|*
name|second_loop
decl_stmt|;
name|edge
name|skip_e
decl_stmt|;
name|tree
name|pre_condition
decl_stmt|;
name|bitmap
name|definitions
decl_stmt|;
name|basic_block
name|bb_before_second_loop
decl_stmt|,
name|bb_after_second_loop
decl_stmt|;
name|basic_block
name|bb_before_first_loop
decl_stmt|;
name|basic_block
name|bb_between_loops
decl_stmt|;
name|basic_block
name|new_exit_bb
decl_stmt|;
name|edge
name|exit_e
init|=
name|loop
operator|->
name|single_exit
decl_stmt|;
name|LOC
name|loop_loc
decl_stmt|;
if|if
condition|(
operator|!
name|slpeel_can_duplicate_loop_p
argument_list|(
name|loop
argument_list|,
name|e
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* We have to initialize cfg_hooks. Then, when calling    cfg_hooks->split_edge, the function tree_split_edge     is actually called and, when calling cfg_hooks->duplicate_block,    the function tree_duplicate_bb is called.  */
name|tree_register_cfg_hooks
argument_list|()
expr_stmt|;
comment|/* 1. Generate a copy of LOOP and put it on E (E is the entry/exit of LOOP).         Resulting CFG would be:          first_loop:         do {         } while ...          second_loop:         do {         } while ...          orig_exit_bb:    */
if|if
condition|(
operator|!
operator|(
name|new_loop
operator|=
name|slpeel_tree_duplicate_loop_to_edge_cfg
argument_list|(
name|loop
argument_list|,
name|loops
argument_list|,
name|e
argument_list|)
operator|)
condition|)
block|{
name|loop_loc
operator|=
name|find_loop_location
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
if|if
condition|(
name|loop_loc
operator|!=
name|UNKNOWN_LOC
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n%s:%d: note: "
argument_list|,
name|LOC_FILE
argument_list|(
name|loop_loc
argument_list|)
argument_list|,
name|LOC_LINE
argument_list|(
name|loop_loc
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"tree_duplicate_loop_to_edge_cfg failed.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|e
operator|==
name|exit_e
condition|)
block|{
comment|/* NEW_LOOP was placed after LOOP.  */
name|first_loop
operator|=
name|loop
expr_stmt|;
name|second_loop
operator|=
name|new_loop
expr_stmt|;
block|}
else|else
block|{
comment|/* NEW_LOOP was placed before LOOP.  */
name|first_loop
operator|=
name|new_loop
expr_stmt|;
name|second_loop
operator|=
name|loop
expr_stmt|;
block|}
name|definitions
operator|=
name|ssa_names_to_replace
argument_list|()
expr_stmt|;
name|slpeel_update_phis_for_duplicate_loop
argument_list|(
name|loop
argument_list|,
name|new_loop
argument_list|,
name|e
operator|==
name|exit_e
argument_list|)
expr_stmt|;
name|rename_variables_in_loop
argument_list|(
name|new_loop
argument_list|)
expr_stmt|;
comment|/* 2. Add the guard that controls whether the first loop is executed.         Resulting CFG would be:          bb_before_first_loop:         if (FIRST_NITERS == 0) GOTO bb_before_second_loop                                GOTO first-loop          first_loop:         do {         } while ...          bb_before_second_loop:          second_loop:         do {         } while ...          orig_exit_bb:    */
name|bb_before_first_loop
operator|=
name|split_edge
argument_list|(
name|loop_preheader_edge
argument_list|(
name|first_loop
argument_list|)
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|bb_before_first_loop
argument_list|,
name|first_loop
operator|->
name|outer
argument_list|)
expr_stmt|;
name|bb_before_second_loop
operator|=
name|split_edge
argument_list|(
name|first_loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|bb_before_second_loop
argument_list|,
name|first_loop
operator|->
name|outer
argument_list|)
expr_stmt|;
name|pre_condition
operator|=
name|fold_build2
argument_list|(
name|LE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|first_niters
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|first_niters
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|skip_e
operator|=
name|slpeel_add_loop_guard
argument_list|(
name|bb_before_first_loop
argument_list|,
name|pre_condition
argument_list|,
name|bb_before_second_loop
argument_list|,
name|bb_before_first_loop
argument_list|)
expr_stmt|;
name|slpeel_update_phi_nodes_for_guard1
argument_list|(
name|skip_e
argument_list|,
name|first_loop
argument_list|,
name|first_loop
operator|==
name|new_loop
argument_list|,
operator|&
name|new_exit_bb
argument_list|,
operator|&
name|definitions
argument_list|)
expr_stmt|;
comment|/* 3. Add the guard that controls whether the second loop is executed.         Resulting CFG would be:          bb_before_first_loop:         if (FIRST_NITERS == 0) GOTO bb_before_second_loop (skip first loop)                                GOTO first-loop          first_loop:         do {         } while ...          bb_between_loops:         if (FIRST_NITERS == NITERS) GOTO bb_after_second_loop (skip second loop)                                     GOTO bb_before_second_loop          bb_before_second_loop:          second_loop:         do {         } while ...          bb_after_second_loop:          orig_exit_bb:    */
name|bb_between_loops
operator|=
name|new_exit_bb
expr_stmt|;
name|bb_after_second_loop
operator|=
name|split_edge
argument_list|(
name|second_loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|bb_after_second_loop
argument_list|,
name|second_loop
operator|->
name|outer
argument_list|)
expr_stmt|;
name|pre_condition
operator|=
name|fold_build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|first_niters
argument_list|,
name|niters
argument_list|)
expr_stmt|;
name|skip_e
operator|=
name|slpeel_add_loop_guard
argument_list|(
name|bb_between_loops
argument_list|,
name|pre_condition
argument_list|,
name|bb_after_second_loop
argument_list|,
name|bb_before_first_loop
argument_list|)
expr_stmt|;
name|slpeel_update_phi_nodes_for_guard2
argument_list|(
name|skip_e
argument_list|,
name|second_loop
argument_list|,
name|second_loop
operator|==
name|new_loop
argument_list|,
operator|&
name|new_exit_bb
argument_list|)
expr_stmt|;
comment|/* 4. Make first-loop iterate FIRST_NITERS times, if requested.    */
if|if
condition|(
name|update_first_loop_count
condition|)
name|slpeel_make_loop_iterate_ntimes
argument_list|(
name|first_loop
argument_list|,
name|first_niters
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|definitions
argument_list|)
expr_stmt|;
name|delete_update_ssa
argument_list|()
expr_stmt|;
return|return
name|new_loop
return|;
block|}
end_function

begin_comment
comment|/* Function vect_get_loop_location.     Extract the location of the loop in the source code.    If the loop is not well formed for vectorization, an estimated    location is calculated.    Return the loop location if succeed and NULL if not.  */
end_comment

begin_function
name|LOC
name|find_loop_location
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|node
init|=
name|NULL_TREE
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
return|return
name|UNKNOWN_LOC
return|;
name|node
operator|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|&&
name|EXPR_P
argument_list|(
name|node
argument_list|)
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|node
argument_list|)
operator|&&
name|EXPR_FILENAME
argument_list|(
name|node
argument_list|)
operator|&&
name|EXPR_LINENO
argument_list|(
name|node
argument_list|)
condition|)
return|return
name|EXPR_LOC
argument_list|(
name|node
argument_list|)
return|;
comment|/* If we got here the loop is probably not "well formed",      try to estimate the loop location */
if|if
condition|(
operator|!
name|loop
operator|->
name|header
condition|)
return|return
name|UNKNOWN_LOC
return|;
name|bb
operator|=
name|loop
operator|->
name|header
expr_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|node
operator|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|&&
name|EXPR_P
argument_list|(
name|node
argument_list|)
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
name|node
argument_list|)
condition|)
return|return
name|EXPR_LOC
argument_list|(
name|node
argument_list|)
return|;
block|}
return|return
name|UNKNOWN_LOC
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************   Vectorization Debug Information.  *************************************************************************/
end_comment

begin_comment
comment|/* Function vect_set_verbosity_level.     Called from toplev.c upon detection of the    -ftree-vectorizer-verbose=N option.  */
end_comment

begin_function
name|void
name|vect_set_verbosity_level
parameter_list|(
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|unsigned
name|int
name|vl
decl_stmt|;
name|vl
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|vl
operator|<
name|MAX_VERBOSITY_LEVEL
condition|)
name|vect_verbosity_level
operator|=
name|vl
expr_stmt|;
else|else
name|vect_verbosity_level
operator|=
name|MAX_VERBOSITY_LEVEL
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_set_dump_settings.     Fix the verbosity level of the vectorizer if the    requested level was not set explicitly using the flag    -ftree-vectorizer-verbose=N.    Decide where to print the debugging information (dump_file/stderr).    If the user defined the verbosity level, but there is no dump file,    print to stderr, otherwise print to the dump file.  */
end_comment

begin_function
specifier|static
name|void
name|vect_set_dump_settings
parameter_list|(
name|void
parameter_list|)
block|{
name|vect_dump
operator|=
name|dump_file
expr_stmt|;
comment|/* Check if the verbosity level was defined by the user:  */
if|if
condition|(
name|vect_verbosity_level
operator|!=
name|MAX_VERBOSITY_LEVEL
condition|)
block|{
comment|/* If there is no dump file, print to stderr.  */
if|if
condition|(
operator|!
name|dump_file
condition|)
name|vect_dump
operator|=
name|stderr
expr_stmt|;
return|return;
block|}
comment|/* User didn't specify verbosity level:  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|vect_verbosity_level
operator|=
name|REPORT_DETAILS
expr_stmt|;
elseif|else
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|vect_verbosity_level
operator|=
name|REPORT_UNVECTORIZED_LOOPS
expr_stmt|;
else|else
name|vect_verbosity_level
operator|=
name|REPORT_NONE
expr_stmt|;
name|gcc_assert
argument_list|(
name|dump_file
operator|||
name|vect_verbosity_level
operator|==
name|REPORT_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function debug_loop_details.     For vectorization debug dumps.  */
end_comment

begin_function
name|bool
name|vect_print_dump_info
parameter_list|(
name|enum
name|verbosity_levels
name|vl
parameter_list|)
block|{
if|if
condition|(
name|vl
operator|>
name|vect_verbosity_level
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|current_function_decl
operator|||
operator|!
name|vect_dump
condition|)
return|return
name|false
return|;
if|if
condition|(
name|vect_loop_location
operator|==
name|UNKNOWN_LOC
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"\n%s:%d: note: "
argument_list|,
name|DECL_SOURCE_FILE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"\n%s:%d: note: "
argument_list|,
name|LOC_FILE
argument_list|(
name|vect_loop_location
argument_list|)
argument_list|,
name|LOC_LINE
argument_list|(
name|vect_loop_location
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************   Vectorization Utilities.  *************************************************************************/
end_comment

begin_comment
comment|/* Function new_stmt_vec_info.     Create and initialize a new stmt_vec_info struct for STMT.  */
end_comment

begin_function
name|stmt_vec_info
name|new_stmt_vec_info
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|stmt_vec_info
name|res
decl_stmt|;
name|res
operator|=
operator|(
name|stmt_vec_info
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_stmt_vec_info
argument_list|)
argument_list|)
expr_stmt|;
name|STMT_VINFO_TYPE
argument_list|(
name|res
argument_list|)
operator|=
name|undef_vec_info_type
expr_stmt|;
name|STMT_VINFO_STMT
argument_list|(
name|res
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|res
argument_list|)
operator|=
name|loop_vinfo
expr_stmt|;
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|res
argument_list|)
operator|=
literal|0
expr_stmt|;
name|STMT_VINFO_LIVE_P
argument_list|(
name|res
argument_list|)
operator|=
literal|0
expr_stmt|;
name|STMT_VINFO_VECTYPE
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|STMT_VINFO_VEC_STMT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|res
argument_list|)
operator|=
name|false
expr_stmt|;
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|STMT_VINFO_DATA_REF
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|res
argument_list|)
operator|=
name|vect_unknown_def_type
expr_stmt|;
else|else
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|res
argument_list|)
operator|=
name|vect_loop_def
expr_stmt|;
name|STMT_VINFO_SAME_ALIGN_REFS
argument_list|(
name|res
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|dr_p
argument_list|,
name|heap
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Function new_loop_vec_info.     Create and initialize a new loop_vec_info struct for LOOP, as well as    stmt_vec_info structs for all the stmts in LOOP.  */
end_comment

begin_function
name|loop_vec_info
name|new_loop_vec_info
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|loop_vec_info
name|res
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|res
operator|=
operator|(
name|loop_vec_info
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_loop_vec_info
argument_list|)
argument_list|)
expr_stmt|;
name|bbs
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Create stmt_info for all stmts in the loop.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|bbs
index|[
name|i
index|]
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|stmt_ann_t
name|ann
init|=
name|get_stmt_ann
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|set_stmt_info
argument_list|(
name|ann
argument_list|,
name|new_stmt_vec_info
argument_list|(
name|phi
argument_list|,
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|stmt_ann_t
name|ann
decl_stmt|;
name|ann
operator|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|set_stmt_info
argument_list|(
name|ann
argument_list|,
name|new_stmt_vec_info
argument_list|(
name|stmt
argument_list|,
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LOOP_VINFO_LOOP
argument_list|(
name|res
argument_list|)
operator|=
name|loop
expr_stmt|;
name|LOOP_VINFO_BBS
argument_list|(
name|res
argument_list|)
operator|=
name|bbs
expr_stmt|;
name|LOOP_VINFO_EXIT_COND
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|LOOP_VINFO_NITERS
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|LOOP_VINFO_VECTORIZABLE_P
argument_list|(
name|res
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOOP_PEELING_FOR_ALIGNMENT
argument_list|(
name|res
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|res
argument_list|)
operator|=
literal|0
expr_stmt|;
name|LOOP_VINFO_DATAREFS
argument_list|(
name|res
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|LOOP_VINFO_DDRS
argument_list|(
name|res
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|ddr_p
argument_list|,
name|heap
argument_list|,
literal|10
operator|*
literal|10
argument_list|)
expr_stmt|;
name|LOOP_VINFO_UNALIGNED_DR
argument_list|(
name|res
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|res
argument_list|)
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|PARAM_VALUE
argument_list|(
name|PARAM_VECT_MAX_VERSION_CHECKS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Function destroy_loop_vec_info.      Free LOOP_VINFO struct, as well as all the stmt_vec_info structs of all the     stmts in the loop.  */
end_comment

begin_function
name|void
name|destroy_loop_vec_info
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|;
name|int
name|nbbs
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|loop_vinfo
condition|)
return|return;
name|loop
operator|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|bbs
operator|=
name|LOOP_VINFO_BBS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|nbbs
operator|=
name|loop
operator|->
name|num_nodes
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nbbs
condition|;
name|j
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|bbs
index|[
name|j
index|]
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|stmt_vec_info
name|stmt_info
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|set_stmt_info
argument_list|(
name|ann
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|stmt_info
condition|)
block|{
comment|/* Check if this is a "pattern stmt" (introduced by the  		 vectorizer during the pattern recognition pass).  */
name|bool
name|remove_stmt_p
init|=
name|false
decl_stmt|;
name|tree
name|orig_stmt
init|=
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|orig_stmt
condition|)
block|{
name|stmt_vec_info
name|orig_stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|orig_stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|orig_stmt_info
operator|&&
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|orig_stmt_info
argument_list|)
condition|)
name|remove_stmt_p
operator|=
name|true
expr_stmt|;
block|}
comment|/* Free stmt_vec_info.  */
name|VEC_free
argument_list|(
name|dr_p
argument_list|,
name|heap
argument_list|,
name|STMT_VINFO_SAME_ALIGN_REFS
argument_list|(
name|stmt_info
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|set_stmt_info
argument_list|(
name|ann
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Remove dead "pattern stmts".  */
if|if
condition|(
name|remove_stmt_p
condition|)
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|LOOP_VINFO_BBS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|free_data_refs
argument_list|(
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|free_dependence_relations
argument_list|(
name|LOOP_VINFO_DDRS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_force_dr_alignment_p.     Returns whether the alignment of a DECL can be forced to be aligned    on ALIGNMENT bit boundary.  */
end_comment

begin_function
name|bool
name|vect_can_force_dr_alignment_p
parameter_list|(
name|tree
name|decl
parameter_list|,
name|unsigned
name|int
name|alignment
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return
operator|(
name|alignment
operator|<=
name|MAX_OFILE_ALIGNMENT
operator|)
return|;
else|else
comment|/* This is not 100% correct.  The absolute correct stack alignment        is STACK_BOUNDARY.  We're supposed to hope, but not assume, that        PREFERRED_STACK_BOUNDARY is honored by all translation units.        However, until someone implements forced stack alignment, SSE        isn't really usable without this.  */
return|return
operator|(
name|alignment
operator|<=
name|PREFERRED_STACK_BOUNDARY
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function get_vectype_for_scalar_type.     Returns the vector type corresponding to SCALAR_TYPE as supported    by the target.  */
end_comment

begin_function
name|tree
name|get_vectype_for_scalar_type
parameter_list|(
name|tree
name|scalar_type
parameter_list|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|TYPE_MODE
argument_list|(
name|scalar_type
argument_list|)
decl_stmt|;
name|int
name|nbytes
init|=
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
decl_stmt|;
name|int
name|nunits
decl_stmt|;
name|tree
name|vectype
decl_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
operator|||
name|nbytes
operator|>=
name|UNITS_PER_SIMD_WORD
condition|)
return|return
name|NULL_TREE
return|;
comment|/* FORNOW: Only a single vector size per target (UNITS_PER_SIMD_WORD)      is expected.  */
name|nunits
operator|=
name|UNITS_PER_SIMD_WORD
operator|/
name|nbytes
expr_stmt|;
name|vectype
operator|=
name|build_vector_type
argument_list|(
name|scalar_type
argument_list|,
name|nunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"get vectype with %d units of type "
argument_list|,
name|nunits
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|scalar_type
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vectype
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vectype: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|vectype
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
argument_list|)
operator|&&
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"mode not supported by target."
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
return|return
name|vectype
return|;
block|}
end_function

begin_comment
comment|/* Function vect_supportable_dr_alignment     Return whether the data reference DR is supported with respect to its    alignment.  */
end_comment

begin_function
name|enum
name|dr_alignment_support
name|vect_supportable_dr_alignment
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|)
block|{
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|vinfo_for_stmt
argument_list|(
name|DR_STMT
argument_list|(
name|dr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
decl_stmt|;
if|if
condition|(
name|aligned_access_p
argument_list|(
name|dr
argument_list|)
condition|)
return|return
name|dr_aligned
return|;
comment|/* Possibly unaligned access.  */
if|if
condition|(
name|DR_IS_READ
argument_list|(
name|dr
argument_list|)
condition|)
block|{
if|if
condition|(
name|vec_realign_load_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|!
name|targetm
operator|.
name|vectorize
operator|.
name|builtin_mask_for_load
operator|||
name|targetm
operator|.
name|vectorize
operator|.
name|builtin_mask_for_load
argument_list|()
operator|)
condition|)
return|return
name|dr_unaligned_software_pipeline
return|;
if|if
condition|(
name|movmisalign_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
comment|/* Can't software pipeline the loads, but can at least do them.  */
return|return
name|dr_unaligned_supported
return|;
block|}
comment|/* Unsupported.  */
return|return
name|dr_unaligned_unsupported
return|;
block|}
end_function

begin_comment
comment|/* Function vect_is_simple_use.     Input:    LOOP - the loop that is being vectorized.    OPERAND - operand of a stmt in LOOP.    DEF - the defining stmt in case OPERAND is an SSA_NAME.     Returns whether a stmt with OPERAND can be vectorized.    Supportable operands are constants, loop invariants, and operands that are    defined by the current iteration of the loop. Unsupportable operands are     those that are defined by a previous iteration of the loop (as is the case    in reduction/induction computations).  */
end_comment

begin_function
name|bool
name|vect_is_simple_use
parameter_list|(
name|tree
name|operand
parameter_list|,
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|tree
modifier|*
name|def_stmt
parameter_list|,
name|tree
modifier|*
name|def
parameter_list|,
name|enum
name|vect_def_type
modifier|*
name|dt
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|stmt_vec_info
name|stmt_vinfo
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
operator|*
name|def_stmt
operator|=
name|NULL_TREE
expr_stmt|;
operator|*
name|def
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vect_is_simple_use: operand "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operand
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
operator|*
name|dt
operator|=
name|vect_constant_def
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not ssa-name."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|def_stmt
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"no def_stmt."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"def_stmt: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
operator|*
name|def_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* empty stmt is expected only in case of a function argument.      (Otherwise - we expect a phi_node or a modify_expr).  */
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
operator|*
name|def_stmt
argument_list|)
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|def_stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
operator|*
name|def
operator|=
name|operand
expr_stmt|;
operator|*
name|dt
operator|=
name|vect_invariant_def
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Unexpected empty stmt."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bb
operator|=
name|bb_for_stmt
argument_list|(
operator|*
name|def_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
operator|*
name|dt
operator|=
name|vect_invariant_def
expr_stmt|;
else|else
block|{
name|stmt_vinfo
operator|=
name|vinfo_for_stmt
argument_list|(
operator|*
name|def_stmt
argument_list|)
expr_stmt|;
operator|*
name|dt
operator|=
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_vinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|dt
operator|==
name|vect_unknown_def_type
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Unsupported pattern."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* stmts inside the loop that have been identified as performing      a reduction operation cannot have uses in the loop.  */
if|if
condition|(
operator|*
name|dt
operator|==
name|vect_reduction_def
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|def_stmt
argument_list|)
operator|!=
name|PHI_NODE
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction used in loop."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"type of def: %d."
argument_list|,
operator|*
name|dt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|def_stmt
argument_list|)
condition|)
block|{
case|case
name|PHI_NODE
case|:
operator|*
name|def
operator|=
name|PHI_RESULT
argument_list|(
operator|*
name|def_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|dt
operator|==
name|vect_induction_def
operator|||
operator|*
name|dt
operator|==
name|vect_reduction_def
operator|||
operator|*
name|dt
operator|==
name|vect_invariant_def
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
operator|*
name|def
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|def_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|dt
operator|==
name|vect_loop_def
operator|||
operator|*
name|dt
operator|==
name|vect_invariant_def
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"unsupported defining stmt: "
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|*
name|dt
operator|==
name|vect_induction_def
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"induction not supported."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function reduction_code_for_scalar_code     Input:    CODE - tree_code of a reduction operations.     Output:    REDUC_CODE - the corresponding tree-code to be used to reduce the       vector of partial results into a single scalar result (which       will also reside in a vector).     Return TRUE if a corresponding REDUC_CODE was found, FALSE otherwise.  */
end_comment

begin_function
name|bool
name|reduction_code_for_scalar_code
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|enum
name|tree_code
modifier|*
name|reduc_code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MAX_EXPR
case|:
operator|*
name|reduc_code
operator|=
name|REDUC_MAX_EXPR
expr_stmt|;
return|return
name|true
return|;
case|case
name|MIN_EXPR
case|:
operator|*
name|reduc_code
operator|=
name|REDUC_MIN_EXPR
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS_EXPR
case|:
operator|*
name|reduc_code
operator|=
name|REDUC_PLUS_EXPR
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function vect_is_simple_reduction     Detect a cross-iteration def-use cucle that represents a simple    reduction computation. We look for the following pattern:     loop_header:      a1 = phi< a0, a2>      a3 = ...      a2 = operation (a3, a1)       such that:    1. operation is commutative and associative and it is safe to        change the order of the computation.    2. no uses for a2 in the loop (a2 is used out of the loop)    3. no uses of a1 in the loop besides the reduction operation.     Condition 1 is tested here.    Conditions 2,3 are tested in vect_mark_stmts_to_be_vectorized.  */
end_comment

begin_function
name|tree
name|vect_is_simple_reduction
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|phi
parameter_list|)
block|{
name|edge
name|latch_e
init|=
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|tree
name|loop_arg
init|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|latch_e
argument_list|)
decl_stmt|;
name|tree
name|def_stmt
decl_stmt|,
name|def1
decl_stmt|,
name|def2
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|tree
name|operation
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|loop_arg
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: not ssa_name: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|loop_arg
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
name|def_stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|loop_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def_stmt
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: no def_stmt."
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|def_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
name|operation
operator|=
name|TREE_OPERAND
argument_list|(
name|def_stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|commutative_tree_code
argument_list|(
name|code
argument_list|)
operator|||
operator|!
name|associative_tree_code
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: not commutative/associative: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
name|op_type
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_type
operator|!=
name|binary_op
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: not binary operation: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|SSA_NAME
operator|||
name|TREE_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: uses not ssa_names: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Check that it's ok to change the order of the computation.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|operation
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: multiple types: operation type: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|type
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|", operands types: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|TREE_TYPE
argument_list|(
name|op2
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* CHECKME: check for !flag_finite_math_only too?  */
if|if
condition|(
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
condition|)
block|{
comment|/* Changing the order of operations changes the semantics.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: unsafe fp math optimization: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_OVERFLOW_TRAPS
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Changing the order of operations changes the semantics.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: unsafe int math optimization: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* reduction is safe. we're dealing with one of the following:      1) integer arithmetic and no trapv      2) floating point arithmetic, and special flags permit this optimization.    */
name|def1
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|def2
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def1
operator|||
operator|!
name|def2
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: no defs for operands: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def1
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb_for_stmt
argument_list|(
name|def1
argument_list|)
argument_list|)
operator|&&
name|def2
operator|==
name|phi
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"detected reduction:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|def_stmt
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def2
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb_for_stmt
argument_list|(
name|def2
argument_list|)
argument_list|)
operator|&&
name|def1
operator|==
name|phi
condition|)
block|{
comment|/* Swap operands (just for simplicity - so that the rest of the code 	 can assume that the reduction variable is always the last (second) 	 argument).  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"detected reduction: need to swap operands:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|swap_tree_operands
argument_list|(
name|def_stmt
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|def_stmt
return|;
block|}
else|else
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduction: unknown pattern."
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|operation
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function vect_is_simple_iv_evolution.     FORNOW: A simple evolution of an induction variables in the loop is    considered a polynomial evolution with constant step.  */
end_comment

begin_function
name|bool
name|vect_is_simple_iv_evolution
parameter_list|(
name|unsigned
name|loop_nb
parameter_list|,
name|tree
name|access_fn
parameter_list|,
name|tree
modifier|*
name|init
parameter_list|,
name|tree
modifier|*
name|step
parameter_list|)
block|{
name|tree
name|init_expr
decl_stmt|;
name|tree
name|step_expr
decl_stmt|;
name|tree
name|evolution_part
init|=
name|evolution_part_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop_nb
argument_list|)
decl_stmt|;
comment|/* When there is no evolution in this loop, the evolution function      is not "simple".  */
if|if
condition|(
name|evolution_part
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
comment|/* When the evolution is a polynomial of degree>= 2      the evolution function is not "simple".  */
if|if
condition|(
name|tree_is_chrec
argument_list|(
name|evolution_part
argument_list|)
condition|)
return|return
name|false
return|;
name|step_expr
operator|=
name|evolution_part
expr_stmt|;
name|init_expr
operator|=
name|unshare_expr
argument_list|(
name|initial_condition_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop_nb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"step: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|step_expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|",  init: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|init_expr
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
operator|*
name|init
operator|=
name|init_expr
expr_stmt|;
operator|*
name|step
operator|=
name|step_expr
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|step_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"step unknown."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vectorize_loops.        Entry Point to loop vectorization phase.  */
end_comment

begin_function
name|void
name|vectorize_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|num_vectorized_loops
init|=
literal|0
decl_stmt|;
comment|/* Fix the verbosity level if not defined explicitly by the user.  */
name|vect_set_dump_settings
argument_list|()
expr_stmt|;
comment|/* Allocate the bitmap that records which virtual variables that       need to be renamed.  */
name|vect_vnames_to_rename
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/*  ----------- Analyze loops. -----------  */
comment|/* If some loop was duplicated, it gets bigger number       than all previously defined loops. This fact allows us to run       only over initial loops skipping newly generated ones.  */
name|vect_loops_num
operator|=
name|loops
operator|->
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vect_loops_num
condition|;
name|i
operator|++
control|)
block|{
name|loop_vec_info
name|loop_vinfo
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|vect_loop_location
operator|=
name|find_loop_location
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loop_vinfo
operator|=
name|vect_analyze_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|aux
operator|=
name|loop_vinfo
expr_stmt|;
if|if
condition|(
operator|!
name|loop_vinfo
operator|||
operator|!
name|LOOP_VINFO_VECTORIZABLE_P
argument_list|(
name|loop_vinfo
argument_list|)
condition|)
continue|continue;
name|vect_transform_loop
argument_list|(
name|loop_vinfo
argument_list|,
name|loops
argument_list|)
expr_stmt|;
name|num_vectorized_loops
operator|++
expr_stmt|;
block|}
name|vect_loop_location
operator|=
name|UNKNOWN_LOC
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_VECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vectorized %u loops in function.\n"
argument_list|,
name|num_vectorized_loops
argument_list|)
expr_stmt|;
comment|/*  ----------- Finalize. -----------  */
name|BITMAP_FREE
argument_list|(
name|vect_vnames_to_rename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vect_loops_num
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
decl_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|loop_vinfo
operator|=
name|loop
operator|->
name|aux
expr_stmt|;
name|destroy_loop_vec_info
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|loop
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

end_unit

