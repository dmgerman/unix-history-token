begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains routines to construct GNU OpenMP constructs,     called from parsing in the C and C++ front ends.     Copyright (C) 2005 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@redhat.com>, 		  Diego Novillo<dnovillo@redhat.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Complete a #pragma omp master construct.  STMT is the structured-block    that follows the pragma.  */
end_comment

begin_function
name|tree
name|c_finish_omp_master
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
return|return
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|OMP_MASTER
argument_list|,
name|void_type_node
argument_list|,
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Complete a #pragma omp critical construct.  STMT is the structured-block    that follows the pragma, NAME is the identifier in the pragma, or null    if it was omitted.  */
end_comment

begin_function
name|tree
name|c_finish_omp_critical
parameter_list|(
name|tree
name|body
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|make_node
argument_list|(
name|OMP_CRITICAL
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|stmt
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_CRITICAL_BODY
argument_list|(
name|stmt
argument_list|)
operator|=
name|body
expr_stmt|;
name|OMP_CRITICAL_NAME
argument_list|(
name|stmt
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|stmt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Complete a #pragma omp ordered construct.  STMT is the structured-block    that follows the pragma.  */
end_comment

begin_function
name|tree
name|c_finish_omp_ordered
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
return|return
name|add_stmt
argument_list|(
name|build1
argument_list|(
name|OMP_ORDERED
argument_list|,
name|void_type_node
argument_list|,
name|stmt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Complete a #pragma omp barrier construct.  */
end_comment

begin_function
name|void
name|c_finish_omp_barrier
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_BARRIER
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Complete a #pragma omp atomic construct.  The expression to be     implemented atomically is LHS code= RHS.  The value returned is    either error_mark_node (if the construct was erroneous) or an    OMP_ATOMIC node which should be added to the current statement tree    with add_stmt.  */
end_comment

begin_function
name|tree
name|c_finish_omp_atomic
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|lhs
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|x
decl_stmt|,
name|type
decl_stmt|,
name|addr
decl_stmt|;
if|if
condition|(
name|lhs
operator|==
name|error_mark_node
operator|||
name|rhs
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
comment|/* ??? According to one reading of the OpenMP spec, complex type are      supported, but there are no atomic stores for any architecture.      But at least icc 9.0 doesn't support complex types here either.      And lets not even talk about vector types...  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid expression type for %<#pragma omp atomic%>"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* ??? Validate that rhs does not overlap lhs.  */
comment|/* Take and save the address of the lhs.  From then on we'll reference it      via indirection.  */
name|addr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|addr
operator|=
name|save_expr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|SAVE_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|ADDR_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|VAR_DECL
operator|)
condition|)
block|{
comment|/* Make sure LHS is simple enough so that goa_lhs_expr_p can recognize 	 it even after unsharing function body.  */
name|tree
name|var
init|=
name|create_tmp_var_raw
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|addr
operator|=
name|build4
argument_list|(
name|TARGET_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|,
name|var
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|lhs
operator|=
name|build_indirect_ref
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* There are lots of warnings, errors, and conversions that need to happen      in the course of interpreting a statement.  Use the normal mechanisms      to do this, and then take it apart again.  */
name|x
operator|=
name|build_modify_expr
argument_list|(
name|lhs
argument_list|,
name|code
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Punt the actual generation of atomic operations to common code.  */
return|return
name|build2
argument_list|(
name|OMP_ATOMIC
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Complete a #pragma omp flush construct.  We don't do anything with the    variable list that the syntax allows.  */
end_comment

begin_function
name|void
name|c_finish_omp_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
name|x
operator|=
name|built_in_decls
index|[
name|BUILT_IN_SYNCHRONIZE
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_stmt
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check and canonicalize #pragma omp for increment expression.    Helper function for c_finish_omp_for.  */
end_comment

begin_function
specifier|static
name|tree
name|check_omp_for_incr_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|exp
operator|==
name|decl
condition|)
return|return
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|t
operator|=
name|check_omp_for_incr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t
argument_list|)
return|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|t
operator|=
name|check_omp_for_incr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
return|return
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|PLUS_EXPR
case|:
name|t
operator|=
name|check_omp_for_incr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|t
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
name|t
operator|=
name|check_omp_for_incr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
return|return
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Validate and emit code for the OpenMP directive #pragma omp for.    INIT, COND, INCR, BODY and PRE_BODY are the five basic elements    of the loop (initialization expression, controlling predicate, increment    expression, body of the loop and statements to go before the loop).    DECL is the iteration variable.  */
end_comment

begin_function
name|tree
name|c_finish_omp_for
parameter_list|(
name|location_t
name|locus
parameter_list|,
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|incr
parameter_list|,
name|tree
name|body
parameter_list|,
name|tree
name|pre_body
parameter_list|)
block|{
name|location_t
name|elocus
init|=
name|locus
decl_stmt|;
name|bool
name|fail
init|=
name|false
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|init
argument_list|)
condition|)
name|elocus
operator|=
name|EXPR_LOCATION
argument_list|(
name|init
argument_list|)
expr_stmt|;
comment|/* Validate the iteration variable.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Hinvalid type for iteration variable %qE"
argument_list|,
operator|&
name|elocus
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|fail
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hiteration variable %qE is unsigned"
argument_list|,
operator|&
name|elocus
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* In the case of "for (int i = 0...)", init will be a decl.  It should      have a DECL_INITIAL that we can turn into an assignment.  */
if|if
condition|(
name|init
operator|==
name|decl
condition|)
block|{
name|elocus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%H%qE is not initialized"
argument_list|,
operator|&
name|elocus
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|init
operator|=
name|integer_zero_node
expr_stmt|;
name|fail
operator|=
name|true
expr_stmt|;
block|}
name|init
operator|=
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|init
argument_list|,
name|elocus
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
operator|==
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"%Hmissing controlling predicate"
argument_list|,
operator|&
name|elocus
argument_list|)
expr_stmt|;
name|fail
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|bool
name|cond_ok
init|=
name|false
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|cond
argument_list|)
condition|)
name|elocus
operator|=
name|EXPR_LOCATION
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|LT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|LE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|GT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|GE_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* 2.5.1.  The comparison in the condition is computed in the type 	     of DECL, otherwise the behavior is undefined.  	     For example: 	     long n; int i; 	     i< n;  	     according to ISO will be evaluated as: 	     (long)i< n;  	     We want to force: 	     i< (int)n;  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|decl
operator|==
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|=
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|decl
operator|==
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|=
name|fold_build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|==
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
condition|)
name|cond_ok
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|==
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|TREE_SET_CODE
argument_list|(
name|cond
argument_list|,
name|swap_tree_comparison
argument_list|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
name|cond_ok
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|cond_ok
condition|)
block|{
name|error
argument_list|(
literal|"%Hinvalid controlling predicate"
argument_list|,
operator|&
name|elocus
argument_list|)
expr_stmt|;
name|fail
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|incr
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"%Hmissing increment expression"
argument_list|,
operator|&
name|elocus
argument_list|)
expr_stmt|;
name|fail
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|bool
name|incr_ok
init|=
name|false
decl_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|incr
argument_list|)
condition|)
name|elocus
operator|=
name|EXPR_LOCATION
argument_list|(
name|incr
argument_list|)
expr_stmt|;
comment|/* Check all the valid increment expressions: v++, v--, ++v, --v, 	 v = v + incr, v = incr + v and v = v - incr.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|incr
argument_list|)
condition|)
block|{
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
name|incr_ok
operator|=
operator|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|0
argument_list|)
operator|==
name|decl
operator|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|0
argument_list|)
operator|!=
name|decl
condition|)
break|break;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
operator|==
name|decl
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS_EXPR
operator|&&
operator|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|decl
operator|||
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|decl
operator|)
condition|)
name|incr_ok
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|decl
condition|)
name|incr_ok
operator|=
name|true
expr_stmt|;
else|else
block|{
name|tree
name|t
init|=
name|check_omp_for_incr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|incr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|error_mark_node
condition|)
block|{
name|incr_ok
operator|=
name|true
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|incr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|incr_ok
condition|)
block|{
name|error
argument_list|(
literal|"%Hinvalid increment expression"
argument_list|,
operator|&
name|elocus
argument_list|)
expr_stmt|;
name|fail
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fail
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|tree
name|t
init|=
name|make_node
argument_list|(
name|OMP_FOR
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|OMP_FOR_INIT
argument_list|(
name|t
argument_list|)
operator|=
name|init
expr_stmt|;
name|OMP_FOR_COND
argument_list|(
name|t
argument_list|)
operator|=
name|cond
expr_stmt|;
name|OMP_FOR_INCR
argument_list|(
name|t
argument_list|)
operator|=
name|incr
expr_stmt|;
name|OMP_FOR_BODY
argument_list|(
name|t
argument_list|)
operator|=
name|body
expr_stmt|;
name|OMP_FOR_PRE_BODY
argument_list|(
name|t
argument_list|)
operator|=
name|pre_body
expr_stmt|;
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|locus
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|t
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Divide CLAUSES into two lists: those that apply to a parallel construct,    and those that apply to a work-sharing construct.  Place the results in    *PAR_CLAUSES and *WS_CLAUSES respectively.  In addition, add a nowait    clause to the work-sharing list.  */
end_comment

begin_function
name|void
name|c_split_parallel_clauses
parameter_list|(
name|tree
name|clauses
parameter_list|,
name|tree
modifier|*
name|par_clauses
parameter_list|,
name|tree
modifier|*
name|ws_clauses
parameter_list|)
block|{
name|tree
name|next
decl_stmt|;
operator|*
name|par_clauses
operator|=
name|NULL
expr_stmt|;
operator|*
name|ws_clauses
operator|=
name|build_omp_clause
argument_list|(
name|OMP_CLAUSE_NOWAIT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|clauses
condition|;
name|clauses
operator|=
name|next
control|)
block|{
name|next
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clauses
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|clauses
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_SHARED
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
case|case
name|OMP_CLAUSE_REDUCTION
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clauses
argument_list|)
operator|=
operator|*
name|par_clauses
expr_stmt|;
operator|*
name|par_clauses
operator|=
name|clauses
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clauses
argument_list|)
operator|=
operator|*
name|ws_clauses
expr_stmt|;
operator|*
name|ws_clauses
operator|=
name|clauses
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* True if OpenMP sharing attribute of DECL is predetermined.  */
end_comment

begin_function
name|enum
name|omp_clause_default_kind
name|c_omp_predetermined_sharing
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Variables with const-qualified type having no mutable member      are predetermined shared.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|OMP_CLAUSE_DEFAULT_SHARED
return|;
return|return
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
return|;
block|}
end_function

end_unit

