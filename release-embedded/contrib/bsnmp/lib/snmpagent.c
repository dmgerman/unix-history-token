begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  *	All rights reserved.  *  * Author: Harti Brandt<harti@freebsd.org>  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Begemot: bsnmp/lib/snmpagent.c,v 1.20 2005/10/04 11:21:33 brandt_h Exp $  *  * SNMP Agent functions  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_INTTYPES_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"asn1.h"
end_include

begin_include
include|#
directive|include
file|"snmp.h"
end_include

begin_include
include|#
directive|include
file|"snmppriv.h"
end_include

begin_include
include|#
directive|include
file|"snmpagent.h"
end_include

begin_function_decl
specifier|static
name|void
name|snmp_debug_func
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|snmp_debug
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
init|=
name|snmp_debug_func
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|snmp_node
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|tree_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure to hold dependencies during SET processing  * The last two members of this structure must be the  * dependency visible by the user and the user data.  */
end_comment

begin_struct
struct|struct
name|depend
block|{
name|TAILQ_ENTRY
argument_list|(
argument|depend
argument_list|)
name|link
expr_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* size of data part */
name|snmp_depop_t
name|func
decl_stmt|;
name|struct
name|snmp_dependency
name|dep
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|<
literal|3
name|u_char
name|data
index|[
literal|0
index|]
decl_stmt|;
else|#
directive|else
name|u_char
name|data
index|[]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|depend_list
argument_list|,
name|depend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Set context  */
end_comment

begin_struct
struct|struct
name|context
block|{
name|struct
name|snmp_context
name|ctx
decl_stmt|;
name|struct
name|depend_list
name|dlist
decl_stmt|;
specifier|const
name|struct
name|snmp_node
modifier|*
name|node
index|[
name|SNMP_MAX_BINDINGS
index|]
decl_stmt|;
name|struct
name|snmp_scratch
name|scratch
index|[
name|SNMP_MAX_BINDINGS
index|]
decl_stmt|;
name|struct
name|depend
modifier|*
name|depend
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TR
parameter_list|(
name|W
parameter_list|)
value|(snmp_trace& SNMP_TRACE_##W)
end_define

begin_decl_stmt
name|u_int
name|snmp_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|oidbuf
index|[
name|ASN_OIDSTRLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a context  */
end_comment

begin_function
name|struct
name|snmp_context
modifier|*
name|snmp_init_context
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
decl_stmt|;
if|if
condition|(
operator|(
name|context
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|context
operator|->
name|dlist
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|context
operator|->
name|ctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a variable for SET/GET and the first GETBULK pass.  * Return the node pointer. If the search fails, set the errp to  * the correct SNMPv2 GET exception code.  */
end_comment

begin_function
specifier|static
name|struct
name|snmp_node
modifier|*
name|find_node
parameter_list|(
specifier|const
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|,
name|enum
name|snmp_syntax
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|snmp_node
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"find: searching %s"
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|value
operator|->
name|var
argument_list|,
name|oidbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an exact match (the entry in the table is a 	 * sub-oid from the variable) we have found what we are for. 	 * If the table oid is higher than the variable, there is no match. 	 */
for|for
control|(
name|tp
operator|=
name|tree
init|;
name|tp
operator|<
name|tree
operator|+
name|tree_size
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|asn_is_suboid
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|,
operator|&
name|value
operator|->
name|var
argument_list|)
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|asn_compare_oid
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|,
operator|&
name|value
operator|->
name|var
argument_list|)
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"find: no match"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|SNMP_SYNTAX_NOSUCHOBJECT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
comment|/* leafs must have a 0 instance identifier */
if|if
condition|(
name|tp
operator|->
name|type
operator|==
name|SNMP_NODE_LEAF
operator|&&
operator|(
name|value
operator|->
name|var
operator|.
name|len
operator|!=
name|tp
operator|->
name|oid
operator|.
name|len
operator|+
literal|1
operator|||
name|value
operator|->
name|var
operator|.
name|subs
index|[
name|tp
operator|->
name|oid
operator|.
name|len
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"find: bad leaf index"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|SNMP_SYNTAX_NOSUCHINSTANCE
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"find: found %s"
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|value
operator|->
name|var
argument_list|,
name|oidbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|snmp_node
modifier|*
name|find_subnode
parameter_list|(
specifier|const
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|snmp_node
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|tree
init|;
name|tp
operator|<
name|tree
operator|+
name|tree_size
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|asn_is_suboid
argument_list|(
operator|&
name|value
operator|->
name|var
argument_list|,
operator|&
name|tp
operator|->
name|oid
argument_list|)
condition|)
return|return
operator|(
name|tp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_pdu_create_response
parameter_list|(
specifier|const
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|resp
parameter_list|)
block|{
name|memset
argument_list|(
name|resp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|resp
operator|->
name|community
argument_list|,
name|pdu
operator|->
name|community
argument_list|)
expr_stmt|;
name|resp
operator|->
name|version
operator|=
name|pdu
operator|->
name|version
expr_stmt|;
name|resp
operator|->
name|type
operator|=
name|SNMP_PDU_RESPONSE
expr_stmt|;
name|resp
operator|->
name|request_id
operator|=
name|pdu
operator|->
name|request_id
expr_stmt|;
name|resp
operator|->
name|version
operator|=
name|pdu
operator|->
name|version
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|version
operator|!=
name|SNMP_V3
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|resp
operator|->
name|engine
argument_list|,
operator|&
name|pdu
operator|->
name|engine
argument_list|,
sizeof|sizeof
argument_list|(
name|pdu
operator|->
name|engine
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|resp
operator|->
name|user
argument_list|,
operator|&
name|pdu
operator|->
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|pdu
operator|->
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|snmp_pdu_init_secparams
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|pdu
operator|->
name|identifier
expr_stmt|;
name|resp
operator|->
name|security_model
operator|=
name|pdu
operator|->
name|security_model
expr_stmt|;
name|resp
operator|->
name|context_engine_len
operator|=
name|pdu
operator|->
name|context_engine_len
expr_stmt|;
name|memcpy
argument_list|(
name|resp
operator|->
name|context_engine
argument_list|,
name|pdu
operator|->
name|context_engine
argument_list|,
name|resp
operator|->
name|context_engine_len
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|resp
operator|->
name|context_name
argument_list|,
name|pdu
operator|->
name|context_name
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
operator|->
name|context_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Execute a GET operation. The tree is rooted at the global 'root'.  * Build the response PDU on the fly. If the return code is SNMP_RET_ERR  * the pdu error status and index will be set.  */
end_comment

begin_function
name|enum
name|snmp_ret
name|snmp_get
parameter_list|(
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|struct
name|asn_buf
modifier|*
name|resp_b
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|resp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|snmp_node
modifier|*
name|tp
decl_stmt|;
name|enum
name|snmp_syntax
name|except
decl_stmt|;
name|struct
name|context
name|context
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|snmp_pdu_create_response
argument_list|(
name|pdu
argument_list|,
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmp_pdu_encode_header
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
operator|!=
name|SNMP_CODE_OK
condition|)
comment|/* cannot even encode header - very bad */
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdu
operator|->
name|nbindings
condition|;
name|i
operator|++
control|)
block|{
name|resp
operator|->
name|bindings
index|[
name|i
index|]
operator|.
name|var
operator|=
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
operator|.
name|var
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|find_node
argument_list|(
operator|&
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
argument_list|,
operator|&
name|except
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"get: nosuchname"
argument_list|)
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"get: exception %u"
argument_list|,
name|except
argument_list|)
expr_stmt|;
name|resp
operator|->
name|bindings
index|[
name|i
index|]
operator|.
name|syntax
operator|=
name|except
expr_stmt|;
block|}
else|else
block|{
comment|/* call the action to fetch the value. */
name|resp
operator|->
name|bindings
index|[
name|i
index|]
operator|.
name|syntax
operator|=
name|tp
operator|->
name|syntax
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|tp
operator|->
name|op
call|)
argument_list|(
operator|&
name|context
operator|.
name|ctx
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|i
index|]
argument_list|,
name|tp
operator|->
name|oid
operator|.
name|len
argument_list|,
name|tp
operator|->
name|index
argument_list|,
name|SNMP_OP_GET
argument_list|)
expr_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"get: action returns %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|SNMP_ERR_NOSUCHNAME
condition|)
block|{
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"get: exception noSuchInstance"
argument_list|)
expr_stmt|;
name|resp
operator|->
name|bindings
index|[
name|i
index|]
operator|.
name|syntax
operator|=
name|SNMP_SYNTAX_NOSUCHINSTANCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
block|}
name|resp
operator|->
name|nbindings
operator|++
expr_stmt|;
name|err
operator|=
name|snmp_binding_encode
argument_list|(
name|resp_b
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ASN_ERR_EOBUF
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_TOOBIG
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
literal|0
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
if|if
condition|(
name|err
operator|!=
name|ASN_ERR_OK
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"get: binding encoding: %u"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|snmp_fix_encoding
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
operator|!=
name|SNMP_CODE_OK
condition|)
block|{
name|snmp_debug
argument_list|(
literal|"get: failed to encode PDU"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
return|return
operator|(
name|SNMP_RET_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|snmp_node
modifier|*
name|next_node
parameter_list|(
specifier|const
name|struct
name|snmp_value
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|pnext
parameter_list|)
block|{
name|struct
name|snmp_node
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"next: searching %s"
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|value
operator|->
name|var
argument_list|,
name|oidbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pnext
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|tree
init|;
name|tp
operator|<
name|tree
operator|+
name|tree_size
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|asn_is_suboid
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|,
operator|&
name|value
operator|->
name|var
argument_list|)
condition|)
block|{
comment|/* the tree OID is a sub-oid of the requested OID. */
if|if
condition|(
name|tp
operator|->
name|type
operator|==
name|SNMP_NODE_LEAF
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|oid
operator|.
name|len
operator|==
name|value
operator|->
name|var
operator|.
name|len
condition|)
block|{
comment|/* request for scalar type */
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"next: found scalar %s"
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|,
name|oidbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
comment|/* try next */
block|}
else|else
block|{
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"next: found column %s"
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|,
name|oidbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|asn_is_suboid
argument_list|(
operator|&
name|value
operator|->
name|var
argument_list|,
operator|&
name|tp
operator|->
name|oid
argument_list|)
operator|||
name|asn_compare_oid
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|,
operator|&
name|value
operator|->
name|var
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"next: found %s"
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|,
name|oidbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pnext
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
block|}
if|if
condition|(
name|TR
argument_list|(
name|FIND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"next: failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|snmp_ret
name|do_getnext
parameter_list|(
name|struct
name|context
modifier|*
name|context
parameter_list|,
specifier|const
name|struct
name|snmp_value
modifier|*
name|inb
parameter_list|,
name|struct
name|snmp_value
modifier|*
name|outb
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|)
block|{
specifier|const
name|struct
name|snmp_node
modifier|*
name|tp
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|next_node
argument_list|(
name|inb
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|eofMib
goto|;
comment|/* retain old variable if we are doing a GETNEXT on an exact 	 * matched leaf only */
if|if
condition|(
name|tp
operator|->
name|type
operator|==
name|SNMP_NODE_LEAF
operator|||
name|next
condition|)
name|outb
operator|->
name|var
operator|=
name|tp
operator|->
name|oid
expr_stmt|;
else|else
name|outb
operator|->
name|var
operator|=
name|inb
operator|->
name|var
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|outb
operator|->
name|syntax
operator|=
name|tp
operator|->
name|syntax
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|type
operator|==
name|SNMP_NODE_LEAF
condition|)
block|{
comment|/* make a GET operation */
name|outb
operator|->
name|var
operator|.
name|subs
index|[
name|outb
operator|->
name|var
operator|.
name|len
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|tp
operator|->
name|op
call|)
argument_list|(
operator|&
name|context
operator|->
name|ctx
argument_list|,
name|outb
argument_list|,
name|tp
operator|->
name|oid
operator|.
name|len
argument_list|,
name|tp
operator|->
name|index
argument_list|,
name|SNMP_OP_GET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* make a GETNEXT */
name|ret
operator|=
call|(
modifier|*
name|tp
operator|->
name|op
call|)
argument_list|(
operator|&
name|context
operator|->
name|ctx
argument_list|,
name|outb
argument_list|,
name|tp
operator|->
name|oid
operator|.
name|len
argument_list|,
name|tp
operator|->
name|index
argument_list|,
name|SNMP_OP_GETNEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOSUCHNAME
condition|)
block|{
comment|/* got something */
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
operator|&&
name|TR
argument_list|(
name|GETNEXT
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"getnext: %s returns %u"
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|outb
operator|->
name|var
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* object has no data - try next */
if|if
condition|(
operator|++
name|tp
operator|==
name|tree
operator|+
name|tree_size
condition|)
break|break;
if|if
condition|(
name|TR
argument_list|(
name|GETNEXT
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"getnext: no data - avancing to %s"
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|tp
operator|->
name|oid
argument_list|)
argument_list|)
expr_stmt|;
name|outb
operator|->
name|var
operator|=
name|tp
operator|->
name|oid
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|SNMP_ERR_NOSUCHNAME
condition|)
block|{
name|eofMib
label|:
name|outb
operator|->
name|var
operator|=
name|inb
operator|->
name|var
expr_stmt|;
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
name|outb
operator|->
name|syntax
operator|=
name|SNMP_SYNTAX_ENDOFMIBVIEW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
return|return
operator|(
name|SNMP_RET_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute a GETNEXT operation. The tree is rooted at the global 'root'.  * Build the response PDU on the fly. The return is:  */
end_comment

begin_function
name|enum
name|snmp_ret
name|snmp_getnext
parameter_list|(
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|struct
name|asn_buf
modifier|*
name|resp_b
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|resp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|context
name|context
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
name|enum
name|snmp_ret
name|result
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|snmp_pdu_create_response
argument_list|(
name|pdu
argument_list|,
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmp_pdu_encode_header
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
condition|)
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdu
operator|->
name|nbindings
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|do_getnext
argument_list|(
operator|&
name|context
argument_list|,
operator|&
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|i
index|]
argument_list|,
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SNMP_RET_OK
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|resp
operator|->
name|nbindings
operator|++
expr_stmt|;
name|err
operator|=
name|snmp_binding_encode
argument_list|(
name|resp_b
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ASN_ERR_EOBUF
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_TOOBIG
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
literal|0
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
if|if
condition|(
name|err
operator|!=
name|ASN_ERR_OK
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"getnext: binding encoding: %u"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|snmp_fix_encoding
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
operator|!=
name|SNMP_CODE_OK
condition|)
block|{
name|snmp_debug
argument_list|(
literal|"getnext: failed to encode PDU"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
return|return
operator|(
name|SNMP_RET_OK
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|snmp_ret
name|snmp_getbulk
parameter_list|(
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|struct
name|asn_buf
modifier|*
name|resp_b
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|resp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|context
name|context
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|u_int
name|non_rep
decl_stmt|;
name|int
name|eomib
decl_stmt|;
name|enum
name|snmp_ret
name|result
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|snmp_pdu_create_response
argument_list|(
name|pdu
argument_list|,
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmp_pdu_encode_header
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
operator|!=
name|SNMP_CODE_OK
condition|)
comment|/* cannot even encode header - very bad */
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
if|if
condition|(
operator|(
name|non_rep
operator|=
name|pdu
operator|->
name|error_status
operator|)
operator|>
name|pdu
operator|->
name|nbindings
condition|)
name|non_rep
operator|=
name|pdu
operator|->
name|nbindings
expr_stmt|;
comment|/* non-repeaters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|non_rep
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|do_getnext
argument_list|(
operator|&
name|context
argument_list|,
operator|&
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|resp
operator|->
name|nbindings
index|]
argument_list|,
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SNMP_RET_OK
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|err
operator|=
name|snmp_binding_encode
argument_list|(
name|resp_b
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|resp
operator|->
name|nbindings
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ASN_ERR_EOBUF
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|err
operator|!=
name|ASN_ERR_OK
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"getnext: binding encoding: %u"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|non_rep
operator|==
name|pdu
operator|->
name|nbindings
condition|)
goto|goto
name|done
goto|;
comment|/* repeates */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|pdu
operator|->
name|error_index
condition|;
name|cnt
operator|++
control|)
block|{
name|eomib
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|non_rep
init|;
name|i
operator|<
name|pdu
operator|->
name|nbindings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|resp
operator|->
name|nbindings
operator|==
name|SNMP_MAX_BINDINGS
condition|)
comment|/* PDU is full */
goto|goto
name|done
goto|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
name|result
operator|=
name|do_getnext
argument_list|(
operator|&
name|context
argument_list|,
operator|&
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|resp
operator|->
name|nbindings
index|]
argument_list|,
name|pdu
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|do_getnext
argument_list|(
operator|&
name|context
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|resp
operator|->
name|nbindings
operator|-
operator|(
name|pdu
operator|->
name|nbindings
operator|-
name|non_rep
operator|)
index|]
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|resp
operator|->
name|nbindings
index|]
argument_list|,
name|pdu
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|SNMP_RET_OK
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|resp
operator|->
name|bindings
index|[
name|resp
operator|->
name|nbindings
index|]
operator|.
name|syntax
operator|!=
name|SNMP_SYNTAX_ENDOFMIBVIEW
condition|)
name|eomib
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|snmp_binding_encode
argument_list|(
name|resp_b
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|resp
operator|->
name|nbindings
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ASN_ERR_EOBUF
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|err
operator|!=
name|ASN_ERR_OK
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|GET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"getnext: binding encoding: %u"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|eomib
condition|)
break|break;
block|}
name|done
label|:
if|if
condition|(
name|snmp_fix_encoding
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
operator|!=
name|SNMP_CODE_OK
condition|)
block|{
name|snmp_debug
argument_list|(
literal|"getnext: failed to encode PDU"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
return|return
operator|(
name|SNMP_RET_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rollback a SET operation. Failed index is 'i'.  */
end_comment

begin_function
specifier|static
name|void
name|rollback
parameter_list|(
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|u_int
name|i
parameter_list|)
block|{
name|struct
name|snmp_value
modifier|*
name|b
decl_stmt|;
specifier|const
name|struct
name|snmp_node
modifier|*
name|np
decl_stmt|;
name|int
name|ret
decl_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|b
operator|=
operator|&
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
expr_stmt|;
name|np
operator|=
name|context
operator|->
name|node
index|[
name|i
index|]
expr_stmt|;
name|context
operator|->
name|ctx
operator|.
name|scratch
operator|=
operator|&
name|context
operator|->
name|scratch
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|np
operator|->
name|op
call|)
argument_list|(
operator|&
name|context
operator|->
name|ctx
argument_list|,
name|b
argument_list|,
name|np
operator|->
name|oid
operator|.
name|len
argument_list|,
name|np
operator|->
name|index
argument_list|,
name|SNMP_OP_ROLLBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|snmp_error
argument_list|(
literal|"set: rollback failed (%d) on variable %s "
literal|"index %u"
argument_list|,
name|ret
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|b
operator|->
name|var
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdu
operator|->
name|version
operator|!=
name|SNMP_V1
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_UNDO_FAILED
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Commit dependencies.  */
end_comment

begin_function
name|int
name|snmp_dep_commit
parameter_list|(
name|struct
name|snmp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
init|=
operator|(
expr|struct
name|context
operator|*
operator|)
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|context->depend
argument_list|,
argument|&context->dlist
argument_list|,
argument|link
argument_list|)
block|{
name|ctx
operator|->
name|dep
operator|=
operator|&
name|context
operator|->
name|depend
operator|->
name|dep
expr_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: dependency commit %s"
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|ctx
operator|->
name|dep
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|context
operator|->
name|depend
operator|->
name|func
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|dep
argument_list|,
name|SNMP_DEPOP_COMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: dependency failed %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
name|SNMP_ERR_NOERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rollback dependencies  */
end_comment

begin_function
name|int
name|snmp_dep_rollback
parameter_list|(
name|struct
name|snmp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
init|=
operator|(
expr|struct
name|context
operator|*
operator|)
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|ret1
decl_stmt|;
name|char
name|objbuf
index|[
name|ASN_OIDSTRLEN
index|]
decl_stmt|;
name|char
name|idxbuf
index|[
name|ASN_OIDSTRLEN
index|]
decl_stmt|;
name|ret1
operator|=
name|SNMP_ERR_NOERROR
expr_stmt|;
while|while
condition|(
operator|(
name|context
operator|->
name|depend
operator|=
name|TAILQ_PREV
argument_list|(
name|context
operator|->
name|depend
argument_list|,
name|depend_list
argument_list|,
name|link
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ctx
operator|->
name|dep
operator|=
operator|&
name|context
operator|->
name|depend
operator|->
name|dep
expr_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: dependency rollback %s"
argument_list|,
name|asn_oid2str
argument_list|(
operator|&
name|ctx
operator|->
name|dep
operator|->
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|context
operator|->
name|depend
operator|->
name|func
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|dep
argument_list|,
name|SNMP_DEPOP_ROLLBACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|snmp_debug
argument_list|(
literal|"set: dep rollback returns %u: %s %s"
argument_list|,
name|ret
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|ctx
operator|->
name|dep
operator|->
name|obj
argument_list|,
name|objbuf
argument_list|)
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|ctx
operator|->
name|dep
operator|->
name|idx
argument_list|,
name|idxbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret1
operator|==
name|SNMP_ERR_NOERROR
condition|)
name|ret1
operator|=
name|ret
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|snmp_dep_finish
parameter_list|(
name|struct
name|snmp_context
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
init|=
operator|(
expr|struct
name|context
operator|*
operator|)
name|ctx
decl_stmt|;
name|struct
name|depend
modifier|*
name|d
decl_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|context
operator|->
name|dlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ctx
operator|->
name|dep
operator|=
operator|&
name|d
operator|->
name|dep
expr_stmt|;
operator|(
name|void
operator|)
name|d
operator|->
name|func
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|dep
argument_list|,
name|SNMP_DEPOP_FINISH
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|context
operator|->
name|dlist
argument_list|,
name|d
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Do a SET operation.  */
end_comment

begin_function
name|enum
name|snmp_ret
name|snmp_set
parameter_list|(
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|struct
name|asn_buf
modifier|*
name|resp_b
parameter_list|,
name|struct
name|snmp_pdu
modifier|*
name|resp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|enum
name|asn_err
name|asnerr
decl_stmt|;
name|struct
name|context
name|context
decl_stmt|;
specifier|const
name|struct
name|snmp_node
modifier|*
name|np
decl_stmt|;
name|struct
name|snmp_value
modifier|*
name|b
decl_stmt|;
name|enum
name|snmp_syntax
name|except
decl_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|context
operator|.
name|dlist
argument_list|)
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|snmp_pdu_create_response
argument_list|(
name|pdu
argument_list|,
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|snmp_pdu_encode_header
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
condition|)
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
comment|/*  	 * 1. Find all nodes, check that they are writeable and 	 *    that the syntax is ok, copy over the binding to the response. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdu
operator|->
name|nbindings
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
operator|&
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|context
operator|.
name|node
index|[
name|i
index|]
operator|=
name|find_node
argument_list|(
name|b
argument_list|,
operator|&
name|except
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* not found altogether or LEAF with wrong index */
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: node not found %s"
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|b
operator|->
name|var
argument_list|,
name|oidbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|=
name|find_subnode
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 2. intermediate object */
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NOT_WRITEABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|except
operator|==
name|SNMP_SYNTAX_NOSUCHOBJECT
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NO_ACCESS
expr_stmt|;
block|}
else|else
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NO_CREATION
expr_stmt|;
block|}
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
comment|/* 		 * 2. write/createable? 		 * Can check this for leafs only, because in v2 we have 		 * to differentiate between NOT_WRITEABLE and NO_CREATION 		 * and only the action routine for COLUMNS knows, whether 		 * a column exists. 		 */
if|if
condition|(
name|np
operator|->
name|type
operator|==
name|SNMP_NODE_LEAF
operator|&&
operator|!
operator|(
name|np
operator|->
name|flags
operator|&
name|SNMP_NODE_CANSET
operator|)
condition|)
block|{
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
block|}
else|else
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_NOT_WRITEABLE
expr_stmt|;
block|}
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
comment|/* 		 * 3. Ensure the right syntax 		 */
if|if
condition|(
name|np
operator|->
name|syntax
operator|!=
name|b
operator|->
name|syntax
condition|)
block|{
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
comment|/* v2: wrongType */
block|}
else|else
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_WRONG_TYPE
expr_stmt|;
block|}
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
comment|/* 		 * 4. Copy binding 		 */
if|if
condition|(
name|snmp_value_copy
argument_list|(
operator|&
name|resp
operator|->
name|bindings
index|[
name|i
index|]
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
name|asnerr
operator|=
name|snmp_binding_encode
argument_list|(
name|resp_b
argument_list|,
operator|&
name|resp
operator|->
name|bindings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|asnerr
operator|==
name|ASN_ERR_EOBUF
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_TOOBIG
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|asnerr
operator|!=
name|ASN_ERR_OK
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_ERR
operator|)
return|;
block|}
name|resp
operator|->
name|nbindings
operator|++
expr_stmt|;
block|}
name|context
operator|.
name|ctx
operator|.
name|code
operator|=
name|SNMP_RET_OK
expr_stmt|;
comment|/* 	 * 2. Call the SET method for each node. If a SET fails, rollback 	 *    everything. Map error codes depending on the version. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdu
operator|->
name|nbindings
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
operator|&
name|pdu
operator|->
name|bindings
index|[
name|i
index|]
expr_stmt|;
name|np
operator|=
name|context
operator|.
name|node
index|[
name|i
index|]
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|var_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|scratch
operator|=
operator|&
name|context
operator|.
name|scratch
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|np
operator|->
name|op
call|)
argument_list|(
operator|&
name|context
operator|.
name|ctx
argument_list|,
name|b
argument_list|,
name|np
operator|->
name|oid
operator|.
name|len
argument_list|,
name|np
operator|->
name|index
argument_list|,
name|SNMP_OP_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: action %s returns %d"
argument_list|,
name|np
operator|->
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V1
condition|)
block|{
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|SNMP_ERR_NO_ACCESS
case|:
name|ret
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_WRONG_TYPE
case|:
comment|/* should no happen */
name|ret
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_WRONG_LENGTH
case|:
name|ret
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_WRONG_ENCODING
case|:
comment|/* should not happen */
name|ret
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_WRONG_VALUE
case|:
name|ret
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_NO_CREATION
case|:
name|ret
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_INCONS_VALUE
case|:
name|ret
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_RES_UNAVAIL
case|:
name|ret
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_COMMIT_FAILED
case|:
name|ret
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_UNDO_FAILED
case|:
name|ret
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_AUTH_ERR
case|:
comment|/* should not happen */
name|ret
operator|=
name|SNMP_ERR_GENERR
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_NOT_WRITEABLE
case|:
name|ret
operator|=
name|SNMP_ERR_NOSUCHNAME
expr_stmt|;
break|break;
case|case
name|SNMP_ERR_INCONS_NAME
case|:
name|ret
operator|=
name|SNMP_ERR_BADVALUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|pdu
operator|->
name|error_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|pdu
operator|->
name|error_status
operator|=
name|ret
expr_stmt|;
name|rollback
argument_list|(
operator|&
name|context
argument_list|,
name|pdu
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|code
operator|=
name|SNMP_RET_ERR
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
comment|/* 	 * 3. Call dependencies 	 */
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: set operations ok"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|snmp_dep_commit
argument_list|(
operator|&
name|context
operator|.
name|ctx
argument_list|)
operator|)
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|ret
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
name|context
operator|.
name|ctx
operator|.
name|var_index
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|snmp_dep_rollback
argument_list|(
operator|&
name|context
operator|.
name|ctx
argument_list|)
operator|)
operator|!=
name|SNMP_ERR_NOERROR
condition|)
block|{
if|if
condition|(
name|pdu
operator|->
name|version
operator|!=
name|SNMP_V1
condition|)
block|{
name|pdu
operator|->
name|error_status
operator|=
name|SNMP_ERR_UNDO_FAILED
expr_stmt|;
name|pdu
operator|->
name|error_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|rollback
argument_list|(
operator|&
name|context
argument_list|,
name|pdu
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|code
operator|=
name|SNMP_RET_ERR
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
comment|/* 	 * 4. Commit and copy values from the original packet to the response. 	 *    This is not the commit operation from RFC 1905 but rather an 	 *    'FREE RESOURCES' operation. It shouldn't fail. 	 */
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: commiting"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdu
operator|->
name|nbindings
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
operator|&
name|resp
operator|->
name|bindings
index|[
name|i
index|]
expr_stmt|;
name|np
operator|=
name|context
operator|.
name|node
index|[
name|i
index|]
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|var_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|scratch
operator|=
operator|&
name|context
operator|.
name|scratch
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
call|(
modifier|*
name|np
operator|->
name|op
call|)
argument_list|(
operator|&
name|context
operator|.
name|ctx
argument_list|,
name|b
argument_list|,
name|np
operator|->
name|oid
operator|.
name|len
argument_list|,
name|np
operator|->
name|index
argument_list|,
name|SNMP_OP_COMMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|SNMP_ERR_NOERROR
condition|)
name|snmp_error
argument_list|(
literal|"set: commit failed (%d) on"
literal|" variable %s index %u"
argument_list|,
name|ret
argument_list|,
name|asn_oid2str_r
argument_list|(
operator|&
name|b
operator|->
name|var
argument_list|,
name|oidbuf
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snmp_fix_encoding
argument_list|(
name|resp_b
argument_list|,
name|resp
argument_list|)
operator|!=
name|SNMP_CODE_OK
condition|)
block|{
name|snmp_error
argument_list|(
literal|"set: fix_encoding failed"
argument_list|)
expr_stmt|;
name|snmp_pdu_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|context
operator|.
name|ctx
operator|.
name|code
operator|=
name|SNMP_RET_IGN
expr_stmt|;
block|}
comment|/* 	 * Done 	 */
name|errout
label|:
name|snmp_dep_finish
argument_list|(
operator|&
name|context
operator|.
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|SET
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"set: returning %d"
argument_list|,
name|context
operator|.
name|ctx
operator|.
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
name|context
operator|.
name|ctx
operator|.
name|code
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a dependency. If it doesn't exist, create one  */
end_comment

begin_function
name|struct
name|snmp_dependency
modifier|*
name|snmp_dep_lookup
parameter_list|(
name|struct
name|snmp_context
modifier|*
name|ctx
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|obj
parameter_list|,
specifier|const
name|struct
name|asn_oid
modifier|*
name|idx
parameter_list|,
name|size_t
name|len
parameter_list|,
name|snmp_depop_t
name|func
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
decl_stmt|;
name|struct
name|depend
modifier|*
name|d
decl_stmt|;
name|context
operator|=
operator|(
expr|struct
name|context
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ctx
operator|-
name|offsetof
argument_list|(
expr|struct
name|context
argument_list|,
name|ctx
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TR
argument_list|(
name|DEPEND
argument_list|)
condition|)
block|{
name|snmp_debug
argument_list|(
literal|"depend: looking for %s"
argument_list|,
name|asn_oid2str
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
condition|)
name|snmp_debug
argument_list|(
literal|"depend: index is %s"
argument_list|,
name|asn_oid2str
argument_list|(
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&context->dlist
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|asn_compare_oid
argument_list|(
name|obj
argument_list|,
operator|&
name|d
operator|->
name|dep
operator|.
name|obj
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|idx
operator|==
name|NULL
operator|&&
name|d
operator|->
name|dep
operator|.
name|idx
operator|.
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|idx
operator|!=
name|NULL
operator|&&
name|asn_compare_oid
argument_list|(
name|idx
argument_list|,
operator|&
name|d
operator|->
name|dep
operator|.
name|idx
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TR
argument_list|(
name|DEPEND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"depend: found"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|d
operator|->
name|dep
operator|)
return|;
block|}
if|if
condition|(
name|TR
argument_list|(
name|DEPEND
argument_list|)
condition|)
name|snmp_debug
argument_list|(
literal|"depend: creating"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|malloc
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|depend
argument_list|,
name|dep
argument_list|)
operator|+
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
operator|&
name|d
operator|->
name|dep
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d
operator|->
name|dep
operator|.
name|obj
operator|=
operator|*
name|obj
expr_stmt|;
if|if
condition|(
name|idx
operator|==
name|NULL
condition|)
name|d
operator|->
name|dep
operator|.
name|idx
operator|.
name|len
operator|=
literal|0
expr_stmt|;
else|else
name|d
operator|->
name|dep
operator|.
name|idx
operator|=
operator|*
name|idx
expr_stmt|;
name|d
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|d
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|context
operator|->
name|dlist
argument_list|,
name|d
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|d
operator|->
name|dep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make an error response from a PDU. We do this without decoding the  * variable bindings. This means we can sent the junk back to a caller  * that has sent us junk in the first place.   */
end_comment

begin_function
name|enum
name|snmp_ret
name|snmp_make_errresp
parameter_list|(
specifier|const
name|struct
name|snmp_pdu
modifier|*
name|pdu
parameter_list|,
name|struct
name|asn_buf
modifier|*
name|pdu_b
parameter_list|,
name|struct
name|asn_buf
modifier|*
name|resp_b
parameter_list|)
block|{
name|u_char
name|type
decl_stmt|;
name|asn_len_t
name|len
decl_stmt|;
name|struct
name|snmp_pdu
name|resp
decl_stmt|;
name|enum
name|asn_err
name|err
decl_stmt|;
name|enum
name|snmp_code
name|code
decl_stmt|;
name|snmp_pdu_create_response
argument_list|(
name|pdu
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|snmp_pdu_decode_header
argument_list|(
name|pdu_b
argument_list|,
operator|&
name|resp
argument_list|)
operator|)
operator|!=
name|SNMP_CODE_OK
condition|)
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
if|if
condition|(
name|pdu
operator|->
name|version
operator|==
name|SNMP_V3
condition|)
block|{
if|if
condition|(
name|resp
operator|.
name|user
operator|.
name|priv_proto
operator|!=
name|SNMP_PRIV_NOPRIV
operator|&&
operator|(
name|asn_get_header
argument_list|(
name|pdu_b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|resp
operator|.
name|scoped_len
argument_list|)
operator|!=
name|ASN_ERR_OK
operator|||
name|type
operator|!=
name|ASN_TYPE_OCTETSTRING
operator|)
condition|)
block|{
name|snmp_error
argument_list|(
literal|"cannot decode encrypted pdu"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
block|}
if|if
condition|(
name|asn_get_sequence
argument_list|(
name|pdu_b
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|ASN_ERR_OK
condition|)
block|{
name|snmp_error
argument_list|(
literal|"cannot decode scoped pdu header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
block|}
name|len
operator|=
name|SNMP_ENGINE_ID_SIZ
expr_stmt|;
if|if
condition|(
name|asn_get_octetstring
argument_list|(
name|pdu_b
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|resp
operator|.
name|context_engine
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|ASN_ERR_OK
condition|)
block|{
name|snmp_error
argument_list|(
literal|"cannot decode msg context engine"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
block|}
name|resp
operator|.
name|context_engine_len
operator|=
name|len
expr_stmt|;
name|len
operator|=
name|SNMP_CONTEXT_NAME_SIZ
expr_stmt|;
if|if
condition|(
name|asn_get_octetstring
argument_list|(
name|pdu_b
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|resp
operator|.
name|context_name
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|ASN_ERR_OK
condition|)
block|{
name|snmp_error
argument_list|(
literal|"cannot decode msg context name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
block|}
name|resp
operator|.
name|context_name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|asn_get_header
argument_list|(
name|pdu_b
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|ASN_ERR_OK
condition|)
block|{
name|snmp_error
argument_list|(
literal|"cannot get pdu header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
operator|~
name|ASN_TYPE_MASK
operator|)
operator|!=
operator|(
name|ASN_TYPE_CONSTRUCTED
operator||
name|ASN_CLASS_CONTEXT
operator|)
condition|)
block|{
name|snmp_error
argument_list|(
literal|"bad pdu header tag"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
block|}
name|err
operator|=
name|snmp_parse_pdus_hdr
argument_list|(
name|pdu_b
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASN_ERR_STOPPED
argument_list|(
name|err
argument_list|)
condition|)
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
if|if
condition|(
name|pdu_b
operator|->
name|asn_len
operator|<
name|len
condition|)
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
name|pdu_b
operator|->
name|asn_len
operator|=
name|len
expr_stmt|;
comment|/* now we have the bindings left - construct new message */
name|resp
operator|.
name|error_status
operator|=
name|pdu
operator|->
name|error_status
expr_stmt|;
name|resp
operator|.
name|error_index
operator|=
name|pdu
operator|->
name|error_index
expr_stmt|;
name|resp
operator|.
name|type
operator|=
name|SNMP_PDU_RESPONSE
expr_stmt|;
name|code
operator|=
name|snmp_pdu_encode_header
argument_list|(
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|SNMP_CODE_OK
condition|)
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
if|if
condition|(
name|pdu_b
operator|->
name|asn_len
operator|>
name|resp_b
operator|->
name|asn_len
condition|)
comment|/* too short */
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|resp_b
operator|->
name|asn_ptr
argument_list|,
name|pdu_b
operator|->
name|asn_cptr
argument_list|,
name|pdu_b
operator|->
name|asn_len
argument_list|)
expr_stmt|;
name|resp_b
operator|->
name|asn_len
operator|-=
name|pdu_b
operator|->
name|asn_len
expr_stmt|;
name|resp_b
operator|->
name|asn_ptr
operator|+=
name|pdu_b
operator|->
name|asn_len
expr_stmt|;
name|code
operator|=
name|snmp_fix_encoding
argument_list|(
name|resp_b
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|SNMP_CODE_OK
condition|)
return|return
operator|(
name|SNMP_RET_IGN
operator|)
return|;
return|return
operator|(
name|SNMP_RET_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|snmp_debug_func
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

