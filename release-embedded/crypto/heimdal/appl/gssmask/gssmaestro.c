begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of KTH nor the names of its contributors may be  *    used to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY KTH AND ITS CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL KTH OR ITS CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<common.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  */
end_comment

begin_struct
struct|struct
name|client
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|socklen_t
name|salen
decl_stmt|;
name|krb5_storage
modifier|*
name|sock
decl_stmt|;
name|int32_t
name|capabilities
decl_stmt|;
name|char
modifier|*
name|target_name
decl_stmt|;
name|char
modifier|*
name|moniker
decl_stmt|;
name|krb5_storage
modifier|*
name|logsock
decl_stmt|;
name|int
name|have_log
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_PTHREAD_SUPPORT
name|pthread_t
name|thr
decl_stmt|;
else|#
directive|else
name|pid_t
name|child
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|client
modifier|*
modifier|*
name|clients
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_clients
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_sec_context
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
modifier|*
name|hContext
parameter_list|,
name|int32_t
modifier|*
name|hCred
parameter_list|,
name|int32_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|targetname
parameter_list|,
specifier|const
name|krb5_data
modifier|*
name|itoken
parameter_list|,
name|krb5_data
modifier|*
name|otoken
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|krb5_data_zero
argument_list|(
name|otoken
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eInitContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
operator|*
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
operator|*
name|hCred
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|putstring
argument_list|(
name|client
argument_list|,
name|targetname
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|itoken
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
operator|*
name|hContext
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|retdata
argument_list|(
name|client
argument_list|,
operator|*
name|otoken
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|accept_sec_context
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
modifier|*
name|hContext
parameter_list|,
name|int32_t
name|flags
parameter_list|,
specifier|const
name|krb5_data
modifier|*
name|itoken
parameter_list|,
name|krb5_data
modifier|*
name|otoken
parameter_list|,
name|int32_t
modifier|*
name|hDelegCred
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|krb5_data_zero
argument_list|(
name|otoken
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eAcceptContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
operator|*
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|itoken
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
operator|*
name|hContext
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|retdata
argument_list|(
name|client
argument_list|,
operator|*
name|otoken
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
operator|*
name|hDelegCred
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|acquire_cred
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
modifier|*
name|hCred
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eAcquireCreds
argument_list|)
expr_stmt|;
name|putstring
argument_list|(
name|client
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|putstring
argument_list|(
name|client
argument_list|,
name|password
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
operator|*
name|hCred
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|toast_resource
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
name|hCred
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eToastResource
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|hCred
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|goodbye
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|)
block|{
name|put32
argument_list|(
name|client
argument_list|,
name|eGoodBye
argument_list|)
expr_stmt|;
return|return
name|GSMERR_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_targetname
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|char
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|put32
argument_list|(
name|client
argument_list|,
name|eGetTargetName
argument_list|)
expr_stmt|;
name|retstring
argument_list|(
name|client
argument_list|,
operator|*
name|target
argument_list|)
expr_stmt|;
return|return
name|GSMERR_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|encrypt_token
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
name|hContext
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|krb5_data
modifier|*
name|in
parameter_list|,
name|krb5_data
modifier|*
name|out
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eEncrypt
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|in
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|retdata
argument_list|(
name|client
argument_list|,
operator|*
name|out
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|decrypt_token
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
name|hContext
parameter_list|,
name|int
name|flags
parameter_list|,
name|krb5_data
modifier|*
name|in
parameter_list|,
name|krb5_data
modifier|*
name|out
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eDecrypt
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|in
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|retdata
argument_list|(
name|client
argument_list|,
operator|*
name|out
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|wrap_token_ext
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
name|hContext
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
name|bflags
parameter_list|,
name|krb5_data
modifier|*
name|header
parameter_list|,
name|krb5_data
modifier|*
name|in
parameter_list|,
name|krb5_data
modifier|*
name|trailer
parameter_list|,
name|krb5_data
modifier|*
name|out
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eWrapExt
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|bflags
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|header
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|in
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|trailer
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|retdata
argument_list|(
name|client
argument_list|,
operator|*
name|out
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|unwrap_token_ext
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
name|hContext
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
name|bflags
parameter_list|,
name|krb5_data
modifier|*
name|header
parameter_list|,
name|krb5_data
modifier|*
name|in
parameter_list|,
name|krb5_data
modifier|*
name|trailer
parameter_list|,
name|krb5_data
modifier|*
name|out
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eUnwrapExt
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|bflags
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|header
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|in
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|trailer
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|retdata
argument_list|(
name|client
argument_list|,
operator|*
name|out
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|get_mic
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
name|hContext
parameter_list|,
name|krb5_data
modifier|*
name|in
parameter_list|,
name|krb5_data
modifier|*
name|mic
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eSign
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|in
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|retdata
argument_list|(
name|client
argument_list|,
operator|*
name|mic
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|verify_mic
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
name|hContext
parameter_list|,
name|krb5_data
modifier|*
name|in
parameter_list|,
name|krb5_data
modifier|*
name|mic
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|eVerify
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
name|hContext
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|client
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|in
argument_list|)
expr_stmt|;
name|putdata
argument_list|(
name|client
argument_list|,
operator|*
name|mic
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|get_version_capa
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|int32_t
modifier|*
name|version
parameter_list|,
name|int32_t
modifier|*
name|capa
parameter_list|,
name|char
modifier|*
modifier|*
name|version_str
parameter_list|)
block|{
name|put32
argument_list|(
name|client
argument_list|,
name|eGetVersionAndCapabilities
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
operator|*
name|version
argument_list|)
expr_stmt|;
name|ret32
argument_list|(
name|client
argument_list|,
operator|*
name|capa
argument_list|)
expr_stmt|;
name|retstring
argument_list|(
name|client
argument_list|,
operator|*
name|version_str
argument_list|)
expr_stmt|;
return|return
name|GSMERR_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|get_moniker
parameter_list|(
name|struct
name|client
modifier|*
name|client
parameter_list|,
name|char
modifier|*
modifier|*
name|moniker
parameter_list|)
block|{
name|put32
argument_list|(
name|client
argument_list|,
name|eGetMoniker
argument_list|)
expr_stmt|;
name|retstring
argument_list|(
name|client
argument_list|,
operator|*
name|moniker
argument_list|)
expr_stmt|;
return|return
name|GSMERR_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_log
parameter_list|(
name|struct
name|client
modifier|*
name|c
parameter_list|)
block|{
name|int32_t
name|port
decl_stmt|;
name|struct
name|sockaddr_storage
name|sast
decl_stmt|;
name|socklen_t
name|salen
init|=
sizeof|sizeof
argument_list|(
name|sast
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|fd2
decl_stmt|,
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sast
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sast
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|sast
argument_list|)
operator|>=
name|c
operator|->
name|salen
argument_list|)
expr_stmt|;
name|fd
operator|=
name|socket
argument_list|(
name|c
operator|->
name|sa
operator|->
name|sa_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"failed to build socket for %s's logging port"
argument_list|,
name|c
operator|->
name|moniker
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sast
operator|)
operator|->
name|sa_family
operator|=
name|c
operator|->
name|sa
operator|->
name|sa_family
expr_stmt|;
name|ret
operator|=
name|bind
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sast
argument_list|,
name|c
operator|->
name|salen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"failed to bind %s's logging port"
argument_list|,
name|c
operator|->
name|moniker
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|fd
argument_list|,
name|SOMAXCONN
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"failed to listen %s's logging port"
argument_list|,
name|c
operator|->
name|moniker
argument_list|)
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|sast
argument_list|)
expr_stmt|;
name|ret
operator|=
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sast
argument_list|,
operator|&
name|salen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"failed to get address of local socket for %s"
argument_list|,
name|c
operator|->
name|moniker
argument_list|)
expr_stmt|;
name|port
operator|=
name|socket_get_port
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sast
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|c
argument_list|,
name|eSetLoggingSocket
argument_list|)
expr_stmt|;
name|put32
argument_list|(
name|c
argument_list|,
name|ntohs
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
argument_list|(
name|sast
argument_list|)
expr_stmt|;
name|fd2
operator|=
name|accept
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sast
argument_list|,
operator|&
name|salen
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd2
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"failed to accept local socket for %s"
argument_list|,
name|c
operator|->
name|moniker
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|fd2
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|build_context
parameter_list|(
name|struct
name|client
modifier|*
name|ipeer
parameter_list|,
name|struct
name|client
modifier|*
name|apeer
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
name|hCred
parameter_list|,
name|int32_t
modifier|*
name|iContext
parameter_list|,
name|int32_t
modifier|*
name|aContext
parameter_list|,
name|int32_t
modifier|*
name|hDelegCred
parameter_list|)
block|{
name|int32_t
name|val
init|=
name|GSMERR_ERROR
decl_stmt|,
name|ic
init|=
literal|0
decl_stmt|,
name|ac
init|=
literal|0
decl_stmt|,
name|deleg
init|=
literal|0
decl_stmt|;
name|krb5_data
name|itoken
decl_stmt|,
name|otoken
decl_stmt|;
name|int
name|iDone
init|=
literal|0
decl_stmt|,
name|aDone
init|=
literal|0
decl_stmt|;
name|int
name|step
init|=
literal|0
decl_stmt|;
name|int
name|first_call
init|=
literal|0x80
decl_stmt|;
if|if
condition|(
name|apeer
operator|->
name|target_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"apeer %s have no target name"
argument_list|,
name|apeer
operator|->
name|name
argument_list|)
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|itoken
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|iDone
operator|||
operator|!
name|aDone
condition|)
block|{
if|if
condition|(
name|iDone
condition|)
block|{
name|warnx
argument_list|(
literal|"iPeer already done, aPeer want extra rtt"
argument_list|)
expr_stmt|;
name|val
operator|=
name|GSMERR_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|val
operator|=
name|init_sec_context
argument_list|(
name|ipeer
argument_list|,
operator|&
name|ic
argument_list|,
operator|&
name|hCred
argument_list|,
name|flags
operator||
name|first_call
argument_list|,
name|apeer
operator|->
name|target_name
argument_list|,
operator|&
name|itoken
argument_list|,
operator|&
name|otoken
argument_list|)
expr_stmt|;
name|step
operator|++
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|GSMERR_OK
case|:
name|iDone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|aDone
condition|)
continue|continue;
break|break;
case|case
name|GSMERR_CONTINUE_NEEDED
case|:
break|break;
default|default:
name|warnx
argument_list|(
literal|"iPeer %s failed with %d (step %d)"
argument_list|,
name|ipeer
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|,
name|step
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|aDone
condition|)
block|{
name|warnx
argument_list|(
literal|"aPeer already done, iPeer want extra rtt"
argument_list|)
expr_stmt|;
name|val
operator|=
name|GSMERR_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|val
operator|=
name|accept_sec_context
argument_list|(
name|apeer
argument_list|,
operator|&
name|ac
argument_list|,
name|flags
operator||
name|first_call
argument_list|,
operator|&
name|otoken
argument_list|,
operator|&
name|itoken
argument_list|,
operator|&
name|deleg
argument_list|)
expr_stmt|;
name|step
operator|++
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|GSMERR_OK
case|:
name|aDone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|iDone
condition|)
continue|continue;
break|break;
case|case
name|GSMERR_CONTINUE_NEEDED
case|:
break|break;
default|default:
name|warnx
argument_list|(
literal|"aPeer %s failed with %d (step %d)"
argument_list|,
name|apeer
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|val
operator|=
name|GSMERR_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|first_call
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|GSMERR_OK
expr_stmt|;
block|}
if|if
condition|(
name|iContext
operator|==
name|NULL
operator|||
name|val
operator|!=
name|GSMERR_OK
condition|)
block|{
if|if
condition|(
name|ic
condition|)
name|toast_resource
argument_list|(
name|ipeer
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|iContext
condition|)
operator|*
name|iContext
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|iContext
operator|=
name|ic
expr_stmt|;
if|if
condition|(
name|aContext
operator|==
name|NULL
operator|||
name|val
operator|!=
name|GSMERR_OK
condition|)
block|{
if|if
condition|(
name|ac
condition|)
name|toast_resource
argument_list|(
name|apeer
argument_list|,
name|ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|aContext
condition|)
operator|*
name|aContext
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|aContext
operator|=
name|ac
expr_stmt|;
if|if
condition|(
name|hDelegCred
operator|==
name|NULL
operator|||
name|val
operator|!=
name|GSMERR_OK
condition|)
block|{
if|if
condition|(
name|deleg
condition|)
name|toast_resource
argument_list|(
name|apeer
argument_list|,
name|deleg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hDelegCred
condition|)
operator|*
name|hDelegCred
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|hDelegCred
operator|=
name|deleg
expr_stmt|;
name|out
label|:
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_mic
parameter_list|(
name|struct
name|client
modifier|*
name|c1
parameter_list|,
name|int32_t
name|hc1
parameter_list|,
name|struct
name|client
modifier|*
name|c2
parameter_list|,
name|int32_t
name|hc2
parameter_list|)
block|{
name|krb5_data
name|msg
decl_stmt|,
name|mic
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
name|msg
operator|.
name|data
operator|=
literal|"foo"
expr_stmt|;
name|msg
operator|.
name|length
operator|=
literal|3
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|mic
argument_list|)
expr_stmt|;
name|val
operator|=
name|get_mic
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|mic
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"get_mic failed to host: %s"
argument_list|,
name|c1
operator|->
name|moniker
argument_list|)
expr_stmt|;
name|val
operator|=
name|verify_mic
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|mic
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"verify_mic failed to host: %s"
argument_list|,
name|c2
operator|->
name|moniker
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|mic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|test_wrap
parameter_list|(
name|struct
name|client
modifier|*
name|c1
parameter_list|,
name|int32_t
name|hc1
parameter_list|,
name|struct
name|client
modifier|*
name|c2
parameter_list|,
name|int32_t
name|hc2
parameter_list|,
name|int
name|conf
parameter_list|)
block|{
name|krb5_data
name|msg
decl_stmt|,
name|wrapped
decl_stmt|,
name|out
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
name|msg
operator|.
name|data
operator|=
literal|"foo"
expr_stmt|;
name|msg
operator|.
name|length
operator|=
literal|3
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|wrapped
argument_list|)
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|val
operator|=
name|encrypt_token
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|conf
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|wrapped
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|warnx
argument_list|(
literal|"encrypt_token failed to host: %s"
argument_list|,
name|c1
operator|->
name|moniker
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|val
operator|=
name|decrypt_token
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|conf
argument_list|,
operator|&
name|wrapped
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|krb5_data_free
argument_list|(
operator|&
name|wrapped
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"decrypt_token failed to host: %s"
argument_list|,
name|c2
operator|->
name|moniker
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|msg
operator|.
name|length
operator|!=
name|out
operator|.
name|length
condition|)
block|{
name|warnx
argument_list|(
literal|"decrypted'ed token have wrong length (%lu != %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|msg
operator|.
name|length
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|out
operator|.
name|length
argument_list|)
expr_stmt|;
name|val
operator|=
name|GSMERR_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|msg
operator|.
name|data
argument_list|,
name|out
operator|.
name|data
argument_list|,
name|msg
operator|.
name|length
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"decryptd'ed token have wrong data"
argument_list|)
expr_stmt|;
name|val
operator|=
name|GSMERR_ERROR
expr_stmt|;
block|}
name|krb5_data_free
argument_list|(
operator|&
name|wrapped
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|test_wrap_ext
parameter_list|(
name|struct
name|client
modifier|*
name|c1
parameter_list|,
name|int32_t
name|hc1
parameter_list|,
name|struct
name|client
modifier|*
name|c2
parameter_list|,
name|int32_t
name|hc2
parameter_list|,
name|int
name|conf
parameter_list|,
name|int
name|bflags
parameter_list|)
block|{
name|krb5_data
name|header
decl_stmt|,
name|msg
decl_stmt|,
name|trailer
decl_stmt|,
name|wrapped
decl_stmt|,
name|out
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
name|header
operator|.
name|data
operator|=
literal|"header"
expr_stmt|;
name|header
operator|.
name|length
operator|=
literal|6
expr_stmt|;
name|msg
operator|.
name|data
operator|=
literal|"0123456789abcdef"
expr_stmt|;
comment|/* padded for most enctypes */
name|msg
operator|.
name|length
operator|=
literal|32
expr_stmt|;
name|trailer
operator|.
name|data
operator|=
literal|"trailer"
expr_stmt|;
name|trailer
operator|.
name|length
operator|=
literal|7
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|wrapped
argument_list|)
expr_stmt|;
name|krb5_data_zero
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
name|val
operator|=
name|wrap_token_ext
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|conf
argument_list|,
name|bflags
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|trailer
argument_list|,
operator|&
name|wrapped
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|warnx
argument_list|(
literal|"encrypt_token failed to host: %s"
argument_list|,
name|c1
operator|->
name|moniker
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|val
operator|=
name|unwrap_token_ext
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|conf
argument_list|,
name|bflags
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|wrapped
argument_list|,
operator|&
name|trailer
argument_list|,
operator|&
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|krb5_data_free
argument_list|(
operator|&
name|wrapped
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"decrypt_token failed to host: %s"
argument_list|,
name|c2
operator|->
name|moniker
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|msg
operator|.
name|length
operator|!=
name|out
operator|.
name|length
condition|)
block|{
name|warnx
argument_list|(
literal|"decrypted'ed token have wrong length (%lu != %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|msg
operator|.
name|length
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|out
operator|.
name|length
argument_list|)
expr_stmt|;
name|val
operator|=
name|GSMERR_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|msg
operator|.
name|data
argument_list|,
name|out
operator|.
name|data
argument_list|,
name|msg
operator|.
name|length
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"decryptd'ed token have wrong data"
argument_list|)
expr_stmt|;
name|val
operator|=
name|GSMERR_ERROR
expr_stmt|;
block|}
name|krb5_data_free
argument_list|(
operator|&
name|wrapped
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|out
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|test_token
parameter_list|(
name|struct
name|client
modifier|*
name|c1
parameter_list|,
name|int32_t
name|hc1
parameter_list|,
name|struct
name|client
modifier|*
name|c2
parameter_list|,
name|int32_t
name|hc2
parameter_list|,
name|int
name|wrap_ext
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|/* mic */
name|test_mic
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|c2
argument_list|,
name|hc2
argument_list|)
expr_stmt|;
name|test_mic
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|c1
argument_list|,
name|hc1
argument_list|)
expr_stmt|;
comment|/* wrap */
name|val
operator|=
name|test_wrap
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|c2
argument_list|,
name|hc2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|c1
argument_list|,
name|hc1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|c2
argument_list|,
name|hc2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|c1
argument_list|,
name|hc1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
if|if
condition|(
name|wrap_ext
condition|)
block|{
comment|/* wrap ext */
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|c2
argument_list|,
name|hc2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|c1
argument_list|,
name|hc1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|c2
argument_list|,
name|hc2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|c1
argument_list|,
name|hc1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|c2
argument_list|,
name|hc2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|c1
argument_list|,
name|hc1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c1
argument_list|,
name|hc1
argument_list|,
name|c2
argument_list|,
name|hc2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|test_wrap_ext
argument_list|(
name|c2
argument_list|,
name|hc2
argument_list|,
name|c1
argument_list|,
name|hc1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
block|}
block|}
return|return
name|GSMERR_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|log_function
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|client
modifier|*
name|c
init|=
name|ptr
decl_stmt|;
name|int32_t
name|cmd
decl_stmt|,
name|line
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|string
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|krb5_ret_int32
argument_list|(
name|c
operator|->
name|logsock
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|eLogSetMoniker
case|:
if|if
condition|(
name|krb5_ret_string
argument_list|(
name|c
operator|->
name|logsock
argument_list|,
operator|&
name|file
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|eLogInfo
case|:
case|case
name|eLogFailure
case|:
if|if
condition|(
name|krb5_ret_string
argument_list|(
name|c
operator|->
name|logsock
argument_list|,
operator|&
name|file
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|krb5_ret_int32
argument_list|(
name|c
operator|->
name|logsock
argument_list|,
operator|&
name|line
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|krb5_ret_string
argument_list|(
name|c
operator|->
name|logsock
argument_list|,
operator|&
name|string
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|printf
argument_list|(
literal|"%s:%lu: %s\n"
argument_list|,
name|file
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|line
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s:%lu: %s\n"
argument_list|,
name|file
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|line
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb5_store_int32
argument_list|(
name|c
operator|->
name|logsock
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"client send bad log command: %d"
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|connect_client
parameter_list|(
specifier|const
name|char
modifier|*
name|slave
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|port
decl_stmt|;
name|struct
name|client
modifier|*
name|c
init|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res0
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|fd
decl_stmt|;
name|name
operator|=
name|estrdup
argument_list|(
name|slave
argument_list|)
expr_stmt|;
name|port
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"port missing from %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|port
operator|++
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|slave
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|ret
operator|=
name|getaddrinfo
argument_list|(
name|name
argument_list|,
name|port
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error resolving %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|res
operator|=
name|res0
operator|,
name|fd
operator|=
operator|-
literal|1
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
name|fd
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|connect
argument_list|(
name|fd
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|c
operator|->
name|sa
operator|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|c
operator|->
name|sa
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|c
operator|->
name|salen
operator|=
name|res
operator|->
name|ai_addrlen
expr_stmt|;
break|break;
comment|/* okay we got one */
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"connect to host: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|c
operator|->
name|sock
operator|=
name|krb5_storage_from_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|sock
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"krb5_storage_from_fd"
argument_list|)
expr_stmt|;
block|{
name|int32_t
name|version
decl_stmt|;
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
name|get_version_capa
argument_list|(
name|c
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|c
operator|->
name|capabilities
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|capabilities
operator|&
name|HAS_MONIKER
condition|)
name|get_moniker
argument_list|(
name|c
argument_list|,
operator|&
name|c
operator|->
name|moniker
argument_list|)
expr_stmt|;
else|else
name|c
operator|->
name|moniker
operator|=
name|c
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|capabilities
operator|&
name|ISSERVER
condition|)
name|get_targetname
argument_list|(
name|c
argument_list|,
operator|&
name|c
operator|->
name|target_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logfile
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|printf
argument_list|(
literal|"starting log socket to client %s\n"
argument_list|,
name|c
operator|->
name|moniker
argument_list|)
expr_stmt|;
name|fd
operator|=
name|wait_log
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|logsock
operator|=
name|krb5_storage_from_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|logsock
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed to create log krb5_storage"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_PTHREAD_SUPPORT
name|pthread_create
argument_list|(
operator|&
name|c
operator|->
name|thr
argument_list|,
name|NULL
argument_list|,
name|log_function
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|->
name|child
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|child
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed to fork"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|child
operator|==
literal|0
condition|)
block|{
name|log_function
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|clients
operator|=
name|erealloc
argument_list|(
name|clients
argument_list|,
operator|(
name|num_clients
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|clients
argument_list|)
argument_list|)
expr_stmt|;
name|clients
index|[
name|num_clients
index|]
operator|=
name|c
expr_stmt|;
name|num_clients
operator|++
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|client
modifier|*
name|get_client
parameter_list|(
specifier|const
name|char
modifier|*
name|slave
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_clients
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|slave
argument_list|,
name|clients
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|clients
index|[
name|i
index|]
return|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed to find client %s"
argument_list|,
name|slave
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|version_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|help_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wrap_ext
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logfile_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|getarg_strings
name|principals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|getarg_strings
name|slaves
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|getargs
name|args
index|[]
init|=
block|{
block|{
literal|"principals"
block|,
literal|0
block|,
name|arg_strings
block|,
operator|&
name|principals
block|,
literal|"Test principal"
block|,
name|NULL
block|}
block|,
block|{
literal|"slaves"
block|,
literal|0
block|,
name|arg_strings
block|,
operator|&
name|slaves
block|,
literal|"Slaves"
block|,
name|NULL
block|}
block|,
block|{
literal|"log-file"
block|,
literal|0
block|,
name|arg_string
block|,
operator|&
name|logfile_str
block|,
literal|"Logfile"
block|,
name|NULL
block|}
block|,
block|{
literal|"wrap-ext"
block|,
literal|0
block|,
name|arg_flag
block|,
operator|&
name|wrap_ext
block|,
literal|"test wrap extended"
block|,
name|NULL
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
name|arg_flag
block|,
operator|&
name|version_flag
block|,
literal|"Print version"
block|,
name|NULL
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
name|arg_flag
block|,
operator|&
name|help_flag
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|ret
parameter_list|)
block|{
name|arg_printusage
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|optidx
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|password
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|size_t
name|num_list
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|setprogname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|optidx
argument_list|)
condition|)
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|help_flag
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|version_flag
condition|)
block|{
name|print_version
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|optidx
operator|!=
name|argc
condition|)
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|principals
operator|.
name|num_strings
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no principals"
argument_list|)
expr_stmt|;
name|user
operator|=
name|estrdup
argument_list|(
name|principals
operator|.
name|strings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|password
operator|=
name|strchr
argument_list|(
name|user
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|password
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"password missing from %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
operator|*
name|password
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|slaves
operator|.
name|num_strings
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"no principals"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile_str
condition|)
block|{
name|printf
argument_list|(
literal|"open logfile %s\n"
argument_list|,
name|logfile_str
argument_list|)
expr_stmt|;
name|logfile
operator|=
name|fopen
argument_list|(
name|logfile_str
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"failed to open: %s"
argument_list|,
name|logfile_str
argument_list|)
expr_stmt|;
block|}
comment|/*      *      */
name|list
operator|=
name|permutate_all
argument_list|(
operator|&
name|slaves
argument_list|,
operator|&
name|num_list
argument_list|)
expr_stmt|;
comment|/*      * Set up connection to all clients      */
name|printf
argument_list|(
literal|"Connecting to slaves\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slaves
operator|.
name|num_strings
condition|;
name|i
operator|++
control|)
name|connect_client
argument_list|(
name|slaves
operator|.
name|strings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*      * Test acquire credentials      */
name|printf
argument_list|(
literal|"Test acquire credentials\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slaves
operator|.
name|num_strings
condition|;
name|i
operator|++
control|)
block|{
name|int32_t
name|hCred
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|acquire_cred
argument_list|(
name|clients
index|[
name|i
index|]
argument_list|,
name|user
argument_list|,
name|password
argument_list|,
literal|1
argument_list|,
operator|&
name|hCred
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|GSMERR_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"Failed to acquire_cred on host %s: %d"
argument_list|,
name|clients
index|[
name|i
index|]
operator|->
name|moniker
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|toast_resource
argument_list|(
name|clients
index|[
name|i
index|]
argument_list|,
name|hCred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
goto|goto
name|out
goto|;
comment|/*      * First test if all slaves can build context to them-self.      */
name|printf
argument_list|(
literal|"Self context tests\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_clients
condition|;
name|i
operator|++
control|)
block|{
name|int32_t
name|hCred
decl_stmt|,
name|val
decl_stmt|,
name|delegCred
decl_stmt|;
name|int32_t
name|clientC
decl_stmt|,
name|serverC
decl_stmt|;
name|struct
name|client
modifier|*
name|c
init|=
name|clients
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|target_name
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%s connects to self using %s\n"
argument_list|,
name|c
operator|->
name|moniker
argument_list|,
name|c
operator|->
name|target_name
argument_list|)
expr_stmt|;
name|val
operator|=
name|acquire_cred
argument_list|(
name|c
argument_list|,
name|user
argument_list|,
name|password
argument_list|,
literal|1
argument_list|,
operator|&
name|hCred
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|GSMERR_OK
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed to acquire_cred: %d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_context
argument_list|(
name|c
argument_list|,
name|c
argument_list|,
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_SEQUENCE_FLAG
operator||
name|GSS_C_INTEG_FLAG
operator||
name|GSS_C_CONF_FLAG
operator||
name|GSS_C_DELEG_FLAG
operator||
name|GSS_C_MUTUAL_FLAG
argument_list|,
name|hCred
argument_list|,
operator|&
name|clientC
argument_list|,
operator|&
name|serverC
argument_list|,
operator|&
name|delegCred
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|GSMERR_OK
condition|)
block|{
name|test_token
argument_list|(
name|c
argument_list|,
name|clientC
argument_list|,
name|c
argument_list|,
name|serverC
argument_list|,
name|wrap_ext
argument_list|)
expr_stmt|;
name|toast_resource
argument_list|(
name|c
argument_list|,
name|clientC
argument_list|)
expr_stmt|;
name|toast_resource
argument_list|(
name|c
argument_list|,
name|serverC
argument_list|)
expr_stmt|;
if|if
condition|(
name|delegCred
condition|)
name|toast_resource
argument_list|(
name|c
argument_list|,
name|delegCred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"build_context failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 	 */
name|val
operator|=
name|build_context
argument_list|(
name|c
argument_list|,
name|c
argument_list|,
name|GSS_C_INTEG_FLAG
operator||
name|GSS_C_CONF_FLAG
argument_list|,
name|hCred
argument_list|,
operator|&
name|clientC
argument_list|,
operator|&
name|serverC
argument_list|,
operator|&
name|delegCred
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|GSMERR_OK
condition|)
block|{
name|test_token
argument_list|(
name|c
argument_list|,
name|clientC
argument_list|,
name|c
argument_list|,
name|serverC
argument_list|,
name|wrap_ext
argument_list|)
expr_stmt|;
name|toast_resource
argument_list|(
name|c
argument_list|,
name|clientC
argument_list|)
expr_stmt|;
name|toast_resource
argument_list|(
name|c
argument_list|,
name|serverC
argument_list|)
expr_stmt|;
if|if
condition|(
name|delegCred
condition|)
name|toast_resource
argument_list|(
name|c
argument_list|,
name|delegCred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"build_context failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
name|toast_resource
argument_list|(
name|c
argument_list|,
name|hCred
argument_list|)
expr_stmt|;
block|}
comment|/*      * Build contexts though all entries in each lists, including the      * step from the last entry to the first, ie treat the list as a      * circle.      *      * Only follow the delegated credential, but test "all"      * flags. (XXX only do deleg|mutual right now.      */
name|printf
argument_list|(
literal|"\"All\" permutation tests\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_list
condition|;
name|i
operator|++
control|)
block|{
name|int32_t
name|hCred
decl_stmt|,
name|val
decl_stmt|,
name|delegCred
init|=
literal|0
decl_stmt|;
name|int32_t
name|clientC
init|=
literal|0
decl_stmt|,
name|serverC
init|=
literal|0
decl_stmt|;
name|struct
name|client
modifier|*
name|client
decl_stmt|,
modifier|*
name|server
decl_stmt|;
name|p
operator|=
name|list
index|[
name|i
index|]
expr_stmt|;
name|client
operator|=
name|get_client
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|acquire_cred
argument_list|(
name|client
argument_list|,
name|user
argument_list|,
name|password
argument_list|,
literal|1
argument_list|,
operator|&
name|hCred
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|GSMERR_OK
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed to acquire_cred: %d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|num_clients
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|server
operator|=
name|get_client
argument_list|(
name|p
index|[
name|j
operator|%
name|num_clients
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|->
name|target_name
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s -> %s\n"
argument_list|,
name|client
operator|->
name|moniker
argument_list|,
name|server
operator|->
name|moniker
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_context
argument_list|(
name|client
argument_list|,
name|server
argument_list|,
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_SEQUENCE_FLAG
operator||
name|GSS_C_INTEG_FLAG
operator||
name|GSS_C_CONF_FLAG
operator||
name|GSS_C_DELEG_FLAG
operator||
name|GSS_C_MUTUAL_FLAG
argument_list|,
name|hCred
argument_list|,
operator|&
name|clientC
argument_list|,
operator|&
name|serverC
argument_list|,
operator|&
name|delegCred
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|GSMERR_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"build_context failed: %d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|test_token
argument_list|(
name|client
argument_list|,
name|clientC
argument_list|,
name|server
argument_list|,
name|serverC
argument_list|,
name|wrap_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
break|break;
name|toast_resource
argument_list|(
name|client
argument_list|,
name|clientC
argument_list|)
expr_stmt|;
name|toast_resource
argument_list|(
name|server
argument_list|,
name|serverC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delegCred
condition|)
block|{
name|warnx
argument_list|(
literal|"no delegated cred on %s"
argument_list|,
name|server
operator|->
name|moniker
argument_list|)
expr_stmt|;
break|break;
block|}
name|toast_resource
argument_list|(
name|client
argument_list|,
name|hCred
argument_list|)
expr_stmt|;
name|hCred
operator|=
name|delegCred
expr_stmt|;
name|client
operator|=
name|server
expr_stmt|;
block|}
if|if
condition|(
name|hCred
condition|)
name|toast_resource
argument_list|(
name|client
argument_list|,
name|hCred
argument_list|)
expr_stmt|;
block|}
comment|/*      * Close all connections to clients      */
name|out
label|:
name|printf
argument_list|(
literal|"sending goodbye and waiting for log sockets\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_clients
condition|;
name|i
operator|++
control|)
block|{
name|goodbye
argument_list|(
name|clients
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|clients
index|[
name|i
index|]
operator|->
name|logsock
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_PTHREAD_SUPPORT
name|pthread_join
argument_list|(
operator|&
name|clients
index|[
name|i
index|]
operator|->
name|thr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|waitpid
argument_list|(
name|clients
index|[
name|i
index|]
operator|->
name|child
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

