begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 - 2006 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"kadmin_locl.h"
end_include

begin_include
include|#
directive|include
file|<parse_units.h>
end_include

begin_comment
comment|/*  * util.c - functions for parsing, unparsing, and editing different  * types of data used in kadmin.  */
end_comment

begin_function_decl
specifier|static
name|int
name|get_response
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * attributes  */
end_comment

begin_decl_stmt
name|struct
name|units
name|kdb_attrs
index|[]
init|=
block|{
block|{
literal|"allow-digest"
block|,
name|KRB5_KDB_ALLOW_DIGEST
block|}
block|,
block|{
literal|"allow-kerberos4"
block|,
name|KRB5_KDB_ALLOW_KERBEROS4
block|}
block|,
block|{
literal|"trusted-for-delegation"
block|,
name|KRB5_KDB_TRUSTED_FOR_DELEGATION
block|}
block|,
block|{
literal|"ok-as-delegate"
block|,
name|KRB5_KDB_OK_AS_DELEGATE
block|}
block|,
block|{
literal|"new-princ"
block|,
name|KRB5_KDB_NEW_PRINC
block|}
block|,
block|{
literal|"support-desmd5"
block|,
name|KRB5_KDB_SUPPORT_DESMD5
block|}
block|,
block|{
literal|"pwchange-service"
block|,
name|KRB5_KDB_PWCHANGE_SERVICE
block|}
block|,
block|{
literal|"disallow-svr"
block|,
name|KRB5_KDB_DISALLOW_SVR
block|}
block|,
block|{
literal|"requires-pw-change"
block|,
name|KRB5_KDB_REQUIRES_PWCHANGE
block|}
block|,
block|{
literal|"requires-hw-auth"
block|,
name|KRB5_KDB_REQUIRES_HW_AUTH
block|}
block|,
block|{
literal|"requires-pre-auth"
block|,
name|KRB5_KDB_REQUIRES_PRE_AUTH
block|}
block|,
block|{
literal|"disallow-all-tix"
block|,
name|KRB5_KDB_DISALLOW_ALL_TIX
block|}
block|,
block|{
literal|"disallow-dup-skey"
block|,
name|KRB5_KDB_DISALLOW_DUP_SKEY
block|}
block|,
block|{
literal|"disallow-proxiable"
block|,
name|KRB5_KDB_DISALLOW_PROXIABLE
block|}
block|,
block|{
literal|"disallow-renewable"
block|,
name|KRB5_KDB_DISALLOW_RENEWABLE
block|}
block|,
block|{
literal|"disallow-tgt-based"
block|,
name|KRB5_KDB_DISALLOW_TGT_BASED
block|}
block|,
block|{
literal|"disallow-forwardable"
block|,
name|KRB5_KDB_DISALLOW_FORWARDABLE
block|}
block|,
block|{
literal|"disallow-postdated"
block|,
name|KRB5_KDB_DISALLOW_POSTDATED
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * convert the attributes in `attributes' into a printable string  * in `str, len'  */
end_comment

begin_function
name|void
name|attributes2str
parameter_list|(
name|krb5_flags
name|attributes
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|unparse_flags
argument_list|(
name|attributes
argument_list|,
name|kdb_attrs
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * convert the string in `str' into attributes in `flags'  * return 0 if parsed ok, else -1.  */
end_comment

begin_function
name|int
name|str2attributes
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|krb5_flags
modifier|*
name|flags
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|parse_flags
argument_list|(
name|str
argument_list|,
name|kdb_attrs
argument_list|,
operator|*
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
name|res
return|;
else|else
block|{
operator|*
name|flags
operator|=
name|res
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * try to parse the string `resp' into attributes in `attr', also  * setting the `bit' in `mask' if attributes are given and valid.  */
end_comment

begin_function
name|int
name|parse_attributes
parameter_list|(
specifier|const
name|char
modifier|*
name|resp
parameter_list|,
name|krb5_flags
modifier|*
name|attr
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|krb5_flags
name|tmp
init|=
operator|*
name|attr
decl_stmt|;
if|if
condition|(
name|str2attributes
argument_list|(
name|resp
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|attr
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|mask
condition|)
operator|*
name|mask
operator||=
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|resp
operator|==
literal|'?'
condition|)
block|{
name|print_flags_table
argument_list|(
name|kdb_attrs
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to parse \"%s\"\n"
argument_list|,
name|resp
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * allow the user to edit the attributes in `attr', prompting with `prompt'  */
end_comment

begin_function
name|int
name|edit_attributes
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|krb5_flags
modifier|*
name|attr
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|resp
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|mask
operator|&&
operator|(
operator|*
name|mask
operator|&
name|bit
operator|)
condition|)
return|return
literal|0
return|;
name|attributes2str
argument_list|(
operator|*
name|attr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|get_response
argument_list|(
literal|"Attributes"
argument_list|,
name|buf
argument_list|,
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|resp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|parse_attributes
argument_list|(
name|resp
argument_list|,
name|attr
argument_list|,
name|mask
argument_list|,
name|bit
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * time_t  * the special value 0 means ``never''  */
end_comment

begin_comment
comment|/*  * Convert the time `t' to a string representation in `str' (of max  * size `len').  If include_time also include time, otherwise just  * date.  */
end_comment

begin_function
name|void
name|time_t2str
parameter_list|(
name|time_t
name|t
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|include_time
parameter_list|)
block|{
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|include_time
condition|)
name|strftime
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"%Y-%m-%d %H:%M:%S UTC"
argument_list|,
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strftime
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"%Y-%m-%d"
argument_list|,
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"never"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert the time representation in `str' to a time in `time'.  * Return 0 if succesful, else -1.  */
end_comment

begin_function
name|int
name|str2time_t
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|time_t
modifier|*
name|t
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|,
name|tm2
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tm2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm2
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|str
operator|++
expr_stmt|;
operator|*
name|t
operator|=
name|parse_time
argument_list|(
name|str
argument_list|,
literal|"month"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|t
operator|+=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"never"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|t
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"now"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|strptime
argument_list|(
name|str
argument_list|,
literal|"%Y-%m-%d"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* XXX this is really a bit optimistic, we should really complain        if there was a problem parsing the time */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strptime
argument_list|(
name|p
argument_list|,
literal|"%H:%M:%S"
argument_list|,
operator|&
name|tm2
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|=
name|tm2
operator|.
name|tm_hour
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|tm2
operator|.
name|tm_min
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|tm2
operator|.
name|tm_sec
expr_stmt|;
block|}
else|else
block|{
comment|/* Do it on the end of the day */
name|tm
operator|.
name|tm_hour
operator|=
literal|23
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
literal|59
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
literal|59
expr_stmt|;
block|}
operator|*
name|t
operator|=
name|tm2time
argument_list|(
name|tm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * try to parse the time in `resp' storing it in `value'  */
end_comment

begin_function
name|int
name|parse_timet
parameter_list|(
specifier|const
name|char
modifier|*
name|resp
parameter_list|,
name|krb5_timestamp
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|time_t
name|tmp
decl_stmt|;
if|if
condition|(
name|str2time_t
argument_list|(
name|resp
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|value
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|mask
condition|)
operator|*
name|mask
operator||=
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|resp
operator|!=
literal|'?'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to parse time \"%s\"\n"
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Print date on format YYYY-mm-dd [hh:mm:ss]\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * allow the user to edit the time in `value'  */
end_comment

begin_function
name|int
name|edit_timet
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|krb5_timestamp
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|resp
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|mask
operator|&&
operator|(
operator|*
name|mask
operator|&
name|bit
operator|)
condition|)
return|return
literal|0
return|;
name|time_t2str
argument_list|(
operator|*
name|value
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|get_response
argument_list|(
name|prompt
argument_list|,
name|buf
argument_list|,
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|parse_timet
argument_list|(
name|resp
argument_list|,
name|value
argument_list|,
name|mask
argument_list|,
name|bit
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * deltat  * the special value 0 means ``unlimited''  */
end_comment

begin_comment
comment|/*  * convert the delta_t value in `t' into a printable form in `str, len'  */
end_comment

begin_function
name|void
name|deltat2str
parameter_list|(
name|unsigned
name|t
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|t
operator|==
literal|0
operator|||
name|t
operator|==
name|INT_MAX
condition|)
name|snprintf
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"unlimited"
argument_list|)
expr_stmt|;
else|else
name|unparse_time
argument_list|(
name|t
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * parse the delta value in `str', storing result in `*delta'  * return 0 if ok, else -1  */
end_comment

begin_function
name|int
name|str2deltat
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|krb5_deltat
modifier|*
name|delta
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"unlimited"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|delta
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|res
operator|=
name|parse_time
argument_list|(
name|str
argument_list|,
literal|"day"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
name|res
return|;
else|else
block|{
operator|*
name|delta
operator|=
name|res
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * try to parse the string in `resp' into a deltad in `value'  * `mask' will get the bit `bit' set if a value was given.  */
end_comment

begin_function
name|int
name|parse_deltat
parameter_list|(
specifier|const
name|char
modifier|*
name|resp
parameter_list|,
name|krb5_deltat
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|krb5_deltat
name|tmp
decl_stmt|;
if|if
condition|(
name|str2deltat
argument_list|(
name|resp
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|value
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|mask
condition|)
operator|*
name|mask
operator||=
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|resp
operator|==
literal|'?'
condition|)
block|{
name|print_time_table
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to parse time \"%s\"\n"
argument_list|,
name|resp
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * allow the user to edit the deltat in `value'  */
end_comment

begin_function
name|int
name|edit_deltat
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|krb5_deltat
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|resp
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|mask
operator|&&
operator|(
operator|*
name|mask
operator|&
name|bit
operator|)
condition|)
return|return
literal|0
return|;
name|deltat2str
argument_list|(
operator|*
name|value
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|get_response
argument_list|(
name|prompt
argument_list|,
name|buf
argument_list|,
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|parse_deltat
argument_list|(
name|resp
argument_list|,
name|value
argument_list|,
name|mask
argument_list|,
name|bit
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * allow the user to edit `ent'  */
end_comment

begin_function
name|void
name|set_defaults
parameter_list|(
name|kadm5_principal_ent_t
name|ent
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|kadm5_principal_ent_t
name|default_ent
parameter_list|,
name|int
name|default_mask
parameter_list|)
block|{
if|if
condition|(
name|default_ent
operator|&&
operator|(
name|default_mask
operator|&
name|KADM5_MAX_LIFE
operator|)
operator|&&
operator|!
operator|(
operator|*
name|mask
operator|&
name|KADM5_MAX_LIFE
operator|)
condition|)
name|ent
operator|->
name|max_life
operator|=
name|default_ent
operator|->
name|max_life
expr_stmt|;
if|if
condition|(
name|default_ent
operator|&&
operator|(
name|default_mask
operator|&
name|KADM5_MAX_RLIFE
operator|)
operator|&&
operator|!
operator|(
operator|*
name|mask
operator|&
name|KADM5_MAX_RLIFE
operator|)
condition|)
name|ent
operator|->
name|max_renewable_life
operator|=
name|default_ent
operator|->
name|max_renewable_life
expr_stmt|;
if|if
condition|(
name|default_ent
operator|&&
operator|(
name|default_mask
operator|&
name|KADM5_PRINC_EXPIRE_TIME
operator|)
operator|&&
operator|!
operator|(
operator|*
name|mask
operator|&
name|KADM5_PRINC_EXPIRE_TIME
operator|)
condition|)
name|ent
operator|->
name|princ_expire_time
operator|=
name|default_ent
operator|->
name|princ_expire_time
expr_stmt|;
if|if
condition|(
name|default_ent
operator|&&
operator|(
name|default_mask
operator|&
name|KADM5_PW_EXPIRATION
operator|)
operator|&&
operator|!
operator|(
operator|*
name|mask
operator|&
name|KADM5_PW_EXPIRATION
operator|)
condition|)
name|ent
operator|->
name|pw_expiration
operator|=
name|default_ent
operator|->
name|pw_expiration
expr_stmt|;
if|if
condition|(
name|default_ent
operator|&&
operator|(
name|default_mask
operator|&
name|KADM5_ATTRIBUTES
operator|)
operator|&&
operator|!
operator|(
operator|*
name|mask
operator|&
name|KADM5_ATTRIBUTES
operator|)
condition|)
name|ent
operator|->
name|attributes
operator|=
name|default_ent
operator|->
name|attributes
operator|&
operator|~
name|KRB5_KDB_DISALLOW_ALL_TIX
expr_stmt|;
block|}
end_function

begin_function
name|int
name|edit_entry
parameter_list|(
name|kadm5_principal_ent_t
name|ent
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
name|kadm5_principal_ent_t
name|default_ent
parameter_list|,
name|int
name|default_mask
parameter_list|)
block|{
name|set_defaults
argument_list|(
name|ent
argument_list|,
name|mask
argument_list|,
name|default_ent
argument_list|,
name|default_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_deltat
argument_list|(
literal|"Max ticket life"
argument_list|,
operator|&
name|ent
operator|->
name|max_life
argument_list|,
name|mask
argument_list|,
name|KADM5_MAX_LIFE
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|edit_deltat
argument_list|(
literal|"Max renewable life"
argument_list|,
operator|&
name|ent
operator|->
name|max_renewable_life
argument_list|,
name|mask
argument_list|,
name|KADM5_MAX_RLIFE
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|edit_timet
argument_list|(
literal|"Principal expiration time"
argument_list|,
operator|&
name|ent
operator|->
name|princ_expire_time
argument_list|,
name|mask
argument_list|,
name|KADM5_PRINC_EXPIRE_TIME
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|edit_timet
argument_list|(
literal|"Password expiration time"
argument_list|,
operator|&
name|ent
operator|->
name|pw_expiration
argument_list|,
name|mask
argument_list|,
name|KADM5_PW_EXPIRATION
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|edit_attributes
argument_list|(
literal|"Attributes"
argument_list|,
operator|&
name|ent
operator|->
name|attributes
argument_list|,
name|mask
argument_list|,
name|KADM5_ATTRIBUTES
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the arguments, set the fields in `ent' and the `mask' for the  * entries having been set.  * Return 1 on failure and 0 on success.  */
end_comment

begin_function
name|int
name|set_entry
parameter_list|(
name|krb5_context
name|contextp
parameter_list|,
name|kadm5_principal_ent_t
name|ent
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|max_ticket_life
parameter_list|,
specifier|const
name|char
modifier|*
name|max_renewable_life
parameter_list|,
specifier|const
name|char
modifier|*
name|expiration
parameter_list|,
specifier|const
name|char
modifier|*
name|pw_expiration
parameter_list|,
specifier|const
name|char
modifier|*
name|attributes
parameter_list|)
block|{
if|if
condition|(
name|max_ticket_life
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parse_deltat
argument_list|(
name|max_ticket_life
argument_list|,
operator|&
name|ent
operator|->
name|max_life
argument_list|,
name|mask
argument_list|,
name|KADM5_MAX_LIFE
argument_list|)
condition|)
block|{
name|krb5_warnx
argument_list|(
name|contextp
argument_list|,
literal|"unable to parse `%s'"
argument_list|,
name|max_ticket_life
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|max_renewable_life
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parse_deltat
argument_list|(
name|max_renewable_life
argument_list|,
operator|&
name|ent
operator|->
name|max_renewable_life
argument_list|,
name|mask
argument_list|,
name|KADM5_MAX_RLIFE
argument_list|)
condition|)
block|{
name|krb5_warnx
argument_list|(
name|contextp
argument_list|,
literal|"unable to parse `%s'"
argument_list|,
name|max_renewable_life
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|expiration
condition|)
block|{
if|if
condition|(
name|parse_timet
argument_list|(
name|expiration
argument_list|,
operator|&
name|ent
operator|->
name|princ_expire_time
argument_list|,
name|mask
argument_list|,
name|KADM5_PRINC_EXPIRE_TIME
argument_list|)
condition|)
block|{
name|krb5_warnx
argument_list|(
name|contextp
argument_list|,
literal|"unable to parse `%s'"
argument_list|,
name|expiration
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|pw_expiration
condition|)
block|{
if|if
condition|(
name|parse_timet
argument_list|(
name|pw_expiration
argument_list|,
operator|&
name|ent
operator|->
name|pw_expiration
argument_list|,
name|mask
argument_list|,
name|KADM5_PW_EXPIRATION
argument_list|)
condition|)
block|{
name|krb5_warnx
argument_list|(
name|contextp
argument_list|,
literal|"unable to parse `%s'"
argument_list|,
name|pw_expiration
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|attributes
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parse_attributes
argument_list|(
name|attributes
argument_list|,
operator|&
name|ent
operator|->
name|attributes
argument_list|,
name|mask
argument_list|,
name|KADM5_ATTRIBUTES
argument_list|)
condition|)
block|{
name|krb5_warnx
argument_list|(
name|contextp
argument_list|,
literal|"unable to parse `%s'"
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Does `string' contain any globing characters?  */
end_comment

begin_function
specifier|static
name|int
name|is_expression
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|quote
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|string
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|quote
condition|)
block|{
name|quote
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|quote
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"[]*?"
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Loop over all principals matching exp.  If any of calls to `func'  * failes, the first error is returned when all principals are  * processed.  */
end_comment

begin_function
name|int
name|foreach_principal
parameter_list|(
specifier|const
name|char
modifier|*
name|exp_str
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|krb5_principal
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|funcname
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|princs
init|=
name|NULL
decl_stmt|;
name|int
name|num_princs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|krb5_error_code
name|saved_ret
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|krb5_principal
name|princ_ent
decl_stmt|;
name|int
name|is_expr
decl_stmt|;
comment|/* if this isn't an expression, there is no point in wading        through the whole database looking for matches */
name|is_expr
operator|=
name|is_expression
argument_list|(
name|exp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_expr
condition|)
name|ret
operator|=
name|kadm5_get_principals
argument_list|(
name|kadm_handle
argument_list|,
name|exp_str
argument_list|,
operator|&
name|princs
argument_list|,
operator|&
name|num_princs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_expr
operator|||
name|ret
operator|==
name|KADM5_AUTH_LIST
condition|)
block|{
comment|/* we might be able to perform the requested opreration even            if we're not allowed to list principals */
name|num_princs
operator|=
literal|1
expr_stmt|;
name|princs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|princs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|princs
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|princs
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|exp_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|princs
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|princs
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_warn
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
literal|"kadm5_get_principals"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_princs
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|krb5_parse_name
argument_list|(
name|context
argument_list|,
name|princs
index|[
name|i
index|]
argument_list|,
operator|&
name|princ_ent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_warn
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
literal|"krb5_parse_name(%s)"
argument_list|,
name|princs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ret
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|princ_ent
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|krb5_clear_error_message
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|krb5_warn
argument_list|(
name|context
argument_list|,
name|ret
argument_list|,
literal|"%s %s"
argument_list|,
name|funcname
argument_list|,
name|princs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_ret
operator|==
literal|0
condition|)
name|saved_ret
operator|=
name|ret
expr_stmt|;
block|}
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|princ_ent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|saved_ret
operator|!=
literal|0
condition|)
name|ret
operator|=
name|saved_ret
expr_stmt|;
name|kadm5_free_name_list
argument_list|(
name|kadm_handle
argument_list|,
name|princs
argument_list|,
operator|&
name|num_princs
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * prompt with `prompt' and default value `def', and store the reply  * in `buf, len'  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
specifier|static
name|jmp_buf
name|jmpbuf
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|interrupt
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|longjmp
argument_list|(
name|jmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_response
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|void
function_decl|(
modifier|*
name|osig
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|osig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmpbuf
argument_list|)
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|osig
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s [%s]:"
argument_list|,
name|prompt
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|krb5_err
argument_list|(
name|context
argument_list|,
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"<stdin>"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|osig
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|def
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|osig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * return [0, 16) or -1  */
end_comment

begin_function
specifier|static
name|int
name|hex2n
parameter_list|(
name|char
name|c
parameter_list|)
block|{
specifier|static
name|char
name|hexdigits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|hexdigits
argument_list|,
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|p
operator|-
name|hexdigits
return|;
block|}
end_function

begin_comment
comment|/*  * convert a key in a readable format into a keyblock.  * return 0 iff succesful, otherwise `err' should point to an error message  */
end_comment

begin_function
name|int
name|parse_des_key
parameter_list|(
specifier|const
name|char
modifier|*
name|key_string
parameter_list|,
name|krb5_key_data
modifier|*
name|key_data
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|key_string
decl_stmt|;
name|unsigned
name|char
name|bits
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|key_string
argument_list|)
operator|!=
literal|16
condition|)
block|{
operator|*
name|error
operator|=
literal|"bad length, should be 16 for DES key"
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|int
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|d1
operator|=
name|hex2n
argument_list|(
name|p
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
expr_stmt|;
name|d2
operator|=
name|hex2n
argument_list|(
name|p
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|<
literal|0
operator|||
name|d2
operator|<
literal|0
condition|)
block|{
operator|*
name|error
operator|=
literal|"non-hex character"
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bits
index|[
name|i
index|]
operator|=
operator|(
name|d1
operator|<<
literal|4
operator|)
operator||
name|d2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_ver
operator|=
literal|2
expr_stmt|;
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_kvno
operator|=
literal|0
expr_stmt|;
comment|/* key */
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_type
index|[
literal|0
index|]
operator|=
name|ETYPE_DES_CBC_CRC
expr_stmt|;
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_length
index|[
literal|0
index|]
operator|=
literal|8
expr_stmt|;
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_contents
index|[
literal|0
index|]
operator|=
name|malloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_contents
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
operator|*
name|error
operator|=
literal|"malloc"
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|memcpy
argument_list|(
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_contents
index|[
literal|0
index|]
argument_list|,
name|bits
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* salt */
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_type
index|[
literal|1
index|]
operator|=
name|KRB5_PW_SALT
expr_stmt|;
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_length
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|key_data
index|[
name|i
index|]
operator|.
name|key_data_contents
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|key_data
index|[
literal|0
index|]
operator|.
name|key_data_type
index|[
literal|0
index|]
operator|=
name|ETYPE_DES_CBC_MD5
expr_stmt|;
name|key_data
index|[
literal|1
index|]
operator|.
name|key_data_type
index|[
literal|0
index|]
operator|=
name|ETYPE_DES_CBC_MD4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

