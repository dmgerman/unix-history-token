begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Tree search generalized from Knuth (6.2.2) Algorithm T just like  * the AT&T man page says.  *  * The node_t structure is for internal use only, lint doesn't grok it.  *  * Written by reading the System V Interface Definition, not the code.  *  * Totally public domain.  *  * $NetBSD: tsearch.c,v 1.3 1999/09/16 11:45:37 lukem Exp $  * $NetBSD: twalk.c,v 1.1 1999/02/22 10:33:16 christos Exp $  * $NetBSD: tdelete.c,v 1.2 1999/09/16 11:45:37 lukem Exp $  * $NetBSD: tfind.c,v 1.2 1999/09/16 11:45:37 lukem Exp $  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|"roken.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|node
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|struct
name|node
modifier|*
name|llink
decl_stmt|,
modifier|*
name|rlink
decl_stmt|;
block|}
name|node_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|__DECONST
end_ifndef

begin_define
define|#
directive|define
name|__DECONST
parameter_list|(
name|type
parameter_list|,
name|var
parameter_list|)
value|((type)(uintptr_t)(const void *)(var))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * find or insert datum into search tree  *  * Parameters:  *	vkey:	key to be located  *	vrootp:	address of tree root  */
end_comment

begin_function
name|ROKEN_LIB_FUNCTION
name|void
modifier|*
name|rk_tsearch
parameter_list|(
specifier|const
name|void
modifier|*
name|vkey
parameter_list|,
name|void
modifier|*
modifier|*
name|vrootp
parameter_list|,
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|node_t
modifier|*
name|q
decl_stmt|;
name|node_t
modifier|*
modifier|*
name|rootp
init|=
operator|(
name|node_t
operator|*
operator|*
operator|)
name|vrootp
decl_stmt|;
if|if
condition|(
name|rootp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|*
name|rootp
operator|!=
name|NULL
condition|)
block|{
comment|/* Knuth's T1: */
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
call|(
modifier|*
name|compar
call|)
argument_list|(
name|vkey
argument_list|,
operator|(
operator|*
name|rootp
operator|)
operator|->
name|key
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* T2: */
return|return
operator|*
name|rootp
return|;
comment|/* we found it! */
name|rootp
operator|=
operator|(
name|r
operator|<
literal|0
operator|)
condition|?
operator|&
operator|(
operator|*
name|rootp
operator|)
operator|->
name|llink
else|:
comment|/* T3: follow left branch */
operator|&
operator|(
operator|*
name|rootp
operator|)
operator|->
name|rlink
expr_stmt|;
comment|/* T4: follow right branch */
block|}
name|q
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|node_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* T5: key not found */
if|if
condition|(
name|q
operator|!=
literal|0
condition|)
block|{
comment|/* make new node */
operator|*
name|rootp
operator|=
name|q
expr_stmt|;
comment|/* link new node to old */
comment|/* LINTED const castaway ok */
name|q
operator|->
name|key
operator|=
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|vkey
argument_list|)
expr_stmt|;
comment|/* initialize new node */
name|q
operator|->
name|llink
operator|=
name|q
operator|->
name|rlink
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the nodes of a tree  *  * Parameters:  *	root:	Root of the tree to be walked  */
end_comment

begin_function
specifier|static
name|void
name|trecurse
parameter_list|(
specifier|const
name|node_t
modifier|*
name|root
parameter_list|,
name|void
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|VISIT
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|llink
operator|==
name|NULL
operator|&&
name|root
operator|->
name|rlink
operator|==
name|NULL
condition|)
call|(
modifier|*
name|action
call|)
argument_list|(
name|root
argument_list|,
name|leaf
argument_list|,
name|level
argument_list|)
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|action
call|)
argument_list|(
name|root
argument_list|,
name|preorder
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|llink
operator|!=
name|NULL
condition|)
name|trecurse
argument_list|(
name|root
operator|->
name|llink
argument_list|,
name|action
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|action
call|)
argument_list|(
name|root
argument_list|,
name|postorder
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|rlink
operator|!=
name|NULL
condition|)
name|trecurse
argument_list|(
name|root
operator|->
name|rlink
argument_list|,
name|action
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|action
call|)
argument_list|(
name|root
argument_list|,
name|endorder
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Walk the nodes of a tree  *  * Parameters:  *	vroot:	Root of the tree to be walked  */
end_comment

begin_function
name|ROKEN_LIB_FUNCTION
name|void
name|rk_twalk
parameter_list|(
specifier|const
name|void
modifier|*
name|vroot
parameter_list|,
name|void
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|VISIT
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|vroot
operator|!=
name|NULL
operator|&&
name|action
operator|!=
name|NULL
condition|)
name|trecurse
argument_list|(
name|vroot
argument_list|,
name|action
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * delete node with given key  *  * vkey:   key to be deleted  * vrootp: address of the root of the tree  * compar: function to carry out node comparisons  */
end_comment

begin_function
name|ROKEN_LIB_FUNCTION
name|void
modifier|*
name|rk_tdelete
parameter_list|(
specifier|const
name|void
modifier|*
name|vkey
parameter_list|,
name|void
modifier|*
modifier|*
name|vrootp
parameter_list|,
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|node_t
modifier|*
modifier|*
name|rootp
init|=
operator|(
name|node_t
operator|*
operator|*
operator|)
name|vrootp
decl_stmt|;
name|node_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|rootp
operator|==
name|NULL
operator|||
operator|(
name|p
operator|=
operator|*
name|rootp
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|cmp
operator|=
call|(
modifier|*
name|compar
call|)
argument_list|(
name|vkey
argument_list|,
operator|(
operator|*
name|rootp
operator|)
operator|->
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
name|rootp
expr_stmt|;
name|rootp
operator|=
operator|(
name|cmp
operator|<
literal|0
operator|)
condition|?
operator|&
operator|(
operator|*
name|rootp
operator|)
operator|->
name|llink
else|:
comment|/* follow llink branch */
operator|&
operator|(
operator|*
name|rootp
operator|)
operator|->
name|rlink
expr_stmt|;
comment|/* follow rlink branch */
if|if
condition|(
operator|*
name|rootp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* key not found */
block|}
name|r
operator|=
operator|(
operator|*
name|rootp
operator|)
operator|->
name|rlink
expr_stmt|;
comment|/* D1: */
if|if
condition|(
operator|(
name|q
operator|=
operator|(
operator|*
name|rootp
operator|)
operator|->
name|llink
operator|)
operator|==
name|NULL
condition|)
comment|/* Left NULL? */
name|q
operator|=
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
comment|/* Right link is NULL? */
if|if
condition|(
name|r
operator|->
name|llink
operator|==
name|NULL
condition|)
block|{
comment|/* D2: Find successor */
name|r
operator|->
name|llink
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
comment|/* D3: Find NULL link */
for|for
control|(
name|q
operator|=
name|r
operator|->
name|llink
init|;
name|q
operator|->
name|llink
operator|!=
name|NULL
condition|;
name|q
operator|=
name|r
operator|->
name|llink
control|)
name|r
operator|=
name|q
expr_stmt|;
name|r
operator|->
name|llink
operator|=
name|q
operator|->
name|rlink
expr_stmt|;
name|q
operator|->
name|llink
operator|=
operator|(
operator|*
name|rootp
operator|)
operator|->
name|llink
expr_stmt|;
name|q
operator|->
name|rlink
operator|=
operator|(
operator|*
name|rootp
operator|)
operator|->
name|rlink
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|*
name|rootp
argument_list|)
expr_stmt|;
comment|/* D4: Free node */
operator|*
name|rootp
operator|=
name|q
expr_stmt|;
comment|/* link parent to new node */
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * find a node, or return 0  *  * Parameters:  *	vkey:	key to be found  *	vrootp:	address of the tree root  */
end_comment

begin_function
name|ROKEN_LIB_FUNCTION
name|void
modifier|*
name|rk_tfind
parameter_list|(
specifier|const
name|void
modifier|*
name|vkey
parameter_list|,
name|void
modifier|*
specifier|const
modifier|*
name|vrootp
parameter_list|,
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|node_t
modifier|*
modifier|*
name|rootp
init|=
operator|(
name|node_t
operator|*
operator|*
operator|)
name|vrootp
decl_stmt|;
if|if
condition|(
name|rootp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|*
name|rootp
operator|!=
name|NULL
condition|)
block|{
comment|/* T1: */
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
call|(
modifier|*
name|compar
call|)
argument_list|(
name|vkey
argument_list|,
operator|(
operator|*
name|rootp
operator|)
operator|->
name|key
argument_list|)
operator|)
operator|==
literal|0
condition|)
comment|/* T2: */
return|return
operator|*
name|rootp
return|;
comment|/* key found */
name|rootp
operator|=
operator|(
name|r
operator|<
literal|0
operator|)
condition|?
operator|&
operator|(
operator|*
name|rootp
operator|)
operator|->
name|llink
else|:
comment|/* T3: follow left branch */
operator|&
operator|(
operator|*
name|rootp
operator|)
operator|->
name|rlink
expr_stmt|;
comment|/* T4: follow right branch */
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

