begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* asn1_gen.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL  * project 2002.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2002 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|"cryptlib.h"
end_include

begin_include
include|#
directive|include
file|<openssl/asn1.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG
value|0x10000
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_IMP
value|(ASN1_GEN_FLAG|1)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_EXP
value|(ASN1_GEN_FLAG|2)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_TAG
value|(ASN1_GEN_FLAG|3)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_BITWRAP
value|(ASN1_GEN_FLAG|4)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_OCTWRAP
value|(ASN1_GEN_FLAG|5)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_SEQWRAP
value|(ASN1_GEN_FLAG|6)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_SETWRAP
value|(ASN1_GEN_FLAG|7)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_FLAG_FORMAT
value|(ASN1_GEN_FLAG|8)
end_define

begin_define
define|#
directive|define
name|ASN1_GEN_STR
parameter_list|(
name|str
parameter_list|,
name|val
parameter_list|)
value|{str, sizeof(str) - 1, val}
end_define

begin_define
define|#
directive|define
name|ASN1_FLAG_EXP_MAX
value|20
end_define

begin_comment
comment|/* Input formats */
end_comment

begin_comment
comment|/* ASCII: default */
end_comment

begin_define
define|#
directive|define
name|ASN1_GEN_FORMAT_ASCII
value|1
end_define

begin_comment
comment|/* UTF8 */
end_comment

begin_define
define|#
directive|define
name|ASN1_GEN_FORMAT_UTF8
value|2
end_define

begin_comment
comment|/* Hex */
end_comment

begin_define
define|#
directive|define
name|ASN1_GEN_FORMAT_HEX
value|3
end_define

begin_comment
comment|/* List of bits */
end_comment

begin_define
define|#
directive|define
name|ASN1_GEN_FORMAT_BITLIST
value|4
end_define

begin_struct
struct|struct
name|tag_name_st
block|{
specifier|const
name|char
modifier|*
name|strnam
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|exp_tag
decl_stmt|;
name|int
name|exp_class
decl_stmt|;
name|int
name|exp_constructed
decl_stmt|;
name|int
name|exp_pad
decl_stmt|;
name|long
name|exp_len
decl_stmt|;
block|}
name|tag_exp_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|imp_tag
decl_stmt|;
name|int
name|imp_class
decl_stmt|;
name|int
name|utype
decl_stmt|;
name|int
name|format
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|tag_exp_type
name|exp_list
index|[
name|ASN1_FLAG_EXP_MAX
index|]
decl_stmt|;
name|int
name|exp_count
decl_stmt|;
block|}
name|tag_exp_arg
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|bitstr_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|bitstr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|bitstr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|append_exp
parameter_list|(
name|tag_exp_arg
modifier|*
name|arg
parameter_list|,
name|int
name|exp_tag
parameter_list|,
name|int
name|exp_class
parameter_list|,
name|int
name|exp_constructed
parameter_list|,
name|int
name|exp_pad
parameter_list|,
name|int
name|imp_ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_tagging
parameter_list|(
specifier|const
name|char
modifier|*
name|vstart
parameter_list|,
name|int
name|vlen
parameter_list|,
name|int
modifier|*
name|ptag
parameter_list|,
name|int
modifier|*
name|pclass
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ASN1_TYPE
modifier|*
name|asn1_multi
parameter_list|(
name|int
name|utype
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|X509V3_CTX
modifier|*
name|cnf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ASN1_TYPE
modifier|*
name|asn1_str2type
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|utype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asn1_str2tag
parameter_list|(
specifier|const
name|char
modifier|*
name|tagstr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|ASN1_TYPE
modifier|*
name|ASN1_generate_nconf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|CONF
modifier|*
name|nconf
parameter_list|)
block|{
name|X509V3_CTX
name|cnf
decl_stmt|;
if|if
condition|(
operator|!
name|nconf
condition|)
return|return
name|ASN1_generate_v3
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|)
return|;
name|X509V3_set_nconf
argument_list|(
operator|&
name|cnf
argument_list|,
name|nconf
argument_list|)
expr_stmt|;
return|return
name|ASN1_generate_v3
argument_list|(
name|str
argument_list|,
operator|&
name|cnf
argument_list|)
return|;
block|}
end_function

begin_function
name|ASN1_TYPE
modifier|*
name|ASN1_generate_v3
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|X509V3_CTX
modifier|*
name|cnf
parameter_list|)
block|{
name|ASN1_TYPE
modifier|*
name|ret
decl_stmt|;
name|tag_exp_arg
name|asn1_tags
decl_stmt|;
name|tag_exp_type
modifier|*
name|etmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|orig_der
init|=
name|NULL
decl_stmt|,
modifier|*
name|new_der
init|=
name|NULL
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cpy_start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cpy_len
decl_stmt|;
name|long
name|hdr_len
decl_stmt|;
name|int
name|hdr_constructed
init|=
literal|0
decl_stmt|,
name|hdr_tag
decl_stmt|,
name|hdr_class
decl_stmt|;
name|int
name|r
decl_stmt|;
name|asn1_tags
operator|.
name|imp_tag
operator|=
operator|-
literal|1
expr_stmt|;
name|asn1_tags
operator|.
name|imp_class
operator|=
operator|-
literal|1
expr_stmt|;
name|asn1_tags
operator|.
name|format
operator|=
name|ASN1_GEN_FORMAT_ASCII
expr_stmt|;
name|asn1_tags
operator|.
name|exp_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONF_parse_list
argument_list|(
name|str
argument_list|,
literal|','
argument_list|,
literal|1
argument_list|,
name|asn1_cb
argument_list|,
operator|&
name|asn1_tags
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|asn1_tags
operator|.
name|utype
operator|==
name|V_ASN1_SEQUENCE
operator|)
operator|||
operator|(
name|asn1_tags
operator|.
name|utype
operator|==
name|V_ASN1_SET
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|cnf
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_GENERATE_V3
argument_list|,
name|ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|asn1_multi
argument_list|(
name|asn1_tags
operator|.
name|utype
argument_list|,
name|asn1_tags
operator|.
name|str
argument_list|,
name|cnf
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|asn1_str2type
argument_list|(
name|asn1_tags
operator|.
name|str
argument_list|,
name|asn1_tags
operator|.
name|format
argument_list|,
name|asn1_tags
operator|.
name|utype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
comment|/* If no tagging return base type */
if|if
condition|(
operator|(
name|asn1_tags
operator|.
name|imp_tag
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|asn1_tags
operator|.
name|exp_count
operator|==
literal|0
operator|)
condition|)
return|return
name|ret
return|;
comment|/* Generate the encoding */
name|cpy_len
operator|=
name|i2d_ASN1_TYPE
argument_list|(
name|ret
argument_list|,
operator|&
name|orig_der
argument_list|)
expr_stmt|;
name|ASN1_TYPE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
comment|/* Set point to start copying for modified encoding */
name|cpy_start
operator|=
name|orig_der
expr_stmt|;
comment|/* Do we need IMPLICIT tagging? */
if|if
condition|(
name|asn1_tags
operator|.
name|imp_tag
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If IMPLICIT we will replace the underlying tag */
comment|/* Skip existing tag+len */
name|r
operator|=
name|ASN1_get_object
argument_list|(
operator|&
name|cpy_start
argument_list|,
operator|&
name|hdr_len
argument_list|,
operator|&
name|hdr_tag
argument_list|,
operator|&
name|hdr_class
argument_list|,
name|cpy_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x80
condition|)
goto|goto
name|err
goto|;
comment|/* Update copy length */
name|cpy_len
operator|-=
name|cpy_start
operator|-
name|orig_der
expr_stmt|;
comment|/* For IMPLICIT tagging the length should match the 		 * original length and constructed flag should be 		 * consistent. 		 */
if|if
condition|(
name|r
operator|&
literal|0x1
condition|)
block|{
comment|/* Indefinite length constructed */
name|hdr_constructed
operator|=
literal|2
expr_stmt|;
name|hdr_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Just retain constructed flag */
name|hdr_constructed
operator|=
name|r
operator|&
name|V_ASN1_CONSTRUCTED
expr_stmt|;
comment|/* Work out new length with IMPLICIT tag: ignore constructed 		 * because it will mess up if indefinite length 		 */
name|len
operator|=
name|ASN1_object_size
argument_list|(
literal|0
argument_list|,
name|hdr_len
argument_list|,
name|asn1_tags
operator|.
name|imp_tag
argument_list|)
expr_stmt|;
block|}
else|else
name|len
operator|=
name|cpy_len
expr_stmt|;
comment|/* Work out length in any EXPLICIT, starting from end */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|etmp
operator|=
name|asn1_tags
operator|.
name|exp_list
operator|+
name|asn1_tags
operator|.
name|exp_count
operator|-
literal|1
init|;
name|i
operator|<
name|asn1_tags
operator|.
name|exp_count
condition|;
name|i
operator|++
operator|,
name|etmp
operator|--
control|)
block|{
comment|/* Content length: number of content octets + any padding */
name|len
operator|+=
name|etmp
operator|->
name|exp_pad
expr_stmt|;
name|etmp
operator|->
name|exp_len
operator|=
name|len
expr_stmt|;
comment|/* Total object length: length including new header */
name|len
operator|=
name|ASN1_object_size
argument_list|(
literal|0
argument_list|,
name|len
argument_list|,
name|etmp
operator|->
name|exp_tag
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate buffer for new encoding */
name|new_der
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_der
condition|)
goto|goto
name|err
goto|;
comment|/* Generate tagged encoding */
name|p
operator|=
name|new_der
expr_stmt|;
comment|/* Output explicit tags first */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|etmp
operator|=
name|asn1_tags
operator|.
name|exp_list
init|;
name|i
operator|<
name|asn1_tags
operator|.
name|exp_count
condition|;
name|i
operator|++
operator|,
name|etmp
operator|++
control|)
block|{
name|ASN1_put_object
argument_list|(
operator|&
name|p
argument_list|,
name|etmp
operator|->
name|exp_constructed
argument_list|,
name|etmp
operator|->
name|exp_len
argument_list|,
name|etmp
operator|->
name|exp_tag
argument_list|,
name|etmp
operator|->
name|exp_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|etmp
operator|->
name|exp_pad
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If IMPLICIT, output tag */
if|if
condition|(
name|asn1_tags
operator|.
name|imp_tag
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|asn1_tags
operator|.
name|imp_class
operator|==
name|V_ASN1_UNIVERSAL
operator|&&
operator|(
name|asn1_tags
operator|.
name|imp_tag
operator|==
name|V_ASN1_SEQUENCE
operator|||
name|asn1_tags
operator|.
name|imp_tag
operator|==
name|V_ASN1_SET
operator|)
condition|)
name|hdr_constructed
operator|=
name|V_ASN1_CONSTRUCTED
expr_stmt|;
name|ASN1_put_object
argument_list|(
operator|&
name|p
argument_list|,
name|hdr_constructed
argument_list|,
name|hdr_len
argument_list|,
name|asn1_tags
operator|.
name|imp_tag
argument_list|,
name|asn1_tags
operator|.
name|imp_class
argument_list|)
expr_stmt|;
block|}
comment|/* Copy across original encoding */
name|memcpy
argument_list|(
name|p
argument_list|,
name|cpy_start
argument_list|,
name|cpy_len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|new_der
expr_stmt|;
comment|/* Obtain new ASN1_TYPE structure */
name|ret
operator|=
name|d2i_ASN1_TYPE
argument_list|(
name|NULL
argument_list|,
operator|&
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
name|orig_der
condition|)
name|OPENSSL_free
argument_list|(
name|orig_der
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_der
condition|)
name|OPENSSL_free
argument_list|(
name|new_der
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|asn1_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|bitstr
parameter_list|)
block|{
name|tag_exp_arg
modifier|*
name|arg
init|=
name|bitstr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|utype
decl_stmt|;
name|int
name|vlen
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|vstart
init|=
name|NULL
decl_stmt|;
name|int
name|tmp_tag
decl_stmt|,
name|tmp_class
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|elem
init|;
name|i
operator|<
name|len
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
block|{
comment|/* Look for the ':' in name value pairs */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|vstart
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|vlen
operator|=
name|len
operator|-
operator|(
name|vstart
operator|-
name|elem
operator|)
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|elem
expr_stmt|;
break|break;
block|}
block|}
name|utype
operator|=
name|asn1_str2tag
argument_list|(
name|elem
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|utype
operator|==
operator|-
literal|1
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CB
argument_list|,
name|ASN1_R_UNKNOWN_TAG
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"tag="
argument_list|,
name|elem
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* If this is not a modifier mark end of string and exit */
if|if
condition|(
operator|!
operator|(
name|utype
operator|&
name|ASN1_GEN_FLAG
operator|)
condition|)
block|{
name|arg
operator|->
name|utype
operator|=
name|utype
expr_stmt|;
name|arg
operator|->
name|str
operator|=
name|vstart
expr_stmt|;
comment|/* If no value and not end of string, error */
if|if
condition|(
operator|!
name|vstart
operator|&&
name|elem
index|[
name|len
index|]
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CB
argument_list|,
name|ASN1_R_MISSING_VALUE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|utype
condition|)
block|{
case|case
name|ASN1_GEN_FLAG_IMP
case|:
comment|/* Check for illegal multiple IMPLICIT tagging */
if|if
condition|(
name|arg
operator|->
name|imp_tag
operator|!=
operator|-
literal|1
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CB
argument_list|,
name|ASN1_R_ILLEGAL_NESTED_TAGGING
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|parse_tagging
argument_list|(
name|vstart
argument_list|,
name|vlen
argument_list|,
operator|&
name|arg
operator|->
name|imp_tag
argument_list|,
operator|&
name|arg
operator|->
name|imp_class
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ASN1_GEN_FLAG_EXP
case|:
if|if
condition|(
operator|!
name|parse_tagging
argument_list|(
name|vstart
argument_list|,
name|vlen
argument_list|,
operator|&
name|tmp_tag
argument_list|,
operator|&
name|tmp_class
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|append_exp
argument_list|(
name|arg
argument_list|,
name|tmp_tag
argument_list|,
name|tmp_class
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ASN1_GEN_FLAG_SEQWRAP
case|:
if|if
condition|(
operator|!
name|append_exp
argument_list|(
name|arg
argument_list|,
name|V_ASN1_SEQUENCE
argument_list|,
name|V_ASN1_UNIVERSAL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ASN1_GEN_FLAG_SETWRAP
case|:
if|if
condition|(
operator|!
name|append_exp
argument_list|(
name|arg
argument_list|,
name|V_ASN1_SET
argument_list|,
name|V_ASN1_UNIVERSAL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ASN1_GEN_FLAG_BITWRAP
case|:
if|if
condition|(
operator|!
name|append_exp
argument_list|(
name|arg
argument_list|,
name|V_ASN1_BIT_STRING
argument_list|,
name|V_ASN1_UNIVERSAL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ASN1_GEN_FLAG_OCTWRAP
case|:
if|if
condition|(
operator|!
name|append_exp
argument_list|(
name|arg
argument_list|,
name|V_ASN1_OCTET_STRING
argument_list|,
name|V_ASN1_UNIVERSAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ASN1_GEN_FLAG_FORMAT
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|vstart
argument_list|,
literal|"ASCII"
argument_list|,
literal|5
argument_list|)
condition|)
name|arg
operator|->
name|format
operator|=
name|ASN1_GEN_FORMAT_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|vstart
argument_list|,
literal|"UTF8"
argument_list|,
literal|4
argument_list|)
condition|)
name|arg
operator|->
name|format
operator|=
name|ASN1_GEN_FORMAT_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|vstart
argument_list|,
literal|"HEX"
argument_list|,
literal|3
argument_list|)
condition|)
name|arg
operator|->
name|format
operator|=
name|ASN1_GEN_FORMAT_HEX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|vstart
argument_list|,
literal|"BITLIST"
argument_list|,
literal|3
argument_list|)
condition|)
name|arg
operator|->
name|format
operator|=
name|ASN1_GEN_FORMAT_BITLIST
expr_stmt|;
else|else
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_CB
argument_list|,
name|ASN1_R_UNKOWN_FORMAT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_tagging
parameter_list|(
specifier|const
name|char
modifier|*
name|vstart
parameter_list|,
name|int
name|vlen
parameter_list|,
name|int
modifier|*
name|ptag
parameter_list|,
name|int
modifier|*
name|pclass
parameter_list|)
block|{
name|char
name|erch
index|[
literal|2
index|]
decl_stmt|;
name|long
name|tag_num
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
if|if
condition|(
operator|!
name|vstart
condition|)
return|return
literal|0
return|;
name|tag_num
operator|=
name|strtoul
argument_list|(
name|vstart
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Check we haven't gone past max length: should be impossible */
if|if
condition|(
name|eptr
operator|&&
operator|*
name|eptr
operator|&&
operator|(
name|eptr
operator|>
name|vstart
operator|+
name|vlen
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tag_num
operator|<
literal|0
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_PARSE_TAGGING
argument_list|,
name|ASN1_R_INVALID_NUMBER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|ptag
operator|=
name|tag_num
expr_stmt|;
comment|/* If we have non numeric characters, parse them */
if|if
condition|(
name|eptr
condition|)
name|vlen
operator|-=
name|eptr
operator|-
name|vstart
expr_stmt|;
else|else
name|vlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vlen
condition|)
block|{
switch|switch
condition|(
operator|*
name|eptr
condition|)
block|{
case|case
literal|'U'
case|:
operator|*
name|pclass
operator|=
name|V_ASN1_UNIVERSAL
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
operator|*
name|pclass
operator|=
name|V_ASN1_APPLICATION
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
operator|*
name|pclass
operator|=
name|V_ASN1_PRIVATE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
operator|*
name|pclass
operator|=
name|V_ASN1_CONTEXT_SPECIFIC
expr_stmt|;
break|break;
default|default:
name|erch
index|[
literal|0
index|]
operator|=
operator|*
name|eptr
expr_stmt|;
name|erch
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ASN1err
argument_list|(
name|ASN1_F_PARSE_TAGGING
argument_list|,
name|ASN1_R_INVALID_MODIFIER
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"Char="
argument_list|,
name|erch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
block|}
block|}
else|else
operator|*
name|pclass
operator|=
name|V_ASN1_CONTEXT_SPECIFIC
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle multiple types: SET and SEQUENCE */
end_comment

begin_function
specifier|static
name|ASN1_TYPE
modifier|*
name|asn1_multi
parameter_list|(
name|int
name|utype
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|X509V3_CTX
modifier|*
name|cnf
parameter_list|)
block|{
name|ASN1_TYPE
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|STACK_OF
argument_list|(
name|ASN1_TYPE
argument_list|)
operator|*
name|sk
operator|=
name|NULL
expr_stmt|;
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|sect
operator|=
name|NULL
expr_stmt|;
name|unsigned
name|char
modifier|*
name|der
init|=
name|NULL
decl_stmt|;
name|int
name|derlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sk
operator|=
name|sk_ASN1_TYPE_new_null
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sk
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|section
condition|)
block|{
if|if
condition|(
operator|!
name|cnf
condition|)
goto|goto
name|bad
goto|;
name|sect
operator|=
name|X509V3_get_section
argument_list|(
name|cnf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sect
condition|)
goto|goto
name|bad
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_CONF_VALUE_num
argument_list|(
name|sect
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ASN1_TYPE
modifier|*
name|typ
init|=
name|ASN1_generate_v3
argument_list|(
name|sk_CONF_VALUE_value
argument_list|(
name|sect
argument_list|,
name|i
argument_list|)
operator|->
name|value
argument_list|,
name|cnf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|typ
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
name|sk_ASN1_TYPE_push
argument_list|(
name|sk
argument_list|,
name|typ
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* Now we has a STACK of the components, convert to the correct form */
if|if
condition|(
name|utype
operator|==
name|V_ASN1_SET
condition|)
name|derlen
operator|=
name|i2d_ASN1_SET_ANY
argument_list|(
name|sk
argument_list|,
operator|&
name|der
argument_list|)
expr_stmt|;
else|else
name|derlen
operator|=
name|i2d_ASN1_SEQUENCE_ANY
argument_list|(
name|sk
argument_list|,
operator|&
name|der
argument_list|)
expr_stmt|;
if|if
condition|(
name|derlen
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|ASN1_TYPE_new
argument_list|()
operator|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|->
name|value
operator|.
name|asn1_string
operator|=
name|ASN1_STRING_type_new
argument_list|(
name|utype
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
name|ret
operator|->
name|type
operator|=
name|utype
expr_stmt|;
name|ret
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|data
operator|=
name|der
expr_stmt|;
name|ret
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|length
operator|=
name|derlen
expr_stmt|;
name|der
operator|=
name|NULL
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|der
condition|)
name|OPENSSL_free
argument_list|(
name|der
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk
condition|)
name|sk_ASN1_TYPE_pop_free
argument_list|(
name|sk
argument_list|,
name|ASN1_TYPE_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|X509V3_section_free
argument_list|(
name|cnf
argument_list|,
name|sect
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|append_exp
parameter_list|(
name|tag_exp_arg
modifier|*
name|arg
parameter_list|,
name|int
name|exp_tag
parameter_list|,
name|int
name|exp_class
parameter_list|,
name|int
name|exp_constructed
parameter_list|,
name|int
name|exp_pad
parameter_list|,
name|int
name|imp_ok
parameter_list|)
block|{
name|tag_exp_type
modifier|*
name|exp_tmp
decl_stmt|;
comment|/* Can only have IMPLICIT if permitted */
if|if
condition|(
operator|(
name|arg
operator|->
name|imp_tag
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|!
name|imp_ok
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_APPEND_EXP
argument_list|,
name|ASN1_R_ILLEGAL_IMPLICIT_TAG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|exp_count
operator|==
name|ASN1_FLAG_EXP_MAX
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_APPEND_EXP
argument_list|,
name|ASN1_R_DEPTH_EXCEEDED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp_tmp
operator|=
operator|&
name|arg
operator|->
name|exp_list
index|[
name|arg
operator|->
name|exp_count
operator|++
index|]
expr_stmt|;
comment|/* If IMPLICIT set tag to implicit value then 	 * reset implicit tag since it has been used. 	 */
if|if
condition|(
name|arg
operator|->
name|imp_tag
operator|!=
operator|-
literal|1
condition|)
block|{
name|exp_tmp
operator|->
name|exp_tag
operator|=
name|arg
operator|->
name|imp_tag
expr_stmt|;
name|exp_tmp
operator|->
name|exp_class
operator|=
name|arg
operator|->
name|imp_class
expr_stmt|;
name|arg
operator|->
name|imp_tag
operator|=
operator|-
literal|1
expr_stmt|;
name|arg
operator|->
name|imp_class
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|exp_tmp
operator|->
name|exp_tag
operator|=
name|exp_tag
expr_stmt|;
name|exp_tmp
operator|->
name|exp_class
operator|=
name|exp_class
expr_stmt|;
block|}
name|exp_tmp
operator|->
name|exp_constructed
operator|=
name|exp_constructed
expr_stmt|;
name|exp_tmp
operator|->
name|exp_pad
operator|=
name|exp_pad
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|asn1_str2tag
parameter_list|(
specifier|const
name|char
modifier|*
name|tagstr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|struct
name|tag_name_st
modifier|*
name|tntmp
decl_stmt|,
name|tnst
index|[]
init|=
block|{
name|ASN1_GEN_STR
argument_list|(
literal|"BOOL"
argument_list|,
name|V_ASN1_BOOLEAN
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"BOOLEAN"
argument_list|,
name|V_ASN1_BOOLEAN
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"NULL"
argument_list|,
name|V_ASN1_NULL
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"INT"
argument_list|,
name|V_ASN1_INTEGER
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"INTEGER"
argument_list|,
name|V_ASN1_INTEGER
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"ENUM"
argument_list|,
name|V_ASN1_ENUMERATED
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"ENUMERATED"
argument_list|,
name|V_ASN1_ENUMERATED
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"OID"
argument_list|,
name|V_ASN1_OBJECT
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"OBJECT"
argument_list|,
name|V_ASN1_OBJECT
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"UTCTIME"
argument_list|,
name|V_ASN1_UTCTIME
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"UTC"
argument_list|,
name|V_ASN1_UTCTIME
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"GENERALIZEDTIME"
argument_list|,
name|V_ASN1_GENERALIZEDTIME
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"GENTIME"
argument_list|,
name|V_ASN1_GENERALIZEDTIME
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"OCT"
argument_list|,
name|V_ASN1_OCTET_STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"OCTETSTRING"
argument_list|,
name|V_ASN1_OCTET_STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"BITSTR"
argument_list|,
name|V_ASN1_BIT_STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"BITSTRING"
argument_list|,
name|V_ASN1_BIT_STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"UNIVERSALSTRING"
argument_list|,
name|V_ASN1_UNIVERSALSTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"UNIV"
argument_list|,
name|V_ASN1_UNIVERSALSTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"IA5"
argument_list|,
name|V_ASN1_IA5STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"IA5STRING"
argument_list|,
name|V_ASN1_IA5STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"UTF8"
argument_list|,
name|V_ASN1_UTF8STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"UTF8String"
argument_list|,
name|V_ASN1_UTF8STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"BMP"
argument_list|,
name|V_ASN1_BMPSTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"BMPSTRING"
argument_list|,
name|V_ASN1_BMPSTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"VISIBLESTRING"
argument_list|,
name|V_ASN1_VISIBLESTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"VISIBLE"
argument_list|,
name|V_ASN1_VISIBLESTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"PRINTABLESTRING"
argument_list|,
name|V_ASN1_PRINTABLESTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"PRINTABLE"
argument_list|,
name|V_ASN1_PRINTABLESTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"T61"
argument_list|,
name|V_ASN1_T61STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"T61STRING"
argument_list|,
name|V_ASN1_T61STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"TELETEXSTRING"
argument_list|,
name|V_ASN1_T61STRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"GeneralString"
argument_list|,
name|V_ASN1_GENERALSTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"GENSTR"
argument_list|,
name|V_ASN1_GENERALSTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"NUMERIC"
argument_list|,
name|V_ASN1_NUMERICSTRING
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"NUMERICSTRING"
argument_list|,
name|V_ASN1_NUMERICSTRING
argument_list|)
block|,
comment|/* Special cases */
name|ASN1_GEN_STR
argument_list|(
literal|"SEQUENCE"
argument_list|,
name|V_ASN1_SEQUENCE
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"SEQ"
argument_list|,
name|V_ASN1_SEQUENCE
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"SET"
argument_list|,
name|V_ASN1_SET
argument_list|)
block|,
comment|/* type modifiers */
comment|/* Explicit tag */
name|ASN1_GEN_STR
argument_list|(
literal|"EXP"
argument_list|,
name|ASN1_GEN_FLAG_EXP
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"EXPLICIT"
argument_list|,
name|ASN1_GEN_FLAG_EXP
argument_list|)
block|,
comment|/* Implicit tag */
name|ASN1_GEN_STR
argument_list|(
literal|"IMP"
argument_list|,
name|ASN1_GEN_FLAG_IMP
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"IMPLICIT"
argument_list|,
name|ASN1_GEN_FLAG_IMP
argument_list|)
block|,
comment|/* OCTET STRING wrapper */
name|ASN1_GEN_STR
argument_list|(
literal|"OCTWRAP"
argument_list|,
name|ASN1_GEN_FLAG_OCTWRAP
argument_list|)
block|,
comment|/* SEQUENCE wrapper */
name|ASN1_GEN_STR
argument_list|(
literal|"SEQWRAP"
argument_list|,
name|ASN1_GEN_FLAG_SEQWRAP
argument_list|)
block|,
comment|/* SET wrapper */
name|ASN1_GEN_STR
argument_list|(
literal|"SETWRAP"
argument_list|,
name|ASN1_GEN_FLAG_SETWRAP
argument_list|)
block|,
comment|/* BIT STRING wrapper */
name|ASN1_GEN_STR
argument_list|(
literal|"BITWRAP"
argument_list|,
name|ASN1_GEN_FLAG_BITWRAP
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"FORM"
argument_list|,
name|ASN1_GEN_FLAG_FORMAT
argument_list|)
block|,
name|ASN1_GEN_STR
argument_list|(
literal|"FORMAT"
argument_list|,
name|ASN1_GEN_FLAG_FORMAT
argument_list|)
block|, 	}
decl_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|tagstr
argument_list|)
expr_stmt|;
name|tntmp
operator|=
name|tnst
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tnst
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|tag_name_st
argument_list|)
condition|;
name|i
operator|++
operator|,
name|tntmp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|==
name|tntmp
operator|->
name|len
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|tntmp
operator|->
name|strnam
argument_list|,
name|tagstr
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|tntmp
operator|->
name|tag
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|ASN1_TYPE
modifier|*
name|asn1_str2type
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|utype
parameter_list|)
block|{
name|ASN1_TYPE
modifier|*
name|atmp
init|=
name|NULL
decl_stmt|;
name|CONF_VALUE
name|vtmp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rdata
decl_stmt|;
name|long
name|rdlen
decl_stmt|;
name|int
name|no_unused
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|atmp
operator|=
name|ASN1_TYPE_new
argument_list|()
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|str
condition|)
name|str
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|utype
condition|)
block|{
case|case
name|V_ASN1_NULL
case|:
if|if
condition|(
name|str
operator|&&
operator|*
name|str
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_NULL_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
break|break;
case|case
name|V_ASN1_BOOLEAN
case|:
if|if
condition|(
name|format
operator|!=
name|ASN1_GEN_FORMAT_ASCII
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_NOT_ASCII_FORMAT
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
name|vtmp
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|vtmp
operator|.
name|section
operator|=
name|NULL
expr_stmt|;
name|vtmp
operator|.
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|X509V3_get_value_bool
argument_list|(
operator|&
name|vtmp
argument_list|,
operator|&
name|atmp
operator|->
name|value
operator|.
name|boolean
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_BOOLEAN
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
break|break;
case|case
name|V_ASN1_INTEGER
case|:
case|case
name|V_ASN1_ENUMERATED
case|:
if|if
condition|(
name|format
operator|!=
name|ASN1_GEN_FORMAT_ASCII
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_INTEGER_NOT_ASCII_FORMAT
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|atmp
operator|->
name|value
operator|.
name|integer
operator|=
name|s2i_ASN1_INTEGER
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|str
argument_list|)
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_INTEGER
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
break|break;
case|case
name|V_ASN1_OBJECT
case|:
if|if
condition|(
name|format
operator|!=
name|ASN1_GEN_FORMAT_ASCII
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_OBJECT_NOT_ASCII_FORMAT
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|atmp
operator|->
name|value
operator|.
name|object
operator|=
name|OBJ_txt2obj
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_OBJECT
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
break|break;
case|case
name|V_ASN1_UTCTIME
case|:
case|case
name|V_ASN1_GENERALIZEDTIME
case|:
if|if
condition|(
name|format
operator|!=
name|ASN1_GEN_FORMAT_ASCII
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_TIME_NOT_ASCII_FORMAT
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|=
name|ASN1_STRING_new
argument_list|()
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
if|if
condition|(
operator|!
name|ASN1_STRING_set
argument_list|(
name|atmp
operator|->
name|value
operator|.
name|asn1_string
argument_list|,
name|str
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|type
operator|=
name|utype
expr_stmt|;
if|if
condition|(
operator|!
name|ASN1_TIME_check
argument_list|(
name|atmp
operator|->
name|value
operator|.
name|asn1_string
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_TIME_VALUE
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
break|break;
case|case
name|V_ASN1_BMPSTRING
case|:
case|case
name|V_ASN1_PRINTABLESTRING
case|:
case|case
name|V_ASN1_IA5STRING
case|:
case|case
name|V_ASN1_T61STRING
case|:
case|case
name|V_ASN1_UTF8STRING
case|:
case|case
name|V_ASN1_VISIBLESTRING
case|:
case|case
name|V_ASN1_UNIVERSALSTRING
case|:
case|case
name|V_ASN1_GENERALSTRING
case|:
case|case
name|V_ASN1_NUMERICSTRING
case|:
if|if
condition|(
name|format
operator|==
name|ASN1_GEN_FORMAT_ASCII
condition|)
name|format
operator|=
name|MBSTRING_ASC
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|==
name|ASN1_GEN_FORMAT_UTF8
condition|)
name|format
operator|=
name|MBSTRING_UTF8
expr_stmt|;
else|else
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_FORMAT
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
if|if
condition|(
name|ASN1_mbstring_copy
argument_list|(
operator|&
name|atmp
operator|->
name|value
operator|.
name|asn1_string
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str
argument_list|,
operator|-
literal|1
argument_list|,
name|format
argument_list|,
name|ASN1_tag2bit
argument_list|(
name|utype
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
break|break;
case|case
name|V_ASN1_BIT_STRING
case|:
case|case
name|V_ASN1_OCTET_STRING
case|:
if|if
condition|(
operator|!
operator|(
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|=
name|ASN1_STRING_new
argument_list|()
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
if|if
condition|(
name|format
operator|==
name|ASN1_GEN_FORMAT_HEX
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rdata
operator|=
name|string_to_hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
operator|&
name|rdlen
argument_list|)
operator|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_HEX
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|data
operator|=
name|rdata
expr_stmt|;
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|length
operator|=
name|rdlen
expr_stmt|;
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|type
operator|=
name|utype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|ASN1_GEN_FORMAT_ASCII
condition|)
name|ASN1_STRING_set
argument_list|(
name|atmp
operator|->
name|value
operator|.
name|asn1_string
argument_list|,
name|str
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|format
operator|==
name|ASN1_GEN_FORMAT_BITLIST
operator|)
operator|&&
operator|(
name|utype
operator|==
name|V_ASN1_BIT_STRING
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|CONF_parse_list
argument_list|(
name|str
argument_list|,
literal|','
argument_list|,
literal|1
argument_list|,
name|bitstr_cb
argument_list|,
name|atmp
operator|->
name|value
operator|.
name|bit_string
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_LIST_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
block|}
name|no_unused
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_ILLEGAL_BITSTRING_FORMAT
argument_list|)
expr_stmt|;
goto|goto
name|bad_form
goto|;
block|}
if|if
condition|(
operator|(
name|utype
operator|==
name|V_ASN1_BIT_STRING
operator|)
operator|&&
name|no_unused
condition|)
block|{
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ASN1_STRING_FLAG_BITS_LEFT
operator||
literal|0x07
operator|)
expr_stmt|;
name|atmp
operator|->
name|value
operator|.
name|asn1_string
operator|->
name|flags
operator||=
name|ASN1_STRING_FLAG_BITS_LEFT
expr_stmt|;
block|}
break|break;
default|default:
name|ASN1err
argument_list|(
name|ASN1_F_ASN1_STR2TYPE
argument_list|,
name|ASN1_R_UNSUPPORTED_TYPE
argument_list|)
expr_stmt|;
goto|goto
name|bad_str
goto|;
break|break;
block|}
name|atmp
operator|->
name|type
operator|=
name|utype
expr_stmt|;
return|return
name|atmp
return|;
name|bad_str
label|:
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"string="
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|bad_form
label|:
name|ASN1_TYPE_free
argument_list|(
name|atmp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bitstr_cb
parameter_list|(
specifier|const
name|char
modifier|*
name|elem
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|bitstr
parameter_list|)
block|{
name|long
name|bitnum
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
if|if
condition|(
operator|!
name|elem
condition|)
return|return
literal|0
return|;
name|bitnum
operator|=
name|strtoul
argument_list|(
name|elem
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|&&
operator|*
name|eptr
operator|&&
operator|(
name|eptr
operator|!=
name|elem
operator|+
name|len
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bitnum
operator|<
literal|0
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_BITSTR_CB
argument_list|,
name|ASN1_R_INVALID_NUMBER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ASN1_BIT_STRING_set_bit
argument_list|(
name|bitstr
argument_list|,
name|bitnum
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ASN1err
argument_list|(
name|ASN1_F_BITSTR_CB
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

