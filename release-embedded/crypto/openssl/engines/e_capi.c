begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* engines/e_capi.c */
end_comment

begin_comment
comment|/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL  * project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 2008 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/buffer.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_SYS_WIN32
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_CAPIENG
end_ifndef

begin_include
include|#
directive|include
file|<openssl/rsa.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32_WINNT
end_ifndef

begin_define
define|#
directive|define
name|_WIN32_WINNT
value|0x0400
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<wincrypt.h>
end_include

begin_comment
comment|/*  * This module uses several "new" interfaces, among which is  * CertGetCertificateContextProperty. CERT_KEY_PROV_INFO_PROP_ID is  * one of possible values you can pass to function in question. By  * checking if it's defined we can see if wincrypt.h and accompanying  * crypt32.lib are in shape. The native MingW32 headers up to and  * including __W32API_VERSION 3.14 lack of struct DSSPUBKEY and the  * defines CERT_STORE_PROV_SYSTEM_A and CERT_STORE_READONLY_FLAG,  * so we check for these too and avoid compiling.  * Yes, it's rather "weak" test and if compilation fails,  * then re-configure with -DOPENSSL_NO_CAPIENG.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CERT_KEY_PROV_INFO_PROP_ID
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|CERT_STORE_PROV_SYSTEM_A
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|CERT_STORE_READONLY_FLAG
argument_list|)
end_if

begin_define
define|#
directive|define
name|__COMPILE_CAPIENG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CERT_KEY_PROV_INFO_PROP_ID */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_NO_CAPIENG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENSSL_SYS_WIN32 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__COMPILE_CAPIENG
end_ifdef

begin_undef
undef|#
directive|undef
name|X509_EXTENSIONS
end_undef

begin_undef
undef|#
directive|undef
name|X509_CERT_PAIR
end_undef

begin_comment
comment|/* Definitions which may be missing from earlier version of headers */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CERT_STORE_OPEN_EXISTING_FLAG
end_ifndef

begin_define
define|#
directive|define
name|CERT_STORE_OPEN_EXISTING_FLAG
value|0x00004000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CERT_STORE_CREATE_NEW_FLAG
end_ifndef

begin_define
define|#
directive|define
name|CERT_STORE_CREATE_NEW_FLAG
value|0x00002000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CERT_SYSTEM_STORE_CURRENT_USER
end_ifndef

begin_define
define|#
directive|define
name|CERT_SYSTEM_STORE_CURRENT_USER
value|0x00010000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509v3.h>
end_include

begin_include
include|#
directive|include
file|"e_capi_err.h"
end_include

begin_include
include|#
directive|include
file|"e_capi_err.c"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_capi_id
init|=
literal|"capi"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|engine_capi_name
init|=
literal|"CryptoAPI ENGINE"
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|CAPI_CTX_st
name|CAPI_CTX
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|CAPI_KEY_st
name|CAPI_KEY
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|capi_addlasterror
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|capi_adderror
parameter_list|(
name|DWORD
name|err
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CAPI_trace
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_list_providers
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_list_containers
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|capi_list_certs
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|,
name|char
modifier|*
name|storename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|capi_free_key
parameter_list|(
name|CAPI_KEY
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|PCCERT_CONTEXT
name|capi_find_cert
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|HCERTSTORE
name|hstore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|CAPI_KEY
modifier|*
name|capi_find_key
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EVP_PKEY
modifier|*
name|capi_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_rsa_sign
parameter_list|(
name|int
name|dtype
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|m_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigret
parameter_list|,
name|unsigned
name|int
modifier|*
name|siglen
parameter_list|,
specifier|const
name|RSA
modifier|*
name|rsa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_rsa_priv_enc
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_rsa_priv_dec
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_rsa_free
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DSA_SIG
modifier|*
name|capi_dsa_do_sign
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|digest
parameter_list|,
name|int
name|dlen
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_dsa_free
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|capi_load_ssl_client_cert
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
argument_list|,
name|X509
operator|*
operator|*
name|pcert
argument_list|,
name|EVP_PKEY
operator|*
operator|*
name|pkey
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|pother
argument_list|,
name|UI_METHOD
operator|*
name|ui_method
argument_list|,
name|void
operator|*
name|callback_data
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cert_select_simple
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_CAPIENG_DIALOG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|cert_select_dialog
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|PCCERT_CONTEXT
function_decl|(
name|WINAPI
modifier|*
name|CERTDLG
function_decl|)
parameter_list|(
name|HCERTSTORE
parameter_list|,
name|HWND
parameter_list|,
name|LPCWSTR
parameter_list|,
name|LPCWSTR
parameter_list|,
name|DWORD
parameter_list|,
name|DWORD
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|HWND
function_decl|(
name|WINAPI
modifier|*
name|GETCONSWIN
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* This structure contains CAPI ENGINE specific data:  * it contains various global options and affects how  * other functions behave.  */
end_comment

begin_define
define|#
directive|define
name|CAPI_DBG_TRACE
value|2
end_define

begin_define
define|#
directive|define
name|CAPI_DBG_ERROR
value|1
end_define

begin_struct
struct|struct
name|CAPI_CTX_st
block|{
name|int
name|debug_level
decl_stmt|;
name|char
modifier|*
name|debug_file
decl_stmt|;
comment|/* Parameters to use for container lookup */
name|DWORD
name|keytype
decl_stmt|;
name|LPSTR
name|cspname
decl_stmt|;
name|DWORD
name|csptype
decl_stmt|;
comment|/* Certificate store name to use */
name|LPSTR
name|storename
decl_stmt|;
name|LPSTR
name|ssl_client_store
decl_stmt|;
comment|/* System store flags */
name|DWORD
name|store_flags
decl_stmt|;
comment|/* Lookup string meanings in load_private_key */
comment|/* Substring of subject: uses "storename" */
define|#
directive|define
name|CAPI_LU_SUBSTR
value|1
comment|/* Friendly name: uses storename */
define|#
directive|define
name|CAPI_LU_FNAME
value|2
comment|/* Container name: uses cspname, keytype */
define|#
directive|define
name|CAPI_LU_CONTNAME
value|3
name|int
name|lookup_method
decl_stmt|;
comment|/* Info to dump with dumpcerts option */
comment|/* Issuer and serial name strings */
define|#
directive|define
name|CAPI_DMP_SUMMARY
value|0x1
comment|/* Friendly name */
define|#
directive|define
name|CAPI_DMP_FNAME
value|0x2
comment|/* Full X509_print dump */
define|#
directive|define
name|CAPI_DMP_FULL
value|0x4
comment|/* Dump PEM format certificate */
define|#
directive|define
name|CAPI_DMP_PEM
value|0x8
comment|/* Dump pseudo key (if possible) */
define|#
directive|define
name|CAPI_DMP_PSKEY
value|0x10
comment|/* Dump key info (if possible) */
define|#
directive|define
name|CAPI_DMP_PKEYINFO
value|0x20
name|DWORD
name|dump_flags
decl_stmt|;
name|int
argument_list|(
operator|*
name|client_cert_select
argument_list|)
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|)
expr_stmt|;
name|CERTDLG
name|certselectdlg
decl_stmt|;
name|GETCONSWIN
name|getconswindow
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|CAPI_CTX
modifier|*
name|capi_ctx_new
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|capi_ctx_free
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_ctx_set_provname
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|LPSTR
name|pname
parameter_list|,
name|DWORD
name|type
parameter_list|,
name|int
name|check
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capi_ctx_set_provname_idx
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|int
name|idx
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CAPI_CMD_LIST_CERTS
value|ENGINE_CMD_BASE
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_LOOKUP_CERT
value|(ENGINE_CMD_BASE + 1)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_DEBUG_LEVEL
value|(ENGINE_CMD_BASE + 2)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_DEBUG_FILE
value|(ENGINE_CMD_BASE + 3)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_KEYTYPE
value|(ENGINE_CMD_BASE + 4)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_LIST_CSPS
value|(ENGINE_CMD_BASE + 5)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_SET_CSP_IDX
value|(ENGINE_CMD_BASE + 6)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_SET_CSP_NAME
value|(ENGINE_CMD_BASE + 7)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_SET_CSP_TYPE
value|(ENGINE_CMD_BASE + 8)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_LIST_CONTAINERS
value|(ENGINE_CMD_BASE + 9)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_LIST_OPTIONS
value|(ENGINE_CMD_BASE + 10)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_LOOKUP_METHOD
value|(ENGINE_CMD_BASE + 11)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_STORE_NAME
value|(ENGINE_CMD_BASE + 12)
end_define

begin_define
define|#
directive|define
name|CAPI_CMD_STORE_FLAGS
value|(ENGINE_CMD_BASE + 13)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|ENGINE_CMD_DEFN
name|capi_cmd_defns
index|[]
init|=
block|{
block|{
name|CAPI_CMD_LIST_CERTS
block|,
literal|"list_certs"
block|,
literal|"List all certificates in store"
block|,
name|ENGINE_CMD_FLAG_NO_INPUT
block|}
block|,
block|{
name|CAPI_CMD_LOOKUP_CERT
block|,
literal|"lookup_cert"
block|,
literal|"Lookup and output certificates"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|CAPI_CMD_DEBUG_LEVEL
block|,
literal|"debug_level"
block|,
literal|"debug level (1=errors, 2=trace)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|CAPI_CMD_DEBUG_FILE
block|,
literal|"debug_file"
block|,
literal|"debugging filename)"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|CAPI_CMD_KEYTYPE
block|,
literal|"key_type"
block|,
literal|"Key type: 1=AT_KEYEXCHANGE (default), 2=AT_SIGNATURE"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|CAPI_CMD_LIST_CSPS
block|,
literal|"list_csps"
block|,
literal|"List all CSPs"
block|,
name|ENGINE_CMD_FLAG_NO_INPUT
block|}
block|,
block|{
name|CAPI_CMD_SET_CSP_IDX
block|,
literal|"csp_idx"
block|,
literal|"Set CSP by index"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|CAPI_CMD_SET_CSP_NAME
block|,
literal|"csp_name"
block|,
literal|"Set CSP name, (default CSP used if not specified)"
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|CAPI_CMD_SET_CSP_TYPE
block|,
literal|"csp_type"
block|,
literal|"Set CSP type, (default RSA_PROV_FULL)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|CAPI_CMD_LIST_CONTAINERS
block|,
literal|"list_containers"
block|,
literal|"list container names"
block|,
name|ENGINE_CMD_FLAG_NO_INPUT
block|}
block|,
block|{
name|CAPI_CMD_LIST_OPTIONS
block|,
literal|"list_options"
block|,
literal|"Set list options (1=summary,2=friendly name, 4=full printout, 8=PEM output, 16=XXX, "
literal|"32=private key info)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|CAPI_CMD_LOOKUP_METHOD
block|,
literal|"lookup_method"
block|,
literal|"Set key lookup method (1=substring, 2=friendlyname, 3=container name)"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
name|CAPI_CMD_STORE_NAME
block|,
literal|"store_name"
block|,
literal|"certificate store name, default \"MY\""
block|,
name|ENGINE_CMD_FLAG_STRING
block|}
block|,
block|{
name|CAPI_CMD_STORE_FLAGS
block|,
literal|"store_flags"
block|,
literal|"Certificate store flags: 1 = system store"
block|,
name|ENGINE_CMD_FLAG_NUMERIC
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|capi_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rsa_capi_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dsa_capi_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cert_capi_idx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|capi_ctrl
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
name|int
name|cmd
parameter_list|,
name|long
name|i
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|BIO
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|capi_idx
operator|==
operator|-
literal|1
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_CTRL
argument_list|,
name|CAPI_R_ENGINE_NOT_INITIALIZED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|e
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
name|out
operator|=
name|BIO_new_fp
argument_list|(
name|stdout
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CAPI_CMD_LIST_CSPS
case|:
name|ret
operator|=
name|capi_list_providers
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_LIST_CERTS
case|:
name|ret
operator|=
name|capi_list_certs
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_LOOKUP_CERT
case|:
name|ret
operator|=
name|capi_list_certs
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_LIST_CONTAINERS
case|:
name|ret
operator|=
name|capi_list_containers
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_STORE_NAME
case|:
if|if
condition|(
name|ctx
operator|->
name|storename
condition|)
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|storename
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|storename
operator|=
name|BUF_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Setting store name to %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_STORE_FLAGS
case|:
if|if
condition|(
name|i
operator|&
literal|1
condition|)
block|{
name|ctx
operator|->
name|store_flags
operator||=
name|CERT_SYSTEM_STORE_LOCAL_MACHINE
expr_stmt|;
name|ctx
operator|->
name|store_flags
operator|&=
operator|~
name|CERT_SYSTEM_STORE_CURRENT_USER
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|store_flags
operator||=
name|CERT_SYSTEM_STORE_CURRENT_USER
expr_stmt|;
name|ctx
operator|->
name|store_flags
operator|&=
operator|~
name|CERT_SYSTEM_STORE_LOCAL_MACHINE
expr_stmt|;
block|}
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Setting flags to %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_DEBUG_LEVEL
case|:
name|ctx
operator|->
name|debug_level
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Setting debug level to %d\n"
argument_list|,
name|ctx
operator|->
name|debug_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_DEBUG_FILE
case|:
name|ctx
operator|->
name|debug_file
operator|=
name|BUF_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Setting debug file to %s\n"
argument_list|,
name|ctx
operator|->
name|debug_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_KEYTYPE
case|:
name|ctx
operator|->
name|keytype
operator|=
name|i
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Setting key type to %d\n"
argument_list|,
name|ctx
operator|->
name|keytype
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_SET_CSP_IDX
case|:
name|ret
operator|=
name|capi_ctx_set_provname_idx
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_LIST_OPTIONS
case|:
name|ctx
operator|->
name|dump_flags
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_LOOKUP_METHOD
case|:
if|if
condition|(
name|i
operator|<
literal|1
operator|||
name|i
operator|>
literal|3
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_CTRL
argument_list|,
name|CAPI_R_INVALID_LOOKUP_METHOD
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|lookup_method
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_SET_CSP_NAME
case|:
name|ret
operator|=
name|capi_ctx_set_provname
argument_list|(
name|ctx
argument_list|,
name|p
argument_list|,
name|ctx
operator|->
name|csptype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_CMD_SET_CSP_TYPE
case|:
name|ctx
operator|->
name|csptype
operator|=
name|i
expr_stmt|;
break|break;
default|default:
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_CTRL
argument_list|,
name|CAPI_R_UNKNOWN_COMMAND
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|BIO_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|RSA_METHOD
name|capi_rsa_method
init|=
block|{
literal|"CryptoAPI RSA method"
block|,
literal|0
block|,
comment|/* pub_enc */
literal|0
block|,
comment|/* pub_dec */
name|capi_rsa_priv_enc
block|,
comment|/* priv_enc */
name|capi_rsa_priv_dec
block|,
comment|/* priv_dec */
literal|0
block|,
comment|/* rsa_mod_exp */
literal|0
block|,
comment|/* bn_mod_exp */
literal|0
block|,
comment|/* init	*/
name|capi_rsa_free
block|,
comment|/* finish */
name|RSA_FLAG_SIGN_VER
block|,
comment|/* flags */
name|NULL
block|,
comment|/* app_data */
name|capi_rsa_sign
block|,
comment|/* rsa_sign */
literal|0
comment|/* rsa_verify */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DSA_METHOD
name|capi_dsa_method
init|=
block|{
literal|"CryptoAPI DSA method"
block|,
name|capi_dsa_do_sign
block|,
comment|/* dsa_do_sign */
literal|0
block|,
comment|/* dsa_sign_setup */
literal|0
block|,
comment|/* dsa_do_verify */
literal|0
block|,
comment|/* dsa_mod_exp */
literal|0
block|,
comment|/* bn_mod_exp */
literal|0
block|,
comment|/* init	*/
name|capi_dsa_free
block|,
comment|/* finish */
literal|0
block|,
comment|/* flags */
name|NULL
block|,
comment|/* app_data */
literal|0
block|,
comment|/* dsa_paramgen */
literal|0
comment|/* dsa_keygen */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|capi_init
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|RSA_METHOD
modifier|*
name|ossl_rsa_meth
decl_stmt|;
specifier|const
name|DSA_METHOD
modifier|*
name|ossl_dsa_meth
decl_stmt|;
if|if
condition|(
name|capi_idx
operator|<
literal|0
condition|)
block|{
name|capi_idx
operator|=
name|ENGINE_get_ex_new_index
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|capi_idx
operator|<
literal|0
condition|)
goto|goto
name|memerr
goto|;
name|cert_capi_idx
operator|=
name|X509_get_ex_new_index
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup RSA_METHOD */
name|rsa_capi_idx
operator|=
name|RSA_get_ex_new_index
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ossl_rsa_meth
operator|=
name|RSA_PKCS1_SSLeay
argument_list|()
expr_stmt|;
name|capi_rsa_method
operator|.
name|rsa_pub_enc
operator|=
name|ossl_rsa_meth
operator|->
name|rsa_pub_enc
expr_stmt|;
name|capi_rsa_method
operator|.
name|rsa_pub_dec
operator|=
name|ossl_rsa_meth
operator|->
name|rsa_pub_dec
expr_stmt|;
name|capi_rsa_method
operator|.
name|rsa_mod_exp
operator|=
name|ossl_rsa_meth
operator|->
name|rsa_mod_exp
expr_stmt|;
name|capi_rsa_method
operator|.
name|bn_mod_exp
operator|=
name|ossl_rsa_meth
operator|->
name|bn_mod_exp
expr_stmt|;
comment|/* Setup DSA Method */
name|dsa_capi_idx
operator|=
name|DSA_get_ex_new_index
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ossl_dsa_meth
operator|=
name|DSA_OpenSSL
argument_list|()
expr_stmt|;
name|capi_dsa_method
operator|.
name|dsa_do_verify
operator|=
name|ossl_dsa_meth
operator|->
name|dsa_do_verify
expr_stmt|;
name|capi_dsa_method
operator|.
name|dsa_mod_exp
operator|=
name|ossl_dsa_meth
operator|->
name|dsa_mod_exp
expr_stmt|;
name|capi_dsa_method
operator|.
name|bn_mod_exp
operator|=
name|ossl_dsa_meth
operator|->
name|bn_mod_exp
expr_stmt|;
block|}
name|ctx
operator|=
name|capi_ctx_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
goto|goto
name|memerr
goto|;
name|ENGINE_set_ex_data
argument_list|(
name|e
argument_list|,
name|capi_idx
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_CAPIENG_DIALOG
block|{
name|HMODULE
name|cryptui
init|=
name|LoadLibrary
argument_list|(
name|TEXT
argument_list|(
literal|"CRYPTUI.DLL"
argument_list|)
argument_list|)
decl_stmt|;
name|HMODULE
name|kernel
init|=
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"KERNEL32.DLL"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cryptui
condition|)
name|ctx
operator|->
name|certselectdlg
operator|=
operator|(
name|CERTDLG
operator|)
name|GetProcAddress
argument_list|(
name|cryptui
argument_list|,
literal|"CryptUIDlgSelectCertificateFromStore"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel
condition|)
name|ctx
operator|->
name|getconswindow
operator|=
operator|(
name|GETCONSWIN
operator|)
name|GetProcAddress
argument_list|(
name|kernel
argument_list|,
literal|"GetConsoleWindow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cryptui
operator|&&
operator|!
name|OPENSSL_isservice
argument_list|()
condition|)
name|ctx
operator|->
name|client_cert_select
operator|=
name|cert_select_dialog
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
name|memerr
label|:
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_INIT
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_destroy
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|ERR_unload_CAPI_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_finish
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|e
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
name|capi_ctx_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ENGINE_set_ex_data
argument_list|(
name|e
argument_list|,
name|capi_idx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* CryptoAPI key application data. This contains  * a handle to the private key container (for sign operations)  * and a handle to the key (for decrypt operations).  */
end_comment

begin_struct
struct|struct
name|CAPI_KEY_st
block|{
comment|/* Associated certificate context (if any) */
name|PCCERT_CONTEXT
name|pcert
decl_stmt|;
name|HCRYPTPROV
name|hprov
decl_stmt|;
name|HCRYPTKEY
name|key
decl_stmt|;
name|DWORD
name|keyspec
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|bind_capi
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ENGINE_set_id
argument_list|(
name|e
argument_list|,
name|engine_capi_id
argument_list|)
operator|||
operator|!
name|ENGINE_set_name
argument_list|(
name|e
argument_list|,
name|engine_capi_name
argument_list|)
operator|||
operator|!
name|ENGINE_set_flags
argument_list|(
name|e
argument_list|,
name|ENGINE_FLAGS_NO_REGISTER_ALL
argument_list|)
operator|||
operator|!
name|ENGINE_set_init_function
argument_list|(
name|e
argument_list|,
name|capi_init
argument_list|)
operator|||
operator|!
name|ENGINE_set_finish_function
argument_list|(
name|e
argument_list|,
name|capi_finish
argument_list|)
operator|||
operator|!
name|ENGINE_set_destroy_function
argument_list|(
name|e
argument_list|,
name|capi_destroy
argument_list|)
operator|||
operator|!
name|ENGINE_set_RSA
argument_list|(
name|e
argument_list|,
operator|&
name|capi_rsa_method
argument_list|)
operator|||
operator|!
name|ENGINE_set_DSA
argument_list|(
name|e
argument_list|,
operator|&
name|capi_dsa_method
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_privkey_function
argument_list|(
name|e
argument_list|,
name|capi_load_privkey
argument_list|)
operator|||
operator|!
name|ENGINE_set_load_ssl_client_cert_function
argument_list|(
name|e
argument_list|,
name|capi_load_ssl_client_cert
argument_list|)
operator|||
operator|!
name|ENGINE_set_cmd_defns
argument_list|(
name|e
argument_list|,
name|capi_cmd_defns
argument_list|)
operator|||
operator|!
name|ENGINE_set_ctrl_function
argument_list|(
name|e
argument_list|,
name|capi_ctrl
argument_list|)
condition|)
return|return
literal|0
return|;
name|ERR_load_CAPI_strings
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DYNAMIC_ENGINE
end_ifndef

begin_function
specifier|static
name|int
name|bind_helper
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|&&
operator|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|engine_capi_id
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|bind_capi
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_macro
name|IMPLEMENT_DYNAMIC_BIND_FN
argument_list|(
argument|bind_helper
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|ENGINE
modifier|*
name|engine_capi
parameter_list|(
name|void
parameter_list|)
block|{
name|ENGINE
modifier|*
name|ret
init|=
name|ENGINE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bind_capi
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|ENGINE_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|ENGINE_load_capi
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Copied from eng_[openssl|dyn].c */
name|ENGINE
modifier|*
name|toadd
init|=
name|engine_capi
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
return|return;
name|ENGINE_add
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ENGINE_free
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
name|ERR_clear_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|lend_tobn
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|,
name|unsigned
name|char
modifier|*
name|bin
parameter_list|,
name|int
name|binlen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Reverse buffer in place: since this is a keyblob structure 	 * that will be freed up after conversion anyway it doesn't  	 * matter if we change it. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|binlen
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|c
operator|=
name|bin
index|[
name|i
index|]
expr_stmt|;
name|bin
index|[
name|i
index|]
operator|=
name|bin
index|[
name|binlen
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|bin
index|[
name|binlen
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BN_bin2bn
argument_list|(
name|bin
argument_list|,
name|binlen
argument_list|,
name|bn
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a CAPI_KEY get an EVP_PKEY structure */
end_comment

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|capi_get_pkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
name|CAPI_KEY
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
name|DWORD
name|len
decl_stmt|;
name|BLOBHEADER
modifier|*
name|bh
decl_stmt|;
name|RSA
modifier|*
name|rkey
init|=
name|NULL
decl_stmt|;
name|DSA
modifier|*
name|dkey
init|=
name|NULL
decl_stmt|;
name|EVP_PKEY
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|CryptExportKey
argument_list|(
name|key
operator|->
name|key
argument_list|,
literal|0
argument_list|,
name|PUBLICKEYBLOB
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PKEY
argument_list|,
name|CAPI_R_PUBKEY_EXPORT_LENGTH_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pubkey
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pubkey
condition|)
goto|goto
name|memerr
goto|;
if|if
condition|(
operator|!
name|CryptExportKey
argument_list|(
name|key
operator|->
name|key
argument_list|,
literal|0
argument_list|,
name|PUBLICKEYBLOB
argument_list|,
literal|0
argument_list|,
name|pubkey
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PKEY
argument_list|,
name|CAPI_R_PUBKEY_EXPORT_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bh
operator|=
operator|(
name|BLOBHEADER
operator|*
operator|)
name|pubkey
expr_stmt|;
if|if
condition|(
name|bh
operator|->
name|bType
operator|!=
name|PUBLICKEYBLOB
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PKEY
argument_list|,
name|CAPI_R_INVALID_PUBLIC_KEY_BLOB
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|bh
operator|->
name|aiKeyAlg
operator|==
name|CALG_RSA_SIGN
operator|||
name|bh
operator|->
name|aiKeyAlg
operator|==
name|CALG_RSA_KEYX
condition|)
block|{
name|RSAPUBKEY
modifier|*
name|rp
decl_stmt|;
name|DWORD
name|rsa_modlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rsa_modulus
decl_stmt|;
name|rp
operator|=
operator|(
name|RSAPUBKEY
operator|*
operator|)
operator|(
name|bh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|magic
operator|!=
literal|0x31415352
condition|)
block|{
name|char
name|magstr
index|[
literal|10
index|]
decl_stmt|;
name|BIO_snprintf
argument_list|(
name|magstr
argument_list|,
literal|10
argument_list|,
literal|"%lx"
argument_list|,
name|rp
operator|->
name|magic
argument_list|)
expr_stmt|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PKEY
argument_list|,
name|CAPI_R_INVALID_RSA_PUBLIC_KEY_BLOB_MAGIC_NUMBER
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"magic=0x"
argument_list|,
name|magstr
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|rsa_modulus
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|rp
operator|+
literal|1
operator|)
expr_stmt|;
name|rkey
operator|=
name|RSA_new_method
argument_list|(
name|eng
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rkey
condition|)
goto|goto
name|memerr
goto|;
name|rkey
operator|->
name|e
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|rkey
operator|->
name|n
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rkey
operator|->
name|e
operator|||
operator|!
name|rkey
operator|->
name|n
condition|)
goto|goto
name|memerr
goto|;
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|rkey
operator|->
name|e
argument_list|,
name|rp
operator|->
name|pubexp
argument_list|)
condition|)
goto|goto
name|memerr
goto|;
name|rsa_modlen
operator|=
name|rp
operator|->
name|bitlen
operator|/
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|lend_tobn
argument_list|(
name|rkey
operator|->
name|n
argument_list|,
name|rsa_modulus
argument_list|,
name|rsa_modlen
argument_list|)
condition|)
goto|goto
name|memerr
goto|;
name|RSA_set_ex_data
argument_list|(
name|rkey
argument_list|,
name|rsa_capi_idx
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|EVP_PKEY_new
argument_list|()
operator|)
condition|)
goto|goto
name|memerr
goto|;
name|EVP_PKEY_assign_RSA
argument_list|(
name|ret
argument_list|,
name|rkey
argument_list|)
expr_stmt|;
name|rkey
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bh
operator|->
name|aiKeyAlg
operator|==
name|CALG_DSS_SIGN
condition|)
block|{
name|DSSPUBKEY
modifier|*
name|dp
decl_stmt|;
name|DWORD
name|dsa_plen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|btmp
decl_stmt|;
name|dp
operator|=
operator|(
name|DSSPUBKEY
operator|*
operator|)
operator|(
name|bh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|magic
operator|!=
literal|0x31535344
condition|)
block|{
name|char
name|magstr
index|[
literal|10
index|]
decl_stmt|;
name|BIO_snprintf
argument_list|(
name|magstr
argument_list|,
literal|10
argument_list|,
literal|"%lx"
argument_list|,
name|dp
operator|->
name|magic
argument_list|)
expr_stmt|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PKEY
argument_list|,
name|CAPI_R_INVALID_DSA_PUBLIC_KEY_BLOB_MAGIC_NUMBER
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"magic=0x"
argument_list|,
name|magstr
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|dsa_plen
operator|=
name|dp
operator|->
name|bitlen
operator|/
literal|8
expr_stmt|;
name|btmp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|dp
operator|+
literal|1
operator|)
expr_stmt|;
name|dkey
operator|=
name|DSA_new_method
argument_list|(
name|eng
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dkey
condition|)
goto|goto
name|memerr
goto|;
name|dkey
operator|->
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dkey
operator|->
name|q
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dkey
operator|->
name|g
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|dkey
operator|->
name|pub_key
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dkey
operator|->
name|p
operator|||
operator|!
name|dkey
operator|->
name|q
operator|||
operator|!
name|dkey
operator|->
name|g
operator|||
operator|!
name|dkey
operator|->
name|pub_key
condition|)
goto|goto
name|memerr
goto|;
if|if
condition|(
operator|!
name|lend_tobn
argument_list|(
name|dkey
operator|->
name|p
argument_list|,
name|btmp
argument_list|,
name|dsa_plen
argument_list|)
condition|)
goto|goto
name|memerr
goto|;
name|btmp
operator|+=
name|dsa_plen
expr_stmt|;
if|if
condition|(
operator|!
name|lend_tobn
argument_list|(
name|dkey
operator|->
name|q
argument_list|,
name|btmp
argument_list|,
literal|20
argument_list|)
condition|)
goto|goto
name|memerr
goto|;
name|btmp
operator|+=
literal|20
expr_stmt|;
if|if
condition|(
operator|!
name|lend_tobn
argument_list|(
name|dkey
operator|->
name|g
argument_list|,
name|btmp
argument_list|,
name|dsa_plen
argument_list|)
condition|)
goto|goto
name|memerr
goto|;
name|btmp
operator|+=
name|dsa_plen
expr_stmt|;
if|if
condition|(
operator|!
name|lend_tobn
argument_list|(
name|dkey
operator|->
name|pub_key
argument_list|,
name|btmp
argument_list|,
name|dsa_plen
argument_list|)
condition|)
goto|goto
name|memerr
goto|;
name|btmp
operator|+=
name|dsa_plen
expr_stmt|;
name|DSA_set_ex_data
argument_list|(
name|dkey
argument_list|,
name|dsa_capi_idx
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ret
operator|=
name|EVP_PKEY_new
argument_list|()
operator|)
condition|)
goto|goto
name|memerr
goto|;
name|EVP_PKEY_assign_DSA
argument_list|(
name|ret
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
name|dkey
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|char
name|algstr
index|[
literal|10
index|]
decl_stmt|;
name|BIO_snprintf
argument_list|(
name|algstr
argument_list|,
literal|10
argument_list|,
literal|"%lx"
argument_list|,
name|bh
operator|->
name|aiKeyAlg
argument_list|)
expr_stmt|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PKEY
argument_list|,
name|CAPI_R_UNSUPPORTED_PUBLIC_KEY_ALGORITHM
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"aiKeyAlg=0x"
argument_list|,
name|algstr
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|err
label|:
if|if
condition|(
name|pubkey
condition|)
name|OPENSSL_free
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
if|if
condition|(
name|rkey
condition|)
name|RSA_free
argument_list|(
name|rkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkey
condition|)
name|DSA_free
argument_list|(
name|dkey
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
name|memerr
label|:
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PKEY
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
end_function

begin_function
specifier|static
name|EVP_PKEY
modifier|*
name|capi_load_privkey
parameter_list|(
name|ENGINE
modifier|*
name|eng
parameter_list|,
specifier|const
name|char
modifier|*
name|key_id
parameter_list|,
name|UI_METHOD
modifier|*
name|ui_method
parameter_list|,
name|void
modifier|*
name|callback_data
parameter_list|)
block|{
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|CAPI_KEY
modifier|*
name|key
decl_stmt|;
name|EVP_PKEY
modifier|*
name|ret
decl_stmt|;
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|eng
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_LOAD_PRIVKEY
argument_list|,
name|CAPI_R_CANT_FIND_CAPI_CONTEXT
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key
operator|=
name|capi_find_key
argument_list|(
name|ctx
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|capi_get_pkey
argument_list|(
name|eng
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|capi_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* CryptoAPI RSA operations */
end_comment

begin_function
name|int
name|capi_rsa_priv_enc
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_PRIV_ENC
argument_list|,
name|CAPI_R_FUNCTION_NOT_SUPPORTED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|capi_rsa_sign
parameter_list|(
name|int
name|dtype
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|m_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigret
parameter_list|,
name|unsigned
name|int
modifier|*
name|siglen
parameter_list|,
specifier|const
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|ALG_ID
name|alg
decl_stmt|;
name|HCRYPTHASH
name|hash
decl_stmt|;
name|DWORD
name|slen
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|CAPI_KEY
modifier|*
name|capi_key
decl_stmt|;
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|rsa
operator|->
name|engine
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Called CAPI_rsa_sign()\n"
argument_list|)
expr_stmt|;
name|capi_key
operator|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|rsa_capi_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|capi_key
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_SIGN
argument_list|,
name|CAPI_R_CANT_GET_KEY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Convert the signature type to a CryptoAPI algorithm ID */
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|NID_sha1
case|:
name|alg
operator|=
name|CALG_SHA1
expr_stmt|;
break|break;
case|case
name|NID_md5
case|:
name|alg
operator|=
name|CALG_MD5
expr_stmt|;
break|break;
case|case
name|NID_md5_sha1
case|:
name|alg
operator|=
name|CALG_SSL3_SHAMD5
expr_stmt|;
break|break;
default|default:
block|{
name|char
name|algstr
index|[
literal|10
index|]
decl_stmt|;
name|BIO_snprintf
argument_list|(
name|algstr
argument_list|,
literal|10
argument_list|,
literal|"%lx"
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_SIGN
argument_list|,
name|CAPI_R_UNSUPPORTED_ALGORITHM_NID
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"NID=0x"
argument_list|,
name|algstr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Create the hash object */
if|if
condition|(
operator|!
name|CryptCreateHash
argument_list|(
name|capi_key
operator|->
name|hprov
argument_list|,
name|alg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|hash
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_SIGN
argument_list|,
name|CAPI_R_CANT_CREATE_HASH_OBJECT
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Set the hash value to the value passed */
if|if
condition|(
operator|!
name|CryptSetHashParam
argument_list|(
name|hash
argument_list|,
name|HP_HASHVAL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_SIGN
argument_list|,
name|CAPI_R_CANT_SET_HASH_VALUE
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Finally sign it */
name|slen
operator|=
name|RSA_size
argument_list|(
name|rsa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CryptSignHashA
argument_list|(
name|hash
argument_list|,
name|capi_key
operator|->
name|keyspec
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sigret
argument_list|,
operator|&
name|slen
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_SIGN
argument_list|,
name|CAPI_R_ERROR_SIGNING_HASH
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* Inplace byte reversal of signature */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slen
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|c
operator|=
name|sigret
index|[
name|i
index|]
expr_stmt|;
name|sigret
index|[
name|i
index|]
operator|=
name|sigret
index|[
name|slen
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|sigret
index|[
name|slen
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|siglen
operator|=
name|slen
expr_stmt|;
block|}
comment|/* Now cleanup */
name|err
label|:
name|CryptDestroyHash
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|capi_rsa_priv_dec
parameter_list|(
name|int
name|flen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|from
parameter_list|,
name|unsigned
name|char
modifier|*
name|to
parameter_list|,
name|RSA
modifier|*
name|rsa
parameter_list|,
name|int
name|padding
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|CAPI_KEY
modifier|*
name|capi_key
decl_stmt|;
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|rsa
operator|->
name|engine
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Called capi_rsa_priv_dec()\n"
argument_list|)
expr_stmt|;
name|capi_key
operator|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|rsa_capi_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|capi_key
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_PRIV_DEC
argument_list|,
name|CAPI_R_CANT_GET_KEY
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|padding
operator|!=
name|RSA_PKCS1_PADDING
condition|)
block|{
name|char
name|errstr
index|[
literal|10
index|]
decl_stmt|;
name|BIO_snprintf
argument_list|(
name|errstr
argument_list|,
literal|10
argument_list|,
literal|"%d"
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_PRIV_DEC
argument_list|,
name|CAPI_R_UNSUPPORTED_PADDING
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"padding="
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Create temp reverse order version of input */
if|if
condition|(
operator|!
operator|(
name|tmpbuf
operator|=
name|OPENSSL_malloc
argument_list|(
name|flen
argument_list|)
operator|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_PRIV_DEC
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|flen
condition|;
name|i
operator|++
control|)
name|tmpbuf
index|[
name|flen
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
comment|/* Finally decrypt it */
if|if
condition|(
operator|!
name|CryptDecrypt
argument_list|(
name|capi_key
operator|->
name|key
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|tmpbuf
argument_list|,
operator|&
name|flen
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_RSA_PRIV_DEC
argument_list|,
name|CAPI_R_DECRYPT_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
name|memcpy
argument_list|(
name|to
argument_list|,
name|tmpbuf
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
return|return
name|flen
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_rsa_free
parameter_list|(
name|RSA
modifier|*
name|rsa
parameter_list|)
block|{
name|CAPI_KEY
modifier|*
name|capi_key
decl_stmt|;
name|capi_key
operator|=
name|RSA_get_ex_data
argument_list|(
name|rsa
argument_list|,
name|rsa_capi_idx
argument_list|)
expr_stmt|;
name|capi_free_key
argument_list|(
name|capi_key
argument_list|)
expr_stmt|;
name|RSA_set_ex_data
argument_list|(
name|rsa
argument_list|,
name|rsa_capi_idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* CryptoAPI DSA operations */
end_comment

begin_function
specifier|static
name|DSA_SIG
modifier|*
name|capi_dsa_do_sign
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|digest
parameter_list|,
name|int
name|dlen
parameter_list|,
name|DSA
modifier|*
name|dsa
parameter_list|)
block|{
name|HCRYPTHASH
name|hash
decl_stmt|;
name|DWORD
name|slen
decl_stmt|;
name|DSA_SIG
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|CAPI_KEY
modifier|*
name|capi_key
decl_stmt|;
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|unsigned
name|char
name|csigbuf
index|[
literal|40
index|]
decl_stmt|;
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|dsa
operator|->
name|engine
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Called CAPI_dsa_do_sign()\n"
argument_list|)
expr_stmt|;
name|capi_key
operator|=
name|DSA_get_ex_data
argument_list|(
name|dsa
argument_list|,
name|dsa_capi_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|capi_key
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_DSA_DO_SIGN
argument_list|,
name|CAPI_R_CANT_GET_KEY
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|dlen
operator|!=
literal|20
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_DSA_DO_SIGN
argument_list|,
name|CAPI_R_INVALID_DIGEST_LENGTH
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Create the hash object */
if|if
condition|(
operator|!
name|CryptCreateHash
argument_list|(
name|capi_key
operator|->
name|hprov
argument_list|,
name|CALG_SHA1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|hash
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_DSA_DO_SIGN
argument_list|,
name|CAPI_R_CANT_CREATE_HASH_OBJECT
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Set the hash value to the value passed */
if|if
condition|(
operator|!
name|CryptSetHashParam
argument_list|(
name|hash
argument_list|,
name|HP_HASHVAL
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_DSA_DO_SIGN
argument_list|,
name|CAPI_R_CANT_SET_HASH_VALUE
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Finally sign it */
name|slen
operator|=
sizeof|sizeof
argument_list|(
name|csigbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CryptSignHashA
argument_list|(
name|hash
argument_list|,
name|capi_key
operator|->
name|keyspec
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|csigbuf
argument_list|,
operator|&
name|slen
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_DSA_DO_SIGN
argument_list|,
name|CAPI_R_ERROR_SIGNING_HASH
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|ret
operator|=
name|DSA_SIG_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
goto|goto
name|err
goto|;
name|ret
operator|->
name|r
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|ret
operator|->
name|s
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|->
name|r
operator|||
operator|!
name|ret
operator|->
name|s
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|lend_tobn
argument_list|(
name|ret
operator|->
name|r
argument_list|,
name|csigbuf
argument_list|,
literal|20
argument_list|)
operator|||
operator|!
name|lend_tobn
argument_list|(
name|ret
operator|->
name|s
argument_list|,
name|csigbuf
operator|+
literal|20
argument_list|,
literal|20
argument_list|)
condition|)
block|{
name|DSA_SIG_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* Now cleanup */
name|err
label|:
name|OPENSSL_cleanse
argument_list|(
name|csigbuf
argument_list|,
literal|40
argument_list|)
expr_stmt|;
name|CryptDestroyHash
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_dsa_free
parameter_list|(
name|DSA
modifier|*
name|dsa
parameter_list|)
block|{
name|CAPI_KEY
modifier|*
name|capi_key
decl_stmt|;
name|capi_key
operator|=
name|DSA_get_ex_data
argument_list|(
name|dsa
argument_list|,
name|dsa_capi_idx
argument_list|)
expr_stmt|;
name|capi_free_key
argument_list|(
name|capi_key
argument_list|)
expr_stmt|;
name|DSA_set_ex_data
argument_list|(
name|dsa
argument_list|,
name|dsa_capi_idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|capi_vtrace
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|int
name|level
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|argptr
parameter_list|)
block|{
name|BIO
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|||
operator|(
name|ctx
operator|->
name|debug_level
operator|<
name|level
operator|)
operator|||
operator|(
operator|!
name|ctx
operator|->
name|debug_file
operator|)
condition|)
return|return;
name|out
operator|=
name|BIO_new_file
argument_list|(
name|ctx
operator|->
name|debug_file
argument_list|,
literal|"a+"
argument_list|)
expr_stmt|;
name|BIO_vprintf
argument_list|(
name|out
argument_list|,
name|format
argument_list|,
name|argptr
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|CAPI_trace
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|capi_vtrace
argument_list|(
name|ctx
argument_list|,
name|CAPI_DBG_TRACE
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|capi_addlasterror
parameter_list|(
name|void
parameter_list|)
block|{
name|capi_adderror
argument_list|(
name|GetLastError
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|capi_adderror
parameter_list|(
name|DWORD
name|err
parameter_list|)
block|{
name|char
name|errstr
index|[
literal|10
index|]
decl_stmt|;
name|BIO_snprintf
argument_list|(
name|errstr
argument_list|,
literal|10
argument_list|,
literal|"%lX"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ERR_add_error_data
argument_list|(
literal|2
argument_list|,
literal|"Error code= 0x"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|wide_to_asc
parameter_list|(
name|LPWSTR
name|wstr
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len_0
decl_stmt|,
name|sz
decl_stmt|;
if|if
condition|(
operator|!
name|wstr
condition|)
return|return
name|NULL
return|;
name|len_0
operator|=
operator|(
name|int
operator|)
name|wcslen
argument_list|(
name|wstr
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* WideCharToMultiByte expects int */
name|sz
operator|=
name|WideCharToMultiByte
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|wstr
argument_list|,
name|len_0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sz
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_WIDE_TO_ASC
argument_list|,
name|CAPI_R_WIN32_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|str
operator|=
name|OPENSSL_malloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_WIDE_TO_ASC
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|WideCharToMultiByte
argument_list|(
name|CP_ACP
argument_list|,
literal|0
argument_list|,
name|wstr
argument_list|,
name|len_0
argument_list|,
name|str
argument_list|,
name|sz
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|CAPIerr
argument_list|(
name|CAPI_F_WIDE_TO_ASC
argument_list|,
name|CAPI_R_WIN32_ERROR
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_get_provname
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|LPSTR
modifier|*
name|pname
parameter_list|,
name|DWORD
modifier|*
name|ptype
parameter_list|,
name|DWORD
name|idx
parameter_list|)
block|{
name|LPSTR
name|name
decl_stmt|;
name|DWORD
name|len
decl_stmt|,
name|err
decl_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"capi_get_provname, index=%d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CryptEnumProvidersA
argument_list|(
name|idx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ptype
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERROR_NO_MORE_ITEMS
condition|)
return|return
literal|2
return|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PROVNAME
argument_list|,
name|CAPI_R_CRYPTENUMPROVIDERS_ERROR
argument_list|)
expr_stmt|;
name|capi_adderror
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|name
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CryptEnumProvidersA
argument_list|(
name|idx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ptype
argument_list|,
name|name
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERROR_NO_MORE_ITEMS
condition|)
return|return
literal|2
return|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PROVNAME
argument_list|,
name|CAPI_R_CRYPTENUMPROVIDERS_ERROR
argument_list|)
expr_stmt|;
name|capi_adderror
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|pname
operator|=
name|name
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"capi_get_provname, returned name=%s, type=%d\n"
argument_list|,
name|name
argument_list|,
operator|*
name|ptype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_list_providers
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|)
block|{
name|DWORD
name|idx
decl_stmt|,
name|ptype
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|LPSTR
name|provname
init|=
name|NULL
decl_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"capi_list_providers\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"Available CSPs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
condition|;
name|idx
operator|++
control|)
block|{
name|ret
operator|=
name|capi_get_provname
argument_list|(
name|ctx
argument_list|,
operator|&
name|provname
argument_list|,
operator|&
name|ptype
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
break|break;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
break|break;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%d. %s, type %d\n"
argument_list|,
name|idx
argument_list|,
name|provname
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|provname
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_list_containers
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|HCRYPTPROV
name|hprov
decl_stmt|;
name|DWORD
name|err
decl_stmt|,
name|idx
decl_stmt|,
name|flags
decl_stmt|,
name|buflen
init|=
literal|0
decl_stmt|,
name|clen
decl_stmt|;
name|LPSTR
name|cname
decl_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Listing containers CSP=%s, type = %d\n"
argument_list|,
name|ctx
operator|->
name|cspname
argument_list|,
name|ctx
operator|->
name|csptype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CryptAcquireContextA
argument_list|(
operator|&
name|hprov
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|cspname
argument_list|,
name|ctx
operator|->
name|csptype
argument_list|,
name|CRYPT_VERIFYCONTEXT
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_LIST_CONTAINERS
argument_list|,
name|CAPI_R_CRYPTACQUIRECONTEXT_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|CryptGetProvParam
argument_list|(
name|hprov
argument_list|,
name|PP_ENUMCONTAINERS
argument_list|,
name|NULL
argument_list|,
operator|&
name|buflen
argument_list|,
name|CRYPT_FIRST
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_LIST_CONTAINERS
argument_list|,
name|CAPI_R_ENUMCONTAINERS_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
name|CryptReleaseContext
argument_list|(
name|hprov
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Got max container len %d\n"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
name|buflen
operator|=
literal|1024
expr_stmt|;
name|cname
operator|=
name|OPENSSL_malloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cname
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_LIST_CONTAINERS
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
condition|;
name|idx
operator|++
control|)
block|{
name|clen
operator|=
name|buflen
expr_stmt|;
name|cname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
name|flags
operator|=
name|CRYPT_FIRST
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|CryptGetProvParam
argument_list|(
name|hprov
argument_list|,
name|PP_ENUMCONTAINERS
argument_list|,
name|cname
argument_list|,
operator|&
name|clen
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|err
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERROR_NO_MORE_ITEMS
condition|)
goto|goto
name|done
goto|;
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_LIST_CONTAINERS
argument_list|,
name|CAPI_R_ENUMCONTAINERS_ERROR
argument_list|)
expr_stmt|;
name|capi_adderror
argument_list|(
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Container name %s, len=%d, index=%d, flags=%d\n"
argument_list|,
name|cname
argument_list|,
name|clen
argument_list|,
name|idx
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cname
index|[
literal|0
index|]
operator|&&
operator|(
name|clen
operator|==
name|buflen
operator|)
condition|)
block|{
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Enumerate bug: using workaround\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%d. %s\n"
argument_list|,
name|idx
argument_list|,
name|cname
argument_list|)
expr_stmt|;
block|}
name|err
label|:
name|ret
operator|=
literal|0
expr_stmt|;
name|done
label|:
if|if
condition|(
name|cname
condition|)
name|OPENSSL_free
argument_list|(
name|cname
argument_list|)
expr_stmt|;
name|CryptReleaseContext
argument_list|(
name|hprov
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|CRYPT_KEY_PROV_INFO
modifier|*
name|capi_get_prov_info
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|PCCERT_CONTEXT
name|cert
parameter_list|)
block|{
name|DWORD
name|len
decl_stmt|;
name|CRYPT_KEY_PROV_INFO
modifier|*
name|pinfo
decl_stmt|;
if|if
condition|(
operator|!
name|CertGetCertificateContextProperty
argument_list|(
name|cert
argument_list|,
name|CERT_KEY_PROV_INFO_PROP_ID
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
condition|)
return|return
name|NULL
return|;
name|pinfo
operator|=
name|OPENSSL_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pinfo
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PROV_INFO
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|CertGetCertificateContextProperty
argument_list|(
name|cert
argument_list|,
name|CERT_KEY_PROV_INFO_PROP_ID
argument_list|,
name|pinfo
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_PROV_INFO
argument_list|,
name|CAPI_R_ERROR_GETTING_KEY_PROVIDER_INFO
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pinfo
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pinfo
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|capi_dump_prov_info
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|,
name|CRYPT_KEY_PROV_INFO
modifier|*
name|pinfo
parameter_list|)
block|{
name|char
modifier|*
name|provname
init|=
name|NULL
decl_stmt|,
modifier|*
name|contname
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pinfo
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"  No Private Key\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|provname
operator|=
name|wide_to_asc
argument_list|(
name|pinfo
operator|->
name|pwszProvName
argument_list|)
expr_stmt|;
name|contname
operator|=
name|wide_to_asc
argument_list|(
name|pinfo
operator|->
name|pwszContainerName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|provname
operator|||
operator|!
name|contname
condition|)
goto|goto
name|err
goto|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"  Private Key Info:\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"    Provider Name:  %s, Provider Type %d\n"
argument_list|,
name|provname
argument_list|,
name|pinfo
operator|->
name|dwProvType
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"    Container Name: %s, Key Type %d\n"
argument_list|,
name|contname
argument_list|,
name|pinfo
operator|->
name|dwKeySpec
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
name|provname
condition|)
name|OPENSSL_free
argument_list|(
name|provname
argument_list|)
expr_stmt|;
if|if
condition|(
name|contname
condition|)
name|OPENSSL_free
argument_list|(
name|contname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|capi_cert_get_fname
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|PCCERT_CONTEXT
name|cert
parameter_list|)
block|{
name|LPWSTR
name|wfname
decl_stmt|;
name|DWORD
name|dlen
decl_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"capi_cert_get_fname\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CertGetCertificateContextProperty
argument_list|(
name|cert
argument_list|,
name|CERT_FRIENDLY_NAME_PROP_ID
argument_list|,
name|NULL
argument_list|,
operator|&
name|dlen
argument_list|)
condition|)
return|return
name|NULL
return|;
name|wfname
operator|=
name|OPENSSL_malloc
argument_list|(
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|CertGetCertificateContextProperty
argument_list|(
name|cert
argument_list|,
name|CERT_FRIENDLY_NAME_PROP_ID
argument_list|,
name|wfname
argument_list|,
operator|&
name|dlen
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fname
init|=
name|wide_to_asc
argument_list|(
name|wfname
argument_list|)
decl_stmt|;
name|OPENSSL_free
argument_list|(
name|wfname
argument_list|)
expr_stmt|;
return|return
name|fname
return|;
block|}
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_CERT_GET_FNAME
argument_list|,
name|CAPI_R_ERROR_GETTING_FRIENDLY_NAME
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|wfname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|capi_dump_cert
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|,
name|PCCERT_CONTEXT
name|cert
parameter_list|)
block|{
name|X509
modifier|*
name|x
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|flags
init|=
name|ctx
operator|->
name|dump_flags
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|CAPI_DMP_FNAME
condition|)
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|fname
operator|=
name|capi_cert_get_fname
argument_list|(
name|ctx
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"  Friendly Name \"%s\"\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"<No Friendly Name>\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|cert
operator|->
name|pbCertEncoded
expr_stmt|;
name|x
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|cert
operator|->
name|cbCertEncoded
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"<Can't parse certificate>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CAPI_DMP_SUMMARY
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"  Subject: "
argument_list|)
expr_stmt|;
name|X509_NAME_print_ex
argument_list|(
name|out
argument_list|,
name|X509_get_subject_name
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XN_FLAG_ONELINE
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n  Issuer: "
argument_list|)
expr_stmt|;
name|X509_NAME_print_ex
argument_list|(
name|out
argument_list|,
name|X509_get_issuer_name
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XN_FLAG_ONELINE
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CAPI_DMP_FULL
condition|)
name|X509_print_ex
argument_list|(
name|out
argument_list|,
name|x
argument_list|,
name|XN_FLAG_ONELINE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CAPI_DMP_PKEYINFO
condition|)
block|{
name|CRYPT_KEY_PROV_INFO
modifier|*
name|pinfo
decl_stmt|;
name|pinfo
operator|=
name|capi_get_prov_info
argument_list|(
name|ctx
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|capi_dump_prov_info
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
name|pinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo
condition|)
name|OPENSSL_free
argument_list|(
name|pinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CAPI_DMP_PEM
condition|)
name|PEM_write_bio_X509
argument_list|(
name|out
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|HCERTSTORE
name|capi_open_store
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|char
modifier|*
name|storename
parameter_list|)
block|{
name|HCERTSTORE
name|hstore
decl_stmt|;
if|if
condition|(
operator|!
name|storename
condition|)
name|storename
operator|=
name|ctx
operator|->
name|storename
expr_stmt|;
if|if
condition|(
operator|!
name|storename
condition|)
name|storename
operator|=
literal|"MY"
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Opening certificate store %s\n"
argument_list|,
name|storename
argument_list|)
expr_stmt|;
name|hstore
operator|=
name|CertOpenStore
argument_list|(
name|CERT_STORE_PROV_SYSTEM_A
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ctx
operator|->
name|store_flags
argument_list|,
name|storename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hstore
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_OPEN_STORE
argument_list|,
name|CAPI_R_ERROR_OPENING_STORE
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
block|}
return|return
name|hstore
return|;
block|}
end_function

begin_function
name|int
name|capi_list_certs
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|BIO
modifier|*
name|out
parameter_list|,
name|char
modifier|*
name|id
parameter_list|)
block|{
name|char
modifier|*
name|storename
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|HCERTSTORE
name|hstore
decl_stmt|;
name|PCCERT_CONTEXT
name|cert
init|=
name|NULL
decl_stmt|;
name|storename
operator|=
name|ctx
operator|->
name|storename
expr_stmt|;
if|if
condition|(
operator|!
name|storename
condition|)
name|storename
operator|=
literal|"MY"
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Listing certs for store %s\n"
argument_list|,
name|storename
argument_list|)
expr_stmt|;
name|hstore
operator|=
name|capi_open_store
argument_list|(
name|ctx
argument_list|,
name|storename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hstore
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|id
condition|)
block|{
name|cert
operator|=
name|capi_find_cert
argument_list|(
name|ctx
argument_list|,
name|id
argument_list|,
name|hstore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|capi_dump_cert
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|CertFreeCertificateContext
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
condition|;
name|idx
operator|++
control|)
block|{
name|LPWSTR
name|fname
init|=
name|NULL
decl_stmt|;
name|cert
operator|=
name|CertEnumCertificatesInStore
argument_list|(
name|hstore
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
break|break;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"Certificate %d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|capi_dump_cert
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
name|cert
argument_list|)
expr_stmt|;
block|}
block|}
name|err
label|:
name|CertCloseStore
argument_list|(
name|hstore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|PCCERT_CONTEXT
name|capi_find_cert
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|HCERTSTORE
name|hstore
parameter_list|)
block|{
name|PCCERT_CONTEXT
name|cert
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fname
init|=
name|NULL
decl_stmt|;
name|int
name|match
decl_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|lookup_method
condition|)
block|{
case|case
name|CAPI_LU_SUBSTR
case|:
return|return
name|CertFindCertificateInStore
argument_list|(
name|hstore
argument_list|,
name|X509_ASN_ENCODING
argument_list|,
literal|0
argument_list|,
name|CERT_FIND_SUBJECT_STR_A
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|)
return|;
case|case
name|CAPI_LU_FNAME
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|cert
operator|=
name|CertEnumCertificatesInStore
argument_list|(
name|hstore
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
return|return
name|NULL
return|;
name|fname
operator|=
name|capi_cert_get_fname
argument_list|(
name|ctx
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|id
argument_list|)
condition|)
name|match
operator|=
literal|0
expr_stmt|;
else|else
name|match
operator|=
literal|1
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
return|return
name|cert
return|;
block|}
block|}
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|CAPI_KEY
modifier|*
name|capi_get_key
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|contname
parameter_list|,
name|char
modifier|*
name|provname
parameter_list|,
name|DWORD
name|ptype
parameter_list|,
name|DWORD
name|keyspec
parameter_list|)
block|{
name|CAPI_KEY
modifier|*
name|key
decl_stmt|;
name|DWORD
name|dwFlags
init|=
literal|0
decl_stmt|;
name|key
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CAPI_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"capi_get_key, contname=%s, provname=%s, type=%d\n"
argument_list|,
name|contname
argument_list|,
name|provname
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|store_flags
operator|&
name|CERT_SYSTEM_STORE_LOCAL_MACHINE
condition|)
name|dwFlags
operator|=
name|CRYPT_MACHINE_KEYSET
expr_stmt|;
if|if
condition|(
operator|!
name|CryptAcquireContextA
argument_list|(
operator|&
name|key
operator|->
name|hprov
argument_list|,
name|contname
argument_list|,
name|provname
argument_list|,
name|ptype
argument_list|,
name|dwFlags
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_KEY
argument_list|,
name|CAPI_R_CRYPTACQUIRECONTEXT_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|CryptGetUserKey
argument_list|(
name|key
operator|->
name|hprov
argument_list|,
name|keyspec
argument_list|,
operator|&
name|key
operator|->
name|key
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_GET_KEY
argument_list|,
name|CAPI_R_GETUSERKEY_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
name|CryptReleaseContext
argument_list|(
name|key
operator|->
name|hprov
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|key
operator|->
name|keyspec
operator|=
name|keyspec
expr_stmt|;
name|key
operator|->
name|pcert
operator|=
name|NULL
expr_stmt|;
return|return
name|key
return|;
name|err
label|:
name|OPENSSL_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|CAPI_KEY
modifier|*
name|capi_get_cert_key
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|PCCERT_CONTEXT
name|cert
parameter_list|)
block|{
name|CAPI_KEY
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|CRYPT_KEY_PROV_INFO
modifier|*
name|pinfo
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|provname
init|=
name|NULL
decl_stmt|,
modifier|*
name|contname
init|=
name|NULL
decl_stmt|;
name|pinfo
operator|=
name|capi_get_prov_info
argument_list|(
name|ctx
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pinfo
condition|)
goto|goto
name|err
goto|;
name|provname
operator|=
name|wide_to_asc
argument_list|(
name|pinfo
operator|->
name|pwszProvName
argument_list|)
expr_stmt|;
name|contname
operator|=
name|wide_to_asc
argument_list|(
name|pinfo
operator|->
name|pwszContainerName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|provname
operator|||
operator|!
name|contname
condition|)
goto|goto
name|err
goto|;
name|key
operator|=
name|capi_get_key
argument_list|(
name|ctx
argument_list|,
name|contname
argument_list|,
name|provname
argument_list|,
name|pinfo
operator|->
name|dwProvType
argument_list|,
name|pinfo
operator|->
name|dwKeySpec
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
name|pinfo
condition|)
name|OPENSSL_free
argument_list|(
name|pinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|provname
condition|)
name|OPENSSL_free
argument_list|(
name|provname
argument_list|)
expr_stmt|;
if|if
condition|(
name|contname
condition|)
name|OPENSSL_free
argument_list|(
name|contname
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_function
name|CAPI_KEY
modifier|*
name|capi_find_key
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|PCCERT_CONTEXT
name|cert
decl_stmt|;
name|HCERTSTORE
name|hstore
decl_stmt|;
name|CAPI_KEY
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|lookup_method
condition|)
block|{
case|case
name|CAPI_LU_SUBSTR
case|:
case|case
name|CAPI_LU_FNAME
case|:
name|hstore
operator|=
name|capi_open_store
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hstore
condition|)
return|return
name|NULL
return|;
name|cert
operator|=
name|capi_find_cert
argument_list|(
name|ctx
argument_list|,
name|id
argument_list|,
name|hstore
argument_list|)
expr_stmt|;
if|if
condition|(
name|cert
condition|)
block|{
name|key
operator|=
name|capi_get_cert_key
argument_list|(
name|ctx
argument_list|,
name|cert
argument_list|)
expr_stmt|;
name|CertFreeCertificateContext
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
name|CertCloseStore
argument_list|(
name|hstore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPI_LU_CONTNAME
case|:
name|key
operator|=
name|capi_get_key
argument_list|(
name|ctx
argument_list|,
name|id
argument_list|,
name|ctx
operator|->
name|cspname
argument_list|,
name|ctx
operator|->
name|csptype
argument_list|,
name|ctx
operator|->
name|keytype
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|key
return|;
block|}
end_function

begin_function
name|void
name|capi_free_key
parameter_list|(
name|CAPI_KEY
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
operator|!
name|key
condition|)
return|return;
name|CryptDestroyKey
argument_list|(
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
name|CryptReleaseContext
argument_list|(
name|key
operator|->
name|hprov
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|pcert
condition|)
name|CertFreeCertificateContext
argument_list|(
name|key
operator|->
name|pcert
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a CAPI_CTX structure */
end_comment

begin_function
specifier|static
name|CAPI_CTX
modifier|*
name|capi_ctx_new
parameter_list|()
block|{
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|OPENSSL_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CAPI_CTX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_CTX_NEW
argument_list|,
name|ERR_R_MALLOC_FAILURE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|cspname
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|csptype
operator|=
name|PROV_RSA_FULL
expr_stmt|;
name|ctx
operator|->
name|dump_flags
operator|=
name|CAPI_DMP_SUMMARY
operator||
name|CAPI_DMP_FNAME
expr_stmt|;
name|ctx
operator|->
name|keytype
operator|=
name|AT_KEYEXCHANGE
expr_stmt|;
name|ctx
operator|->
name|storename
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|ssl_client_store
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|store_flags
operator|=
name|CERT_STORE_OPEN_EXISTING_FLAG
operator||
name|CERT_STORE_READONLY_FLAG
operator||
name|CERT_SYSTEM_STORE_CURRENT_USER
expr_stmt|;
name|ctx
operator|->
name|lookup_method
operator|=
name|CAPI_LU_SUBSTR
expr_stmt|;
name|ctx
operator|->
name|debug_level
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|debug_file
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|client_cert_select
operator|=
name|cert_select_simple
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|capi_ctx_free
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Calling capi_ctx_free with %lx\n"
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return;
if|if
condition|(
name|ctx
operator|->
name|cspname
condition|)
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|cspname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|debug_file
condition|)
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|debug_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|storename
condition|)
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|storename
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ssl_client_store
condition|)
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|ssl_client_store
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_ctx_set_provname
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|LPSTR
name|pname
parameter_list|,
name|DWORD
name|type
parameter_list|,
name|int
name|check
parameter_list|)
block|{
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"capi_ctx_set_provname, name=%s, type=%d\n"
argument_list|,
name|pname
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
condition|)
block|{
name|HCRYPTPROV
name|hprov
decl_stmt|;
if|if
condition|(
operator|!
name|CryptAcquireContextA
argument_list|(
operator|&
name|hprov
argument_list|,
name|NULL
argument_list|,
name|pname
argument_list|,
name|type
argument_list|,
name|CRYPT_VERIFYCONTEXT
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CAPI_CTX_SET_PROVNAME
argument_list|,
name|CAPI_R_CRYPTACQUIRECONTEXT_ERROR
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CryptReleaseContext
argument_list|(
name|hprov
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|cspname
condition|)
name|OPENSSL_free
argument_list|(
name|ctx
operator|->
name|cspname
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cspname
operator|=
name|BUF_strdup
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|csptype
operator|=
name|type
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capi_ctx_set_provname_idx
parameter_list|(
name|CAPI_CTX
modifier|*
name|ctx
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|LPSTR
name|pname
decl_stmt|;
name|DWORD
name|type
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|capi_get_provname
argument_list|(
name|ctx
argument_list|,
operator|&
name|pname
argument_list|,
operator|&
name|type
argument_list|,
name|idx
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|res
operator|=
name|capi_ctx_set_provname
argument_list|(
name|ctx
argument_list|,
name|pname
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|pname
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|cert_issuer_match
argument_list|(
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
argument_list|,
name|X509
operator|*
name|x
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|X509_NAME
modifier|*
name|nm
decl_stmt|;
comment|/* Special case: empty list: match anything */
if|if
condition|(
name|sk_X509_NAME_num
argument_list|(
name|ca_dn
argument_list|)
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_NAME_num
argument_list|(
name|ca_dn
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|nm
operator|=
name|sk_X509_NAME_value
argument_list|(
name|ca_dn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|X509_NAME_cmp
argument_list|(
name|nm
argument_list|,
name|X509_get_issuer_name
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|capi_load_ssl_client_cert
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509_NAME
argument_list|)
operator|*
name|ca_dn
argument_list|,
name|X509
operator|*
operator|*
name|pcert
argument_list|,
name|EVP_PKEY
operator|*
operator|*
name|pkey
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|pother
argument_list|,
name|UI_METHOD
operator|*
name|ui_method
argument_list|,
name|void
operator|*
name|callback_data
argument_list|)
block|{
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
operator|=
name|NULL
expr_stmt|;
name|X509
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|storename
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|client_cert_idx
decl_stmt|;
name|HCERTSTORE
name|hstore
decl_stmt|;
name|PCCERT_CONTEXT
name|cert
init|=
name|NULL
decl_stmt|,
name|excert
init|=
name|NULL
decl_stmt|;
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|CAPI_KEY
modifier|*
name|key
decl_stmt|;
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|e
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
operator|*
name|pcert
operator|=
name|NULL
expr_stmt|;
operator|*
name|pkey
operator|=
name|NULL
expr_stmt|;
name|storename
operator|=
name|ctx
operator|->
name|ssl_client_store
expr_stmt|;
if|if
condition|(
operator|!
name|storename
condition|)
name|storename
operator|=
literal|"MY"
expr_stmt|;
name|hstore
operator|=
name|capi_open_store
argument_list|(
name|ctx
argument_list|,
name|storename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hstore
condition|)
return|return
literal|0
return|;
comment|/* Enumerate all certificates collect any matches */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|cert
operator|=
name|CertEnumCertificatesInStore
argument_list|(
name|hstore
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cert
condition|)
break|break;
name|p
operator|=
name|cert
operator|->
name|pbCertEncoded
expr_stmt|;
name|x
operator|=
name|d2i_X509
argument_list|(
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
name|cert
operator|->
name|cbCertEncoded
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|CAPI_trace
argument_list|(
name|ctx
argument_list|,
literal|"Can't Parse Certificate %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cert_issuer_match
argument_list|(
name|ca_dn
argument_list|,
name|x
argument_list|)
operator|&&
name|X509_check_purpose
argument_list|(
name|x
argument_list|,
name|X509_PURPOSE_SSL_CLIENT
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|key
operator|=
name|capi_get_cert_key
argument_list|(
name|ctx
argument_list|,
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Match found: attach extra data to it so 			 * we can retrieve the key later. 			 */
name|excert
operator|=
name|CertDuplicateCertificateContext
argument_list|(
name|cert
argument_list|)
expr_stmt|;
name|key
operator|->
name|pcert
operator|=
name|excert
expr_stmt|;
name|X509_set_ex_data
argument_list|(
name|x
argument_list|,
name|cert_capi_idx
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|certs
condition|)
name|certs
operator|=
name|sk_X509_new_null
argument_list|()
expr_stmt|;
name|sk_X509_push
argument_list|(
name|certs
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cert
condition|)
name|CertFreeCertificateContext
argument_list|(
name|cert
argument_list|)
expr_stmt|;
if|if
condition|(
name|hstore
condition|)
name|CertCloseStore
argument_list|(
name|hstore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|certs
condition|)
return|return
literal|0
return|;
comment|/* Select the appropriate certificate */
name|client_cert_idx
operator|=
name|ctx
operator|->
name|client_cert_select
argument_list|(
name|e
argument_list|,
name|ssl
argument_list|,
name|certs
argument_list|)
expr_stmt|;
comment|/* Set the selected certificate and free the rest */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|certs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|client_cert_idx
condition|)
operator|*
name|pcert
operator|=
name|x
expr_stmt|;
else|else
block|{
name|key
operator|=
name|X509_get_ex_data
argument_list|(
name|x
argument_list|,
name|cert_capi_idx
argument_list|)
expr_stmt|;
name|capi_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|sk_X509_free
argument_list|(
name|certs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pcert
condition|)
return|return
literal|0
return|;
comment|/* Setup key for selected certificate */
name|key
operator|=
name|X509_get_ex_data
argument_list|(
operator|*
name|pcert
argument_list|,
name|cert_capi_idx
argument_list|)
expr_stmt|;
operator|*
name|pkey
operator|=
name|capi_get_pkey
argument_list|(
name|e
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|X509_set_ex_data
argument_list|(
operator|*
name|pcert
argument_list|,
name|cert_capi_idx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Simple client cert selection function: always select first */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cert_select_simple
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPENSSL_CAPIENG_DIALOG
end_ifdef

begin_comment
comment|/* More complex cert selection function, using standard function  * CryptUIDlgSelectCertificateFromStore() to produce a dialog box.  */
end_comment

begin_comment
comment|/* Definitions which are in cryptuiapi.h but this is not present in older  * versions of headers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CRYPTUI_SELECT_LOCATION_COLUMN
end_ifndef

begin_define
define|#
directive|define
name|CRYPTUI_SELECT_LOCATION_COLUMN
value|0x000000010
end_define

begin_define
define|#
directive|define
name|CRYPTUI_SELECT_INTENDEDUSE_COLUMN
value|0x000000004
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|dlg_title
value|L"OpenSSL Application SSL Client Certificate Selection"
end_define

begin_define
define|#
directive|define
name|dlg_prompt
value|L"Select a certificate to use for authentication"
end_define

begin_define
define|#
directive|define
name|dlg_columns
value|CRYPTUI_SELECT_LOCATION_COLUMN \ 			|CRYPTUI_SELECT_INTENDEDUSE_COLUMN
end_define

begin_decl_stmt
specifier|static
name|int
name|cert_select_dialog
argument_list|(
name|ENGINE
operator|*
name|e
argument_list|,
name|SSL
operator|*
name|ssl
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
argument_list|)
block|{
name|X509
modifier|*
name|x
decl_stmt|;
name|HCERTSTORE
name|dstore
decl_stmt|;
name|PCCERT_CONTEXT
name|cert
decl_stmt|;
name|CAPI_CTX
modifier|*
name|ctx
decl_stmt|;
name|CAPI_KEY
modifier|*
name|key
decl_stmt|;
name|HWND
name|hwnd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|sk_X509_num
argument_list|(
name|certs
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|0
return|;
name|ctx
operator|=
name|ENGINE_get_ex_data
argument_list|(
name|e
argument_list|,
name|capi_idx
argument_list|)
expr_stmt|;
comment|/* Create an in memory store of certificates */
name|dstore
operator|=
name|CertOpenStore
argument_list|(
name|CERT_STORE_PROV_MEMORY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CERT_STORE_CREATE_NEW_FLAG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dstore
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CERT_SELECT_DIALOG
argument_list|,
name|CAPI_R_ERROR_CREATING_STORE
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Add all certificates to store */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|certs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|key
operator|=
name|X509_get_ex_data
argument_list|(
name|x
argument_list|,
name|cert_capi_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CertAddCertificateContextToStore
argument_list|(
name|dstore
argument_list|,
name|key
operator|->
name|pcert
argument_list|,
name|CERT_STORE_ADD_NEW
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|CAPIerr
argument_list|(
name|CAPI_F_CERT_SELECT_DIALOG
argument_list|,
name|CAPI_R_ERROR_ADDING_CERT
argument_list|)
expr_stmt|;
name|capi_addlasterror
argument_list|()
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|hwnd
operator|=
name|GetForegroundWindow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hwnd
condition|)
name|hwnd
operator|=
name|GetActiveWindow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hwnd
operator|&&
name|ctx
operator|->
name|getconswindow
condition|)
name|hwnd
operator|=
name|ctx
operator|->
name|getconswindow
argument_list|()
expr_stmt|;
comment|/* Call dialog to select one */
name|cert
operator|=
name|ctx
operator|->
name|certselectdlg
argument_list|(
name|dstore
argument_list|,
name|hwnd
argument_list|,
name|dlg_title
argument_list|,
name|dlg_prompt
argument_list|,
name|dlg_columns
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find matching cert from list */
if|if
condition|(
name|cert
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|certs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|key
operator|=
name|X509_get_ex_data
argument_list|(
name|x
argument_list|,
name|cert_capi_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|CertCompareCertificate
argument_list|(
name|X509_ASN_ENCODING
operator||
name|PKCS_7_ASN_ENCODING
argument_list|,
name|cert
operator|->
name|pCertInfo
argument_list|,
name|key
operator|->
name|pcert
operator|->
name|pCertInfo
argument_list|)
condition|)
block|{
name|idx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
name|err
label|:
if|if
condition|(
name|dstore
condition|)
name|CertCloseStore
argument_list|(
name|dstore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|idx
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__COMPILE_CAPIENG */
end_comment

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_DYNAMIC_ENGINE
end_ifndef

begin_function_decl
name|OPENSSL_EXPORT
name|int
name|bind_engine
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|dynamic_fns
modifier|*
name|fns
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|OPENSSL_EXPORT
name|int
name|bind_engine
parameter_list|(
name|ENGINE
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
specifier|const
name|dynamic_fns
modifier|*
name|fns
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|IMPLEMENT_DYNAMIC_CHECK_FN
argument_list|()
end_macro

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|ENGINE_load_capi
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

