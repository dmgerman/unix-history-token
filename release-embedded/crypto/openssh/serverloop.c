begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $OpenBSD: serverloop.c,v 1.169 2013/12/19 00:19:12 dtucker Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Author: Tatu Ylonen<ylo@cs.hut.fi>  * Copyright (c) 1995 Tatu Ylonen<ylo@cs.hut.fi>, Espoo, Finland  *                    All rights reserved  * Server main loop for handling the interactive session.  *  * As far as I am concerned, the code I have written for this software  * can be used freely for any purpose.  Any derived versions of this  * software must be clearly marked as such, and if the derived work is  * incompatible with the protocol description in the RFC file, it must be  * called by a name other than "ssh" or "Secure Shell".  *  * SSH2 support by Markus Friedl.  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"openbsd-compat/sys-queue.h"
end_include

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_include
include|#
directive|include
file|"packet.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"servconf.h"
end_include

begin_include
include|#
directive|include
file|"canohost.h"
end_include

begin_include
include|#
directive|include
file|"sshpty.h"
end_include

begin_include
include|#
directive|include
file|"channels.h"
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|"ssh1.h"
end_include

begin_include
include|#
directive|include
file|"ssh2.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"cipher.h"
end_include

begin_include
include|#
directive|include
file|"kex.h"
end_include

begin_include
include|#
directive|include
file|"hostfile.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"session.h"
end_include

begin_include
include|#
directive|include
file|"dispatch.h"
end_include

begin_include
include|#
directive|include
file|"auth-options.h"
end_include

begin_include
include|#
directive|include
file|"serverloop.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"roaming.h"
end_include

begin_decl_stmt
specifier|extern
name|ServerOptions
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|extern
name|Kex
modifier|*
name|xxx_kex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Authctxt
modifier|*
name|the_authctxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|use_privsep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Buffer
name|stdin_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdin data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stdout_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stdout data. */
end_comment

begin_decl_stmt
specifier|static
name|Buffer
name|stderr_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for stderr data. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stdin (for writing) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stdout (for reading); 				   May be same number as fdin. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for stderr.  May be -1. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stdin_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes written to stdin. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stdout_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stdout bytes sent to client. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|stderr_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stderr bytes sent to client. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|fdout_bytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of stdout bytes read from program. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF message received from client. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdout_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF encountered reading from fdout. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fderr_eof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EOF encountered readung from fderr. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fdin_is_tty
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fdin points to a tty. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to client (input). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to client (output). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|connection_closed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Connection to client closed. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|buffer_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "Soft" max buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_more_sessions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disallow further sessions. */
end_comment

begin_comment
comment|/*  * This SIGCHLD kludge is used to detect when the child exits.  The server  * will exit after that, as soon as forwarded connections have terminated.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|child_terminated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The child has terminated. */
end_comment

begin_comment
comment|/* Cleanup on signals (!use_privsep case only) */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|received_sigterm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|server_init_dispatch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * we write to this pipe if a SIGCHLD is caught in order to avoid  * the race between select() and child_terminated  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|notify_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|notify_setup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|notify_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"pipe(notify_pipe) failed %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fcntl
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|fcntl
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"fcntl(notify_pipe, F_SETFD) failed %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_nonblock
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|notify_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* read end */
name|notify_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* write end */
block|}
end_function

begin_function
specifier|static
name|void
name|notify_parent
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|notify_pipe
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
name|notify_pipe
index|[
literal|1
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_prepare
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
if|if
condition|(
name|notify_pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
name|FD_SET
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
name|readset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_done
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|notify_pipe
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
name|readset
argument_list|)
condition|)
while|while
condition|(
name|read
argument_list|(
name|notify_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|debug2
argument_list|(
literal|"notify_done: reading"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|child_terminated
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|_UNICOS
name|mysignal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|notify_parent
argument_list|()
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sigterm_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|received_sigterm
operator|=
name|sig
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stderr data, and buffer it for sending  * to the client.  */
end_comment

begin_function
specifier|static
name|void
name|make_packets_from_stderr_data
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
comment|/* Send buffered stderr data to the client. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|512
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
block|}
name|packet_start
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stderr_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make packets from buffered stdout data, and buffer it for sending to the  * client.  */
end_comment

begin_function
specifier|static
name|void
name|make_packets_from_stdout_data
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
comment|/* Send buffered stdout data to the client. */
while|while
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|len
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|512
condition|)
name|len
operator|=
literal|512
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep the packets at reasonable size. */
if|if
condition|(
name|len
operator|>
name|packet_get_maxsize
argument_list|()
condition|)
name|len
operator|=
name|packet_get_maxsize
argument_list|()
expr_stmt|;
block|}
name|packet_start
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|buffer_consume
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|client_alive_check
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|channel_id
decl_stmt|;
comment|/* timeout, check to see how many we have had */
if|if
condition|(
name|packet_inc_alive_timeouts
argument_list|()
operator|>
name|options
operator|.
name|client_alive_count_max
condition|)
block|{
name|logit
argument_list|(
literal|"Timeout, client not responding."
argument_list|)
expr_stmt|;
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * send a bogus global/channel request with "wantreply", 	 * we should get back a failure 	 */
if|if
condition|(
operator|(
name|channel_id
operator|=
name|channel_find_open
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|"keepalive@openssh.com"
argument_list|)
expr_stmt|;
name|packet_put_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* boolean: want reply */
block|}
else|else
block|{
name|channel_request_start
argument_list|(
name|channel_id
argument_list|,
literal|"keepalive@openssh.com"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sleep in select() until we can do something.  This will initialize the  * select masks.  Upon return, the masks will indicate which descriptors  * have data or can accept data.  Optionally, a maximum time can be specified  * for the duration of the wait (0 = infinite).  */
end_comment

begin_function
specifier|static
name|void
name|wait_until_can_do_something
parameter_list|(
name|fd_set
modifier|*
modifier|*
name|readsetp
parameter_list|,
name|fd_set
modifier|*
modifier|*
name|writesetp
parameter_list|,
name|int
modifier|*
name|maxfdp
parameter_list|,
name|u_int
modifier|*
name|nallocp
parameter_list|,
name|u_int64_t
name|max_time_milliseconds
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|time_t
name|minwait_secs
init|=
literal|0
decl_stmt|;
name|int
name|client_alive_scheduled
init|=
literal|0
decl_stmt|;
name|int
name|program_alive_scheduled
init|=
literal|0
decl_stmt|;
comment|/* Allocate and update select() masks for channel descriptors. */
name|channel_prepare_select
argument_list|(
name|readsetp
argument_list|,
name|writesetp
argument_list|,
name|maxfdp
argument_list|,
name|nallocp
argument_list|,
operator|&
name|minwait_secs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|minwait_secs
operator|!=
literal|0
condition|)
name|max_time_milliseconds
operator|=
name|MIN
argument_list|(
name|max_time_milliseconds
argument_list|,
operator|(
name|u_int
operator|)
name|minwait_secs
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	 * if using client_alive, set the max timeout accordingly, 	 * and indicate that this particular timeout was for client 	 * alive by setting the client_alive_scheduled flag. 	 * 	 * this could be randomized somewhat to make traffic 	 * analysis more difficult, but we're not doing it yet. 	 */
if|if
condition|(
name|compat20
operator|&&
name|max_time_milliseconds
operator|==
literal|0
operator|&&
name|options
operator|.
name|client_alive_interval
condition|)
block|{
name|client_alive_scheduled
operator|=
literal|1
expr_stmt|;
name|max_time_milliseconds
operator|=
operator|(
name|u_int64_t
operator|)
name|options
operator|.
name|client_alive_interval
operator|*
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|compat20
condition|)
block|{
if|#
directive|if
literal|0
comment|/* wrong: bad condition XXX */
block|if (channel_not_very_much_buffered_data())
endif|#
directive|endif
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Read packets from the client unless we have too much 		 * buffered stdin or channel data. 		 */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|<
name|buffer_high
operator|&&
name|channel_not_very_much_buffered_data
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_in
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* 		 * If there is not too much data already buffered going to 		 * the client, try to get some more data from the program. 		 */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
block|{
name|program_alive_scheduled
operator|=
name|child_terminated
expr_stmt|;
if|if
condition|(
operator|!
name|fdout_eof
condition|)
name|FD_SET
argument_list|(
name|fdout
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fderr_eof
condition|)
name|FD_SET
argument_list|(
name|fderr
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we have buffered data, try to write some of that data 		 * to the program. 		 */
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|>
literal|0
condition|)
name|FD_SET
argument_list|(
name|fdin
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
block|}
name|notify_prepare
argument_list|(
operator|*
name|readsetp
argument_list|)
expr_stmt|;
comment|/* 	 * If we have buffered packet data going to the client, mark that 	 * descriptor. 	 */
if|if
condition|(
name|packet_have_data_to_write
argument_list|()
condition|)
name|FD_SET
argument_list|(
name|connection_out
argument_list|,
operator|*
name|writesetp
argument_list|)
expr_stmt|;
comment|/* 	 * If child has terminated and there is enough buffer space to read 	 * from it, then read as much as is available and exit. 	 */
if|if
condition|(
name|child_terminated
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
if|if
condition|(
name|max_time_milliseconds
operator|==
literal|0
operator|||
name|client_alive_scheduled
condition|)
name|max_time_milliseconds
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|max_time_milliseconds
operator|==
literal|0
condition|)
name|tvp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|max_time_milliseconds
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|1000
operator|*
operator|(
name|max_time_milliseconds
operator|%
literal|1000
operator|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|tv
expr_stmt|;
block|}
comment|/* Wait for something to happen, or the timeout to expire. */
name|ret
operator|=
name|select
argument_list|(
operator|(
operator|*
name|maxfdp
operator|)
operator|+
literal|1
argument_list|,
operator|*
name|readsetp
argument_list|,
operator|*
name|writesetp
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|*
name|readsetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|writesetp
argument_list|,
literal|0
argument_list|,
operator|*
name|nallocp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|error
argument_list|(
literal|"select: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|client_alive_scheduled
condition|)
name|client_alive_check
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|compat20
operator|&&
name|program_alive_scheduled
operator|&&
name|fdin_is_tty
condition|)
block|{
if|if
condition|(
operator|!
name|fdout_eof
condition|)
name|FD_SET
argument_list|(
name|fdout
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fderr_eof
condition|)
name|FD_SET
argument_list|(
name|fderr
argument_list|,
operator|*
name|readsetp
argument_list|)
expr_stmt|;
block|}
block|}
name|notify_done
argument_list|(
operator|*
name|readsetp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Processes input from the client and the program.  Input data is stored  * in buffers and processed later.  */
end_comment

begin_function
specifier|static
name|void
name|process_input
parameter_list|(
name|fd_set
modifier|*
name|readset
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
literal|16384
index|]
decl_stmt|;
comment|/* Read and buffer any input data from the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_in
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|int
name|cont
init|=
literal|0
decl_stmt|;
name|len
operator|=
name|roaming_read
argument_list|(
name|connection_in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|cont
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cont
condition|)
return|return;
name|verbose
argument_list|(
literal|"Connection closed by %.100s"
argument_list|,
name|get_remote_ipaddr
argument_list|()
argument_list|)
expr_stmt|;
name|connection_closed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compat20
condition|)
return|return;
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
operator|&&
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|verbose
argument_list|(
literal|"Read error from remote host "
literal|"%.100s: %.100s"
argument_list|,
name|get_remote_ipaddr
argument_list|()
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Buffer any received data. */
name|packet_process_incoming
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|compat20
condition|)
return|return;
comment|/* Read and buffer any available stdout data from the program. */
if|if
condition|(
operator|!
name|fdout_eof
operator|&&
name|FD_ISSET
argument_list|(
name|fdout
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fdout
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
operator|(
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|!
name|child_terminated
operator|)
operator|)
condition|)
block|{
comment|/* do nothing */
ifndef|#
directive|ifndef
name|PTY_ZEROREAD
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
else|#
directive|else
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|isatty
argument_list|(
name|fdout
argument_list|)
operator|&&
name|len
operator|<=
literal|0
operator|)
operator|||
operator|(
name|isatty
argument_list|(
name|fdout
argument_list|)
operator|&&
operator|(
name|len
operator|<
literal|0
operator|||
operator|(
name|len
operator|==
literal|0
operator|&&
name|errno
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|fdout_eof
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|stdout_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fdout_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Read and buffer any available stderr data from the program. */
if|if
condition|(
operator|!
name|fderr_eof
operator|&&
name|FD_ISSET
argument_list|(
name|fderr
argument_list|,
name|readset
argument_list|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fderr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
operator|(
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
operator|&&
operator|!
name|child_terminated
operator|)
operator|)
condition|)
block|{
comment|/* do nothing */
ifndef|#
directive|ifndef
name|PTY_ZEROREAD
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
else|#
directive|else
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|isatty
argument_list|(
name|fderr
argument_list|)
operator|&&
name|len
operator|<=
literal|0
operator|)
operator|||
operator|(
name|isatty
argument_list|(
name|fderr
argument_list|)
operator|&&
operator|(
name|len
operator|<
literal|0
operator|||
operator|(
name|len
operator|==
literal|0
operator|&&
name|errno
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|fderr_eof
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Sends data from internal buffers to client program stdin.  */
end_comment

begin_function
specifier|static
name|void
name|process_output
parameter_list|(
name|fd_set
modifier|*
name|writeset
parameter_list|)
block|{
name|struct
name|termios
name|tio
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Write buffered data to program stdin. */
if|if
condition|(
operator|!
name|compat20
operator|&&
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|fdin
argument_list|,
name|writeset
argument_list|)
condition|)
block|{
name|data
operator|=
name|buffer_ptr
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|fdin
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
operator|)
condition|)
block|{
comment|/* do nothing */
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|fdin
operator|!=
name|fdout
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|else
name|shutdown
argument_list|(
name|fdin
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
comment|/* We will no longer send. */
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Successful write. */
if|if
condition|(
name|fdin_is_tty
operator|&&
name|dlen
operator|>=
literal|1
operator|&&
name|data
index|[
literal|0
index|]
operator|!=
literal|'\r'
operator|&&
name|tcgetattr
argument_list|(
name|fdin
argument_list|,
operator|&
name|tio
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|&&
operator|(
name|tio
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
condition|)
block|{
comment|/* 				 * Simulate echo to reduce the impact of 				 * traffic analysis 				 */
name|packet_send_ignore
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
comment|/* Consume the data from the buffer. */
name|buffer_consume
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Update the count of bytes written to the program. */
name|stdin_bytes
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Send any buffered packet data to the client. */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|connection_out
argument_list|,
name|writeset
argument_list|)
condition|)
name|packet_write_poll
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait until all buffered output has been sent to the client.  * This is used when the program terminates.  */
end_comment

begin_function
specifier|static
name|void
name|drain_output
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Send any buffered stdout data to the client. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_STDOUT_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Update the count of sent bytes. */
name|stdout_bytes
operator|+=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Send any buffered stderr data to the client. */
if|if
condition|(
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|packet_start
argument_list|(
name|SSH_SMSG_STDERR_DATA
argument_list|)
expr_stmt|;
name|packet_put_string
argument_list|(
name|buffer_ptr
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|,
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
comment|/* Update the count of sent bytes. */
name|stderr_bytes
operator|+=
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Wait until all buffered data has been written to the client. */
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_buffered_input_packets
parameter_list|(
name|void
parameter_list|)
block|{
name|dispatch_run
argument_list|(
name|DISPATCH_NONBLOCK
argument_list|,
name|NULL
argument_list|,
name|compat20
condition|?
name|xxx_kex
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs the interactive session.  This handles data transmission between  * the client and the program.  Note that the notion of stdin, stdout, and  * stderr in this function is sort of reversed: this function writes to  * stdin (of the child program), and reads from stdout and stderr (of the  * child program).  */
end_comment

begin_function
name|void
name|server_loop
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|int
name|fdin_arg
parameter_list|,
name|int
name|fdout_arg
parameter_list|,
name|int
name|fderr_arg
parameter_list|)
block|{
name|fd_set
modifier|*
name|readset
init|=
name|NULL
decl_stmt|,
modifier|*
name|writeset
init|=
name|NULL
decl_stmt|;
name|int
name|max_fd
init|=
literal|0
decl_stmt|;
name|u_int
name|nalloc
init|=
literal|0
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
comment|/* Status returned by wait(). */
name|pid_t
name|wait_pid
decl_stmt|;
comment|/* pid returned by wait(). */
name|int
name|waiting_termination
init|=
literal|0
decl_stmt|;
comment|/* Have displayed waiting close message. */
name|u_int64_t
name|max_time_milliseconds
decl_stmt|;
name|u_int
name|previous_stdout_buffer_bytes
decl_stmt|;
name|u_int
name|stdout_buffer_bytes
decl_stmt|;
name|int
name|type
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session."
argument_list|)
expr_stmt|;
comment|/* Initialize the SIGCHLD kludge. */
name|child_terminated
operator|=
literal|0
expr_stmt|;
name|mysignal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize our global variables. */
name|fdin
operator|=
name|fdin_arg
expr_stmt|;
name|fdout
operator|=
name|fdout_arg
expr_stmt|;
name|fderr
operator|=
name|fderr_arg
expr_stmt|;
comment|/* nonblocking IO */
name|set_nonblock
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|fdout
argument_list|)
expr_stmt|;
comment|/* we don't have stderr for interactive terminal sessions, see below */
if|if
condition|(
name|fderr
operator|!=
operator|-
literal|1
condition|)
name|set_nonblock
argument_list|(
name|fderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_IGNOREMSG
operator|)
operator|&&
name|isatty
argument_list|(
name|fdin
argument_list|)
condition|)
name|fdin_is_tty
operator|=
literal|1
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
name|notify_setup
argument_list|()
expr_stmt|;
name|previous_stdout_buffer_bytes
operator|=
literal|0
expr_stmt|;
comment|/* Set approximate I/O buffer size. */
if|if
condition|(
name|packet_is_interactive
argument_list|()
condition|)
name|buffer_high
operator|=
literal|4096
expr_stmt|;
else|else
name|buffer_high
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Initialize max_fd to the maximum of the known file descriptors. */
block|max_fd = MAX(connection_in, connection_out); 	max_fd = MAX(max_fd, fdin); 	max_fd = MAX(max_fd, fdout); 	if (fderr != -1) 		max_fd = MAX(max_fd, fderr);
endif|#
directive|endif
comment|/* Initialize Initialize buffers. */
name|buffer_init
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_init
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* 	 * If we have no separate fderr (which is the case when we have a pty 	 * - there we cannot make difference between data sent to stdout and 	 * stderr), indicate that we have seen an EOF from stderr.  This way 	 * we don't need to check the descriptor everywhere. 	 */
if|if
condition|(
name|fderr
operator|==
operator|-
literal|1
condition|)
name|fderr_eof
operator|=
literal|1
expr_stmt|;
name|server_init_dispatch
argument_list|()
expr_stmt|;
comment|/* Main loop of the server for the interactive session mode. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Process buffered packets from the client. */
name|process_buffered_input_packets
argument_list|()
expr_stmt|;
comment|/* 		 * If we have received eof, and there is no more pending 		 * input data, cause a real eof by closing fdin. 		 */
if|if
condition|(
name|stdin_eof
operator|&&
name|fdin
operator|!=
operator|-
literal|1
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fdin
operator|!=
name|fdout
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
else|else
name|shutdown
argument_list|(
name|fdin
argument_list|,
name|SHUT_WR
argument_list|)
expr_stmt|;
comment|/* We will no longer send. */
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make packets from buffered stderr data to send to the client. */
name|make_packets_from_stderr_data
argument_list|()
expr_stmt|;
comment|/* 		 * Make packets from buffered stdout data to send to the 		 * client. If there is very little to send, this arranges to 		 * not send them now, but to wait a short while to see if we 		 * are getting more data. This is necessary, as some systems 		 * wake up readers from a pty after each separate character. 		 */
name|max_time_milliseconds
operator|=
literal|0
expr_stmt|;
name|stdout_buffer_bytes
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_buffer_bytes
operator|!=
literal|0
operator|&&
name|stdout_buffer_bytes
operator|<
literal|256
operator|&&
name|stdout_buffer_bytes
operator|!=
name|previous_stdout_buffer_bytes
condition|)
block|{
comment|/* try again after a while */
name|max_time_milliseconds
operator|=
literal|10
expr_stmt|;
block|}
else|else
block|{
comment|/* Send it now. */
name|make_packets_from_stdout_data
argument_list|()
expr_stmt|;
block|}
name|previous_stdout_buffer_bytes
operator|=
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
comment|/* Send channel data to the client. */
if|if
condition|(
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
comment|/* 		 * Bail out of the loop if the program has closed its output 		 * descriptors, and we have no more data to send to the 		 * client, and there is no pending buffered data. 		 */
if|if
condition|(
name|fdout_eof
operator|&&
name|fderr_eof
operator|&&
operator|!
name|packet_have_data_to_write
argument_list|()
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
operator|==
literal|0
operator|&&
name|buffer_len
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|channel_still_open
argument_list|()
condition|)
break|break;
if|if
condition|(
operator|!
name|waiting_termination
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
literal|"Waiting for forwarded connections to terminate...\r\n"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|waiting_termination
operator|=
literal|1
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Display list of open channels. */
name|cp
operator|=
name|channel_open_message
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stderr_buffer
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|max_fd
operator|=
name|MAX
argument_list|(
name|connection_in
argument_list|,
name|connection_out
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|fdin
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|fdout
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|fderr
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|notify_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Sleep in select() until we can do something. */
name|wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
operator|&
name|max_fd
argument_list|,
operator|&
name|nalloc
argument_list|,
name|max_time_milliseconds
argument_list|)
expr_stmt|;
if|if
condition|(
name|received_sigterm
condition|)
block|{
name|logit
argument_list|(
literal|"Exiting on signal %d"
argument_list|,
operator|(
name|int
operator|)
name|received_sigterm
argument_list|)
expr_stmt|;
comment|/* Clean up sessions, utmp, etc. */
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
comment|/* Process any channel events. */
name|channel_after_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
comment|/* Process input from the client and from program stdout/stderr. */
name|process_input
argument_list|(
name|readset
argument_list|)
expr_stmt|;
comment|/* Process output to the client and to program stdin. */
name|process_output
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
comment|/* Cleanup and termination code. */
comment|/* Wait until all output has been sent to the client. */
name|drain_output
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"End of interactive session; stdin %ld, stdout (read %ld, sent %ld), stderr %ld bytes."
argument_list|,
name|stdin_bytes
argument_list|,
name|fdout_bytes
argument_list|,
name|stdout_bytes
argument_list|,
name|stderr_bytes
argument_list|)
expr_stmt|;
comment|/* Free and clear the buffers. */
name|buffer_free
argument_list|(
operator|&
name|stdin_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stdout_buffer
argument_list|)
expr_stmt|;
name|buffer_free
argument_list|(
operator|&
name|stderr_buffer
argument_list|)
expr_stmt|;
comment|/* Close the file descriptors. */
if|if
condition|(
name|fdout
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdout
argument_list|)
expr_stmt|;
name|fdout
operator|=
operator|-
literal|1
expr_stmt|;
name|fdout_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fderr
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fderr
argument_list|)
expr_stmt|;
name|fderr
operator|=
operator|-
literal|1
expr_stmt|;
name|fderr_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fdin
argument_list|)
expr_stmt|;
name|fdin
operator|=
operator|-
literal|1
expr_stmt|;
name|channel_free_all
argument_list|()
expr_stmt|;
comment|/* We no longer want our SIGCHLD handler to be called. */
name|mysignal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wait_pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|packet_disconnect
argument_list|(
literal|"wait: %.100s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_pid
operator|!=
name|pid
condition|)
name|error
argument_list|(
literal|"Strange, wait returned pid %ld, expected %ld"
argument_list|,
operator|(
name|long
operator|)
name|wait_pid
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
comment|/* Check if it exited normally. */
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
comment|/* Yes, normal exit.  Get exit status and send it to the client. */
name|debug
argument_list|(
literal|"Command exited with status %d."
argument_list|,
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH_SMSG_EXITSTATUS
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
comment|/* 		 * Wait for exit confirmation.  Note that there might be 		 * other packets coming before it; however, the program has 		 * already died so we just ignore them.  The client is 		 * supposed to respond with the confirmation when it receives 		 * the exit status. 		 */
do|do
block|{
name|type
operator|=
name|packet_read
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|type
operator|!=
name|SSH_CMSG_EXIT_CONFIRMATION
condition|)
do|;
name|debug
argument_list|(
literal|"Received exit confirmation."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if the program terminated due to a signal. */
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
name|packet_disconnect
argument_list|(
literal|"Command terminated on signal %d."
argument_list|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some weird exit cause.  Just exit. */
name|packet_disconnect
argument_list|(
literal|"wait returned status %04x."
argument_list|,
name|wait_status
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|collect_children
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|sigset_t
name|oset
decl_stmt|,
name|nset
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* block SIGCHLD while we check for dead children */
name|sigemptyset
argument_list|(
operator|&
name|nset
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|nset
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|nset
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_terminated
condition|)
block|{
name|debug
argument_list|(
literal|"Received SIGCHLD."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|0
operator|||
operator|(
name|pid
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
operator|)
condition|)
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
name|session_close_by_pid
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
block|}
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_loop2
parameter_list|(
name|Authctxt
modifier|*
name|authctxt
parameter_list|)
block|{
name|fd_set
modifier|*
name|readset
init|=
name|NULL
decl_stmt|,
modifier|*
name|writeset
init|=
name|NULL
decl_stmt|;
name|int
name|rekeying
init|=
literal|0
decl_stmt|,
name|max_fd
decl_stmt|;
name|u_int
name|nalloc
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|rekey_timeout_ms
init|=
literal|0
decl_stmt|;
name|debug
argument_list|(
literal|"Entering interactive session for SSH2."
argument_list|)
expr_stmt|;
name|mysignal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
name|child_terminated
operator|=
literal|0
expr_stmt|;
name|connection_in
operator|=
name|packet_get_connection_in
argument_list|()
expr_stmt|;
name|connection_out
operator|=
name|packet_get_connection_out
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|use_privsep
condition|)
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigterm_handler
argument_list|)
expr_stmt|;
block|}
name|notify_setup
argument_list|()
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|connection_in
argument_list|,
name|connection_out
argument_list|)
expr_stmt|;
name|max_fd
operator|=
name|MAX
argument_list|(
name|max_fd
argument_list|,
name|notify_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|server_init_dispatch
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|process_buffered_input_packets
argument_list|()
expr_stmt|;
name|rekeying
operator|=
operator|(
name|xxx_kex
operator|!=
name|NULL
operator|&&
operator|!
name|xxx_kex
operator|->
name|done
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|rekeying
operator|&&
name|packet_not_very_much_data_to_write
argument_list|()
condition|)
name|channel_output_poll
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|rekey_interval
operator|>
literal|0
operator|&&
name|compat20
operator|&&
operator|!
name|rekeying
condition|)
name|rekey_timeout_ms
operator|=
name|packet_get_rekey_timeout
argument_list|()
operator|*
literal|1000
expr_stmt|;
else|else
name|rekey_timeout_ms
operator|=
literal|0
expr_stmt|;
name|wait_until_can_do_something
argument_list|(
operator|&
name|readset
argument_list|,
operator|&
name|writeset
argument_list|,
operator|&
name|max_fd
argument_list|,
operator|&
name|nalloc
argument_list|,
name|rekey_timeout_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|received_sigterm
condition|)
block|{
name|logit
argument_list|(
literal|"Exiting on signal %d"
argument_list|,
operator|(
name|int
operator|)
name|received_sigterm
argument_list|)
expr_stmt|;
comment|/* Clean up sessions, utmp, etc. */
name|cleanup_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
name|collect_children
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|rekeying
condition|)
block|{
name|channel_after_select
argument_list|(
name|readset
argument_list|,
name|writeset
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_need_rekeying
argument_list|()
condition|)
block|{
name|debug
argument_list|(
literal|"need rekeying"
argument_list|)
expr_stmt|;
name|xxx_kex
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|kex_send_kexinit
argument_list|(
name|xxx_kex
argument_list|)
expr_stmt|;
block|}
block|}
name|process_input
argument_list|(
name|readset
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection_closed
condition|)
break|break;
name|process_output
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
block|}
name|collect_children
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|readset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|writeset
argument_list|)
expr_stmt|;
comment|/* free all channels, no more reads and writes */
name|channel_free_all
argument_list|()
expr_stmt|;
comment|/* free remaining sessions, e.g. remove wtmp entries */
name|session_destroy_all
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_input_keep_alive
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|debug
argument_list|(
literal|"Got %d/%u for keepalive"
argument_list|,
name|type
argument_list|,
name|seq
argument_list|)
expr_stmt|;
comment|/* 	 * reset timeout, since we got a sane answer from the client. 	 * even if this was generated by something other than 	 * the bogus CHANNEL_REQUEST we send for keepalives. 	 */
name|packet_set_alive_timeouts
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_input_stdin_data
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|data_len
decl_stmt|;
comment|/* Stdin data from the client.  Append it to the buffer. */
comment|/* Ignore any data if the client has closed stdin. */
if|if
condition|(
name|fdin
operator|==
operator|-
literal|1
condition|)
return|return;
name|data
operator|=
name|packet_get_string
argument_list|(
operator|&
name|data_len
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|buffer_append
argument_list|(
operator|&
name|stdin_buffer
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_input_eof
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
comment|/* 	 * Eof from the client.  The stdin descriptor to the 	 * program will be closed when all buffered data has 	 * drained. 	 */
name|debug
argument_list|(
literal|"EOF received for stdin."
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|stdin_eof
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_input_window_size
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|u_int
name|row
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|u_int
name|col
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|u_int
name|xpixel
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|u_int
name|ypixel
init|=
name|packet_get_int
argument_list|()
decl_stmt|;
name|debug
argument_list|(
literal|"Window change received."
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|fdin
operator|!=
operator|-
literal|1
condition|)
name|pty_change_window_size
argument_list|(
name|fdin
argument_list|,
name|row
argument_list|,
name|col
argument_list|,
name|xpixel
argument_list|,
name|ypixel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|server_request_direct_tcpip
parameter_list|(
name|void
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|,
modifier|*
name|originator
decl_stmt|;
name|u_short
name|target_port
decl_stmt|,
name|originator_port
decl_stmt|;
name|target
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|target_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|originator
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|originator_port
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_request_direct_tcpip: originator %s port %d, target %s "
literal|"port %d"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|,
name|target
argument_list|,
name|target_port
argument_list|)
expr_stmt|;
comment|/* XXX fine grained permissions */
if|if
condition|(
operator|(
name|options
operator|.
name|allow_tcp_forwarding
operator|&
name|FORWARD_LOCAL
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|no_port_forwarding_flag
condition|)
block|{
name|c
operator|=
name|channel_connect_to
argument_list|(
name|target
argument_list|,
name|target_port
argument_list|,
literal|"direct-tcpip"
argument_list|,
literal|"direct-tcpip"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logit
argument_list|(
literal|"refused local port forward: "
literal|"originator %s port %d, target %s port %d"
argument_list|,
name|originator
argument_list|,
name|originator_port
argument_list|,
name|target
argument_list|,
name|target_port
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|originator
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|server_request_tun
parameter_list|(
name|void
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|tun
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|mode
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SSH_TUNMODE_POINTOPOINT
case|:
case|case
name|SSH_TUNMODE_ETHERNET
case|:
break|break;
default|default:
name|packet_send_debug
argument_list|(
literal|"Unsupported tunnel device mode."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|options
operator|.
name|permit_tun
operator|&
name|mode
operator|)
operator|==
literal|0
condition|)
block|{
name|packet_send_debug
argument_list|(
literal|"Server has rejected tunnel device "
literal|"forwarding"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tun
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
if|if
condition|(
name|forced_tun_device
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tun
operator|!=
name|SSH_TUNID_ANY
operator|&&
name|forced_tun_device
operator|!=
name|tun
condition|)
goto|goto
name|done
goto|;
name|tun
operator|=
name|forced_tun_device
expr_stmt|;
block|}
name|sock
operator|=
name|tun_open
argument_list|(
name|tun
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|options
operator|.
name|hpn_disabled
condition|)
name|c
operator|=
name|channel_new
argument_list|(
literal|"tun"
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|CHAN_TCP_WINDOW_DEFAULT
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"tun"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|channel_new
argument_list|(
literal|"tun"
argument_list|,
name|SSH_CHANNEL_OPEN
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
operator|-
literal|1
argument_list|,
name|options
operator|.
name|hpn_buffer_size
argument_list|,
name|CHAN_TCP_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"tun"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|datagram
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SSH_TUN_FILTER
argument_list|)
if|if
condition|(
name|mode
operator|==
name|SSH_TUNMODE_POINTOPOINT
condition|)
name|channel_register_filter
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|sys_tun_infilter
argument_list|,
name|sys_tun_outfilter
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
label|:
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|packet_send_debug
argument_list|(
literal|"Failed to open the tunnel device."
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|Channel
modifier|*
name|server_request_session
parameter_list|(
name|void
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|debug
argument_list|(
literal|"input_session_request"
argument_list|)
expr_stmt|;
name|packet_check_eom
argument_list|()
expr_stmt|;
if|if
condition|(
name|no_more_sessions
condition|)
block|{
name|packet_disconnect
argument_list|(
literal|"Possible attack: attempt to open a session "
literal|"after additional sessions disabled"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A server session has no fd to read or write until a 	 * CHANNEL_REQUEST for a shell is made, so we set the type to 	 * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all 	 * CHANNEL_REQUEST messages is registered. 	 */
name|c
operator|=
name|channel_new
argument_list|(
literal|"session"
argument_list|,
name|SSH_CHANNEL_LARVAL
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
comment|/*window size*/
literal|0
argument_list|,
name|CHAN_SES_PACKET_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|"server-session"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|hpn_disabled
operator|&&
name|options
operator|.
name|tcp_rcv_buf_poll
condition|)
name|c
operator|->
name|dynamic_window
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|session_open
argument_list|(
name|the_authctxt
argument_list|,
name|c
operator|->
name|self
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|debug
argument_list|(
literal|"session open failed, free channel %d"
argument_list|,
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|channel_free
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|channel_register_cleanup
argument_list|(
name|c
operator|->
name|self
argument_list|,
name|session_close_by_channel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_input_channel_open
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ctype
decl_stmt|;
name|int
name|rchan
decl_stmt|;
name|u_int
name|rmaxpack
decl_stmt|,
name|rwindow
decl_stmt|,
name|len
decl_stmt|;
name|ctype
operator|=
name|packet_get_string
argument_list|(
operator|&
name|len
argument_list|)
expr_stmt|;
name|rchan
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rwindow
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rmaxpack
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_channel_open: ctype %s rchan %d win %d max %d"
argument_list|,
name|ctype
argument_list|,
name|rchan
argument_list|,
name|rwindow
argument_list|,
name|rmaxpack
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"session"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|server_request_session
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"direct-tcpip"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|server_request_direct_tcpip
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ctype
argument_list|,
literal|"tun@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|server_request_tun
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"server_input_channel_open: confirm %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|c
operator|->
name|remote_id
operator|=
name|rchan
expr_stmt|;
name|c
operator|->
name|remote_window
operator|=
name|rwindow
expr_stmt|;
name|c
operator|->
name|remote_maxpacket
operator|=
name|rmaxpack
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|!=
name|SSH_CHANNEL_CONNECTING
condition|)
block|{
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|self
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_window
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|local_maxpacket
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|debug
argument_list|(
literal|"server_input_channel_open: failure %s"
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|packet_start
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|rchan
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|datafellows
operator|&
name|SSH_BUG_OPENFAILURE
operator|)
condition|)
block|{
name|packet_put_cstring
argument_list|(
literal|"open failed"
argument_list|)
expr_stmt|;
name|packet_put_cstring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_input_global_request
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|rtype
decl_stmt|;
name|int
name|want_reply
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|,
name|allocated_listen_port
init|=
literal|0
decl_stmt|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|want_reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_global_request: rtype %s want_reply %d"
argument_list|,
name|rtype
argument_list|,
name|want_reply
argument_list|)
expr_stmt|;
comment|/* -R style forwarding */
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"tcpip-forward"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|listen_address
decl_stmt|;
name|u_short
name|listen_port
decl_stmt|;
name|pw
operator|=
name|the_authctxt
operator|->
name|pw
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
operator|||
operator|!
name|the_authctxt
operator|->
name|valid
condition|)
name|fatal
argument_list|(
literal|"server_input_global_request: no/invalid user"
argument_list|)
expr_stmt|;
name|listen_address
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|listen_port
operator|=
operator|(
name|u_short
operator|)
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_global_request: tcpip-forward listen %s port %d"
argument_list|,
name|listen_address
argument_list|,
name|listen_port
argument_list|)
expr_stmt|;
comment|/* check permissions */
if|if
condition|(
operator|(
name|options
operator|.
name|allow_tcp_forwarding
operator|&
name|FORWARD_REMOTE
operator|)
operator|==
literal|0
operator|||
name|no_port_forwarding_flag
operator|||
operator|(
operator|!
name|want_reply
operator|&&
name|listen_port
operator|==
literal|0
operator|)
ifndef|#
directive|ifndef
name|NO_IPPORT_RESERVED_CONCEPT
operator|||
operator|(
name|listen_port
operator|!=
literal|0
operator|&&
name|listen_port
operator|<
name|IPPORT_RESERVED
operator|&&
name|pw
operator|->
name|pw_uid
operator|!=
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
name|packet_send_debug
argument_list|(
literal|"Server has disabled port forwarding."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Start listening on the port */
name|success
operator|=
name|channel_setup_remote_fwd_listener
argument_list|(
name|listen_address
argument_list|,
name|listen_port
argument_list|,
operator|&
name|allocated_listen_port
argument_list|,
name|options
operator|.
name|gateway_ports
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|listen_address
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"cancel-tcpip-forward"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cancel_address
decl_stmt|;
name|u_short
name|cancel_port
decl_stmt|;
name|cancel_address
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cancel_port
operator|=
operator|(
name|u_short
operator|)
name|packet_get_int
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"%s: cancel-tcpip-forward addr %s port %d"
argument_list|,
name|__func__
argument_list|,
name|cancel_address
argument_list|,
name|cancel_port
argument_list|)
expr_stmt|;
name|success
operator|=
name|channel_cancel_rport_listener
argument_list|(
name|cancel_address
argument_list|,
name|cancel_port
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cancel_address
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"no-more-sessions@openssh.com"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|no_more_sessions
operator|=
literal|1
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|want_reply
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_REQUEST_SUCCESS
else|:
name|SSH2_MSG_REQUEST_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
name|allocated_listen_port
operator|>
literal|0
condition|)
name|packet_put_int
argument_list|(
name|allocated_listen_port
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
name|packet_write_wait
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_input_channel_req
parameter_list|(
name|int
name|type
parameter_list|,
name|u_int32_t
name|seq
parameter_list|,
name|void
modifier|*
name|ctxt
parameter_list|)
block|{
name|Channel
modifier|*
name|c
decl_stmt|;
name|int
name|id
decl_stmt|,
name|reply
decl_stmt|,
name|success
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|rtype
decl_stmt|;
name|id
operator|=
name|packet_get_int
argument_list|()
expr_stmt|;
name|rtype
operator|=
name|packet_get_string
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|reply
operator|=
name|packet_get_char
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_input_channel_req: channel %d request %s reply %d"
argument_list|,
name|id
argument_list|,
name|rtype
argument_list|,
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|channel_lookup
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|packet_disconnect
argument_list|(
literal|"server_input_channel_req: "
literal|"unknown channel %d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"eow@openssh.com"
argument_list|)
condition|)
block|{
name|packet_check_eom
argument_list|()
expr_stmt|;
name|chan_rcvd_eow
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_LARVAL
operator|||
name|c
operator|->
name|type
operator|==
name|SSH_CHANNEL_OPEN
operator|)
operator|&&
name|strcmp
argument_list|(
name|c
operator|->
name|ctype
argument_list|,
literal|"session"
argument_list|)
operator|==
literal|0
condition|)
name|success
operator|=
name|session_input_channel_req
argument_list|(
name|c
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|packet_start
argument_list|(
name|success
condition|?
name|SSH2_MSG_CHANNEL_SUCCESS
else|:
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|)
expr_stmt|;
name|packet_put_int
argument_list|(
name|c
operator|->
name|remote_id
argument_list|)
expr_stmt|;
name|packet_send
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_init_dispatch_20
parameter_list|(
name|void
parameter_list|)
block|{
name|debug
argument_list|(
literal|"server_init_dispatch_20"
argument_list|)
expr_stmt|;
name|dispatch_init
argument_list|(
operator|&
name|dispatch_protocol_error
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EOF
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_EXTENDED_DATA
argument_list|,
operator|&
name|channel_input_extended_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN
argument_list|,
operator|&
name|server_input_channel_open
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_REQUEST
argument_list|,
operator|&
name|server_input_channel_req
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_WINDOW_ADJUST
argument_list|,
operator|&
name|channel_input_window_adjust
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_GLOBAL_REQUEST
argument_list|,
operator|&
name|server_input_global_request
argument_list|)
expr_stmt|;
comment|/* client_alive */
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_SUCCESS
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_CHANNEL_FAILURE
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_SUCCESS
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH2_MSG_REQUEST_FAILURE
argument_list|,
operator|&
name|server_input_keep_alive
argument_list|)
expr_stmt|;
comment|/* rekeying */
name|dispatch_set
argument_list|(
name|SSH2_MSG_KEXINIT
argument_list|,
operator|&
name|kex_input_kexinit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_init_dispatch_13
parameter_list|(
name|void
parameter_list|)
block|{
name|debug
argument_list|(
literal|"server_init_dispatch_13"
argument_list|)
expr_stmt|;
name|dispatch_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_CMSG_EOF
argument_list|,
operator|&
name|server_input_eof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_CMSG_STDIN_DATA
argument_list|,
operator|&
name|server_input_stdin_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_CMSG_WINDOW_SIZE
argument_list|,
operator|&
name|server_input_window_size
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_close
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_close_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_DATA
argument_list|,
operator|&
name|channel_input_data
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_CONFIRMATION
argument_list|,
operator|&
name|channel_input_open_confirmation
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_OPEN_FAILURE
argument_list|,
operator|&
name|channel_input_open_failure
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_PORT_OPEN
argument_list|,
operator|&
name|channel_input_port_open
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_init_dispatch_15
parameter_list|(
name|void
parameter_list|)
block|{
name|server_init_dispatch_13
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"server_init_dispatch_15"
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE
argument_list|,
operator|&
name|channel_input_ieof
argument_list|)
expr_stmt|;
name|dispatch_set
argument_list|(
name|SSH_MSG_CHANNEL_CLOSE_CONFIRMATION
argument_list|,
operator|&
name|channel_input_oclose
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_init_dispatch
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|compat20
condition|)
name|server_init_dispatch_20
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|compat13
condition|)
name|server_init_dispatch_13
argument_list|()
expr_stmt|;
else|else
name|server_init_dispatch_15
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

