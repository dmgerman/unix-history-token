begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Patrick Powell 1995  * This code is based on code written by Patrick Powell (papowell@astart.com)  * It may be used for any purpose as long as this notice remains intact  * on all source code distributions  */
end_comment

begin_comment
comment|/**************************************************************  * Original:  * Patrick Powell Tue Apr 11 09:48:21 PDT 1995  * A bombproof version of doprnt (dopr) included.  * Sigh.  This sort of thing is always nasty do deal with.  Note that  * the version here does not include floating point...  *  * snprintf() is used instead of sprintf() as it does limit checks  * for string length.  This covers a nasty loophole.  *  * The other functions are there to prevent NULL pointers from  * causing nast effects.  *  * More Recently:  *  Brandon Long<blong@fiction.net> 9/15/96 for mutt 0.43  *  This was ugly.  It is still ugly.  I opted out of floating point  *  numbers, but the formatter understands just about everything  *  from the normal C string format, at least as far as I can tell from  *  the Solaris 2.5 printf(3S) man page.  *  *  Brandon Long<blong@fiction.net> 10/22/97 for mutt 0.87.1  *    Ok, added some minimal floating point support, which means this  *    probably requires libm on most operating systems.  Don't yet  *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()  *    was pretty badly broken, it just wasn't being exercised in ways  *    which showed it, so that's been fixed.  Also, formated the code  *    to mutt conventions, and removed dead code left over from the  *    original.  Also, there is now a builtin-test, just compile with:  *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm  *    and run snprintf for results.  *   *  Thomas Roessler<roessler@guug.de> 01/27/98 for mutt 0.89i  *    The PGP code was using unsigned hexadecimal formats.   *    Unfortunately, unsigned formats simply didn't work.  *  *  Michael Elkins<me@cs.hmc.edu> 03/05/98 for mutt 0.90.8  *    The original code assumed that both snprintf() and vsnprintf() were  *    missing.  Some systems only have snprintf() but not vsnprintf(), so  *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.  *  *  Andrew Tridgell (tridge@samba.org) Oct 1998  *    fixed handling of %.0f  *    added test for HAVE_LONG_DOUBLE  *  * tridge@samba.org, idra@samba.org, April 2001  *    got rid of fcvt code (twas buggy and made testing harder)  *    added C99 semantics  *  * date: 2002/12/19 19:56:31;  author: herb;  state: Exp;  lines: +2 -0  * actually print args for %g and %e  *   * date: 2002/06/03 13:37:52;  author: jmcd;  state: Exp;  lines: +8 -0  * Since includes.h isn't included here, VA_COPY has to be defined here.  I don't  * see any include file that is guaranteed to be here, so I'm defining it  * locally.  Fixes AIX and Solaris builds.  *   * date: 2002/06/03 03:07:24;  author: tridge;  state: Exp;  lines: +5 -13  * put the ifdef for HAVE_VA_COPY in one place rather than in lots of  * functions  *   * date: 2002/05/17 14:51:22;  author: jmcd;  state: Exp;  lines: +21 -4  * Fix usage of va_list passed as an arg.  Use __va_copy before using it  * when it exists.  *   * date: 2002/04/16 22:38:04;  author: idra;  state: Exp;  lines: +20 -14  * Fix incorrect zpadlen handling in fmtfp.  * Thanks to Ollie Oldham<ollie.oldham@metro-optix.com> for spotting it.  * few mods to make it easier to compile the tests.  * addedd the "Ollie" test to the floating point ones.  *  * Martin Pool (mbp@samba.org) April 2003  *    Remove NO_CONFIG_H so that the test case can be built within a source  *    tree with less trouble.  *    Remove unnecessary SAFE_FREE() definition.  *  * Martin Pool (mbp@samba.org) May 2003  *    Put in a prototype for dummy_snprintf() to quiet compiler warnings.  *  *    Move #endif to make sure VA_COPY, LDOUBLE, etc are defined even  *    if the C library has some snprintf functions already.  *  * Damien Miller (djm@mindrot.org) Jan 2007  *    Fix integer overflows in return value.  *    Make formatting quite a bit faster by inlining dopr_outch()  *  **************************************************************/
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BROKEN_SNPRINTF
argument_list|)
end_if

begin_comment
comment|/* For those with broken snprintf() */
end_comment

begin_undef
undef|#
directive|undef
name|HAVE_SNPRINTF
end_undef

begin_undef
undef|#
directive|undef
name|HAVE_VSNPRINTF
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VA_COPY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VA_COPY
end_ifdef

begin_define
define|#
directive|define
name|VA_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|va_copy(dest, src)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE___VA_COPY
end_ifdef

begin_define
define|#
directive|define
name|VA_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|__va_copy(dest, src)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_COPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|(dest) = (src)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SNPRINTF
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_VSNPRINTF
argument_list|)
end_if

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
end_ifdef

begin_define
define|#
directive|define
name|LDOUBLE
value|long double
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LDOUBLE
value|double
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_LONG
end_ifdef

begin_define
define|#
directive|define
name|LLONG
value|long long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LLONG
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * dopr(): poor man's version of doprintf  */
end_comment

begin_comment
comment|/* format read states */
end_comment

begin_define
define|#
directive|define
name|DP_S_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|DP_S_FLAGS
value|1
end_define

begin_define
define|#
directive|define
name|DP_S_MIN
value|2
end_define

begin_define
define|#
directive|define
name|DP_S_DOT
value|3
end_define

begin_define
define|#
directive|define
name|DP_S_MAX
value|4
end_define

begin_define
define|#
directive|define
name|DP_S_MOD
value|5
end_define

begin_define
define|#
directive|define
name|DP_S_CONV
value|6
end_define

begin_define
define|#
directive|define
name|DP_S_DONE
value|7
end_define

begin_comment
comment|/* format flags - Bits */
end_comment

begin_define
define|#
directive|define
name|DP_F_MINUS
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|DP_F_PLUS
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|DP_F_SPACE
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|DP_F_NUM
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|DP_F_ZERO
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|DP_F_UP
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|DP_F_UNSIGNED
value|(1<< 6)
end_define

begin_comment
comment|/* Conversion Flags */
end_comment

begin_define
define|#
directive|define
name|DP_C_SHORT
value|1
end_define

begin_define
define|#
directive|define
name|DP_C_LONG
value|2
end_define

begin_define
define|#
directive|define
name|DP_C_LDOUBLE
value|3
end_define

begin_define
define|#
directive|define
name|DP_C_LLONG
value|4
end_define

begin_define
define|#
directive|define
name|char_to_int
parameter_list|(
name|p
parameter_list|)
value|((p)- '0')
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
value|(((p)>= (q)) ? (p) : (q))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOPR_OUTCH
parameter_list|(
name|buf
parameter_list|,
name|pos
parameter_list|,
name|buflen
parameter_list|,
name|thechar
parameter_list|)
define|\
value|do { \ 		if (pos + 1>= INT_MAX) { \ 			errno = ERANGE; \ 			return -1; \ 		} \ 		if (pos< buflen) \ 			buf[pos] = thechar; \ 		(pos)++; \ 	} while (0)
end_define

begin_function_decl
specifier|static
name|int
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args_in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LLONG
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LDOUBLE
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args_in
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
name|LLONG
name|value
decl_stmt|;
name|LDOUBLE
name|fvalue
decl_stmt|;
name|char
modifier|*
name|strvalue
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|cflags
decl_stmt|;
name|size_t
name|currlen
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|VA_COPY
argument_list|(
name|args
argument_list|,
name|args_in
argument_list|)
expr_stmt|;
name|state
operator|=
name|DP_S_DEFAULT
expr_stmt|;
name|currlen
operator|=
name|flags
operator|=
name|cflags
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
while|while
condition|(
name|state
operator|!=
name|DP_S_DONE
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
name|state
operator|=
name|DP_S_DONE
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DP_S_DEFAULT
case|:
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
name|state
operator|=
name|DP_S_FLAGS
expr_stmt|;
else|else
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
name|DP_S_FLAGS
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|flags
operator||=
name|DP_F_MINUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|flags
operator||=
name|DP_F_PLUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|flags
operator||=
name|DP_F_SPACE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|flags
operator||=
name|DP_F_NUM
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|flags
operator||=
name|DP_F_ZERO
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
name|state
operator|=
name|DP_S_MIN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DP_S_MIN
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
name|min
operator|=
literal|10
operator|*
name|min
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|min
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
block|}
break|break;
case|case
name|DP_S_DOT
case|:
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|state
operator|=
name|DP_S_MAX
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
block|}
break|break;
case|case
name|DP_S_MAX
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|10
operator|*
name|max
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|max
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
block|}
break|break;
case|case
name|DP_S_MOD
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'h'
case|:
name|cflags
operator|=
name|DP_C_SHORT
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|cflags
operator|=
name|DP_C_LONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'l'
condition|)
block|{
comment|/* It's a long long */
name|cflags
operator|=
name|DP_C_LLONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
name|cflags
operator|=
name|DP_C_LDOUBLE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|state
operator|=
name|DP_S_CONV
expr_stmt|;
break|break;
case|case
name|DP_S_CONV
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LLONG
condition|)
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LLONG
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'o'
case|:
name|flags
operator||=
name|DP_F_UNSIGNED
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LLONG
condition|)
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned LLONG
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|8
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'u'
case|:
name|flags
operator||=
name|DP_F_UNSIGNED
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LLONG
condition|)
name|value
operator|=
operator|(
name|LLONG
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned LLONG
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'X'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'x'
case|:
name|flags
operator||=
name|DP_F_UNSIGNED
expr_stmt|;
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LLONG
condition|)
name|value
operator|=
operator|(
name|LLONG
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned LLONG
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|16
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtfp
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fvalue
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'e'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtfp
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fvalue
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'G'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'g'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtfp
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fvalue
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'c'
case|:
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strvalue
condition|)
name|strvalue
operator|=
literal|"(NULL)"
expr_stmt|;
if|if
condition|(
name|max
operator|==
operator|-
literal|1
condition|)
block|{
name|max
operator|=
name|strlen
argument_list|(
name|strvalue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|>
literal|0
operator|&&
name|max
operator|>=
literal|0
operator|&&
name|min
operator|>
name|max
condition|)
name|max
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|fmtstr
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|strvalue
argument_list|,
name|flags
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'p'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
operator|(
name|long
operator|)
name|strvalue
argument_list|,
literal|16
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
block|{
name|short
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|short int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
block|{
name|long
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
operator|(
name|long
name|int
operator|)
name|currlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LLONG
condition|)
block|{
name|LLONG
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LLONG
operator|*
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
operator|(
name|LLONG
operator|)
name|currlen
expr_stmt|;
block|}
else|else
block|{
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* not supported yet, treat as next char */
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Unknown, skip */
break|break;
block|}
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DEFAULT
expr_stmt|;
name|flags
operator|=
name|cflags
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|DP_S_DONE
case|:
break|break;
default|default:
comment|/* hmm? */
break|break;
comment|/* some picky compilers need this */
block|}
block|}
if|if
condition|(
name|maxlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|currlen
operator|<
name|maxlen
operator|-
literal|1
condition|)
name|buffer
index|[
name|currlen
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|maxlen
operator|>
literal|0
condition|)
name|buffer
index|[
name|maxlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|currlen
operator|<
name|INT_MAX
condition|?
operator|(
name|int
operator|)
name|currlen
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|padlen
decl_stmt|,
name|strln
decl_stmt|;
comment|/* amount to pad */
name|int
name|cnt
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|printf
argument_list|(
literal|"fmtstr min=%d max=%d s=[%s]\n"
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|"<NULL>"
expr_stmt|;
block|}
for|for
control|(
name|strln
operator|=
literal|0
init|;
name|strln
operator|<
name|max
operator|&&
name|value
index|[
name|strln
index|]
condition|;
operator|++
name|strln
control|)
empty_stmt|;
comment|/* strlen */
name|padlen
operator|=
name|min
operator|-
name|strln
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justify */
while|while
condition|(
operator|(
name|padlen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
operator|*
name|value
argument_list|)
expr_stmt|;
operator|*
name|value
operator|++
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|padlen
operator|<
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
end_comment

begin_function
specifier|static
name|int
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LLONG
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|signvalue
init|=
literal|0
decl_stmt|;
name|unsigned
name|LLONG
name|uvalue
decl_stmt|;
name|char
name|convert
index|[
literal|20
index|]
decl_stmt|;
name|int
name|place
init|=
literal|0
decl_stmt|;
name|int
name|spadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to space pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to zero pad */
name|int
name|caps
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|uvalue
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DP_F_UNSIGNED
operator|)
condition|)
block|{
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|signvalue
operator|=
literal|'-'
expr_stmt|;
name|uvalue
operator|=
operator|-
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|DP_F_UP
condition|)
name|caps
operator|=
literal|1
expr_stmt|;
comment|/* Should characters be upper case? */
do|do
block|{
name|convert
index|[
name|place
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|uvalue
operator|%
operator|(
name|unsigned
operator|)
name|base
index|]
expr_stmt|;
name|uvalue
operator|=
operator|(
name|uvalue
operator|/
operator|(
name|unsigned
operator|)
name|base
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|uvalue
operator|&&
operator|(
name|place
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|place
operator|==
literal|20
condition|)
name|place
operator|--
expr_stmt|;
name|convert
index|[
name|place
index|]
operator|=
literal|0
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|place
expr_stmt|;
name|spadlen
operator|=
name|min
operator|-
name|MAX
argument_list|(
name|max
argument_list|,
name|place
argument_list|)
operator|-
operator|(
name|signvalue
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spadlen
operator|<
literal|0
condition|)
name|spadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_ZERO
condition|)
block|{
name|zpadlen
operator|=
name|MAX
argument_list|(
name|zpadlen
argument_list|,
name|spadlen
argument_list|)
expr_stmt|;
name|spadlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|spadlen
operator|=
operator|-
name|spadlen
expr_stmt|;
comment|/* Left Justifty */
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|printf
argument_list|(
literal|"zpad: %d, spad: %d, min: %d, max: %d, place: %d\n"
argument_list|,
name|zpadlen
argument_list|,
name|spadlen
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|place
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Spaces */
while|while
condition|(
name|spadlen
operator|>
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|spadlen
expr_stmt|;
block|}
comment|/* Sign */
if|if
condition|(
name|signvalue
condition|)
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
comment|/* Zeros */
if|if
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
block|}
comment|/* Digits */
while|while
condition|(
name|place
operator|>
literal|0
condition|)
block|{
operator|--
name|place
expr_stmt|;
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|convert
index|[
name|place
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Left Justified spaces */
while|while
condition|(
name|spadlen
operator|<
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|spadlen
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|LDOUBLE
name|abs_val
parameter_list|(
name|LDOUBLE
name|value
parameter_list|)
block|{
name|LDOUBLE
name|result
init|=
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
name|value
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|LDOUBLE
name|POW10
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|LDOUBLE
name|result
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|val
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
name|val
operator|--
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|LLONG
name|ROUND
parameter_list|(
name|LDOUBLE
name|value
parameter_list|)
block|{
name|LLONG
name|intpart
decl_stmt|;
name|intpart
operator|=
operator|(
name|LLONG
operator|)
name|value
expr_stmt|;
name|value
operator|=
name|value
operator|-
name|intpart
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0.5
condition|)
name|intpart
operator|++
expr_stmt|;
return|return
name|intpart
return|;
block|}
end_function

begin_comment
comment|/* a replacement for modf that doesn't need the math library. Should    be portable, but slow */
end_comment

begin_function
specifier|static
name|double
name|my_modf
parameter_list|(
name|double
name|x0
parameter_list|,
name|double
modifier|*
name|iptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|l
decl_stmt|;
name|double
name|x
init|=
name|x0
decl_stmt|;
name|double
name|f
init|=
literal|1.0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
operator|(
name|long
operator|)
name|x
expr_stmt|;
if|if
condition|(
name|l
operator|<=
operator|(
name|x
operator|+
literal|1
operator|)
operator|&&
name|l
operator|>=
operator|(
name|x
operator|-
literal|1
operator|)
condition|)
break|break;
name|x
operator|*=
literal|0.1
expr_stmt|;
name|f
operator|*=
literal|10.0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|100
condition|)
block|{
comment|/* 		 * yikes! the number is beyond what we can handle. 		 * What do we do? 		 */
operator|(
operator|*
name|iptr
operator|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|double
name|i2
decl_stmt|;
name|double
name|ret
decl_stmt|;
name|ret
operator|=
name|my_modf
argument_list|(
name|x0
operator|-
name|l
operator|*
name|f
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
operator|(
operator|*
name|iptr
operator|)
operator|=
name|l
operator|*
name|f
operator|+
name|i2
expr_stmt|;
return|return
name|ret
return|;
block|}
operator|(
operator|*
name|iptr
operator|)
operator|=
name|l
expr_stmt|;
return|return
name|x
operator|-
operator|(
operator|*
name|iptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LDOUBLE
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|signvalue
init|=
literal|0
decl_stmt|;
name|double
name|ufvalue
decl_stmt|;
name|char
name|iconvert
index|[
literal|311
index|]
decl_stmt|;
name|char
name|fconvert
index|[
literal|311
index|]
decl_stmt|;
name|int
name|iplace
init|=
literal|0
decl_stmt|;
name|int
name|fplace
init|=
literal|0
decl_stmt|;
name|int
name|padlen
init|=
literal|0
decl_stmt|;
comment|/* amount to pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
name|int
name|caps
init|=
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|double
name|intpart
decl_stmt|;
name|double
name|fracpart
decl_stmt|;
name|double
name|temp
decl_stmt|;
comment|/*  	 * AIX manpage says the default is 0, but Solaris says the default 	 * is 6, and sprintf on AIX defaults to 6 	 */
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|6
expr_stmt|;
name|ufvalue
operator|=
name|abs_val
argument_list|(
name|fvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvalue
operator|<
literal|0
condition|)
block|{
name|signvalue
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
block|{
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (flags& DP_F_UP) caps = 1;
comment|/* Should characters be upper case? */
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (max == 0) ufvalue += 0.5;
comment|/* if max = 0 we must round */
endif|#
directive|endif
comment|/*  	 * Sorry, we only support 16 digits past the decimal because of our  	 * conversion method 	 */
if|if
condition|(
name|max
operator|>
literal|16
condition|)
name|max
operator|=
literal|16
expr_stmt|;
comment|/* We "cheat" by converting the fractional part to integer by 	 * multiplying by a factor of 10 	 */
name|temp
operator|=
name|ufvalue
expr_stmt|;
name|my_modf
argument_list|(
name|temp
argument_list|,
operator|&
name|intpart
argument_list|)
expr_stmt|;
name|fracpart
operator|=
name|ROUND
argument_list|(
operator|(
name|POW10
argument_list|(
name|max
argument_list|)
operator|)
operator|*
operator|(
name|ufvalue
operator|-
name|intpart
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fracpart
operator|>=
name|POW10
argument_list|(
name|max
argument_list|)
condition|)
block|{
name|intpart
operator|++
expr_stmt|;
name|fracpart
operator|-=
name|POW10
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
comment|/* Convert integer part */
do|do
block|{
name|temp
operator|=
name|intpart
operator|*
literal|0.1
expr_stmt|;
name|my_modf
argument_list|(
name|temp
argument_list|,
operator|&
name|intpart
argument_list|)
expr_stmt|;
name|idx
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|temp
operator|-
name|intpart
operator|+
literal|0.05
operator|)
operator|*
literal|10.0
argument_list|)
expr_stmt|;
comment|/* idx = (int) (((double)(temp*0.1) -intpart +0.05) *10.0); */
comment|/* printf ("%llf, %f, %x\n", temp, intpart, idx); */
name|iconvert
index|[
name|iplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|idx
index|]
expr_stmt|;
block|}
do|while
condition|(
name|intpart
operator|&&
operator|(
name|iplace
operator|<
literal|311
operator|)
condition|)
do|;
if|if
condition|(
name|iplace
operator|==
literal|311
condition|)
name|iplace
operator|--
expr_stmt|;
name|iconvert
index|[
name|iplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Convert fractional part */
if|if
condition|(
name|fracpart
condition|)
block|{
do|do
block|{
name|temp
operator|=
name|fracpart
operator|*
literal|0.1
expr_stmt|;
name|my_modf
argument_list|(
name|temp
argument_list|,
operator|&
name|fracpart
argument_list|)
expr_stmt|;
name|idx
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|temp
operator|-
name|fracpart
operator|+
literal|0.05
operator|)
operator|*
literal|10.0
argument_list|)
expr_stmt|;
comment|/* idx = (int) ((((temp/10) -fracpart) +0.05) *10); */
comment|/* printf ("%lf, %lf, %ld\n", temp, fracpart, idx ); */
name|fconvert
index|[
name|fplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|idx
index|]
expr_stmt|;
block|}
do|while
condition|(
name|fracpart
operator|&&
operator|(
name|fplace
operator|<
literal|311
operator|)
condition|)
do|;
if|if
condition|(
name|fplace
operator|==
literal|311
condition|)
name|fplace
operator|--
expr_stmt|;
block|}
name|fconvert
index|[
name|fplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* -1 for decimal point, another -1 if we are printing a sign */
name|padlen
operator|=
name|min
operator|-
name|iplace
operator|-
name|max
operator|-
literal|1
operator|-
operator|(
operator|(
name|signvalue
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|fplace
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justifty */
if|if
condition|(
operator|(
name|flags
operator|&
name|DP_F_ZERO
operator|)
operator|&&
operator|(
name|padlen
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|signvalue
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
name|signvalue
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
if|if
condition|(
name|signvalue
condition|)
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
while|while
condition|(
name|iplace
operator|>
literal|0
condition|)
block|{
operator|--
name|iplace
expr_stmt|;
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|iconvert
index|[
name|iplace
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|printf
argument_list|(
literal|"fmtfp: fplace=%d zpadlen=%d\n"
argument_list|,
name|fplace
argument_list|,
name|zpadlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Decimal point.  This should probably use locale to find the correct 	 * char to print out. 	 */
if|if
condition|(
name|max
operator|>
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
while|while
condition|(
name|fplace
operator|>
literal|0
condition|)
block|{
operator|--
name|fplace
expr_stmt|;
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fconvert
index|[
name|fplace
index|]
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|padlen
operator|<
literal|0
condition|)
block|{
name|DOPR_OUTCH
argument_list|(
name|buffer
argument_list|,
operator|*
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(HAVE_SNPRINTF) || !defined(HAVE_VSNPRINTF) */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VSNPRINTF
argument_list|)
end_if

begin_function
name|int
name|vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
return|return
name|dopr
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SNPRINTF
argument_list|)
end_if

begin_function
name|int
name|snprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
name|SNPRINTF_CONST
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

