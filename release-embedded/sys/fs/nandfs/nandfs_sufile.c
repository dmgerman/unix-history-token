begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Semihalf.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs_mount.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs_subr.h>
end_include

begin_define
define|#
directive|define
name|SU_USAGE_OFF
parameter_list|(
name|bp
parameter_list|,
name|offset
parameter_list|)
define|\
value|((struct nandfs_segment_usage *)((bp)->b_data + offset))
end_define

begin_function
specifier|static
name|int
name|nandfs_seg_usage_blk_offset
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|seg
parameter_list|,
name|uint64_t
modifier|*
name|blk
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|;
name|uint16_t
name|seg_size
decl_stmt|;
name|seg_size
operator|=
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_segment_usage_size
expr_stmt|;
name|off
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_sufile_header
argument_list|)
argument_list|,
name|seg_size
argument_list|)
expr_stmt|;
name|off
operator|+=
operator|(
name|seg
operator|*
name|seg_size
operator|)
expr_stmt|;
operator|*
name|blk
operator|=
name|off
operator|/
name|fsdev
operator|->
name|nd_blocksize
expr_stmt|;
operator|*
name|offset
operator|=
name|off
operator|%
name|fsdev
operator|->
name|nd_blocksize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Alloc new segment */
end_comment

begin_function
name|int
name|nandfs_alloc_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
modifier|*
name|seg
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|nandfs_sufile_header
modifier|*
name|su_header
decl_stmt|;
name|struct
name|nandfs_segment_usage
modifier|*
name|su_usage
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp_header
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|vblk
decl_stmt|,
name|offset
decl_stmt|,
name|i
decl_stmt|,
name|rest
decl_stmt|,
name|nsegments
decl_stmt|;
name|uint16_t
name|seg_size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|;
name|seg_size
operator|=
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_segment_usage_size
expr_stmt|;
name|nsegments
operator|=
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_nsegments
expr_stmt|;
name|su_node
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Read header buffer */
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp_header
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|su_header
operator|=
operator|(
expr|struct
name|nandfs_sufile_header
operator|*
operator|)
name|bp_header
operator|->
name|b_data
expr_stmt|;
comment|/* Get last allocated segment */
name|i
operator|=
name|su_header
operator|->
name|sh_last_alloc
operator|+
literal|1
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|found
condition|)
block|{
name|nandfs_seg_usage_blk_offset
argument_list|(
name|fsdev
argument_list|,
name|i
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|nandfs_bmap_lookup
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
operator|&
name|vblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot find vblk for blk "
literal|"blk:%jx\n"
argument_list|,
name|__func__
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vblk
condition|)
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nandfs_bcreate
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot create/read "
literal|"vblk:%jx\n"
argument_list|,
name|__func__
argument_list|,
name|vblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|su_usage
operator|=
name|SU_USAGE_OFF
argument_list|(
name|bp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|su_usage
operator|=
name|SU_USAGE_OFF
argument_list|(
name|bp_header
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bp_header
expr_stmt|;
block|}
name|rest
operator|=
operator|(
name|fsdev
operator|->
name|nd_blocksize
operator|-
name|offset
operator|)
operator|/
name|seg_size
expr_stmt|;
comment|/* Go through all su usage in block */
while|while
condition|(
name|rest
condition|)
block|{
comment|/* When last check start from beggining */
if|if
condition|(
name|i
operator|==
name|nsegments
condition|)
break|break;
if|if
condition|(
operator|!
name|su_usage
operator|->
name|su_flags
condition|)
block|{
name|su_usage
operator|->
name|su_flags
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|su_usage
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* If all checked return error */
if|if
condition|(
name|i
operator|==
name|su_header
operator|->
name|sh_last_alloc
condition|)
block|{
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: cannot allocate segment \n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
literal|0
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rest
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* Otherwise read another block */
if|if
condition|(
name|blk
operator|!=
literal|0
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nsegments
condition|)
block|{
name|blk
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|blk
operator|++
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
operator|*
name|seg
operator|=
name|i
expr_stmt|;
name|su_header
operator|->
name|sh_last_alloc
operator|=
name|i
expr_stmt|;
name|su_header
operator|->
name|sh_ncleansegs
operator|--
expr_stmt|;
name|su_header
operator|->
name|sh_ndirtysegs
operator|++
expr_stmt|;
name|fsdev
operator|->
name|nd_super
operator|.
name|s_free_blocks_count
operator|=
name|su_header
operator|->
name|sh_ncleansegs
operator|*
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
name|fsdev
operator|->
name|nd_clean_segs
operator|--
expr_stmt|;
comment|/* 		 * It is mostly called from syncer() so we want to force 		 * making buf dirty. 		 */
name|error
operator|=
name|nandfs_dirty_buf
argument_list|(
name|bp_header
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bp
operator|&&
name|bp
operator|!=
name|bp_header
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bp
operator|&&
name|bp
operator|!=
name|bp_header
condition|)
name|nandfs_dirty_buf
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: seg:%#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: failed\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make buffer dirty, it will be updated soon but first it need to be  * gathered by syncer.  */
end_comment

begin_function
name|int
name|nandfs_touch_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|seg
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|su_node
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|nandfs_seg_usage_blk_offset
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nandfs_error
argument_list|(
literal|"%s: cannot preallocate new segment\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
name|nandfs_dirty_buf
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: seg:%#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Update block count of segment */
end_comment

begin_function
name|int
name|nandfs_update_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|seg
parameter_list|,
name|uint32_t
name|nblks
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|nandfs_segment_usage
modifier|*
name|su_usage
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|su_node
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|nandfs_seg_usage_blk_offset
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: read block:%jx to update\n"
argument_list|,
name|__func__
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|su_usage
operator|=
name|SU_USAGE_OFF
argument_list|(
name|bp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|su_usage
operator|->
name|su_lastmod
operator|=
name|fsdev
operator|->
name|nd_ts
operator|.
name|tv_sec
expr_stmt|;
name|su_usage
operator|->
name|su_flags
operator|=
name|NANDFS_SEGMENT_USAGE_DIRTY
expr_stmt|;
name|su_usage
operator|->
name|su_nblocks
operator|+=
name|nblks
expr_stmt|;
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: seg:%#jx inc:%#x cur:%#x\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|,
name|nblks
operator|,
name|su_usage
operator|->
name|su_nblocks
operator|)
argument_list|)
expr_stmt|;
name|nandfs_dirty_buf
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make segment free */
end_comment

begin_function
name|int
name|nandfs_free_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|seg
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|nandfs_sufile_header
modifier|*
name|su_header
decl_stmt|;
name|struct
name|nandfs_segment_usage
modifier|*
name|su_usage
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp_header
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|su_node
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Read su header */
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp_header
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|su_header
operator|=
operator|(
expr|struct
name|nandfs_sufile_header
operator|*
operator|)
name|bp_header
operator|->
name|b_data
expr_stmt|;
name|nandfs_seg_usage_blk_offset
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|/* Read su usage block if other than su header block */
if|if
condition|(
name|blk
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp_header
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
name|bp
operator|=
name|bp_header
expr_stmt|;
comment|/* Reset su usage data */
name|su_usage
operator|=
name|SU_USAGE_OFF
argument_list|(
name|bp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|su_usage
operator|->
name|su_lastmod
operator|=
name|fsdev
operator|->
name|nd_ts
operator|.
name|tv_sec
expr_stmt|;
name|su_usage
operator|->
name|su_nblocks
operator|=
literal|0
expr_stmt|;
name|su_usage
operator|->
name|su_flags
operator|=
literal|0
expr_stmt|;
comment|/* Update clean/dirty counter in header */
name|su_header
operator|->
name|sh_ncleansegs
operator|++
expr_stmt|;
name|su_header
operator|->
name|sh_ndirtysegs
operator|--
expr_stmt|;
comment|/* 	 *  Make buffers dirty, called by cleaner 	 *  so force dirty even if no much space left 	 *  on device 	 */
name|nandfs_dirty_buf
argument_list|(
name|bp_header
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|bp_header
condition|)
name|nandfs_dirty_buf
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Update free block count */
name|fsdev
operator|->
name|nd_super
operator|.
name|s_free_blocks_count
operator|=
name|su_header
operator|->
name|sh_ncleansegs
operator|*
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
name|fsdev
operator|->
name|nd_clean_segs
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: seg:%#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_bad_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|seg
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|nandfs_segment_usage
modifier|*
name|su_usage
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|su_node
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|nandfs_seg_usage_blk_offset
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|su_usage
operator|=
name|SU_USAGE_OFF
argument_list|(
name|bp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|su_usage
operator|->
name|su_lastmod
operator|=
name|fsdev
operator|->
name|nd_ts
operator|.
name|tv_sec
expr_stmt|;
name|su_usage
operator|->
name|su_flags
operator|=
name|NANDFS_SEGMENT_USAGE_ERROR
expr_stmt|;
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: seg:%#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|)
argument_list|)
expr_stmt|;
name|nandfs_dirty_buf
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_markgc_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|seg
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|nandfs_segment_usage
modifier|*
name|su_usage
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|su_node
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|nandfs_seg_usage_blk_offset
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
name|blk
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|su_usage
operator|=
name|SU_USAGE_OFF
argument_list|(
name|bp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|su_usage
operator|->
name|su_flags
operator|&
name|NANDFS_SEGMENT_USAGE_GC
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|su_usage
operator|->
name|su_flags
operator||=
name|NANDFS_SEGMENT_USAGE_GC
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: seg:%#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_clear_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|seg
parameter_list|)
block|{
name|uint64_t
name|offset
decl_stmt|,
name|segsize
decl_stmt|;
name|uint32_t
name|bps
decl_stmt|,
name|bsize
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bps
operator|=
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
name|bsize
operator|=
name|fsdev
operator|->
name|nd_blocksize
expr_stmt|;
name|segsize
operator|=
name|bsize
operator|*
name|bps
expr_stmt|;
name|nandfs_get_segment_range
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|,
operator|&
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|*=
name|bsize
expr_stmt|;
name|DPRINTF
argument_list|(
name|SEG
argument_list|,
operator|(
literal|"%s: seg:%#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|)
argument_list|)
expr_stmt|;
comment|/* Erase it and mark it bad when fail */
if|if
condition|(
name|nandfs_erase
argument_list|(
name|fsdev
argument_list|,
name|offset
argument_list|,
name|segsize
argument_list|)
condition|)
name|error
operator|=
name|nandfs_bad_segment
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Mark it free */
name|error
operator|=
name|nandfs_free_segment
argument_list|(
name|fsdev
argument_list|,
name|seg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_get_seg_stat
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|struct
name|nandfs_seg_stat
modifier|*
name|nss
parameter_list|)
block|{
name|struct
name|nandfs_sufile_header
modifier|*
name|suhdr
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|su_node
operator|=
name|nandfsdev
operator|->
name|nd_su_node
expr_stmt|;
name|NANDFS_WRITELOCK
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
name|err
operator|=
name|nandfs_bread
argument_list|(
name|nandfsdev
operator|->
name|nd_su_node
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NANDFS_WRITEUNLOCK
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|suhdr
operator|=
operator|(
expr|struct
name|nandfs_sufile_header
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|nss
operator|->
name|nss_nsegs
operator|=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_nsegments
expr_stmt|;
name|nss
operator|->
name|nss_ncleansegs
operator|=
name|suhdr
operator|->
name|sh_ncleansegs
expr_stmt|;
name|nss
operator|->
name|nss_ndirtysegs
operator|=
name|suhdr
operator|->
name|sh_ndirtysegs
expr_stmt|;
name|nss
operator|->
name|nss_ctime
operator|=
literal|0
expr_stmt|;
name|nss
operator|->
name|nss_nongc_ctime
operator|=
name|nandfsdev
operator|->
name|nd_ts
operator|.
name|tv_sec
expr_stmt|;
name|nss
operator|->
name|nss_prot_seq
operator|=
name|nandfsdev
operator|->
name|nd_seg_sequence
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NANDFS_WRITEUNLOCK
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_get_segment_info_ioctl
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_argv
modifier|*
name|nargv
parameter_list|)
block|{
name|struct
name|nandfs_suinfo
modifier|*
name|nsi
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|nargv
operator|->
name|nv_nmembs
operator|>
name|NANDFS_SEGMENTS_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nsi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_suinfo
argument_list|)
operator|*
name|nargv
operator|->
name|nv_nmembs
argument_list|,
name|M_NANDFSTEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_get_segment_info
argument_list|(
name|fsdev
argument_list|,
name|nsi
argument_list|,
name|nargv
operator|->
name|nv_nmembs
argument_list|,
name|nargv
operator|->
name|nv_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|nsi
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nargv
operator|->
name|nv_base
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_suinfo
argument_list|)
operator|*
name|nargv
operator|->
name|nv_nmembs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nsi
argument_list|,
name|M_NANDFSTEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_get_segment_info
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_suinfo
modifier|*
name|nsi
parameter_list|,
name|uint32_t
name|nmembs
parameter_list|,
name|uint64_t
name|segment
parameter_list|)
block|{
return|return
operator|(
name|nandfs_get_segment_info_filter
argument_list|(
name|fsdev
argument_list|,
name|nsi
argument_list|,
name|nmembs
argument_list|,
name|segment
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_get_segment_info_filter
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_suinfo
modifier|*
name|nsi
parameter_list|,
name|uint32_t
name|nmembs
parameter_list|,
name|uint64_t
name|segment
parameter_list|,
name|uint64_t
modifier|*
name|nsegs
parameter_list|,
name|uint32_t
name|filter
parameter_list|,
name|uint32_t
name|nfilter
parameter_list|)
block|{
name|struct
name|nandfs_segment_usage
modifier|*
name|su
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|su_node
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|curr
decl_stmt|,
name|blocknr
decl_stmt|,
name|blockoff
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|curr
operator|=
operator|~
operator|(
literal|0
operator|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|su_node
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nsegs
operator|!=
name|NULL
condition|)
operator|*
name|nsegs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmembs
condition|;
name|segment
operator|++
control|)
block|{
if|if
condition|(
name|segment
operator|==
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_nsegments
condition|)
break|break;
name|nandfs_seg_usage_blk_offset
argument_list|(
name|fsdev
argument_list|,
name|segment
argument_list|,
operator|&
name|blocknr
argument_list|,
operator|&
name|blockoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|curr
operator|!=
name|blocknr
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|err
operator|=
name|nandfs_bread
argument_list|(
name|su_node
argument_list|,
name|blocknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|curr
operator|=
name|blocknr
expr_stmt|;
block|}
name|su
operator|=
name|SU_USAGE_OFF
argument_list|(
name|bp
argument_list|,
name|blockoff
argument_list|)
expr_stmt|;
name|flags
operator|=
name|su
operator|->
name|su_flags
expr_stmt|;
if|if
condition|(
name|segment
operator|==
name|fsdev
operator|->
name|nd_seg_num
operator|||
name|segment
operator|==
name|fsdev
operator|->
name|nd_next_seg_num
condition|)
name|flags
operator||=
name|NANDFS_SEGMENT_USAGE_ACTIVE
expr_stmt|;
if|if
condition|(
name|nfilter
operator|!=
literal|0
operator|&&
operator|(
name|flags
operator|&
name|nfilter
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|filter
operator|!=
literal|0
operator|&&
operator|(
name|flags
operator|&
name|filter
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|nsi
operator|->
name|nsi_num
operator|=
name|segment
expr_stmt|;
name|nsi
operator|->
name|nsi_lastmod
operator|=
name|su
operator|->
name|su_lastmod
expr_stmt|;
name|nsi
operator|->
name|nsi_blocks
operator|=
name|su
operator|->
name|su_nblocks
expr_stmt|;
name|nsi
operator|->
name|nsi_flags
operator|=
name|flags
expr_stmt|;
name|nsi
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|nsegs
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|nsegs
operator|)
operator|++
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

