begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This file contains sub-routines to build up USB descriptors from  * USB templates.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_GLOBAL_INCLUDE_FILE
end_ifdef

begin_include
include|#
directive|include
include|USB_GLOBAL_INCLUDE_FILE
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_cdc.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dynamic.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/template/usb_template.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_GLOBAL_INCLUDE_FILE */
end_comment

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|usb_template
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|usb_template
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|usb_make_raw_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_make_endpoint_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
parameter_list|,
specifier|const
name|struct
name|usb_temp_endpoint_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_make_interface_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
parameter_list|,
specifier|const
name|struct
name|usb_temp_interface_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_make_config_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
parameter_list|,
specifier|const
name|struct
name|usb_temp_config_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_make_device_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
parameter_list|,
specifier|const
name|struct
name|usb_temp_device_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|usb_hw_ep_match
parameter_list|(
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|usb_hw_ep_find_match
parameter_list|(
name|struct
name|usb_hw_ep_scratch
modifier|*
parameter_list|,
name|struct
name|usb_hw_ep_scratch_sub
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|usb_hw_ep_get_needs
parameter_list|(
name|struct
name|usb_hw_ep_scratch
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usb_hw_ep_resolve
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|struct
name|usb_descriptor
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|usb_temp_device_desc
modifier|*
name|usb_temp_get_tdd
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|usb_temp_get_device_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|usb_temp_get_qualifier_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|usb_temp_get_config_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|usb_temp_get_string_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|usb_temp_get_vendor_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
specifier|const
name|struct
name|usb_device_request
modifier|*
parameter_list|,
name|uint16_t
modifier|*
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|usb_temp_get_hub_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usb_temp_get_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|struct
name|usb_device_request
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usb_temp_setup_by_index
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|uint16_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_temp_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_make_raw_desc  *  * This function will insert a raw USB descriptor into the generated  * USB configuration.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_make_raw_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
name|temp
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|raw
parameter_list|)
block|{
name|void
modifier|*
name|dst
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
comment|/*          * The first byte of any USB descriptor gives the length.          */
if|if
condition|(
name|raw
condition|)
block|{
name|len
operator|=
name|raw
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|buf
condition|)
block|{
name|dst
operator|=
name|USB_ADD_BYTES
argument_list|(
name|temp
operator|->
name|buf
argument_list|,
name|temp
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|raw
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* check if we have got a CDC union descriptor */
if|if
condition|(
operator|(
name|raw
index|[
literal|0
index|]
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_cdc_union_descriptor
argument_list|)
operator|)
operator|&&
operator|(
name|raw
index|[
literal|1
index|]
operator|==
name|UDESC_CS_INTERFACE
operator|)
operator|&&
operator|(
name|raw
index|[
literal|2
index|]
operator|==
name|UDESCSUB_CDC_UNION
operator|)
condition|)
block|{
name|struct
name|usb_cdc_union_descriptor
modifier|*
name|ud
init|=
operator|(
name|void
operator|*
operator|)
name|dst
decl_stmt|;
comment|/* update the interface numbers */
name|ud
operator|->
name|bMasterInterface
operator|+=
name|temp
operator|->
name|bInterfaceNumber
expr_stmt|;
name|ud
operator|->
name|bSlaveInterface
index|[
literal|0
index|]
operator|+=
name|temp
operator|->
name|bInterfaceNumber
expr_stmt|;
block|}
comment|/* check if we have got an interface association descriptor */
if|if
condition|(
operator|(
name|raw
index|[
literal|0
index|]
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_interface_assoc_descriptor
argument_list|)
operator|)
operator|&&
operator|(
name|raw
index|[
literal|1
index|]
operator|==
name|UDESC_IFACE_ASSOC
operator|)
condition|)
block|{
name|struct
name|usb_interface_assoc_descriptor
modifier|*
name|iad
init|=
operator|(
name|void
operator|*
operator|)
name|dst
decl_stmt|;
comment|/* update the interface number */
name|iad
operator|->
name|bFirstInterface
operator|+=
name|temp
operator|->
name|bInterfaceNumber
expr_stmt|;
block|}
comment|/* check if we have got a call management descriptor */
if|if
condition|(
operator|(
name|raw
index|[
literal|0
index|]
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_cdc_cm_descriptor
argument_list|)
operator|)
operator|&&
operator|(
name|raw
index|[
literal|1
index|]
operator|==
name|UDESC_CS_INTERFACE
operator|)
operator|&&
operator|(
name|raw
index|[
literal|2
index|]
operator|==
name|UDESCSUB_CDC_CM
operator|)
condition|)
block|{
name|struct
name|usb_cdc_cm_descriptor
modifier|*
name|ccd
init|=
operator|(
name|void
operator|*
operator|)
name|dst
decl_stmt|;
comment|/* update the interface number */
name|ccd
operator|->
name|bDataInterface
operator|+=
name|temp
operator|->
name|bInterfaceNumber
expr_stmt|;
block|}
block|}
name|temp
operator|->
name|size
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_make_endpoint_desc  *  * This function will generate an USB endpoint descriptor from the  * given USB template endpoint descriptor, which will be inserted into  * the USB configuration.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_make_endpoint_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
name|temp
parameter_list|,
specifier|const
name|struct
name|usb_temp_endpoint_desc
modifier|*
name|ted
parameter_list|)
block|{
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ed
decl_stmt|;
specifier|const
name|void
modifier|*
modifier|*
name|rd
decl_stmt|;
name|uint16_t
name|old_size
decl_stmt|;
name|uint16_t
name|mps
decl_stmt|;
name|uint8_t
name|ea
decl_stmt|;
comment|/* Endpoint Address */
name|uint8_t
name|et
decl_stmt|;
comment|/* Endpiont Type */
comment|/* Reserve memory */
name|old_size
operator|=
name|temp
operator|->
name|size
expr_stmt|;
name|ea
operator|=
operator|(
name|ted
operator|->
name|bEndpointAddress
operator|&
operator|(
name|UE_ADDR
operator||
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator|)
operator|)
expr_stmt|;
name|et
operator|=
operator|(
name|ted
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
if|if
condition|(
name|et
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
comment|/* account for extra byte fields */
name|temp
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
expr_stmt|;
block|}
comment|/* Scan all Raw Descriptors first */
name|rd
operator|=
name|ted
operator|->
name|ppRawDesc
expr_stmt|;
if|if
condition|(
name|rd
condition|)
block|{
while|while
condition|(
operator|*
name|rd
condition|)
block|{
name|usb_make_raw_desc
argument_list|(
name|temp
argument_list|,
operator|*
name|rd
argument_list|)
expr_stmt|;
name|rd
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ted
operator|->
name|pPacketSize
operator|==
name|NULL
condition|)
block|{
comment|/* not initialized */
name|temp
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
return|return;
block|}
name|mps
operator|=
name|ted
operator|->
name|pPacketSize
operator|->
name|mps
index|[
name|temp
operator|->
name|usb_speed
index|]
expr_stmt|;
if|if
condition|(
name|mps
operator|==
literal|0
condition|)
block|{
comment|/* not initialized */
name|temp
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mps
operator|==
name|UE_ZERO_MPS
condition|)
block|{
comment|/* escape for Zero Max Packet Size */
name|mps
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Fill out the real USB endpoint descriptor 	 * in case there is a buffer present: 	 */
if|if
condition|(
name|temp
operator|->
name|buf
condition|)
block|{
name|ed
operator|=
name|USB_ADD_BYTES
argument_list|(
name|temp
operator|->
name|buf
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|==
name|UE_ISOCHRONOUS
condition|)
name|ed
operator|->
name|bLength
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
operator|+
literal|2
expr_stmt|;
else|else
name|ed
operator|->
name|bLength
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
expr_stmt|;
name|ed
operator|->
name|bDescriptorType
operator|=
name|UDESC_ENDPOINT
expr_stmt|;
name|ed
operator|->
name|bEndpointAddress
operator|=
name|ea
expr_stmt|;
name|ed
operator|->
name|bmAttributes
operator|=
name|ted
operator|->
name|bmAttributes
expr_stmt|;
name|USETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|,
name|mps
argument_list|)
expr_stmt|;
comment|/* setup bInterval parameter */
if|if
condition|(
name|ted
operator|->
name|pIntervals
operator|&&
name|ted
operator|->
name|pIntervals
operator|->
name|bInterval
index|[
name|temp
operator|->
name|usb_speed
index|]
condition|)
block|{
name|ed
operator|->
name|bInterval
operator|=
name|ted
operator|->
name|pIntervals
operator|->
name|bInterval
index|[
name|temp
operator|->
name|usb_speed
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|UE_BULK
case|:
case|case
name|UE_CONTROL
case|:
name|ed
operator|->
name|bInterval
operator|=
literal|0
expr_stmt|;
comment|/* not used */
break|break;
case|case
name|UE_INTERRUPT
case|:
switch|switch
condition|(
name|temp
operator|->
name|usb_speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
name|ed
operator|->
name|bInterval
operator|=
literal|1
expr_stmt|;
comment|/* 1 ms */
break|break;
default|default:
name|ed
operator|->
name|bInterval
operator|=
literal|4
expr_stmt|;
comment|/* 1 ms */
break|break;
block|}
break|break;
default|default:
comment|/* UE_ISOCHRONOUS */
switch|switch
condition|(
name|temp
operator|->
name|usb_speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
name|ed
operator|->
name|bInterval
operator|=
literal|1
expr_stmt|;
comment|/* 1 ms */
break|break;
default|default:
name|ed
operator|->
name|bInterval
operator|=
literal|1
expr_stmt|;
comment|/* 125 us */
break|break;
block|}
break|break;
block|}
block|}
block|}
name|temp
operator|->
name|bNumEndpoints
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_make_interface_desc  *  * This function will generate an USB interface descriptor from the  * given USB template interface descriptor, which will be inserted  * into the USB configuration.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_make_interface_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
name|temp
parameter_list|,
specifier|const
name|struct
name|usb_temp_interface_desc
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
specifier|const
name|struct
name|usb_temp_endpoint_desc
modifier|*
modifier|*
name|ted
decl_stmt|;
specifier|const
name|void
modifier|*
modifier|*
name|rd
decl_stmt|;
name|uint16_t
name|old_size
decl_stmt|;
comment|/* Reserve memory */
name|old_size
operator|=
name|temp
operator|->
name|size
expr_stmt|;
name|temp
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
expr_stmt|;
comment|/* Update interface and alternate interface numbers */
if|if
condition|(
name|tid
operator|->
name|isAltInterface
operator|==
literal|0
condition|)
block|{
name|temp
operator|->
name|bAlternateSetting
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|bInterfaceNumber
operator|++
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|->
name|bAlternateSetting
operator|++
expr_stmt|;
block|}
comment|/* Scan all Raw Descriptors first */
name|rd
operator|=
name|tid
operator|->
name|ppRawDesc
expr_stmt|;
if|if
condition|(
name|rd
condition|)
block|{
while|while
condition|(
operator|*
name|rd
condition|)
block|{
name|usb_make_raw_desc
argument_list|(
name|temp
argument_list|,
operator|*
name|rd
argument_list|)
expr_stmt|;
name|rd
operator|++
expr_stmt|;
block|}
block|}
comment|/* Reset some counters */
name|temp
operator|->
name|bNumEndpoints
operator|=
literal|0
expr_stmt|;
comment|/* Scan all Endpoint Descriptors second */
name|ted
operator|=
name|tid
operator|->
name|ppEndpoints
expr_stmt|;
if|if
condition|(
name|ted
condition|)
block|{
while|while
condition|(
operator|*
name|ted
condition|)
block|{
name|usb_make_endpoint_desc
argument_list|(
name|temp
argument_list|,
operator|*
name|ted
argument_list|)
expr_stmt|;
name|ted
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Fill out the real USB interface descriptor 	 * in case there is a buffer present: 	 */
if|if
condition|(
name|temp
operator|->
name|buf
condition|)
block|{
name|id
operator|=
name|USB_ADD_BYTES
argument_list|(
name|temp
operator|->
name|buf
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|id
operator|->
name|bLength
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
expr_stmt|;
name|id
operator|->
name|bDescriptorType
operator|=
name|UDESC_INTERFACE
expr_stmt|;
name|id
operator|->
name|bInterfaceNumber
operator|=
name|temp
operator|->
name|bInterfaceNumber
expr_stmt|;
name|id
operator|->
name|bAlternateSetting
operator|=
name|temp
operator|->
name|bAlternateSetting
expr_stmt|;
name|id
operator|->
name|bNumEndpoints
operator|=
name|temp
operator|->
name|bNumEndpoints
expr_stmt|;
name|id
operator|->
name|bInterfaceClass
operator|=
name|tid
operator|->
name|bInterfaceClass
expr_stmt|;
name|id
operator|->
name|bInterfaceSubClass
operator|=
name|tid
operator|->
name|bInterfaceSubClass
expr_stmt|;
name|id
operator|->
name|bInterfaceProtocol
operator|=
name|tid
operator|->
name|bInterfaceProtocol
expr_stmt|;
name|id
operator|->
name|iInterface
operator|=
name|tid
operator|->
name|iInterface
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_make_config_desc  *  * This function will generate an USB config descriptor from the given  * USB template config descriptor, which will be inserted into the USB  * configuration.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_make_config_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
name|temp
parameter_list|,
specifier|const
name|struct
name|usb_temp_config_desc
modifier|*
name|tcd
parameter_list|)
block|{
name|struct
name|usb_config_descriptor
modifier|*
name|cd
decl_stmt|;
specifier|const
name|struct
name|usb_temp_interface_desc
modifier|*
modifier|*
name|tid
decl_stmt|;
name|uint16_t
name|old_size
decl_stmt|;
comment|/* Reserve memory */
name|old_size
operator|=
name|temp
operator|->
name|size
expr_stmt|;
name|temp
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|cd
argument_list|)
expr_stmt|;
comment|/* Reset some counters */
name|temp
operator|->
name|bInterfaceNumber
operator|=
literal|0xFF
expr_stmt|;
name|temp
operator|->
name|bAlternateSetting
operator|=
literal|0
expr_stmt|;
comment|/* Scan all the USB interfaces */
name|tid
operator|=
name|tcd
operator|->
name|ppIfaceDesc
expr_stmt|;
if|if
condition|(
name|tid
condition|)
block|{
while|while
condition|(
operator|*
name|tid
condition|)
block|{
name|usb_make_interface_desc
argument_list|(
name|temp
argument_list|,
operator|*
name|tid
argument_list|)
expr_stmt|;
name|tid
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Fill out the real USB config descriptor 	 * in case there is a buffer present: 	 */
if|if
condition|(
name|temp
operator|->
name|buf
condition|)
block|{
name|cd
operator|=
name|USB_ADD_BYTES
argument_list|(
name|temp
operator|->
name|buf
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
comment|/* compute total size */
name|old_size
operator|=
name|temp
operator|->
name|size
operator|-
name|old_size
expr_stmt|;
name|cd
operator|->
name|bLength
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|->
name|bDescriptorType
operator|=
name|UDESC_CONFIG
expr_stmt|;
name|USETW
argument_list|(
name|cd
operator|->
name|wTotalLength
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
name|cd
operator|->
name|bNumInterface
operator|=
name|temp
operator|->
name|bInterfaceNumber
operator|+
literal|1
expr_stmt|;
name|cd
operator|->
name|bConfigurationValue
operator|=
name|temp
operator|->
name|bConfigurationValue
expr_stmt|;
name|cd
operator|->
name|iConfiguration
operator|=
name|tcd
operator|->
name|iConfiguration
expr_stmt|;
name|cd
operator|->
name|bmAttributes
operator|=
name|tcd
operator|->
name|bmAttributes
expr_stmt|;
name|cd
operator|->
name|bMaxPower
operator|=
name|tcd
operator|->
name|bMaxPower
expr_stmt|;
name|cd
operator|->
name|bmAttributes
operator||=
operator|(
name|UC_REMOTE_WAKEUP
operator||
name|UC_BUS_POWERED
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|self_powered
condition|)
block|{
name|cd
operator|->
name|bmAttributes
operator||=
name|UC_SELF_POWERED
expr_stmt|;
block|}
else|else
block|{
name|cd
operator|->
name|bmAttributes
operator|&=
operator|~
name|UC_SELF_POWERED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_make_device_desc  *  * This function will generate an USB device descriptor from the  * given USB template device descriptor.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_make_device_desc
parameter_list|(
name|struct
name|usb_temp_setup
modifier|*
name|temp
parameter_list|,
specifier|const
name|struct
name|usb_temp_device_desc
modifier|*
name|tdd
parameter_list|)
block|{
name|struct
name|usb_temp_data
modifier|*
name|utd
decl_stmt|;
specifier|const
name|struct
name|usb_temp_config_desc
modifier|*
modifier|*
name|tcd
decl_stmt|;
name|uint16_t
name|old_size
decl_stmt|;
comment|/* Reserve memory */
name|old_size
operator|=
name|temp
operator|->
name|size
expr_stmt|;
name|temp
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|utd
argument_list|)
expr_stmt|;
comment|/* Scan all the USB configs */
name|temp
operator|->
name|bConfigurationValue
operator|=
literal|1
expr_stmt|;
name|tcd
operator|=
name|tdd
operator|->
name|ppConfigDesc
expr_stmt|;
if|if
condition|(
name|tcd
condition|)
block|{
while|while
condition|(
operator|*
name|tcd
condition|)
block|{
name|usb_make_config_desc
argument_list|(
name|temp
argument_list|,
operator|*
name|tcd
argument_list|)
expr_stmt|;
name|temp
operator|->
name|bConfigurationValue
operator|++
expr_stmt|;
name|tcd
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Fill out the real USB device descriptor 	 * in case there is a buffer present: 	 */
if|if
condition|(
name|temp
operator|->
name|buf
condition|)
block|{
name|utd
operator|=
name|USB_ADD_BYTES
argument_list|(
name|temp
operator|->
name|buf
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
comment|/* Store a pointer to our template device descriptor */
name|utd
operator|->
name|tdd
operator|=
name|tdd
expr_stmt|;
comment|/* Fill out USB device descriptor */
name|utd
operator|->
name|udd
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|utd
operator|->
name|udd
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bDescriptorType
operator|=
name|UDESC_DEVICE
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bDeviceClass
operator|=
name|tdd
operator|->
name|bDeviceClass
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bDeviceSubClass
operator|=
name|tdd
operator|->
name|bDeviceSubClass
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bDeviceProtocol
operator|=
name|tdd
operator|->
name|bDeviceProtocol
expr_stmt|;
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|idVendor
argument_list|,
name|tdd
operator|->
name|idVendor
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|idProduct
argument_list|,
name|tdd
operator|->
name|idProduct
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|bcdDevice
argument_list|,
name|tdd
operator|->
name|bcdDevice
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|iManufacturer
operator|=
name|tdd
operator|->
name|iManufacturer
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|iProduct
operator|=
name|tdd
operator|->
name|iProduct
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|iSerialNumber
operator|=
name|tdd
operator|->
name|iSerialNumber
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bNumConfigurations
operator|=
name|temp
operator|->
name|bConfigurationValue
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Fill out the USB device qualifier. Pretend that we 		 * don't support any other speeds by setting 		 * "bNumConfigurations" equal to zero. That saves us 		 * generating an extra set of configuration 		 * descriptors. 		 */
name|utd
operator|->
name|udq
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|utd
operator|->
name|udq
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udq
operator|.
name|bDescriptorType
operator|=
name|UDESC_DEVICE_QUALIFIER
expr_stmt|;
name|utd
operator|->
name|udq
operator|.
name|bDeviceClass
operator|=
name|tdd
operator|->
name|bDeviceClass
expr_stmt|;
name|utd
operator|->
name|udq
operator|.
name|bDeviceSubClass
operator|=
name|tdd
operator|->
name|bDeviceSubClass
expr_stmt|;
name|utd
operator|->
name|udq
operator|.
name|bDeviceProtocol
operator|=
name|tdd
operator|->
name|bDeviceProtocol
expr_stmt|;
name|utd
operator|->
name|udq
operator|.
name|bNumConfigurations
operator|=
literal|0
expr_stmt|;
name|USETW
argument_list|(
name|utd
operator|->
name|udq
operator|.
name|bcdUSB
argument_list|,
literal|0x0200
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udq
operator|.
name|bMaxPacketSize0
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|temp
operator|->
name|usb_speed
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|bcdUSB
argument_list|,
literal|0x0110
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bMaxPacketSize
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|USB_SPEED_FULL
case|:
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|bcdUSB
argument_list|,
literal|0x0110
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bMaxPacketSize
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|USB_SPEED_HIGH
case|:
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|bcdUSB
argument_list|,
literal|0x0200
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bMaxPacketSize
operator|=
literal|64
expr_stmt|;
break|break;
case|case
name|USB_SPEED_VARIABLE
case|:
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|bcdUSB
argument_list|,
literal|0x0250
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bMaxPacketSize
operator|=
literal|255
expr_stmt|;
comment|/* 512 bytes */
break|break;
case|case
name|USB_SPEED_SUPER
case|:
name|USETW
argument_list|(
name|utd
operator|->
name|udd
operator|.
name|bcdUSB
argument_list|,
literal|0x0300
argument_list|)
expr_stmt|;
name|utd
operator|->
name|udd
operator|.
name|bMaxPacketSize
operator|=
literal|9
expr_stmt|;
comment|/* 2**9 = 512 bytes */
break|break;
default|default:
name|temp
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_hw_ep_match  *  * Return values:  *    0: The endpoint profile does not match the criterias  * Else: The endpoint profile matches the criterias  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usb_hw_ep_match
parameter_list|(
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
name|pf
parameter_list|,
name|uint8_t
name|ep_type
parameter_list|,
name|uint8_t
name|ep_dir_in
parameter_list|)
block|{
if|if
condition|(
name|ep_type
operator|==
name|UE_CONTROL
condition|)
block|{
comment|/* special */
return|return
operator|(
name|pf
operator|->
name|support_control
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pf
operator|->
name|support_in
operator|&&
name|ep_dir_in
operator|)
operator|||
operator|(
name|pf
operator|->
name|support_out
operator|&&
operator|!
name|ep_dir_in
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pf
operator|->
name|support_interrupt
operator|&&
operator|(
name|ep_type
operator|==
name|UE_INTERRUPT
operator|)
operator|)
operator|||
operator|(
name|pf
operator|->
name|support_isochronous
operator|&&
operator|(
name|ep_type
operator|==
name|UE_ISOCHRONOUS
operator|)
operator|)
operator|||
operator|(
name|pf
operator|->
name|support_bulk
operator|&&
operator|(
name|ep_type
operator|==
name|UE_BULK
operator|)
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_hw_ep_find_match  *  * This function is used to find the best matching endpoint profile  * for and endpoint belonging to an USB descriptor.  *  * Return values:  *    0: Success. Got a match.  * Else: Failure. No match.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usb_hw_ep_find_match
parameter_list|(
name|struct
name|usb_hw_ep_scratch
modifier|*
name|ues
parameter_list|,
name|struct
name|usb_hw_ep_scratch_sub
modifier|*
name|ep
parameter_list|,
name|uint8_t
name|is_simplex
parameter_list|)
block|{
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
name|pf
decl_stmt|;
name|uint16_t
name|distance
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|uint16_t
name|max_frame_size
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|best_n
decl_stmt|;
name|uint8_t
name|dir_in
decl_stmt|;
name|uint8_t
name|dir_out
decl_stmt|;
name|distance
operator|=
literal|0xFFFF
expr_stmt|;
name|best_n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ep
operator|->
name|needs_in
operator|)
operator|&&
operator|(
operator|!
name|ep
operator|->
name|needs_out
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are done */
block|}
if|if
condition|(
name|ep
operator|->
name|needs_ep_type
operator|==
name|UE_CONTROL
condition|)
block|{
name|dir_in
operator|=
literal|1
expr_stmt|;
name|dir_out
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ep
operator|->
name|needs_in
condition|)
block|{
name|dir_in
operator|=
literal|1
expr_stmt|;
name|dir_out
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dir_in
operator|=
literal|0
expr_stmt|;
name|dir_out
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|!=
operator|(
name|USB_EP_MAX
operator|/
literal|2
operator|)
condition|;
name|n
operator|++
control|)
block|{
comment|/* get HW endpoint profile */
call|(
name|ues
operator|->
name|methods
operator|->
name|get_hw_ep_profile
call|)
argument_list|(
name|ues
operator|->
name|udev
argument_list|,
operator|&
name|pf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
block|{
comment|/* end of profiles */
break|break;
block|}
comment|/* check if IN-endpoint is reserved */
if|if
condition|(
name|dir_in
operator|||
name|pf
operator|->
name|is_simplex
condition|)
block|{
if|if
condition|(
name|ues
operator|->
name|bmInAlloc
index|[
name|n
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
comment|/* mismatch */
continue|continue;
block|}
block|}
comment|/* check if OUT-endpoint is reserved */
if|if
condition|(
name|dir_out
operator|||
name|pf
operator|->
name|is_simplex
condition|)
block|{
if|if
condition|(
name|ues
operator|->
name|bmOutAlloc
index|[
name|n
operator|/
literal|8
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|n
operator|%
literal|8
operator|)
operator|)
condition|)
block|{
comment|/* mismatch */
continue|continue;
block|}
block|}
comment|/* check simplex */
if|if
condition|(
name|pf
operator|->
name|is_simplex
operator|==
name|is_simplex
condition|)
block|{
comment|/* mismatch */
continue|continue;
block|}
comment|/* check if HW endpoint matches */
if|if
condition|(
operator|!
name|usb_hw_ep_match
argument_list|(
name|pf
argument_list|,
name|ep
operator|->
name|needs_ep_type
argument_list|,
name|dir_in
argument_list|)
condition|)
block|{
comment|/* mismatch */
continue|continue;
block|}
comment|/* get maximum frame size */
if|if
condition|(
name|dir_in
condition|)
name|max_frame_size
operator|=
name|pf
operator|->
name|max_in_frame_size
expr_stmt|;
else|else
name|max_frame_size
operator|=
name|pf
operator|->
name|max_out_frame_size
expr_stmt|;
comment|/* check if we have a matching profile */
if|if
condition|(
name|max_frame_size
operator|>=
name|ep
operator|->
name|max_frame_size
condition|)
block|{
name|temp
operator|=
operator|(
name|max_frame_size
operator|-
name|ep
operator|->
name|max_frame_size
operator|)
expr_stmt|;
if|if
condition|(
name|distance
operator|>
name|temp
condition|)
block|{
name|distance
operator|=
name|temp
expr_stmt|;
name|best_n
operator|=
name|n
expr_stmt|;
name|ep
operator|->
name|pf
operator|=
name|pf
expr_stmt|;
block|}
block|}
block|}
comment|/* see if we got a match */
if|if
condition|(
name|best_n
operator|!=
literal|0
condition|)
block|{
comment|/* get the correct profile */
name|pf
operator|=
name|ep
operator|->
name|pf
expr_stmt|;
comment|/* reserve IN-endpoint */
if|if
condition|(
name|dir_in
condition|)
block|{
name|ues
operator|->
name|bmInAlloc
index|[
name|best_n
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|best_n
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|ep
operator|->
name|hw_endpoint_in
operator|=
name|best_n
operator||
name|UE_DIR_IN
expr_stmt|;
name|ep
operator|->
name|needs_in
operator|=
literal|0
expr_stmt|;
block|}
comment|/* reserve OUT-endpoint */
if|if
condition|(
name|dir_out
condition|)
block|{
name|ues
operator|->
name|bmOutAlloc
index|[
name|best_n
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|best_n
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|ep
operator|->
name|hw_endpoint_out
operator|=
name|best_n
operator||
name|UE_DIR_OUT
expr_stmt|;
name|ep
operator|->
name|needs_out
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* got a match */
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_hw_ep_get_needs  *  * This function will figure out the type and number of endpoints  * which are needed for an USB configuration.  *  * Return values:  *    0: Success.  * Else: Failure.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint8_t
name|usb_hw_ep_get_needs
parameter_list|(
name|struct
name|usb_hw_ep_scratch
modifier|*
name|ues
parameter_list|,
name|uint8_t
name|ep_type
parameter_list|,
name|uint8_t
name|is_complete
parameter_list|)
block|{
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
name|pf
decl_stmt|;
name|struct
name|usb_hw_ep_scratch_sub
modifier|*
name|ep_iface
decl_stmt|;
name|struct
name|usb_hw_ep_scratch_sub
modifier|*
name|ep_curr
decl_stmt|;
name|struct
name|usb_hw_ep_scratch_sub
modifier|*
name|ep_max
decl_stmt|;
name|struct
name|usb_hw_ep_scratch_sub
modifier|*
name|ep_end
decl_stmt|;
name|struct
name|usb_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ed
decl_stmt|;
name|enum
name|usb_dev_speed
name|speed
decl_stmt|;
name|uint16_t
name|wMaxPacketSize
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|uint8_t
name|ep_no
decl_stmt|;
name|ep_iface
operator|=
name|ues
operator|->
name|ep_max
expr_stmt|;
name|ep_curr
operator|=
name|ues
operator|->
name|ep_max
expr_stmt|;
name|ep_end
operator|=
name|ues
operator|->
name|ep
operator|+
name|USB_EP_MAX
expr_stmt|;
name|ep_max
operator|=
name|ues
operator|->
name|ep_max
expr_stmt|;
name|desc
operator|=
name|NULL
expr_stmt|;
name|speed
operator|=
name|usbd_get_speed
argument_list|(
name|ues
operator|->
name|udev
argument_list|)
expr_stmt|;
name|repeat
label|:
while|while
condition|(
operator|(
name|desc
operator|=
name|usb_desc_foreach
argument_list|(
name|ues
operator|->
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_INTERFACE
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
operator|)
condition|)
block|{
name|id
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|bAlternateSetting
operator|==
literal|0
condition|)
block|{
comment|/* going forward */
name|ep_iface
operator|=
name|ep_max
expr_stmt|;
block|}
else|else
block|{
comment|/* reset */
name|ep_curr
operator|=
name|ep_iface
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_ENDPOINT
operator|)
operator|&&
operator|(
name|desc
operator|->
name|bLength
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
operator|)
condition|)
block|{
name|ed
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
goto|goto
name|handle_endpoint_desc
goto|;
block|}
block|}
name|ues
operator|->
name|ep_max
operator|=
name|ep_max
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|handle_endpoint_desc
label|:
name|temp
operator|=
operator|(
name|ed
operator|->
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|ep_type
condition|)
block|{
if|if
condition|(
name|ep_curr
operator|==
name|ep_end
condition|)
block|{
comment|/* too many endpoints */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
name|wMaxPacketSize
operator|=
name|UGETW
argument_list|(
name|ed
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wMaxPacketSize
operator|&
literal|0xF800
operator|)
operator|&&
operator|(
name|speed
operator|==
name|USB_SPEED_HIGH
operator|)
condition|)
block|{
comment|/* handle packet multiplier */
name|temp
operator|=
operator|(
name|wMaxPacketSize
operator|>>
literal|11
operator|)
operator|&
literal|3
expr_stmt|;
name|wMaxPacketSize
operator|&=
literal|0x7FF
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|1
condition|)
block|{
name|wMaxPacketSize
operator|*=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|wMaxPacketSize
operator|*=
literal|3
expr_stmt|;
block|}
block|}
comment|/* 		 * Check if we have a fixed endpoint number, else the 		 * endpoint number is allocated dynamically: 		 */
name|ep_no
operator|=
operator|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_ADDR
operator|)
expr_stmt|;
if|if
condition|(
name|ep_no
operator|!=
literal|0
condition|)
block|{
comment|/* get HW endpoint profile */
call|(
name|ues
operator|->
name|methods
operator|->
name|get_hw_ep_profile
call|)
argument_list|(
name|ues
operator|->
name|udev
argument_list|,
operator|&
name|pf
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
block|{
comment|/* HW profile does not exist - failure */
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Endpoint profile %u "
literal|"does not exist\n"
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* reserve fixed endpoint number */
if|if
condition|(
name|ep_type
operator|==
name|UE_CONTROL
condition|)
block|{
name|ues
operator|->
name|bmInAlloc
index|[
name|ep_no
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|ep_no
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
name|ues
operator|->
name|bmOutAlloc
index|[
name|ep_no
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|ep_no
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pf
operator|->
name|max_in_frame_size
operator|<
name|wMaxPacketSize
operator|)
operator|||
operator|(
name|pf
operator|->
name|max_out_frame_size
operator|<
name|wMaxPacketSize
operator|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Endpoint profile %u "
literal|"has too small buffer\n"
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_DIR_IN
condition|)
block|{
name|ues
operator|->
name|bmInAlloc
index|[
name|ep_no
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|ep_no
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|max_in_frame_size
operator|<
name|wMaxPacketSize
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Endpoint profile %u "
literal|"has too small buffer\n"
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|ues
operator|->
name|bmOutAlloc
index|[
name|ep_no
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|ep_no
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|max_out_frame_size
operator|<
name|wMaxPacketSize
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Endpoint profile %u "
literal|"has too small buffer\n"
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|is_complete
condition|)
block|{
comment|/* check if we have enough buffer space */
if|if
condition|(
name|wMaxPacketSize
operator|>
name|ep_curr
operator|->
name|max_frame_size
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* failure */
block|}
if|if
condition|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_DIR_IN
condition|)
block|{
name|ed
operator|->
name|bEndpointAddress
operator|=
name|ep_curr
operator|->
name|hw_endpoint_in
expr_stmt|;
block|}
else|else
block|{
name|ed
operator|->
name|bEndpointAddress
operator|=
name|ep_curr
operator|->
name|hw_endpoint_out
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* compute the maximum frame size */
if|if
condition|(
name|ep_curr
operator|->
name|max_frame_size
operator|<
name|wMaxPacketSize
condition|)
block|{
name|ep_curr
operator|->
name|max_frame_size
operator|=
name|wMaxPacketSize
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|==
name|UE_CONTROL
condition|)
block|{
name|ep_curr
operator|->
name|needs_in
operator|=
literal|1
expr_stmt|;
name|ep_curr
operator|->
name|needs_out
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ed
operator|->
name|bEndpointAddress
operator|&
name|UE_DIR_IN
condition|)
block|{
name|ep_curr
operator|->
name|needs_in
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ep_curr
operator|->
name|needs_out
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ep_curr
operator|->
name|needs_ep_type
operator|=
name|ep_type
expr_stmt|;
block|}
name|ep_curr
operator|++
expr_stmt|;
if|if
condition|(
name|ep_max
operator|<
name|ep_curr
condition|)
block|{
name|ep_max
operator|=
name|ep_curr
expr_stmt|;
block|}
block|}
goto|goto
name|repeat
goto|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_hw_ep_resolve  *  * This function will try to resolve endpoint requirements by the  * given endpoint profiles that the USB hardware reports.  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|usb_hw_ep_resolve
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_descriptor
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|usb_hw_ep_scratch
modifier|*
name|ues
decl_stmt|;
name|struct
name|usb_hw_ep_scratch_sub
modifier|*
name|ep
decl_stmt|;
specifier|const
name|struct
name|usb_hw_ep_profile
modifier|*
name|pf
decl_stmt|;
specifier|const
name|struct
name|usb_bus_methods
modifier|*
name|methods
decl_stmt|;
name|struct
name|usb_device_descriptor
modifier|*
name|dd
decl_stmt|;
name|uint16_t
name|mps
decl_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
comment|/* get bus methods */
name|methods
operator|=
name|udev
operator|->
name|bus
operator|->
name|methods
expr_stmt|;
if|if
condition|(
name|methods
operator|->
name|get_hw_ep_profile
operator|==
name|NULL
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|bDescriptorType
operator|==
name|UDESC_DEVICE
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|bLength
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
name|dd
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
comment|/* get HW control endpoint 0 profile */
call|(
name|methods
operator|->
name|get_hw_ep_profile
call|)
argument_list|(
name|udev
argument_list|,
operator|&
name|pf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|usb_hw_ep_match
argument_list|(
name|pf
argument_list|,
name|UE_CONTROL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Endpoint 0 does not "
literal|"support control\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
name|mps
operator|=
name|dd
operator|->
name|bMaxPacketSize
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
block|{
comment|/* 			 * We can optionally choose another packet size ! 			 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* check if "mps" is ok */
if|if
condition|(
name|pf
operator|->
name|max_in_frame_size
operator|>=
name|mps
condition|)
block|{
break|break;
block|}
comment|/* reduce maximum packet size */
name|mps
operator|/=
literal|2
expr_stmt|;
comment|/* check if "mps" is too small */
if|if
condition|(
name|mps
operator|<
literal|8
condition|)
block|{
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
block|}
name|dd
operator|->
name|bMaxPacketSize
operator|=
name|mps
expr_stmt|;
block|}
else|else
block|{
comment|/* We only have one choice */
if|if
condition|(
name|mps
operator|==
literal|255
condition|)
block|{
name|mps
operator|=
literal|512
expr_stmt|;
block|}
comment|/* Check if we support the specified wMaxPacketSize */
if|if
condition|(
name|pf
operator|->
name|max_in_frame_size
operator|<
name|mps
condition|)
block|{
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
if|if
condition|(
name|desc
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CONFIG
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|bLength
operator|<
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ues
operator|->
name|cd
operator|)
argument_list|)
condition|)
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
name|ues
operator|=
name|udev
operator|->
name|scratch
operator|.
name|hw_ep_scratch
expr_stmt|;
name|memset
argument_list|(
name|ues
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ues
argument_list|)
argument_list|)
expr_stmt|;
name|ues
operator|->
name|ep_max
operator|=
name|ues
operator|->
name|ep
expr_stmt|;
name|ues
operator|->
name|cd
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
name|ues
operator|->
name|methods
operator|=
name|methods
expr_stmt|;
name|ues
operator|->
name|udev
operator|=
name|udev
expr_stmt|;
comment|/* Get all the endpoints we need */
if|if
condition|(
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_ISOCHRONOUS
argument_list|,
literal|0
argument_list|)
operator|||
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_INTERRUPT
argument_list|,
literal|0
argument_list|)
operator|||
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_CONTROL
argument_list|,
literal|0
argument_list|)
operator|||
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_BULK
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Could not get needs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
for|for
control|(
name|ep
operator|=
name|ues
operator|->
name|ep
init|;
name|ep
operator|!=
name|ues
operator|->
name|ep_max
condition|;
name|ep
operator|++
control|)
block|{
while|while
condition|(
name|ep
operator|->
name|needs_in
operator|||
name|ep
operator|->
name|needs_out
condition|)
block|{
comment|/* 		         * First try to use a simplex endpoint. 		         * Then try to use a duplex endpoint. 		         */
if|if
condition|(
name|usb_hw_ep_find_match
argument_list|(
name|ues
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
operator|&&
name|usb_hw_ep_find_match
argument_list|(
name|ues
argument_list|,
name|ep
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Could not find match\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
block|}
block|}
name|ues
operator|->
name|ep_max
operator|=
name|ues
operator|->
name|ep
expr_stmt|;
comment|/* Update all endpoint addresses */
if|if
condition|(
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_ISOCHRONOUS
argument_list|,
literal|1
argument_list|)
operator|||
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_INTERRUPT
argument_list|,
literal|1
argument_list|)
operator|||
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_CONTROL
argument_list|,
literal|1
argument_list|)
operator|||
name|usb_hw_ep_get_needs
argument_list|(
name|ues
argument_list|,
name|UE_BULK
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Could not update endpoint address\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_tdd  *  * Returns:  *  NULL: No USB template device descriptor found.  *  Else: Pointer to the USB template device descriptor.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|usb_temp_device_desc
modifier|*
name|usb_temp_get_tdd
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
if|if
condition|(
name|udev
operator|->
name|usb_template_ptr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|udev
operator|->
name|usb_template_ptr
operator|->
name|tdd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_device_desc  *  * Returns:  *  NULL: No USB device descriptor found.  *  Else: Pointer to USB device descriptor.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|usb_temp_get_device_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_device_descriptor
modifier|*
name|dd
decl_stmt|;
if|if
condition|(
name|udev
operator|->
name|usb_template_ptr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dd
operator|=
operator|&
name|udev
operator|->
name|usb_template_ptr
operator|->
name|udd
expr_stmt|;
if|if
condition|(
name|dd
operator|->
name|bDescriptorType
operator|!=
name|UDESC_DEVICE
condition|)
block|{
comment|/* sanity check failed */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_qualifier_desc  *  * Returns:  *  NULL: No USB device_qualifier descriptor found.  *  Else: Pointer to USB device_qualifier descriptor.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|usb_temp_get_qualifier_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_device_qualifier
modifier|*
name|dq
decl_stmt|;
if|if
condition|(
name|udev
operator|->
name|usb_template_ptr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dq
operator|=
operator|&
name|udev
operator|->
name|usb_template_ptr
operator|->
name|udq
expr_stmt|;
if|if
condition|(
name|dq
operator|->
name|bDescriptorType
operator|!=
name|UDESC_DEVICE_QUALIFIER
condition|)
block|{
comment|/* sanity check failed */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_config_desc  *  * Returns:  *  NULL: No USB config descriptor found.  *  Else: Pointer to USB config descriptor having index "index".  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|usb_temp_get_config_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint16_t
modifier|*
name|pLength
parameter_list|,
name|uint8_t
name|index
parameter_list|)
block|{
name|struct
name|usb_device_descriptor
modifier|*
name|dd
decl_stmt|;
name|struct
name|usb_config_descriptor
modifier|*
name|cd
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
if|if
condition|(
name|udev
operator|->
name|usb_template_ptr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dd
operator|=
operator|&
name|udev
operator|->
name|usb_template_ptr
operator|->
name|udd
expr_stmt|;
name|cd
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|udev
operator|->
name|usb_template_ptr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|dd
operator|->
name|bNumConfigurations
condition|)
block|{
comment|/* out of range */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
name|index
operator|--
condition|)
block|{
if|if
condition|(
name|cd
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CONFIG
condition|)
block|{
comment|/* sanity check failed */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|temp
operator|=
name|UGETW
argument_list|(
name|cd
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
name|cd
operator|=
name|USB_ADD_BYTES
argument_list|(
name|cd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pLength
condition|)
block|{
operator|*
name|pLength
operator|=
name|UGETW
argument_list|(
name|cd
operator|->
name|wTotalLength
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_vendor_desc  *  * Returns:  *  NULL: No vendor descriptor found.  *  Else: Pointer to a vendor descriptor.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|usb_temp_get_vendor_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
specifier|const
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
name|uint16_t
modifier|*
name|plen
parameter_list|)
block|{
specifier|const
name|struct
name|usb_temp_device_desc
modifier|*
name|tdd
decl_stmt|;
name|tdd
operator|=
name|usb_temp_get_tdd
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdd
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|tdd
operator|->
name|getVendorDesc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
call|(
name|tdd
operator|->
name|getVendorDesc
call|)
argument_list|(
name|req
argument_list|,
name|plen
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_string_desc  *  * Returns:  *  NULL: No string descriptor found.  *  Else: Pointer to a string descriptor.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|usb_temp_get_string_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint16_t
name|lang_id
parameter_list|,
name|uint8_t
name|string_index
parameter_list|)
block|{
specifier|const
name|struct
name|usb_temp_device_desc
modifier|*
name|tdd
decl_stmt|;
name|tdd
operator|=
name|usb_temp_get_tdd
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdd
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|tdd
operator|->
name|getStringDesc
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
call|(
name|tdd
operator|->
name|getStringDesc
call|)
argument_list|(
name|lang_id
argument_list|,
name|string_index
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_hub_desc  *  * Returns:  *  NULL: No USB HUB descriptor found.  *  Else: Pointer to a USB HUB descriptor.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|usb_temp_get_hub_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* needs to be implemented */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_get_desc  *  * This function is a demultiplexer for local USB device side control  * endpoint requests.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|usb_error_t
name|usb_temp_get_desc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_device_request
modifier|*
name|req
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|pPtr
parameter_list|,
name|uint16_t
modifier|*
name|pLength
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|req
operator|->
name|bmRequestType
condition|)
block|{
case|case
name|UT_READ_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_DESCRIPTOR
case|:
goto|goto
name|tr_handle_get_descriptor
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
case|case
name|UT_READ_CLASS_DEVICE
case|:
switch|switch
condition|(
name|req
operator|->
name|bRequest
condition|)
block|{
case|case
name|UR_GET_DESCRIPTOR
case|:
goto|goto
name|tr_handle_get_class_descriptor
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
name|tr_handle_get_descriptor
label|:
switch|switch
condition|(
name|req
operator|->
name|wValue
index|[
literal|1
index|]
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
if|if
condition|(
name|req
operator|->
name|wValue
index|[
literal|0
index|]
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|buf
operator|=
name|usb_temp_get_device_desc
argument_list|(
name|udev
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
name|UDESC_DEVICE_QUALIFIER
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_HIGH
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
if|if
condition|(
name|req
operator|->
name|wValue
index|[
literal|0
index|]
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|buf
operator|=
name|usb_temp_get_qualifier_desc
argument_list|(
name|udev
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
name|UDESC_OTHER_SPEED_CONFIGURATION
case|:
if|if
condition|(
name|udev
operator|->
name|speed
operator|!=
name|USB_SPEED_HIGH
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
case|case
name|UDESC_CONFIG
case|:
name|buf
operator|=
name|usb_temp_get_config_desc
argument_list|(
name|udev
argument_list|,
operator|&
name|len
argument_list|,
name|req
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
case|case
name|UDESC_STRING
case|:
name|buf
operator|=
name|usb_temp_get_string_desc
argument_list|(
name|udev
argument_list|,
name|UGETW
argument_list|(
name|req
operator|->
name|wIndex
argument_list|)
argument_list|,
name|req
operator|->
name|wValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
default|default:
goto|goto
name|tr_stalled
goto|;
block|}
name|tr_handle_get_class_descriptor
label|:
if|if
condition|(
name|req
operator|->
name|wValue
index|[
literal|0
index|]
condition|)
block|{
goto|goto
name|tr_stalled
goto|;
block|}
name|buf
operator|=
name|usb_temp_get_hub_desc
argument_list|(
name|udev
argument_list|)
expr_stmt|;
goto|goto
name|tr_valid
goto|;
name|tr_valid
label|:
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|tr_stalled
goto|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|pPtr
operator|=
name|buf
expr_stmt|;
operator|*
name|pLength
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
name|tr_stalled
label|:
comment|/* try to get a vendor specific descriptor */
name|len
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|usb_temp_get_vendor_desc
argument_list|(
name|udev
argument_list|,
name|req
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
goto|goto
name|tr_valid
goto|;
operator|*
name|pPtr
operator|=
name|NULL
expr_stmt|;
operator|*
name|pLength
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we ignore failures */
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_setup  *  * This function generates USB descriptors according to the given USB  * template device descriptor. It will also try to figure out the best  * matching endpoint addresses using the hardware endpoint profiles.  *  * Returns:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|usb_error_t
name|usb_temp_setup
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
specifier|const
name|struct
name|usb_temp_device_desc
modifier|*
name|tdd
parameter_list|)
block|{
name|struct
name|usb_temp_setup
modifier|*
name|uts
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|usb_error_t
name|error
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
comment|/* be NULL safe */
if|if
condition|(
name|tdd
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Protect scratch area */
name|do_unlock
operator|=
name|usbd_enum_lock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|uts
operator|=
name|udev
operator|->
name|scratch
operator|.
name|temp_setup
expr_stmt|;
name|memset
argument_list|(
name|uts
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uts
argument_list|)
argument_list|)
expr_stmt|;
name|uts
operator|->
name|usb_speed
operator|=
name|udev
operator|->
name|speed
expr_stmt|;
name|uts
operator|->
name|self_powered
operator|=
name|udev
operator|->
name|flags
operator|.
name|self_powered
expr_stmt|;
comment|/* first pass */
name|usb_make_device_desc
argument_list|(
name|uts
argument_list|,
name|tdd
argument_list|)
expr_stmt|;
if|if
condition|(
name|uts
operator|->
name|err
condition|)
block|{
comment|/* some error happened */
goto|goto
name|done
goto|;
block|}
comment|/* sanity check */
if|if
condition|(
name|uts
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|uts
operator|->
name|err
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* allocate zeroed memory */
name|uts
operator|->
name|buf
operator|=
name|usbd_alloc_config_desc
argument_list|(
name|udev
argument_list|,
name|uts
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Allow malloc() to return NULL regardless of M_WAITOK flag. 	 * This helps when porting the software to non-FreeBSD 	 * systems. 	 */
if|if
condition|(
name|uts
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* could not allocate memory */
name|uts
operator|->
name|err
operator|=
name|USB_ERR_NOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* second pass */
name|uts
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|usb_make_device_desc
argument_list|(
name|uts
argument_list|,
name|tdd
argument_list|)
expr_stmt|;
comment|/* 	 * Store a pointer to our descriptors: 	 */
name|udev
operator|->
name|usb_template_ptr
operator|=
name|uts
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|uts
operator|->
name|err
condition|)
block|{
comment|/* some error happened during second pass */
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Resolve all endpoint addresses ! 	 */
name|buf
operator|=
name|usb_temp_get_device_desc
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|uts
operator|->
name|err
operator|=
name|usb_hw_ep_resolve
argument_list|(
name|udev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uts
operator|->
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Could not resolve endpoints for "
literal|"Device Descriptor, error = %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|uts
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
name|n
operator|++
control|)
block|{
name|buf
operator|=
name|usb_temp_get_config_desc
argument_list|(
name|udev
argument_list|,
name|NULL
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|uts
operator|->
name|err
operator|=
name|usb_hw_ep_resolve
argument_list|(
name|udev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uts
operator|->
name|err
condition|)
block|{
name|DPRINTFN
argument_list|(
literal|0
argument_list|,
literal|"Could not resolve endpoints for "
literal|"Config Descriptor %u, error = %s\n"
argument_list|,
name|n
argument_list|,
name|usbd_errstr
argument_list|(
name|uts
operator|->
name|err
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|error
operator|=
name|uts
operator|->
name|err
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|usb_temp_unsetup
argument_list|(
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
name|usbd_enum_unlock
argument_list|(
name|udev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_temp_unsetup  *  * This function frees any memory associated with the currently  * setup template, if any.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_temp_unsetup
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|)
block|{
name|usbd_free_config_desc
argument_list|(
name|udev
argument_list|,
name|udev
operator|->
name|usb_template_ptr
argument_list|)
expr_stmt|;
name|udev
operator|->
name|usb_template_ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|usb_temp_setup_by_index
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|uint16_t
name|index
parameter_list|)
block|{
name|usb_error_t
name|err
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|USB_TEMP_MSC
case|:
name|err
operator|=
name|usb_temp_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|usb_template_msc
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_TEMP_CDCE
case|:
name|err
operator|=
name|usb_temp_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|usb_template_cdce
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_TEMP_MTP
case|:
name|err
operator|=
name|usb_temp_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|usb_template_mtp
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_TEMP_MODEM
case|:
name|err
operator|=
name|usb_temp_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|usb_template_modem
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_TEMP_AUDIO
case|:
name|err
operator|=
name|usb_temp_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|usb_template_audio
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_TEMP_KBD
case|:
name|err
operator|=
name|usb_temp_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|usb_template_kbd
argument_list|)
expr_stmt|;
break|break;
case|case
name|USB_TEMP_MOUSE
case|:
name|err
operator|=
name|usb_temp_setup
argument_list|(
name|udev
argument_list|,
operator|&
name|usb_template_mouse
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_temp_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* register our functions */
name|usb_temp_get_desc_p
operator|=
operator|&
name|usb_temp_get_desc
expr_stmt|;
name|usb_temp_setup_by_index_p
operator|=
operator|&
name|usb_temp_setup_by_index
expr_stmt|;
name|usb_temp_unsetup_p
operator|=
operator|&
name|usb_temp_unsetup
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usb_temp_init
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|usb_temp_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|usb_temp_unload
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|usb_temp_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

