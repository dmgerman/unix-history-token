begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright Â© 1997-2003 by The XFree86 Project, Inc.  * Copyright Â© 2007 Dave Airlie  * Copyright Â© 2007-2008 Intel Corporation  *   Jesse Barnes<jesse.barnes@intel.com>  * Copyright 2005-2006 Luc Verhaegen  * Copyright (c) 2001, Andy Ritger  aritger@nvidia.com  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Except as contained in this notice, the name of the copyright holder(s)  * and author(s) shall not be used in advertising or otherwise to promote  * the sale, use or other dealings in this Software without prior written  * authorization from the copyright holder(s) and author(s).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc.h>
end_include

begin_define
define|#
directive|define
name|KHZ2PICOS
parameter_list|(
name|a
parameter_list|)
value|(1000000000UL/(a))
end_define

begin_comment
comment|/**  * drm_mode_debug_printmodeline - debug print a mode  * @dev: DRM device  * @mode: mode to print  *  * LOCKING:  * None.  *  * Describe @mode using DRM_DEBUG.  */
end_comment

begin_function
name|void
name|drm_mode_debug_printmodeline
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"Modeline %d:\"%s\" %d %d %d %d %d %d %d %d %d %d "
literal|"0x%x 0x%x\n"
argument_list|,
name|mode
operator|->
name|base
operator|.
name|id
argument_list|,
name|mode
operator|->
name|name
argument_list|,
name|mode
operator|->
name|vrefresh
argument_list|,
name|mode
operator|->
name|clock
argument_list|,
name|mode
operator|->
name|hdisplay
argument_list|,
name|mode
operator|->
name|hsync_start
argument_list|,
name|mode
operator|->
name|hsync_end
argument_list|,
name|mode
operator|->
name|htotal
argument_list|,
name|mode
operator|->
name|vdisplay
argument_list|,
name|mode
operator|->
name|vsync_start
argument_list|,
name|mode
operator|->
name|vsync_end
argument_list|,
name|mode
operator|->
name|vtotal
argument_list|,
name|mode
operator|->
name|type
argument_list|,
name|mode
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_cvt_mode -create a modeline based on CVT algorithm  * @dev: DRM device  * @hdisplay: hdisplay size  * @vdisplay: vdisplay size  * @vrefresh  : vrefresh rate  * @reduced : Whether the GTF calculation is simplified  * @interlaced:Whether the interlace is supported  *  * LOCKING:  * none.  *  * return the modeline based on CVT algorithm  *  * This function is called to generate the modeline based on CVT algorithm  * according to the hdisplay, vdisplay, vrefresh.  * It is based from the VESA(TM) Coordinated Video Timing Generator by  * Graham Loveridge April 9, 2003 available at  * http://www.elo.utfsm.cl/~elo212/docs/CVTd6r1.xls   *  * And it is copied from xf86CVTmode in xserver/hw/xfree86/modes/xf86cvt.c.  * What I have done is to translate it by using integer calculation.  */
end_comment

begin_define
define|#
directive|define
name|HV_FACTOR
value|1000
end_define

begin_function
name|struct
name|drm_display_mode
modifier|*
name|drm_cvt_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|hdisplay
parameter_list|,
name|int
name|vdisplay
parameter_list|,
name|int
name|vrefresh
parameter_list|,
name|bool
name|reduced
parameter_list|,
name|bool
name|interlaced
parameter_list|,
name|bool
name|margins
parameter_list|)
block|{
comment|/* 1) top/bottom margin size (% of height) - default: 1.8, */
define|#
directive|define
name|CVT_MARGIN_PERCENTAGE
value|18
comment|/* 2) character cell horizontal granularity (pixels) - default 8 */
define|#
directive|define
name|CVT_H_GRANULARITY
value|8
comment|/* 3) Minimum vertical porch (lines) - default 3 */
define|#
directive|define
name|CVT_MIN_V_PORCH
value|3
comment|/* 4) Minimum number of vertical back porch lines - default 6 */
define|#
directive|define
name|CVT_MIN_V_BPORCH
value|6
comment|/* Pixel Clock step (kHz) */
define|#
directive|define
name|CVT_CLOCK_STEP
value|250
name|struct
name|drm_display_mode
modifier|*
name|drm_mode
decl_stmt|;
name|unsigned
name|int
name|vfieldrate
decl_stmt|,
name|hperiod
decl_stmt|;
name|int
name|hdisplay_rnd
decl_stmt|,
name|hmargin
decl_stmt|,
name|vdisplay_rnd
decl_stmt|,
name|vmargin
decl_stmt|,
name|vsync
decl_stmt|;
name|int
name|interlace
decl_stmt|;
comment|/* allocate the drm_display_mode structure. If failure, we will 	 * return directly 	 */
name|drm_mode
operator|=
name|drm_mode_create
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drm_mode
condition|)
return|return
name|NULL
return|;
comment|/* the CVT default refresh rate is 60Hz */
if|if
condition|(
operator|!
name|vrefresh
condition|)
name|vrefresh
operator|=
literal|60
expr_stmt|;
comment|/* the required field fresh rate */
if|if
condition|(
name|interlaced
condition|)
name|vfieldrate
operator|=
name|vrefresh
operator|*
literal|2
expr_stmt|;
else|else
name|vfieldrate
operator|=
name|vrefresh
expr_stmt|;
comment|/* horizontal pixels */
name|hdisplay_rnd
operator|=
name|hdisplay
operator|-
operator|(
name|hdisplay
operator|%
name|CVT_H_GRANULARITY
operator|)
expr_stmt|;
comment|/* determine the left&right borders */
name|hmargin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|margins
condition|)
block|{
name|hmargin
operator|=
name|hdisplay_rnd
operator|*
name|CVT_MARGIN_PERCENTAGE
operator|/
literal|1000
expr_stmt|;
name|hmargin
operator|-=
name|hmargin
operator|%
name|CVT_H_GRANULARITY
expr_stmt|;
block|}
comment|/* find the total active pixels */
name|drm_mode
operator|->
name|hdisplay
operator|=
name|hdisplay_rnd
operator|+
literal|2
operator|*
name|hmargin
expr_stmt|;
comment|/* find the number of lines per field */
if|if
condition|(
name|interlaced
condition|)
name|vdisplay_rnd
operator|=
name|vdisplay
operator|/
literal|2
expr_stmt|;
else|else
name|vdisplay_rnd
operator|=
name|vdisplay
expr_stmt|;
comment|/* find the top& bottom borders */
name|vmargin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|margins
condition|)
name|vmargin
operator|=
name|vdisplay_rnd
operator|*
name|CVT_MARGIN_PERCENTAGE
operator|/
literal|1000
expr_stmt|;
name|drm_mode
operator|->
name|vdisplay
operator|=
name|vdisplay
operator|+
literal|2
operator|*
name|vmargin
expr_stmt|;
comment|/* Interlaced */
if|if
condition|(
name|interlaced
condition|)
name|interlace
operator|=
literal|1
expr_stmt|;
else|else
name|interlace
operator|=
literal|0
expr_stmt|;
comment|/* Determine VSync Width from aspect ratio */
if|if
condition|(
operator|!
operator|(
name|vdisplay
operator|%
literal|3
operator|)
operator|&&
operator|(
operator|(
name|vdisplay
operator|*
literal|4
operator|/
literal|3
operator|)
operator|==
name|hdisplay
operator|)
condition|)
name|vsync
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|vdisplay
operator|%
literal|9
operator|)
operator|&&
operator|(
operator|(
name|vdisplay
operator|*
literal|16
operator|/
literal|9
operator|)
operator|==
name|hdisplay
operator|)
condition|)
name|vsync
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|vdisplay
operator|%
literal|10
operator|)
operator|&&
operator|(
operator|(
name|vdisplay
operator|*
literal|16
operator|/
literal|10
operator|)
operator|==
name|hdisplay
operator|)
condition|)
name|vsync
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|vdisplay
operator|%
literal|4
operator|)
operator|&&
operator|(
operator|(
name|vdisplay
operator|*
literal|5
operator|/
literal|4
operator|)
operator|==
name|hdisplay
operator|)
condition|)
name|vsync
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|vdisplay
operator|%
literal|9
operator|)
operator|&&
operator|(
operator|(
name|vdisplay
operator|*
literal|15
operator|/
literal|9
operator|)
operator|==
name|hdisplay
operator|)
condition|)
name|vsync
operator|=
literal|7
expr_stmt|;
else|else
comment|/* custom */
name|vsync
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|!
name|reduced
condition|)
block|{
comment|/* simplify the GTF calculation */
comment|/* 4) Minimum time of vertical sync + back porch interval (Âµs) 		 * default 550.0 		 */
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
define|#
directive|define
name|CVT_MIN_VSYNC_BP
value|550
comment|/* 3) Nominal HSync width (% of line period) - default 8 */
define|#
directive|define
name|CVT_HSYNC_PERCENTAGE
value|8
name|unsigned
name|int
name|hblank_percentage
decl_stmt|;
name|int
name|vsyncandback_porch
decl_stmt|,
name|vback_porch
decl_stmt|,
name|hblank
decl_stmt|;
comment|/* estimated the horizontal period */
name|tmp1
operator|=
name|HV_FACTOR
operator|*
literal|1000000
operator|-
name|CVT_MIN_VSYNC_BP
operator|*
name|HV_FACTOR
operator|*
name|vfieldrate
expr_stmt|;
name|tmp2
operator|=
operator|(
name|vdisplay_rnd
operator|+
literal|2
operator|*
name|vmargin
operator|+
name|CVT_MIN_V_PORCH
operator|)
operator|*
literal|2
operator|+
name|interlace
expr_stmt|;
name|hperiod
operator|=
name|tmp1
operator|*
literal|2
operator|/
operator|(
name|tmp2
operator|*
name|vfieldrate
operator|)
expr_stmt|;
name|tmp1
operator|=
name|CVT_MIN_VSYNC_BP
operator|*
name|HV_FACTOR
operator|/
name|hperiod
operator|+
literal|1
expr_stmt|;
comment|/* 9. Find number of lines in sync + backporch */
if|if
condition|(
name|tmp1
operator|<
operator|(
name|vsync
operator|+
name|CVT_MIN_V_PORCH
operator|)
condition|)
name|vsyncandback_porch
operator|=
name|vsync
operator|+
name|CVT_MIN_V_PORCH
expr_stmt|;
else|else
name|vsyncandback_porch
operator|=
name|tmp1
expr_stmt|;
comment|/* 10. Find number of lines in back porch */
name|vback_porch
operator|=
name|vsyncandback_porch
operator|-
name|vsync
expr_stmt|;
name|drm_mode
operator|->
name|vtotal
operator|=
name|vdisplay_rnd
operator|+
literal|2
operator|*
name|vmargin
operator|+
name|vsyncandback_porch
operator|+
name|CVT_MIN_V_PORCH
expr_stmt|;
comment|/* 5) Definition of Horizontal blanking time limitation */
comment|/* Gradient (%/kHz) - default 600 */
define|#
directive|define
name|CVT_M_FACTOR
value|600
comment|/* Offset (%) - default 40 */
define|#
directive|define
name|CVT_C_FACTOR
value|40
comment|/* Blanking time scaling factor - default 128 */
define|#
directive|define
name|CVT_K_FACTOR
value|128
comment|/* Scaling factor weighting - default 20 */
define|#
directive|define
name|CVT_J_FACTOR
value|20
define|#
directive|define
name|CVT_M_PRIME
value|(CVT_M_FACTOR * CVT_K_FACTOR / 256)
define|#
directive|define
name|CVT_C_PRIME
value|((CVT_C_FACTOR - CVT_J_FACTOR) * CVT_K_FACTOR / 256 + \ 			 CVT_J_FACTOR)
comment|/* 12. Find ideal blanking duty cycle from formula */
name|hblank_percentage
operator|=
name|CVT_C_PRIME
operator|*
name|HV_FACTOR
operator|-
name|CVT_M_PRIME
operator|*
name|hperiod
operator|/
literal|1000
expr_stmt|;
comment|/* 13. Blanking time */
if|if
condition|(
name|hblank_percentage
operator|<
literal|20
operator|*
name|HV_FACTOR
condition|)
name|hblank_percentage
operator|=
literal|20
operator|*
name|HV_FACTOR
expr_stmt|;
name|hblank
operator|=
name|drm_mode
operator|->
name|hdisplay
operator|*
name|hblank_percentage
operator|/
operator|(
literal|100
operator|*
name|HV_FACTOR
operator|-
name|hblank_percentage
operator|)
expr_stmt|;
name|hblank
operator|-=
name|hblank
operator|%
operator|(
literal|2
operator|*
name|CVT_H_GRANULARITY
operator|)
expr_stmt|;
comment|/* 14. find the total pixes per line */
name|drm_mode
operator|->
name|htotal
operator|=
name|drm_mode
operator|->
name|hdisplay
operator|+
name|hblank
expr_stmt|;
name|drm_mode
operator|->
name|hsync_end
operator|=
name|drm_mode
operator|->
name|hdisplay
operator|+
name|hblank
operator|/
literal|2
expr_stmt|;
name|drm_mode
operator|->
name|hsync_start
operator|=
name|drm_mode
operator|->
name|hsync_end
operator|-
operator|(
name|drm_mode
operator|->
name|htotal
operator|*
name|CVT_HSYNC_PERCENTAGE
operator|)
operator|/
literal|100
expr_stmt|;
name|drm_mode
operator|->
name|hsync_start
operator|+=
name|CVT_H_GRANULARITY
operator|-
name|drm_mode
operator|->
name|hsync_start
operator|%
name|CVT_H_GRANULARITY
expr_stmt|;
comment|/* fill the Vsync values */
name|drm_mode
operator|->
name|vsync_start
operator|=
name|drm_mode
operator|->
name|vdisplay
operator|+
name|CVT_MIN_V_PORCH
expr_stmt|;
name|drm_mode
operator|->
name|vsync_end
operator|=
name|drm_mode
operator|->
name|vsync_start
operator|+
name|vsync
expr_stmt|;
block|}
else|else
block|{
comment|/* Reduced blanking */
comment|/* Minimum vertical blanking interval time (Âµs)- default 460 */
define|#
directive|define
name|CVT_RB_MIN_VBLANK
value|460
comment|/* Fixed number of clocks for horizontal sync */
define|#
directive|define
name|CVT_RB_H_SYNC
value|32
comment|/* Fixed number of clocks for horizontal blanking */
define|#
directive|define
name|CVT_RB_H_BLANK
value|160
comment|/* Fixed number of lines for vertical front porch - default 3*/
define|#
directive|define
name|CVT_RB_VFPORCH
value|3
name|int
name|vbilines
decl_stmt|;
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* 8. Estimate Horizontal period. */
name|tmp1
operator|=
name|HV_FACTOR
operator|*
literal|1000000
operator|-
name|CVT_RB_MIN_VBLANK
operator|*
name|HV_FACTOR
operator|*
name|vfieldrate
expr_stmt|;
name|tmp2
operator|=
name|vdisplay_rnd
operator|+
literal|2
operator|*
name|vmargin
expr_stmt|;
name|hperiod
operator|=
name|tmp1
operator|/
operator|(
name|tmp2
operator|*
name|vfieldrate
operator|)
expr_stmt|;
comment|/* 9. Find number of lines in vertical blanking */
name|vbilines
operator|=
name|CVT_RB_MIN_VBLANK
operator|*
name|HV_FACTOR
operator|/
name|hperiod
operator|+
literal|1
expr_stmt|;
comment|/* 10. Check if vertical blanking is sufficient */
if|if
condition|(
name|vbilines
operator|<
operator|(
name|CVT_RB_VFPORCH
operator|+
name|vsync
operator|+
name|CVT_MIN_V_BPORCH
operator|)
condition|)
name|vbilines
operator|=
name|CVT_RB_VFPORCH
operator|+
name|vsync
operator|+
name|CVT_MIN_V_BPORCH
expr_stmt|;
comment|/* 11. Find total number of lines in vertical field */
name|drm_mode
operator|->
name|vtotal
operator|=
name|vdisplay_rnd
operator|+
literal|2
operator|*
name|vmargin
operator|+
name|vbilines
expr_stmt|;
comment|/* 12. Find total number of pixels in a line */
name|drm_mode
operator|->
name|htotal
operator|=
name|drm_mode
operator|->
name|hdisplay
operator|+
name|CVT_RB_H_BLANK
expr_stmt|;
comment|/* Fill in HSync values */
name|drm_mode
operator|->
name|hsync_end
operator|=
name|drm_mode
operator|->
name|hdisplay
operator|+
name|CVT_RB_H_BLANK
operator|/
literal|2
expr_stmt|;
name|drm_mode
operator|->
name|hsync_start
operator|=
name|drm_mode
operator|->
name|hsync_end
operator|-
name|CVT_RB_H_SYNC
expr_stmt|;
comment|/* Fill in VSync values */
name|drm_mode
operator|->
name|vsync_start
operator|=
name|drm_mode
operator|->
name|vdisplay
operator|+
name|CVT_RB_VFPORCH
expr_stmt|;
name|drm_mode
operator|->
name|vsync_end
operator|=
name|drm_mode
operator|->
name|vsync_start
operator|+
name|vsync
expr_stmt|;
block|}
comment|/* 15/13. Find pixel clock frequency (kHz for xf86) */
name|drm_mode
operator|->
name|clock
operator|=
name|drm_mode
operator|->
name|htotal
operator|*
name|HV_FACTOR
operator|*
literal|1000
operator|/
name|hperiod
expr_stmt|;
name|drm_mode
operator|->
name|clock
operator|-=
name|drm_mode
operator|->
name|clock
operator|%
name|CVT_CLOCK_STEP
expr_stmt|;
comment|/* 18/16. Find actual vertical frame frequency */
comment|/* ignore - just set the mode flag for interlaced */
if|if
condition|(
name|interlaced
condition|)
block|{
name|drm_mode
operator|->
name|vtotal
operator|*=
literal|2
expr_stmt|;
name|drm_mode
operator|->
name|flags
operator||=
name|DRM_MODE_FLAG_INTERLACE
expr_stmt|;
block|}
comment|/* Fill the mode line name */
name|drm_mode_set_name
argument_list|(
name|drm_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduced
condition|)
name|drm_mode
operator|->
name|flags
operator||=
operator|(
name|DRM_MODE_FLAG_PHSYNC
operator||
name|DRM_MODE_FLAG_NVSYNC
operator|)
expr_stmt|;
else|else
name|drm_mode
operator|->
name|flags
operator||=
operator|(
name|DRM_MODE_FLAG_PVSYNC
operator||
name|DRM_MODE_FLAG_NHSYNC
operator|)
expr_stmt|;
return|return
name|drm_mode
return|;
block|}
end_function

begin_comment
comment|/**  * drm_gtf_mode_complex - create the modeline based on full GTF algorithm  *  * @dev		:drm device  * @hdisplay	:hdisplay size  * @vdisplay	:vdisplay size  * @vrefresh	:vrefresh rate.  * @interlaced	:whether the interlace is supported  * @margins	:desired margin size  * @GTF_[MCKJ]  :extended GTF formula parameters  *  * LOCKING.  * none.  *  * return the modeline based on full GTF algorithm.  *  * GTF feature blocks specify C and J in multiples of 0.5, so we pass them  * in here multiplied by two.  For a C of 40, pass in 80.  */
end_comment

begin_function
name|struct
name|drm_display_mode
modifier|*
name|drm_gtf_mode_complex
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|hdisplay
parameter_list|,
name|int
name|vdisplay
parameter_list|,
name|int
name|vrefresh
parameter_list|,
name|bool
name|interlaced
parameter_list|,
name|int
name|margins
parameter_list|,
name|int
name|GTF_M
parameter_list|,
name|int
name|GTF_2C
parameter_list|,
name|int
name|GTF_K
parameter_list|,
name|int
name|GTF_2J
parameter_list|)
block|{
comment|/* 1) top/bottom margin size (% of height) - default: 1.8, */
define|#
directive|define
name|GTF_MARGIN_PERCENTAGE
value|18
comment|/* 2) character cell horizontal granularity (pixels) - default 8 */
define|#
directive|define
name|GTF_CELL_GRAN
value|8
comment|/* 3) Minimum vertical porch (lines) - default 3 */
define|#
directive|define
name|GTF_MIN_V_PORCH
value|1
comment|/* width of vsync in lines */
define|#
directive|define
name|V_SYNC_RQD
value|3
comment|/* width of hsync as % of total line */
define|#
directive|define
name|H_SYNC_PERCENT
value|8
comment|/* min time of vsync + back porch (microsec) */
define|#
directive|define
name|MIN_VSYNC_PLUS_BP
value|550
comment|/* C' and M' are part of the Blanking Duty Cycle computation */
define|#
directive|define
name|GTF_C_PRIME
value|((((GTF_2C - GTF_2J) * GTF_K / 256) + GTF_2J) / 2)
define|#
directive|define
name|GTF_M_PRIME
value|(GTF_K * GTF_M / 256)
name|struct
name|drm_display_mode
modifier|*
name|drm_mode
decl_stmt|;
name|unsigned
name|int
name|hdisplay_rnd
decl_stmt|,
name|vdisplay_rnd
decl_stmt|,
name|vfieldrate_rqd
decl_stmt|;
name|int
name|top_margin
decl_stmt|,
name|bottom_margin
decl_stmt|;
name|int
name|interlace
decl_stmt|;
name|unsigned
name|int
name|hfreq_est
decl_stmt|;
name|int
name|vsync_plus_bp
decl_stmt|,
name|vback_porch
decl_stmt|;
name|unsigned
name|int
name|vtotal_lines
decl_stmt|,
name|vfieldrate_est
decl_stmt|,
name|hperiod
decl_stmt|;
name|unsigned
name|int
name|vfield_rate
decl_stmt|,
name|vframe_rate
decl_stmt|;
name|int
name|left_margin
decl_stmt|,
name|right_margin
decl_stmt|;
name|unsigned
name|int
name|total_active_pixels
decl_stmt|,
name|ideal_duty_cycle
decl_stmt|;
name|unsigned
name|int
name|hblank
decl_stmt|,
name|total_pixels
decl_stmt|,
name|pixel_freq
decl_stmt|;
name|int
name|hsync
decl_stmt|,
name|hfront_porch
decl_stmt|,
name|vodd_front_porch_lines
decl_stmt|;
name|unsigned
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|drm_mode
operator|=
name|drm_mode_create
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drm_mode
condition|)
return|return
name|NULL
return|;
comment|/* 1. In order to give correct results, the number of horizontal 	 * pixels requested is first processed to ensure that it is divisible 	 * by the character size, by rounding it to the nearest character 	 * cell boundary: 	 */
name|hdisplay_rnd
operator|=
operator|(
name|hdisplay
operator|+
name|GTF_CELL_GRAN
operator|/
literal|2
operator|)
operator|/
name|GTF_CELL_GRAN
expr_stmt|;
name|hdisplay_rnd
operator|=
name|hdisplay_rnd
operator|*
name|GTF_CELL_GRAN
expr_stmt|;
comment|/* 2. If interlace is requested, the number of vertical lines assumed 	 * by the calculation must be halved, as the computation calculates 	 * the number of vertical lines per field. 	 */
if|if
condition|(
name|interlaced
condition|)
name|vdisplay_rnd
operator|=
name|vdisplay
operator|/
literal|2
expr_stmt|;
else|else
name|vdisplay_rnd
operator|=
name|vdisplay
expr_stmt|;
comment|/* 3. Find the frame rate required: */
if|if
condition|(
name|interlaced
condition|)
name|vfieldrate_rqd
operator|=
name|vrefresh
operator|*
literal|2
expr_stmt|;
else|else
name|vfieldrate_rqd
operator|=
name|vrefresh
expr_stmt|;
comment|/* 4. Find number of lines in Top margin: */
name|top_margin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|margins
condition|)
name|top_margin
operator|=
operator|(
name|vdisplay_rnd
operator|*
name|GTF_MARGIN_PERCENTAGE
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* 5. Find number of lines in bottom margin: */
name|bottom_margin
operator|=
name|top_margin
expr_stmt|;
comment|/* 6. If interlace is required, then set variable interlace: */
if|if
condition|(
name|interlaced
condition|)
name|interlace
operator|=
literal|1
expr_stmt|;
else|else
name|interlace
operator|=
literal|0
expr_stmt|;
comment|/* 7. Estimate the Horizontal frequency */
block|{
name|tmp1
operator|=
operator|(
literal|1000000
operator|-
name|MIN_VSYNC_PLUS_BP
operator|*
name|vfieldrate_rqd
operator|)
operator|/
literal|500
expr_stmt|;
name|tmp2
operator|=
operator|(
name|vdisplay_rnd
operator|+
literal|2
operator|*
name|top_margin
operator|+
name|GTF_MIN_V_PORCH
operator|)
operator|*
literal|2
operator|+
name|interlace
expr_stmt|;
name|hfreq_est
operator|=
operator|(
name|tmp2
operator|*
literal|1000
operator|*
name|vfieldrate_rqd
operator|)
operator|/
name|tmp1
expr_stmt|;
block|}
comment|/* 8. Find the number of lines in V sync + back porch */
comment|/* [V SYNC+BP] = RINT(([MIN VSYNC+BP] * hfreq_est / 1000000)) */
name|vsync_plus_bp
operator|=
name|MIN_VSYNC_PLUS_BP
operator|*
name|hfreq_est
operator|/
literal|1000
expr_stmt|;
name|vsync_plus_bp
operator|=
operator|(
name|vsync_plus_bp
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/*  9. Find the number of lines in V back porch alone: */
name|vback_porch
operator|=
name|vsync_plus_bp
operator|-
name|V_SYNC_RQD
expr_stmt|;
comment|/*  10. Find the total number of lines in Vertical field period: */
name|vtotal_lines
operator|=
name|vdisplay_rnd
operator|+
name|top_margin
operator|+
name|bottom_margin
operator|+
name|vsync_plus_bp
operator|+
name|GTF_MIN_V_PORCH
expr_stmt|;
comment|/*  11. Estimate the Vertical field frequency: */
name|vfieldrate_est
operator|=
name|hfreq_est
operator|/
name|vtotal_lines
expr_stmt|;
comment|/*  12. Find the actual horizontal period: */
name|hperiod
operator|=
literal|1000000
operator|/
operator|(
name|vfieldrate_rqd
operator|*
name|vtotal_lines
operator|)
expr_stmt|;
comment|/*  13. Find the actual Vertical field frequency: */
name|vfield_rate
operator|=
name|hfreq_est
operator|/
name|vtotal_lines
expr_stmt|;
comment|/*  14. Find the Vertical frame frequency: */
if|if
condition|(
name|interlaced
condition|)
name|vframe_rate
operator|=
name|vfield_rate
operator|/
literal|2
expr_stmt|;
else|else
name|vframe_rate
operator|=
name|vfield_rate
expr_stmt|;
comment|/*  15. Find number of pixels in left margin: */
if|if
condition|(
name|margins
condition|)
name|left_margin
operator|=
operator|(
name|hdisplay_rnd
operator|*
name|GTF_MARGIN_PERCENTAGE
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
else|else
name|left_margin
operator|=
literal|0
expr_stmt|;
comment|/* 16.Find number of pixels in right margin: */
name|right_margin
operator|=
name|left_margin
expr_stmt|;
comment|/* 17.Find total number of active pixels in image and left and right */
name|total_active_pixels
operator|=
name|hdisplay_rnd
operator|+
name|left_margin
operator|+
name|right_margin
expr_stmt|;
comment|/* 18.Find the ideal blanking duty cycle from blanking duty cycle */
name|ideal_duty_cycle
operator|=
name|GTF_C_PRIME
operator|*
literal|1000
operator|-
operator|(
name|GTF_M_PRIME
operator|*
literal|1000000
operator|/
name|hfreq_est
operator|)
expr_stmt|;
comment|/* 19.Find the number of pixels in the blanking time to the nearest 	 * double character cell: */
name|hblank
operator|=
name|total_active_pixels
operator|*
name|ideal_duty_cycle
operator|/
operator|(
literal|100000
operator|-
name|ideal_duty_cycle
operator|)
expr_stmt|;
name|hblank
operator|=
operator|(
name|hblank
operator|+
name|GTF_CELL_GRAN
operator|)
operator|/
operator|(
literal|2
operator|*
name|GTF_CELL_GRAN
operator|)
expr_stmt|;
name|hblank
operator|=
name|hblank
operator|*
literal|2
operator|*
name|GTF_CELL_GRAN
expr_stmt|;
comment|/* 20.Find total number of pixels: */
name|total_pixels
operator|=
name|total_active_pixels
operator|+
name|hblank
expr_stmt|;
comment|/* 21.Find pixel clock frequency: */
name|pixel_freq
operator|=
name|total_pixels
operator|*
name|hfreq_est
operator|/
literal|1000
expr_stmt|;
comment|/* Stage 1 computations are now complete; I should really pass 	 * the results to another function and do the Stage 2 computations, 	 * but I only need a few more values so I'll just append the 	 * computations here for now */
comment|/* 17. Find the number of pixels in the horizontal sync period: */
name|hsync
operator|=
name|H_SYNC_PERCENT
operator|*
name|total_pixels
operator|/
literal|100
expr_stmt|;
name|hsync
operator|=
operator|(
name|hsync
operator|+
name|GTF_CELL_GRAN
operator|/
literal|2
operator|)
operator|/
name|GTF_CELL_GRAN
expr_stmt|;
name|hsync
operator|=
name|hsync
operator|*
name|GTF_CELL_GRAN
expr_stmt|;
comment|/* 18. Find the number of pixels in horizontal front porch period */
name|hfront_porch
operator|=
name|hblank
operator|/
literal|2
operator|-
name|hsync
expr_stmt|;
comment|/*  36. Find the number of lines in the odd front porch period: */
name|vodd_front_porch_lines
operator|=
name|GTF_MIN_V_PORCH
expr_stmt|;
comment|/* finally, pack the results in the mode struct */
name|drm_mode
operator|->
name|hdisplay
operator|=
name|hdisplay_rnd
expr_stmt|;
name|drm_mode
operator|->
name|hsync_start
operator|=
name|hdisplay_rnd
operator|+
name|hfront_porch
expr_stmt|;
name|drm_mode
operator|->
name|hsync_end
operator|=
name|drm_mode
operator|->
name|hsync_start
operator|+
name|hsync
expr_stmt|;
name|drm_mode
operator|->
name|htotal
operator|=
name|total_pixels
expr_stmt|;
name|drm_mode
operator|->
name|vdisplay
operator|=
name|vdisplay_rnd
expr_stmt|;
name|drm_mode
operator|->
name|vsync_start
operator|=
name|vdisplay_rnd
operator|+
name|vodd_front_porch_lines
expr_stmt|;
name|drm_mode
operator|->
name|vsync_end
operator|=
name|drm_mode
operator|->
name|vsync_start
operator|+
name|V_SYNC_RQD
expr_stmt|;
name|drm_mode
operator|->
name|vtotal
operator|=
name|vtotal_lines
expr_stmt|;
name|drm_mode
operator|->
name|clock
operator|=
name|pixel_freq
expr_stmt|;
if|if
condition|(
name|interlaced
condition|)
block|{
name|drm_mode
operator|->
name|vtotal
operator|*=
literal|2
expr_stmt|;
name|drm_mode
operator|->
name|flags
operator||=
name|DRM_MODE_FLAG_INTERLACE
expr_stmt|;
block|}
name|drm_mode_set_name
argument_list|(
name|drm_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GTF_M
operator|==
literal|600
operator|&&
name|GTF_2C
operator|==
literal|80
operator|&&
name|GTF_K
operator|==
literal|128
operator|&&
name|GTF_2J
operator|==
literal|40
condition|)
name|drm_mode
operator|->
name|flags
operator|=
name|DRM_MODE_FLAG_NHSYNC
operator||
name|DRM_MODE_FLAG_PVSYNC
expr_stmt|;
else|else
name|drm_mode
operator|->
name|flags
operator|=
name|DRM_MODE_FLAG_PHSYNC
operator||
name|DRM_MODE_FLAG_NVSYNC
expr_stmt|;
return|return
name|drm_mode
return|;
block|}
end_function

begin_comment
comment|/**  * drm_gtf_mode - create the modeline based on GTF algorithm  *  * @dev		:drm device  * @hdisplay	:hdisplay size  * @vdisplay	:vdisplay size  * @vrefresh	:vrefresh rate.  * @interlaced	:whether the interlace is supported  * @margins	:whether the margin is supported  *  * LOCKING.  * none.  *  * return the modeline based on GTF algorithm  *  * This function is to create the modeline based on the GTF algorithm.  * Generalized Timing Formula is derived from:  *	GTF Spreadsheet by Andy Morrish (1/5/97)  *	available at http://www.vesa.org  *  * And it is copied from the file of xserver/hw/xfree86/modes/xf86gtf.c.  * What I have done is to translate it by using integer calculation.  * I also refer to the function of fb_get_mode in the file of  * drivers/video/fbmon.c  *  * Standard GTF parameters:  * M = 600  * C = 40  * K = 128  * J = 20  */
end_comment

begin_function
name|struct
name|drm_display_mode
modifier|*
name|drm_gtf_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|int
name|hdisplay
parameter_list|,
name|int
name|vdisplay
parameter_list|,
name|int
name|vrefresh
parameter_list|,
name|bool
name|lace
parameter_list|,
name|int
name|margins
parameter_list|)
block|{
return|return
name|drm_gtf_mode_complex
argument_list|(
name|dev
argument_list|,
name|hdisplay
argument_list|,
name|vdisplay
argument_list|,
name|vrefresh
argument_list|,
name|lace
argument_list|,
name|margins
argument_list|,
literal|600
argument_list|,
literal|40
operator|*
literal|2
argument_list|,
literal|128
argument_list|,
literal|20
operator|*
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_set_name - set the name on a mode  * @mode: name will be set in this mode  *  * LOCKING:  * None.  *  * Set the name of @mode to a standard format.  */
end_comment

begin_function
name|void
name|drm_mode_set_name
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|bool
name|interlaced
init|=
operator|!
operator|!
operator|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
operator|)
decl_stmt|;
name|snprintf
argument_list|(
name|mode
operator|->
name|name
argument_list|,
name|DRM_DISPLAY_MODE_LEN
argument_list|,
literal|"%dx%d%s"
argument_list|,
name|mode
operator|->
name|hdisplay
argument_list|,
name|mode
operator|->
name|vdisplay
argument_list|,
name|interlaced
condition|?
literal|"i"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_list_concat - move modes from one list to another  * @head: source list  * @new: dst list  *  * LOCKING:  * Caller must ensure both lists are locked.  *  * Move all the modes from @head to @new.  */
end_comment

begin_function
name|void
name|drm_mode_list_concat
parameter_list|(
name|struct
name|list_head
modifier|*
name|head
parameter_list|,
name|struct
name|list_head
modifier|*
name|new
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_safe
argument_list|(
argument|entry
argument_list|,
argument|tmp
argument_list|,
argument|head
argument_list|)
block|{
name|list_move_tail
argument_list|(
name|entry
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * drm_mode_width - get the width of a mode  * @mode: mode  *  * LOCKING:  * None.  *  * Return @mode's width (hdisplay) value.  *  * FIXME: is this needed?  *  * RETURNS:  * @mode->hdisplay  */
end_comment

begin_function
name|int
name|drm_mode_width
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
return|return
name|mode
operator|->
name|hdisplay
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_height - get the height of a mode  * @mode: mode  *  * LOCKING:  * None.  *  * Return @mode's height (vdisplay) value.  *  * FIXME: is this needed?  *  * RETURNS:  * @mode->vdisplay  */
end_comment

begin_function
name|int
name|drm_mode_height
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
return|return
name|mode
operator|->
name|vdisplay
return|;
block|}
end_function

begin_comment
comment|/** drm_mode_hsync - get the hsync of a mode  * @mode: mode  *  * LOCKING:  * None.  *  * Return @modes's hsync rate in kHz, rounded to the nearest int.  */
end_comment

begin_function
name|int
name|drm_mode_hsync
parameter_list|(
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|calc_val
decl_stmt|;
if|if
condition|(
name|mode
operator|->
name|hsync
condition|)
return|return
name|mode
operator|->
name|hsync
return|;
if|if
condition|(
name|mode
operator|->
name|htotal
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|calc_val
operator|=
operator|(
name|mode
operator|->
name|clock
operator|*
literal|1000
operator|)
operator|/
name|mode
operator|->
name|htotal
expr_stmt|;
comment|/* hsync in Hz */
name|calc_val
operator|+=
literal|500
expr_stmt|;
comment|/* round to 1000Hz */
name|calc_val
operator|/=
literal|1000
expr_stmt|;
comment|/* truncate to kHz */
return|return
name|calc_val
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_vrefresh - get the vrefresh of a mode  * @mode: mode  *  * LOCKING:  * None.  *  * Return @mode's vrefresh rate in Hz or calculate it if necessary.  *  * FIXME: why is this needed?  shouldn't vrefresh be set already?  *  * RETURNS:  * Vertical refresh rate. It will be the result of actual value plus 0.5.  * If it is 70.288, it will return 70Hz.  * If it is 59.6, it will return 60Hz.  */
end_comment

begin_function
name|int
name|drm_mode_vrefresh
parameter_list|(
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|refresh
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|calc_val
decl_stmt|;
if|if
condition|(
name|mode
operator|->
name|vrefresh
operator|>
literal|0
condition|)
name|refresh
operator|=
name|mode
operator|->
name|vrefresh
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|->
name|htotal
operator|>
literal|0
operator|&&
name|mode
operator|->
name|vtotal
operator|>
literal|0
condition|)
block|{
name|int
name|vtotal
decl_stmt|;
name|vtotal
operator|=
name|mode
operator|->
name|vtotal
expr_stmt|;
comment|/* work out vrefresh the value will be x1000 */
name|calc_val
operator|=
operator|(
name|mode
operator|->
name|clock
operator|*
literal|1000
operator|)
expr_stmt|;
name|calc_val
operator|/=
name|mode
operator|->
name|htotal
expr_stmt|;
name|refresh
operator|=
operator|(
name|calc_val
operator|+
name|vtotal
operator|/
literal|2
operator|)
operator|/
name|vtotal
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
name|refresh
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
condition|)
name|refresh
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|vscan
operator|>
literal|1
condition|)
name|refresh
operator|/=
name|mode
operator|->
name|vscan
expr_stmt|;
block|}
return|return
name|refresh
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_set_crtcinfo - set CRTC modesetting parameters  * @p: mode  * @adjust_flags: unused? (FIXME)  *  * LOCKING:  * None.  *  * Setup the CRTC modesetting parameters for @p, adjusting if necessary.  */
end_comment

begin_function
name|void
name|drm_mode_set_crtcinfo
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|p
parameter_list|,
name|int
name|adjust_flags
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|p
operator|->
name|type
operator|&
name|DRM_MODE_TYPE_CRTC_C
operator|)
operator|==
name|DRM_MODE_TYPE_BUILTIN
operator|)
condition|)
return|return;
name|p
operator|->
name|crtc_hdisplay
operator|=
name|p
operator|->
name|hdisplay
expr_stmt|;
name|p
operator|->
name|crtc_hsync_start
operator|=
name|p
operator|->
name|hsync_start
expr_stmt|;
name|p
operator|->
name|crtc_hsync_end
operator|=
name|p
operator|->
name|hsync_end
expr_stmt|;
name|p
operator|->
name|crtc_htotal
operator|=
name|p
operator|->
name|htotal
expr_stmt|;
name|p
operator|->
name|crtc_hskew
operator|=
name|p
operator|->
name|hskew
expr_stmt|;
name|p
operator|->
name|crtc_vdisplay
operator|=
name|p
operator|->
name|vdisplay
expr_stmt|;
name|p
operator|->
name|crtc_vsync_start
operator|=
name|p
operator|->
name|vsync_start
expr_stmt|;
name|p
operator|->
name|crtc_vsync_end
operator|=
name|p
operator|->
name|vsync_end
expr_stmt|;
name|p
operator|->
name|crtc_vtotal
operator|=
name|p
operator|->
name|vtotal
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
block|{
if|if
condition|(
name|adjust_flags
operator|&
name|CRTC_INTERLACE_HALVE_V
condition|)
block|{
name|p
operator|->
name|crtc_vdisplay
operator|/=
literal|2
expr_stmt|;
name|p
operator|->
name|crtc_vsync_start
operator|/=
literal|2
expr_stmt|;
name|p
operator|->
name|crtc_vsync_end
operator|/=
literal|2
expr_stmt|;
name|p
operator|->
name|crtc_vtotal
operator|/=
literal|2
expr_stmt|;
block|}
name|p
operator|->
name|crtc_vtotal
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
condition|)
block|{
name|p
operator|->
name|crtc_vdisplay
operator|*=
literal|2
expr_stmt|;
name|p
operator|->
name|crtc_vsync_start
operator|*=
literal|2
expr_stmt|;
name|p
operator|->
name|crtc_vsync_end
operator|*=
literal|2
expr_stmt|;
name|p
operator|->
name|crtc_vtotal
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|vscan
operator|>
literal|1
condition|)
block|{
name|p
operator|->
name|crtc_vdisplay
operator|*=
name|p
operator|->
name|vscan
expr_stmt|;
name|p
operator|->
name|crtc_vsync_start
operator|*=
name|p
operator|->
name|vscan
expr_stmt|;
name|p
operator|->
name|crtc_vsync_end
operator|*=
name|p
operator|->
name|vscan
expr_stmt|;
name|p
operator|->
name|crtc_vtotal
operator|*=
name|p
operator|->
name|vscan
expr_stmt|;
block|}
name|p
operator|->
name|crtc_vblank_start
operator|=
name|min
argument_list|(
name|p
operator|->
name|crtc_vsync_start
argument_list|,
name|p
operator|->
name|crtc_vdisplay
argument_list|)
expr_stmt|;
name|p
operator|->
name|crtc_vblank_end
operator|=
name|max
argument_list|(
name|p
operator|->
name|crtc_vsync_end
argument_list|,
name|p
operator|->
name|crtc_vtotal
argument_list|)
expr_stmt|;
name|p
operator|->
name|crtc_hblank_start
operator|=
name|min
argument_list|(
name|p
operator|->
name|crtc_hsync_start
argument_list|,
name|p
operator|->
name|crtc_hdisplay
argument_list|)
expr_stmt|;
name|p
operator|->
name|crtc_hblank_end
operator|=
name|max
argument_list|(
name|p
operator|->
name|crtc_hsync_end
argument_list|,
name|p
operator|->
name|crtc_htotal
argument_list|)
expr_stmt|;
name|p
operator|->
name|crtc_hadjusted
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|crtc_vadjusted
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_duplicate - allocate and duplicate an existing mode  * @m: mode to duplicate  *  * LOCKING:  * None.  *  * Just allocate a new mode, copy the existing mode into it, and return  * a pointer to it.  Used to create new instances of established modes.  */
end_comment

begin_function
name|struct
name|drm_display_mode
modifier|*
name|drm_mode_duplicate
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|nmode
decl_stmt|;
name|int
name|new_id
decl_stmt|;
name|nmode
operator|=
name|drm_mode_create
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nmode
condition|)
return|return
name|NULL
return|;
name|new_id
operator|=
name|nmode
operator|->
name|base
operator|.
name|id
expr_stmt|;
operator|*
name|nmode
operator|=
operator|*
name|mode
expr_stmt|;
name|nmode
operator|->
name|base
operator|.
name|id
operator|=
name|new_id
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|nmode
operator|->
name|head
argument_list|)
expr_stmt|;
return|return
name|nmode
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_equal - test modes for equality  * @mode1: first mode  * @mode2: second mode  *  * LOCKING:  * None.  *  * Check to see if @mode1 and @mode2 are equivalent.  *  * RETURNS:  * true if the modes are equal, false otherwise.  */
end_comment

begin_function
name|bool
name|drm_mode_equal
parameter_list|(
name|struct
name|drm_display_mode
modifier|*
name|mode1
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode2
parameter_list|)
block|{
comment|/* do clock check convert to PICOS so fb modes get matched 	 * the same */
if|if
condition|(
name|mode1
operator|->
name|clock
operator|&&
name|mode2
operator|->
name|clock
condition|)
block|{
if|if
condition|(
name|KHZ2PICOS
argument_list|(
name|mode1
operator|->
name|clock
argument_list|)
operator|!=
name|KHZ2PICOS
argument_list|(
name|mode2
operator|->
name|clock
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|mode1
operator|->
name|clock
operator|!=
name|mode2
operator|->
name|clock
condition|)
return|return
name|false
return|;
if|if
condition|(
name|mode1
operator|->
name|hdisplay
operator|==
name|mode2
operator|->
name|hdisplay
operator|&&
name|mode1
operator|->
name|hsync_start
operator|==
name|mode2
operator|->
name|hsync_start
operator|&&
name|mode1
operator|->
name|hsync_end
operator|==
name|mode2
operator|->
name|hsync_end
operator|&&
name|mode1
operator|->
name|htotal
operator|==
name|mode2
operator|->
name|htotal
operator|&&
name|mode1
operator|->
name|hskew
operator|==
name|mode2
operator|->
name|hskew
operator|&&
name|mode1
operator|->
name|vdisplay
operator|==
name|mode2
operator|->
name|vdisplay
operator|&&
name|mode1
operator|->
name|vsync_start
operator|==
name|mode2
operator|->
name|vsync_start
operator|&&
name|mode1
operator|->
name|vsync_end
operator|==
name|mode2
operator|->
name|vsync_end
operator|&&
name|mode1
operator|->
name|vtotal
operator|==
name|mode2
operator|->
name|vtotal
operator|&&
name|mode1
operator|->
name|vscan
operator|==
name|mode2
operator|->
name|vscan
operator|&&
name|mode1
operator|->
name|flags
operator|==
name|mode2
operator|->
name|flags
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_validate_size - make sure modes adhere to size constraints  * @dev: DRM device  * @mode_list: list of modes to check  * @maxX: maximum width  * @maxY: maximum height  * @maxPitch: max pitch  *  * LOCKING:  * Caller must hold a lock protecting @mode_list.  *  * The DRM device (@dev) has size and pitch limits.  Here we validate the  * modes we probed for @dev against those limits and set their status as  * necessary.  */
end_comment

begin_function
name|void
name|drm_mode_validate_size
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|list_head
modifier|*
name|mode_list
parameter_list|,
name|int
name|maxX
parameter_list|,
name|int
name|maxY
parameter_list|,
name|int
name|maxPitch
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|mode_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|maxPitch
operator|>
literal|0
operator|&&
name|mode
operator|->
name|hdisplay
operator|>
name|maxPitch
condition|)
name|mode
operator|->
name|status
operator|=
name|MODE_BAD_WIDTH
expr_stmt|;
if|if
condition|(
name|maxX
operator|>
literal|0
operator|&&
name|mode
operator|->
name|hdisplay
operator|>
name|maxX
condition|)
name|mode
operator|->
name|status
operator|=
name|MODE_VIRTUAL_X
expr_stmt|;
if|if
condition|(
name|maxY
operator|>
literal|0
operator|&&
name|mode
operator|->
name|vdisplay
operator|>
name|maxY
condition|)
name|mode
operator|->
name|status
operator|=
name|MODE_VIRTUAL_Y
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * drm_mode_validate_clocks - validate modes against clock limits  * @dev: DRM device  * @mode_list: list of modes to check  * @min: minimum clock rate array  * @max: maximum clock rate array  * @n_ranges: number of clock ranges (size of arrays)  *  * LOCKING:  * Caller must hold a lock protecting @mode_list.  *  * Some code may need to check a mode list against the clock limits of the  * device in question.  This function walks the mode list, testing to make  * sure each mode falls within a given range (defined by @min and @max  * arrays) and sets @mode->status as needed.  */
end_comment

begin_function
name|void
name|drm_mode_validate_clocks
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|list_head
modifier|*
name|mode_list
parameter_list|,
name|int
modifier|*
name|min
parameter_list|,
name|int
modifier|*
name|max
parameter_list|,
name|int
name|n_ranges
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|mode_list
argument_list|,
argument|head
argument_list|)
block|{
name|bool
name|good
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ranges
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mode
operator|->
name|clock
operator|>=
name|min
index|[
name|i
index|]
operator|&&
name|mode
operator|->
name|clock
operator|<=
name|max
index|[
name|i
index|]
condition|)
block|{
name|good
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|good
condition|)
name|mode
operator|->
name|status
operator|=
name|MODE_CLOCK_RANGE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * drm_mode_prune_invalid - remove invalid modes from mode list  * @dev: DRM device  * @mode_list: list of modes to check  * @verbose: be verbose about it  *  * LOCKING:  * Caller must hold a lock protecting @mode_list.  *  * Once mode list generation is complete, a caller can use this routine to  * remove invalid modes from a mode list.  If any of the modes have a  * status other than %MODE_OK, they are removed from @mode_list and freed.  */
end_comment

begin_function
name|void
name|drm_mode_prune_invalid
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|list_head
modifier|*
name|mode_list
parameter_list|,
name|bool
name|verbose
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mode
argument_list|,
argument|t
argument_list|,
argument|mode_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|mode
operator|->
name|status
operator|!=
name|MODE_OK
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|mode
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|drm_mode_debug_printmodeline
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|DRM_DEBUG_KMS
argument_list|(
literal|"Not using %s mode %d\n"
argument_list|,
name|mode
operator|->
name|name
argument_list|,
name|mode
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|drm_mode_destroy
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * drm_mode_compare - compare modes for favorability  * @priv: unused  * @lh_a: list_head for first mode  * @lh_b: list_head for second mode  *  * LOCKING:  * None.  *  * Compare two modes, given by @lh_a and @lh_b, returning a value indicating  * which is better.  *  * RETURNS:  * Negative if @lh_a is better than @lh_b, zero if they're equivalent, or  * positive if @lh_b is better than @lh_a.  */
end_comment

begin_function
specifier|static
name|int
name|drm_mode_compare
parameter_list|(
name|void
modifier|*
name|priv
parameter_list|,
name|struct
name|list_head
modifier|*
name|lh_a
parameter_list|,
name|struct
name|list_head
modifier|*
name|lh_b
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|a
init|=
name|list_entry
argument_list|(
name|lh_a
argument_list|,
expr|struct
name|drm_display_mode
argument_list|,
name|head
argument_list|)
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|b
init|=
name|list_entry
argument_list|(
name|lh_b
argument_list|,
expr|struct
name|drm_display_mode
argument_list|,
name|head
argument_list|)
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|diff
operator|=
operator|(
operator|(
name|b
operator|->
name|type
operator|&
name|DRM_MODE_TYPE_PREFERRED
operator|)
operator|!=
literal|0
operator|)
operator|-
operator|(
operator|(
name|a
operator|->
name|type
operator|&
name|DRM_MODE_TYPE_PREFERRED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
name|diff
operator|=
name|b
operator|->
name|hdisplay
operator|*
name|b
operator|->
name|vdisplay
operator|-
name|a
operator|->
name|hdisplay
operator|*
name|a
operator|->
name|vdisplay
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
name|diff
operator|=
name|b
operator|->
name|clock
operator|-
name|a
operator|->
name|clock
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_sort - sort mode list  * @mode_list: list to sort  *  * LOCKING:  * Caller must hold a lock protecting @mode_list.  *  * Sort @mode_list by favorability, putting good modes first.  */
end_comment

begin_function
name|void
name|drm_mode_sort
parameter_list|(
name|struct
name|list_head
modifier|*
name|mode_list
parameter_list|)
block|{
name|drm_list_sort
argument_list|(
name|NULL
argument_list|,
name|mode_list
argument_list|,
name|drm_mode_compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * drm_mode_connector_list_update - update the mode list for the connector  * @connector: the connector to update  *  * LOCKING:  * Caller must hold a lock protecting @mode_list.  *  * This moves the modes from the @connector probed_modes list  * to the actual mode list. It compares the probed mode against the current  * list and only adds different modes. All modes unverified after this point  * will be removed by the prune invalid modes.  */
end_comment

begin_function
name|void
name|drm_mode_connector_list_update
parameter_list|(
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|drm_display_mode
modifier|*
name|pmode
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|int
name|found_it
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|pmode
argument_list|,
argument|pt
argument_list|,
argument|&connector->probed_modes
argument_list|,
argument|head
argument_list|)
block|{
name|found_it
operator|=
literal|0
expr_stmt|;
comment|/* go through current modes checking for the new probed mode */
name|list_for_each_entry
argument_list|(
argument|mode
argument_list|,
argument|&connector->modes
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|drm_mode_equal
argument_list|(
name|pmode
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|found_it
operator|=
literal|1
expr_stmt|;
comment|/* if equal delete the probed mode */
name|mode
operator|->
name|status
operator|=
name|pmode
operator|->
name|status
expr_stmt|;
comment|/* Merge type bits together */
name|mode
operator|->
name|type
operator||=
name|pmode
operator|->
name|type
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|pmode
operator|->
name|head
argument_list|)
expr_stmt|;
name|drm_mode_destroy
argument_list|(
name|connector
operator|->
name|dev
argument_list|,
name|pmode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found_it
condition|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|pmode
operator|->
name|head
argument_list|,
operator|&
name|connector
operator|->
name|modes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * drm_mode_parse_command_line_for_connector - parse command line for connector  * @mode_option - per connector mode option  * @connector - connector to parse line for  *  * This parses the connector specific then generic command lines for  * modes and options to configure the connector.  *  * This uses the same parameters as the fb modedb.c, except for extra  *<xres>x<yres>[M][R][-<bpp>][@<refresh>][i][m][eDd]  *  * enable/enable Digital/disable bit at the end  */
end_comment

begin_function
name|bool
name|drm_mode_parse_command_line_for_connector
parameter_list|(
specifier|const
name|char
modifier|*
name|mode_option
parameter_list|,
name|struct
name|drm_connector
modifier|*
name|connector
parameter_list|,
name|struct
name|drm_cmdline_mode
modifier|*
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|namelen
decl_stmt|;
name|bool
name|res_specified
init|=
name|false
decl_stmt|,
name|bpp_specified
init|=
name|false
decl_stmt|,
name|refresh_specified
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|xres
init|=
literal|0
decl_stmt|,
name|yres
init|=
literal|0
decl_stmt|,
name|bpp
init|=
literal|32
decl_stmt|,
name|refresh
init|=
literal|0
decl_stmt|;
name|bool
name|yres_specified
init|=
name|false
decl_stmt|,
name|cvt
init|=
name|false
decl_stmt|,
name|rb
init|=
name|false
decl_stmt|;
name|bool
name|interlace
init|=
name|false
decl_stmt|,
name|margins
init|=
name|false
decl_stmt|,
name|was_digit
init|=
name|false
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|drm_connector_force
name|force
init|=
name|DRM_FORCE_UNSPECIFIED
decl_stmt|;
ifdef|#
directive|ifdef
name|XXX_CONFIG_FB
if|if
condition|(
operator|!
name|mode_option
condition|)
name|mode_option
operator|=
name|fb_mode_option
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|mode_option
condition|)
block|{
name|mode
operator|->
name|specified
operator|=
name|false
expr_stmt|;
return|return
name|false
return|;
block|}
name|name
operator|=
name|mode_option
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|namelen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|name
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'@'
case|:
if|if
condition|(
operator|!
name|refresh_specified
operator|&&
operator|!
name|bpp_specified
operator|&&
operator|!
name|yres_specified
operator|&&
operator|!
name|cvt
operator|&&
operator|!
name|rb
operator|&&
name|was_digit
condition|)
block|{
name|refresh
operator|=
name|strtol
argument_list|(
operator|&
name|name
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|refresh_specified
operator|=
name|true
expr_stmt|;
name|was_digit
operator|=
name|false
expr_stmt|;
block|}
else|else
goto|goto
name|done
goto|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
name|bpp_specified
operator|&&
operator|!
name|yres_specified
operator|&&
operator|!
name|cvt
operator|&&
operator|!
name|rb
operator|&&
name|was_digit
condition|)
block|{
name|bpp
operator|=
name|strtol
argument_list|(
operator|&
name|name
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|bpp_specified
operator|=
name|true
expr_stmt|;
name|was_digit
operator|=
name|false
expr_stmt|;
block|}
else|else
goto|goto
name|done
goto|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|yres_specified
operator|&&
name|was_digit
condition|)
block|{
name|yres
operator|=
name|strtol
argument_list|(
operator|&
name|name
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|yres_specified
operator|=
name|true
expr_stmt|;
name|was_digit
operator|=
name|false
expr_stmt|;
block|}
else|else
goto|goto
name|done
goto|;
case|case
literal|'0'
operator|...
literal|'9'
case|:
name|was_digit
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|yres_specified
operator|||
name|cvt
operator|||
name|was_digit
condition|)
goto|goto
name|done
goto|;
name|cvt
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|yres_specified
operator|||
name|cvt
operator|||
name|rb
operator|||
name|was_digit
condition|)
goto|goto
name|done
goto|;
name|rb
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|cvt
operator|||
name|yres_specified
operator|||
name|was_digit
condition|)
goto|goto
name|done
goto|;
name|margins
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|cvt
operator|||
name|yres_specified
operator|||
name|was_digit
condition|)
goto|goto
name|done
goto|;
name|interlace
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|yres_specified
operator|||
name|bpp_specified
operator|||
name|refresh_specified
operator|||
name|was_digit
operator|||
operator|(
name|force
operator|!=
name|DRM_FORCE_UNSPECIFIED
operator|)
condition|)
goto|goto
name|done
goto|;
name|force
operator|=
name|DRM_FORCE_ON
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|yres_specified
operator|||
name|bpp_specified
operator|||
name|refresh_specified
operator|||
name|was_digit
operator|||
operator|(
name|force
operator|!=
name|DRM_FORCE_UNSPECIFIED
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|connector
operator|->
name|connector_type
operator|!=
name|DRM_MODE_CONNECTOR_DVII
operator|)
operator|&&
operator|(
name|connector
operator|->
name|connector_type
operator|!=
name|DRM_MODE_CONNECTOR_HDMIB
operator|)
condition|)
name|force
operator|=
name|DRM_FORCE_ON
expr_stmt|;
else|else
name|force
operator|=
name|DRM_FORCE_ON_DIGITAL
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|yres_specified
operator|||
name|bpp_specified
operator|||
name|refresh_specified
operator|||
name|was_digit
operator|||
operator|(
name|force
operator|!=
name|DRM_FORCE_UNSPECIFIED
operator|)
condition|)
goto|goto
name|done
goto|;
name|force
operator|=
name|DRM_FORCE_OFF
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|yres_specified
condition|)
block|{
name|char
modifier|*
name|ch
decl_stmt|;
name|xres
operator|=
name|strtol
argument_list|(
name|name
argument_list|,
operator|&
name|ch
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|ch
operator|==
literal|'x'
operator|)
condition|)
name|res_specified
operator|=
name|true
expr_stmt|;
else|else
name|i
operator|=
name|ch
operator|-
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|yres_specified
operator|&&
name|was_digit
condition|)
block|{
comment|/* catch mode that begins with digits but has no 'x' */
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"parse error at position %i in video mode '%s'\n"
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mode
operator|->
name|specified
operator|=
name|false
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|res_specified
condition|)
block|{
name|mode
operator|->
name|specified
operator|=
name|true
expr_stmt|;
name|mode
operator|->
name|xres
operator|=
name|xres
expr_stmt|;
name|mode
operator|->
name|yres
operator|=
name|yres
expr_stmt|;
block|}
if|if
condition|(
name|refresh_specified
condition|)
block|{
name|mode
operator|->
name|refresh_specified
operator|=
name|true
expr_stmt|;
name|mode
operator|->
name|refresh
operator|=
name|refresh
expr_stmt|;
block|}
if|if
condition|(
name|bpp_specified
condition|)
block|{
name|mode
operator|->
name|bpp_specified
operator|=
name|true
expr_stmt|;
name|mode
operator|->
name|bpp
operator|=
name|bpp
expr_stmt|;
block|}
name|mode
operator|->
name|rb
operator|=
name|rb
expr_stmt|;
name|mode
operator|->
name|cvt
operator|=
name|cvt
expr_stmt|;
name|mode
operator|->
name|interlace
operator|=
name|interlace
expr_stmt|;
name|mode
operator|->
name|margins
operator|=
name|margins
expr_stmt|;
name|mode
operator|->
name|force
operator|=
name|force
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|struct
name|drm_display_mode
modifier|*
name|drm_mode_create_from_cmdline_mode
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|drm_cmdline_mode
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|drm_display_mode
modifier|*
name|mode
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|cvt
condition|)
name|mode
operator|=
name|drm_cvt_mode
argument_list|(
name|dev
argument_list|,
name|cmd
operator|->
name|xres
argument_list|,
name|cmd
operator|->
name|yres
argument_list|,
name|cmd
operator|->
name|refresh_specified
condition|?
name|cmd
operator|->
name|refresh
else|:
literal|60
argument_list|,
name|cmd
operator|->
name|rb
argument_list|,
name|cmd
operator|->
name|interlace
argument_list|,
name|cmd
operator|->
name|margins
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|drm_gtf_mode
argument_list|(
name|dev
argument_list|,
name|cmd
operator|->
name|xres
argument_list|,
name|cmd
operator|->
name|yres
argument_list|,
name|cmd
operator|->
name|refresh_specified
condition|?
name|cmd
operator|->
name|refresh
else|:
literal|60
argument_list|,
name|cmd
operator|->
name|interlace
argument_list|,
name|cmd
operator|->
name|margins
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
return|return
name|NULL
return|;
name|drm_mode_set_crtcinfo
argument_list|(
name|mode
argument_list|,
name|CRTC_INTERLACE_HALVE_V
argument_list|)
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

end_unit

