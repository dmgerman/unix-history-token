begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2007-8 Advanced Micro Devices, Inc.  * Copyright 2008 Red Hat Inc.  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sublicense,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL  * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR  * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE.  *  * Authors: Dave Airlie  *          Alex Deucher  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/drm2/drmP.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_crtc_helper.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/radeon/radeon_drm.h>
end_include

begin_include
include|#
directive|include
file|<dev/drm2/drm_fixed.h>
end_include

begin_include
include|#
directive|include
file|"radeon.h"
end_include

begin_include
include|#
directive|include
file|"atom.h"
end_include

begin_include
include|#
directive|include
file|"atom-bits.h"
end_include

begin_function
specifier|static
name|void
name|atombios_overscan_setup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|SET_CRTC_OVERSCAN_PS_ALLOCATION
name|args
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|SetCRTC_OverScan
argument_list|)
decl_stmt|;
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucCRTC
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
switch|switch
condition|(
name|radeon_crtc
operator|->
name|rmx_type
condition|)
block|{
case|case
name|RMX_CENTER
case|:
name|args
operator|.
name|usOverscanTop
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
name|mode
operator|->
name|crtc_vdisplay
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanBottom
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
name|mode
operator|->
name|crtc_vdisplay
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanLeft
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
name|mode
operator|->
name|crtc_hdisplay
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanRight
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
name|mode
operator|->
name|crtc_hdisplay
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RMX_ASPECT
case|:
name|a1
operator|=
name|mode
operator|->
name|crtc_vdisplay
operator|*
name|adjusted_mode
operator|->
name|crtc_hdisplay
expr_stmt|;
name|a2
operator|=
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|*
name|mode
operator|->
name|crtc_hdisplay
expr_stmt|;
if|if
condition|(
name|a1
operator|>
name|a2
condition|)
block|{
name|args
operator|.
name|usOverscanLeft
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
operator|(
name|a2
operator|/
name|mode
operator|->
name|crtc_vdisplay
operator|)
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanRight
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_hdisplay
operator|-
operator|(
name|a2
operator|/
name|mode
operator|->
name|crtc_vdisplay
operator|)
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a2
operator|>
name|a1
condition|)
block|{
name|args
operator|.
name|usOverscanTop
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
operator|(
name|a1
operator|/
name|mode
operator|->
name|crtc_hdisplay
operator|)
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanBottom
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|adjusted_mode
operator|->
name|crtc_vdisplay
operator|-
operator|(
name|a1
operator|/
name|mode
operator|->
name|crtc_hdisplay
operator|)
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|RMX_FULL
case|:
default|default:
name|args
operator|.
name|usOverscanRight
operator|=
name|cpu_to_le16
argument_list|(
name|radeon_crtc
operator|->
name|h_border
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanLeft
operator|=
name|cpu_to_le16
argument_list|(
name|radeon_crtc
operator|->
name|h_border
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanBottom
operator|=
name|cpu_to_le16
argument_list|(
name|radeon_crtc
operator|->
name|v_border
argument_list|)
expr_stmt|;
name|args
operator|.
name|usOverscanTop
operator|=
name|cpu_to_le16
argument_list|(
name|radeon_crtc
operator|->
name|v_border
argument_list|)
expr_stmt|;
break|break;
block|}
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_scaler_setup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|ENABLE_SCALER_PS_ALLOCATION
name|args
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|EnableScaler
argument_list|)
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
comment|/* fixme - fill in enc_priv for atom dac */
name|enum
name|radeon_tv_std
name|tv_std
init|=
name|TV_STD_NTSC
decl_stmt|;
name|bool
name|is_tv
init|=
name|false
decl_stmt|,
name|is_cv
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
operator|&&
name|radeon_crtc
operator|->
name|crtc_id
condition|)
return|return;
if|if
condition|(
name|radeon_encoder
operator|->
name|active_device
operator|&
name|ATOM_DEVICE_TV_SUPPORT
condition|)
block|{
name|struct
name|radeon_encoder_atom_dac
modifier|*
name|tv_dac
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|tv_std
operator|=
name|tv_dac
operator|->
name|tv_std
expr_stmt|;
name|is_tv
operator|=
name|true
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucScaler
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
if|if
condition|(
name|is_tv
condition|)
block|{
switch|switch
condition|(
name|tv_std
condition|)
block|{
case|case
name|TV_STD_NTSC
case|:
default|default:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_NTSC
expr_stmt|;
break|break;
case|case
name|TV_STD_PAL
case|:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_PAL
expr_stmt|;
break|break;
case|case
name|TV_STD_PAL_M
case|:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_PALM
expr_stmt|;
break|break;
case|case
name|TV_STD_PAL_60
case|:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_PAL60
expr_stmt|;
break|break;
case|case
name|TV_STD_NTSC_J
case|:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_NTSCJ
expr_stmt|;
break|break;
case|case
name|TV_STD_SCART_PAL
case|:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_PAL
expr_stmt|;
comment|/* ??? */
break|break;
case|case
name|TV_STD_SECAM
case|:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_SECAM
expr_stmt|;
break|break;
case|case
name|TV_STD_PAL_CN
case|:
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_PALCN
expr_stmt|;
break|break;
block|}
name|args
operator|.
name|ucEnable
operator|=
name|SCALER_ENABLE_MULTITAP_MODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_cv
condition|)
block|{
name|args
operator|.
name|ucTVStandard
operator|=
name|ATOM_TV_CV
expr_stmt|;
name|args
operator|.
name|ucEnable
operator|=
name|SCALER_ENABLE_MULTITAP_MODE
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|radeon_crtc
operator|->
name|rmx_type
condition|)
block|{
case|case
name|RMX_FULL
case|:
name|args
operator|.
name|ucEnable
operator|=
name|ATOM_SCALER_EXPANSION
expr_stmt|;
break|break;
case|case
name|RMX_CENTER
case|:
name|args
operator|.
name|ucEnable
operator|=
name|ATOM_SCALER_CENTER
expr_stmt|;
break|break;
case|case
name|RMX_ASPECT
case|:
name|args
operator|.
name|ucEnable
operator|=
name|ATOM_SCALER_EXPANSION
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
name|args
operator|.
name|ucEnable
operator|=
name|ATOM_SCALER_DISABLE
expr_stmt|;
else|else
name|args
operator|.
name|ucEnable
operator|=
name|ATOM_SCALER_CENTER
expr_stmt|;
break|break;
block|}
block|}
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|is_tv
operator|||
name|is_cv
operator|)
operator|&&
name|rdev
operator|->
name|family
operator|>=
name|CHIP_RV515
operator|&&
name|rdev
operator|->
name|family
operator|<=
name|CHIP_R580
condition|)
block|{
name|atom_rv515_force_tv_scaler
argument_list|(
name|rdev
argument_list|,
name|radeon_crtc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_lock_crtc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|lock
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|UpdateCRTC_DoubleBufferRegisters
argument_list|)
decl_stmt|;
name|ENABLE_CRTC_PS_ALLOCATION
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucCRTC
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
name|args
operator|.
name|ucEnable
operator|=
name|lock
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_enable_crtc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|EnableCRTC
argument_list|)
decl_stmt|;
name|ENABLE_CRTC_PS_ALLOCATION
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucCRTC
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
name|args
operator|.
name|ucEnable
operator|=
name|state
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_enable_crtc_memreq
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|EnableCRTCMemReq
argument_list|)
decl_stmt|;
name|ENABLE_CRTC_PS_ALLOCATION
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucCRTC
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
name|args
operator|.
name|ucEnable
operator|=
name|state
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_blank_crtc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|BlankCRTC
argument_list|)
decl_stmt|;
name|BLANK_CRTC_PS_ALLOCATION
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucCRTC
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
name|args
operator|.
name|ucBlanking
operator|=
name|state
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_powergate_crtc
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|EnableDispPowerGating
argument_list|)
decl_stmt|;
name|ENABLE_DISP_POWER_GATING_PARAMETERS_V2_1
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucDispPipeId
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
name|args
operator|.
name|ucEnable
operator|=
name|state
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|atombios_crtc_dpms
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DRM_MODE_DPMS_ON
case|:
name|radeon_crtc
operator|->
name|enabled
operator|=
name|true
expr_stmt|;
comment|/* adjust pm to dpms changes BEFORE enabling crtcs */
name|radeon_pm_compute_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
operator|&&
operator|!
name|radeon_crtc
operator|->
name|in_mode_set
condition|)
name|atombios_powergate_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_DISABLE
argument_list|)
expr_stmt|;
name|atombios_enable_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE3
argument_list|(
name|rdev
argument_list|)
operator|&&
operator|!
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
name|atombios_enable_crtc_memreq
argument_list|(
name|crtc
argument_list|,
name|ATOM_ENABLE
argument_list|)
expr_stmt|;
name|atombios_blank_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_DISABLE
argument_list|)
expr_stmt|;
name|drm_vblank_post_modeset
argument_list|(
name|dev
argument_list|,
name|radeon_crtc
operator|->
name|crtc_id
argument_list|)
expr_stmt|;
name|radeon_crtc_load_lut
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRM_MODE_DPMS_STANDBY
case|:
case|case
name|DRM_MODE_DPMS_SUSPEND
case|:
case|case
name|DRM_MODE_DPMS_OFF
case|:
name|drm_vblank_pre_modeset
argument_list|(
name|dev
argument_list|,
name|radeon_crtc
operator|->
name|crtc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_crtc
operator|->
name|enabled
condition|)
name|atombios_blank_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE3
argument_list|(
name|rdev
argument_list|)
operator|&&
operator|!
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
name|atombios_enable_crtc_memreq
argument_list|(
name|crtc
argument_list|,
name|ATOM_DISABLE
argument_list|)
expr_stmt|;
name|atombios_enable_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_DISABLE
argument_list|)
expr_stmt|;
name|radeon_crtc
operator|->
name|enabled
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
operator|&&
operator|!
name|radeon_crtc
operator|->
name|in_mode_set
condition|)
name|atombios_powergate_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_ENABLE
argument_list|)
expr_stmt|;
comment|/* adjust pm to dpms changes AFTER disabling crtcs */
name|radeon_pm_compute_clocks
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_set_crtc_dtd_timing
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|SET_CRTC_USING_DTD_TIMING_PARAMETERS
name|args
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|SetCRTC_UsingDTDTiming
argument_list|)
decl_stmt|;
name|u16
name|misc
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_Size
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_hdisplay
operator|-
operator|(
name|radeon_crtc
operator|->
name|h_border
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_Blanking_Time
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_hblank_end
operator|-
name|mode
operator|->
name|crtc_hdisplay
operator|+
operator|(
name|radeon_crtc
operator|->
name|h_border
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_Size
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vdisplay
operator|-
operator|(
name|radeon_crtc
operator|->
name|v_border
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_Blanking_Time
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vblank_end
operator|-
name|mode
operator|->
name|crtc_vdisplay
operator|+
operator|(
name|radeon_crtc
operator|->
name|v_border
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_SyncOffset
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_hsync_start
operator|-
name|mode
operator|->
name|crtc_hdisplay
operator|+
name|radeon_crtc
operator|->
name|h_border
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_SyncWidth
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_hsync_end
operator|-
name|mode
operator|->
name|crtc_hsync_start
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_SyncOffset
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vsync_start
operator|-
name|mode
operator|->
name|crtc_vdisplay
operator|+
name|radeon_crtc
operator|->
name|v_border
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_SyncWidth
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vsync_end
operator|-
name|mode
operator|->
name|crtc_vsync_start
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucH_Border
operator|=
name|radeon_crtc
operator|->
name|h_border
expr_stmt|;
name|args
operator|.
name|ucV_Border
operator|=
name|radeon_crtc
operator|->
name|v_border
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|misc
operator||=
name|ATOM_VSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|misc
operator||=
name|ATOM_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_CSYNC
condition|)
name|misc
operator||=
name|ATOM_COMPOSITESYNC
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
name|misc
operator||=
name|ATOM_INTERLACE
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
condition|)
name|misc
operator||=
name|ATOM_DOUBLE_CLOCK_MODE
expr_stmt|;
name|args
operator|.
name|susModeMiscInfo
operator|.
name|usAccess
operator|=
name|cpu_to_le16
argument_list|(
name|misc
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucCRTC
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_crtc_set_timing
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|SET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION
name|args
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|SetCRTC_Timing
argument_list|)
decl_stmt|;
name|u16
name|misc
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_Total
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_htotal
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_Disp
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_hdisplay
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_SyncStart
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_hsync_start
argument_list|)
expr_stmt|;
name|args
operator|.
name|usH_SyncWidth
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_hsync_end
operator|-
name|mode
operator|->
name|crtc_hsync_start
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_Total
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vtotal
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_Disp
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vdisplay
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_SyncStart
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vsync_start
argument_list|)
expr_stmt|;
name|args
operator|.
name|usV_SyncWidth
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|crtc_vsync_end
operator|-
name|mode
operator|->
name|crtc_vsync_start
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucOverscanRight
operator|=
name|radeon_crtc
operator|->
name|h_border
expr_stmt|;
name|args
operator|.
name|ucOverscanLeft
operator|=
name|radeon_crtc
operator|->
name|h_border
expr_stmt|;
name|args
operator|.
name|ucOverscanBottom
operator|=
name|radeon_crtc
operator|->
name|v_border
expr_stmt|;
name|args
operator|.
name|ucOverscanTop
operator|=
name|radeon_crtc
operator|->
name|v_border
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NVSYNC
condition|)
name|misc
operator||=
name|ATOM_VSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_NHSYNC
condition|)
name|misc
operator||=
name|ATOM_HSYNC_POLARITY
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_CSYNC
condition|)
name|misc
operator||=
name|ATOM_COMPOSITESYNC
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_INTERLACE
condition|)
name|misc
operator||=
name|ATOM_INTERLACE
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|flags
operator|&
name|DRM_MODE_FLAG_DBLSCAN
condition|)
name|misc
operator||=
name|ATOM_DOUBLE_CLOCK_MODE
expr_stmt|;
name|args
operator|.
name|susModeMiscInfo
operator|.
name|usAccess
operator|=
name|cpu_to_le16
argument_list|(
name|misc
argument_list|)
expr_stmt|;
name|args
operator|.
name|ucCRTC
operator|=
name|radeon_crtc
operator|->
name|crtc_id
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_disable_ss
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|pll_id
parameter_list|)
block|{
name|u32
name|ss_cntl
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|pll_id
condition|)
block|{
case|case
name|ATOM_PPLL1
case|:
name|ss_cntl
operator|=
name|RREG32
argument_list|(
name|EVERGREEN_P1PLL_SS_CNTL
argument_list|)
expr_stmt|;
name|ss_cntl
operator|&=
operator|~
name|EVERGREEN_PxPLL_SS_EN
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_P1PLL_SS_CNTL
argument_list|,
name|ss_cntl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL2
case|:
name|ss_cntl
operator|=
name|RREG32
argument_list|(
name|EVERGREEN_P2PLL_SS_CNTL
argument_list|)
expr_stmt|;
name|ss_cntl
operator|&=
operator|~
name|EVERGREEN_PxPLL_SS_EN
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_P2PLL_SS_CNTL
argument_list|,
name|ss_cntl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM_DCPLL
case|:
case|case
name|ATOM_PPLL_INVALID
case|:
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|pll_id
condition|)
block|{
case|case
name|ATOM_PPLL1
case|:
name|ss_cntl
operator|=
name|RREG32
argument_list|(
name|AVIVO_P1PLL_INT_SS_CNTL
argument_list|)
expr_stmt|;
name|ss_cntl
operator|&=
operator|~
literal|1
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_P1PLL_INT_SS_CNTL
argument_list|,
name|ss_cntl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL2
case|:
name|ss_cntl
operator|=
name|RREG32
argument_list|(
name|AVIVO_P2PLL_INT_SS_CNTL
argument_list|)
expr_stmt|;
name|ss_cntl
operator|&=
operator|~
literal|1
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_P2PLL_INT_SS_CNTL
argument_list|,
name|ss_cntl
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM_DCPLL
case|:
case|case
name|ATOM_PPLL_INVALID
case|:
return|return;
block|}
block|}
block|}
end_function

begin_union
union|union
name|atom_enable_ss
block|{
name|ENABLE_LVDS_SS_PARAMETERS
name|lvds_ss
decl_stmt|;
name|ENABLE_LVDS_SS_PARAMETERS_V2
name|lvds_ss_2
decl_stmt|;
name|ENABLE_SPREAD_SPECTRUM_ON_PPLL_PS_ALLOCATION
name|v1
decl_stmt|;
name|ENABLE_SPREAD_SPECTRUM_ON_PPLL_V2
name|v2
decl_stmt|;
name|ENABLE_SPREAD_SPECTRUM_ON_PPLL_V3
name|v3
decl_stmt|;
block|}
union|;
end_union

begin_function
specifier|static
name|void
name|atombios_crtc_program_ss
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|int
name|enable
parameter_list|,
name|int
name|pll_id
parameter_list|,
name|int
name|crtc_id
parameter_list|,
name|struct
name|radeon_atom_ss
modifier|*
name|ss
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|EnableSpreadSpectrumOnPPLL
argument_list|)
decl_stmt|;
name|union
name|atom_enable_ss
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|num_crtc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|mode_info
operator|.
name|crtcs
index|[
name|i
index|]
operator|&&
name|rdev
operator|->
name|mode_info
operator|.
name|crtcs
index|[
name|i
index|]
operator|->
name|enabled
operator|&&
name|i
operator|!=
name|crtc_id
operator|&&
name|pll_id
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|crtcs
index|[
name|i
index|]
operator|->
name|pll_id
condition|)
block|{
comment|/* one other crtc is using this pll don't turn 				 * off spread spectrum as it might turn off 				 * display on active crtc 				 */
return|return;
block|}
block|}
block|}
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE5
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|args
operator|.
name|v3
operator|.
name|usSpreadSpectrumAmountFrac
operator|=
name|cpu_to_le16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|ucSpreadSpectrumType
operator|=
name|ss
operator|->
name|type
operator|&
name|ATOM_SS_CENTRE_SPREAD_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|pll_id
condition|)
block|{
case|case
name|ATOM_PPLL1
case|:
name|args
operator|.
name|v3
operator|.
name|ucSpreadSpectrumType
operator||=
name|ATOM_PPLL_SS_TYPE_V3_P1PLL
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL2
case|:
name|args
operator|.
name|v3
operator|.
name|ucSpreadSpectrumType
operator||=
name|ATOM_PPLL_SS_TYPE_V3_P2PLL
expr_stmt|;
break|break;
case|case
name|ATOM_DCPLL
case|:
name|args
operator|.
name|v3
operator|.
name|ucSpreadSpectrumType
operator||=
name|ATOM_PPLL_SS_TYPE_V3_DCPLL
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL_INVALID
case|:
return|return;
block|}
name|args
operator|.
name|v3
operator|.
name|usSpreadSpectrumAmount
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|amount
argument_list|)
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|usSpreadSpectrumStep
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|step
argument_list|)
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|ucEnable
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|(
name|ss
operator|->
name|percentage
operator|==
literal|0
operator|)
operator|||
operator|(
name|ss
operator|->
name|type
operator|&
name|ATOM_EXTERNAL_SS_MASK
operator|)
operator|||
name|ASIC_IS_DCE61
argument_list|(
name|rdev
argument_list|)
condition|)
name|args
operator|.
name|v3
operator|.
name|ucEnable
operator|=
name|ATOM_DISABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|args
operator|.
name|v2
operator|.
name|usSpreadSpectrumPercentage
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|percentage
argument_list|)
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|ucSpreadSpectrumType
operator|=
name|ss
operator|->
name|type
operator|&
name|ATOM_SS_CENTRE_SPREAD_MODE_MASK
expr_stmt|;
switch|switch
condition|(
name|pll_id
condition|)
block|{
case|case
name|ATOM_PPLL1
case|:
name|args
operator|.
name|v2
operator|.
name|ucSpreadSpectrumType
operator||=
name|ATOM_PPLL_SS_TYPE_V2_P1PLL
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL2
case|:
name|args
operator|.
name|v2
operator|.
name|ucSpreadSpectrumType
operator||=
name|ATOM_PPLL_SS_TYPE_V2_P2PLL
expr_stmt|;
break|break;
case|case
name|ATOM_DCPLL
case|:
name|args
operator|.
name|v2
operator|.
name|ucSpreadSpectrumType
operator||=
name|ATOM_PPLL_SS_TYPE_V2_DCPLL
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL_INVALID
case|:
return|return;
block|}
name|args
operator|.
name|v2
operator|.
name|usSpreadSpectrumAmount
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|amount
argument_list|)
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|usSpreadSpectrumStep
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|step
argument_list|)
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|ucEnable
operator|=
name|enable
expr_stmt|;
if|if
condition|(
operator|(
name|ss
operator|->
name|percentage
operator|==
literal|0
operator|)
operator|||
operator|(
name|ss
operator|->
name|type
operator|&
name|ATOM_EXTERNAL_SS_MASK
operator|)
operator|||
name|ASIC_IS_DCE41
argument_list|(
name|rdev
argument_list|)
condition|)
name|args
operator|.
name|v2
operator|.
name|ucEnable
operator|=
name|ATOM_DISABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ASIC_IS_DCE3
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|args
operator|.
name|v1
operator|.
name|usSpreadSpectrumPercentage
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|percentage
argument_list|)
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucSpreadSpectrumType
operator|=
name|ss
operator|->
name|type
operator|&
name|ATOM_SS_CENTRE_SPREAD_MODE_MASK
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucSpreadSpectrumStep
operator|=
name|ss
operator|->
name|step
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucSpreadSpectrumDelay
operator|=
name|ss
operator|->
name|delay
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucSpreadSpectrumRange
operator|=
name|ss
operator|->
name|range
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucPpll
operator|=
name|pll_id
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucEnable
operator|=
name|enable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|enable
operator|==
name|ATOM_DISABLE
operator|)
operator|||
operator|(
name|ss
operator|->
name|percentage
operator|==
literal|0
operator|)
operator|||
operator|(
name|ss
operator|->
name|type
operator|&
name|ATOM_EXTERNAL_SS_MASK
operator|)
condition|)
block|{
name|atombios_disable_ss
argument_list|(
name|rdev
argument_list|,
name|pll_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|args
operator|.
name|lvds_ss_2
operator|.
name|usSpreadSpectrumPercentage
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|percentage
argument_list|)
expr_stmt|;
name|args
operator|.
name|lvds_ss_2
operator|.
name|ucSpreadSpectrumType
operator|=
name|ss
operator|->
name|type
operator|&
name|ATOM_SS_CENTRE_SPREAD_MODE_MASK
expr_stmt|;
name|args
operator|.
name|lvds_ss_2
operator|.
name|ucSpreadSpectrumStep
operator|=
name|ss
operator|->
name|step
expr_stmt|;
name|args
operator|.
name|lvds_ss_2
operator|.
name|ucSpreadSpectrumDelay
operator|=
name|ss
operator|->
name|delay
expr_stmt|;
name|args
operator|.
name|lvds_ss_2
operator|.
name|ucSpreadSpectrumRange
operator|=
name|ss
operator|->
name|range
expr_stmt|;
name|args
operator|.
name|lvds_ss_2
operator|.
name|ucEnable
operator|=
name|enable
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|enable
operator|==
name|ATOM_DISABLE
operator|)
operator|||
operator|(
name|ss
operator|->
name|percentage
operator|==
literal|0
operator|)
operator|||
operator|(
name|ss
operator|->
name|type
operator|&
name|ATOM_EXTERNAL_SS_MASK
operator|)
condition|)
block|{
name|atombios_disable_ss
argument_list|(
name|rdev
argument_list|,
name|pll_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|args
operator|.
name|lvds_ss
operator|.
name|usSpreadSpectrumPercentage
operator|=
name|cpu_to_le16
argument_list|(
name|ss
operator|->
name|percentage
argument_list|)
expr_stmt|;
name|args
operator|.
name|lvds_ss
operator|.
name|ucSpreadSpectrumType
operator|=
name|ss
operator|->
name|type
operator|&
name|ATOM_SS_CENTRE_SPREAD_MODE_MASK
expr_stmt|;
name|args
operator|.
name|lvds_ss
operator|.
name|ucSpreadSpectrumStepSize_Delay
operator|=
operator|(
name|ss
operator|->
name|step
operator|&
literal|3
operator|)
operator|<<
literal|2
expr_stmt|;
name|args
operator|.
name|lvds_ss
operator|.
name|ucSpreadSpectrumStepSize_Delay
operator||=
operator|(
name|ss
operator|->
name|delay
operator|&
literal|7
operator|)
operator|<<
literal|4
expr_stmt|;
name|args
operator|.
name|lvds_ss
operator|.
name|ucEnable
operator|=
name|enable
expr_stmt|;
block|}
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_union
union|union
name|adjust_pixel_clock
block|{
name|ADJUST_DISPLAY_PLL_PS_ALLOCATION
name|v1
decl_stmt|;
name|ADJUST_DISPLAY_PLL_PS_ALLOCATION_V3
name|v3
decl_stmt|;
block|}
union|;
end_union

begin_function
specifier|static
name|u32
name|atombios_adjust_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
init|=
name|radeon_crtc
operator|->
name|encoder
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
init|=
name|radeon_get_connector_for_encoder
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|u32
name|adjusted_clock
init|=
name|mode
operator|->
name|clock
decl_stmt|;
name|int
name|encoder_mode
init|=
name|atombios_get_encoder_mode
argument_list|(
name|encoder
argument_list|)
decl_stmt|;
name|u32
name|dp_clock
init|=
name|mode
operator|->
name|clock
decl_stmt|;
name|int
name|bpc
init|=
name|radeon_get_monitor_bpc
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|bool
name|is_duallink
init|=
name|radeon_dig_monitor_is_duallink
argument_list|(
name|encoder
argument_list|,
name|mode
operator|->
name|clock
argument_list|)
decl_stmt|;
comment|/* reset the pll flags */
name|radeon_crtc
operator|->
name|pll_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS600
operator|)
operator|||
operator|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS690
operator|)
operator|||
operator|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_RS740
operator|)
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
operator|(
comment|/*RADEON_PLL_USE_FRAC_FB_DIV |*/
name|RADEON_PLL_PREFER_CLOSEST_LOWER
operator|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE32
argument_list|(
name|rdev
argument_list|)
operator|&&
name|mode
operator|->
name|clock
operator|>
literal|200000
condition|)
comment|/* range limits??? */
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_PREFER_HIGH_FB_DIV
expr_stmt|;
else|else
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_PREFER_LOW_REF_DIV
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|family
operator|<
name|CHIP_RV770
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_PREFER_MINM_OVER_MAXP
expr_stmt|;
comment|/* use frac fb div on APUs */
if|if
condition|(
name|ASIC_IS_DCE41
argument_list|(
name|rdev
argument_list|)
operator|||
name|ASIC_IS_DCE61
argument_list|(
name|rdev
argument_list|)
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_FRAC_FB_DIV
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE32
argument_list|(
name|rdev
argument_list|)
operator|&&
name|mode
operator|->
name|clock
operator|>
literal|165000
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_FRAC_FB_DIV
expr_stmt|;
block|}
else|else
block|{
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_LEGACY
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|clock
operator|>
literal|200000
condition|)
comment|/* range limits??? */
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_PREFER_HIGH_FB_DIV
expr_stmt|;
else|else
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_PREFER_LOW_REF_DIV
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|radeon_encoder
operator|->
name|devices
operator|&
operator|(
name|ATOM_DEVICE_LCD_SUPPORT
operator||
name|ATOM_DEVICE_DFP_SUPPORT
operator|)
operator|)
operator|||
operator|(
name|radeon_encoder_get_dp_bridge_encoder_id
argument_list|(
name|encoder
argument_list|)
operator|!=
name|ENCODER_OBJECT_ID_NONE
operator|)
condition|)
block|{
if|if
condition|(
name|connector
condition|)
block|{
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|dp_clock
operator|=
name|dig_connector
operator|->
name|dp_clock
expr_stmt|;
block|}
block|}
comment|/* use recommended ref_div for ss */
if|if
condition|(
name|radeon_encoder
operator|->
name|devices
operator|&
operator|(
name|ATOM_DEVICE_LCD_SUPPORT
operator|)
condition|)
block|{
if|if
condition|(
name|radeon_crtc
operator|->
name|ss_enabled
condition|)
block|{
if|if
condition|(
name|radeon_crtc
operator|->
name|ss
operator|.
name|refdiv
condition|)
block|{
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_REF_DIV
expr_stmt|;
name|radeon_crtc
operator|->
name|pll_reference_div
operator|=
name|radeon_crtc
operator|->
name|ss
operator|.
name|refdiv
expr_stmt|;
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_FRAC_FB_DIV
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
comment|/* DVO wants 2x pixel clock if the DVO chip is in 12 bit mode */
if|if
condition|(
name|radeon_encoder
operator|->
name|encoder_id
operator|==
name|ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1
condition|)
name|adjusted_clock
operator|=
name|mode
operator|->
name|clock
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|active_device
operator|&
operator|(
name|ATOM_DEVICE_TV_SUPPORT
operator|)
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_PREFER_CLOSEST_LOWER
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|devices
operator|&
operator|(
name|ATOM_DEVICE_LCD_SUPPORT
operator|)
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_IS_LCD
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|encoder
operator|->
name|encoder_type
operator|!=
name|DRM_MODE_ENCODER_DAC
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_NO_ODD_POST_DIV
expr_stmt|;
if|if
condition|(
name|encoder
operator|->
name|encoder_type
operator|==
name|DRM_MODE_ENCODER_LVDS
condition|)
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_REF_DIV
expr_stmt|;
block|}
comment|/* DCE3+ has an AdjustDisplayPll that will adjust the pixel clock 	 * accordingly based on the encoder/transmitter to work around 	 * special hw requirements. 	 */
if|if
condition|(
name|ASIC_IS_DCE3
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|union
name|adjust_pixel_clock
name|args
decl_stmt|;
name|u8
name|frev
decl_stmt|,
name|crev
decl_stmt|;
name|int
name|index
decl_stmt|;
name|index
operator|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|AdjustDisplayPll
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atom_parse_cmd_header
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|&
name|frev
argument_list|,
operator|&
name|crev
argument_list|)
condition|)
return|return
name|adjusted_clock
return|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|frev
condition|)
block|{
case|case
literal|1
case|:
switch|switch
condition|(
name|crev
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|args
operator|.
name|v1
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucTransmitterID
operator|=
name|radeon_encoder
operator|->
name|encoder_id
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucEncodeMode
operator|=
name|encoder_mode
expr_stmt|;
if|if
condition|(
name|radeon_crtc
operator|->
name|ss_enabled
operator|&&
name|radeon_crtc
operator|->
name|ss
operator|.
name|percentage
condition|)
name|args
operator|.
name|v1
operator|.
name|ucConfig
operator||=
name|ADJUST_DISPLAY_CONFIG_SS_ENABLE
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
name|adjusted_clock
operator|=
name|le16_to_cpu
argument_list|(
name|args
operator|.
name|v1
operator|.
name|usPixelClock
argument_list|)
operator|*
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|mode
operator|->
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucTransmitterID
operator|=
name|radeon_encoder
operator|->
name|encoder_id
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucEncodeMode
operator|=
name|encoder_mode
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucDispPllConfig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|radeon_crtc
operator|->
name|ss_enabled
operator|&&
name|radeon_crtc
operator|->
name|ss
operator|.
name|percentage
condition|)
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucDispPllConfig
operator||=
name|DISPPLL_CONFIG_SS_ENABLE
expr_stmt|;
if|if
condition|(
name|ENCODER_MODE_IS_DP
argument_list|(
name|encoder_mode
argument_list|)
condition|)
block|{
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucDispPllConfig
operator||=
name|DISPPLL_CONFIG_COHERENT_MODE
expr_stmt|;
comment|/* 16200 or 27000 */
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|dp_clock
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|radeon_encoder
operator|->
name|devices
operator|&
operator|(
name|ATOM_DEVICE_DFP_SUPPORT
operator|)
condition|)
block|{
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
if|if
condition|(
name|encoder_mode
operator|==
name|ATOM_ENCODER_MODE_HDMI
condition|)
comment|/* deep color support */
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
operator|(
name|mode
operator|->
name|clock
operator|*
name|bpc
operator|/
literal|8
operator|)
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|dig
operator|->
name|coherent_mode
condition|)
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucDispPllConfig
operator||=
name|DISPPLL_CONFIG_COHERENT_MODE
expr_stmt|;
if|if
condition|(
name|is_duallink
condition|)
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucDispPllConfig
operator||=
name|DISPPLL_CONFIG_DUAL_LINK
expr_stmt|;
block|}
if|if
condition|(
name|radeon_encoder_get_dp_bridge_encoder_id
argument_list|(
name|encoder
argument_list|)
operator|!=
name|ENCODER_OBJECT_ID_NONE
condition|)
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucExtTransmitterID
operator|=
name|radeon_encoder_get_dp_bridge_encoder_id
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
else|else
name|args
operator|.
name|v3
operator|.
name|sInput
operator|.
name|ucExtTransmitterID
operator|=
literal|0
expr_stmt|;
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
name|adjusted_clock
operator|=
name|le32_to_cpu
argument_list|(
name|args
operator|.
name|v3
operator|.
name|sOutput
operator|.
name|ulDispPllFreq
argument_list|)
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|v3
operator|.
name|sOutput
operator|.
name|ucRefDiv
condition|)
block|{
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_FRAC_FB_DIV
expr_stmt|;
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_REF_DIV
expr_stmt|;
name|radeon_crtc
operator|->
name|pll_reference_div
operator|=
name|args
operator|.
name|v3
operator|.
name|sOutput
operator|.
name|ucRefDiv
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|.
name|v3
operator|.
name|sOutput
operator|.
name|ucPostDiv
condition|)
block|{
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_FRAC_FB_DIV
expr_stmt|;
name|radeon_crtc
operator|->
name|pll_flags
operator||=
name|RADEON_PLL_USE_POST_DIV
expr_stmt|;
name|radeon_crtc
operator|->
name|pll_post_div
operator|=
name|args
operator|.
name|v3
operator|.
name|sOutput
operator|.
name|ucPostDiv
expr_stmt|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown table version %d %d\n"
argument_list|,
name|frev
argument_list|,
name|crev
argument_list|)
expr_stmt|;
return|return
name|adjusted_clock
return|;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown table version %d %d\n"
argument_list|,
name|frev
argument_list|,
name|crev
argument_list|)
expr_stmt|;
return|return
name|adjusted_clock
return|;
block|}
block|}
return|return
name|adjusted_clock
return|;
block|}
end_function

begin_union
union|union
name|set_pixel_clock
block|{
name|SET_PIXEL_CLOCK_PS_ALLOCATION
name|base
decl_stmt|;
name|PIXEL_CLOCK_PARAMETERS
name|v1
decl_stmt|;
name|PIXEL_CLOCK_PARAMETERS_V2
name|v2
decl_stmt|;
name|PIXEL_CLOCK_PARAMETERS_V3
name|v3
decl_stmt|;
name|PIXEL_CLOCK_PARAMETERS_V5
name|v5
decl_stmt|;
name|PIXEL_CLOCK_PARAMETERS_V6
name|v6
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* on DCE5, make sure the voltage is high enough to support the  * required disp clk.  */
end_comment

begin_function
specifier|static
name|void
name|atombios_crtc_set_disp_eng_pll
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|,
name|u32
name|dispclk
parameter_list|)
block|{
name|u8
name|frev
decl_stmt|,
name|crev
decl_stmt|;
name|int
name|index
decl_stmt|;
name|union
name|set_pixel_clock
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|index
operator|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|SetPixelClock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atom_parse_cmd_header
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|&
name|frev
argument_list|,
operator|&
name|crev
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|frev
condition|)
block|{
case|case
literal|1
case|:
switch|switch
condition|(
name|crev
condition|)
block|{
case|case
literal|5
case|:
comment|/* if the default dcpll clock is specified, 			 * SetPixelClock provides the dividers 			 */
name|args
operator|.
name|v5
operator|.
name|ucCRTC
operator|=
name|ATOM_CRTC_INVALID
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|dispclk
argument_list|)
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|ucPpll
operator|=
name|ATOM_DCPLL
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* if the default dcpll clock is specified, 			 * SetPixelClock provides the dividers 			 */
name|args
operator|.
name|v6
operator|.
name|ulDispEngClkFreq
operator|=
name|cpu_to_le32
argument_list|(
name|dispclk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE61
argument_list|(
name|rdev
argument_list|)
condition|)
name|args
operator|.
name|v6
operator|.
name|ucPpll
operator|=
name|ATOM_EXT_PLL1
expr_stmt|;
elseif|else
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
name|args
operator|.
name|v6
operator|.
name|ucPpll
operator|=
name|ATOM_PPLL0
expr_stmt|;
else|else
name|args
operator|.
name|v6
operator|.
name|ucPpll
operator|=
name|ATOM_DCPLL
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown table version %d %d\n"
argument_list|,
name|frev
argument_list|,
name|crev
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown table version %d %d\n"
argument_list|,
name|frev
argument_list|,
name|crev
argument_list|)
expr_stmt|;
return|return;
block|}
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_crtc_program_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|u32
name|crtc_id
parameter_list|,
name|int
name|pll_id
parameter_list|,
name|u32
name|encoder_mode
parameter_list|,
name|u32
name|encoder_id
parameter_list|,
name|u32
name|clock
parameter_list|,
name|u32
name|ref_div
parameter_list|,
name|u32
name|fb_div
parameter_list|,
name|u32
name|frac_fb_div
parameter_list|,
name|u32
name|post_div
parameter_list|,
name|int
name|bpc
parameter_list|,
name|bool
name|ss_enabled
parameter_list|,
name|struct
name|radeon_atom_ss
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|u8
name|frev
decl_stmt|,
name|crev
decl_stmt|;
name|int
name|index
init|=
name|GetIndexIntoMasterTable
argument_list|(
name|COMMAND
argument_list|,
name|SetPixelClock
argument_list|)
decl_stmt|;
name|union
name|set_pixel_clock
name|args
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atom_parse_cmd_header
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|&
name|frev
argument_list|,
operator|&
name|crev
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|frev
condition|)
block|{
case|case
literal|1
case|:
switch|switch
condition|(
name|crev
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|clock
operator|==
name|ATOM_DISABLE
condition|)
return|return;
name|args
operator|.
name|v1
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|usRefDiv
operator|=
name|cpu_to_le16
argument_list|(
name|ref_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|usFbDiv
operator|=
name|cpu_to_le16
argument_list|(
name|fb_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucFracFbDiv
operator|=
name|frac_fb_div
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucPostDiv
operator|=
name|post_div
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucPpll
operator|=
name|pll_id
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucCRTC
operator|=
name|crtc_id
expr_stmt|;
name|args
operator|.
name|v1
operator|.
name|ucRefDivSrc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|args
operator|.
name|v2
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|usRefDiv
operator|=
name|cpu_to_le16
argument_list|(
name|ref_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|usFbDiv
operator|=
name|cpu_to_le16
argument_list|(
name|fb_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|ucFracFbDiv
operator|=
name|frac_fb_div
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|ucPostDiv
operator|=
name|post_div
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|ucPpll
operator|=
name|pll_id
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|ucCRTC
operator|=
name|crtc_id
expr_stmt|;
name|args
operator|.
name|v2
operator|.
name|ucRefDivSrc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|args
operator|.
name|v3
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|usRefDiv
operator|=
name|cpu_to_le16
argument_list|(
name|ref_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|usFbDiv
operator|=
name|cpu_to_le16
argument_list|(
name|fb_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|ucFracFbDiv
operator|=
name|frac_fb_div
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|ucPostDiv
operator|=
name|post_div
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|ucPpll
operator|=
name|pll_id
expr_stmt|;
if|if
condition|(
name|crtc_id
operator|==
name|ATOM_CRTC2
condition|)
name|args
operator|.
name|v3
operator|.
name|ucMiscInfo
operator|=
name|PIXEL_CLOCK_MISC_CRTC_SEL_CRTC2
expr_stmt|;
else|else
name|args
operator|.
name|v3
operator|.
name|ucMiscInfo
operator|=
name|PIXEL_CLOCK_MISC_CRTC_SEL_CRTC1
expr_stmt|;
if|if
condition|(
name|ss_enabled
operator|&&
operator|(
name|ss
operator|->
name|type
operator|&
name|ATOM_EXTERNAL_SS_MASK
operator|)
condition|)
name|args
operator|.
name|v3
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_MISC_REF_DIV_SRC
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|ucTransmitterId
operator|=
name|encoder_id
expr_stmt|;
name|args
operator|.
name|v3
operator|.
name|ucEncoderMode
operator|=
name|encoder_mode
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|args
operator|.
name|v5
operator|.
name|ucCRTC
operator|=
name|crtc_id
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|usPixelClock
operator|=
name|cpu_to_le16
argument_list|(
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|ucRefDiv
operator|=
name|ref_div
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|usFbDiv
operator|=
name|cpu_to_le16
argument_list|(
name|fb_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|ulFbDivDecFrac
operator|=
name|cpu_to_le32
argument_list|(
name|frac_fb_div
operator|*
literal|100000
argument_list|)
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|ucPostDiv
operator|=
name|post_div
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|ucMiscInfo
operator|=
literal|0
expr_stmt|;
comment|/* HDMI depth, etc. */
if|if
condition|(
name|ss_enabled
operator|&&
operator|(
name|ss
operator|->
name|type
operator|&
name|ATOM_EXTERNAL_SS_MASK
operator|)
condition|)
name|args
operator|.
name|v5
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V5_MISC_REF_DIV_SRC
expr_stmt|;
switch|switch
condition|(
name|bpc
condition|)
block|{
case|case
literal|8
case|:
default|default:
name|args
operator|.
name|v5
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V5_MISC_HDMI_24BPP
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|args
operator|.
name|v5
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V5_MISC_HDMI_30BPP
expr_stmt|;
break|break;
block|}
name|args
operator|.
name|v5
operator|.
name|ucTransmitterID
operator|=
name|encoder_id
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|ucEncoderMode
operator|=
name|encoder_mode
expr_stmt|;
name|args
operator|.
name|v5
operator|.
name|ucPpll
operator|=
name|pll_id
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|args
operator|.
name|v6
operator|.
name|ulDispEngClkFreq
operator|=
name|cpu_to_le32
argument_list|(
name|crtc_id
operator|<<
literal|24
operator||
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
name|args
operator|.
name|v6
operator|.
name|ucRefDiv
operator|=
name|ref_div
expr_stmt|;
name|args
operator|.
name|v6
operator|.
name|usFbDiv
operator|=
name|cpu_to_le16
argument_list|(
name|fb_div
argument_list|)
expr_stmt|;
name|args
operator|.
name|v6
operator|.
name|ulFbDivDecFrac
operator|=
name|cpu_to_le32
argument_list|(
name|frac_fb_div
operator|*
literal|100000
argument_list|)
expr_stmt|;
name|args
operator|.
name|v6
operator|.
name|ucPostDiv
operator|=
name|post_div
expr_stmt|;
name|args
operator|.
name|v6
operator|.
name|ucMiscInfo
operator|=
literal|0
expr_stmt|;
comment|/* HDMI depth, etc. */
if|if
condition|(
name|ss_enabled
operator|&&
operator|(
name|ss
operator|->
name|type
operator|&
name|ATOM_EXTERNAL_SS_MASK
operator|)
condition|)
name|args
operator|.
name|v6
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V6_MISC_REF_DIV_SRC
expr_stmt|;
switch|switch
condition|(
name|bpc
condition|)
block|{
case|case
literal|8
case|:
default|default:
name|args
operator|.
name|v6
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V6_MISC_HDMI_24BPP
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|args
operator|.
name|v6
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V6_MISC_HDMI_30BPP
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|args
operator|.
name|v6
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V6_MISC_HDMI_36BPP
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|args
operator|.
name|v6
operator|.
name|ucMiscInfo
operator||=
name|PIXEL_CLOCK_V6_MISC_HDMI_48BPP
expr_stmt|;
break|break;
block|}
name|args
operator|.
name|v6
operator|.
name|ucTransmitterID
operator|=
name|encoder_id
expr_stmt|;
name|args
operator|.
name|v6
operator|.
name|ucEncoderMode
operator|=
name|encoder_mode
expr_stmt|;
name|args
operator|.
name|v6
operator|.
name|ucPpll
operator|=
name|pll_id
expr_stmt|;
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown table version %d %d\n"
argument_list|,
name|frev
argument_list|,
name|crev
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unknown table version %d %d\n"
argument_list|,
name|frev
argument_list|,
name|crev
argument_list|)
expr_stmt|;
return|return;
block|}
name|atom_execute_table
argument_list|(
name|rdev
operator|->
name|mode_info
operator|.
name|atom_context
argument_list|,
name|index
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|atombios_crtc_prepare_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
name|int
name|encoder_mode
init|=
name|atombios_get_encoder_mode
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
name|radeon_crtc
operator|->
name|bpc
operator|=
literal|8
expr_stmt|;
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|(
name|radeon_encoder
operator|->
name|active_device
operator|&
operator|(
name|ATOM_DEVICE_LCD_SUPPORT
operator||
name|ATOM_DEVICE_DFP_SUPPORT
operator|)
operator|)
operator|||
operator|(
name|radeon_encoder_get_dp_bridge_encoder_id
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
operator|!=
name|ENCODER_OBJECT_ID_NONE
operator|)
condition|)
block|{
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
name|struct
name|drm_connector
modifier|*
name|connector
init|=
name|radeon_get_connector_for_encoder
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector
modifier|*
name|radeon_connector
init|=
name|to_radeon_connector
argument_list|(
name|connector
argument_list|)
decl_stmt|;
name|struct
name|radeon_connector_atom_dig
modifier|*
name|dig_connector
init|=
name|radeon_connector
operator|->
name|con_priv
decl_stmt|;
name|int
name|dp_clock
decl_stmt|;
name|radeon_crtc
operator|->
name|bpc
operator|=
name|radeon_get_monitor_bpc
argument_list|(
name|connector
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|encoder_mode
condition|)
block|{
case|case
name|ATOM_ENCODER_MODE_DP_MST
case|:
case|case
name|ATOM_ENCODER_MODE_DP
case|:
comment|/* DP/eDP */
name|dp_clock
operator|=
name|dig_connector
operator|->
name|dp_clock
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_asic_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|ASIC_INTERNAL_SS_ON_DP
argument_list|,
name|dp_clock
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dp_clock
operator|==
literal|16200
condition|)
block|{
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_ppll_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|ATOM_DP_SS_ID2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|radeon_crtc
operator|->
name|ss_enabled
condition|)
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_ppll_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|ATOM_DP_SS_ID1
argument_list|)
expr_stmt|;
block|}
else|else
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_ppll_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|ATOM_DP_SS_ID1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ATOM_ENCODER_MODE_LVDS
case|:
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_asic_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|dig
operator|->
name|lcd_ss_id
argument_list|,
name|mode
operator|->
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
else|else
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_ppll_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|dig
operator|->
name|lcd_ss_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM_ENCODER_MODE_DVI
case|:
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_asic_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|ASIC_INTERNAL_SS_ON_TMDS
argument_list|,
name|mode
operator|->
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM_ENCODER_MODE_HDMI
case|:
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
name|radeon_crtc
operator|->
name|ss_enabled
operator|=
name|radeon_atombios_get_asic_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|,
name|ASIC_INTERNAL_SS_ON_HDMI
argument_list|,
name|mode
operator|->
name|clock
operator|/
literal|10
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* adjust pixel clock as needed */
name|radeon_crtc
operator|->
name|adjusted_clock
operator|=
name|atombios_adjust_pll
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_crtc_set_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
name|u32
name|pll_clock
init|=
name|mode
operator|->
name|clock
decl_stmt|;
name|u32
name|ref_div
init|=
literal|0
decl_stmt|,
name|fb_div
init|=
literal|0
decl_stmt|,
name|frac_fb_div
init|=
literal|0
decl_stmt|,
name|post_div
init|=
literal|0
decl_stmt|;
name|struct
name|radeon_pll
modifier|*
name|pll
decl_stmt|;
name|int
name|encoder_mode
init|=
name|atombios_get_encoder_mode
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|radeon_crtc
operator|->
name|pll_id
condition|)
block|{
case|case
name|ATOM_PPLL1
case|:
name|pll
operator|=
operator|&
name|rdev
operator|->
name|clock
operator|.
name|p1pll
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL2
case|:
name|pll
operator|=
operator|&
name|rdev
operator|->
name|clock
operator|.
name|p2pll
expr_stmt|;
break|break;
case|case
name|ATOM_DCPLL
case|:
case|case
name|ATOM_PPLL_INVALID
case|:
default|default:
name|pll
operator|=
operator|&
name|rdev
operator|->
name|clock
operator|.
name|dcpll
expr_stmt|;
break|break;
block|}
comment|/* update pll params */
name|pll
operator|->
name|flags
operator|=
name|radeon_crtc
operator|->
name|pll_flags
expr_stmt|;
name|pll
operator|->
name|reference_div
operator|=
name|radeon_crtc
operator|->
name|pll_reference_div
expr_stmt|;
name|pll
operator|->
name|post_div
operator|=
name|radeon_crtc
operator|->
name|pll_post_div
expr_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|active_device
operator|&
operator|(
name|ATOM_DEVICE_TV_SUPPORT
operator|)
condition|)
comment|/* TV seems to prefer the legacy algo on some boards */
name|radeon_compute_pll_legacy
argument_list|(
name|pll
argument_list|,
name|radeon_crtc
operator|->
name|adjusted_clock
argument_list|,
operator|&
name|pll_clock
argument_list|,
operator|&
name|fb_div
argument_list|,
operator|&
name|frac_fb_div
argument_list|,
operator|&
name|ref_div
argument_list|,
operator|&
name|post_div
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
name|radeon_compute_pll_avivo
argument_list|(
name|pll
argument_list|,
name|radeon_crtc
operator|->
name|adjusted_clock
argument_list|,
operator|&
name|pll_clock
argument_list|,
operator|&
name|fb_div
argument_list|,
operator|&
name|frac_fb_div
argument_list|,
operator|&
name|ref_div
argument_list|,
operator|&
name|post_div
argument_list|)
expr_stmt|;
else|else
name|radeon_compute_pll_legacy
argument_list|(
name|pll
argument_list|,
name|radeon_crtc
operator|->
name|adjusted_clock
argument_list|,
operator|&
name|pll_clock
argument_list|,
operator|&
name|fb_div
argument_list|,
operator|&
name|frac_fb_div
argument_list|,
operator|&
name|ref_div
argument_list|,
operator|&
name|post_div
argument_list|)
expr_stmt|;
name|atombios_crtc_program_ss
argument_list|(
name|rdev
argument_list|,
name|ATOM_DISABLE
argument_list|,
name|radeon_crtc
operator|->
name|pll_id
argument_list|,
name|radeon_crtc
operator|->
name|crtc_id
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|)
expr_stmt|;
name|atombios_crtc_program_pll
argument_list|(
name|crtc
argument_list|,
name|radeon_crtc
operator|->
name|crtc_id
argument_list|,
name|radeon_crtc
operator|->
name|pll_id
argument_list|,
name|encoder_mode
argument_list|,
name|radeon_encoder
operator|->
name|encoder_id
argument_list|,
name|mode
operator|->
name|clock
argument_list|,
name|ref_div
argument_list|,
name|fb_div
argument_list|,
name|frac_fb_div
argument_list|,
name|post_div
argument_list|,
name|radeon_crtc
operator|->
name|bpc
argument_list|,
name|radeon_crtc
operator|->
name|ss_enabled
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_crtc
operator|->
name|ss_enabled
condition|)
block|{
comment|/* calculate ss amount and step size */
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|u32
name|step_size
decl_stmt|;
name|u32
name|amount
init|=
operator|(
operator|(
operator|(
name|fb_div
operator|*
literal|10
operator|)
operator|+
name|frac_fb_div
operator|)
operator|*
name|radeon_crtc
operator|->
name|ss
operator|.
name|percentage
operator|)
operator|/
literal|10000
decl_stmt|;
name|radeon_crtc
operator|->
name|ss
operator|.
name|amount
operator|=
operator|(
name|amount
operator|/
literal|10
operator|)
operator|&
name|ATOM_PPLL_SS_AMOUNT_V2_FBDIV_MASK
expr_stmt|;
name|radeon_crtc
operator|->
name|ss
operator|.
name|amount
operator||=
operator|(
operator|(
name|amount
operator|-
operator|(
name|amount
operator|/
literal|10
operator|)
operator|)
operator|<<
name|ATOM_PPLL_SS_AMOUNT_V2_NFRAC_SHIFT
operator|)
operator|&
name|ATOM_PPLL_SS_AMOUNT_V2_NFRAC_MASK
expr_stmt|;
if|if
condition|(
name|radeon_crtc
operator|->
name|ss
operator|.
name|type
operator|&
name|ATOM_PPLL_SS_TYPE_V2_CENTRE_SPREAD
condition|)
name|step_size
operator|=
operator|(
literal|4
operator|*
name|amount
operator|*
name|ref_div
operator|*
operator|(
name|radeon_crtc
operator|->
name|ss
operator|.
name|rate
operator|*
literal|2048
operator|)
operator|)
operator|/
operator|(
literal|125
operator|*
literal|25
operator|*
name|pll
operator|->
name|reference_freq
operator|/
literal|100
operator|)
expr_stmt|;
else|else
name|step_size
operator|=
operator|(
literal|2
operator|*
name|amount
operator|*
name|ref_div
operator|*
operator|(
name|radeon_crtc
operator|->
name|ss
operator|.
name|rate
operator|*
literal|2048
operator|)
operator|)
operator|/
operator|(
literal|125
operator|*
literal|25
operator|*
name|pll
operator|->
name|reference_freq
operator|/
literal|100
operator|)
expr_stmt|;
name|radeon_crtc
operator|->
name|ss
operator|.
name|step
operator|=
name|step_size
expr_stmt|;
block|}
name|atombios_crtc_program_ss
argument_list|(
name|rdev
argument_list|,
name|ATOM_ENABLE
argument_list|,
name|radeon_crtc
operator|->
name|pll_id
argument_list|,
name|radeon_crtc
operator|->
name|crtc_id
argument_list|,
operator|&
name|radeon_crtc
operator|->
name|ss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dce4_crtc_do_set_base
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|atomic
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_framebuffer
modifier|*
name|radeon_fb
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|target_fb
decl_stmt|;
name|struct
name|drm_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|radeon_bo
modifier|*
name|rbo
decl_stmt|;
name|uint64_t
name|fb_location
decl_stmt|;
name|uint32_t
name|fb_format
decl_stmt|,
name|fb_pitch_pixels
decl_stmt|,
name|tiling_flags
decl_stmt|;
name|unsigned
name|bankw
decl_stmt|,
name|bankh
decl_stmt|,
name|mtaspect
decl_stmt|,
name|tile_split
decl_stmt|;
name|u32
name|fb_swap
init|=
name|EVERGREEN_GRPH_ENDIAN_SWAP
argument_list|(
name|EVERGREEN_GRPH_ENDIAN_NONE
argument_list|)
decl_stmt|;
name|u32
name|tmp
decl_stmt|,
name|viewport_w
decl_stmt|,
name|viewport_h
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* no fb bound */
if|if
condition|(
operator|!
name|atomic
operator|&&
operator|!
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No FB bound\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|atomic
condition|)
block|{
name|radeon_fb
operator|=
name|to_radeon_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|target_fb
operator|=
name|fb
expr_stmt|;
block|}
else|else
block|{
name|radeon_fb
operator|=
name|to_radeon_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|target_fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
block|}
comment|/* If atomic, assume fb object is pinned& idle& fenced and 	 * just update base pointers 	 */
name|obj
operator|=
name|radeon_fb
operator|->
name|obj
expr_stmt|;
name|rbo
operator|=
name|gem_to_radeon_bo
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rbo
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|r
return|;
if|if
condition|(
name|atomic
condition|)
name|fb_location
operator|=
name|radeon_bo_gpu_offset
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|radeon_bo_pin
argument_list|(
name|rbo
argument_list|,
name|RADEON_GEM_DOMAIN_VRAM
argument_list|,
operator|&
name|fb_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|radeon_bo_unreserve
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|radeon_bo_get_tiling_flags
argument_list|(
name|rbo
argument_list|,
operator|&
name|tiling_flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|target_fb
operator|->
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|fb_format
operator|=
operator|(
name|EVERGREEN_GRPH_DEPTH
argument_list|(
name|EVERGREEN_GRPH_DEPTH_8BPP
argument_list|)
operator||
name|EVERGREEN_GRPH_FORMAT
argument_list|(
name|EVERGREEN_GRPH_FORMAT_INDEXED
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|fb_format
operator|=
operator|(
name|EVERGREEN_GRPH_DEPTH
argument_list|(
name|EVERGREEN_GRPH_DEPTH_16BPP
argument_list|)
operator||
name|EVERGREEN_GRPH_FORMAT
argument_list|(
name|EVERGREEN_GRPH_FORMAT_ARGB1555
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|fb_format
operator|=
operator|(
name|EVERGREEN_GRPH_DEPTH
argument_list|(
name|EVERGREEN_GRPH_DEPTH_16BPP
argument_list|)
operator||
name|EVERGREEN_GRPH_FORMAT
argument_list|(
name|EVERGREEN_GRPH_FORMAT_ARGB565
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|fb_swap
operator|=
name|EVERGREEN_GRPH_ENDIAN_SWAP
argument_list|(
name|EVERGREEN_GRPH_ENDIAN_8IN16
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|fb_format
operator|=
operator|(
name|EVERGREEN_GRPH_DEPTH
argument_list|(
name|EVERGREEN_GRPH_DEPTH_32BPP
argument_list|)
operator||
name|EVERGREEN_GRPH_FORMAT
argument_list|(
name|EVERGREEN_GRPH_FORMAT_ARGB8888
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|fb_swap
operator|=
name|EVERGREEN_GRPH_ENDIAN_SWAP
argument_list|(
name|EVERGREEN_GRPH_ENDIAN_8IN32
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unsupported screen depth %d\n"
argument_list|,
name|target_fb
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|tiling_flags
operator|&
name|RADEON_TILING_MACRO
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_TAHITI
condition|)
name|tmp
operator|=
name|rdev
operator|->
name|config
operator|.
name|si
operator|.
name|tile_config
expr_stmt|;
elseif|else
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_CAYMAN
condition|)
name|tmp
operator|=
name|rdev
operator|->
name|config
operator|.
name|cayman
operator|.
name|tile_config
expr_stmt|;
else|else
name|tmp
operator|=
name|rdev
operator|->
name|config
operator|.
name|evergreen
operator|.
name|tile_config
expr_stmt|;
switch|switch
condition|(
operator|(
name|tmp
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* 4 banks */
name|fb_format
operator||=
name|EVERGREEN_GRPH_NUM_BANKS
argument_list|(
name|EVERGREEN_ADDR_SURF_4_BANK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 8 banks */
default|default:
name|fb_format
operator||=
name|EVERGREEN_GRPH_NUM_BANKS
argument_list|(
name|EVERGREEN_ADDR_SURF_8_BANK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 16 banks */
name|fb_format
operator||=
name|EVERGREEN_GRPH_NUM_BANKS
argument_list|(
name|EVERGREEN_ADDR_SURF_16_BANK
argument_list|)
expr_stmt|;
break|break;
block|}
name|fb_format
operator||=
name|EVERGREEN_GRPH_ARRAY_MODE
argument_list|(
name|EVERGREEN_GRPH_ARRAY_2D_TILED_THIN1
argument_list|)
expr_stmt|;
name|evergreen_tiling_fields
argument_list|(
name|tiling_flags
argument_list|,
operator|&
name|bankw
argument_list|,
operator|&
name|bankh
argument_list|,
operator|&
name|mtaspect
argument_list|,
operator|&
name|tile_split
argument_list|)
expr_stmt|;
name|fb_format
operator||=
name|EVERGREEN_GRPH_TILE_SPLIT
argument_list|(
name|tile_split
argument_list|)
expr_stmt|;
name|fb_format
operator||=
name|EVERGREEN_GRPH_BANK_WIDTH
argument_list|(
name|bankw
argument_list|)
expr_stmt|;
name|fb_format
operator||=
name|EVERGREEN_GRPH_BANK_HEIGHT
argument_list|(
name|bankh
argument_list|)
expr_stmt|;
name|fb_format
operator||=
name|EVERGREEN_GRPH_MACRO_TILE_ASPECT
argument_list|(
name|mtaspect
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tiling_flags
operator|&
name|RADEON_TILING_MICRO
condition|)
name|fb_format
operator||=
name|EVERGREEN_GRPH_ARRAY_MODE
argument_list|(
name|EVERGREEN_GRPH_ARRAY_1D_TILED_THIN1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_TAHITI
operator|)
operator|||
operator|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_PITCAIRN
operator|)
condition|)
name|fb_format
operator||=
name|SI_GRPH_PIPE_CONFIG
argument_list|(
name|SI_ADDR_SURF_P8_32x32_8x16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rdev
operator|->
name|family
operator|==
name|CHIP_VERDE
condition|)
name|fb_format
operator||=
name|SI_GRPH_PIPE_CONFIG
argument_list|(
name|SI_ADDR_SURF_P4_8x16
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|radeon_crtc
operator|->
name|crtc_id
condition|)
block|{
case|case
literal|0
case|:
name|WREG32
argument_list|(
name|AVIVO_D1VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|WREG32
argument_list|(
name|AVIVO_D2VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|WREG32
argument_list|(
name|EVERGREEN_D3VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|WREG32
argument_list|(
name|EVERGREEN_D4VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|WREG32
argument_list|(
name|EVERGREEN_D5VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|WREG32
argument_list|(
name|EVERGREEN_D6VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|upper_32_bits
argument_list|(
name|fb_location
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|upper_32_bits
argument_list|(
name|fb_location
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|u32
operator|)
name|fb_location
operator|&
name|EVERGREEN_GRPH_SURFACE_ADDRESS_MASK
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|u32
operator|)
name|fb_location
operator|&
name|EVERGREEN_GRPH_SURFACE_ADDRESS_MASK
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|fb_format
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_SWAP_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|fb_swap
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_SURFACE_OFFSET_X
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_SURFACE_OFFSET_Y
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_X_START
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_Y_START
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_X_END
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|target_fb
operator|->
name|width
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_Y_END
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|target_fb
operator|->
name|height
argument_list|)
expr_stmt|;
name|fb_pitch_pixels
operator|=
name|target_fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|/
operator|(
name|target_fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_PITCH
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|fb_pitch_pixels
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_ENABLE
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_DESKTOP_HEIGHT
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|target_fb
operator|->
name|height
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
literal|3
expr_stmt|;
name|y
operator|&=
operator|~
literal|1
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_VIEWPORT_START
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|viewport_w
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|viewport_h
operator|=
operator|(
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_VIEWPORT_SIZE
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|viewport_w
operator|<<
literal|16
operator|)
operator||
name|viewport_h
argument_list|)
expr_stmt|;
comment|/* pageflip setup */
comment|/* make sure flip is at vb rather than hb */
name|tmp
operator|=
name|RREG32
argument_list|(
name|EVERGREEN_GRPH_FLIP_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|EVERGREEN_GRPH_SURFACE_UPDATE_H_RETRACE_EN
expr_stmt|;
name|WREG32
argument_list|(
name|EVERGREEN_GRPH_FLIP_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* set pageflip to happen anywhere in vblank interval */
name|WREG32
argument_list|(
name|EVERGREEN_MASTER_UPDATE_MODE
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atomic
operator|&&
name|fb
operator|&&
name|fb
operator|!=
name|crtc
operator|->
name|fb
condition|)
block|{
name|radeon_fb
operator|=
name|to_radeon_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|rbo
operator|=
name|gem_to_radeon_bo
argument_list|(
name|radeon_fb
operator|->
name|obj
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rbo
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|r
return|;
name|radeon_bo_unpin
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
block|}
comment|/* Bytes per pixel may have changed */
name|radeon_bandwidth_update
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|avivo_crtc_do_set_base
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|atomic
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_framebuffer
modifier|*
name|radeon_fb
decl_stmt|;
name|struct
name|drm_gem_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|radeon_bo
modifier|*
name|rbo
decl_stmt|;
name|struct
name|drm_framebuffer
modifier|*
name|target_fb
decl_stmt|;
name|uint64_t
name|fb_location
decl_stmt|;
name|uint32_t
name|fb_format
decl_stmt|,
name|fb_pitch_pixels
decl_stmt|,
name|tiling_flags
decl_stmt|;
name|u32
name|fb_swap
init|=
name|R600_D1GRPH_SWAP_ENDIAN_NONE
decl_stmt|;
name|u32
name|tmp
decl_stmt|,
name|viewport_w
decl_stmt|,
name|viewport_h
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* no fb bound */
if|if
condition|(
operator|!
name|atomic
operator|&&
operator|!
name|crtc
operator|->
name|fb
condition|)
block|{
name|DRM_DEBUG_KMS
argument_list|(
literal|"No FB bound\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|atomic
condition|)
block|{
name|radeon_fb
operator|=
name|to_radeon_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|target_fb
operator|=
name|fb
expr_stmt|;
block|}
else|else
block|{
name|radeon_fb
operator|=
name|to_radeon_framebuffer
argument_list|(
name|crtc
operator|->
name|fb
argument_list|)
expr_stmt|;
name|target_fb
operator|=
name|crtc
operator|->
name|fb
expr_stmt|;
block|}
name|obj
operator|=
name|radeon_fb
operator|->
name|obj
expr_stmt|;
name|rbo
operator|=
name|gem_to_radeon_bo
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rbo
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|r
return|;
comment|/* If atomic, assume fb object is pinned& idle& fenced and 	 * just update base pointers 	 */
if|if
condition|(
name|atomic
condition|)
name|fb_location
operator|=
name|radeon_bo_gpu_offset
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|radeon_bo_pin
argument_list|(
name|rbo
argument_list|,
name|RADEON_GEM_DOMAIN_VRAM
argument_list|,
operator|&
name|fb_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|radeon_bo_unreserve
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
name|radeon_bo_get_tiling_flags
argument_list|(
name|rbo
argument_list|,
operator|&
name|tiling_flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|target_fb
operator|->
name|bits_per_pixel
condition|)
block|{
case|case
literal|8
case|:
name|fb_format
operator|=
name|AVIVO_D1GRPH_CONTROL_DEPTH_8BPP
operator||
name|AVIVO_D1GRPH_CONTROL_8BPP_INDEXED
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|fb_format
operator|=
name|AVIVO_D1GRPH_CONTROL_DEPTH_16BPP
operator||
name|AVIVO_D1GRPH_CONTROL_16BPP_ARGB1555
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|fb_format
operator|=
name|AVIVO_D1GRPH_CONTROL_DEPTH_16BPP
operator||
name|AVIVO_D1GRPH_CONTROL_16BPP_RGB565
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|fb_swap
operator|=
name|R600_D1GRPH_SWAP_ENDIAN_16BIT
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|fb_format
operator|=
name|AVIVO_D1GRPH_CONTROL_DEPTH_32BPP
operator||
name|AVIVO_D1GRPH_CONTROL_32BPP_ARGB8888
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|fb_swap
operator|=
name|R600_D1GRPH_SWAP_ENDIAN_32BIT
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|DRM_ERROR
argument_list|(
literal|"Unsupported screen depth %d\n"
argument_list|,
name|target_fb
operator|->
name|bits_per_pixel
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_R600
condition|)
block|{
if|if
condition|(
name|tiling_flags
operator|&
name|RADEON_TILING_MACRO
condition|)
name|fb_format
operator||=
name|R600_D1GRPH_ARRAY_MODE_2D_TILED_THIN1
expr_stmt|;
elseif|else
if|if
condition|(
name|tiling_flags
operator|&
name|RADEON_TILING_MICRO
condition|)
name|fb_format
operator||=
name|R600_D1GRPH_ARRAY_MODE_1D_TILED_THIN1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tiling_flags
operator|&
name|RADEON_TILING_MACRO
condition|)
name|fb_format
operator||=
name|AVIVO_D1GRPH_MACRO_ADDRESS_MODE
expr_stmt|;
if|if
condition|(
name|tiling_flags
operator|&
name|RADEON_TILING_MICRO
condition|)
name|fb_format
operator||=
name|AVIVO_D1GRPH_TILED
expr_stmt|;
block|}
if|if
condition|(
name|radeon_crtc
operator|->
name|crtc_id
operator|==
literal|0
condition|)
name|WREG32
argument_list|(
name|AVIVO_D1VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|WREG32
argument_list|(
name|AVIVO_D2VGA_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_RV770
condition|)
block|{
if|if
condition|(
name|radeon_crtc
operator|->
name|crtc_id
condition|)
block|{
name|WREG32
argument_list|(
name|R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH
argument_list|,
name|upper_32_bits
argument_list|(
name|fb_location
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH
argument_list|,
name|upper_32_bits
argument_list|(
name|fb_location
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WREG32
argument_list|(
name|R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH
argument_list|,
name|upper_32_bits
argument_list|(
name|fb_location
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH
argument_list|,
name|upper_32_bits
argument_list|(
name|fb_location
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|u32
operator|)
name|fb_location
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|u32
operator|)
name|fb_location
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|fb_format
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdev
operator|->
name|family
operator|>=
name|CHIP_R600
condition|)
name|WREG32
argument_list|(
name|R600_D1GRPH_SWAP_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|fb_swap
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_SURFACE_OFFSET_X
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_SURFACE_OFFSET_Y
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_X_START
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_Y_START
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_X_END
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|target_fb
operator|->
name|width
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_Y_END
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|target_fb
operator|->
name|height
argument_list|)
expr_stmt|;
name|fb_pitch_pixels
operator|=
name|target_fb
operator|->
name|pitches
index|[
literal|0
index|]
operator|/
operator|(
name|target_fb
operator|->
name|bits_per_pixel
operator|/
literal|8
operator|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_PITCH
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|fb_pitch_pixels
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_ENABLE
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1MODE_DESKTOP_HEIGHT
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|target_fb
operator|->
name|height
argument_list|)
expr_stmt|;
name|x
operator|&=
operator|~
literal|3
expr_stmt|;
name|y
operator|&=
operator|~
literal|1
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1MODE_VIEWPORT_START
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|x
operator|<<
literal|16
operator|)
operator||
name|y
argument_list|)
expr_stmt|;
name|viewport_w
operator|=
name|crtc
operator|->
name|mode
operator|.
name|hdisplay
expr_stmt|;
name|viewport_h
operator|=
operator|(
name|crtc
operator|->
name|mode
operator|.
name|vdisplay
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1MODE_VIEWPORT_SIZE
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
operator|(
name|viewport_w
operator|<<
literal|16
operator|)
operator||
name|viewport_h
argument_list|)
expr_stmt|;
comment|/* pageflip setup */
comment|/* make sure flip is at vb rather than hb */
name|tmp
operator|=
name|RREG32
argument_list|(
name|AVIVO_D1GRPH_FLIP_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|AVIVO_D1GRPH_SURFACE_UPDATE_H_RETRACE_EN
expr_stmt|;
name|WREG32
argument_list|(
name|AVIVO_D1GRPH_FLIP_CONTROL
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* set pageflip to happen anywhere in vblank interval */
name|WREG32
argument_list|(
name|AVIVO_D1MODE_MASTER_UPDATE_MODE
operator|+
name|radeon_crtc
operator|->
name|crtc_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atomic
operator|&&
name|fb
operator|&&
name|fb
operator|!=
name|crtc
operator|->
name|fb
condition|)
block|{
name|radeon_fb
operator|=
name|to_radeon_framebuffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|rbo
operator|=
name|gem_to_radeon_bo
argument_list|(
name|radeon_fb
operator|->
name|obj
argument_list|)
expr_stmt|;
name|r
operator|=
name|radeon_bo_reserve
argument_list|(
name|rbo
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|r
return|;
name|radeon_bo_unpin
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
name|radeon_bo_unreserve
argument_list|(
name|rbo
argument_list|)
expr_stmt|;
block|}
comment|/* Bytes per pixel may have changed */
name|radeon_bandwidth_update
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|atombios_crtc_set_base
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
return|return
name|dce4_crtc_do_set_base
argument_list|(
name|crtc
argument_list|,
name|old_fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
return|return
name|avivo_crtc_do_set_base
argument_list|(
name|crtc
argument_list|,
name|old_fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|radeon_crtc_do_set_base
argument_list|(
name|crtc
argument_list|,
name|old_fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|atombios_crtc_set_base_atomic
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|fb
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|enum
name|mode_set_atomic
name|state
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
return|return
name|dce4_crtc_do_set_base
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
return|return
name|avivo_crtc_do_set_base
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|radeon_crtc_do_set_base
argument_list|(
name|crtc
argument_list|,
name|fb
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* properly set additional regs when using atombios */
end_comment

begin_function
specifier|static
name|void
name|radeon_legacy_atom_fixup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|u32
name|disp_merge_cntl
decl_stmt|;
switch|switch
condition|(
name|radeon_crtc
operator|->
name|crtc_id
condition|)
block|{
case|case
literal|0
case|:
name|disp_merge_cntl
operator|=
name|RREG32
argument_list|(
name|RADEON_DISP_MERGE_CNTL
argument_list|)
expr_stmt|;
name|disp_merge_cntl
operator|&=
operator|~
name|RADEON_DISP_RGB_OFFSET_EN
expr_stmt|;
name|WREG32
argument_list|(
name|RADEON_DISP_MERGE_CNTL
argument_list|,
name|disp_merge_cntl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|disp_merge_cntl
operator|=
name|RREG32
argument_list|(
name|RADEON_DISP2_MERGE_CNTL
argument_list|)
expr_stmt|;
name|disp_merge_cntl
operator|&=
operator|~
name|RADEON_DISP2_RGB_OFFSET_EN
expr_stmt|;
name|WREG32
argument_list|(
name|RADEON_DISP2_MERGE_CNTL
argument_list|,
name|disp_merge_cntl
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|RADEON_FP_H2_SYNC_STRT_WID
argument_list|,
name|RREG32
argument_list|(
name|RADEON_CRTC2_H_SYNC_STRT_WID
argument_list|)
argument_list|)
expr_stmt|;
name|WREG32
argument_list|(
name|RADEON_FP_V2_SYNC_STRT_WID
argument_list|,
name|RREG32
argument_list|(
name|RADEON_CRTC2_V_SYNC_STRT_WID
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * radeon_get_pll_use_mask - look up a mask of which pplls are in use  *  * @crtc: drm crtc  *  * Returns the mask of which PPLLs (Pixel PLLs) are in use.  */
end_comment

begin_function
specifier|static
name|u32
name|radeon_get_pll_use_mask
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|test_crtc
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|test_radeon_crtc
decl_stmt|;
name|u32
name|pll_in_use
init|=
literal|0
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|test_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|==
name|test_crtc
condition|)
continue|continue;
name|test_radeon_crtc
operator|=
name|to_radeon_crtc
argument_list|(
name|test_crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_radeon_crtc
operator|->
name|pll_id
operator|!=
name|ATOM_PPLL_INVALID
condition|)
name|pll_in_use
operator||=
operator|(
literal|1
operator|<<
name|test_radeon_crtc
operator|->
name|pll_id
operator|)
expr_stmt|;
block|}
return|return
name|pll_in_use
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_get_shared_dp_ppll - return the PPLL used by another crtc for DP  *  * @crtc: drm crtc  *  * Returns the PPLL (Pixel PLL) used by another crtc/encoder which is  * also in DP mode.  For DP, a single PPLL can be used for all DP  * crtcs/encoders.  */
end_comment

begin_function
specifier|static
name|int
name|radeon_get_shared_dp_ppll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|test_crtc
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|test_radeon_crtc
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|test_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|==
name|test_crtc
condition|)
continue|continue;
name|test_radeon_crtc
operator|=
name|to_radeon_crtc
argument_list|(
name|test_crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_radeon_crtc
operator|->
name|encoder
operator|&&
name|ENCODER_MODE_IS_DP
argument_list|(
name|atombios_get_encoder_mode
argument_list|(
name|test_radeon_crtc
operator|->
name|encoder
argument_list|)
argument_list|)
condition|)
block|{
comment|/* for DP use the same PLL for all */
if|if
condition|(
name|test_radeon_crtc
operator|->
name|pll_id
operator|!=
name|ATOM_PPLL_INVALID
condition|)
return|return
name|test_radeon_crtc
operator|->
name|pll_id
return|;
block|}
block|}
return|return
name|ATOM_PPLL_INVALID
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_get_shared_nondp_ppll - return the PPLL used by another non-DP crtc  *  * @crtc: drm crtc  * @encoder: drm encoder  *  * Returns the PPLL (Pixel PLL) used by another non-DP crtc/encoder which can  * be shared (i.e., same clock).  */
end_comment

begin_function
specifier|static
name|int
name|radeon_get_shared_nondp_ppll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_crtc
modifier|*
name|test_crtc
decl_stmt|;
name|struct
name|radeon_crtc
modifier|*
name|test_radeon_crtc
decl_stmt|;
name|u32
name|adjusted_clock
decl_stmt|,
name|test_adjusted_clock
decl_stmt|;
name|adjusted_clock
operator|=
name|radeon_crtc
operator|->
name|adjusted_clock
expr_stmt|;
if|if
condition|(
name|adjusted_clock
operator|==
literal|0
condition|)
return|return
name|ATOM_PPLL_INVALID
return|;
name|list_for_each_entry
argument_list|(
argument|test_crtc
argument_list|,
argument|&dev->mode_config.crtc_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|crtc
operator|==
name|test_crtc
condition|)
continue|continue;
name|test_radeon_crtc
operator|=
name|to_radeon_crtc
argument_list|(
name|test_crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_radeon_crtc
operator|->
name|encoder
operator|&&
operator|!
name|ENCODER_MODE_IS_DP
argument_list|(
name|atombios_get_encoder_mode
argument_list|(
name|test_radeon_crtc
operator|->
name|encoder
argument_list|)
argument_list|)
condition|)
block|{
comment|/* check if we are already driving this connector with another crtc */
if|if
condition|(
name|test_radeon_crtc
operator|->
name|connector
operator|==
name|radeon_crtc
operator|->
name|connector
condition|)
block|{
comment|/* if we are, return that pll */
if|if
condition|(
name|test_radeon_crtc
operator|->
name|pll_id
operator|!=
name|ATOM_PPLL_INVALID
condition|)
return|return
name|test_radeon_crtc
operator|->
name|pll_id
return|;
block|}
comment|/* for non-DP check the clock */
name|test_adjusted_clock
operator|=
name|test_radeon_crtc
operator|->
name|adjusted_clock
expr_stmt|;
if|if
condition|(
operator|(
name|crtc
operator|->
name|mode
operator|.
name|clock
operator|==
name|test_crtc
operator|->
name|mode
operator|.
name|clock
operator|)
operator|&&
operator|(
name|adjusted_clock
operator|==
name|test_adjusted_clock
operator|)
operator|&&
operator|(
name|radeon_crtc
operator|->
name|ss_enabled
operator|==
name|test_radeon_crtc
operator|->
name|ss_enabled
operator|)
operator|&&
operator|(
name|test_radeon_crtc
operator|->
name|pll_id
operator|!=
name|ATOM_PPLL_INVALID
operator|)
condition|)
return|return
name|test_radeon_crtc
operator|->
name|pll_id
return|;
block|}
block|}
return|return
name|ATOM_PPLL_INVALID
return|;
block|}
end_function

begin_comment
comment|/**  * radeon_atom_pick_pll - Allocate a PPLL for use by the crtc.  *  * @crtc: drm crtc  *  * Returns the PPLL (Pixel PLL) to be used by the crtc.  For DP monitors  * a single PPLL can be used for all DP crtcs/encoders.  For non-DP  * monitors a dedicated PPLL must be used.  If a particular board has  * an external DP PLL, return ATOM_PPLL_INVALID to skip PLL programming  * as there is no need to program the PLL itself.  If we are not able to  * allocate a PLL, return ATOM_PPLL_INVALID to skip PLL programming to  * avoid messing up an existing monitor.  *  * Asic specific PLL information  *  * DCE 6.1  * - PPLL2 is only available to UNIPHYA (both DP and non-DP)  * - PPLL0, PPLL1 are available for UNIPHYB/C/D/E/F (both DP and non-DP)  *  * DCE 6.0  * - PPLL0 is available to all UNIPHY (DP only)  * - PPLL1, PPLL2 are available for all UNIPHY (both DP and non-DP) and DAC  *  * DCE 5.0  * - DCPLL is available to all UNIPHY (DP only)  * - PPLL1, PPLL2 are available for all UNIPHY (both DP and non-DP) and DAC  *  * DCE 3.0/4.0/4.1  * - PPLL1, PPLL2 are available for all UNIPHY (both DP and non-DP) and DAC  *  */
end_comment

begin_function
specifier|static
name|int
name|radeon_atom_pick_pll
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
name|u32
name|pll_in_use
decl_stmt|;
name|int
name|pll
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE61
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|struct
name|radeon_encoder_atom_dig
modifier|*
name|dig
init|=
name|radeon_encoder
operator|->
name|enc_priv
decl_stmt|;
if|if
condition|(
operator|(
name|radeon_encoder
operator|->
name|encoder_id
operator|==
name|ENCODER_OBJECT_ID_INTERNAL_UNIPHY
operator|)
operator|&&
operator|(
name|dig
operator|->
name|linkb
operator|==
name|false
operator|)
condition|)
comment|/* UNIPHY A uses PPLL2 */
return|return
name|ATOM_PPLL2
return|;
elseif|else
if|if
condition|(
name|ENCODER_MODE_IS_DP
argument_list|(
name|atombios_get_encoder_mode
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
argument_list|)
condition|)
block|{
comment|/* UNIPHY B/C/D/E/F */
if|if
condition|(
name|rdev
operator|->
name|clock
operator|.
name|dp_extclk
condition|)
comment|/* skip PPLL programming if using ext clock */
return|return
name|ATOM_PPLL_INVALID
return|;
else|else
block|{
comment|/* use the same PPLL for all DP monitors */
name|pll
operator|=
name|radeon_get_shared_dp_ppll
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|!=
name|ATOM_PPLL_INVALID
condition|)
return|return
name|pll
return|;
block|}
block|}
else|else
block|{
comment|/* use the same PPLL for all monitors with the same clock */
name|pll
operator|=
name|radeon_get_shared_nondp_ppll
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|!=
name|ATOM_PPLL_INVALID
condition|)
return|return
name|pll
return|;
block|}
comment|/* UNIPHY B/C/D/E/F */
name|pll_in_use
operator|=
name|radeon_get_pll_use_mask
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pll_in_use
operator|&
operator|(
literal|1
operator|<<
name|ATOM_PPLL0
operator|)
operator|)
condition|)
return|return
name|ATOM_PPLL0
return|;
if|if
condition|(
operator|!
operator|(
name|pll_in_use
operator|&
operator|(
literal|1
operator|<<
name|ATOM_PPLL1
operator|)
operator|)
condition|)
return|return
name|ATOM_PPLL1
return|;
name|DRM_ERROR
argument_list|(
literal|"unable to allocate a PPLL\n"
argument_list|)
expr_stmt|;
return|return
name|ATOM_PPLL_INVALID
return|;
block|}
elseif|else
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
comment|/* in DP mode, the DP ref clock can come from PPLL, DCPLL, or ext clock, 		 * depending on the asic: 		 * DCE4: PPLL or ext clock 		 * DCE5: PPLL, DCPLL, or ext clock 		 * DCE6: PPLL, PPLL0, or ext clock 		 * 		 * Setting ATOM_PPLL_INVALID will cause SetPixelClock to skip 		 * PPLL/DCPLL programming and only program the DP DTO for the 		 * crtc virtual pixel clock. 		 */
if|if
condition|(
name|ENCODER_MODE_IS_DP
argument_list|(
name|atombios_get_encoder_mode
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdev
operator|->
name|clock
operator|.
name|dp_extclk
condition|)
comment|/* skip PPLL programming if using ext clock */
return|return
name|ATOM_PPLL_INVALID
return|;
elseif|else
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
comment|/* use PPLL0 for all DP */
return|return
name|ATOM_PPLL0
return|;
elseif|else
if|if
condition|(
name|ASIC_IS_DCE5
argument_list|(
name|rdev
argument_list|)
condition|)
comment|/* use DCPLL for all DP */
return|return
name|ATOM_DCPLL
return|;
else|else
block|{
comment|/* use the same PPLL for all DP monitors */
name|pll
operator|=
name|radeon_get_shared_dp_ppll
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|!=
name|ATOM_PPLL_INVALID
condition|)
return|return
name|pll
return|;
block|}
block|}
else|else
block|{
comment|/* use the same PPLL for all monitors with the same clock */
name|pll
operator|=
name|radeon_get_shared_nondp_ppll
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pll
operator|!=
name|ATOM_PPLL_INVALID
condition|)
return|return
name|pll
return|;
block|}
comment|/* all other cases */
name|pll_in_use
operator|=
name|radeon_get_pll_use_mask
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pll_in_use
operator|&
operator|(
literal|1
operator|<<
name|ATOM_PPLL1
operator|)
operator|)
condition|)
return|return
name|ATOM_PPLL1
return|;
if|if
condition|(
operator|!
operator|(
name|pll_in_use
operator|&
operator|(
literal|1
operator|<<
name|ATOM_PPLL2
operator|)
operator|)
condition|)
return|return
name|ATOM_PPLL2
return|;
name|DRM_ERROR
argument_list|(
literal|"unable to allocate a PPLL\n"
argument_list|)
expr_stmt|;
return|return
name|ATOM_PPLL_INVALID
return|;
block|}
else|else
block|{
comment|/* on pre-R5xx asics, the crtc to pll mapping is hardcoded */
comment|/* some atombios (observed in some DCE2/DCE3) code have a bug, 		 * the matching btw pll and crtc is done through 		 * PCLK_CRTC[1|2]_CNTL (0x480/0x484) but atombios code use the 		 * pll (1 or 2) to select which register to write. ie if using 		 * pll1 it will use PCLK_CRTC1_CNTL (0x480) and if using pll2 		 * it will use PCLK_CRTC2_CNTL (0x484), it then use crtc id to 		 * choose which value to write. Which is reverse order from 		 * register logic. So only case that works is when pllid is 		 * same as crtcid or when both pll and crtc are enabled and 		 * both use same clock. 		 * 		 * So just return crtc id as if crtc and pll were hard linked 		 * together even if they aren't 		 */
return|return
name|radeon_crtc
operator|->
name|crtc_id
return|;
block|}
block|}
end_function

begin_function
name|void
name|radeon_atom_disp_eng_pll_init
parameter_list|(
name|struct
name|radeon_device
modifier|*
name|rdev
parameter_list|)
block|{
comment|/* always set DCPLL */
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
name|atombios_crtc_set_disp_eng_pll
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|clock
operator|.
name|default_dispclk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
name|struct
name|radeon_atom_ss
name|ss
decl_stmt|;
name|bool
name|ss_enabled
init|=
name|radeon_atombios_get_asic_ss_info
argument_list|(
name|rdev
argument_list|,
operator|&
name|ss
argument_list|,
name|ASIC_INTERNAL_SS_ON_DCPLL
argument_list|,
name|rdev
operator|->
name|clock
operator|.
name|default_dispclk
argument_list|)
decl_stmt|;
if|if
condition|(
name|ss_enabled
condition|)
name|atombios_crtc_program_ss
argument_list|(
name|rdev
argument_list|,
name|ATOM_DISABLE
argument_list|,
name|ATOM_DCPLL
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
comment|/* XXX: DCE5, make sure voltage, dispclk is high enough */
name|atombios_crtc_set_disp_eng_pll
argument_list|(
name|rdev
argument_list|,
name|rdev
operator|->
name|clock
operator|.
name|default_dispclk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss_enabled
condition|)
name|atombios_crtc_program_ss
argument_list|(
name|rdev
argument_list|,
name|ATOM_ENABLE
argument_list|,
name|ATOM_DCPLL
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|atombios_crtc_mode_set
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|struct
name|drm_framebuffer
modifier|*
name|old_fb
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_encoder
modifier|*
name|radeon_encoder
init|=
name|to_radeon_encoder
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
decl_stmt|;
name|bool
name|is_tvcv
init|=
name|false
decl_stmt|;
if|if
condition|(
name|radeon_encoder
operator|->
name|active_device
operator|&
operator|(
name|ATOM_DEVICE_TV_SUPPORT
operator||
name|ATOM_DEVICE_CV_SUPPORT
operator|)
condition|)
name|is_tvcv
operator|=
name|true
expr_stmt|;
name|atombios_crtc_set_pll
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
name|atombios_set_crtc_dtd_timing
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ASIC_IS_AVIVO
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_tvcv
condition|)
name|atombios_crtc_set_timing
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
else|else
name|atombios_set_crtc_dtd_timing
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atombios_crtc_set_timing
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|radeon_crtc
operator|->
name|crtc_id
operator|==
literal|0
condition|)
name|atombios_set_crtc_dtd_timing
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|radeon_legacy_atom_fixup
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
block|}
name|atombios_crtc_set_base
argument_list|(
name|crtc
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|old_fb
argument_list|)
expr_stmt|;
name|atombios_overscan_setup
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
expr_stmt|;
name|atombios_scaler_setup
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|atombios_crtc_mode_fixup
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|,
specifier|const
name|struct
name|drm_display_mode
modifier|*
name|mode
parameter_list|,
name|struct
name|drm_display_mode
modifier|*
name|adjusted_mode
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|drm_encoder
modifier|*
name|encoder
decl_stmt|;
comment|/* assign the encoder to the radeon crtc to avoid repeated lookups later */
name|list_for_each_entry
argument_list|(
argument|encoder
argument_list|,
argument|&dev->mode_config.encoder_list
argument_list|,
argument|head
argument_list|)
block|{
if|if
condition|(
name|encoder
operator|->
name|crtc
operator|==
name|crtc
condition|)
block|{
name|radeon_crtc
operator|->
name|encoder
operator|=
name|encoder
expr_stmt|;
name|radeon_crtc
operator|->
name|connector
operator|=
name|radeon_get_connector_for_encoder
argument_list|(
name|encoder
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|radeon_crtc
operator|->
name|encoder
operator|==
name|NULL
operator|)
operator|||
operator|(
name|radeon_crtc
operator|->
name|connector
operator|==
name|NULL
operator|)
condition|)
block|{
name|radeon_crtc
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
name|radeon_crtc
operator|->
name|connector
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|radeon_crtc_scaling_mode_fixup
argument_list|(
name|crtc
argument_list|,
name|mode
argument_list|,
name|adjusted_mode
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|atombios_crtc_prepare_pll
argument_list|(
name|crtc
argument_list|,
name|adjusted_mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* pick pll */
name|radeon_crtc
operator|->
name|pll_id
operator|=
name|radeon_atom_pick_pll
argument_list|(
name|crtc
argument_list|)
expr_stmt|;
comment|/* if we can't get a PPLL for a non-DP encoder, fail */
if|if
condition|(
operator|(
name|radeon_crtc
operator|->
name|pll_id
operator|==
name|ATOM_PPLL_INVALID
operator|)
operator|&&
operator|!
name|ENCODER_MODE_IS_DP
argument_list|(
name|atombios_get_encoder_mode
argument_list|(
name|radeon_crtc
operator|->
name|encoder
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_crtc_prepare
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|radeon_crtc
operator|->
name|in_mode_set
operator|=
name|true
expr_stmt|;
comment|/* disable crtc pair power gating before programming */
if|if
condition|(
name|ASIC_IS_DCE6
argument_list|(
name|rdev
argument_list|)
condition|)
name|atombios_powergate_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_DISABLE
argument_list|)
expr_stmt|;
name|atombios_lock_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_ENABLE
argument_list|)
expr_stmt|;
name|atombios_crtc_dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_crtc_commit
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|atombios_crtc_dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_ON
argument_list|)
expr_stmt|;
name|atombios_lock_crtc
argument_list|(
name|crtc
argument_list|,
name|ATOM_DISABLE
argument_list|)
expr_stmt|;
name|radeon_crtc
operator|->
name|in_mode_set
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atombios_crtc_disable
parameter_list|(
name|struct
name|drm_crtc
modifier|*
name|crtc
parameter_list|)
block|{
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
init|=
name|to_radeon_crtc
argument_list|(
name|crtc
argument_list|)
decl_stmt|;
name|struct
name|drm_device
modifier|*
name|dev
init|=
name|crtc
operator|->
name|dev
decl_stmt|;
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
name|struct
name|radeon_atom_ss
name|ss
decl_stmt|;
name|int
name|i
decl_stmt|;
name|atombios_crtc_dpms
argument_list|(
name|crtc
argument_list|,
name|DRM_MODE_DPMS_OFF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdev
operator|->
name|num_crtc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rdev
operator|->
name|mode_info
operator|.
name|crtcs
index|[
name|i
index|]
operator|&&
name|rdev
operator|->
name|mode_info
operator|.
name|crtcs
index|[
name|i
index|]
operator|->
name|enabled
operator|&&
name|i
operator|!=
name|radeon_crtc
operator|->
name|crtc_id
operator|&&
name|radeon_crtc
operator|->
name|pll_id
operator|==
name|rdev
operator|->
name|mode_info
operator|.
name|crtcs
index|[
name|i
index|]
operator|->
name|pll_id
condition|)
block|{
comment|/* one other crtc is using this pll don't turn 			 * off the pll 			 */
goto|goto
name|done
goto|;
block|}
block|}
switch|switch
condition|(
name|radeon_crtc
operator|->
name|pll_id
condition|)
block|{
case|case
name|ATOM_PPLL1
case|:
case|case
name|ATOM_PPLL2
case|:
comment|/* disable the ppll */
name|atombios_crtc_program_pll
argument_list|(
name|crtc
argument_list|,
name|radeon_crtc
operator|->
name|crtc_id
argument_list|,
name|radeon_crtc
operator|->
name|pll_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ATOM_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM_PPLL0
case|:
comment|/* disable the ppll */
if|if
condition|(
name|ASIC_IS_DCE61
argument_list|(
name|rdev
argument_list|)
condition|)
name|atombios_crtc_program_pll
argument_list|(
name|crtc
argument_list|,
name|radeon_crtc
operator|->
name|crtc_id
argument_list|,
name|radeon_crtc
operator|->
name|pll_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ATOM_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|done
label|:
name|radeon_crtc
operator|->
name|pll_id
operator|=
name|ATOM_PPLL_INVALID
expr_stmt|;
name|radeon_crtc
operator|->
name|adjusted_clock
operator|=
literal|0
expr_stmt|;
name|radeon_crtc
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
name|radeon_crtc
operator|->
name|connector
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|drm_crtc_helper_funcs
name|atombios_helper_funcs
init|=
block|{
operator|.
name|dpms
operator|=
name|atombios_crtc_dpms
block|,
operator|.
name|mode_fixup
operator|=
name|atombios_crtc_mode_fixup
block|,
operator|.
name|mode_set
operator|=
name|atombios_crtc_mode_set
block|,
operator|.
name|mode_set_base
operator|=
name|atombios_crtc_set_base
block|,
operator|.
name|mode_set_base_atomic
operator|=
name|atombios_crtc_set_base_atomic
block|,
operator|.
name|prepare
operator|=
name|atombios_crtc_prepare
block|,
operator|.
name|commit
operator|=
name|atombios_crtc_commit
block|,
operator|.
name|load_lut
operator|=
name|radeon_crtc_load_lut
block|,
operator|.
name|disable
operator|=
name|atombios_crtc_disable
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|radeon_atombios_init_crtc
parameter_list|(
name|struct
name|drm_device
modifier|*
name|dev
parameter_list|,
name|struct
name|radeon_crtc
modifier|*
name|radeon_crtc
parameter_list|)
block|{
name|struct
name|radeon_device
modifier|*
name|rdev
init|=
name|dev
operator|->
name|dev_private
decl_stmt|;
if|if
condition|(
name|ASIC_IS_DCE4
argument_list|(
name|rdev
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|radeon_crtc
operator|->
name|crtc_id
condition|)
block|{
case|case
literal|0
case|:
default|default:
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
name|EVERGREEN_CRTC0_REGISTER_OFFSET
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
name|EVERGREEN_CRTC1_REGISTER_OFFSET
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
name|EVERGREEN_CRTC2_REGISTER_OFFSET
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
name|EVERGREEN_CRTC3_REGISTER_OFFSET
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
name|EVERGREEN_CRTC4_REGISTER_OFFSET
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
name|EVERGREEN_CRTC5_REGISTER_OFFSET
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|radeon_crtc
operator|->
name|crtc_id
operator|==
literal|1
condition|)
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
name|AVIVO_D2CRTC_H_TOTAL
operator|-
name|AVIVO_D1CRTC_H_TOTAL
expr_stmt|;
else|else
name|radeon_crtc
operator|->
name|crtc_offset
operator|=
literal|0
expr_stmt|;
block|}
name|radeon_crtc
operator|->
name|pll_id
operator|=
name|ATOM_PPLL_INVALID
expr_stmt|;
name|radeon_crtc
operator|->
name|adjusted_clock
operator|=
literal|0
expr_stmt|;
name|radeon_crtc
operator|->
name|encoder
operator|=
name|NULL
expr_stmt|;
name|radeon_crtc
operator|->
name|connector
operator|=
name|NULL
expr_stmt|;
name|drm_crtc_helper_add
argument_list|(
operator|&
name|radeon_crtc
operator|->
name|base
argument_list|,
operator|&
name|atombios_helper_funcs
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

