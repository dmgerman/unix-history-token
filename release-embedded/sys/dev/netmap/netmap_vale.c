begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013-2014 Universita` di Pisa. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This module implements the VALE switch for netmap  --- VALE SWITCH ---  NMG_LOCK() serializes all modifications to switches and ports. A switch cannot be deleted until all ports are gone.  For each switch, an SX lock (RWlock on linux) protects deletion of ports. When configuring or deleting a new port, the lock is acquired in exclusive mode (after holding NMG_LOCK). When forwarding, the lock is acquired in shared mode (without NMG_LOCK). The lock is held throughout the entire forwarding cycle, during which the thread may incur in a page fault. Hence it is important that sleepable shared locks are used.  On the rx ring, the per-port lock is grabbed initially to reserve a number of slot in the ring, then the lock is released, packets are copied from source to destination, and then the lock is acquired again and the receive ring is updated. (A similar thing is done on the tx ring for NIC and host stack ports attached to the switch)   */
end_comment

begin_comment
comment|/*  * OS-specific code that is used only within this file.  * Other OS-specific code that must be accessed by drivers  * is present in netmap_kern.h  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* prerequisite */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* defines used in kernel.h */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* types used in module initialization */
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw struct, UID, GID */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_comment
comment|/* struct socket */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* sockaddrs */
end_comment

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/* BIOCIMMEDIATE */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_comment
comment|/* bus_dmamap_* */
end_comment

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_define
define|#
directive|define
name|BDG_RWLOCK_T
value|struct rwlock
end_define

begin_comment
comment|// struct rwlock
end_comment

begin_define
define|#
directive|define
name|BDG_RWINIT
parameter_list|(
name|b
parameter_list|)
define|\
value|rw_init_flags(&(b)->bdg_lock, "bdg lock", RW_NOWITNESS)
end_define

begin_define
define|#
directive|define
name|BDG_WLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_WUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_wunlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_rlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RTRYLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_try_rlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RUNLOCK
parameter_list|(
name|b
parameter_list|)
value|rw_runlock(&(b)->bdg_lock)
end_define

begin_define
define|#
directive|define
name|BDG_RWDESTROY
parameter_list|(
name|b
parameter_list|)
value|rw_destroy(&(b)->bdg_lock)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"bsd_glue.h"
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
end_elif

begin_warning
warning|#
directive|warning
warning|OSX support is only partial
end_warning

begin_include
include|#
directive|include
file|"osx_glue.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unsupported platform
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unsupported */
end_comment

begin_comment
comment|/*  * common headers  */
end_comment

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_mem2.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|WITH_VALE
end_ifdef

begin_comment
comment|/*  * system parameters (most of them in netmap_kern.h)  * NM_NAME	prefix for switch port names, default "vale"  * NM_BDG_MAXPORTS	number of ports  * NM_BRIDGES	max number of switches in the system.  *	XXX should become a sysctl or tunable  *  * Switch ports are named valeX:Y where X is the switch name and Y  * is the port. If Y matches a physical interface name, the port is  * connected to a physical device.  *  * Unlike physical interfaces, switch ports use their own memory region  * for rings and buffers.  * The virtual interfaces use per-queue lock instead of core lock.  * In the tx loop, we aggregate traffic in batches to make all operations  * faster. The batch size is bridge_batch.  */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXRINGS
value|16
end_define

begin_comment
comment|/* XXX unclear how many. */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_MAXSLOTS
value|4096
end_define

begin_comment
comment|/* XXX same as above */
end_comment

begin_define
define|#
directive|define
name|NM_BRIDGE_RINGSIZE
value|1024
end_define

begin_comment
comment|/* in the device */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_HASH
value|1024
end_define

begin_comment
comment|/* forwarding table entries */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH
value|1024
end_define

begin_comment
comment|/* entries in the forwarding buffer */
end_comment

begin_define
define|#
directive|define
name|NM_MULTISEG
value|64
end_define

begin_comment
comment|/* max size of a chain of bufs */
end_comment

begin_comment
comment|/* actual size of the tables */
end_comment

begin_define
define|#
directive|define
name|NM_BDG_BATCH_MAX
value|(NM_BDG_BATCH + NM_MULTISEG)
end_define

begin_comment
comment|/* NM_FT_NULL terminates a list of slots in the ft */
end_comment

begin_define
define|#
directive|define
name|NM_FT_NULL
value|NM_BDG_BATCH_MAX
end_define

begin_define
define|#
directive|define
name|NM_BRIDGES
value|8
end_define

begin_comment
comment|/* number of bridges */
end_comment

begin_comment
comment|/*  * bridge_batch is set via sysctl to the max batch size to be  * used in the bridge. The actual value may be larger as the  * last packet in the block may overflow the size.  */
end_comment

begin_decl_stmt
name|int
name|bridge_batch
init|=
name|NM_BDG_BATCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bridge batch size */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_dev_netmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|bridge_batch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bridge_batch
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|bdg_netmap_attach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_bwrap_attach
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|netmap_bwrap_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
parameter_list|,
name|int
name|onoff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|kern_netmap_regif
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Each transmit queue accumulates a batch of packets into  * a structure before forwarding. Packets to the same  * destination are put in a list using ft_next as a link field.  * ft_frags and ft_next are valid only on the first fragment.  */
end_comment

begin_struct
struct|struct
name|nm_bdg_fwd
block|{
comment|/* forwarding entry for a bridge */
name|void
modifier|*
name|ft_buf
decl_stmt|;
comment|/* netmap or indirect buffer */
name|uint8_t
name|ft_frags
decl_stmt|;
comment|/* how many fragments (only on 1st frag) */
name|uint8_t
name|_ft_port
decl_stmt|;
comment|/* dst port (unused) */
name|uint16_t
name|ft_flags
decl_stmt|;
comment|/* flags, e.g. indirect */
name|uint16_t
name|ft_len
decl_stmt|;
comment|/* src fragment len */
name|uint16_t
name|ft_next
decl_stmt|;
comment|/* next packet to same destination */
block|}
struct|;
end_struct

begin_comment
comment|/*  * For each output interface, nm_bdg_q is used to construct a list.  * bq_len is the number of output buffers (we can have coalescing  * during the copy).  */
end_comment

begin_struct
struct|struct
name|nm_bdg_q
block|{
name|uint16_t
name|bq_head
decl_stmt|;
name|uint16_t
name|bq_tail
decl_stmt|;
name|uint32_t
name|bq_len
decl_stmt|;
comment|/* number of buffers */
block|}
struct|;
end_struct

begin_comment
comment|/* XXX revise this */
end_comment

begin_struct
struct|struct
name|nm_hash_ent
block|{
name|uint64_t
name|mac
decl_stmt|;
comment|/* the top 2 bytes are the epoch */
name|uint64_t
name|ports
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * nm_bridge is a descriptor for a VALE switch.  * Interfaces for a bridge are all in bdg_ports[].  * The array has fixed size, an empty entry does not terminate  * the search, but lookups only occur on attach/detach so we  * don't mind if they are slow.  *  * The bridge is non blocking on the transmit ports: excess  * packets are dropped if there is no room on the output port.  *  * bdg_lock protects accesses to the bdg_ports array.  * This is a rw lock (or equivalent).  */
end_comment

begin_struct
struct|struct
name|nm_bridge
block|{
comment|/* XXX what is the proper alignment/layout ? */
name|BDG_RWLOCK_T
name|bdg_lock
decl_stmt|;
comment|/* protects bdg_ports */
name|int
name|bdg_namelen
decl_stmt|;
name|uint32_t
name|bdg_active_ports
decl_stmt|;
comment|/* 0 means free */
name|char
name|bdg_basename
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
comment|/* Indexes of active ports (up to active_ports) 	 * and all other remaining ports. 	 */
name|uint8_t
name|bdg_port_index
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|bdg_ports
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
comment|/* 	 * The function to decide the destination port. 	 * It returns either of an index of the destination port, 	 * NM_BDG_BROADCAST to broadcast this packet, or NM_BDG_NOPORT not to 	 * forward this packet.  ring_nr is the source ring index, and the 	 * function may overwrite this value to forward this packet to a 	 * different ring index. 	 * This function must be set by netmap_bdgctl(). 	 */
name|bdg_lookup_fn_t
name|nm_bdg_lookup
decl_stmt|;
comment|/* the forwarding table, MAC+ports. 	 * XXX should be changed to an argument to be passed to 	 * the lookup function, and allocated on attach 	 */
name|struct
name|nm_hash_ent
name|ht
index|[
name|NM_BDG_HASH
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX in principle nm_bridges could be created dynamically  * Right now we have a static array and deletions are protected  * by an exclusive lock.  */
end_comment

begin_decl_stmt
name|struct
name|nm_bridge
name|nm_bridges
index|[
name|NM_BRIDGES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * this is a slightly optimized copy routine which rounds  * to multiple of 64 bytes and is often faster than dealing  * with other odd sizes. We assume there is enough room  * in the source and destination buffers.  *  * XXX only for multiples of 64 bytes, non overlapped.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pkt_copy
parameter_list|(
name|void
modifier|*
name|_src
parameter_list|,
name|void
modifier|*
name|_dst
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|uint64_t
modifier|*
name|src
init|=
name|_src
decl_stmt|;
name|uint64_t
modifier|*
name|dst
init|=
name|_dst
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|l
operator|>=
literal|1024
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|likely
argument_list|(
name|l
operator|>
literal|0
argument_list|)
condition|;
name|l
operator|-=
literal|64
control|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * locate a bridge among the existing ones.  * MUST BE CALLED WITH NMG_LOCK()  *  * a ':' in the name terminates the bridge name. Otherwise, just NM_NAME.  * We assume that this is called with a name of at least NM_NAME chars.  */
end_comment

begin_function
specifier|static
name|struct
name|nm_bridge
modifier|*
name|nm_find_bridge
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|namelen
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|NM_NAME
argument_list|)
expr_stmt|;
comment|/* base length */
name|l
operator|=
name|name
condition|?
name|strlen
argument_list|(
name|name
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* actual length */
if|if
condition|(
name|l
operator|<
name|namelen
condition|)
block|{
name|D
argument_list|(
literal|"invalid bridge name %s"
argument_list|,
name|name
condition|?
name|name
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
name|namelen
operator|+
literal|1
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
block|{
name|namelen
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|namelen
operator|>=
name|IFNAMSIZ
condition|)
name|namelen
operator|=
name|IFNAMSIZ
expr_stmt|;
name|ND
argument_list|(
literal|"--- prefix is '%.*s' ---"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* lookup the name, remember empty slot if there is one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bridge
modifier|*
name|x
init|=
name|nm_bridges
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|bdg_active_ports
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|create
operator|&&
name|b
operator|==
name|NULL
condition|)
name|b
operator|=
name|x
expr_stmt|;
comment|/* record empty slot */
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|bdg_namelen
operator|!=
name|namelen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|x
operator|->
name|bdg_basename
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"found '%.*s' at %d"
argument_list|,
name|namelen
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|b
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NM_BRIDGES
operator|&&
name|b
condition|)
block|{
comment|/* name not found, can create entry */
comment|/* initialize the bridge */
name|strncpy
argument_list|(
name|b
operator|->
name|bdg_basename
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"create new bridge %s with ports %d"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_namelen
operator|=
name|namelen
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BDG_MAXPORTS
condition|;
name|i
operator|++
control|)
name|b
operator|->
name|bdg_port_index
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* set the default function */
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|netmap_bdg_learning
expr_stmt|;
comment|/* reset the MAC address table */
name|bzero
argument_list|(
name|b
operator|->
name|ht
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_hash_ent
argument_list|)
operator|*
name|NM_BDG_HASH
argument_list|)
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Free the forwarding tables for rings attached to switch ports.  */
end_comment

begin_function
specifier|static
name|void
name|nm_free_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|nrings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
condition|)
block|{
name|free
argument_list|(
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|NULL
expr_stmt|;
comment|/* protect from freeing twice */
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate the forwarding tables for the rings attached to the bridge ports.  */
end_comment

begin_function
specifier|static
name|int
name|nm_alloc_bdgfwd
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|int
name|nrings
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|,
name|num_dstq
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* all port:rings + broadcast */
name|num_dstq
operator|=
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
expr_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_fwd
argument_list|)
operator|*
name|NM_BDG_BATCH_MAX
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bdg_q
argument_list|)
operator|*
name|num_dstq
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|NM_BDG_BATCH_MAX
expr_stmt|;
name|nrings
operator|=
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
expr_stmt|;
name|kring
operator|=
name|na
operator|->
name|tx_rings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrings
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|dstq
decl_stmt|;
name|int
name|j
decl_stmt|;
name|ft
operator|=
name|malloc
argument_list|(
name|l
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ft
condition|)
block|{
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|dstq
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH_MAX
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_dstq
condition|;
name|j
operator|++
control|)
block|{
name|dstq
index|[
name|j
index|]
operator|.
name|bq_head
operator|=
name|dstq
index|[
name|j
index|]
operator|.
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
name|dstq
index|[
name|j
index|]
operator|.
name|bq_len
operator|=
literal|0
expr_stmt|;
block|}
name|kring
index|[
name|i
index|]
operator|.
name|nkr_ft
operator|=
name|ft
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_bdg_detach_common
parameter_list|(
name|struct
name|nm_bridge
modifier|*
name|b
parameter_list|,
name|int
name|hw
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|int
name|s_hw
init|=
name|hw
decl_stmt|,
name|s_sw
init|=
name|sw
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lim
init|=
name|b
operator|->
name|bdg_active_ports
decl_stmt|;
name|uint8_t
name|tmp
index|[
name|NM_BDG_MAXPORTS
index|]
decl_stmt|;
comment|/* 	New algorithm: 	make a copy of bdg_port_index; 	lookup NA(ifp)->bdg_port and SWNA(ifp)->bdg_port 	in the array of bdg_port_index, replacing them with 	entries from the bottom of the array; 	decrement bdg_active_ports; 	acquire BDG_WLOCK() and copy back the array. 	 */
name|D
argument_list|(
literal|"detach %d and %d (lim %d)"
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|,
name|lim
argument_list|)
expr_stmt|;
comment|/* make a copy of the list of active ports, update it, 	 * and then copy back within BDG_WLOCK(). 	 */
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|b
operator|->
name|bdg_port_index
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|hw
operator|>=
literal|0
operator|||
name|sw
operator|>=
literal|0
operator|)
operator|&&
name|i
operator|<
name|lim
condition|;
control|)
block|{
if|if
condition|(
name|hw
operator|>=
literal|0
operator|&&
name|tmp
index|[
name|i
index|]
operator|==
name|hw
condition|)
block|{
name|ND
argument_list|(
literal|"detach hw %d at %d"
argument_list|,
name|hw
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lim
operator|--
expr_stmt|;
comment|/* point to last active port */
name|tmp
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|lim
index|]
expr_stmt|;
comment|/* swap with i */
name|tmp
index|[
name|lim
index|]
operator|=
name|hw
expr_stmt|;
comment|/* now this is inactive */
name|hw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sw
operator|>=
literal|0
operator|&&
name|tmp
index|[
name|i
index|]
operator|==
name|sw
condition|)
block|{
name|ND
argument_list|(
literal|"detach sw %d at %d"
argument_list|,
name|sw
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lim
operator|--
expr_stmt|;
name|tmp
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|lim
index|]
expr_stmt|;
name|tmp
index|[
name|lim
index|]
operator|=
name|sw
expr_stmt|;
name|sw
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw
operator|>=
literal|0
operator|||
name|sw
operator|>=
literal|0
condition|)
block|{
name|D
argument_list|(
literal|"XXX delete failed hw %d sw %d, should panic..."
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_ports
index|[
name|s_hw
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s_sw
operator|>=
literal|0
condition|)
block|{
name|b
operator|->
name|bdg_ports
index|[
name|s_sw
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|b
operator|->
name|bdg_port_index
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|=
name|lim
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"now %d active ports"
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|==
literal|0
condition|)
block|{
name|ND
argument_list|(
literal|"marking bridge %s as free"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|)
expr_stmt|;
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_adapter_vp_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|vpna
operator|->
name|na_bdg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|ND
argument_list|(
literal|"%s has %d references"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|na
operator|->
name|na_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|netmap_bdg_detach_common
argument_list|(
name|b
argument_list|,
name|vpna
operator|->
name|bdg_port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to get a reference to a netmap adapter attached to a VALE switch.  * If the adapter is found (or is created), this function returns 0, a  * non NULL pointer is returned into *na, and the caller holds a  * reference to the adapter.  * If an adapter is not found, then no reference is grabbed and the  * function returns an error code, or 0 if there is just a VALE prefix  * mismatch. Therefore the caller holds a reference when  * (*na != NULL&& return == 0).  */
end_comment

begin_function
name|int
name|netmap_get_bdg_na
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|netmap_adapter
modifier|*
modifier|*
name|na
parameter_list|,
name|int
name|create
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|ret
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cand
init|=
operator|-
literal|1
decl_stmt|,
name|cand2
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|needed
decl_stmt|;
operator|*
name|na
operator|=
name|NULL
expr_stmt|;
comment|/* default return value */
comment|/* first try to see if this is a bridge port. */
name|NMG_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_NAME
argument_list|,
sizeof|sizeof
argument_list|(
name|NM_NAME
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* no error, but no VALE prefix */
block|}
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"no bridges available for '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|create
condition|?
name|ENOMEM
else|:
name|ENXIO
operator|)
return|;
block|}
comment|/* Now we are sure that name starts with the bridge's name, 	 * lookup the port in the bridge. We need to scan the entire 	 * list. It is not important to hold a WLOCK on the bridge 	 * during the search because NMG_LOCK already guarantees 	 * that there are no other possible writers. 	 */
comment|/* lookup in the local list of ports */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|vpna
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
expr_stmt|;
comment|// KASSERT(na != NULL);
name|ifp
operator|=
name|vpna
operator|->
name|up
operator|.
name|ifp
expr_stmt|;
comment|/* XXX make sure the name only contains one : */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|netmap_adapter_get
argument_list|(
operator|&
name|vpna
operator|->
name|up
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"found existing if %s refs %d"
argument_list|,
name|name
argument_list|,
name|vpna
operator|->
name|na_bdg_refcount
argument_list|)
expr_stmt|;
operator|*
name|na
operator|=
operator|(
expr|struct
name|netmap_adapter
operator|*
operator|)
name|vpna
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* not found, should we create it? */
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|ENXIO
return|;
comment|/* yes we should, see if we have space to attach entries */
name|needed
operator|=
literal|2
expr_stmt|;
comment|/* in some cases we only need 1 */
if|if
condition|(
name|b
operator|->
name|bdg_active_ports
operator|+
name|needed
operator|>=
name|NM_BDG_MAXPORTS
condition|)
block|{
name|D
argument_list|(
literal|"bridge full %d, cannot create new port"
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
comment|/* record the next two ports available, but do not allocate yet */
name|cand
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|b
operator|->
name|bdg_active_ports
index|]
expr_stmt|;
name|cand2
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|b
operator|->
name|bdg_active_ports
operator|+
literal|1
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"+++ bridge %s port %s used %d avail %d %d"
argument_list|,
name|b
operator|->
name|bdg_basename
argument_list|,
name|name
argument_list|,
name|b
operator|->
name|bdg_active_ports
argument_list|,
name|cand
argument_list|,
name|cand2
argument_list|)
expr_stmt|;
comment|/* 	 * try see if there is a matching NIC with this name 	 * (after the bridge's name) 	 */
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|name
operator|+
name|b
operator|->
name|bdg_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
block|{
comment|/* this is a virtual port */
if|if
condition|(
name|nmr
operator|->
name|nr_cmd
condition|)
block|{
comment|/* nr_cmd must be 0 for a virtual port */
return|return
name|EINVAL
return|;
block|}
comment|/* create a struct ifnet for the new port. 		 * need M_NOWAIT as we are under nma_lock 		 */
name|ifp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
return|return
name|ENOMEM
return|;
name|strcpy
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* bdg_netmap_attach creates a struct netmap_adapter */
name|error
operator|=
name|bdg_netmap_attach
argument_list|(
name|nmr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|D
argument_list|(
literal|"error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ret
operator|=
name|NA
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|cand2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* only need one port */
block|}
else|else
block|{
comment|/* this is a NIC */
name|struct
name|ifnet
modifier|*
name|fake_ifp
decl_stmt|;
name|error
operator|=
name|netmap_get_hw_na
argument_list|(
name|ifp
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* make sure the NIC is not already in use */
if|if
condition|(
name|NETMAP_OWNED_BY_ANY
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"NIC %s busy, cannot attach to bridge"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* create a fake interface */
name|fake_ifp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fake_ifp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|strcpy
argument_list|(
name|fake_ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|netmap_bwrap_attach
argument_list|(
name|fake_ifp
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|fake_ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|NA
argument_list|(
name|fake_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_arg1
operator|!=
name|NETMAP_BDG_HOST
condition|)
name|cand2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* only need one port */
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|vpna
operator|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|ret
expr_stmt|;
name|BDG_WLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|vpna
operator|->
name|bdg_port
operator|=
name|cand
expr_stmt|;
name|ND
argument_list|(
literal|"NIC  %p to bridge port %d"
argument_list|,
name|vpna
argument_list|,
name|cand
argument_list|)
expr_stmt|;
comment|/* bind the port to the bridge (virtual ports are not active) */
name|b
operator|->
name|bdg_ports
index|[
name|cand
index|]
operator|=
name|vpna
expr_stmt|;
name|vpna
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|++
expr_stmt|;
if|if
condition|(
name|cand2
operator|>=
literal|0
condition|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|hostna
init|=
name|vpna
operator|+
literal|1
decl_stmt|;
comment|/* also bind the host stack to the bridge */
name|b
operator|->
name|bdg_ports
index|[
name|cand2
index|]
operator|=
name|hostna
expr_stmt|;
name|hostna
operator|->
name|bdg_port
operator|=
name|cand2
expr_stmt|;
name|hostna
operator|->
name|na_bdg
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|bdg_active_ports
operator|++
expr_stmt|;
name|ND
argument_list|(
literal|"host %p to bridge port %d"
argument_list|,
name|hostna
argument_list|,
name|cand2
argument_list|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|"if %s refs %d"
argument_list|,
name|name
argument_list|,
name|vpna
operator|->
name|up
operator|.
name|na_refcount
argument_list|)
expr_stmt|;
name|BDG_WUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
operator|*
name|na
operator|=
name|ret
expr_stmt|;
name|netmap_adapter_get
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Process NETMAP_BDG_ATTACH and NETMAP_BDG_DETACH */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_attach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_if
modifier|*
name|nifp
decl_stmt|;
name|struct
name|netmap_priv_d
modifier|*
name|npriv
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
decl_stmt|;
name|int
name|error
decl_stmt|;
name|npriv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|npriv
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|1
comment|/* create if not exists */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
comment|/* no device, or another bridge or user owns the device */
goto|goto
name|unlock_exit
goto|;
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
comment|/* VALE prefix missing */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
if|if
condition|(
name|na
operator|->
name|active_fds
operator|>
literal|0
condition|)
block|{
comment|/* already registered */
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
name|nifp
operator|=
name|netmap_do_regif
argument_list|(
name|npriv
argument_list|,
name|na
argument_list|,
name|nmr
operator|->
name|nr_ringid
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nifp
condition|)
block|{
goto|goto
name|unref_exit
goto|;
block|}
name|bna
operator|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
expr_stmt|;
name|bna
operator|->
name|na_kpriv
operator|=
name|npriv
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|ND
argument_list|(
literal|"registered %s to netmap-mode"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|unref_exit
label|:
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|unlock_exit
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|npriv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|npriv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nm_bdg_detach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
decl_stmt|;
name|int
name|last_instance
decl_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* no device, or another bridge or user owns the device */
goto|goto
name|unlock_exit
goto|;
block|}
if|if
condition|(
name|na
operator|==
name|NULL
condition|)
block|{
comment|/* VALE prefix missing */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unlock_exit
goto|;
block|}
name|bna
operator|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|active_fds
operator|==
literal|0
condition|)
block|{
comment|/* not registered */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unref_exit
goto|;
block|}
name|last_instance
operator|=
name|netmap_dtor_locked
argument_list|(
name|bna
operator|->
name|na_kpriv
argument_list|)
expr_stmt|;
comment|/* unregister */
if|if
condition|(
operator|!
name|last_instance
condition|)
block|{
name|D
argument_list|(
literal|"--- error, trying to detach an entry with active mmaps"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|netmap_priv_d
modifier|*
name|npriv
init|=
name|bna
operator|->
name|na_kpriv
decl_stmt|;
name|bna
operator|->
name|na_kpriv
operator|=
name|NULL
expr_stmt|;
name|D
argument_list|(
literal|"deleting priv"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|npriv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npriv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|npriv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|unref_exit
label|:
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|unlock_exit
label|:
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* exported to kernel callers, e.g. OVS ?  * Entry point.  * Called without NMG_LOCK.  */
end_comment

begin_function
name|int
name|netmap_bdg_ctl
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|bdg_lookup_fn_t
name|func
parameter_list|)
block|{
name|struct
name|nm_bridge
modifier|*
name|b
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|iter
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|nmr
operator|->
name|nr_name
decl_stmt|;
name|int
name|cmd
init|=
name|nmr
operator|->
name|nr_cmd
decl_stmt|,
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NETMAP_BDG_ATTACH
case|:
name|error
operator|=
name|nm_bdg_attach
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_DETACH
case|:
name|error
operator|=
name|nm_bdg_detach
argument_list|(
name|nmr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_LIST
case|:
comment|/* this is used to enumerate bridges and ports */
if|if
condition|(
name|namelen
condition|)
block|{
comment|/* look up indexes of bridge and port */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NM_NAME
argument_list|,
name|strlen
argument_list|(
name|NM_NAME
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
condition|;
name|j
operator|++
control|)
block|{
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|vpna
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vpna
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"---AAAAAAAAARGH-------"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|iter
operator|=
name|vpna
operator|->
name|up
operator|.
name|ifp
expr_stmt|;
comment|/* the former and the latter identify a 				 * virtual port and a NIC, respectively 				 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|iter
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* bridge index */
name|nmr
operator|->
name|nr_arg1
operator|=
name|b
operator|-
name|nm_bridges
expr_stmt|;
name|nmr
operator|->
name|nr_arg2
operator|=
name|i
expr_stmt|;
comment|/* port index */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* return the first non-empty entry starting from 			 * bridge nr_arg1 and port nr_arg2. 			 * 			 * Users can detect the end of the same bridge by 			 * seeing the new and old value of nr_arg1, and can 			 * detect the end of all the bridge by error != 0 			 */
name|i
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
name|j
operator|=
name|nmr
operator|->
name|nr_arg2
expr_stmt|;
name|NMG_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|error
operator|=
name|ENOENT
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|nm_bridges
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|b
operator|->
name|bdg_active_ports
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
comment|/* following bridges scan from 0 */
continue|continue;
block|}
name|nmr
operator|->
name|nr_arg1
operator|=
name|i
expr_stmt|;
name|nmr
operator|->
name|nr_arg2
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
name|vpna
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|j
index|]
expr_stmt|;
name|iter
operator|=
name|vpna
operator|->
name|up
operator|.
name|ifp
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|iter
operator|->
name|if_xname
argument_list|,
operator|(
name|size_t
operator|)
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|NETMAP_BDG_LOOKUP_REG
case|:
comment|/* register a lookup function to the given bridge. 		 * nmr->nr_name may be just bridge's name (including ':' 		 * if it is not just NM_NAME). 		 */
if|if
condition|(
operator|!
name|func
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|b
operator|=
name|nm_find_bridge
argument_list|(
name|name
argument_list|,
literal|0
comment|/* don't create */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|nm_bdg_lookup
operator|=
name|func
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|NETMAP_BDG_OFFSET
case|:
name|NMG_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|netmap_get_bdg_na
argument_list|(
name|nmr
argument_list|,
operator|&
name|na
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|&&
operator|!
name|error
condition|)
block|{
name|vpna
operator|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
expr_stmt|;
if|if
condition|(
name|nmr
operator|->
name|nr_arg1
operator|>
name|NETMAP_BDG_MAX_OFFSET
condition|)
name|nmr
operator|->
name|nr_arg1
operator|=
name|NETMAP_BDG_MAX_OFFSET
expr_stmt|;
name|vpna
operator|->
name|offset
operator|=
name|nmr
operator|->
name|nr_arg1
expr_stmt|;
name|D
argument_list|(
literal|"Using offset %d for %p"
argument_list|,
name|vpna
operator|->
name|offset
argument_list|,
name|vpna
argument_list|)
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|NMG_UNLOCK
argument_list|()
expr_stmt|;
break|break;
default|default:
name|D
argument_list|(
literal|"invalid cmd (nmr->nr_cmd) (0x%x)"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_vp_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|u_int
name|ntx
decl_stmt|,
name|nrx
decl_stmt|,
name|tailroom
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|leases
decl_stmt|;
comment|/* XXX vps do not need host rings, 	 * but we crash if we don't have one 	 */
name|ntx
operator|=
name|na
operator|->
name|num_tx_rings
operator|+
literal|1
expr_stmt|;
name|nrx
operator|=
name|na
operator|->
name|num_rx_rings
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Leases are attached to RX rings on vale ports 	 */
name|tailroom
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|na
operator|->
name|num_rx_desc
operator|*
name|nrx
expr_stmt|;
name|error
operator|=
name|netmap_krings_create
argument_list|(
name|na
argument_list|,
name|ntx
argument_list|,
name|nrx
argument_list|,
name|tailroom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|leases
operator|=
name|na
operator|->
name|tailroom
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrx
condition|;
name|i
operator|++
control|)
block|{
comment|/* Receive rings */
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_leases
operator|=
name|leases
expr_stmt|;
name|leases
operator|+=
name|na
operator|->
name|num_rx_desc
expr_stmt|;
block|}
name|error
operator|=
name|nm_alloc_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_vp_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|nm_free_bdgfwd
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|netmap_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|u_int
name|n
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Grab packets from a kring, move them into the ft structure  * associated to the tx (input) port. Max one instance per port,  * filtered on input (ioctl, poll or XXX).  * Returns the next position in the ring.  */
end_comment

begin_function
specifier|static
name|int
name|nm_bdg_preflush
parameter_list|(
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|u_int
name|end
parameter_list|)
block|{
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
decl_stmt|;
name|u_int
name|j
init|=
name|kring
operator|->
name|nr_hwcur
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|ft_i
init|=
literal|0
decl_stmt|;
comment|/* start from 0 */
name|u_int
name|frags
init|=
literal|1
decl_stmt|;
comment|/* how many frags ? */
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|na
operator|->
name|na_bdg
decl_stmt|;
comment|/* To protect against modifications to the bridge we acquire a 	 * shared lock, waiting if we can sleep (if the source port is 	 * attached to a user process) or with a trylock otherwise (NICs). 	 */
name|ND
argument_list|(
literal|"wait rlock for %d packets"
argument_list|,
operator|(
operator|(
name|j
operator|>
name|end
condition|?
name|lim
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|end
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|->
name|up
operator|.
name|na_flags
operator|&
name|NAF_BDG_MAYSLEEP
condition|)
name|BDG_RLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BDG_RTRYLOCK
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"rlock acquired for %d packets"
argument_list|,
operator|(
operator|(
name|j
operator|>
name|end
condition|?
name|lim
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|end
operator|)
operator|-
name|j
argument_list|)
expr_stmt|;
name|ft
operator|=
name|kring
operator|->
name|nkr_ft
expr_stmt|;
for|for
control|(
init|;
name|likely
argument_list|(
name|j
operator|!=
name|end
argument_list|)
condition|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_len
operator|=
name|slot
operator|->
name|len
expr_stmt|;
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_flags
operator|=
name|slot
operator|->
name|flags
expr_stmt|;
name|ND
argument_list|(
literal|"flags is 0x%x"
argument_list|,
name|slot
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* this slot goes into a list so initialize the link field */
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_next
operator|=
name|NM_FT_NULL
expr_stmt|;
name|buf
operator|=
name|ft
index|[
name|ft_i
index|]
operator|.
name|ft_buf
operator|=
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_INDIRECT
operator|)
condition|?
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|slot
operator|->
name|ptr
else|:
name|BDG_NMB
argument_list|(
operator|&
name|na
operator|->
name|up
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|__builtin_prefetch
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|++
name|ft_i
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|NS_MOREFRAG
condition|)
block|{
name|frags
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|netmap_verbose
operator|&&
name|frags
operator|>
literal|1
argument_list|)
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"%d frags at %d"
argument_list|,
name|frags
argument_list|,
name|ft_i
operator|-
name|frags
argument_list|)
expr_stmt|;
name|ft
index|[
name|ft_i
operator|-
name|frags
index|]
operator|.
name|ft_frags
operator|=
name|frags
expr_stmt|;
name|frags
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|int
operator|)
name|ft_i
operator|>=
name|bridge_batch
argument_list|)
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frags
operator|>
literal|1
condition|)
block|{
name|D
argument_list|(
literal|"truncate incomplete fragment at %d (%d frags)"
argument_list|,
name|ft_i
argument_list|,
name|frags
argument_list|)
expr_stmt|;
comment|// ft_i> 0, ft[ft_i-1].flags has NS_MOREFRAG
name|ft
index|[
name|ft_i
operator|-
literal|1
index|]
operator|.
name|ft_frags
operator|&=
operator|~
name|NS_MOREFRAG
expr_stmt|;
name|ft
index|[
name|ft_i
operator|-
name|frags
index|]
operator|.
name|ft_frags
operator|=
name|frags
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ft_i
condition|)
name|ft_i
operator|=
name|nm_bdg_flush
argument_list|(
name|ft
argument_list|,
name|ft_i
argument_list|,
name|na
argument_list|,
name|ring_nr
argument_list|)
expr_stmt|;
name|BDG_RUNLOCK
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|/* ----- FreeBSD if_bridge hash function ------- */
end_comment

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  *  * http://www.burtleburtle.net/bob/hash/spooky.html  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {                                                                    \         a -= b; a -= c; a ^= (c>> 13);                                 \         b -= c; b -= a; b ^= (a<< 8);                                  \         c -= a; c -= b; c ^= (b>> 13);                                 \         a -= b; a -= c; a ^= (c>> 12);                                 \         b -= c; b -= a; b ^= (a<< 16);                                 \         c -= a; c -= b; c ^= (b>> 5);                                  \         a -= b; a -= c; a ^= (c>> 3);                                  \         b -= c; b -= a; b ^= (a<< 10);                                 \         c -= a; c -= b; c ^= (b>> 15);                                 \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|nm_bridge_rthash
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
comment|// hask key
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(NM_BDG_HASH-1)
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_function
specifier|static
name|int
name|bdg_netmap_reg
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
comment|/* the interface is already attached to the bridge, 	 * so we only need to toggle IFCAP_NETMAP. 	 */
name|BDG_WLOCK
argument_list|(
name|vpna
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_NETMAP
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_NETMAP
expr_stmt|;
block|}
name|BDG_WUNLOCK
argument_list|(
name|vpna
operator|->
name|na_bdg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup function for a learning bridge.  * Update the hash table with the source address,  * and then returns the destination port index, and the  * ring in *dst_ring (at the moment, always use ring 0)  */
end_comment

begin_function
name|u_int
name|netmap_bdg_learning
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|u_int
name|buf_len
parameter_list|,
name|uint8_t
modifier|*
name|dst_ring
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|nm_hash_ent
modifier|*
name|ht
init|=
name|na
operator|->
name|na_bdg
operator|->
name|ht
decl_stmt|;
name|uint32_t
name|sh
decl_stmt|,
name|dh
decl_stmt|;
name|u_int
name|dst
decl_stmt|,
name|mysrc
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
name|uint64_t
name|smac
decl_stmt|,
name|dmac
decl_stmt|;
if|if
condition|(
name|buf_len
operator|<
literal|14
condition|)
block|{
name|D
argument_list|(
literal|"invalid buf length %d"
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
return|return
name|NM_BDG_NOPORT
return|;
block|}
name|dmac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|)
argument_list|)
operator|&
literal|0xffffffffffff
expr_stmt|;
name|smac
operator|=
name|le64toh
argument_list|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|buf
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|smac
operator|>>=
literal|16
expr_stmt|;
comment|/* 	 * The hash is somewhat expensive, there might be some 	 * worthwhile optimizations here. 	 */
if|if
condition|(
operator|(
name|buf
index|[
literal|6
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* valid src */
name|uint8_t
modifier|*
name|s
init|=
name|buf
operator|+
literal|6
decl_stmt|;
name|sh
operator|=
name|nm_bridge_rthash
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|// XXX hash of source
comment|/* update source port forwarding entry */
name|ht
index|[
name|sh
index|]
operator|.
name|mac
operator|=
name|smac
expr_stmt|;
comment|/* XXX expire ? */
name|ht
index|[
name|sh
index|]
operator|.
name|ports
operator|=
name|mysrc
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"src %02x:%02x:%02x:%02x:%02x:%02x on port %d"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|,
name|s
index|[
literal|3
index|]
argument_list|,
name|s
index|[
literal|4
index|]
argument_list|,
name|s
index|[
literal|5
index|]
argument_list|,
name|mysrc
argument_list|)
expr_stmt|;
block|}
name|dst
operator|=
name|NM_BDG_BROADCAST
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* unicast */
name|dh
operator|=
name|nm_bridge_rthash
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// XXX hash of dst
if|if
condition|(
name|ht
index|[
name|dh
index|]
operator|.
name|mac
operator|==
name|dmac
condition|)
block|{
comment|/* found dst */
name|dst
operator|=
name|ht
index|[
name|dh
index|]
operator|.
name|ports
expr_stmt|;
block|}
comment|/* XXX otherwise return NM_BDG_UNKNOWN ? */
block|}
operator|*
name|dst_ring
operator|=
literal|0
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/*  * Available space in the ring. Only used in VALE code  * and only with is_rx = 1  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|nm_kr_space
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|k
parameter_list|,
name|int
name|is_rx
parameter_list|)
block|{
name|int
name|space
decl_stmt|;
if|if
condition|(
name|is_rx
condition|)
block|{
name|int
name|busy
init|=
name|k
operator|->
name|nkr_hwlease
operator|-
name|k
operator|->
name|nr_hwcur
decl_stmt|;
if|if
condition|(
name|busy
operator|<
literal|0
condition|)
name|busy
operator|+=
name|k
operator|->
name|nkr_num_slots
expr_stmt|;
name|space
operator|=
name|k
operator|->
name|nkr_num_slots
operator|-
literal|1
operator|-
name|busy
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX never used in this branch */
name|space
operator|=
name|k
operator|->
name|nr_hwtail
operator|-
name|k
operator|->
name|nkr_hwlease
expr_stmt|;
if|if
condition|(
name|space
operator|<
literal|0
condition|)
name|space
operator|+=
name|k
operator|->
name|nkr_num_slots
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|// sanity check
block|if (k->nkr_hwlease>= k->nkr_num_slots || 		k->nr_hwcur>= k->nkr_num_slots || 		k->nr_tail>= k->nkr_num_slots || 		busy< 0 || 		busy>= k->nkr_num_slots) { 		D("invalid kring, cur %d tail %d lease %d lease_idx %d lim %d",			k->nr_hwcur, k->nr_hwtail, k->nkr_hwlease, 			k->nkr_lease_idx, k->nkr_num_slots); 	}
endif|#
directive|endif
return|return
name|space
return|;
block|}
end_function

begin_comment
comment|/* make a lease on the kring for N positions. return the  * lease index  * XXX only used in VALE code and with is_rx = 1  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|nm_kr_lease
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|k
parameter_list|,
name|u_int
name|n
parameter_list|,
name|int
name|is_rx
parameter_list|)
block|{
name|uint32_t
name|lim
init|=
name|k
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|lease_idx
init|=
name|k
operator|->
name|nkr_lease_idx
decl_stmt|;
name|k
operator|->
name|nkr_leases
index|[
name|lease_idx
index|]
operator|=
name|NR_NOSLOT
expr_stmt|;
name|k
operator|->
name|nkr_lease_idx
operator|=
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|nm_kr_space
argument_list|(
name|k
argument_list|,
name|is_rx
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"invalid request for %d slots"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX verify that there are n slots */
name|k
operator|->
name|nkr_hwlease
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|nkr_hwlease
operator|>
name|lim
condition|)
name|k
operator|->
name|nkr_hwlease
operator|-=
name|lim
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|nkr_hwlease
operator|>=
name|k
operator|->
name|nkr_num_slots
operator|||
name|k
operator|->
name|nr_hwcur
operator|>=
name|k
operator|->
name|nkr_num_slots
operator|||
name|k
operator|->
name|nr_hwtail
operator|>=
name|k
operator|->
name|nkr_num_slots
operator|||
name|k
operator|->
name|nkr_lease_idx
operator|>=
name|k
operator|->
name|nkr_num_slots
condition|)
block|{
name|D
argument_list|(
literal|"invalid kring %s, cur %d tail %d lease %d lease_idx %d lim %d"
argument_list|,
name|k
operator|->
name|na
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|k
operator|->
name|nr_hwcur
argument_list|,
name|k
operator|->
name|nr_hwtail
argument_list|,
name|k
operator|->
name|nkr_hwlease
argument_list|,
name|k
operator|->
name|nkr_lease_idx
argument_list|,
name|k
operator|->
name|nkr_num_slots
argument_list|)
expr_stmt|;
block|}
return|return
name|lease_idx
return|;
block|}
end_function

begin_comment
comment|/*  * This flush routine supports only unicast and broadcast but a large  * number of ports, and lets us replace the learn and dispatch functions.  */
end_comment

begin_function
name|int
name|nm_bdg_flush
parameter_list|(
name|struct
name|nm_bdg_fwd
modifier|*
name|ft
parameter_list|,
name|u_int
name|n
parameter_list|,
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|)
block|{
name|struct
name|nm_bdg_q
modifier|*
name|dst_ents
decl_stmt|,
modifier|*
name|brddst
decl_stmt|;
name|uint16_t
name|num_dsts
init|=
literal|0
decl_stmt|,
modifier|*
name|dsts
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|na
operator|->
name|na_bdg
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|me
init|=
name|na
operator|->
name|bdg_port
decl_stmt|;
comment|/* 	 * The work area (pointed by ft) is followed by an array of 	 * pointers to queues , dst_ents; there are NM_BDG_MAXRINGS 	 * queues per port plus one for the broadcast traffic. 	 * Then we have an array of destination indexes. 	 */
name|dst_ents
operator|=
operator|(
expr|struct
name|nm_bdg_q
operator|*
operator|)
operator|(
name|ft
operator|+
name|NM_BDG_BATCH_MAX
operator|)
expr_stmt|;
name|dsts
operator|=
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|dst_ents
operator|+
name|NM_BDG_MAXPORTS
operator|*
name|NM_BDG_MAXRINGS
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* first pass: find a destination for each packet in the batch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|likely
argument_list|(
name|i
operator|<
name|n
argument_list|)
condition|;
name|i
operator|+=
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
control|)
block|{
name|uint8_t
name|dst_ring
init|=
name|ring_nr
decl_stmt|;
comment|/* default, same ring as origin */
name|uint16_t
name|dst_port
decl_stmt|,
name|d_i
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|ft
index|[
name|i
index|]
operator|.
name|ft_buf
decl_stmt|;
name|u_int
name|len
init|=
name|ft
index|[
name|i
index|]
operator|.
name|ft_len
decl_stmt|;
name|ND
argument_list|(
literal|"slot %d frags %d"
argument_list|,
name|i
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
argument_list|)
expr_stmt|;
comment|/* Drop the packet if the offset is not into the first 		   fragment nor at the very beginning of the second. */
if|if
condition|(
name|unlikely
argument_list|(
name|na
operator|->
name|offset
operator|>
name|len
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|len
operator|==
name|na
operator|->
name|offset
condition|)
block|{
name|buf
operator|=
name|ft
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ft_buf
expr_stmt|;
name|len
operator|=
name|ft
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|ft_len
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|+=
name|na
operator|->
name|offset
expr_stmt|;
name|len
operator|-=
name|na
operator|->
name|offset
expr_stmt|;
block|}
name|dst_port
operator|=
name|b
operator|->
name|nm_bdg_lookup
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|dst_ring
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|>
literal|255
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"slot %d port %d -> %d"
argument_list|,
name|i
argument_list|,
name|me
argument_list|,
name|dst_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_NOPORT
condition|)
continue|continue;
comment|/* this packet is identified to be dropped */
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|>
name|NM_BDG_MAXPORTS
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|dst_port
operator|==
name|NM_BDG_BROADCAST
condition|)
name|dst_ring
operator|=
literal|0
expr_stmt|;
comment|/* broadcasts always go to ring 0 */
elseif|else
if|if
condition|(
name|unlikely
argument_list|(
name|dst_port
operator|==
name|me
operator|||
operator|!
name|b
operator|->
name|bdg_ports
index|[
name|dst_port
index|]
argument_list|)
condition|)
continue|continue;
comment|/* get a position in the scratch pad */
name|d_i
operator|=
name|dst_port
operator|*
name|NM_BDG_MAXRINGS
operator|+
name|dst_ring
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
comment|/* append the first fragment to the list */
if|if
condition|(
name|d
operator|->
name|bq_head
operator|==
name|NM_FT_NULL
condition|)
block|{
comment|/* new destination */
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
comment|/* remember this position to be scanned later */
if|if
condition|(
name|dst_port
operator|!=
name|NM_BDG_BROADCAST
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
else|else
block|{
name|ft
index|[
name|d
operator|->
name|bq_tail
index|]
operator|.
name|ft_next
operator|=
name|i
expr_stmt|;
name|d
operator|->
name|bq_tail
operator|=
name|i
expr_stmt|;
block|}
name|d
operator|->
name|bq_len
operator|+=
name|ft
index|[
name|i
index|]
operator|.
name|ft_frags
expr_stmt|;
block|}
comment|/* 	 * Broadcast traffic goes to ring 0 on all destinations. 	 * So we need to add these rings to the list of ports to scan. 	 * XXX at the moment we scan all NM_BDG_MAXPORTS ports, which is 	 * expensive. We should keep a compact list of active destinations 	 * so we could shorten this loop. 	 */
name|brddst
operator|=
name|dst_ents
operator|+
name|NM_BDG_BROADCAST
operator|*
name|NM_BDG_MAXRINGS
expr_stmt|;
if|if
condition|(
name|brddst
operator|->
name|bq_head
operator|!=
name|NM_FT_NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|likely
argument_list|(
name|j
operator|<
name|b
operator|->
name|bdg_active_ports
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|uint16_t
name|d_i
decl_stmt|;
name|i
operator|=
name|b
operator|->
name|bdg_port_index
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|i
operator|==
name|me
argument_list|)
condition|)
continue|continue;
name|d_i
operator|=
name|i
operator|*
name|NM_BDG_MAXRINGS
expr_stmt|;
if|if
condition|(
name|dst_ents
index|[
name|d_i
index|]
operator|.
name|bq_head
operator|==
name|NM_FT_NULL
condition|)
name|dsts
index|[
name|num_dsts
operator|++
index|]
operator|=
name|d_i
expr_stmt|;
block|}
block|}
name|ND
argument_list|(
literal|5
argument_list|,
literal|"pass 1 done %d pkts %d dsts"
argument_list|,
name|n
argument_list|,
name|num_dsts
argument_list|)
expr_stmt|;
comment|/* second pass: scan destinations (XXX will be modular somehow) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dsts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ifnet
modifier|*
name|dst_ifp
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|dst_na
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|u_int
name|dst_nr
decl_stmt|,
name|lim
decl_stmt|,
name|j
decl_stmt|,
name|sent
init|=
literal|0
decl_stmt|,
name|d_i
decl_stmt|,
name|next
decl_stmt|,
name|brd_next
decl_stmt|;
name|u_int
name|needed
decl_stmt|,
name|howmany
decl_stmt|;
name|int
name|retry
init|=
name|netmap_txsync_retry
decl_stmt|;
name|struct
name|nm_bdg_q
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|my_start
init|=
literal|0
decl_stmt|,
name|lease_idx
init|=
literal|0
decl_stmt|;
name|int
name|nrings
decl_stmt|;
name|int
name|offset_mismatch
decl_stmt|;
name|d_i
operator|=
name|dsts
index|[
name|i
index|]
expr_stmt|;
name|ND
argument_list|(
literal|"second pass %d port %d"
argument_list|,
name|i
argument_list|,
name|d_i
argument_list|)
expr_stmt|;
name|d
operator|=
name|dst_ents
operator|+
name|d_i
expr_stmt|;
comment|// XXX fix the division
name|dst_na
operator|=
name|b
operator|->
name|bdg_ports
index|[
name|d_i
operator|/
name|NM_BDG_MAXRINGS
index|]
expr_stmt|;
comment|/* protect from the lookup function returning an inactive 		 * destination port 		 */
if|if
condition|(
name|unlikely
argument_list|(
name|dst_na
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|dst_na
operator|->
name|up
operator|.
name|na_flags
operator|&
name|NAF_SW_ONLY
condition|)
goto|goto
name|cleanup
goto|;
name|dst_ifp
operator|=
name|dst_na
operator|->
name|up
operator|.
name|ifp
expr_stmt|;
comment|/* 		 * The interface may be in !netmap mode in two cases: 		 * - when na is attached but not activated yet; 		 * - when na is being deactivated but is still attached. 		 */
if|if
condition|(
name|unlikely
argument_list|(
operator|!
operator|(
name|dst_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|"not in netmap mode!"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|offset_mismatch
operator|=
operator|(
name|dst_na
operator|->
name|offset
operator|!=
name|na
operator|->
name|offset
operator|)
expr_stmt|;
comment|/* there is at least one either unicast or broadcast packet */
name|brd_next
operator|=
name|brddst
operator|->
name|bq_head
expr_stmt|;
name|next
operator|=
name|d
operator|->
name|bq_head
expr_stmt|;
comment|/* we need to reserve this many slots. If fewer are 		 * available, some packets will be dropped. 		 * Packets may have multiple fragments, so we may not use 		 * there is a chance that we may not use all of the slots 		 * we have claimed, so we will need to handle the leftover 		 * ones when we regain the lock. 		 */
name|needed
operator|=
name|d
operator|->
name|bq_len
operator|+
name|brddst
operator|->
name|bq_len
expr_stmt|;
name|ND
argument_list|(
literal|5
argument_list|,
literal|"pass 2 dst %d is %x %s"
argument_list|,
name|i
argument_list|,
name|d_i
argument_list|,
name|is_vp
condition|?
literal|"virtual"
else|:
literal|"nic/host"
argument_list|)
expr_stmt|;
name|dst_nr
operator|=
name|d_i
operator|&
operator|(
name|NM_BDG_MAXRINGS
operator|-
literal|1
operator|)
expr_stmt|;
name|nrings
operator|=
name|dst_na
operator|->
name|up
operator|.
name|num_rx_rings
expr_stmt|;
if|if
condition|(
name|dst_nr
operator|>=
name|nrings
condition|)
name|dst_nr
operator|=
name|dst_nr
operator|%
name|nrings
expr_stmt|;
name|kring
operator|=
operator|&
name|dst_na
operator|->
name|up
operator|.
name|rx_rings
index|[
name|dst_nr
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
name|retry
label|:
comment|/* reserve the buffers in the queue and an entry 		 * to report completion, and drop lock. 		 * XXX this might become a helper function. 		 */
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kring
operator|->
name|nkr_stopped
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|dst_na
operator|->
name|retry
condition|)
block|{
name|dst_na
operator|->
name|up
operator|.
name|nm_notify
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|,
name|dst_nr
argument_list|,
name|NR_RX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|my_start
operator|=
name|j
operator|=
name|kring
operator|->
name|nkr_hwlease
expr_stmt|;
name|howmany
operator|=
name|nm_kr_space
argument_list|(
name|kring
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|needed
operator|<
name|howmany
condition|)
name|howmany
operator|=
name|needed
expr_stmt|;
name|lease_idx
operator|=
name|nm_kr_lease
argument_list|(
name|kring
argument_list|,
name|howmany
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
comment|/* only retry if we need more than available slots */
if|if
condition|(
name|retry
operator|&&
name|needed
operator|<=
name|howmany
condition|)
name|retry
operator|=
literal|0
expr_stmt|;
comment|/* copy to the destination queue */
while|while
condition|(
name|howmany
operator|>
literal|0
condition|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|nm_bdg_fwd
modifier|*
name|ft_p
decl_stmt|,
modifier|*
name|ft_end
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
name|int
name|fix_mismatch
init|=
name|offset_mismatch
decl_stmt|;
comment|/* find the queue from which we pick next packet. 			 * NM_FT_NULL is always higher than valid indexes 			 * so we never dereference it if the other list 			 * has packets (and if both are empty we never 			 * get here). 			 */
if|if
condition|(
name|next
operator|<
name|brd_next
condition|)
block|{
name|ft_p
operator|=
name|ft
operator|+
name|next
expr_stmt|;
name|next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
block|}
else|else
block|{
comment|/* insert broadcast */
name|ft_p
operator|=
name|ft
operator|+
name|brd_next
expr_stmt|;
name|brd_next
operator|=
name|ft_p
operator|->
name|ft_next
expr_stmt|;
block|}
name|cnt
operator|=
name|ft_p
operator|->
name|ft_frags
expr_stmt|;
comment|// cnt> 0
if|if
condition|(
name|unlikely
argument_list|(
name|cnt
operator|>
name|howmany
argument_list|)
condition|)
break|break;
comment|/* no more space */
name|howmany
operator|-=
name|cnt
expr_stmt|;
if|if
condition|(
name|netmap_verbose
operator|&&
name|cnt
operator|>
literal|1
condition|)
name|RD
argument_list|(
literal|5
argument_list|,
literal|"rx %d frags to %d"
argument_list|,
name|cnt
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ft_end
operator|=
name|ft_p
operator|+
name|cnt
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
init|=
name|ft_p
operator|->
name|ft_buf
decl_stmt|;
name|size_t
name|copy_len
init|=
name|ft_p
operator|->
name|ft_len
decl_stmt|,
name|dst_len
init|=
name|copy_len
decl_stmt|;
name|slot
operator|=
operator|&
name|ring
operator|->
name|slot
index|[
name|j
index|]
expr_stmt|;
name|dst
operator|=
name|BDG_NMB
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|fix_mismatch
argument_list|)
condition|)
block|{
comment|/* We are processing the first fragment 				     * and there is a mismatch between source 				     * and destination offsets. Create a zeroed 				     * header for the destination, independently 				     * of the source header length and content. 				     */
name|src
operator|+=
name|na
operator|->
name|offset
expr_stmt|;
name|copy_len
operator|-=
name|na
operator|->
name|offset
expr_stmt|;
name|bzero
argument_list|(
name|dst
argument_list|,
name|dst_na
operator|->
name|offset
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|dst_na
operator|->
name|offset
expr_stmt|;
name|dst_len
operator|=
name|dst_na
operator|->
name|offset
operator|+
name|copy_len
expr_stmt|;
comment|/* fix the first fragment only */
name|fix_mismatch
operator|=
literal|0
expr_stmt|;
comment|/* Here it could be copy_len == dst_len == 0, 				     * and so a zero length fragment is passed. 				     */
block|}
name|ND
argument_list|(
literal|"send [%d] %d(%d) bytes at %s:%d"
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|copy_len
argument_list|,
operator|(
name|int
operator|)
name|dst_len
argument_list|,
name|NM_IFPNAME
argument_list|(
name|dst_ifp
argument_list|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* round to a multiple of 64 */
name|copy_len
operator|=
operator|(
name|copy_len
operator|+
literal|63
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
if|if
condition|(
name|ft_p
operator|->
name|ft_flags
operator|&
name|NS_INDIRECT
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|copy_len
argument_list|)
condition|)
block|{
comment|// invalid user pointer, pretend len is 0
name|dst_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//memcpy(dst, src, copy_len);
name|pkt_copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
operator|(
name|int
operator|)
name|copy_len
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|len
operator|=
name|dst_len
expr_stmt|;
name|slot
operator|->
name|flags
operator|=
operator|(
name|cnt
operator|<<
literal|8
operator|)
operator||
name|NS_MOREFRAG
expr_stmt|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|ft_p
operator|++
expr_stmt|;
name|sent
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ft_p
operator|!=
name|ft_end
condition|)
do|;
name|slot
operator|->
name|flags
operator|=
operator|(
name|cnt
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* clear flag on last entry */
comment|/* are we done ? */
if|if
condition|(
name|next
operator|==
name|NM_FT_NULL
operator|&&
name|brd_next
operator|==
name|NM_FT_NULL
condition|)
break|break;
block|}
block|{
comment|/* current position */
name|uint32_t
modifier|*
name|p
init|=
name|kring
operator|->
name|nkr_leases
decl_stmt|;
comment|/* shorthand */
name|uint32_t
name|update_pos
decl_stmt|;
name|int
name|still_locked
init|=
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|howmany
operator|>
literal|0
argument_list|)
condition|)
block|{
comment|/* not used all bufs. If i am the last one 			 * i can recover the slots, otherwise must 			 * fill them with 0 to mark empty packets. 			 */
name|ND
argument_list|(
literal|"leftover %d bufs"
argument_list|,
name|howmany
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
operator|==
name|kring
operator|->
name|nkr_lease_idx
condition|)
block|{
comment|/* yes i am the last one */
name|ND
argument_list|(
literal|"roll back nkr_hwlease to %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|kring
operator|->
name|nkr_hwlease
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|howmany
operator|--
operator|>
literal|0
condition|)
block|{
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|j
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|nm_next
argument_list|(
name|j
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|p
index|[
name|lease_idx
index|]
operator|=
name|j
expr_stmt|;
comment|/* report I am done */
name|update_pos
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
if|if
condition|(
name|my_start
operator|==
name|update_pos
condition|)
block|{
comment|/* all slots before my_start have been reported, 			 * so scan subsequent leases to see if other ranges 			 * have been completed, and to a selwakeup or txsync. 		         */
while|while
condition|(
name|lease_idx
operator|!=
name|kring
operator|->
name|nkr_lease_idx
operator|&&
name|p
index|[
name|lease_idx
index|]
operator|!=
name|NR_NOSLOT
condition|)
block|{
name|j
operator|=
name|p
index|[
name|lease_idx
index|]
expr_stmt|;
name|p
index|[
name|lease_idx
index|]
operator|=
name|NR_NOSLOT
expr_stmt|;
name|lease_idx
operator|=
name|nm_next
argument_list|(
name|lease_idx
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
comment|/* j is the new 'write' position. j != my_start 			 * means there are new buffers to report 			 */
if|if
condition|(
name|likely
argument_list|(
name|j
operator|!=
name|my_start
argument_list|)
condition|)
block|{
name|kring
operator|->
name|nr_hwtail
operator|=
name|j
expr_stmt|;
name|dst_na
operator|->
name|up
operator|.
name|nm_notify
argument_list|(
operator|&
name|dst_na
operator|->
name|up
argument_list|,
name|dst_nr
argument_list|,
name|NR_RX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|still_locked
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_na
operator|->
name|retry
operator|&&
name|retry
operator|--
condition|)
goto|goto
name|retry
goto|;
block|}
block|}
if|if
condition|(
name|still_locked
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|d
operator|->
name|bq_head
operator|=
name|d
operator|->
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
comment|/* cleanup */
name|d
operator|->
name|bq_len
operator|=
literal|0
expr_stmt|;
block|}
name|brddst
operator|->
name|bq_head
operator|=
name|brddst
operator|->
name|bq_tail
operator|=
name|NM_FT_NULL
expr_stmt|;
comment|/* cleanup */
name|brddst
operator|->
name|bq_len
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_vp_txsync
parameter_list|(
name|struct
name|netmap_vp_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|up
operator|.
name|tx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|u_int
name|done
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|cur
init|=
name|kring
operator|->
name|rcur
decl_stmt|;
if|if
condition|(
name|bridge_batch
operator|<=
literal|0
condition|)
block|{
comment|/* testing only */
name|done
operator|=
name|cur
expr_stmt|;
comment|// used all
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|bridge_batch
operator|>
name|NM_BDG_BATCH
condition|)
name|bridge_batch
operator|=
name|NM_BDG_BATCH
expr_stmt|;
name|done
operator|=
name|nm_bdg_preflush
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
name|kring
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|done
operator|!=
name|cur
condition|)
name|D
argument_list|(
literal|"early break at %d/ %d, tail %d"
argument_list|,
name|done
argument_list|,
name|cur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|)
expr_stmt|;
comment|/* 	 * packets between 'done' and 'cur' are left unsent. 	 */
name|kring
operator|->
name|nr_hwcur
operator|=
name|done
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_prev
argument_list|(
name|done
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|nm_txsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s ring %d flags %d"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|up
operator|.
name|ifp
argument_list|)
argument_list|,
name|ring_nr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * main dispatch routine for the bridge.  * We already know that only one thread is running this.  * we must run nm_bdg_preflush without lock.  */
end_comment

begin_function
specifier|static
name|int
name|bdg_netmap_txsync
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|(
expr|struct
name|netmap_vp_adapter
operator|*
operator|)
name|na
decl_stmt|;
return|return
name|netmap_vp_txsync
argument_list|(
name|vpna
argument_list|,
name|ring_nr
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_vp_rxsync
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|,
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
name|head
init|=
name|nm_rxsync_prologue
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|head
operator|>
name|lim
condition|)
block|{
name|D
argument_list|(
literal|"ouch dangerous reset!!!"
argument_list|)
expr_stmt|;
name|n
operator|=
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* First part, import newly received packets. */
comment|/* actually nothing to do here, they are already in the kring */
comment|/* Second part, skip past packets that userspace has released. */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* consistency check, but nothing really important here */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|likely
argument_list|(
name|nm_i
operator|!=
name|head
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|BDG_NMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|netmap_buffer_base
condition|)
block|{
comment|/* bad buf */
name|D
argument_list|(
literal|"bad buffer index %d, ignore ?"
argument_list|,
name|slot
operator|->
name|buf_idx
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
block|}
comment|/* tell userspace that there are new packets */
name|nm_rxsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|done
label|:
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * user process reading from a VALE switch.  * Already protected against concurrent calls from userspace,  * but we must acquire the queue's lock to protect against  * writers on the same queue.  */
end_comment

begin_function
specifier|static
name|int
name|bdg_netmap_rxsync
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|n
operator|=
name|netmap_vp_rxsync
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|kring
operator|->
name|q_lock
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bdg_netmap_attach
parameter_list|(
name|struct
name|nmreq
modifier|*
name|nmr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vpna
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vpna
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpna
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|na
operator|=
operator|&
name|vpna
operator|->
name|up
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
comment|/* bound checking */
name|na
operator|->
name|num_tx_rings
operator|=
name|nmr
operator|->
name|nr_tx_rings
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|na
operator|->
name|num_tx_rings
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXRINGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_tx_rings
operator|=
name|na
operator|->
name|num_tx_rings
expr_stmt|;
comment|// write back
name|na
operator|->
name|num_rx_rings
operator|=
name|nmr
operator|->
name|nr_rx_rings
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|na
operator|->
name|num_rx_rings
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXRINGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nmr
operator|->
name|nr_rx_rings
operator|=
name|na
operator|->
name|num_rx_rings
expr_stmt|;
comment|// write back
name|nm_bound_var
argument_list|(
operator|&
name|nmr
operator|->
name|nr_tx_slots
argument_list|,
name|NM_BRIDGE_RINGSIZE
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|nmr
operator|->
name|nr_tx_slots
expr_stmt|;
name|nm_bound_var
argument_list|(
operator|&
name|nmr
operator|->
name|nr_rx_slots
argument_list|,
name|NM_BRIDGE_RINGSIZE
argument_list|,
literal|1
argument_list|,
name|NM_BDG_MAXSLOTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|nmr
operator|->
name|nr_rx_slots
expr_stmt|;
name|vpna
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|na
operator|->
name|na_flags
operator||=
name|NAF_BDG_MAYSLEEP
operator||
name|NAF_MEM_OWNER
expr_stmt|;
name|na
operator|->
name|nm_txsync
operator|=
name|bdg_netmap_txsync
expr_stmt|;
name|na
operator|->
name|nm_rxsync
operator|=
name|bdg_netmap_rxsync
expr_stmt|;
name|na
operator|->
name|nm_register
operator|=
name|bdg_netmap_reg
expr_stmt|;
name|na
operator|->
name|nm_dtor
operator|=
name|netmap_adapter_vp_dtor
expr_stmt|;
name|na
operator|->
name|nm_krings_create
operator|=
name|netmap_vp_krings_create
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
operator|=
name|netmap_vp_krings_delete
expr_stmt|;
name|na
operator|->
name|nm_mem
operator|=
name|netmap_mem_private_new
argument_list|(
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
comment|/* other nmd fields are set in the common routine */
name|error
operator|=
name|netmap_attach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|vpna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_bwrap_dtor
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|struct
name|nm_bridge
modifier|*
name|b
init|=
name|bna
operator|->
name|up
operator|.
name|na_bdg
decl_stmt|,
modifier|*
name|bh
init|=
name|bna
operator|->
name|host
operator|.
name|na_bdg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|ND
argument_list|(
literal|"na %p"
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
condition|)
block|{
name|netmap_bdg_detach_common
argument_list|(
name|b
argument_list|,
name|bna
operator|->
name|up
operator|.
name|bdg_port
argument_list|,
operator|(
name|bh
condition|?
name|bna
operator|->
name|host
operator|.
name|bdg_port
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|hwna
operator|->
name|na_private
operator|=
name|NULL
expr_stmt|;
name|netmap_adapter_put
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ifp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intr callback for NICs connected to a bridge.  * Simply ignore tx interrupts (maybe we could try to recover space ?)  * and pass received packets from nic to the bridge.  *  * XXX TODO check locking: this is called from the interrupt  * handler so we should make sure that the interface is not  * disconnected while passing down an interrupt.  *  * Note, no user process can access this NIC or the host stack.  * The only part of the ring that is significant are the slots,  * and head/cur/tail are set from the kring as needed  * (part as a receive ring, part as a transmit ring).  *  * callback that overwrites the hwna notify callback.  * Packets come from the outside or from the host stack and are put on an hwna rx ring.  * The bridge wrapper then sends the packets through the bridge.  */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_intr_notify
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_nr
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|hostna
init|=
operator|&
name|bna
operator|->
name|host
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|,
modifier|*
name|bkring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|is_host_ring
init|=
name|ring_nr
operator|==
name|na
operator|->
name|num_rx_rings
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|vpna
init|=
operator|&
name|bna
operator|->
name|up
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s %s%d 0x%x"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
operator|(
name|tx
operator|==
name|NR_TX
condition|?
literal|"TX"
else|:
literal|"RX"
operator|)
argument_list|,
name|ring_nr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NAF_DISABLE_NOTIFY
condition|)
block|{
name|kring
operator|=
name|tx
operator|==
name|NR_TX
condition|?
name|na
operator|->
name|tx_rings
else|:
name|na
operator|->
name|rx_rings
expr_stmt|;
name|bkring
operator|=
name|tx
operator|==
name|NR_TX
condition|?
name|vpna
operator|->
name|up
operator|.
name|rx_rings
else|:
name|vpna
operator|->
name|up
operator|.
name|tx_rings
expr_stmt|;
if|if
condition|(
name|kring
index|[
name|ring_nr
index|]
operator|.
name|nkr_stopped
condition|)
name|netmap_disable_ring
argument_list|(
operator|&
name|bkring
index|[
name|ring_nr
index|]
argument_list|)
expr_stmt|;
else|else
name|bkring
index|[
name|ring_nr
index|]
operator|.
name|nkr_stopped
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
literal|0
return|;
comment|/* we only care about receive interrupts */
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
return|return
literal|0
return|;
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_nr
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
comment|/* make sure the ring is not disabled */
if|if
condition|(
name|nm_kr_tryget
argument_list|(
name|kring
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|is_host_ring
operator|&&
name|hostna
operator|->
name|na_bdg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|bna
operator|->
name|save_notify
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
name|tx
argument_list|,
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
comment|/* Here we expect ring->head = ring->cur = ring->tail 	 * because everything has been released from the previous round. 	 * However the ring is shared and we might have info from 	 * the wrong side (the tx ring). Hence we overwrite with 	 * the info from the rx kring. 	 */
if|if
condition|(
name|netmap_verbose
condition|)
name|D
argument_list|(
literal|"%s head %d cur %d tail %d (kring %d %d %d)"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|kring
operator|->
name|rhead
argument_list|,
name|kring
operator|->
name|rcur
argument_list|,
name|kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
name|ring
operator|->
name|head
operator|=
name|kring
operator|->
name|rhead
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|rcur
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
comment|/* simulate a user wakeup on the rx ring */
if|if
condition|(
name|is_host_ring
condition|)
block|{
name|netmap_rxsync_from_host
argument_list|(
name|na
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vpna
operator|=
name|hostna
expr_stmt|;
name|ring_nr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* fetch packets that have arrived. 		 * XXX maybe do this in a loop ? 		 */
name|error
operator|=
name|na
operator|->
name|nm_rxsync
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|put_out
goto|;
block|}
if|if
condition|(
name|kring
operator|->
name|nr_hwcur
operator|==
name|kring
operator|->
name|nr_hwtail
operator|&&
name|netmap_verbose
condition|)
block|{
name|D
argument_list|(
literal|"how strange, interrupt with no packets on %s"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|put_out
goto|;
block|}
comment|/* new packets are ring->cur to ring->tail, and the bkring 	 * had hwcur == ring->cur. So advance ring->cur to ring->tail 	 * to push all packets out. 	 */
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|ring
operator|->
name|tail
expr_stmt|;
comment|/* also set tail to what the bwrap expects */
name|bkring
operator|=
operator|&
name|vpna
operator|->
name|up
operator|.
name|tx_rings
index|[
name|ring_nr
index|]
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|bkring
operator|->
name|nr_hwtail
expr_stmt|;
comment|// rtail too ?
comment|/* pass packets to the switch */
name|nm_txsync_prologue
argument_list|(
name|bkring
argument_list|)
expr_stmt|;
comment|// XXX error checking ?
name|netmap_vp_txsync
argument_list|(
name|vpna
argument_list|,
name|ring_nr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* mark all buffers as released on this ring */
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
comment|/* another call to actually release the buffers */
if|if
condition|(
operator|!
name|is_host_ring
condition|)
block|{
name|error
operator|=
name|na
operator|->
name|nm_rxsync
argument_list|(
name|na
argument_list|,
name|ring_nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mark all packets as released, as in the 		 * second part of netmap_rxsync_from_host() 		 */
name|kring
operator|->
name|nr_hwcur
operator|=
name|kring
operator|->
name|nr_hwtail
expr_stmt|;
name|nm_rxsync_finalize
argument_list|(
name|kring
argument_list|)
expr_stmt|;
block|}
name|put_out
label|:
name|nm_kr_put
argument_list|(
name|kring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_bwrap_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|struct
name|netmap_vp_adapter
modifier|*
name|hostna
init|=
operator|&
name|bna
operator|->
name|host
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ND
argument_list|(
literal|"%s %s"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|,
name|onoff
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|int
name|i
decl_stmt|;
name|hwna
operator|->
name|na_lut
operator|=
name|na
operator|->
name|na_lut
expr_stmt|;
name|hwna
operator|->
name|na_lut_objtotal
operator|=
name|na
operator|->
name|na_lut_objtotal
expr_stmt|;
if|if
condition|(
name|hostna
operator|->
name|na_bdg
condition|)
block|{
name|hostna
operator|->
name|up
operator|.
name|na_lut
operator|=
name|na
operator|->
name|na_lut
expr_stmt|;
name|hostna
operator|->
name|up
operator|.
name|na_lut_objtotal
operator|=
name|na
operator|->
name|na_lut_objtotal
expr_stmt|;
block|}
comment|/* cross-link the netmap rings 		 * The original number of rings comes from hwna, 		 * rx rings on one side equals tx rings on the other. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|na
operator|->
name|num_rx_rings
condition|;
name|i
operator|++
control|)
block|{
name|hwna
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
operator|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
name|hwna
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|=
name|na
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|na
operator|->
name|num_tx_rings
condition|;
name|i
operator|++
control|)
block|{
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
operator|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|nkr_num_slots
expr_stmt|;
name|hwna
operator|->
name|rx_rings
index|[
name|i
index|]
operator|.
name|ring
operator|=
name|na
operator|->
name|tx_rings
index|[
name|i
index|]
operator|.
name|ring
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hwna
operator|->
name|ifp
condition|)
block|{
name|error
operator|=
name|hwna
operator|->
name|nm_register
argument_list|(
name|hwna
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|bdg_netmap_reg
argument_list|(
name|na
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|bna
operator|->
name|save_notify
operator|=
name|hwna
operator|->
name|nm_notify
expr_stmt|;
name|hwna
operator|->
name|nm_notify
operator|=
name|netmap_bwrap_intr_notify
expr_stmt|;
block|}
else|else
block|{
name|hwna
operator|->
name|nm_notify
operator|=
name|bna
operator|->
name|save_notify
expr_stmt|;
name|hwna
operator|->
name|na_lut
operator|=
name|NULL
expr_stmt|;
name|hwna
operator|->
name|na_lut_objtotal
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_bwrap_config
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
modifier|*
name|txr
parameter_list|,
name|u_int
modifier|*
name|txd
parameter_list|,
name|u_int
modifier|*
name|rxr
parameter_list|,
name|u_int
modifier|*
name|rxd
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
comment|/* forward the request */
name|netmap_update_config
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
comment|/* swap the results */
operator|*
name|txr
operator|=
name|hwna
operator|->
name|num_rx_rings
expr_stmt|;
operator|*
name|txd
operator|=
name|hwna
operator|->
name|num_rx_desc
expr_stmt|;
operator|*
name|rxr
operator|=
name|hwna
operator|->
name|num_tx_rings
expr_stmt|;
operator|*
name|rxd
operator|=
name|hwna
operator|->
name|num_rx_desc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_bwrap_krings_create
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hostna
init|=
operator|&
name|bna
operator|->
name|host
operator|.
name|up
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ND
argument_list|(
literal|"%s"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|netmap_vp_krings_create
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|hwna
operator|->
name|nm_krings_create
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_vp_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|hostna
operator|->
name|tx_rings
operator|=
name|na
operator|->
name|tx_rings
operator|+
name|na
operator|->
name|num_tx_rings
expr_stmt|;
name|hostna
operator|->
name|rx_rings
operator|=
name|na
operator|->
name|rx_rings
operator|+
name|na
operator|->
name|num_rx_rings
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netmap_bwrap_krings_delete
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|ND
argument_list|(
literal|"%s"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|hwna
operator|->
name|nm_krings_delete
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
name|netmap_vp_krings_delete
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* notify method for the bridge-->hwna direction */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_notify
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_n
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
operator|(
expr|struct
name|netmap_bwrap_adapter
operator|*
operator|)
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|bna
operator|->
name|hwna
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
decl_stmt|,
modifier|*
name|hw_kring
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
decl_stmt|;
name|u_int
name|lim
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
condition|)
return|return
name|EINVAL
return|;
name|kring
operator|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|ring_n
index|]
expr_stmt|;
name|hw_kring
operator|=
operator|&
name|hwna
operator|->
name|tx_rings
index|[
name|ring_n
index|]
expr_stmt|;
name|ring
operator|=
name|kring
operator|->
name|ring
expr_stmt|;
name|lim
operator|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|hwna
operator|->
name|ifp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|hwna
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
return|return
literal|0
return|;
comment|/* first step: simulate a user wakeup on the rx ring */
name|netmap_vp_rxsync
argument_list|(
name|na
argument_list|,
name|ring_n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%s[%d] PRE rx(c%3d t%3d l%3d) ring(h%3d c%3d t%3d) tx(c%3d ht%3d t%3d)"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|,
name|ring_n
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|nkr_hwlease
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|hw_kring
operator|->
name|nr_hwcur
argument_list|,
name|hw_kring
operator|->
name|nr_hwtail
argument_list|,
name|hw_ring
operator|->
name|rtail
argument_list|)
expr_stmt|;
comment|/* second step: the simulated user consumes all new packets */
name|ring
operator|->
name|head
operator|=
name|ring
operator|->
name|cur
operator|=
name|ring
operator|->
name|tail
expr_stmt|;
comment|/* third step: the new packets are sent on the tx ring 	 * (which is actually the same ring) 	 */
comment|/* set tail to what the hw expects */
name|ring
operator|->
name|tail
operator|=
name|hw_kring
operator|->
name|rtail
expr_stmt|;
if|if
condition|(
name|ring_n
operator|==
name|na
operator|->
name|num_rx_rings
condition|)
block|{
name|netmap_txsync_to_host
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nm_txsync_prologue
argument_list|(
operator|&
name|hwna
operator|->
name|tx_rings
index|[
name|ring_n
index|]
argument_list|)
expr_stmt|;
comment|// XXX error checking ?
name|error
operator|=
name|hwna
operator|->
name|nm_txsync
argument_list|(
name|hwna
argument_list|,
name|ring_n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* fourth step: now we are back the rx ring */
comment|/* claim ownership on all hw owned bufs */
name|ring
operator|->
name|head
operator|=
name|nm_next
argument_list|(
name|ring
operator|->
name|tail
argument_list|,
name|lim
argument_list|)
expr_stmt|;
comment|/* skip past reserved slot */
name|ring
operator|->
name|tail
operator|=
name|kring
operator|->
name|rtail
expr_stmt|;
comment|/* restore saved value of tail, for safety */
comment|/* fifth step: the user goes to sleep again, causing another rxsync */
name|netmap_vp_rxsync
argument_list|(
name|na
argument_list|,
name|ring_n
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"%s[%d] PST rx(c%3d t%3d l%3d) ring(h%3d c%3d t%3d) tx(c%3d ht%3d t%3d)"
argument_list|,
name|NM_IFPNAME
argument_list|(
name|na
operator|->
name|ifp
argument_list|)
argument_list|,
name|ring_n
argument_list|,
name|kring
operator|->
name|nr_hwcur
argument_list|,
name|kring
operator|->
name|nr_hwtail
argument_list|,
name|kring
operator|->
name|nkr_hwlease
argument_list|,
name|ring
operator|->
name|head
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|tail
argument_list|,
name|hw_kring
operator|->
name|nr_hwcur
argument_list|,
name|hw_kring
operator|->
name|nr_hwtail
argument_list|,
name|hw_kring
operator|->
name|rtail
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netmap_bwrap_host_notify
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|u_int
name|ring_n
parameter_list|,
name|enum
name|txrx
name|tx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
init|=
name|na
operator|->
name|na_private
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|port_na
init|=
operator|&
name|bna
operator|->
name|up
operator|.
name|up
decl_stmt|;
if|if
condition|(
name|tx
operator|==
name|NR_TX
operator|||
name|ring_n
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
return|return
name|netmap_bwrap_notify
argument_list|(
name|port_na
argument_list|,
name|port_na
operator|->
name|num_rx_rings
argument_list|,
name|NR_RX
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* attach a bridge wrapper to the 'real' device */
end_comment

begin_function
specifier|static
name|int
name|netmap_bwrap_attach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|fake
parameter_list|,
name|struct
name|ifnet
modifier|*
name|real
parameter_list|)
block|{
name|struct
name|netmap_bwrap_adapter
modifier|*
name|bna
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|na
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hwna
init|=
name|NA
argument_list|(
name|real
argument_list|)
decl_stmt|;
name|struct
name|netmap_adapter
modifier|*
name|hostna
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bna
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bna
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bna
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|na
operator|=
operator|&
name|bna
operator|->
name|up
operator|.
name|up
expr_stmt|;
name|na
operator|->
name|ifp
operator|=
name|fake
expr_stmt|;
comment|/* fill the ring data for the bwrap adapter with rx/tx meanings 	 * swapped. The real cross-linking will be done during register, 	 * when all the krings will have been created. 	 */
name|na
operator|->
name|num_rx_rings
operator|=
name|hwna
operator|->
name|num_tx_rings
expr_stmt|;
name|na
operator|->
name|num_tx_rings
operator|=
name|hwna
operator|->
name|num_rx_rings
expr_stmt|;
name|na
operator|->
name|num_tx_desc
operator|=
name|hwna
operator|->
name|num_rx_desc
expr_stmt|;
name|na
operator|->
name|num_rx_desc
operator|=
name|hwna
operator|->
name|num_tx_desc
expr_stmt|;
name|na
operator|->
name|nm_dtor
operator|=
name|netmap_bwrap_dtor
expr_stmt|;
name|na
operator|->
name|nm_register
operator|=
name|netmap_bwrap_register
expr_stmt|;
comment|// na->nm_txsync = netmap_bwrap_txsync;
comment|// na->nm_rxsync = netmap_bwrap_rxsync;
name|na
operator|->
name|nm_config
operator|=
name|netmap_bwrap_config
expr_stmt|;
name|na
operator|->
name|nm_krings_create
operator|=
name|netmap_bwrap_krings_create
expr_stmt|;
name|na
operator|->
name|nm_krings_delete
operator|=
name|netmap_bwrap_krings_delete
expr_stmt|;
name|na
operator|->
name|nm_notify
operator|=
name|netmap_bwrap_notify
expr_stmt|;
name|na
operator|->
name|nm_mem
operator|=
name|hwna
operator|->
name|nm_mem
expr_stmt|;
name|na
operator|->
name|na_private
operator|=
name|na
expr_stmt|;
comment|/* prevent NIOCREGIF */
name|bna
operator|->
name|up
operator|.
name|retry
operator|=
literal|1
expr_stmt|;
comment|/* XXX maybe this should depend on the hwna */
name|bna
operator|->
name|hwna
operator|=
name|hwna
expr_stmt|;
name|netmap_adapter_get
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
name|hwna
operator|->
name|na_private
operator|=
name|bna
expr_stmt|;
comment|/* weak reference */
name|hostna
operator|=
operator|&
name|bna
operator|->
name|host
operator|.
name|up
expr_stmt|;
name|hostna
operator|->
name|ifp
operator|=
name|hwna
operator|->
name|ifp
expr_stmt|;
name|hostna
operator|->
name|num_tx_rings
operator|=
literal|1
expr_stmt|;
name|hostna
operator|->
name|num_tx_desc
operator|=
name|hwna
operator|->
name|num_rx_desc
expr_stmt|;
name|hostna
operator|->
name|num_rx_rings
operator|=
literal|1
expr_stmt|;
name|hostna
operator|->
name|num_rx_desc
operator|=
name|hwna
operator|->
name|num_tx_desc
expr_stmt|;
comment|// hostna->nm_txsync = netmap_bwrap_host_txsync;
comment|// hostna->nm_rxsync = netmap_bwrap_host_rxsync;
name|hostna
operator|->
name|nm_notify
operator|=
name|netmap_bwrap_host_notify
expr_stmt|;
name|hostna
operator|->
name|nm_mem
operator|=
name|na
operator|->
name|nm_mem
expr_stmt|;
name|hostna
operator|->
name|na_private
operator|=
name|bna
expr_stmt|;
name|ND
argument_list|(
literal|"%s<->%s txr %d txd %d rxr %d rxd %d"
argument_list|,
name|fake
operator|->
name|if_xname
argument_list|,
name|real
operator|->
name|if_xname
argument_list|,
name|na
operator|->
name|num_tx_rings
argument_list|,
name|na
operator|->
name|num_tx_desc
argument_list|,
name|na
operator|->
name|num_rx_rings
argument_list|,
name|na
operator|->
name|num_rx_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|netmap_attach_common
argument_list|(
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|netmap_adapter_put
argument_list|(
name|hwna
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bna
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|netmap_init_bridges
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|nm_bridges
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nm_bridge
argument_list|)
operator|*
name|NM_BRIDGES
argument_list|)
expr_stmt|;
comment|/* safety */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NM_BRIDGES
condition|;
name|i
operator|++
control|)
name|BDG_RWINIT
argument_list|(
operator|&
name|nm_bridges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_VALE */
end_comment

end_unit

