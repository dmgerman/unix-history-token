begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Adrian Chadd, Xenion Pty Ltd.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_comment
comment|/* XXX for some support functions */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx_ht.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_athrate.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_comment
comment|/*  * XXX net80211?  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_AMPDU_SUBFRAME_DEFAULT
value|32
end_define

begin_define
define|#
directive|define
name|ATH_AGGR_DELIM_SZ
value|4
end_define

begin_comment
comment|/* delimiter size */
end_comment

begin_define
define|#
directive|define
name|ATH_AGGR_MINPLEN
value|256
end_define

begin_comment
comment|/* in bytes, minimum packet length */
end_comment

begin_comment
comment|/* number of delimiters for encryption padding */
end_comment

begin_define
define|#
directive|define
name|ATH_AGGR_ENCRYPTDELIM
value|10
end_define

begin_comment
comment|/*  * returns delimiter padding required given the packet length  */
end_comment

begin_define
define|#
directive|define
name|ATH_AGGR_GET_NDELIM
parameter_list|(
name|_len
parameter_list|)
define|\
value|(((((_len) + ATH_AGGR_DELIM_SZ)< ATH_AGGR_MINPLEN) ?	\ 	    (ATH_AGGR_MINPLEN - (_len) - ATH_AGGR_DELIM_SZ) : 0)>> 2)
end_define

begin_define
define|#
directive|define
name|PADBYTES
parameter_list|(
name|_len
parameter_list|)
value|((4 - ((_len) % 4)) % 4)
end_define

begin_decl_stmt
name|int
name|ath_max_4ms_framelen
index|[
literal|4
index|]
index|[
literal|32
index|]
init|=
block|{
index|[
name|MCS_HT20
index|]
operator|=
block|{
literal|3212
block|,
literal|6432
block|,
literal|9648
block|,
literal|12864
block|,
literal|19300
block|,
literal|25736
block|,
literal|28952
block|,
literal|32172
block|,
literal|6424
block|,
literal|12852
block|,
literal|19280
block|,
literal|25708
block|,
literal|38568
block|,
literal|51424
block|,
literal|57852
block|,
literal|64280
block|,
literal|9628
block|,
literal|19260
block|,
literal|28896
block|,
literal|38528
block|,
literal|57792
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|12828
block|,
literal|25656
block|,
literal|38488
block|,
literal|51320
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|, 	}
block|,
index|[
name|MCS_HT20_SGI
index|]
operator|=
block|{
literal|3572
block|,
literal|7144
block|,
literal|10720
block|,
literal|14296
block|,
literal|21444
block|,
literal|28596
block|,
literal|32172
block|,
literal|35744
block|,
literal|7140
block|,
literal|14284
block|,
literal|21428
block|,
literal|28568
block|,
literal|42856
block|,
literal|57144
block|,
literal|64288
block|,
literal|65532
block|,
literal|10700
block|,
literal|21408
block|,
literal|32112
block|,
literal|42816
block|,
literal|64228
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|14256
block|,
literal|28516
block|,
literal|42780
block|,
literal|57040
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|, 	}
block|,
index|[
name|MCS_HT40
index|]
operator|=
block|{
literal|6680
block|,
literal|13360
block|,
literal|20044
block|,
literal|26724
block|,
literal|40092
block|,
literal|53456
block|,
literal|60140
block|,
literal|65532
block|,
literal|13348
block|,
literal|26700
block|,
literal|40052
block|,
literal|53400
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|20004
block|,
literal|40008
block|,
literal|60016
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|26644
block|,
literal|53292
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|, 	}
block|,
index|[
name|MCS_HT40_SGI
index|]
operator|=
block|{
literal|7420
block|,
literal|14844
block|,
literal|22272
block|,
literal|29696
block|,
literal|44544
block|,
literal|59396
block|,
literal|65532
block|,
literal|65532
block|,
literal|14832
block|,
literal|29668
block|,
literal|44504
block|,
literal|59340
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|22232
block|,
literal|44464
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|29616
block|,
literal|59232
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|,
literal|65532
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX should be in net80211  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mpdudensity_map
index|[]
init|=
block|{
literal|0
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_NA */
literal|25
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_025 */
literal|50
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_05 */
literal|100
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_1 */
literal|200
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_2 */
literal|400
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_4 */
literal|800
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_8 */
literal|1600
block|,
comment|/* IEEE80211_HTCAP_MPDUDENSITY_16 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX should be in the HAL/net80211 ?  */
end_comment

begin_define
define|#
directive|define
name|BITS_PER_BYTE
value|8
end_define

begin_define
define|#
directive|define
name|OFDM_PLCP_BITS
value|22
end_define

begin_define
define|#
directive|define
name|HT_RC_2_MCS
parameter_list|(
name|_rc
parameter_list|)
value|((_rc)& 0x7f)
end_define

begin_define
define|#
directive|define
name|HT_RC_2_STREAMS
parameter_list|(
name|_rc
parameter_list|)
value|((((_rc)& 0x78)>> 3) + 1)
end_define

begin_define
define|#
directive|define
name|L_STF
value|8
end_define

begin_define
define|#
directive|define
name|L_LTF
value|8
end_define

begin_define
define|#
directive|define
name|L_SIG
value|4
end_define

begin_define
define|#
directive|define
name|HT_SIG
value|8
end_define

begin_define
define|#
directive|define
name|HT_STF
value|4
end_define

begin_define
define|#
directive|define
name|HT_LTF
parameter_list|(
name|_ns
parameter_list|)
value|(4 * (_ns))
end_define

begin_define
define|#
directive|define
name|SYMBOL_TIME
parameter_list|(
name|_ns
parameter_list|)
value|((_ns)<< 2)
end_define

begin_comment
comment|// ns * 4 us
end_comment

begin_define
define|#
directive|define
name|SYMBOL_TIME_HALFGI
parameter_list|(
name|_ns
parameter_list|)
value|(((_ns) * 18 + 4) / 5)
end_define

begin_comment
comment|// ns * 3.6 us
end_comment

begin_define
define|#
directive|define
name|NUM_SYMBOLS_PER_USEC
parameter_list|(
name|_usec
parameter_list|)
value|(_usec>> 2)
end_define

begin_define
define|#
directive|define
name|NUM_SYMBOLS_PER_USEC_HALFGI
parameter_list|(
name|_usec
parameter_list|)
value|(((_usec*5)-4)/18)
end_define

begin_define
define|#
directive|define
name|IS_HT_RATE
parameter_list|(
name|_rate
parameter_list|)
value|((_rate)& 0x80)
end_define

begin_decl_stmt
specifier|const
name|uint32_t
name|bits_per_symbol
index|[]
index|[
literal|2
index|]
init|=
block|{
comment|/* 20MHz 40MHz */
block|{
literal|26
block|,
literal|54
block|}
block|,
comment|//  0: BPSK
block|{
literal|52
block|,
literal|108
block|}
block|,
comment|//  1: QPSK 1/2
block|{
literal|78
block|,
literal|162
block|}
block|,
comment|//  2: QPSK 3/4
block|{
literal|104
block|,
literal|216
block|}
block|,
comment|//  3: 16-QAM 1/2
block|{
literal|156
block|,
literal|324
block|}
block|,
comment|//  4: 16-QAM 3/4
block|{
literal|208
block|,
literal|432
block|}
block|,
comment|//  5: 64-QAM 2/3
block|{
literal|234
block|,
literal|486
block|}
block|,
comment|//  6: 64-QAM 3/4
block|{
literal|260
block|,
literal|540
block|}
block|,
comment|//  7: 64-QAM 5/6
block|{
literal|52
block|,
literal|108
block|}
block|,
comment|//  8: BPSK
block|{
literal|104
block|,
literal|216
block|}
block|,
comment|//  9: QPSK 1/2
block|{
literal|156
block|,
literal|324
block|}
block|,
comment|// 10: QPSK 3/4
block|{
literal|208
block|,
literal|432
block|}
block|,
comment|// 11: 16-QAM 1/2
block|{
literal|312
block|,
literal|648
block|}
block|,
comment|// 12: 16-QAM 3/4
block|{
literal|416
block|,
literal|864
block|}
block|,
comment|// 13: 64-QAM 2/3
block|{
literal|468
block|,
literal|972
block|}
block|,
comment|// 14: 64-QAM 3/4
block|{
literal|520
block|,
literal|1080
block|}
block|,
comment|// 15: 64-QAM 5/6
block|{
literal|78
block|,
literal|162
block|}
block|,
comment|// 16: BPSK
block|{
literal|156
block|,
literal|324
block|}
block|,
comment|// 17: QPSK 1/2
block|{
literal|234
block|,
literal|486
block|}
block|,
comment|// 18: QPSK 3/4
block|{
literal|312
block|,
literal|648
block|}
block|,
comment|// 19: 16-QAM 1/2
block|{
literal|468
block|,
literal|972
block|}
block|,
comment|// 20: 16-QAM 3/4
block|{
literal|624
block|,
literal|1296
block|}
block|,
comment|// 21: 64-QAM 2/3
block|{
literal|702
block|,
literal|1458
block|}
block|,
comment|// 22: 64-QAM 3/4
block|{
literal|780
block|,
literal|1620
block|}
block|,
comment|// 23: 64-QAM 5/6
block|{
literal|104
block|,
literal|216
block|}
block|,
comment|// 24: BPSK
block|{
literal|208
block|,
literal|432
block|}
block|,
comment|// 25: QPSK 1/2
block|{
literal|312
block|,
literal|648
block|}
block|,
comment|// 26: QPSK 3/4
block|{
literal|416
block|,
literal|864
block|}
block|,
comment|// 27: 16-QAM 1/2
block|{
literal|624
block|,
literal|1296
block|}
block|,
comment|// 28: 16-QAM 3/4
block|{
literal|832
block|,
literal|1728
block|}
block|,
comment|// 29: 64-QAM 2/3
block|{
literal|936
block|,
literal|1944
block|}
block|,
comment|// 30: 64-QAM 3/4
block|{
literal|1040
block|,
literal|2160
block|}
block|,
comment|// 31: 64-QAM 5/6
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fill in the rate array information based on the current  * node configuration and the choices made by the rate  * selection code and ath_buf setup code.  *  * Later on, this may end up also being made by the  * rate control code, but for now it can live here.  *  * This needs to be called just before the packet is  * queued to the software queue or hardware queue,  * so all of the needed fields in bf_state are setup.  */
end_comment

begin_function
name|void
name|ath_tx_rate_fill_rcflags
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|struct
name|ath_rc_series
modifier|*
name|rc
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATH_RC_NUM
condition|;
name|i
operator|++
control|)
block|{
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|tries
operator|==
literal|0
condition|)
continue|continue;
name|rate
operator|=
name|rt
operator|->
name|info
index|[
name|rc
index|[
name|i
index|]
operator|.
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
comment|/* 		 * Only enable short preamble for legacy rates 		 */
if|if
condition|(
operator|(
operator|!
name|IS_HT_RATE
argument_list|(
name|rate
argument_list|)
operator|)
operator|&&
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
condition|)
name|rate
operator||=
name|rt
operator|->
name|info
index|[
name|rc
index|[
name|i
index|]
operator|.
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
comment|/* 		 * Save this, used by the TX and completion code 		 */
name|rc
index|[
name|i
index|]
operator|.
name|ratecode
operator|=
name|rate
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_RTSCTS_FLAG
expr_stmt|;
comment|/* Only enable shortgi, 2040, dual-stream if HT is set */
if|if
condition|(
name|IS_HT_RATE
argument_list|(
name|rate
argument_list|)
condition|)
block|{
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_HT_FLAG
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|==
literal|40
condition|)
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_CW40_FLAG
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|==
literal|40
operator|&&
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI40
operator|&&
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI40
condition|)
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_SGI_FLAG
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|==
literal|20
operator|&&
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI20
operator|&&
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI20
condition|)
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_SGI_FLAG
expr_stmt|;
comment|/* 			 * If we have STBC TX enabled and the receiver 			 * can receive (at least) 1 stream STBC, AND it's 			 * MCS 0-7, AND we have at least two chains enabled, 			 * enable STBC. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_TXSTBC
operator|&&
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_RXSTBC_1STREAM
operator|&&
operator|(
name|sc
operator|->
name|sc_cur_txchainmask
operator|>
literal|1
operator|)
operator|&&
name|HT_RC_2_STREAMS
argument_list|(
name|rate
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_STBC_FLAG
expr_stmt|;
block|}
comment|/* 			 * XXX TODO: LDPC 			 */
comment|/* 			 * Dual / Triple stream rate? 			 */
if|if
condition|(
name|HT_RC_2_STREAMS
argument_list|(
name|rate
argument_list|)
operator|==
literal|2
condition|)
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_DS_FLAG
expr_stmt|;
elseif|else
if|if
condition|(
name|HT_RC_2_STREAMS
argument_list|(
name|rate
argument_list|)
operator|==
literal|3
condition|)
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|ATH_RC_TS_FLAG
expr_stmt|;
block|}
comment|/* 		 * Calculate the maximum TX power cap for the current 		 * node. 		 */
name|rc
index|[
name|i
index|]
operator|.
name|tx_power_cap
operator|=
name|ieee80211_get_node_txpower
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate the maximum 4ms frame length based 		 * on the MCS rate, SGI and channel width flags. 		 */
if|if
condition|(
operator|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_HT_FLAG
operator|)
operator|&&
operator|(
name|HT_RC_2_MCS
argument_list|(
name|rate
argument_list|)
operator|<
literal|32
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_CW40_FLAG
condition|)
block|{
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_SGI_FLAG
condition|)
name|j
operator|=
name|MCS_HT40_SGI
expr_stmt|;
else|else
name|j
operator|=
name|MCS_HT40
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_SGI_FLAG
condition|)
name|j
operator|=
name|MCS_HT20_SGI
expr_stmt|;
else|else
name|j
operator|=
name|MCS_HT20
expr_stmt|;
block|}
name|rc
index|[
name|i
index|]
operator|.
name|max4msframelen
operator|=
name|ath_max_4ms_framelen
index|[
name|j
index|]
index|[
name|HT_RC_2_MCS
argument_list|(
name|rate
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|rc
index|[
name|i
index|]
operator|.
name|max4msframelen
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: i=%d, rate=0x%x, flags=0x%x, max4ms=%d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|rate
argument_list|,
name|rc
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|rc
index|[
name|i
index|]
operator|.
name|max4msframelen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the number of delimiters to be added to  * meet the minimum required mpdudensity.  *  * Caller should make sure that the rate is HT.  *  * TODO: is this delimiter calculation supposed to be the  * total frame length, the hdr length, the data length (including  * delimiters, padding, CRC, etc) or ?  *  * TODO: this should ensure that the rate control information  * HAS been setup for the first rate.  *  * TODO: ensure this is only called for MCS rates.  *  * TODO: enforce MCS< 31  */
end_comment

begin_function
specifier|static
name|int
name|ath_compute_num_delims
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|first_bf
parameter_list|,
name|uint16_t
name|pktlen
parameter_list|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|first_bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|ndelim
decl_stmt|,
name|mindelim
init|=
literal|0
decl_stmt|;
name|int
name|mpdudensity
decl_stmt|;
comment|/* in 1/100'th of a microsecond */
name|uint8_t
name|rc
decl_stmt|,
name|rix
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|width
decl_stmt|,
name|half_gi
decl_stmt|;
name|uint32_t
name|nsymbits
decl_stmt|,
name|nsymbols
decl_stmt|;
name|uint16_t
name|minlen
decl_stmt|;
comment|/* 	 * vap->iv_ampdu_density is a value, rather than the actual 	 * density. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_ampdu_density
operator|>
name|IEEE80211_HTCAP_MPDUDENSITY_16
condition|)
name|mpdudensity
operator|=
literal|1600
expr_stmt|;
comment|/* maximum density */
else|else
name|mpdudensity
operator|=
name|ieee80211_mpdudensity_map
index|[
name|vap
operator|->
name|iv_ampdu_density
index|]
expr_stmt|;
comment|/* Select standard number of delimiters based on frame length */
name|ndelim
operator|=
name|ATH_AGGR_GET_NDELIM
argument_list|(
name|pktlen
argument_list|)
expr_stmt|;
comment|/* 	 * If encryption is enabled, add extra delimiters to let the 	 * crypto hardware catch up. This could be tuned per-MAC and 	 * per-rate, but for now we'll simply assume encryption is 	 * always enabled. 	 * 	 * Also note that the Atheros reference driver inserts two 	 * delimiters by default for pre-AR9380 peers.  This will 	 * include "that" required delimiter. 	 */
name|ndelim
operator|+=
name|ATH_AGGR_ENCRYPTDELIM
expr_stmt|;
comment|/* 	 * For AR9380, there's a minimum number of delimeters 	 * required when doing RTS. 	 * 	 * XXX TODO: this is only needed if (a) RTS/CTS is enabled, and 	 * XXX (b) this is the first sub-frame in the aggregate. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_use_ent
operator|&&
operator|(
name|sc
operator|->
name|sc_ent_cfg
operator|&
name|AH_ENT_RTSCTS_DELIM_WAR
operator|)
operator|&&
name|ndelim
operator|<
name|AH_FIRST_DESC_NDELIMS
condition|)
name|ndelim
operator|=
name|AH_FIRST_DESC_NDELIMS
expr_stmt|;
comment|/* 	 * If sc_delim_min_pad is non-zero, enforce it as the minimum 	 * pad delimiter count. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_delim_min_pad
operator|!=
literal|0
condition|)
name|ndelim
operator|=
name|MAX
argument_list|(
name|ndelim
argument_list|,
name|sc
operator|->
name|sc_delim_min_pad
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: pktlen=%d, ndelim=%d, mpdudensity=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pktlen
argument_list|,
name|ndelim
argument_list|,
name|mpdudensity
argument_list|)
expr_stmt|;
comment|/* 	 * If the MPDU density is 0, we can return here. 	 * Otherwise, we need to convert the desired mpdudensity 	 * into a byte length, based on the rate in the subframe. 	 */
if|if
condition|(
name|mpdudensity
operator|==
literal|0
condition|)
return|return
name|ndelim
return|;
comment|/* 	 * Convert desired mpdu density from microeconds to bytes based 	 * on highest rate in rate series (i.e. first rate) to determine 	 * required minimum length for subframe. Take into account 	 * whether high rate is 20 or 40Mhz and half or full GI. 	 */
name|rix
operator|=
name|first_bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
expr_stmt|;
name|rc
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
name|flags
operator|=
name|first_bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|flags
expr_stmt|;
name|width
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|ATH_RC_CW40_FLAG
operator|)
expr_stmt|;
name|half_gi
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|ATH_RC_SGI_FLAG
operator|)
expr_stmt|;
comment|/* 	 * mpdudensity is in 1/100th of a usec, so divide by 100 	 */
if|if
condition|(
name|half_gi
condition|)
name|nsymbols
operator|=
name|NUM_SYMBOLS_PER_USEC_HALFGI
argument_list|(
name|mpdudensity
argument_list|)
expr_stmt|;
else|else
name|nsymbols
operator|=
name|NUM_SYMBOLS_PER_USEC
argument_list|(
name|mpdudensity
argument_list|)
expr_stmt|;
name|nsymbols
operator|/=
literal|100
expr_stmt|;
if|if
condition|(
name|nsymbols
operator|==
literal|0
condition|)
name|nsymbols
operator|=
literal|1
expr_stmt|;
name|nsymbits
operator|=
name|bits_per_symbol
index|[
name|HT_RC_2_MCS
argument_list|(
name|rc
argument_list|)
index|]
index|[
name|width
index|]
expr_stmt|;
name|minlen
operator|=
operator|(
name|nsymbols
operator|*
name|nsymbits
operator|)
operator|/
name|BITS_PER_BYTE
expr_stmt|;
comment|/* 	 * Min length is the minimum frame length for the 	 * required MPDU density. 	 */
if|if
condition|(
name|pktlen
operator|<
name|minlen
condition|)
block|{
name|mindelim
operator|=
operator|(
name|minlen
operator|-
name|pktlen
operator|)
operator|/
name|ATH_AGGR_DELIM_SZ
expr_stmt|;
name|ndelim
operator|=
name|MAX
argument_list|(
name|mindelim
argument_list|,
name|ndelim
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: pktlen=%d, minlen=%d, rix=%x, rc=%x, width=%d, hgi=%d, ndelim=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pktlen
argument_list|,
name|minlen
argument_list|,
name|rix
argument_list|,
name|rc
argument_list|,
name|width
argument_list|,
name|half_gi
argument_list|,
name|ndelim
argument_list|)
expr_stmt|;
return|return
name|ndelim
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch the aggregation limit.  *  * It's the lowest of the four rate series 4ms frame length.  */
end_comment

begin_function
specifier|static
name|int
name|ath_get_aggr_limit
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|int
name|amin
init|=
name|ATH_AGGR_MAXSIZE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_aggr_limit
operator|>
literal|0
operator|&&
name|sc
operator|->
name|sc_aggr_limit
operator|<
name|ATH_AGGR_MAXSIZE
condition|)
name|amin
operator|=
name|sc
operator|->
name|sc_aggr_limit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATH_RC_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
name|i
index|]
operator|.
name|tries
operator|==
literal|0
condition|)
continue|continue;
name|amin
operator|=
name|MIN
argument_list|(
name|amin
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
name|i
index|]
operator|.
name|max4msframelen
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: max frame len= %d\n"
argument_list|,
name|__func__
argument_list|,
name|amin
argument_list|)
expr_stmt|;
return|return
name|amin
return|;
block|}
end_function

begin_comment
comment|/*  * Setup a 11n rate series structure  *  * This should be called for both legacy and MCS rates.  *  * This uses the rate series stuf from ath_tx_rate_fill_rcflags().  *  * It, along with ath_buf_set_rate, must be called -after- a burst  * or aggregate is setup.  */
end_comment

begin_function
specifier|static
name|void
name|ath_rateseries_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|HAL_11N_RATE_SERIES
modifier|*
name|series
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_BOOL
name|shortPreamble
init|=
name|AH_FALSE
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|struct
name|ath_rc_series
modifier|*
name|rc
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
decl_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
condition|)
name|shortPreamble
operator|=
name|AH_TRUE
expr_stmt|;
comment|/* 	 * If this is the first frame in an aggregate series, 	 * use the aggregate length. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|pktlen
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_al
expr_stmt|;
else|else
name|pktlen
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
expr_stmt|;
comment|/* 	 * XXX TODO: modify this routine to use the bfs_rc[x].flags 	 * XXX fields. 	 */
name|memset
argument_list|(
name|series
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|HAL_11N_RATE_SERIES
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATH_RC_NUM
condition|;
name|i
operator|++
control|)
block|{
comment|/* Only set flags for actual TX attempts */
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|tries
operator|==
literal|0
condition|)
continue|continue;
name|series
index|[
name|i
index|]
operator|.
name|Tries
operator|=
name|rc
index|[
name|i
index|]
operator|.
name|tries
expr_stmt|;
comment|/* 		 * XXX TODO: When the NIC is capable of three stream TX, 		 * transmit 1/2 stream rates on two streams. 		 * 		 * This reduces the power consumption of the NIC and 		 * keeps it within the PCIe slot power limits. 		 */
name|series
index|[
name|i
index|]
operator|.
name|ChSel
operator|=
name|sc
operator|->
name|sc_cur_txchainmask
expr_stmt|;
comment|/* 		 * Setup rate and TX power cap for this series. 		 */
name|series
index|[
name|i
index|]
operator|.
name|Rate
operator|=
name|rt
operator|->
name|info
index|[
name|rc
index|[
name|i
index|]
operator|.
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
name|series
index|[
name|i
index|]
operator|.
name|RateIndex
operator|=
name|rc
index|[
name|i
index|]
operator|.
name|rix
expr_stmt|;
name|series
index|[
name|i
index|]
operator|.
name|tx_power_cap
operator|=
name|rc
index|[
name|i
index|]
operator|.
name|tx_power_cap
expr_stmt|;
comment|/* 		 * Enable RTS/CTS as appropriate. 		 */
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_RTSCTS_FLAG
condition|)
name|series
index|[
name|i
index|]
operator|.
name|RateFlags
operator||=
name|HAL_RATESERIES_RTS_CTS
expr_stmt|;
comment|/* 		 * 11n rate? Update 11n flags. 		 */
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_HT_FLAG
condition|)
block|{
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_CW40_FLAG
condition|)
name|series
index|[
name|i
index|]
operator|.
name|RateFlags
operator||=
name|HAL_RATESERIES_2040
expr_stmt|;
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_SGI_FLAG
condition|)
name|series
index|[
name|i
index|]
operator|.
name|RateFlags
operator||=
name|HAL_RATESERIES_HALFGI
expr_stmt|;
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_STBC_FLAG
condition|)
name|series
index|[
name|i
index|]
operator|.
name|RateFlags
operator||=
name|HAL_RATESERIES_STBC
expr_stmt|;
block|}
comment|/* 		 * PktDuration doesn't include slot, ACK, RTS, etc timing - 		 * it's just the packet duration 		 */
if|if
condition|(
name|rc
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|ATH_RC_HT_FLAG
condition|)
block|{
name|series
index|[
name|i
index|]
operator|.
name|PktDuration
operator|=
name|ath_computedur_ht
argument_list|(
name|pktlen
argument_list|,
name|series
index|[
name|i
index|]
operator|.
name|Rate
argument_list|,
name|HT_RC_2_STREAMS
argument_list|(
name|series
index|[
name|i
index|]
operator|.
name|Rate
argument_list|)
argument_list|,
name|series
index|[
name|i
index|]
operator|.
name|RateFlags
operator|&
name|HAL_RATESERIES_2040
argument_list|,
name|series
index|[
name|i
index|]
operator|.
name|RateFlags
operator|&
name|HAL_RATESERIES_HALFGI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|shortPreamble
condition|)
name|series
index|[
name|i
index|]
operator|.
name|Rate
operator||=
name|rt
operator|->
name|info
index|[
name|rc
index|[
name|i
index|]
operator|.
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|series
index|[
name|i
index|]
operator|.
name|PktDuration
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rc
index|[
name|i
index|]
operator|.
name|rix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void ath_rateseries_print(struct ath_softc *sc, HAL_11N_RATE_SERIES *series) { 	int i; 	for (i = 0; i< ATH_RC_NUM; i++) { 		device_printf(sc->sc_dev ,"series %d: rate %x; tries %d; " 		    "pktDuration %d; chSel %d; txpowcap %d, rateFlags %x\n", 		    i, 		    series[i].Rate, 		    series[i].Tries, 		    series[i].PktDuration, 		    series[i].ChSel, 		    series[i].tx_power_cap, 		    series[i].RateFlags); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Setup the 11n rate scenario and burst duration for the given TX descriptor  * list.  *  * This isn't useful for sending beacon frames, which has different needs  * wrt what's passed into the rate scenario function.  */
end_comment

begin_function
name|void
name|ath_buf_set_rate
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|HAL_11N_RATE_SERIES
name|series
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|is_pspoll
init|=
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
operator|==
name|HAL_PKT_TYPE_PSPOLL
operator|)
decl_stmt|;
name|int
name|ctsrate
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
decl_stmt|;
name|int
name|flags
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
decl_stmt|;
comment|/* Setup rate scenario */
name|memset
argument_list|(
operator|&
name|series
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|series
argument_list|)
argument_list|)
expr_stmt|;
name|ath_rateseries_setup
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|series
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|ath_rateseries_print(sc, series);
endif|#
directive|endif
comment|/* Set rate scenario */
comment|/* 	 * Note: Don't allow hardware to override the duration on 	 * ps-poll packets. 	 */
name|ath_hal_set11nratescenario
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
operator|!
name|is_pspoll
argument_list|,
comment|/* whether to override the duration or not */
name|ctsrate
argument_list|,
comment|/* rts/cts rate */
name|series
argument_list|,
comment|/* 11n rate series */
literal|4
argument_list|,
comment|/* number of series */
name|flags
argument_list|)
expr_stmt|;
comment|/* Set burst duration */
comment|/* 	 * This is only required when doing 11n burst, not aggregation 	 * ie, if there's a second frame in a RIFS or A-MPDU burst 	 * w/>1 A-MPDU frame bursting back to back. 	 * Normal A-MPDU doesn't do bursting -between- aggregates. 	 * 	 * .. and it's highly likely this won't ever be implemented 	 */
comment|//ath_hal_set11nburstduration(ah, ds, 8192);
block|}
end_function

begin_comment
comment|/*  * Form an aggregate packet list.  *  * This function enforces the aggregate restrictions/requirements.  *  * These are:  *  * + The aggregate size maximum (64k for AR9160 and later, 8K for  *   AR5416 when doing RTS frame protection.)  * + Maximum number of sub-frames for an aggregate  * + The aggregate delimiter size, giving MACs time to do whatever is  *   needed before each frame  * + Enforce the BAW limit  *  * Each descriptor queued should have the DMA setup.  * The rate series, descriptor setup, linking, etc is all done  * externally. This routine simply chains them together.  * ath_tx_setds_11n() will take care of configuring the per-  * descriptor setup, and ath_buf_set_rate() will configure the  * rate control.  *  * The TID lock is required for the entirety of this function.  *  * If some code in another thread adds to the head of this  * list, very strange behaviour will occur. Since retransmission is the  * only reason this will occur, and this routine is designed to be called  * from within the scheduler task, it won't ever clash with the completion  * task.  *  * So if you want to call this from an upper layer context (eg, to direct-  * dispatch aggregate frames to the hardware), please keep this in mind.  */
end_comment

begin_function
name|ATH_AGGR_STATUS
name|ath_tx_form_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_q
parameter_list|)
block|{
comment|//struct ieee80211_node *ni =&an->an_node;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_first
init|=
name|NULL
decl_stmt|,
modifier|*
name|bf_prev
init|=
name|NULL
decl_stmt|;
name|int
name|nframes
init|=
literal|0
decl_stmt|;
name|uint16_t
name|aggr_limit
init|=
literal|0
decl_stmt|,
name|al
init|=
literal|0
decl_stmt|,
name|bpad
init|=
literal|0
decl_stmt|,
name|al_delta
decl_stmt|,
name|h_baw
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|status
init|=
name|ATH_AGGR_DONE
decl_stmt|;
name|int
name|prev_frames
init|=
literal|0
decl_stmt|;
comment|/* XXX for AR5416 burst, not done here */
name|int
name|prev_al
init|=
literal|0
decl_stmt|;
comment|/* XXX also for AR5416 burst */
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_ERROR
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|h_baw
operator|=
name|tap
operator|->
name|txa_wnd
operator|/
literal|2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bf
operator|=
name|ATH_TID_FIRST
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf_first
operator|==
name|NULL
condition|)
name|bf_first
operator|=
name|bf
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_DONE
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* 			 * It's the first frame; 			 * set the aggregation limit based on the 			 * rate control decision that has been made. 			 */
name|aggr_limit
operator|=
name|ath_get_aggr_limit
argument_list|(
name|sc
argument_list|,
name|bf_first
argument_list|)
expr_stmt|;
block|}
comment|/* Set this early just so things don't get confused */
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If the frame doesn't have a sequence number that we're 		 * tracking in the BAW (eg NULL QOS data frame), we can't 		 * aggregate it. Stop the aggregation process; the sender 		 * can then TX what's in the list thus far and then 		 * TX the frame individually. 		 */
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_NONAGGR
expr_stmt|;
break|break;
block|}
comment|/* 		 * If any of the rates are non-HT, this packet 		 * can't be aggregated. 		 * XXX TODO: add a bf_state flag which gets marked 		 * if any active rate is non-HT. 		 */
comment|/* 		 * do not exceed aggregation limit 		 */
name|al_delta
operator|=
name|ATH_AGGR_DELIM_SZ
operator|+
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
expr_stmt|;
if|if
condition|(
name|nframes
operator|&&
operator|(
name|aggr_limit
operator|<
operator|(
name|al
operator|+
name|bpad
operator|+
name|al_delta
operator|+
name|prev_al
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_LIMITED
expr_stmt|;
break|break;
block|}
comment|/* 		 * If RTS/CTS is set on the first frame, enforce 		 * the RTS aggregate limit. 		 */
if|if
condition|(
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
operator|(
name|HAL_TXDESC_CTSENA
operator||
name|HAL_TXDESC_RTSENA
operator|)
condition|)
block|{
if|if
condition|(
name|nframes
operator|&&
operator|(
name|sc
operator|->
name|sc_rts_aggr_limit
operator|<
operator|(
name|al
operator|+
name|bpad
operator|+
name|al_delta
operator|+
name|prev_al
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_8K_LIMITED
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Do not exceed subframe limit. 		 */
if|if
condition|(
operator|(
name|nframes
operator|+
name|prev_frames
operator|)
operator|>=
name|MIN
argument_list|(
operator|(
name|h_baw
operator|)
argument_list|,
name|IEEE80211_AMPDU_SUBFRAME_DEFAULT
argument_list|)
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_LIMITED
expr_stmt|;
break|break;
block|}
comment|/* 		 * If the current frame has an RTS/CTS configuration 		 * that differs from the first frame, override the 		 * subsequent frame with this config. 		 */
if|if
condition|(
name|bf
operator|!=
name|bf_first
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&=
operator|~
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
expr_stmt|;
block|}
comment|/* 		 * If the packet has a sequence number, do not 		 * step outside of the block-ack window. 		 */
if|if
condition|(
operator|!
name|BAW_WITHIN
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_BAW_CLOSED
expr_stmt|;
break|break;
block|}
comment|/* 		 * this packet is part of an aggregate. 		 */
name|ATH_TID_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* The TID lock is required for the BAW update */
name|ath_tx_addto_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
operator|=
literal|1
expr_stmt|;
comment|/* 		 * XXX enforce ACK for aggregate frames (this needs to be 		 * XXX handled more gracefully? 		 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
name|HAL_TXDESC_NOACK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: HAL_TXDESC_NOACK set for an aggregate frame?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&=
operator|(
operator|~
name|HAL_TXDESC_NOACK
operator|)
expr_stmt|;
block|}
comment|/* 		 * Add the now owned buffer (which isn't 		 * on the software TXQ any longer) to our 		 * aggregate frame list. 		 */
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|nframes
operator|++
expr_stmt|;
comment|/* Completion handler */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_aggr_comp
expr_stmt|;
comment|/* 		 * add padding for previous frame to aggregation length 		 */
name|al
operator|+=
name|bpad
operator|+
name|al_delta
expr_stmt|;
comment|/* 		 * Calculate delimiters needed for the current frame 		 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ndelim
operator|=
name|ath_compute_num_delims
argument_list|(
name|sc
argument_list|,
name|bf_first
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate the padding needed from this set of delimiters, 		 * used when calculating if the next frame will fit in 		 * the aggregate. 		 */
name|bpad
operator|=
name|PADBYTES
argument_list|(
name|al_delta
argument_list|)
operator|+
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ndelim
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* 		 * Chain the buffers together 		 */
if|if
condition|(
name|bf_prev
condition|)
name|bf_prev
operator|->
name|bf_next
operator|=
name|bf
expr_stmt|;
name|bf_prev
operator|=
name|bf
expr_stmt|;
comment|/* 		 * If we're leaking frames, just return at this point; 		 * we've queued a single frame and we don't want to add 		 * any more. 		 */
if|if
condition|(
name|tid
operator|->
name|an
operator|->
name|an_leak_count
condition|)
block|{
name|status
operator|=
name|ATH_AGGR_LEAK_CLOSED
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|/* 		 * terminate aggregation on a small packet boundary 		 */
block|if (bf->bf_state.bfs_pktlen< ATH_AGGR_MINPLEN) { 			status = ATH_AGGR_SHORTPKT; 			break; 		}
endif|#
directive|endif
block|}
name|finish
label|:
comment|/* 	 * Just in case the list was empty when we tried to 	 * dequeue a packet .. 	 */
if|if
condition|(
name|bf_first
condition|)
block|{
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_al
operator|=
name|al
expr_stmt|;
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|=
name|nframes
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

end_unit

