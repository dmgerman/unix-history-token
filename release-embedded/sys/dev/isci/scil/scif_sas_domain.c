begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This file is provided under a dual BSD/GPLv2 license.  When using or  * redistributing this file, you may do so under either license.  *  * GPL LICENSE SUMMARY  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.  * The full GNU General Public License is included in this distribution  * in the file called LICENSE.GPL.  *  * BSD LICENSE  *  * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in  *     the documentation and/or other materials provided with the  *     distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * @file  *  * @brief This file contains the implementation of the SCIF_SAS_DOMAIN  *        object.  */
end_comment

begin_include
include|#
directive|include
file|<dev/isci/scil/intel_sas.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_fast_list.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_port.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_io_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scic_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_user_callback.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_abstract_list.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_base_iterator.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_logger.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_domain.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/scif_sas_smp_remote_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/isci/scil/sci_util.h>
end_include

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R I V A T E   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method will attempt to handle an operation timeout (i.e.  *        discovery or reset).  *  * @param[in]  cookie This parameter specifies the domain in which the  *             timeout occurred.  *  * @return none  */
end_comment

begin_function
specifier|static
name|void
name|scif_sas_domain_operation_timeout_handler
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|cookie
decl_stmt|;
name|U32
name|state
decl_stmt|;
name|state
operator|=
name|sci_base_state_machine_get_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
expr_stmt|;
comment|// Based upon the state of the domain, we know whether we were in the
comment|// process of performing discovery or a reset.
if|if
condition|(
name|state
operator|==
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
condition|)
block|{
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"Domain:0x%x State:0x%x DISCOVER timeout!\n"
operator|,
name|fw_domain
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
name|fw_domain
operator|->
name|operation
operator|.
name|status
operator|=
name|SCI_FAILURE_TIMEOUT
expr_stmt|;
comment|//search all the smp devices in the domain and cancel their activities
comment|//if there is any outstanding activity remained. The smp devices will terminate
comment|//all the started internal IOs.
name|scif_sas_domain_cancel_smp_activities
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
name|scif_sas_domain_continue_discover
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCIF_LOG_ERROR
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"Domain:0x%x State:0x%x operation timeout in invalid state\n"
operator|,
name|fw_domain
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P U B L I C   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_function
name|SCI_PORT_HANDLE_T
name|scif_domain_get_scic_port_handle
parameter_list|(
name|SCI_DOMAIN_HANDLE_T
name|domain
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|domain
decl_stmt|;
if|if
condition|(
operator|(
name|fw_domain
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fw_domain
operator|->
name|core_object
operator|==
name|SCI_INVALID_HANDLE
operator|)
condition|)
return|return
name|SCI_INVALID_HANDLE
return|;
name|SCIF_LOG_WARNING
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"Domain:0x%x no associated core port found\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
return|return
name|fw_domain
operator|->
name|core_object
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_REMOTE_DEVICE_HANDLE_T
name|scif_domain_get_device_by_sas_address
parameter_list|(
name|SCI_DOMAIN_HANDLE_T
name|domain
parameter_list|,
name|SCI_SAS_ADDRESS_T
modifier|*
name|sas_address
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|domain
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
decl_stmt|;
name|SCI_SAS_ADDRESS_T
name|fw_device_address
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scif_domain_get_device_by_sas_address(0x%x, 0x%x) enter\n"
operator|,
name|domain
operator|,
name|sas_address
operator|)
argument_list|)
expr_stmt|;
comment|// Search the abstract list to see if there is a remote device with the
comment|// same SAS address.
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|fw_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|scic_remote_device_get_sas_address
argument_list|(
name|fw_device
operator|->
name|core_object
argument_list|,
operator|&
name|fw_device_address
argument_list|)
expr_stmt|;
comment|// Check to see if this is the device for which we are searching.
if|if
condition|(
operator|(
name|fw_device_address
operator|.
name|low
operator|==
name|sas_address
operator|->
name|low
operator|)
operator|&&
operator|(
name|fw_device_address
operator|.
name|high
operator|==
name|sas_address
operator|->
name|high
operator|)
condition|)
block|{
return|return
name|fw_device
return|;
block|}
name|element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_INVALID_HANDLE
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SCI_ITERATORS
argument_list|)
end_if

begin_function
name|SCI_ITERATOR_HANDLE_T
name|scif_domain_get_remote_device_iterator
parameter_list|(
name|SCI_DOMAIN_HANDLE_T
name|domain
parameter_list|,
name|void
modifier|*
name|iterator_buffer
parameter_list|)
block|{
name|SCI_ITERATOR_HANDLE_T
name|iterator
init|=
operator|(
name|SCI_ITERATOR_HANDLE_T
operator|*
operator|)
name|iterator_buffer
decl_stmt|;
name|sci_base_iterator_construct
argument_list|(
name|iterator
argument_list|,
operator|&
operator|(
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|domain
operator|)
operator|->
name|remote_device_list
argument_list|)
expr_stmt|;
return|return
name|iterator
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// !defined(DISABLE_SCI_ITERATORS)
end_comment

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|SCI_STATUS
name|scif_domain_discover
parameter_list|(
name|SCI_DOMAIN_HANDLE_T
name|domain
parameter_list|,
name|U32
name|discover_timeout
parameter_list|,
name|U32
name|device_timeout
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|domain
decl_stmt|;
name|SCI_STATUS
name|status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCI_STATUS
name|op_status
init|=
name|SCI_SUCCESS
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_domain_discover(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|domain
operator|,
name|discover_timeout
operator|,
name|device_timeout
operator|)
argument_list|)
expr_stmt|;
comment|// Check to make sure the size of the domain doesn't cause potential issues
comment|// with the remote device timer and the domain timer.
if|if
condition|(
operator|(
name|device_timeout
operator|*
name|sci_abstract_list_size
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
operator|)
operator|>
name|discover_timeout
condition|)
name|status
operator|=
name|SCI_WARNING_TIMER_CONFLICT
expr_stmt|;
name|op_status
operator|=
name|fw_domain
operator|->
name|state_handlers
operator|->
name|discover_handler
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
argument_list|,
name|discover_timeout
argument_list|,
name|device_timeout
argument_list|)
expr_stmt|;
comment|// The status of the discover operation takes priority.
if|if
condition|(
operator|(
name|status
operator|==
name|SCI_SUCCESS
operator|)
operator|||
operator|(
name|status
operator|!=
name|SCI_SUCCESS
operator|&&
name|op_status
operator|!=
name|SCI_SUCCESS
operator|)
condition|)
block|{
name|status
operator|=
name|op_status
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|U32
name|scif_domain_get_suggested_discover_timeout
parameter_list|(
name|SCI_DOMAIN_HANDLE_T
name|domain
parameter_list|)
block|{
name|U32
name|suggested_timeout
init|=
name|SCIF_DOMAIN_DISCOVER_TIMEOUT
decl_stmt|;
comment|//milli-seconds
return|return
name|suggested_timeout
return|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_stop_complete
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_STATUS
name|completion_status
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_stop_complete(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|completion_status
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_ready
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_ready(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
comment|// The controller supplied with the port should match the controller
comment|// saved in the domain.
name|ASSERT
argument_list|(
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
operator|==
name|fw_domain
operator|->
name|controller
argument_list|)
expr_stmt|;
name|fw_domain
operator|->
name|is_port_ready
operator|=
name|TRUE
expr_stmt|;
name|fw_domain
operator|->
name|state_handlers
operator|->
name|port_ready_handler
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_not_ready
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|U32
name|reason_code
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_not_ready(0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
comment|// The controller supplied with the port should match the controller
comment|// saved in the domain.
name|ASSERT
argument_list|(
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
operator|==
name|fw_domain
operator|->
name|controller
argument_list|)
expr_stmt|;
comment|// There is no need to take action on the port reconfiguring since it is
comment|// just a change of the port width.
if|if
condition|(
name|reason_code
operator|!=
name|SCIC_PORT_NOT_READY_RECONFIGURING
condition|)
block|{
name|fw_domain
operator|->
name|is_port_ready
operator|=
name|FALSE
expr_stmt|;
name|fw_domain
operator|->
name|state_handlers
operator|->
name|port_not_ready_handler
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
argument_list|,
name|reason_code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_hard_reset_complete
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_STATUS
name|completion_status
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
decl_stmt|;
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|fw_domain
operator|->
name|request_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_TASK_REQUEST_T
modifier|*
name|task_request
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_hard_reset_complete(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|completion_status
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|task_request
operator|=
operator|(
name|SCIF_SAS_TASK_REQUEST_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|scif_sas_task_request_get_function
argument_list|(
name|task_request
argument_list|)
operator|==
name|SCI_SAS_HARD_RESET
condition|)
block|{
name|fw_device
operator|=
name|task_request
operator|->
name|parent
operator|.
name|device
expr_stmt|;
if|if
condition|(
name|fw_device
operator|->
name|domain
operator|==
name|fw_domain
condition|)
block|{
name|scic_remote_device_reset_complete
argument_list|(
name|fw_device
operator|->
name|core_object
argument_list|)
expr_stmt|;
name|scif_cb_task_request_complete
argument_list|(
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
argument_list|,
name|fw_device
argument_list|,
name|task_request
argument_list|,
operator|(
name|SCI_TASK_STATUS
operator|)
name|completion_status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_bc_change_primitive_recieved
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_PHY_HANDLE_T
name|phy
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
operator|(
name|SCIF_SAS_CONTROLLER_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|controller
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scic_cb_port_bc_change_primitive_recieved(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_domain
operator|->
name|broadcast_change_count
operator|==
literal|0
condition|)
block|{
comment|// Enable the BCN detection only if the bcn_count is zero. If bcn_count is
comment|// not zero at this time, we won't enable BCN detection since all non-zero
comment|// BCN_count means same to us. Furthermore, we avoid BCN storm by not
comment|// always enabling the BCN_detection.
name|scic_port_enable_broadcast_change_notification
argument_list|(
name|fw_domain
operator|->
name|core_object
argument_list|)
expr_stmt|;
block|}
name|fw_domain
operator|->
name|broadcast_change_count
operator|++
expr_stmt|;
comment|//if there is smp device on this domain that is in the middle of discover
comment|//process or smp target reset, don't notify the driver layer.
if|if
condition|(
operator|!
name|scif_sas_domain_is_in_smp_activity
argument_list|(
name|fw_domain
argument_list|)
condition|)
comment|// Notify the user that there is, potentially, a change to the domain.
name|scif_cb_domain_change_notification
argument_list|(
name|fw_controller
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_bc_ses_primitive_recieved
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_PHY_HANDLE_T
name|phy
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_bc_ses_primitive_received(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_bc_expander_primitive_recieved
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_PHY_HANDLE_T
name|phy
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_bc_expander_primitive_received(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_bc_aen_primitive_recieved
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_PHY_HANDLE_T
name|phy
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_bc_aen_primitive_received(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_link_up
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_PHY_HANDLE_T
name|phy
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_link_up(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
name|scif_sas_domain_update_device_port_width
argument_list|(
name|fw_domain
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// ---------------------------------------------------------------------------
end_comment

begin_function
name|void
name|scic_cb_port_link_down
parameter_list|(
name|SCI_CONTROLLER_HANDLE_T
name|controller
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|,
name|SCI_PHY_HANDLE_T
name|phy
parameter_list|)
block|{
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
init|=
operator|(
name|SCIF_SAS_DOMAIN_T
operator|*
operator|)
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|sci_object_get_association
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scic_cb_port_link_down(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|controller
operator|,
name|port
operator|,
name|phy
operator|)
argument_list|)
expr_stmt|;
name|scif_sas_domain_update_device_port_width
argument_list|(
name|fw_domain
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|//* P R O T E C T E D   M E T H O D S
end_comment

begin_comment
comment|//******************************************************************************
end_comment

begin_comment
comment|/**  * @brief This method constructs the framework's SAS domain object.  During  *        the construction process a linkage to the corresponding core port  *        object.  *  * @param[in]  domain This parameter specifies the domain object to be  *             constructed.  * @param[in]  domain_id This parameter specifies the ID for the domain  *             object.  * @param[in]  fw_controller This parameter specifies the controller managing  *             the domain being constructed.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_domain_construct
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|U8
name|domain_id
parameter_list|,
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_sas_domain_construct(0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_domain
operator|,
name|domain_id
operator|,
name|fw_controller
operator|)
argument_list|)
expr_stmt|;
name|sci_base_domain_construct
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
argument_list|,
name|sci_base_object_get_logger
argument_list|(
name|fw_controller
argument_list|)
argument_list|,
name|scif_sas_domain_state_table
argument_list|)
expr_stmt|;
name|scif_sas_domain_initialize_state_logging
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
name|sci_abstract_list_construct
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|,
operator|&
name|fw_controller
operator|->
name|free_remote_device_pool
argument_list|)
expr_stmt|;
comment|// Retrieve the core's port object that directly corresponds to this
comment|// domain.
name|scic_controller_get_port_handle
argument_list|(
name|fw_controller
operator|->
name|core_object
argument_list|,
name|domain_id
argument_list|,
operator|&
name|fw_domain
operator|->
name|core_object
argument_list|)
expr_stmt|;
comment|// Set the association in the core port to this framework domain object.
name|sci_object_set_association
argument_list|(
operator|(
name|SCI_OBJECT_HANDLE_T
operator|)
name|fw_domain
operator|->
name|core_object
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
name|sci_fast_list_init
argument_list|(
operator|&
name|fw_domain
operator|->
name|request_list
argument_list|)
expr_stmt|;
name|fw_domain
operator|->
name|operation
operator|.
name|timer
operator|=
name|NULL
expr_stmt|;
name|fw_domain
operator|->
name|is_port_ready
operator|=
name|FALSE
expr_stmt|;
name|fw_domain
operator|->
name|device_start_count
operator|=
literal|0
expr_stmt|;
name|fw_domain
operator|->
name|controller
operator|=
name|fw_controller
expr_stmt|;
name|fw_domain
operator|->
name|operation
operator|.
name|status
operator|=
name|SCI_SUCCESS
expr_stmt|;
name|fw_domain
operator|->
name|is_config_route_table_needed
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method will terminate the requests outstanding in the core  *        based on the supplied criteria.  *        - if the all three parameters are specified then only the single  *          SCIF_SAS_REQUEST object is terminated.  *        - if only the SCIF_SAS_DOMAIN and SCIF_SAS_REMOTE_DEVICE are  *          specified, then all SCIF_SAS_REQUEST objects outstanding at  *          the device are terminated.  The one exclusion to this rule is  *          that the fw_requestor is not terminated.  *        - if only the SCIF_SAS_DOMAIN object is specified, then all  *          SCIF_SAS_REQUEST objects outstanding in the domain are  *          terminated.  *  * @param[in]  fw_domain This parameter specifies the domain in which to  *             terminate requests.  * @param[in]  fw_device This parameter specifies the remote device in  *             which to terminate requests.  This parameter can be NULL  *             as long as the fw_request parameter is NULL.  It is a  *             required parameter if the fw_request parameter is not NULL.  * @param[in]  fw_request This parameter specifies the request object to  *             be terminated.  This parameter can be NULL.  * @param[in]  fw_requestor This parameter specifies the task management  *             request that is responsible for the termination of requests.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_domain_terminate_requests
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|,
name|SCIF_SAS_REQUEST_T
modifier|*
name|fw_request
parameter_list|,
name|SCIF_SAS_TASK_REQUEST_T
modifier|*
name|fw_requestor
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_sas_domain_terminate_requests(0x%x, 0x%x, 0x%x, 0x%x) enter\n"
operator|,
name|fw_domain
operator|,
name|fw_device
operator|,
name|fw_request
operator|,
name|fw_requestor
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_request
operator|!=
name|NULL
condition|)
block|{
name|fw_request
operator|->
name|terminate_requestor
operator|=
name|fw_requestor
expr_stmt|;
name|fw_request
operator|->
name|state_handlers
operator|->
name|abort_handler
argument_list|(
operator|&
name|fw_request
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|fw_domain
operator|->
name|request_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_REQUEST_T
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
comment|// Cycle through the fast list of IO requests.  Terminate each
comment|// outstanding requests that matches the criteria supplied by the
comment|// caller.
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|request
operator|=
operator|(
name|SCIF_SAS_REQUEST_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|// The current element may be deleted from the list becasue of
comment|// IO completion so advance to the next element early
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|// Ensure we pass the supplied criteria before terminating the
comment|// request.
if|if
condition|(
operator|(
name|fw_device
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|request
operator|->
name|device
operator|==
name|fw_device
operator|)
operator|&&
operator|(
name|fw_requestor
operator|!=
operator|(
name|SCIF_SAS_TASK_REQUEST_T
operator|*
operator|)
name|request
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|request
operator|->
name|is_waiting_for_abort_task_set
operator|==
name|FALSE
operator|)
operator|||
operator|(
name|request
operator|->
name|terminate_requestor
operator|==
name|NULL
operator|)
condition|)
block|{
name|request
operator|->
name|terminate_requestor
operator|=
name|fw_requestor
expr_stmt|;
name|request
operator|->
name|state_handlers
operator|->
name|abort_handler
argument_list|(
operator|&
name|request
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method searches the domain object to find a  *        SCIF_SAS_REQUEST object associated with the supplied IO tag.  *  * @param[in]  fw_domain This parameter specifies the domain in which to  *             to find the request object.  * @param[in]  io_tag This parameter specifies the IO tag value for which  *             to locate the corresponding request.  *  * @return This method returns a pointer to the SCIF_SAS_REQUEST object  *         associated with the supplied IO tag.  * @retval NULL This value is returned if the IO tag does not resolve to  *         a request.  */
end_comment

begin_function
name|SCIF_SAS_REQUEST_T
modifier|*
name|scif_sas_domain_get_request_by_io_tag
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|U16
name|io_tag
parameter_list|)
block|{
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|fw_domain
operator|->
name|request_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_IO_REQUEST_T
modifier|*
name|io_request
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_TASK_MANAGEMENT
operator|,
literal|"scif_sas_domain_get_request_by_io_tag(0x%x, 0x%x) enter\n"
operator|,
name|fw_domain
operator|,
name|io_tag
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|io_request
operator|=
operator|(
name|SCIF_SAS_IO_REQUEST_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|// Check to see if we located the request with an identical IO tag.
if|if
condition|(
name|scic_io_request_get_io_tag
argument_list|(
name|io_request
operator|->
name|parent
operator|.
name|core_object
argument_list|)
operator|==
name|io_tag
condition|)
return|return
operator|&
name|io_request
operator|->
name|parent
return|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method performs domain object initialization to be done  *        when the scif_controller_initialize() method is invoked.  *        This includes operation timeout creation.  *  * @param[in]  fw_domain This parameter specifies the domain object for  *             which to perform initialization.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_domain_initialize
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_INITIALIZATION
operator|,
literal|"scif_sas_domain_initialize(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
comment|// Create the timer for each domain.  It is too early in the process
comment|// to allocate this during construction since the user didn't have
comment|// a chance to set it's association.
if|if
condition|(
name|fw_domain
operator|->
name|operation
operator|.
name|timer
operator|==
literal|0
condition|)
block|{
name|fw_domain
operator|->
name|operation
operator|.
name|timer
operator|=
name|scif_cb_timer_create
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|scif_sas_domain_operation_timeout_handler
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method performs domain object handling for core remote  *        device start complete notifications.  Core remote device starts  *        and start completes are only done during discovery.  This could  *        ultimately be wrapped into a handler method on the domain (they  *        actually already exist).  This method will decrement the number  *        of device start operations ongoing and attempt to determine if  *        discovery is complete.  *  * @param[in]  fw_domain This parameter specifies the domain object for  *             which to perform initialization.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_domain_remote_device_start_complete
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SMP_DISCOVER_RESPONSE_PROTOCOLS_T
name|dev_protocols
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_remote_device_start_complete(0x%x, 0x%x) enter\n"
operator|,
name|fw_domain
operator|,
name|fw_device
operator|)
argument_list|)
expr_stmt|;
comment|// If a device is being started/start completed, then we must be
comment|// during discovery.
name|ASSERT
argument_list|(
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
operator|.
name|current_state_id
operator|==
name|SCI_BASE_DOMAIN_STATE_DISCOVERING
argument_list|)
expr_stmt|;
name|scic_remote_device_get_protocols
argument_list|(
name|fw_device
operator|->
name|core_object
argument_list|,
operator|&
name|dev_protocols
argument_list|)
expr_stmt|;
comment|// Decrement the number of devices being started and check to see
comment|// if all have finished being started or failed as the case may be.
name|fw_domain
operator|->
name|device_start_in_progress_count
operator|--
expr_stmt|;
if|if
condition|(
name|dev_protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
condition|)
block|{
if|if
condition|(
name|fw_device
operator|->
name|containing_device
operator|==
name|NULL
condition|)
comment|//kick off the smp discover process if this expander is direct attached.
name|scif_sas_smp_remote_device_start_discover
argument_list|(
name|fw_device
argument_list|)
expr_stmt|;
else|else
comment|//mark this device, the discover process of this device will start after
comment|//its containing smp device finish discover.
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_DISCOVER
expr_stmt|;
block|}
else|else
block|{
name|fw_domain
operator|->
name|state_handlers
operator|->
name|device_start_complete_handler
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
argument_list|,
operator|&
name|fw_device
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This methods check each smp device in this domain. If there is at  *        least one smp device in discover or target reset activity, this  *        domain is considered in smp activity. Note this routine is not  *        called on fast IO path.  *  * @param[in] fw_domain The framework domain object  *  * @return BOOL value to indicate whether a domain is in SMP activity.  */
end_comment

begin_function
name|BOOL
name|scif_sas_domain_is_in_smp_activity
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
decl_stmt|;
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|SMP_DISCOVER_RESPONSE_PROTOCOLS_T
name|dev_protocols
decl_stmt|;
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|scic_remote_device_get_protocols
argument_list|(
name|current_device
operator|->
name|core_object
argument_list|,
operator|&
name|dev_protocols
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
operator|&&
name|scif_sas_smp_remote_device_is_in_activity
argument_list|(
name|current_device
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This methods finds a expander attached device by searching the domain's  *        device list using connected expander device and expander phy id.  *  * @param[in] fw_domain The framework domain object  * @param[in] parent_device The expander device the target device attaches to.  * @param[in] expander_phy_id The expander phy id that the target device owns.  *  * @return found remote device or a NULL value if no device found.  */
end_comment

begin_function
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|scif_sas_domain_get_device_by_containing_device
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|containing_device
parameter_list|,
name|U8
name|expander_phy_id
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
comment|//parent device must not be NULL.
name|ASSERT
argument_list|(
name|containing_device
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// Search the abstract list to see if there is a remote device meets the
comment|// search condition.
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|fw_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|// Check to see if this is the device for which we are searching.
if|if
condition|(
operator|(
name|fw_device
operator|->
name|containing_device
operator|==
name|containing_device
operator|)
operator|&&
operator|(
name|fw_device
operator|->
name|expander_phy_identifier
operator|==
name|expander_phy_id
operator|)
condition|)
block|{
return|return
name|fw_device
return|;
block|}
name|element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
block|}
return|return
name|SCI_INVALID_HANDLE
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This methods finds the first device that is in STOPPED state and its  *        connection_rate is still in SPINUP_HOLD(value 3).  *  * @param[in] fw_domain The framework domain object  *  * @return SCIF_SAS_REMOTE_DEVICE_T The device that is in SPINUP_HOLD or NULL.  */
end_comment

begin_function
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|scif_sas_domain_find_device_in_spinup_hold
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scif_sas_domain_find_device_in_spinup_hold(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
comment|//search throught domain's device list to find the first sata device on spinup_hold
name|current_element
operator|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
comment|//We must get the next element before we remove the current
comment|//device. Or else, we will get wrong next_element, since the erased
comment|//element has been put into free pool.
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
if|if
condition|(
name|sci_base_state_machine_get_state
argument_list|(
operator|&
name|current_device
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
operator|==
name|SCI_BASE_REMOTE_DEVICE_STATE_STOPPED
operator|&&
name|scic_remote_device_get_connection_rate
argument_list|(
name|current_device
operator|->
name|core_object
argument_list|)
operator|==
name|SCI_SATA_SPINUP_HOLD
condition|)
block|{
return|return
name|current_device
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This methods finds the first device that has specific activity scheduled.  *  * @param[in] fw_domain The framework domain object  * @param[in] smp_activity A specified smp activity. The valid range is [1,5].  *  * @return SCIF_SAS_REMOTE_DEVICE_T The device that has specified smp activity scheduled.  */
end_comment

begin_function
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|scif_sas_domain_find_device_has_scheduled_activity
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|U8
name|smp_activity
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
decl_stmt|;
name|SMP_DISCOVER_RESPONSE_PROTOCOLS_T
name|dev_protocols
decl_stmt|;
comment|//config route table activity has higher priority than discover activity.
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|scic_remote_device_get_protocols
argument_list|(
name|current_device
operator|->
name|core_object
argument_list|,
operator|&
name|dev_protocols
argument_list|)
expr_stmt|;
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
operator|&&
name|current_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|==
name|smp_activity
condition|)
block|{
return|return
name|current_device
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This methods finds the smp device that has is_config_route_table_scheduled  *        flag set to TRUE, and start config route table on it. If there is no  *        smp device scheduled to config route table, find the smp device has  *        is_discover_scheduled and start the smp discover process on them.  *  * @param[in] fw_domain The framework domain that to start smp discover process.  *  * @return NONE  */
end_comment

begin_function
name|void
name|scif_sas_domain_start_smp_activity
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|device_has_scheduled_activity
init|=
name|NULL
decl_stmt|;
comment|//first, find device that has config route table activity scheduled.
comment|//config route table activity has higher priority than Discover.
name|device_has_scheduled_activity
operator|=
name|scif_sas_domain_find_device_has_scheduled_activity
argument_list|(
name|fw_domain
argument_list|,
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CONFIG_ROUTE_TABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_has_scheduled_activity
operator|!=
name|NULL
condition|)
block|{
name|scif_sas_smp_remote_device_configure_route_table
argument_list|(
name|device_has_scheduled_activity
argument_list|)
expr_stmt|;
name|device_has_scheduled_activity
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_NONE
expr_stmt|;
return|return;
block|}
comment|//if no device has config route table activity scheduled, search again, find
comment|//device has discover activity scheduled.
name|device_has_scheduled_activity
operator|=
name|scif_sas_domain_find_device_has_scheduled_activity
argument_list|(
name|fw_domain
argument_list|,
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_DISCOVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_has_scheduled_activity
operator|!=
name|NULL
condition|)
name|scif_sas_smp_remote_device_start_discover
argument_list|(
name|device_has_scheduled_activity
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method starts domain's smp discover process from the top level expander.  *  * @param[in] fw_domain The framework domain that to start smp discover process.  @ @param[in] top_expander The top level expander device to start smp discover process.  *  * @return None  */
end_comment

begin_function
name|void
name|scif_sas_domain_start_smp_discover
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|top_expander
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
decl_stmt|;
comment|// something changed behind expander
comment|// mark all the device behind expander to be NOT
comment|// is_currently_discovered.
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|current_device
operator|->
name|is_currently_discovered
operator|=
name|FALSE
expr_stmt|;
comment|//reset all the devices' port witdh except the top expander.
if|if
condition|(
name|current_device
operator|->
name|containing_device
operator|!=
name|NULL
condition|)
name|current_device
operator|->
name|device_port_width
operator|=
literal|1
expr_stmt|;
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
block|}
comment|//expander device itself should be set to is_currently_discovered.
name|top_expander
operator|->
name|is_currently_discovered
operator|=
name|TRUE
expr_stmt|;
comment|//kick off the smp discover process.
name|scif_sas_smp_remote_device_start_discover
argument_list|(
name|top_expander
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method continues domain's smp discover process and  *        may transit to READY state if all smp activities are done.  *  * @param[in] fw_domain The framework domain that to start smp discover process.  *  * @return None  */
end_comment

begin_function
name|void
name|scif_sas_domain_continue_discover
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_continue_discover(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_domain
operator|->
name|device_start_in_progress_count
operator|==
literal|0
operator|&&
operator|!
name|scif_sas_domain_is_in_smp_activity
argument_list|(
name|fw_domain
argument_list|)
condition|)
block|{
comment|//domain scrub the remote device list to see if there is a need
comment|//to start smp discover on expander device. There may be no
comment|//need to start any smp discover.
name|scif_sas_domain_start_smp_activity
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
comment|//In domain discovery timeout case, we cancel all
comment|//the smp activities, and terminate all the smp requests, then
comment|//this routine is called. But the smp request may not done
comment|//terminated. We want to guard the domain trasitting to READY
comment|//by checking outstanding smp request count. If there is outstanding
comment|//smp request, the domain will not transit to READY. Later when
comment|//the smp request is terminated at smp remote device, this routine
comment|//will be called then the domain will transit to READY state.
if|if
condition|(
operator|!
name|scif_sas_domain_is_in_smp_activity
argument_list|(
name|fw_domain
argument_list|)
operator|&&
name|scif_sas_domain_get_smp_request_count
argument_list|(
name|fw_domain
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|//before domain transit to READY state, domain has some clean up
comment|//work to do, such like update domain's remote devcie list.
name|scif_sas_domain_finish_discover
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method finishes domain's smp discover process and  *        update domain's remote device list.  *  * @param[in] fw_domain The framework domain that's to finish smp discover process.  *  * @return None  */
end_comment

begin_function
name|void
name|scif_sas_domain_finish_discover
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
init|=
name|NULL
decl_stmt|;
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
init|=
name|NULL
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator||
name|SCIF_LOG_OBJECT_DOMAIN_DISCOVERY
operator|,
literal|"scif_sas_domain_finish_discover(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
comment|//need to scrub all the devices behind the expander. Check each
comment|//device's discover_status. if the is_currently_discovered is FALSE, means
comment|//the device is not been rediscovered. this device needs to be removed.
name|current_element
operator|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
comment|//We must get the next element before we remove the current
comment|//device. Or else, we will get wrong next_element, since the erased
comment|//element has been put into free pool.
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_device
operator|->
name|is_currently_discovered
operator|==
name|FALSE
condition|)
block|{
comment|// Notify the framework user of the device removal.
name|scif_cb_domain_device_removed
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|current_device
argument_list|)
expr_stmt|;
block|}
block|}
name|sci_base_state_machine_change_state
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
name|SCI_BASE_DOMAIN_STATE_READY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method remove an expander device and its child devices, in order to  *        deal with a detected illeagal phy connection.  *  * @param[in] fw_domain The domain that a expander belongs to.  * @param[in] fw_device The expander device to be removed.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_domain_remove_expander_device
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
parameter_list|)
block|{
name|SCIF_SAS_SMP_REMOTE_DEVICE_T
modifier|*
name|smp_remote_device
init|=
operator|&
name|fw_device
operator|->
name|protocol_device
operator|.
name|smp_device
decl_stmt|;
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|smp_remote_device
operator|->
name|smp_phy_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_SMP_PHY_T
modifier|*
name|curr_smp_phy
init|=
name|NULL
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|curr_smp_phy
operator|=
operator|(
name|SCIF_SAS_SMP_PHY_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_smp_phy
operator|->
name|attached_device_type
operator|!=
name|SMP_NO_DEVICE_ATTACHED
operator|&&
name|curr_smp_phy
operator|->
name|u
operator|.
name|end_device
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|curr_smp_phy
operator|->
name|attached_device_type
operator|==
name|SMP_END_DEVICE_ONLY
condition|)
name|current_device
operator|=
name|curr_smp_phy
operator|->
name|u
operator|.
name|end_device
expr_stmt|;
else|else
name|current_device
operator|=
name|curr_smp_phy
operator|->
name|u
operator|.
name|attached_phy
operator|->
name|owning_device
expr_stmt|;
name|scif_cb_domain_device_removed
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|current_device
argument_list|)
expr_stmt|;
block|}
block|}
comment|//remove device itself
name|scif_cb_domain_device_removed
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|,
name|fw_domain
argument_list|,
name|fw_device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method searches the whole domain and finds all the smp devices to  *        cancel their smp activities if there is any.  *  * @param[in] fw_domain The domain that its smp activities are to be canceled.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_domain_cancel_smp_activities
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
decl_stmt|;
comment|//purge all the outstanding internal IOs in HPQ.
name|scif_sas_high_priority_request_queue_purge_domain
argument_list|(
operator|&
name|fw_domain
operator|->
name|controller
operator|->
name|hprq
argument_list|,
name|fw_domain
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|SMP_DISCOVER_RESPONSE_PROTOCOLS_T
name|dev_protocols
decl_stmt|;
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|scic_remote_device_get_protocols
argument_list|(
name|current_device
operator|->
name|core_object
argument_list|,
operator|&
name|dev_protocols
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
condition|)
block|{
name|scif_sas_smp_remote_device_cancel_smp_activity
argument_list|(
name|current_device
argument_list|)
expr_stmt|;
block|}
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method searches the domain's request list and counts outstanding  *           smp IOs.  *  * @param[in] fw_domain The domain that its request list is to be searched.  *  * @return U8 The possible return value of this routine is 0 or 1.  */
end_comment

begin_function
name|U8
name|scif_sas_domain_get_smp_request_count
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCI_FAST_LIST_ELEMENT_T
modifier|*
name|element
init|=
name|fw_domain
operator|->
name|request_list
operator|.
name|list_head
decl_stmt|;
name|SCIF_SAS_REQUEST_T
modifier|*
name|request
init|=
name|NULL
decl_stmt|;
name|U8
name|count
init|=
literal|0
decl_stmt|;
name|SCIC_TRANSPORT_PROTOCOL
name|protocol
decl_stmt|;
comment|// Cycle through the fast list of IO requests.  Terminate each
comment|// outstanding requests that matches the criteria supplied by the
comment|// caller.
while|while
condition|(
name|element
operator|!=
name|NULL
condition|)
block|{
name|request
operator|=
operator|(
name|SCIF_SAS_REQUEST_T
operator|*
operator|)
name|sci_fast_list_get_object
argument_list|(
name|element
argument_list|)
expr_stmt|;
comment|// The current element may be deleted from the list becasue of
comment|// IO completion so advance to the next element early
name|element
operator|=
name|sci_fast_list_get_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|protocol
operator|=
name|scic_io_request_get_protocol
argument_list|(
name|request
operator|->
name|core_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|SCIC_SMP_PROTOCOL
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**  * @brief This method start clear affiliation activities for smp devices in  *           this domain.  *  * @param[in] fw_domain The domain that its smp devices are scheduled to clear  *                affiliation for all the EA SATA devices.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_domain_start_clear_affiliation
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|scif_sas_domain_schedule_clear_affiliation
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
name|scif_sas_domain_continue_clear_affiliation
argument_list|(
name|fw_domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @brief This method schedule clear affiliation activities for smp devices in  *           this domain.  *  * @param[in] fw_domain The domain that its smp devices are scheduled to clear  *                affiliation for all the EA SATA devices.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_domain_schedule_clear_affiliation
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
init|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
decl_stmt|;
name|SMP_DISCOVER_RESPONSE_PROTOCOLS_T
name|dev_protocols
decl_stmt|;
comment|//config route table activity has higher priority than discover activity.
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|scic_remote_device_get_protocols
argument_list|(
name|current_device
operator|->
name|core_object
argument_list|,
operator|&
name|dev_protocols
argument_list|)
expr_stmt|;
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_smp_target
condition|)
block|{
name|current_device
operator|->
name|protocol_device
operator|.
name|smp_device
operator|.
name|scheduled_activity
operator|=
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CLEAR_AFFILIATION
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method carries clear affiliation activities for a smp devices in  *           this domain during controller stop process.  *  * @param[in] fw_domain The domain that its smp devices are to clear  *                affiliation for all the EA SATA devices.  *  * @return none.  */
end_comment

begin_function
name|void
name|scif_sas_domain_continue_clear_affiliation
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|smp_device
init|=
name|scif_sas_domain_find_device_has_scheduled_activity
argument_list|(
name|fw_domain
argument_list|,
name|SCIF_SAS_SMP_REMOTE_DEVICE_ACTIVITY_CLEAR_AFFILIATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|smp_device
operator|!=
name|NULL
condition|)
name|scif_sas_smp_remote_device_start_clear_affiliation
argument_list|(
name|smp_device
argument_list|)
expr_stmt|;
else|else
block|{
comment|//This domain has done clear affiliation.
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
init|=
name|fw_domain
operator|->
name|controller
decl_stmt|;
name|fw_controller
operator|->
name|current_domain_to_clear_affiliation
operator|++
expr_stmt|;
comment|//let controller continue to clear affiliation on other domains.
name|scif_sas_controller_clear_affiliation
argument_list|(
name|fw_domain
operator|->
name|controller
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method releases resource for a framework domain.  *  * @param[in] fw_controller This parameter specifies the framework  *            controller, its associated domain's resources are to be released.  * @param[in] fw_domain This parameter specifies the framework  *            domain whose resources are to be released.  */
end_comment

begin_function
name|void
name|scif_sas_domain_release_resource
parameter_list|(
name|SCIF_SAS_CONTROLLER_T
modifier|*
name|fw_controller
parameter_list|,
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
if|if
condition|(
name|fw_domain
operator|->
name|operation
operator|.
name|timer
operator|!=
name|NULL
condition|)
block|{
name|scif_cb_timer_destroy
argument_list|(
name|fw_controller
argument_list|,
name|fw_domain
operator|->
name|operation
operator|.
name|timer
argument_list|)
expr_stmt|;
name|fw_domain
operator|->
name|operation
operator|.
name|timer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @brief This method finds the a EA device that has target reset scheduled.  *  * @param[in] fw_domain The framework domain object  *  * @return SCIF_SAS_REMOTE_DEVICE_T The EA device that has target reset scheduled.  */
end_comment

begin_function
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|scif_sas_domain_find_next_ea_target_reset
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|SCI_ABSTRACT_ELEMENT_T
modifier|*
name|current_element
decl_stmt|;
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|current_device
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scif_sas_domain_find_next_ea_target_reset(0x%x) enter\n"
operator|,
name|fw_domain
operator|)
argument_list|)
expr_stmt|;
comment|//search throught domain's device list to find the first sata device on spinup_hold
name|current_element
operator|=
name|sci_abstract_list_get_front
argument_list|(
operator|&
name|fw_domain
operator|->
name|remote_device_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_element
operator|!=
name|NULL
condition|)
block|{
name|current_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|sci_abstract_list_get_object
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
name|current_element
operator|=
name|sci_abstract_list_get_next
argument_list|(
name|current_element
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_device
operator|->
name|ea_target_reset_request_scheduled
operator|!=
name|NULL
condition|)
block|{
return|return
name|current_device
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_WIDE_PORTED_TARGETS
argument_list|)
end_if

begin_comment
comment|/**  * @brief This method update the direct attached device port width.  *  * @param[in] fw_domain The framework domain object  * @param[in] port The associated port object which recently has link up/down  *                 event happened.  *  * @return none  */
end_comment

begin_function
name|void
name|scif_sas_domain_update_device_port_width
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|,
name|SCI_PORT_HANDLE_T
name|port
parameter_list|)
block|{
name|SCIF_SAS_REMOTE_DEVICE_T
modifier|*
name|fw_device
decl_stmt|;
name|SCIC_PORT_PROPERTIES_T
name|properties
decl_stmt|;
name|U8
name|new_port_width
init|=
literal|0
decl_stmt|;
name|SCIF_LOG_TRACE
argument_list|(
operator|(
name|sci_base_object_get_logger
argument_list|(
name|fw_domain
argument_list|)
operator|,
name|SCIF_LOG_OBJECT_DOMAIN
operator|,
literal|"scif_sas_domain_update_device_port_width(0x%x, 0x%x) enter\n"
operator|,
name|fw_domain
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
name|scic_port_get_properties
argument_list|(
name|port
argument_list|,
operator|&
name|properties
argument_list|)
expr_stmt|;
name|fw_device
operator|=
operator|(
name|SCIF_SAS_REMOTE_DEVICE_T
operator|*
operator|)
name|scif_domain_get_device_by_sas_address
argument_list|(
name|fw_domain
argument_list|,
operator|&
name|properties
operator|.
name|remote
operator|.
name|sas_address
argument_list|)
expr_stmt|;
comment|// If the device already existed in the domain, it is a wide port SSP target,
comment|// we need to update its port width.
if|if
condition|(
name|fw_device
operator|!=
name|SCI_INVALID_HANDLE
condition|)
block|{
name|SMP_DISCOVER_RESPONSE_PROTOCOLS_T
name|dev_protocols
decl_stmt|;
name|scic_remote_device_get_protocols
argument_list|(
name|fw_device
operator|->
name|core_object
argument_list|,
operator|&
name|dev_protocols
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_protocols
operator|.
name|u
operator|.
name|bits
operator|.
name|attached_ssp_target
condition|)
block|{
comment|//Get accurate port width from port's phy mask for a DA device.
name|SCI_GET_BITS_SET_COUNT
argument_list|(
name|properties
operator|.
name|phy_mask
argument_list|,
name|new_port_width
argument_list|)
expr_stmt|;
name|scif_sas_remote_device_update_port_width
argument_list|(
name|fw_device
argument_list|,
name|new_port_width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//#if !defined(DISABLE_WIDE_PORTED_TARGETS)
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCI_LOGGING
end_ifdef

begin_comment
comment|/**  * This method will turn on logging of domain state changes.  *  * @param[in] fw_domain The domain for which the state logging is to be turned  *       on.  */
end_comment

begin_function
name|void
name|scif_sas_domain_initialize_state_logging
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|sci_base_state_machine_logger_initialize
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine_logger
argument_list|,
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|,
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|parent
argument_list|,
name|scif_cb_logger_log_states
argument_list|,
literal|"SCIF_SAS_DOMAIN_T"
argument_list|,
literal|"base state machine"
argument_list|,
name|SCIF_LOG_OBJECT_DOMAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * This method will turn off logging of domain state changes.  *  * @param[in] fw_domain The domain for which the state logging is to be turned  *       off.  */
end_comment

begin_function
name|void
name|scif_sas_domain_deinitialize_state_logging
parameter_list|(
name|SCIF_SAS_DOMAIN_T
modifier|*
name|fw_domain
parameter_list|)
block|{
name|sci_base_state_machine_logger_deinitialize
argument_list|(
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine_logger
argument_list|,
operator|&
name|fw_domain
operator|->
name|parent
operator|.
name|state_machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

