begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Chelsio Communications, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCPSTATES
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toecore.h>
end_include

begin_include
include|#
directive|include
file|"cxgb_include.h"
end_include

begin_include
include|#
directive|include
file|"ulp/tom/cxgb_tom.h"
end_include

begin_include
include|#
directive|include
file|"ulp/tom/cxgb_l2t.h"
end_include

begin_include
include|#
directive|include
file|"ulp/tom/cxgb_toepcb.h"
end_include

begin_function_decl
specifier|static
name|void
name|t3_send_reset_synqe
parameter_list|(
name|struct
name|toedev
modifier|*
parameter_list|,
name|struct
name|synq_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|alloc_stid
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|stid
init|=
operator|-
literal|1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sfree
condition|)
block|{
name|union
name|listen_entry
modifier|*
name|p
init|=
name|t
operator|->
name|sfree
decl_stmt|;
name|stid
operator|=
operator|(
name|p
operator|-
name|t
operator|->
name|stid_tab
operator|)
operator|+
name|t
operator|->
name|stid_base
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|stid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_stid
parameter_list|(
name|struct
name|tid_info
modifier|*
name|t
parameter_list|,
name|int
name|stid
parameter_list|)
block|{
name|union
name|listen_entry
modifier|*
name|p
init|=
name|stid2entry
argument_list|(
name|t
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|sfree
expr_stmt|;
name|t
operator|->
name|sfree
operator|=
name|p
expr_stmt|;
name|t
operator|->
name|stids_in_use
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t
operator|->
name|stid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|alloc_lctx
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|int
name|qset
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_ctx
argument_list|)
argument_list|,
name|M_CXGB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lctx
operator|->
name|stid
operator|=
name|alloc_stid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|stid
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|lctx
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|lctx
operator|->
name|inp
operator|=
name|inp
expr_stmt|;
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|qset
operator|=
name|qset
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|lctx
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Don't call this directly, use release_lctx instead */
end_comment

begin_function
specifier|static
name|int
name|free_lctx
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|refcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: refcnt %d"
operator|,
name|__func__
operator|,
name|lctx
operator|->
name|refcnt
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
argument_list|,
operator|(
literal|"%s: synq not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lctx
operator|->
name|stid
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: bad stid %d."
operator|,
name|__func__
operator|,
name|lctx
operator|->
name|stid
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, lctx %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|lctx
argument_list|,
name|lctx
operator|->
name|inp
argument_list|)
expr_stmt|;
name|free_stid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lctx
argument_list|,
name|M_CXGB
argument_list|)
expr_stmt|;
return|return
name|in_pcbrele_wlocked
argument_list|(
name|inp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hold_lctx
parameter_list|(
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|lctx
operator|->
name|refcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|listen_hashfn
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
return|return
operator|(
name|fnv_32_buf
argument_list|(
operator|&
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|,
name|FNV1_32_INIT
argument_list|)
operator|&
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a listen_ctx entry to the listen hash table.  */
end_comment

begin_function
specifier|static
name|void
name|listen_hash_add
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|lctx
operator|->
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|td
operator|->
name|listen_hash
index|[
name|bucket
index|]
argument_list|,
name|lctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|td
operator|->
name|lctx_count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for the listening socket's context entry in the hash and return it.  */
end_comment

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_find
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lctx
argument_list|,
argument|&td->listen_hash[bucket]
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|lctx
operator|->
name|inp
operator|==
name|inp
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes the listen_ctx structure for inp from the hash and returns it.  */
end_comment

begin_function
specifier|static
name|struct
name|listen_ctx
modifier|*
name|listen_hash_del
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|int
name|bucket
init|=
name|listen_hashfn
argument_list|(
name|inp
argument_list|,
name|td
operator|->
name|listen_mask
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lctx
argument_list|,
argument|&td->listen_hash[bucket]
argument_list|,
argument|link
argument_list|,
argument|l
argument_list|)
block|{
if|if
condition|(
name|lctx
operator|->
name|inp
operator|==
name|inp
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|td
operator|->
name|lctx_count
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|td
operator|->
name|lctx_hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lctx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Releases a hold on the lctx.  Must be called with the listening socket's inp  * locked.  The inp may be freed by this function and it returns NULL to  * indicate this.  */
end_comment

begin_function
specifier|static
name|struct
name|inpcb
modifier|*
name|release_lctx
parameter_list|(
name|struct
name|tom_data
modifier|*
name|td
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|int
name|inp_freed
init|=
literal|0
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|lctx
operator|->
name|refcnt
argument_list|)
condition|)
name|inp_freed
operator|=
name|free_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp_freed
condition|?
name|NULL
else|:
name|inp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_server
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_pass_open_req
modifier|*
name|req
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|lctx
operator|->
name|qset
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_OPEN_REQ
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|local_port
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|req
operator|->
name|local_ip
argument_list|,
operator|&
name|inp
operator|->
name|inp_laddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|req
operator|->
name|peer_port
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|peer_ip
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|peer_netmask
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|opt0h
operator|=
name|htonl
argument_list|(
name|F_DELACK
operator||
name|F_TCAM_BYPASS
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt0l
operator|=
name|htonl
argument_list|(
name|V_RCV_BUFSIZ
argument_list|(
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|opt1
operator|=
name|htonl
argument_list|(
name|V_CONN_POLICY
argument_list|(
name|CPL_CONN_POLICY_ASK
argument_list|)
argument_list|)
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|destroy_server
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|struct
name|listen_ctx
modifier|*
name|lctx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_close_listserv_req
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|lctx
operator|->
name|qset
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_CLOSE_LISTSRV_REQ
argument_list|,
name|lctx
operator|->
name|stid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|cpu_idx
operator|=
literal|0
expr_stmt|;
name|t3_offload_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_CLOSE_LISTSRV_RPL message.  If the status is good we release  * the STID.  */
end_comment

begin_function
specifier|static
name|int
name|do_close_server_rpl
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_close_listserv_rpl
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, status %u"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|rpl
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: failed (%u) to close listener for stid %u"
argument_list|,
name|__func__
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|stid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|listen_hash_del
argument_list|(
name|td
argument_list|,
name|lctx
operator|->
name|inp
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: inp %p still in listen hash"
operator|,
name|__func__
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_PASS_OPEN_RPL message.  Remove the lctx from the listen hash  * table and free it if there was any error, otherwise nothing to do.  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_open_rpl
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_pass_open_rpl
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|int
name|stid
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
comment|/* 	 * We get these replies also when setting up HW filters.  Just throw 	 * those away. 	 */
if|if
condition|(
name|stid
operator|>=
name|td
operator|->
name|tid_maps
operator|.
name|stid_base
operator|+
name|td
operator|->
name|tid_maps
operator|.
name|nstids
condition|)
goto|goto
name|done
goto|;
name|lctx
operator|=
name|lookup_stid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|stid
argument_list|)
expr_stmt|;
name|inp
operator|=
name|lctx
operator|->
name|inp
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, status %u, flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|rpl
operator|->
name|status
argument_list|,
name|lctx
operator|->
name|flags
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|flags
operator|&=
operator|~
name|LCTX_RPL_PENDING
expr_stmt|;
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s: hw listen (stid %d) failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|stid
argument_list|,
name|rpl
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * If the inp has been dropped (listening socket closed) then 	 * listen_stop must have run and taken the inp out of the hash. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|KASSERT
argument_list|(
name|listen_hash_del
argument_list|(
name|td
argument_list|,
name|inp
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: inp %p still in listen hash"
operator|,
name|__func__
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|&&
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
if|if
condition|(
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Listening socket stopped listening earlier and now the chip tells us 	 * it has started the hardware listener.  Stop it; the lctx will be 	 * released in do_close_server_rpl. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
condition|)
block|{
name|destroy_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Failed to start hardware listener.  Take inp out of the hash and 	 * release our reference on it.  An error message has been logged 	 * already. 	 */
if|if
condition|(
name|rpl
operator|->
name|status
operator|!=
name|CPL_ERR_NONE
condition|)
block|{
name|listen_hash_del
argument_list|(
name|td
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
operator|!=
name|NULL
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* hardware listener open for business */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|done
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pass_accept_req_to_protohdrs
parameter_list|(
specifier|const
name|struct
name|cpl_pass_accept_req
modifier|*
name|cpl
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|)
block|{
specifier|const
name|struct
name|tcp_options
modifier|*
name|t3opt
init|=
operator|&
name|cpl
operator|->
name|tcp_options
decl_stmt|;
name|bzero
argument_list|(
name|inc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|->
name|inc_faddr
operator|.
name|s_addr
operator|=
name|cpl
operator|->
name|peer_ip
expr_stmt|;
name|inc
operator|->
name|inc_laddr
operator|.
name|s_addr
operator|=
name|cpl
operator|->
name|local_ip
expr_stmt|;
name|inc
operator|->
name|inc_fport
operator|=
name|cpl
operator|->
name|peer_port
expr_stmt|;
name|inc
operator|->
name|inc_lport
operator|=
name|cpl
operator|->
name|local_port
expr_stmt|;
name|bzero
argument_list|(
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sport
operator|=
name|cpl
operator|->
name|peer_port
expr_stmt|;
name|th
operator|->
name|th_dport
operator|=
name|cpl
operator|->
name|local_port
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|rcv_isn
argument_list|)
expr_stmt|;
comment|/* as in tcp_fields_to_host */
name|th
operator|->
name|th_flags
operator|=
name|TH_SYN
expr_stmt|;
name|bzero
argument_list|(
name|to
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3opt
operator|->
name|mss
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_MSS
expr_stmt|;
name|to
operator|->
name|to_mss
operator|=
name|be16toh
argument_list|(
name|t3opt
operator|->
name|mss
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t3opt
operator|->
name|wsf
condition|)
block|{
name|to
operator|->
name|to_flags
operator||=
name|TOF_SCALE
expr_stmt|;
name|to
operator|->
name|to_wscale
operator|=
name|t3opt
operator|->
name|wsf
expr_stmt|;
block|}
if|if
condition|(
name|t3opt
operator|->
name|tstamp
condition|)
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
if|if
condition|(
name|t3opt
operator|->
name|sack
condition|)
name|to
operator|->
name|to_flags
operator||=
name|TOF_SACKPERM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|hold_synqe
parameter_list|(
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|release_synqe
parameter_list|(
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|)
condition|)
name|m_freem
argument_list|(
name|synqe
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use the trailing space in the mbuf in which the PASS_ACCEPT_REQ arrived to  * store some state temporarily.  There will be enough room in the mbuf's  * trailing space as the CPL is not that large.  *  * XXX: bad hack.  */
end_comment

begin_function
specifier|static
name|struct
name|synq_entry
modifier|*
name|mbuf_to_synq_entry
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|len
init|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|synq_entry
argument_list|)
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|len
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"%s: no room for synq_entry (%td, %d)\n"
argument_list|,
name|__func__
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|buf
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|buf
operator|=
operator|&
name|m
operator|->
name|m_pktdat
index|[
literal|0
index|]
expr_stmt|;
name|buflen
operator|=
name|MHLEN
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|&
name|m
operator|->
name|m_dat
index|[
literal|0
index|]
expr_stmt|;
name|buflen
operator|=
name|MLEN
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|buflen
operator|-
name|len
operator|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_define
define|#
directive|define
name|REJECT_PASS_ACCEPT
parameter_list|()
value|do { \ 	reject_reason = __LINE__; \ 	goto reject; \ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REJECT_PASS_ACCEPT
parameter_list|()
value|do { goto reject; } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The context associated with a tid entry via insert_tid could be a synq_entry  * or a toepcb.  The only way CPL handlers can tell is via a bit in these flags.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|toepcb
argument_list|,
name|tp_flags
argument_list|)
operator|==
name|offsetof
argument_list|(
expr|struct
name|synq_entry
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Handle a CPL_PASS_ACCEPT_REQ message.  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_accept_req
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|td
operator|->
name|tod
decl_stmt|;
specifier|const
name|struct
name|cpl_pass_accept_req
modifier|*
name|req
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|req
operator|->
name|tos_tid
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|lookup_stid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|stid
argument_list|)
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in
name|nam
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|int
name|reject_reason
decl_stmt|;
endif|#
directive|endif
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|pass_accept_req_to_protohdrs
argument_list|(
name|req
argument_list|,
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
comment|/* 	 * Don't offload if the interface that received the SYN doesn't have 	 * IFCAP_TOE enabled. 	 */
name|pi
operator|=
name|NULL
expr_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|hw_addr
argument_list|,
name|req
operator|->
name|dst_mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
continue|continue;
name|pi
operator|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
name|ifp
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE4
operator|)
operator|==
literal|0
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* 	 * Don't offload if the outgoing interface for the route back to the 	 * peer is not the same as the interface that received the SYN. 	 */
name|bzero
argument_list|(
operator|&
name|nam
argument_list|,
sizeof|sizeof
argument_list|(
name|nam
argument_list|)
argument_list|)
expr_stmt|;
name|nam
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|nam
argument_list|)
expr_stmt|;
name|nam
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|nam
operator|.
name|sin_addr
operator|=
name|inc
operator|.
name|inc_faddr
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nam
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
else|else
block|{
name|struct
name|sockaddr
modifier|*
name|nexthop
decl_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|nexthop
operator|=
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|?
name|rt
operator|->
name|rt_gateway
else|:
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|nam
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|==
name|ifp
condition|)
name|e
operator|=
name|t3_l2t_get
argument_list|(
name|pi
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|,
name|nexthop
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
comment|/* no l2te, or ifp mismatch */
block|}
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* Don't offload if the 4-tuple is already in use */
if|if
condition|(
name|toe_4tuple_check
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|,
name|ifp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|inp
operator|=
name|lctx
operator|->
name|inp
expr_stmt|;
comment|/* listening socket (not owned by the TOE) */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* 		 * The listening socket has closed.  The reply from the TOE to 		 * our CPL_CLOSE_LISTSRV_REQ will ultimately release all 		 * resources tied to this listen context. 		 */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
comment|/* Reuse the mbuf that delivered the CPL to us */
name|synqe
operator|=
name|mbuf_to_synq_entry
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|flags
operator|=
name|TP_IS_A_SYNQ_ENTRY
expr_stmt|;
name|synqe
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|synqe
operator|->
name|lctx
operator|=
name|lctx
expr_stmt|;
name|synqe
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|synqe
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|synqe
operator|->
name|opt0h
operator|=
name|calc_opt0h
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|qset
operator|=
name|pi
operator|->
name|first_qset
operator|+
operator|(
name|arc4random
argument_list|()
operator|%
name|pi
operator|->
name|nqsets
operator|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|rx_credits
operator|=
name|min
argument_list|(
name|select_rcv_wnd
argument_list|(
name|so
argument_list|)
operator|>>
literal|10
argument_list|,
name|M_RCV_BUFSIZ
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|synqe
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|synqe
operator|->
name|reply
argument_list|,
name|RPL_OK
argument_list|)
expr_stmt|;
name|insert_tid
argument_list|(
name|td
argument_list|,
name|synqe
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|hold_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
name|hold_lctx
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
comment|/* syncache_add releases both pcbinfo and pcb locks */
name|toe_syncache_add
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
name|inp
argument_list|,
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_UNLOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* 	 * If we replied during syncache_add (reply is RPL_DONE), good. 	 * Otherwise (reply is unchanged - RPL_OK) it's no longer ok to reply. 	 * The mbuf will stick around as long as the entry is in the syncache. 	 * The kernel is free to retry syncache_respond but we'll ignore it due 	 * to RPL_DONT. 	 */
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|synqe
operator|->
name|reply
argument_list|,
name|RPL_OK
argument_list|,
name|RPL_DONT
argument_list|)
condition|)
block|{
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* listener closed.  synqe must have been aborted. */
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: listener %p closed but synqe %p not aborted"
operator|,
name|__func__
operator|,
name|inp
operator|,
name|synqe
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p, synqe %p, ABORTED"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
return|return
operator|(
name|__LINE__
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|!
operator|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_SHUTDOWN
operator|)
argument_list|,
operator|(
literal|"%s: synqe %p aborted, but listener %p not dropped."
operator|,
name|__func__
operator|,
name|synqe
operator|,
name|inp
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* removed from synq list */
name|inp
operator|=
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
comment|/* about to exit function */
name|REJECT_PASS_ACCEPT
argument_list|()
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|synqe
operator|->
name|reply
operator|==
name|RPL_DONE
argument_list|,
operator|(
literal|"%s: reply %d"
operator|,
name|__func__
operator|,
name|synqe
operator|->
name|reply
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, tid %u, OK"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|reject
label|:
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, tid %u, REJECT (%d)"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|reject_reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|==
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|l2t_release
argument_list|(
name|td
operator|->
name|l2t
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|queue_tid_release
argument_list|(
name|tod
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pass_establish_to_protohdrs
parameter_list|(
specifier|const
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|)
block|{
name|uint16_t
name|tcp_opt
init|=
name|be16toh
argument_list|(
name|cpl
operator|->
name|tcp_opt
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|inc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inc
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|->
name|inc_faddr
operator|.
name|s_addr
operator|=
name|cpl
operator|->
name|peer_ip
expr_stmt|;
name|inc
operator|->
name|inc_laddr
operator|.
name|s_addr
operator|=
name|cpl
operator|->
name|local_ip
expr_stmt|;
name|inc
operator|->
name|inc_fport
operator|=
name|cpl
operator|->
name|peer_port
expr_stmt|;
name|inc
operator|->
name|inc_lport
operator|=
name|cpl
operator|->
name|local_port
expr_stmt|;
name|bzero
argument_list|(
name|th
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_sport
operator|=
name|cpl
operator|->
name|peer_port
expr_stmt|;
name|th
operator|->
name|th_dport
operator|=
name|cpl
operator|->
name|local_port
expr_stmt|;
name|th
operator|->
name|th_flags
operator|=
name|TH_ACK
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|rcv_isn
argument_list|)
expr_stmt|;
comment|/* as in tcp_fields_to_host */
name|th
operator|->
name|th_ack
operator|=
name|be32toh
argument_list|(
name|cpl
operator|->
name|snd_isn
argument_list|)
expr_stmt|;
comment|/* ditto */
name|bzero
argument_list|(
name|to
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_TCPOPT_TSTAMP
argument_list|(
name|tcp_opt
argument_list|)
condition|)
name|to
operator|->
name|to_flags
operator||=
name|TOF_TS
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a CPL_PASS_ESTABLISH message.  The T3 has already established a  * connection and we need to do the software side setup.  */
end_comment

begin_function
specifier|static
name|int
name|do_pass_establish
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|td
operator|->
name|tod
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|cpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|struct
name|tcphdr
name|th
decl_stmt|;
name|struct
name|in_conninfo
name|inc
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|int
name|stid
init|=
name|G_PASS_OPEN_TID
argument_list|(
name|ntohl
argument_list|(
name|cpl
operator|->
name|tos_tid
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|CTR5
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, tid %u, lctx %p, inp_flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|stid
argument_list|,
name|tid
argument_list|,
name|lctx
argument_list|,
name|inp
operator|->
name|inp_flags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|qs
operator|->
name|idx
operator|==
name|synqe
operator|->
name|qset
argument_list|,
operator|(
literal|"%s qset mismatch %d %d"
operator|,
name|__func__
operator|,
name|qs
operator|->
name|idx
operator|,
name|synqe
operator|->
name|qset
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* for syncache_expand */
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
argument_list|)
condition|)
block|{
comment|/* 		 * The listening socket has closed.  The TOM must have aborted 		 * all the embryonic connections (including this one) that were 		 * on the lctx's synq.  do_abort_rpl for the tid is responsible 		 * for cleaning up. 		 */
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_SHUTDOWN
argument_list|,
operator|(
literal|"%s: listen socket dropped but tid %u not aborted."
operator|,
name|__func__
operator|,
name|tid
operator|)
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pass_establish_to_protohdrs
argument_list|(
name|cpl
argument_list|,
operator|&
name|inc
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|to
argument_list|)
expr_stmt|;
comment|/* Lie in order to pass the checks in syncache_expand */
name|to
operator|.
name|to_tsecr
operator|=
name|synqe
operator|->
name|ts
expr_stmt|;
name|th
operator|.
name|th_ack
operator|=
name|synqe
operator|->
name|iss
operator|+
literal|1
expr_stmt|;
name|toep
operator|=
name|toepcb_alloc
argument_list|(
name|tod
argument_list|)
expr_stmt|;
if|if
condition|(
name|toep
operator|==
name|NULL
condition|)
block|{
name|reset
label|:
name|t3_send_reset_synqe
argument_list|(
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|toep
operator|->
name|tp_qset
operator|=
name|qs
operator|->
name|idx
expr_stmt|;
name|toep
operator|->
name|tp_l2t
operator|=
name|synqe
operator|->
name|e
expr_stmt|;
name|toep
operator|->
name|tp_tid
operator|=
name|tid
expr_stmt|;
name|toep
operator|->
name|tp_rx_credits
operator|=
name|synqe
operator|->
name|rx_credits
expr_stmt|;
name|synqe
operator|->
name|toep
operator|=
name|toep
expr_stmt|;
name|synqe
operator|->
name|cpl
operator|=
name|cpl
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
if|if
condition|(
operator|!
name|toe_syncache_expand
argument_list|(
operator|&
name|inc
argument_list|,
operator|&
name|to
argument_list|,
operator|&
name|th
argument_list|,
operator|&
name|so
argument_list|)
operator|||
name|so
operator|==
name|NULL
condition|)
block|{
name|toepcb_free
argument_list|(
name|toep
argument_list|)
expr_stmt|;
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|synqe
operator|->
name|flags
operator|&
name|TP_SYNQE_EXPANDED
operator|)
argument_list|)
condition|)
block|{
name|struct
name|inpcb
modifier|*
name|new_inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|intotcpcb
argument_list|(
name|new_inp
argument_list|)
argument_list|,
name|TT_KEEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_offload_socket
argument_list|(
name|tod
argument_list|,
name|synqe
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the synq entry and release its reference on the lctx */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_init_listen_cpl_handlers
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_PASS_OPEN_RPL
argument_list|,
name|do_pass_open_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_CLOSE_LISTSRV_RPL
argument_list|,
name|do_close_server_rpl
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_PASS_ACCEPT_REQ
argument_list|,
name|do_pass_accept_req
argument_list|)
expr_stmt|;
name|t3_register_cpl_handler
argument_list|(
name|sc
argument_list|,
name|CPL_PASS_ESTABLISH
argument_list|,
name|do_pass_establish
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a listening server by sending a passive open request to HW.  *  * Can't take adapter lock here and access to sc->flags, sc->open_device_map,  * sc->offload_map, if_capenable are all race prone.  */
end_comment

begin_function
name|int
name|t3_listen_start
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV4
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|notyet
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: listen request ignored, %s is busy"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
argument_list|,
operator|(
literal|"%s: TOM not initialized"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|open_device_map
operator|&
name|sc
operator|->
name|offload_map
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* no port that's UP with IFCAP_TOE enabled */
comment|/* 	 * Find a running port with IFCAP_TOE4.  We'll use the first such port's 	 * queues to send the passive open and receive the reply to it. 	 * 	 * XXX: need a way to mark an port in use by offload.  if_cxgbe should 	 * then reject any attempt to bring down such a port (and maybe reject 	 * attempts to disable IFCAP_TOE on that port too?). 	 */
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|i
argument_list|)
operator|&&
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TOE4
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
literal|"%s: no running port with TOE capability enabled."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|pi
operator|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|listen_hash_find
argument_list|(
name|td
argument_list|,
name|inp
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* already setup */
name|lctx
operator|=
name|alloc_lctx
argument_list|(
name|td
argument_list|,
name|inp
argument_list|,
name|pi
operator|->
name|first_qset
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: listen request ignored, %s couldn't allocate lctx\n"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|listen_hash_add
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u (%s), lctx %p, inp %p"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|tcpstates
index|[
name|tp
operator|->
name|t_state
index|]
argument_list|,
name|lctx
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|create_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s failed to create hw listener.\n"
argument_list|,
name|__func__
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|listen_hash_del
argument_list|(
name|td
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
comment|/* can't be freed, host stack has a reference */
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inp freed"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|lctx
operator|->
name|flags
operator||=
name|LCTX_RPL_PENDING
expr_stmt|;
name|done
label|:
ifdef|#
directive|ifdef
name|notyet
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a listening server by sending a close_listsvr request to HW.  * The server TID is freed when we get the reply.  */
end_comment

begin_function
name|int
name|t3_listen_stop
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|listen_ctx
modifier|*
name|lctx
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|t3_tomdata
argument_list|(
name|tod
argument_list|)
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|tp
operator|->
name|t_inpcb
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|listen_hash_del
argument_list|(
name|td
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* no hardware listener for this inp */
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: stid %u, lctx %p, flags %x"
argument_list|,
name|__func__
argument_list|,
name|lctx
operator|->
name|stid
argument_list|,
name|lctx
argument_list|,
name|lctx
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * If the reply to the PASS_OPEN is still pending we'll wait for it to 	 * arrive and clean up when it does. 	 */
if|if
condition|(
name|lctx
operator|->
name|flags
operator|&
name|LCTX_RPL_PENDING
condition|)
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|)
argument_list|,
operator|(
literal|"%s: synq not empty."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
block|}
comment|/* 	 * The host stack will abort all the connections on the listening 	 * socket's so_comp.  It doesn't know about the connections on the synq 	 * so we need to take care of those. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|synqe
argument_list|,
argument|&lctx->synq
argument_list|,
argument|link
argument_list|)
block|{
name|KASSERT
argument_list|(
name|synqe
operator|->
name|lctx
operator|==
name|lctx
argument_list|,
operator|(
literal|"%s: synq corrupt"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|t3_send_reset_synqe
argument_list|(
name|tod
argument_list|,
name|synqe
argument_list|)
expr_stmt|;
block|}
name|destroy_server
argument_list|(
name|sc
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_syncache_added
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|hold_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_syncache_removed
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
name|__unused
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX */
end_comment

begin_function_decl
specifier|extern
name|void
name|tcp_dooptions
parameter_list|(
name|struct
name|tcpopt
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|t3_syncache_respond
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
name|synqe
operator|->
name|e
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|cpl_pass_accept_rpl
modifier|*
name|rpl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|r
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|tcpopt
name|to
decl_stmt|;
name|int
name|mtu_idx
decl_stmt|,
name|cpu_idx
decl_stmt|;
comment|/* 	 * The first time we run it's during the call to syncache_add.  That's 	 * the only one we care about. 	 */
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|synqe
operator|->
name|reply
argument_list|,
name|RPL_OK
argument_list|,
name|RPL_DONE
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* reply to the CPL only if it's ok to do so */
name|r
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|lctx
operator|->
name|qset
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|,
name|rpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Use only the provided mbuf (with ip and tcp headers) and what's in 	 * synqe.  Avoid looking at the listening socket (lctx->inp) here. 	 * 	 * XXX: if the incoming SYN had the TCP timestamp option but the kernel 	 * decides it doesn't want to use TCP timestamps we have no way of 	 * relaying this info to the chip on a per-tid basis (all we have is a 	 * global knob). 	 */
name|bzero
argument_list|(
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_dooptions
argument_list|(
operator|&
name|to
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|,
name|TO_SYN
argument_list|)
expr_stmt|;
comment|/* stash them for later */
name|synqe
operator|->
name|iss
operator|=
name|be32toh
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|ts
operator|=
name|to
operator|.
name|to_tsval
expr_stmt|;
name|mtu_idx
operator|=
name|find_best_mtu_idx
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|to
operator|.
name|to_mss
argument_list|)
expr_stmt|;
name|cpu_idx
operator|=
name|sc
operator|->
name|rrss_map
index|[
name|synqe
operator|->
name|qset
index|]
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
literal|0
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|rpl
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_ACCEPT_RPL
argument_list|,
name|synqe
operator|->
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt2
operator|=
name|calc_opt2
argument_list|(
name|cpu_idx
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|rsvd
operator|=
name|rpl
operator|->
name|opt2
expr_stmt|;
comment|/* workaround for HW bug */
name|rpl
operator|->
name|peer_ip
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|rpl
operator|->
name|opt0h
operator|=
name|synqe
operator|->
name|opt0h
operator||
name|calc_opt0h
argument_list|(
name|NULL
argument_list|,
name|mtu_idx
argument_list|,
name|to
operator|.
name|to_wscale
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rpl
operator|->
name|opt0l_status
operator|=
name|htobe32
argument_list|(
name|CPL_PASS_OPEN_ACCEPT
argument_list|)
operator||
name|calc_opt0l
argument_list|(
name|NULL
argument_list|,
name|synqe
operator|->
name|rx_credits
argument_list|)
expr_stmt|;
name|l2t_send
argument_list|(
name|sc
argument_list|,
name|r
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|done
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|do_abort_req_synqe
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|td
operator|->
name|tod
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_req_rss
modifier|*
name|req
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|req
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|KASSERT
argument_list|(
name|synqe
operator|->
name|flags
operator|&
name|TP_IS_A_SYNQ_ENTRY
argument_list|,
operator|(
literal|"%s: !SYNQ_ENTRY"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %u, synqe %p (%x), lctx %p, status %d"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|,
name|synqe
operator|->
name|lctx
argument_list|,
name|req
operator|->
name|status
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_REQ_RCVD
operator|)
condition|)
block|{
name|synqe
operator|->
name|flags
operator||=
name|TP_ABORT_REQ_RCVD
expr_stmt|;
name|synqe
operator|->
name|flags
operator||=
name|TP_ABORT_SHUTDOWN
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|synqe
operator|->
name|flags
operator|&=
operator|~
name|TP_ABORT_REQ_RCVD
expr_stmt|;
comment|/* 	 * If we'd sent a reset on this synqe, we'll ignore this and clean up in 	 * the T3's reply to our reset instead. 	 */
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
name|synqe
operator|->
name|flags
operator||=
name|TP_ABORT_RPL_SENT
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|tod
argument_list|,
name|tid
argument_list|,
name|qs
operator|->
name|idx
argument_list|)
expr_stmt|;
name|l2t_release
argument_list|(
name|td
operator|->
name|l2t
argument_list|,
name|synqe
operator|->
name|e
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
name|send_abort_rpl
argument_list|(
name|tod
argument_list|,
name|tid
argument_list|,
name|qs
operator|->
name|idx
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|do_abort_rpl_synqe
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|adap
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tod
init|=
operator|&
name|td
operator|->
name|tod
decl_stmt|;
specifier|const
name|struct
name|cpl_abort_rpl_rss
modifier|*
name|rpl
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|GET_TID
argument_list|(
name|rpl
argument_list|)
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|lookup_tid
argument_list|(
operator|&
name|td
operator|->
name|tid_maps
argument_list|,
name|tid
argument_list|)
decl_stmt|;
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %d, synqe %p, status %d"
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|rpl
operator|->
name|status
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_RPL_PENDING
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_RPL_RCVD
operator|)
condition|)
block|{
name|synqe
operator|->
name|flags
operator||=
name|TP_ABORT_RPL_RCVD
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|synqe
operator|->
name|flags
operator|&=
operator|~
name|TP_ABORT_RPL_RCVD
expr_stmt|;
name|synqe
operator|->
name|flags
operator|&=
name|TP_ABORT_RPL_PENDING
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|lctx
operator|->
name|synq
argument_list|,
name|synqe
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|inp
operator|=
name|release_lctx
argument_list|(
name|td
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|release_tid
argument_list|(
name|tod
argument_list|,
name|tid
argument_list|,
name|qs
operator|->
name|idx
argument_list|)
expr_stmt|;
name|l2t_release
argument_list|(
name|td
operator|->
name|l2t
argument_list|,
name|synqe
operator|->
name|e
argument_list|)
expr_stmt|;
name|release_synqe
argument_list|(
name|synqe
argument_list|)
expr_stmt|;
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|t3_send_reset_synqe
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|struct
name|synq_entry
modifier|*
name|synqe
parameter_list|)
block|{
name|struct
name|cpl_abort_req
modifier|*
name|req
decl_stmt|;
name|unsigned
name|int
name|tid
init|=
name|synqe
operator|->
name|tid
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|listen_ctx
modifier|*
name|lctx
init|=
name|synqe
operator|->
name|lctx
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|lctx
operator|->
name|inp
decl_stmt|;
endif|#
directive|endif
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CXGB
argument_list|,
literal|"%s: tid %d, synqe %p (%x)"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|synqe
argument_list|,
name|synqe
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|synqe
operator|->
name|flags
operator|&
name|TP_ABORT_SHUTDOWN
condition|)
return|return;
name|synqe
operator|->
name|flags
operator||=
operator|(
name|TP_ABORT_RPL_PENDING
operator||
name|TP_ABORT_SHUTDOWN
operator|)
expr_stmt|;
name|m
operator|=
name|M_GETHDR_OFLD
argument_list|(
name|synqe
operator|->
name|qset
argument_list|,
name|CPL_PRIORITY_DATA
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|CXGB_UNIMPLEMENTED
argument_list|()
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_OFLD_HOST_ABORT_CON_REQ
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_ABORT_REQ
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|rsvd0
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|rsvd1
operator|=
operator|!
operator|(
name|synqe
operator|->
name|flags
operator|&
name|TP_DATASENT
operator|)
expr_stmt|;
name|req
operator|->
name|cmd
operator|=
name|CPL_ABORT_SEND_RST
expr_stmt|;
name|l2t_send
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|synqe
operator|->
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_offload_socket
parameter_list|(
name|struct
name|toedev
modifier|*
name|tod
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|tod
operator|->
name|tod_softc
decl_stmt|;
name|struct
name|tom_data
modifier|*
name|td
init|=
name|sc
operator|->
name|tom_softc
decl_stmt|;
name|struct
name|synq_entry
modifier|*
name|synqe
init|=
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|inpcb
modifier|*
name|inp
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|struct
name|cpl_pass_establish
modifier|*
name|cpl
init|=
name|synqe
operator|->
name|cpl
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|synqe
operator|->
name|toep
decl_stmt|;
name|INP_INFO_LOCK_ASSERT
argument_list|(
operator|&
name|V_tcbinfo
argument_list|)
expr_stmt|;
comment|/* prevents bad race with accept() */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|offload_socket
argument_list|(
name|so
argument_list|,
name|toep
argument_list|)
expr_stmt|;
name|make_established
argument_list|(
name|so
argument_list|,
name|cpl
operator|->
name|snd_isn
argument_list|,
name|cpl
operator|->
name|rcv_isn
argument_list|,
name|cpl
operator|->
name|tcp_opt
argument_list|)
expr_stmt|;
name|update_tid
argument_list|(
name|td
argument_list|,
name|toep
argument_list|,
name|synqe
operator|->
name|tid
argument_list|)
expr_stmt|;
name|synqe
operator|->
name|flags
operator||=
name|TP_SYNQE_EXPANDED
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

