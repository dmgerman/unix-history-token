begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  * Copyright (C) 2010 Spectra Logic Corporation  * Copyright (C) 2008 Doug Rabson  * Copyright (C) 2005 Rusty Russell, IBM Corporation  * Copyright (C) 2005 Mike Wray, Hewlett-Packard  * Copyright (C) 2005 XenSource Ltd  *   * This file may be distributed separately from the Linux kernel, or  * incorporated into other software packages, subject to the following license:  *   * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this source file (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use, copy, modify,  * merge, publish, distribute, sublicense, and/or sell copies of the Software,  * and to permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *   * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  */
end_comment

begin_comment
comment|/**  * \file xenbusb.c  *  * \brief Shared support functions for managing the NewBus busses that contain  *        Xen front and back end device instances.  *  * The NewBus implementation of XenBus attaches a xenbusb_front and xenbusb_back  * child bus to the xenstore device.  This strategy allows the small differences  * in the handling of XenBus operations for front and back devices to be handled  * as overrides in xenbusb_front/back.c.  Front and back specific device  * classes are also provided so device drivers can register for the devices they  * can handle without the need to filter within their probe routines.  The  * net result is a device hierarchy that might look like this:  *  * xenstore0/  *           xenbusb_front0/  *                         xn0  *                         xbd0  *                         xbd1  *           xenbusb_back0/  *                        xbbd0  *                        xnb0  *                        xnb1  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<xen/gnttab.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenstore/xenstorevar.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusb.h>
end_include

begin_include
include|#
directive|include
file|<xen/xenbus/xenbusvar.h>
end_include

begin_comment
comment|/*------------------------- Private Functions --------------------------------*/
end_comment

begin_comment
comment|/**  * \brief Deallocate XenBus device instance variables.  *  * \param ivars  The instance variable block to free.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_free_child_ivars
parameter_list|(
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
parameter_list|)
block|{
if|if
condition|(
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
operator|!=
name|NULL
condition|)
block|{
name|xs_unregister_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ivars
operator|->
name|xd_local_watch
operator|.
name|node
operator|!=
name|NULL
condition|)
block|{
name|xs_unregister_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_local_watch
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_local_watch
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ivars
operator|->
name|xd_node
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_node
operator|=
name|NULL
expr_stmt|;
block|}
name|ivars
operator|->
name|xd_node_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ivars
operator|->
name|xd_type
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ivars
operator|->
name|xd_type
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_type
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ivars
operator|->
name|xd_otherend_path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_path
operator|=
name|NULL
expr_stmt|;
block|}
name|ivars
operator|->
name|xd_otherend_path_len
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|ivars
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * XenBus watch callback registered against the "state" XenStore  * node of the other-end of a split device connection.  *  * This callback is invoked whenever the state of a device instance's  * peer changes.  *  * \param watch      The xs_watch object used to register this callback  *                   function.  * \param vec        An array of pointers to NUL terminated strings containing  *                   watch event data.  The vector should be indexed via the  *                   xs_watch_type enum in xs_wire.h.  * \param vec_size   The number of elements in vec.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_otherend_watch_cb
parameter_list|(
name|struct
name|xs_watch
modifier|*
name|watch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vec
parameter_list|,
name|unsigned
name|int
name|vec_size
name|__unused
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|enum
name|xenbus_state
name|newstate
decl_stmt|;
name|ivars
operator|=
operator|(
expr|struct
name|xenbus_device_ivars
operator|*
operator|)
name|watch
operator|->
name|callback_data
expr_stmt|;
name|child
operator|=
name|ivars
operator|->
name|xd_dev
expr_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|path
operator|=
name|vec
index|[
name|XS_WATCH_PATH
index|]
expr_stmt|;
if|if
condition|(
name|ivars
operator|->
name|xd_otherend_path
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|,
name|path
argument_list|,
name|ivars
operator|->
name|xd_otherend_path_len
argument_list|)
condition|)
return|return;
name|newstate
operator|=
name|xenbus_read_driver_state
argument_list|(
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
expr_stmt|;
name|XENBUSB_OTHEREND_CHANGED
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * XenBus watch callback registered against the XenStore sub-tree  * represnting the local half of a split device connection.  *  * This callback is invoked whenever any XenStore data in the subtree  * is modified, either by us or another privledged domain.  *  * \param watch      The xs_watch object used to register this callback  *                   function.  * \param vec        An array of pointers to NUL terminated strings containing  *                   watch event data.  The vector should be indexed via the  *                   xs_watch_type enum in xs_wire.h.  * \param vec_size   The number of elements in vec.  *  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_local_watch_cb
parameter_list|(
name|struct
name|xs_watch
modifier|*
name|watch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vec
parameter_list|,
name|unsigned
name|int
name|vec_size
name|__unused
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|device_t
name|bus
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|ivars
operator|=
operator|(
expr|struct
name|xenbus_device_ivars
operator|*
operator|)
name|watch
operator|->
name|callback_data
expr_stmt|;
name|child
operator|=
name|ivars
operator|->
name|xd_dev
expr_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|path
operator|=
name|vec
index|[
name|XS_WATCH_PATH
index|]
expr_stmt|;
if|if
condition|(
name|ivars
operator|->
name|xd_node
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|,
name|path
argument_list|,
name|ivars
operator|->
name|xd_node_len
argument_list|)
condition|)
return|return;
name|XENBUSB_LOCALEND_CHANGED
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
operator|&
name|path
index|[
name|ivars
operator|->
name|xd_node_len
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Search our internal record of configured devices (not the XenStore)  * to determine if the XenBus device indicated by \a node is known to  * the system.  *  * \param dev   The XenBus bus instance to search for device children.  * \param node  The XenStore node path for the device to find.  *  * \return  The device_t of the found device if any, or NULL.  *  * \note device_t is a pointer type, so it can be compared against  *       NULL for validity.   */
end_comment

begin_function
specifier|static
name|device_t
name|xenbusb_device_exists
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|)
block|{
name|device_t
modifier|*
name|kids
decl_stmt|;
name|device_t
name|result
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|count
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|result
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|result
operator|=
name|kids
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xenbusb_delete_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* 	 * We no longer care about the otherend of the 	 * connection.  Cancel the watches now so that we 	 * don't try to handle an event for a partially 	 * detached child. 	 */
if|if
condition|(
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
operator|!=
name|NULL
condition|)
name|xs_unregister_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivars
operator|->
name|xd_local_watch
operator|.
name|node
operator|!=
name|NULL
condition|)
name|xs_unregister_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_local_watch
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|xenbusb_free_child_ivars
argument_list|(
name|ivars
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \param dev    The NewBus device representing this XenBus bus.  * \param child	 The NewBus device representing a child of dev%'s XenBus bus.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_verify_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|xs_exists
argument_list|(
name|XST_NIL
argument_list|,
name|xenbus_get_node
argument_list|(
name|child
argument_list|)
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Device tree has been removed from Xenbus. 		 * Tear down the device. 		 */
name|xenbusb_delete_child
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * \brief Enumerate the devices on a XenBus bus and register them with  *        the NewBus device tree.  *  * xenbusb_enumerate_bus() will create entries (in state DS_NOTPRESENT)  * for nodes that appear in the XenStore, but will not invoke probe/attach  * operations on drivers.  Probe/Attach processing must be separately  * performed via an invocation of xenbusb_probe_children().  This is usually  * done via the xbs_probe_children task.  *  * \param xbs  XenBus Bus device softc of the owner of the bus to enumerate.  *  * \return  On success, 0. Otherwise an errno value indicating the  *          type of failure.  */
end_comment

begin_function
specifier|static
name|int
name|xenbusb_enumerate_bus
parameter_list|(
name|struct
name|xenbusb_softc
modifier|*
name|xbs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|types
decl_stmt|;
name|u_int
name|type_idx
decl_stmt|;
name|u_int
name|type_count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xs_directory
argument_list|(
name|XST_NIL
argument_list|,
name|xbs
operator|->
name|xbs_node
argument_list|,
literal|""
argument_list|,
operator|&
name|type_count
argument_list|,
operator|&
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|type_idx
operator|=
literal|0
init|;
name|type_idx
operator|<
name|type_count
condition|;
name|type_idx
operator|++
control|)
name|XENBUSB_ENUMERATE_TYPE
argument_list|(
name|xbs
operator|->
name|xbs_dev
argument_list|,
name|types
index|[
name|type_idx
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|types
argument_list|,
name|M_XENSTORE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Handler for all generic XenBus device systcl nodes.  */
end_comment

begin_function
specifier|static
name|int
name|xenbusb_device_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|dev
operator|=
operator|(
name|device_t
operator|)
name|arg1
expr_stmt|;
switch|switch
condition|(
name|arg2
condition|)
block|{
case|case
name|XENBUS_IVAR_NODE
case|:
name|value
operator|=
name|xenbus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|XENBUS_IVAR_TYPE
case|:
name|value
operator|=
name|xenbus_get_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|XENBUS_IVAR_STATE
case|:
name|value
operator|=
name|xenbus_strstate
argument_list|(
name|xenbus_get_state
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|XENBUS_IVAR_OTHEREND_ID
case|:
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|xenbus_get_otherend_id
argument_list|(
name|dev
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
comment|/* NOTREACHED */
case|case
name|XENBUS_IVAR_OTHEREND_PATH
case|:
name|value
operator|=
name|xenbus_get_otherend_path
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Create read-only systcl nodes for xenbusb device ivar data.  *  * \param dev  The XenBus device instance to register with sysctl.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_device_sysctl_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xenstore_path"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|XENBUS_IVAR_NODE
argument_list|,
name|xenbusb_device_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"XenStore path to device"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xenbus_dev_type"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|XENBUS_IVAR_TYPE
argument_list|,
name|xenbusb_device_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"XenBus device type"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xenbus_connection_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|XENBUS_IVAR_STATE
argument_list|,
name|xenbusb_device_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"XenBus state of peer connection"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xenbus_peer_domid"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|XENBUS_IVAR_OTHEREND_ID
argument_list|,
name|xenbusb_device_sysctl_handler
argument_list|,
literal|"I"
argument_list|,
literal|"Xen domain ID of peer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"xenstore_peer_path"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|dev
argument_list|,
name|XENBUS_IVAR_OTHEREND_PATH
argument_list|,
name|xenbusb_device_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"XenStore path to peer device"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Decrement the number of XenBus child devices in the  *        connecting state by one and release the xbs_attch_ch  *        interrupt configuration hook if the connecting count  *        drops to zero.  *  * \param xbs  XenBus Bus device softc of the owner of the bus to enumerate.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_release_confighook
parameter_list|(
name|struct
name|xenbusb_softc
modifier|*
name|xbs
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|xbs
operator|->
name|xbs_connecting_children
operator|>
literal|0
argument_list|,
operator|(
literal|"Connecting device count error\n"
operator|)
argument_list|)
expr_stmt|;
name|xbs
operator|->
name|xbs_connecting_children
operator|--
expr_stmt|;
if|if
condition|(
name|xbs
operator|->
name|xbs_connecting_children
operator|==
literal|0
operator|&&
operator|(
name|xbs
operator|->
name|xbs_flags
operator|&
name|XBS_ATTACH_CH_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|xbs
operator|->
name|xbs_flags
operator|&=
operator|~
name|XBS_ATTACH_CH_ACTIVE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_attach_ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * \brief Verify the existance of attached device instances and perform  *        probe/attach processing for newly arrived devices.  *  * \param dev  The NewBus device representing this XenBus bus.  *  * \return  On success, 0. Otherwise an errno value indicating the  *          type of failure.  */
end_comment

begin_function
specifier|static
name|int
name|xenbusb_probe_children
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|kids
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|device_get_state
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
operator|!=
name|DS_NOTPRESENT
condition|)
block|{
comment|/* 				 * We already know about this one. 				 * Make sure it's still here. 				 */
name|xenbusb_verify_device
argument_list|(
name|dev
argument_list|,
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|device_probe_and_attach
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
block|{
name|struct
name|xenbusb_softc
modifier|*
name|xbs
decl_stmt|;
comment|/* 				 * We don't have a PV driver for this device. 				 * However, an emulated device we do support 				 * may share this backend.  Hide the node from 				 * XenBus until the next rescan, but leave it's 				 * state unchanged so we don't inadvertently 				 * prevent attachment of any emulated device. 				 */
name|xenbusb_delete_child
argument_list|(
name|dev
argument_list|,
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * Since the XenStore state of this device 				 * still indicates a pending attach, manually 				 * release it's hold on the boot process. 				 */
name|xbs
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xenbusb_release_confighook
argument_list|(
name|xbs
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * Transition device to the closed state 				 * so the world knows that attachment will 				 * not occur. 				 */
name|xenbus_set_state
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|,
name|XenbusStateClosed
argument_list|)
expr_stmt|;
comment|/* 				 * Remove our record of this device. 				 * So long as it remains in the closed 				 * state in the XenStore, we will not find 				 * it again.  The state will only change 				 * if the control domain actively reconfigures 				 * this device. 				 */
name|xenbusb_delete_child
argument_list|(
name|dev
argument_list|,
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Augment default newbus provided dynamic sysctl 			 * variables with the standard ivar contents of 			 * XenBus devices. 			 */
name|xenbusb_device_sysctl_init
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * Now that we have a driver managing this device 			 * that can receive otherend state change events, 			 * hook up a watch for them. 			 */
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xs_register_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
name|xs_register_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_local_watch
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * \brief Task callback function to perform XenBus probe operations  *        from a known safe context.  *  * \param arg      The NewBus device_t representing the bus instance to  *                 on which to perform probe processing.  * \param pending  The number of times this task was queued before it could  *                 be run.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_probe_children_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Hold Giant until the Giant free newbus changes are committed. 	 */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|xenbusb_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief XenStore watch callback for the root node of the XenStore  *        subtree representing a XenBus.  *  * This callback performs, or delegates to the xbs_probe_children task,  * all processing necessary to handle dynmaic device arrival and departure  * events from a XenBus.  *  * \param watch  The XenStore watch object associated with this callback.  * \param vec    The XenStore watch event data.  * \param len	 The number of fields in the event data stream.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_devices_changed
parameter_list|(
name|struct
name|xs_watch
modifier|*
name|watch
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|vec
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|struct
name|xenbusb_softc
modifier|*
name|xbs
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|bus
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|u_int
name|component
decl_stmt|;
name|xbs
operator|=
operator|(
expr|struct
name|xenbusb_softc
operator|*
operator|)
name|watch
operator|->
name|callback_data
expr_stmt|;
name|dev
operator|=
name|xbs
operator|->
name|xbs_dev
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|XS_WATCH_PATH
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"xenbusb_devices_changed: "
literal|"Short Event Data.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|node
operator|=
name|strdup
argument_list|(
name|vec
index|[
name|XS_WATCH_PATH
index|]
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|node
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|bus
operator|=
name|node
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|type
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Extract the device ID.  A device ID has one or more path 	 * components separated by the '/' character. 	 * 	 * e.g. "<frontend vm id>/<frontend dev id>" for backend devices. 	 */
name|id
operator|=
name|p
expr_stmt|;
for|for
control|(
name|component
operator|=
literal|0
init|;
name|component
operator|<
name|xbs
operator|->
name|xbs_id_components
condition|;
name|component
operator|++
control|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|id
operator|!=
literal|0
operator|&&
name|component
operator|>=
name|xbs
operator|->
name|xbs_id_components
operator|-
literal|1
condition|)
block|{
name|xenbusb_add_device
argument_list|(
name|xbs
operator|->
name|xbs_dev
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|xbs
operator|->
name|xbs_probe_children
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|free
argument_list|(
name|node
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * \brief Interrupt configuration hook callback associated with xbs_attch_ch.  *  * Since interrupts are always functional at the time of XenBus configuration,  * there is nothing to be done when the callback occurs.  This hook is only  * registered to hold up boot processing while XenBus devices come online.  *   * \param arg  Unused configuration hook callback argument.  */
end_comment

begin_function
specifier|static
name|void
name|xenbusb_nop_confighook_cb
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*--------------------------- Public Functions -------------------------------*/
end_comment

begin_comment
comment|/*--------- API comments for these methods can be found in xenbusb.h ---------*/
end_comment

begin_function
name|void
name|xenbusb_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
name|__unused
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
comment|/* 	 * A single instance of each bus type for which we have a driver 	 * is always present in a system operating under Xen. 	 */
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
name|driver
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xenbusb_add_device
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|xenbusb_softc
modifier|*
name|xbs
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|devpath_sbuf
decl_stmt|;
name|char
modifier|*
name|devpath
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xbs
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devpath_sbuf
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|sbuf_printf
argument_list|(
name|devpath_sbuf
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|xbs
operator|->
name|xbs_node
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|devpath_sbuf
argument_list|)
expr_stmt|;
name|devpath
operator|=
name|sbuf_data
argument_list|(
name|devpath_sbuf
argument_list|)
expr_stmt|;
name|ivars
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ivars
argument_list|)
argument_list|,
name|M_XENBUS
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|xs_exists
argument_list|(
name|XST_NIL
argument_list|,
name|devpath
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_t
name|child
decl_stmt|;
name|enum
name|xenbus_state
name|state
decl_stmt|;
name|char
modifier|*
name|statepath
decl_stmt|;
name|child
operator|=
name|xenbusb_device_exists
argument_list|(
name|dev
argument_list|,
name|devpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We are already tracking this node 			 */
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|state
operator|=
name|xenbus_read_driver_state
argument_list|(
name|devpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|XenbusStateInitialising
condition|)
block|{
comment|/* 			 * Device is not new, so ignore it. This can 			 * happen if a device is going away after 			 * switching to Closed. 			 */
name|printf
argument_list|(
literal|"xenbusb_add_device: Device %s ignored. "
literal|"State %d\n"
argument_list|,
name|devpath
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sx_init
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|,
literal|"xdlock"
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_flags
operator|=
name|XDF_CONNECTING
expr_stmt|;
name|ivars
operator|->
name|xd_node
operator|=
name|strdup
argument_list|(
name|devpath
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_node_len
operator|=
name|strlen
argument_list|(
name|devpath
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_type
operator|=
name|strdup
argument_list|(
name|type
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_state
operator|=
name|XenbusStateInitialising
expr_stmt|;
name|error
operator|=
name|XENBUSB_GET_OTHEREND_NODE
argument_list|(
name|dev
argument_list|,
name|ivars
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"xenbus_update_device: %s no otherend id\n"
argument_list|,
name|devpath
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|statepath
operator|=
name|malloc
argument_list|(
name|ivars
operator|->
name|xd_otherend_path_len
operator|+
name|strlen
argument_list|(
literal|"/state"
argument_list|)
operator|+
literal|1
argument_list|,
name|M_XENBUS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|statepath
argument_list|,
literal|"%s/state"
argument_list|,
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
operator|=
name|statepath
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|callback
operator|=
name|xenbusb_otherend_watch_cb
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|callback_data
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
expr_stmt|;
name|ivars
operator|->
name|xd_local_watch
operator|.
name|node
operator|=
name|ivars
operator|->
name|xd_node
expr_stmt|;
name|ivars
operator|->
name|xd_local_watch
operator|.
name|callback
operator|=
name|xenbusb_local_watch_cb
expr_stmt|;
name|ivars
operator|->
name|xd_local_watch
operator|.
name|callback_data
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
name|xbs
operator|->
name|xbs_connecting_children
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_dev
operator|=
name|child
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ivars
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|sbuf_delete
argument_list|(
name|devpath_sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|xenbusb_free_child_ivars
argument_list|(
name|ivars
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xenbusb_attach
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|char
modifier|*
name|bus_node
parameter_list|,
name|u_int
name|id_components
parameter_list|)
block|{
name|struct
name|xenbusb_softc
modifier|*
name|xbs
decl_stmt|;
name|xbs
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_lock
argument_list|,
literal|"xenbusb softc lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|xbs
operator|->
name|xbs_node
operator|=
name|bus_node
expr_stmt|;
name|xbs
operator|->
name|xbs_id_components
operator|=
name|id_components
expr_stmt|;
name|xbs
operator|->
name|xbs_dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * Since XenBus busses are attached to the XenStore, and 	 * the XenStore does not probe children until after interrupt 	 * services are available, this config hook is used solely 	 * to ensure that the remainder of the boot process (e.g. 	 * mount root) is deferred until child devices are adequately 	 * probed.  We unblock the boot process as soon as the 	 * connecting child count in our softc goes to 0. 	 */
name|xbs
operator|->
name|xbs_attach_ch
operator|.
name|ich_func
operator|=
name|xenbusb_nop_confighook_cb
expr_stmt|;
name|xbs
operator|->
name|xbs_attach_ch
operator|.
name|ich_arg
operator|=
name|dev
expr_stmt|;
name|config_intrhook_establish
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_attach_ch
argument_list|)
expr_stmt|;
name|xbs
operator|->
name|xbs_flags
operator||=
name|XBS_ATTACH_CH_ACTIVE
expr_stmt|;
name|xbs
operator|->
name|xbs_connecting_children
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The subtree for this bus type may not yet exist 	 * causing initial enumeration to fail.  We still 	 * want to return success from our attach though 	 * so that we are ready to handle devices for this 	 * bus when they are dynamically attached to us 	 * by a Xen management action. 	 */
operator|(
name|void
operator|)
name|xenbusb_enumerate_bus
argument_list|(
name|xbs
argument_list|)
expr_stmt|;
name|xenbusb_probe_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xbs
operator|->
name|xbs_device_watch
operator|.
name|node
operator|=
name|bus_node
expr_stmt|;
name|xbs
operator|->
name|xbs_device_watch
operator|.
name|callback
operator|=
name|xenbusb_devices_changed
expr_stmt|;
name|xbs
operator|->
name|xbs_device_watch
operator|.
name|callback_data
operator|=
operator|(
name|uintptr_t
operator|)
name|xbs
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_probe_children
argument_list|,
literal|0
argument_list|,
name|xenbusb_probe_children_cb
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|xs_register_watch
argument_list|(
operator|&
name|xbs
operator|->
name|xbs_device_watch
argument_list|)
expr_stmt|;
name|xenbusb_release_confighook
argument_list|(
name|xbs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xenbusb_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
modifier|*
name|kids
decl_stmt|;
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|error
decl_stmt|;
name|char
modifier|*
name|statepath
decl_stmt|;
comment|/* 	 * We must re-examine each device and find the new path for 	 * its backend. 	 */
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|device_get_state
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
operator|==
name|DS_NOTPRESENT
condition|)
continue|continue;
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xs_unregister_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
name|xenbus_set_state
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|,
name|XenbusStateInitialising
argument_list|)
expr_stmt|;
comment|/* 			 * Find the new backend details and 			 * re-register our watch. 			 */
name|error
operator|=
name|XENBUSB_GET_OTHEREND_NODE
argument_list|(
name|dev
argument_list|,
name|ivars
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|statepath
operator|=
name|malloc
argument_list|(
name|ivars
operator|->
name|xd_otherend_path_len
operator|+
name|strlen
argument_list|(
literal|"/state"
argument_list|)
operator|+
literal|1
argument_list|,
name|M_XENBUS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|statepath
argument_list|,
literal|"%s/state"
argument_list|,
name|ivars
operator|->
name|xd_otherend_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
argument_list|,
name|M_XENBUS
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_otherend_watch
operator|.
name|node
operator|=
name|statepath
expr_stmt|;
name|DEVICE_RESUME
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xs_register_watch
argument_list|(
operator|&
name|ivars
operator|->
name|xd_otherend_watch
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * Can't do this yet since we are running in 			 * the xenwatch thread and if we sleep here, 			 * we will stop delivering watch notifications 			 * and the device will never come back online. 			 */
block|sx_xlock(&ivars->xd_lock); 			while (ivars->xd_state != XenbusStateClosed&& ivars->xd_state != XenbusStateConnected) 				sx_sleep(&ivars->xd_state,&ivars->xd_lock, 				    0, "xdresume", 0); 			sx_xunlock(&ivars->xd_lock);
endif|#
directive|endif
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xenbusb_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xenbusb_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|XENBUS_IVAR_NODE
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_node
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_TYPE
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_STATE
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_state
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_OTHEREND_ID
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_otherend_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XENBUS_IVAR_OTHEREND_PATH
case|:
operator|*
name|result
operator|=
operator|(
name|uintptr_t
operator|)
name|ivars
operator|->
name|xd_otherend_path
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xenbusb_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|enum
name|xenbus_state
name|newstate
decl_stmt|;
name|int
name|currstate
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|XENBUS_IVAR_STATE
case|:
block|{
name|int
name|error
decl_stmt|;
name|newstate
operator|=
operator|(
expr|enum
name|xenbus_state
operator|)
name|value
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivars
operator|->
name|xd_state
operator|==
name|newstate
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|xs_scanf
argument_list|(
name|XST_NIL
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|,
literal|"state"
argument_list|,
name|NULL
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|currstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
do|do
block|{
name|error
operator|=
name|xs_printf
argument_list|(
name|XST_NIL
argument_list|,
name|ivars
operator|->
name|xd_node
argument_list|,
literal|"state"
argument_list|,
literal|"%d"
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|EAGAIN
condition|)
do|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Avoid looping through xenbus_dev_fatal() 			 * which calls xenbus_write_ivar to set the 			 * state to closing. 			 */
if|if
condition|(
name|newstate
operator|!=
name|XenbusStateClosing
condition|)
name|xenbus_dev_fatal
argument_list|(
name|dev
argument_list|,
name|error
argument_list|,
literal|"writing new state"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ivars
operator|->
name|xd_state
operator|=
name|newstate
expr_stmt|;
if|if
condition|(
operator|(
name|ivars
operator|->
name|xd_flags
operator|&
name|XDF_CONNECTING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|newstate
operator|==
name|XenbusStateClosed
operator|||
name|newstate
operator|==
name|XenbusStateConnected
operator|)
condition|)
block|{
name|struct
name|xenbusb_softc
modifier|*
name|xbs
decl_stmt|;
name|ivars
operator|->
name|xd_flags
operator|&=
operator|~
name|XDF_CONNECTING
expr_stmt|;
name|xbs
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xenbusb_release_confighook
argument_list|(
name|xbs
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|ivars
operator|->
name|xd_state
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|XENBUS_IVAR_NODE
case|:
case|case
name|XENBUS_IVAR_TYPE
case|:
case|case
name|XENBUS_IVAR_OTHEREND_ID
case|:
case|case
name|XENBUS_IVAR_OTHEREND_PATH
case|:
comment|/* 		 * These variables are read-only. 		 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xenbusb_otherend_changed
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|enum
name|xenbus_state
name|state
parameter_list|)
block|{
name|XENBUS_OTHEREND_CHANGED
argument_list|(
name|child
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xenbusb_localend_changed
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
literal|"/state"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|xenbus_device_ivars
modifier|*
name|ivars
decl_stmt|;
name|ivars
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
name|ivars
operator|->
name|xd_state
operator|=
name|xenbus_read_driver_state
argument_list|(
name|ivars
operator|->
name|xd_node
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|ivars
operator|->
name|xd_lock
argument_list|)
expr_stmt|;
block|}
name|XENBUS_LOCALEND_CHANGED
argument_list|(
name|child
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

