begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*   svc_rpcsec_gss.c      Copyright (c) 2000 The Regents of the University of Michigan.   All rights reserved.    Copyright (c) 2000 Dug Song<dugsong@UMICH.EDU>.   All rights reserved, all wrongs reversed.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright      notice, this list of conditions and the following disclaimer in the      documentation and/or other materials provided with the distribution.   3. Neither the name of the University nor the names of its      contributors may be used to endorse or promote products derived      from this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    $Id: svc_auth_gss.c,v 1.27 2002/01/15 15:43:00 andros Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcsec_gss.h>
end_include

begin_include
include|#
directive|include
file|"rpcsec_gss_int.h"
end_include

begin_function_decl
specifier|static
name|bool_t
name|svc_rpc_gss_wrap
parameter_list|(
name|SVCAUTH
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|svc_rpc_gss_unwrap
parameter_list|(
name|SVCAUTH
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|svc_rpc_gss_release
parameter_list|(
name|SVCAUTH
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|auth_stat
name|svc_rpc_gss
parameter_list|(
name|struct
name|svc_req
modifier|*
parameter_list|,
name|struct
name|rpc_msg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpc_gss_svc_getcred
parameter_list|(
name|struct
name|svc_req
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|svc_auth_ops
name|svc_auth_gss_ops
init|=
block|{
name|svc_rpc_gss_wrap
block|,
name|svc_rpc_gss_unwrap
block|,
name|svc_rpc_gss_release
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sx
name|svc_rpc_gss_lock
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|svc_rpc_gss_callback
block|{
name|SLIST_ENTRY
argument_list|(
argument|svc_rpc_gss_callback
argument_list|)
name|cb_link
expr_stmt|;
name|rpc_gss_callback_t
name|cb_callback
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument|svc_rpc_gss_callback_list
argument_list|,
argument|svc_rpc_gss_callback
argument_list|)
name|svc_rpc_gss_callbacks
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|svc_rpc_gss_callbacks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|svc_rpc_gss_svc_name
block|{
name|SLIST_ENTRY
argument_list|(
argument|svc_rpc_gss_svc_name
argument_list|)
name|sn_link
expr_stmt|;
name|char
modifier|*
name|sn_principal
decl_stmt|;
name|gss_OID
name|sn_mech
decl_stmt|;
name|u_int
name|sn_req_time
decl_stmt|;
name|gss_cred_id_t
name|sn_cred
decl_stmt|;
name|u_int
name|sn_program
decl_stmt|;
name|u_int
name|sn_version
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument|svc_rpc_gss_svc_name_list
argument_list|,
argument|svc_rpc_gss_svc_name
argument_list|)
name|svc_rpc_gss_svc_names
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|svc_rpc_gss_svc_names
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
name|svc_rpc_gss_client_state
block|{
name|CLIENT_NEW
block|,
comment|/* still authenticating */
name|CLIENT_ESTABLISHED
block|,
comment|/* context established */
name|CLIENT_STALE
comment|/* garbage to collect */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|SVC_RPC_GSS_SEQWINDOW
value|128
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RPCAUTH_UNIXGIDS
end_ifndef

begin_define
define|#
directive|define
name|RPCAUTH_UNIXGIDS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|svc_rpc_gss_clientid
block|{
name|unsigned
name|long
name|ci_hostid
decl_stmt|;
name|uint32_t
name|ci_boottime
decl_stmt|;
name|uint32_t
name|ci_id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|svc_rpc_gss_client
block|{
name|TAILQ_ENTRY
argument_list|(
argument|svc_rpc_gss_client
argument_list|)
name|cl_link
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|svc_rpc_gss_client
argument_list|)
name|cl_alllink
expr_stmt|;
specifier|volatile
name|u_int
name|cl_refs
decl_stmt|;
name|struct
name|sx
name|cl_lock
decl_stmt|;
name|struct
name|svc_rpc_gss_clientid
name|cl_id
decl_stmt|;
name|time_t
name|cl_expiration
decl_stmt|;
comment|/* when to gc */
name|enum
name|svc_rpc_gss_client_state
name|cl_state
decl_stmt|;
comment|/* client state */
name|bool_t
name|cl_locked
decl_stmt|;
comment|/* fixed service+qop */
name|gss_ctx_id_t
name|cl_ctx
decl_stmt|;
comment|/* context id */
name|gss_cred_id_t
name|cl_creds
decl_stmt|;
comment|/* delegated creds */
name|gss_name_t
name|cl_cname
decl_stmt|;
comment|/* client name */
name|struct
name|svc_rpc_gss_svc_name
modifier|*
name|cl_sname
decl_stmt|;
comment|/* server name used */
name|rpc_gss_rawcred_t
name|cl_rawcred
decl_stmt|;
comment|/* raw credentials */
name|rpc_gss_ucred_t
name|cl_ucred
decl_stmt|;
comment|/* unix-style credentials */
name|struct
name|ucred
modifier|*
name|cl_cred
decl_stmt|;
comment|/* kernel-style credentials */
name|int
name|cl_rpcflavor
decl_stmt|;
comment|/* RPC pseudo sec flavor */
name|bool_t
name|cl_done_callback
decl_stmt|;
comment|/* TRUE after call */
name|void
modifier|*
name|cl_cookie
decl_stmt|;
comment|/* user cookie from callback */
name|gid_t
name|cl_gid_storage
index|[
name|RPCAUTH_UNIXGIDS
index|]
decl_stmt|;
name|gss_OID
name|cl_mech
decl_stmt|;
comment|/* mechanism */
name|gss_qop_t
name|cl_qop
decl_stmt|;
comment|/* quality of protection */
name|uint32_t
name|cl_seqlast
decl_stmt|;
comment|/* sequence window origin */
name|uint32_t
name|cl_seqmask
index|[
name|SVC_RPC_GSS_SEQWINDOW
operator|/
literal|32
index|]
decl_stmt|;
comment|/* bitmask of seqnums */
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|svc_rpc_gss_client_list
argument_list|,
name|svc_rpc_gss_client
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This structure holds enough information to unwrap arguments or wrap  * results for a given request. We use the rq_clntcred area for this  * (which is a per-request buffer).  */
end_comment

begin_struct
struct|struct
name|svc_rpc_gss_cookedcred
block|{
name|struct
name|svc_rpc_gss_client
modifier|*
name|cc_client
decl_stmt|;
name|rpc_gss_service_t
name|cc_service
decl_stmt|;
name|uint32_t
name|cc_seq
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CLIENT_HASH_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|CLIENT_MAX
value|128
end_define

begin_decl_stmt
name|struct
name|svc_rpc_gss_client_list
name|svc_rpc_gss_client_hash
index|[
name|CLIENT_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|svc_rpc_gss_client_list
name|svc_rpc_gss_clients
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|svc_rpc_gss_client_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|svc_rpc_gss_next_clientid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|svc_rpc_gss_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLIENT_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|svc_rpc_gss_client_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|svc_rpc_gss_clients
argument_list|)
expr_stmt|;
name|svc_auth_reg
argument_list|(
name|RPCSEC_GSS
argument_list|,
name|svc_rpc_gss
argument_list|,
name|rpc_gss_svc_getcred
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|,
literal|"gsslock"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|svc_rpc_gss_init
argument_list|,
name|SI_SUB_KMEM
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|svc_rpc_gss_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|bool_t
name|rpc_gss_set_callback
parameter_list|(
name|rpc_gss_callback_t
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_callback
modifier|*
name|scb
decl_stmt|;
name|scb
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|svc_rpc_gss_callback
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scb
condition|)
block|{
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|scb
operator|->
name|cb_callback
operator|=
operator|*
name|cb
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|svc_rpc_gss_callbacks
argument_list|,
name|scb
argument_list|,
name|cb_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rpc_gss_clear_callback
parameter_list|(
name|rpc_gss_callback_t
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_callback
modifier|*
name|scb
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&svc_rpc_gss_callbacks
argument_list|,
argument|cb_link
argument_list|)
block|{
if|if
condition|(
name|scb
operator|->
name|cb_callback
operator|.
name|program
operator|==
name|cb
operator|->
name|program
operator|&&
name|scb
operator|->
name|cb_callback
operator|.
name|version
operator|==
name|cb
operator|->
name|version
operator|&&
name|scb
operator|->
name|cb_callback
operator|.
name|callback
operator|==
name|cb
operator|->
name|callback
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|svc_rpc_gss_callbacks
argument_list|,
name|scb
argument_list|,
name|svc_rpc_gss_callback
argument_list|,
name|cb_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|scb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scb
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_acquire_svc_cred
parameter_list|(
name|struct
name|svc_rpc_gss_svc_name
modifier|*
name|sname
parameter_list|)
block|{
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|gss_buffer_desc
name|namebuf
decl_stmt|;
name|gss_name_t
name|name
decl_stmt|;
name|gss_OID_set_desc
name|oid_set
decl_stmt|;
name|oid_set
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|oid_set
operator|.
name|elements
operator|=
name|sname
operator|->
name|sn_mech
expr_stmt|;
name|namebuf
operator|.
name|value
operator|=
operator|(
name|void
operator|*
operator|)
name|sname
operator|->
name|sn_principal
expr_stmt|;
name|namebuf
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|sname
operator|->
name|sn_principal
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_import_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|namebuf
argument_list|,
name|GSS_C_NT_HOSTBASED_SERVICE
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|sname
operator|->
name|sn_cred
operator|!=
name|GSS_C_NO_CREDENTIAL
condition|)
name|gss_release_cred
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|sname
operator|->
name|sn_cred
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_acquire_cred
argument_list|(
operator|&
name|min_stat
argument_list|,
name|name
argument_list|,
name|sname
operator|->
name|sn_req_time
argument_list|,
operator|&
name|oid_set
argument_list|,
name|GSS_C_ACCEPT
argument_list|,
operator|&
name|sname
operator|->
name|sn_cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|rpc_gss_set_svc_name
parameter_list|(
specifier|const
name|char
modifier|*
name|principal
parameter_list|,
specifier|const
name|char
modifier|*
name|mechanism
parameter_list|,
name|u_int
name|req_time
parameter_list|,
name|u_int
name|program
parameter_list|,
name|u_int
name|version
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_svc_name
modifier|*
name|sname
decl_stmt|;
name|gss_OID
name|mech_oid
decl_stmt|;
if|if
condition|(
operator|!
name|rpc_gss_mech_to_oid
argument_list|(
name|mechanism
argument_list|,
operator|&
name|mech_oid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|sname
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sname
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|sname
operator|->
name|sn_principal
operator|=
name|strdup
argument_list|(
name|principal
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|sname
operator|->
name|sn_mech
operator|=
name|mech_oid
expr_stmt|;
name|sname
operator|->
name|sn_req_time
operator|=
name|req_time
expr_stmt|;
name|sname
operator|->
name|sn_cred
operator|=
name|GSS_C_NO_CREDENTIAL
expr_stmt|;
name|sname
operator|->
name|sn_program
operator|=
name|program
expr_stmt|;
name|sname
operator|->
name|sn_version
operator|=
name|version
expr_stmt|;
if|if
condition|(
operator|!
name|rpc_gss_acquire_svc_cred
argument_list|(
name|sname
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|sname
operator|->
name|sn_principal
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|sname
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sname
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|svc_rpc_gss_svc_names
argument_list|,
name|sname
argument_list|,
name|sn_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rpc_gss_clear_svc_name
parameter_list|(
name|u_int
name|program
parameter_list|,
name|u_int
name|version
parameter_list|)
block|{
name|OM_uint32
name|min_stat
decl_stmt|;
name|struct
name|svc_rpc_gss_svc_name
modifier|*
name|sname
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sname
argument_list|,
argument|&svc_rpc_gss_svc_names
argument_list|,
argument|sn_link
argument_list|)
block|{
if|if
condition|(
name|sname
operator|->
name|sn_program
operator|==
name|program
operator|&&
name|sname
operator|->
name|sn_version
operator|==
name|version
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|svc_rpc_gss_svc_names
argument_list|,
name|sname
argument_list|,
name|svc_rpc_gss_svc_name
argument_list|,
name|sn_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|gss_release_cred
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|sname
operator|->
name|sn_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sname
operator|->
name|sn_principal
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|sname
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sname
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool_t
name|rpc_gss_get_principal_name
parameter_list|(
name|rpc_gss_principal_t
modifier|*
name|principal
parameter_list|,
specifier|const
name|char
modifier|*
name|mech
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|gss_OID
name|mech_oid
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|gss_buffer_desc
name|buf
decl_stmt|;
name|gss_name_t
name|gss_name
decl_stmt|,
name|gss_mech_name
decl_stmt|;
name|rpc_gss_principal_t
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|rpc_gss_mech_to_oid
argument_list|(
name|mech
argument_list|,
operator|&
name|mech_oid
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * Construct a gss_buffer containing the full name formatted 	 * as "name/node@domain" where node and domain are optional. 	 */
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|namelen
operator|+=
name|strlen
argument_list|(
name|node
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|domain
condition|)
block|{
name|namelen
operator|+=
name|strlen
argument_list|(
name|domain
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|buf
operator|.
name|value
operator|=
name|mem_alloc
argument_list|(
name|namelen
argument_list|)
expr_stmt|;
name|buf
operator|.
name|length
operator|=
name|namelen
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|.
name|value
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|.
name|value
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|.
name|value
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|domain
condition|)
block|{
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|.
name|value
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|.
name|value
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Convert that to a gss_name_t and then convert that to a 	 * mechanism name in the selected mechanism. 	 */
name|maj_stat
operator|=
name|gss_import_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|buf
argument_list|,
name|GSS_C_NT_USER_NAME
argument_list|,
operator|&
name|gss_name
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|buf
operator|.
name|value
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_import_name"
argument_list|,
name|mech_oid
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|maj_stat
operator|=
name|gss_canonicalize_name
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gss_name
argument_list|,
name|mech_oid
argument_list|,
operator|&
name|gss_mech_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_canonicalize_name"
argument_list|,
name|mech_oid
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gss_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gss_name
argument_list|)
expr_stmt|;
comment|/* 	 * Export the mechanism name and use that to construct the 	 * rpc_gss_principal_t result. 	 */
name|maj_stat
operator|=
name|gss_export_name
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gss_mech_name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_export_name"
argument_list|,
name|mech_oid
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gss_mech_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gss_mech_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|result
operator|->
name|len
operator|=
name|buf
operator|.
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|buf
operator|.
name|value
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
operator|*
name|principal
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|rpc_gss_getcred
parameter_list|(
name|struct
name|svc_req
modifier|*
name|req
parameter_list|,
name|rpc_gss_rawcred_t
modifier|*
modifier|*
name|rcred
parameter_list|,
name|rpc_gss_ucred_t
modifier|*
modifier|*
name|ucred
parameter_list|,
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_cookedcred
modifier|*
name|cc
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|rq_cred
operator|.
name|oa_flavor
operator|!=
name|RPCSEC_GSS
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|cc
operator|=
name|req
operator|->
name|rq_clntcred
expr_stmt|;
name|client
operator|=
name|cc
operator|->
name|cc_client
expr_stmt|;
if|if
condition|(
name|rcred
condition|)
operator|*
name|rcred
operator|=
operator|&
name|client
operator|->
name|cl_rawcred
expr_stmt|;
if|if
condition|(
name|ucred
condition|)
operator|*
name|ucred
operator|=
operator|&
name|client
operator|->
name|cl_ucred
expr_stmt|;
if|if
condition|(
name|cookie
condition|)
operator|*
name|cookie
operator|=
name|client
operator|->
name|cl_cookie
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This simpler interface is used by svc_getcred to copy the cred data  * into a kernel cred structure.  */
end_comment

begin_function
specifier|static
name|int
name|rpc_gss_svc_getcred
parameter_list|(
name|struct
name|svc_req
modifier|*
name|req
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
name|crp
parameter_list|,
name|int
modifier|*
name|flavorp
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|struct
name|svc_rpc_gss_cookedcred
modifier|*
name|cc
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|rpc_gss_ucred_t
modifier|*
name|uc
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|rq_cred
operator|.
name|oa_flavor
operator|!=
name|RPCSEC_GSS
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|cc
operator|=
name|req
operator|->
name|rq_clntcred
expr_stmt|;
name|client
operator|=
name|cc
operator|->
name|cc_client
expr_stmt|;
if|if
condition|(
name|flavorp
condition|)
operator|*
name|flavorp
operator|=
name|client
operator|->
name|cl_rpcflavor
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_cred
condition|)
block|{
operator|*
name|crp
operator|=
name|crhold
argument_list|(
name|client
operator|->
name|cl_cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|uc
operator|=
operator|&
name|client
operator|->
name|cl_ucred
expr_stmt|;
name|cr
operator|=
name|client
operator|->
name|cl_cred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|cr
operator|->
name|cr_uid
operator|=
name|cr
operator|->
name|cr_ruid
operator|=
name|cr
operator|->
name|cr_svuid
operator|=
name|uc
operator|->
name|uid
expr_stmt|;
name|cr
operator|->
name|cr_rgid
operator|=
name|cr
operator|->
name|cr_svgid
operator|=
name|uc
operator|->
name|gid
expr_stmt|;
name|crsetgroups
argument_list|(
name|cr
argument_list|,
name|uc
operator|->
name|gidlen
argument_list|,
name|uc
operator|->
name|gidlist
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_prison
operator|=
operator|&
name|prison0
expr_stmt|;
name|prison_hold
argument_list|(
name|cr
operator|->
name|cr_prison
argument_list|)
expr_stmt|;
operator|*
name|crp
operator|=
name|crhold
argument_list|(
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rpc_gss_svc_max_data_length
parameter_list|(
name|struct
name|svc_req
modifier|*
name|req
parameter_list|,
name|int
name|max_tp_unit_len
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_cookedcred
modifier|*
name|cc
init|=
name|req
operator|->
name|rq_clntcred
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
init|=
name|cc
operator|->
name|cc_client
decl_stmt|;
name|int
name|want_conf
decl_stmt|;
name|OM_uint32
name|max
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|int
name|result
decl_stmt|;
switch|switch
condition|(
name|client
operator|->
name|cl_rawcred
operator|.
name|service
condition|)
block|{
case|case
name|rpc_gss_svc_none
case|:
return|return
operator|(
name|max_tp_unit_len
operator|)
return|;
break|break;
case|case
name|rpc_gss_svc_default
case|:
case|case
name|rpc_gss_svc_integrity
case|:
name|want_conf
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|rpc_gss_svc_privacy
case|:
name|want_conf
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|maj_stat
operator|=
name|gss_wrap_size_limit
argument_list|(
operator|&
name|min_stat
argument_list|,
name|client
operator|->
name|cl_ctx
argument_list|,
name|want_conf
argument_list|,
name|client
operator|->
name|cl_qop
argument_list|,
name|max_tp_unit_len
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|max
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_wrap_size_limit"
argument_list|,
name|client
operator|->
name|cl_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|svc_rpc_gss_client
modifier|*
name|svc_rpc_gss_find_client
parameter_list|(
name|struct
name|svc_rpc_gss_clientid
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|struct
name|svc_rpc_gss_client_list
modifier|*
name|list
decl_stmt|;
name|unsigned
name|long
name|hostid
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_find_client(%d)"
argument_list|,
name|id
operator|->
name|ci_id
argument_list|)
expr_stmt|;
name|getcredhostid
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|ci_hostid
operator|!=
name|hostid
operator|||
name|id
operator|->
name|ci_boottime
operator|!=
name|boottime
operator|.
name|tv_sec
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|list
operator|=
operator|&
name|svc_rpc_gss_client_hash
index|[
name|id
operator|->
name|ci_id
operator|%
name|CLIENT_HASH_SIZE
index|]
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|client
argument_list|,
argument|list
argument_list|,
argument|cl_link
argument_list|)
block|{
if|if
condition|(
name|client
operator|->
name|cl_id
operator|.
name|ci_id
operator|==
name|id
operator|->
name|ci_id
condition|)
block|{
comment|/* 			 * Move this client to the front of the LRU 			 * list. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|svc_rpc_gss_clients
argument_list|,
name|client
argument_list|,
name|cl_alllink
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|svc_rpc_gss_clients
argument_list|,
name|client
argument_list|,
name|cl_alllink
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|client
operator|->
name|cl_refs
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|client
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|svc_rpc_gss_client
modifier|*
name|svc_rpc_gss_create_client
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|struct
name|svc_rpc_gss_client_list
modifier|*
name|list
decl_stmt|;
name|unsigned
name|long
name|hostid
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_create_client()"
argument_list|)
expr_stmt|;
name|client
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|svc_rpc_gss_client
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|client
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|svc_rpc_gss_client
argument_list|)
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|client
operator|->
name|cl_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|,
literal|"GSS-client"
argument_list|)
expr_stmt|;
name|getcredhostid
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
name|client
operator|->
name|cl_id
operator|.
name|ci_hostid
operator|=
name|hostid
expr_stmt|;
name|client
operator|->
name|cl_id
operator|.
name|ci_boottime
operator|=
name|boottime
operator|.
name|tv_sec
expr_stmt|;
name|client
operator|->
name|cl_id
operator|.
name|ci_id
operator|=
name|svc_rpc_gss_next_clientid
operator|++
expr_stmt|;
name|list
operator|=
operator|&
name|svc_rpc_gss_client_hash
index|[
name|client
operator|->
name|cl_id
operator|.
name|ci_id
operator|%
name|CLIENT_HASH_SIZE
index|]
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|client
argument_list|,
name|cl_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|svc_rpc_gss_clients
argument_list|,
name|client
argument_list|,
name|cl_alllink
argument_list|)
expr_stmt|;
name|svc_rpc_gss_client_count
operator|++
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Start the client off with a short expiration time. We will 	 * try to get a saner value from the client creds later. 	 */
name|client
operator|->
name|cl_state
operator|=
name|CLIENT_NEW
expr_stmt|;
name|client
operator|->
name|cl_locked
operator|=
name|FALSE
expr_stmt|;
name|client
operator|->
name|cl_expiration
operator|=
name|time_uptime
operator|+
literal|5
operator|*
literal|60
expr_stmt|;
return|return
operator|(
name|client
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svc_rpc_gss_destroy_client
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|)
block|{
name|OM_uint32
name|min_stat
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_destroy_client()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_ctx
condition|)
name|gss_delete_sec_context
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|client
operator|->
name|cl_ctx
argument_list|,
name|GSS_C_NO_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_cname
condition|)
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|client
operator|->
name|cl_cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
condition|)
name|mem_free
argument_list|(
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
argument_list|)
operator|+
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_cred
condition|)
name|crfree
argument_list|(
name|client
operator|->
name|cl_cred
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drop a reference to a client and free it if that was the last reference.  */
end_comment

begin_function
specifier|static
name|void
name|svc_rpc_gss_release_client
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|)
block|{
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|client
operator|->
name|cl_refs
argument_list|)
condition|)
return|return;
name|svc_rpc_gss_destroy_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a client from our global lists.  * Must be called with svc_rpc_gss_lock held.  */
end_comment

begin_function
specifier|static
name|void
name|svc_rpc_gss_forget_client_locked
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_client_list
modifier|*
name|list
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|svc_rpc_gss_client_hash
index|[
name|client
operator|->
name|cl_id
operator|.
name|ci_id
operator|%
name|CLIENT_HASH_SIZE
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|list
argument_list|,
name|client
argument_list|,
name|cl_link
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|svc_rpc_gss_clients
argument_list|,
name|client
argument_list|,
name|cl_alllink
argument_list|)
expr_stmt|;
name|svc_rpc_gss_client_count
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a client from our global lists and free it if we can.  */
end_comment

begin_function
specifier|static
name|void
name|svc_rpc_gss_forget_client
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_client_list
modifier|*
name|list
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|tclient
decl_stmt|;
name|list
operator|=
operator|&
name|svc_rpc_gss_client_hash
index|[
name|client
operator|->
name|cl_id
operator|.
name|ci_id
operator|%
name|CLIENT_HASH_SIZE
index|]
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tclient
argument_list|,
argument|list
argument_list|,
argument|cl_link
argument_list|)
block|{
comment|/* 		 * Make sure this client has not already been removed 		 * from the lists by svc_rpc_gss_forget_client() or 		 * svc_rpc_gss_forget_client_locked(). 		 */
if|if
condition|(
name|client
operator|==
name|tclient
condition|)
block|{
name|svc_rpc_gss_forget_client_locked
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|svc_rpc_gss_release_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|svc_rpc_gss_timeout_clients
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|time_t
name|now
init|=
name|time_uptime
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_timeout_clients()"
argument_list|)
expr_stmt|;
comment|/* 	 * First enforce the max client limit. We keep 	 * svc_rpc_gss_clients in LRU order. 	 */
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|client
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|svc_rpc_gss_clients
argument_list|,
name|svc_rpc_gss_client_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|svc_rpc_gss_client_count
operator|>
name|CLIENT_MAX
operator|&&
name|client
operator|!=
name|NULL
condition|)
block|{
name|svc_rpc_gss_forget_client_locked
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|svc_rpc_gss_release_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|client
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|svc_rpc_gss_clients
argument_list|,
name|svc_rpc_gss_client_list
argument_list|)
expr_stmt|;
block|}
name|again
label|:
name|TAILQ_FOREACH
argument_list|(
argument|client
argument_list|,
argument|&svc_rpc_gss_clients
argument_list|,
argument|cl_alllink
argument_list|)
block|{
if|if
condition|(
name|client
operator|->
name|cl_state
operator|==
name|CLIENT_STALE
operator|||
name|now
operator|>
name|client
operator|->
name|cl_expiration
condition|)
block|{
name|svc_rpc_gss_forget_client_locked
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"expiring client %p"
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|svc_rpc_gss_release_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * OID<->string routines.  These are uuuuugly.  */
end_comment

begin_function
specifier|static
name|OM_uint32
name|gss_oid_to_str
parameter_list|(
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_OID
name|oid
parameter_list|,
name|gss_buffer_t
name|oid_str
parameter_list|)
block|{
name|char
name|numstr
index|[
literal|128
index|]
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|;
name|int
name|numshift
decl_stmt|;
name|size_t
name|string_length
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
comment|/* Decoded according to krb5/gssapi_krb5.c */
comment|/* First determine the size of the string */
name|string_length
operator|=
literal|0
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|numshift
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|oid
operator|->
name|elements
expr_stmt|;
name|number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%ld "
argument_list|,
name|number
operator|/
literal|40
argument_list|)
expr_stmt|;
name|string_length
operator|+=
name|strlen
argument_list|(
name|numstr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%ld "
argument_list|,
name|number
operator|%
literal|40
argument_list|)
expr_stmt|;
name|string_length
operator|+=
name|strlen
argument_list|(
name|numstr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|oid
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|numshift
operator|+
literal|7
argument_list|)
operator|<
operator|(
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|*
literal|8
operator|)
condition|)
block|{
name|number
operator|=
operator|(
name|number
operator|<<
literal|7
operator|)
operator||
operator|(
name|cp
index|[
name|i
index|]
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|numshift
operator|+=
literal|7
expr_stmt|;
block|}
else|else
block|{
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cp
index|[
name|i
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%ld "
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|string_length
operator|+=
name|strlen
argument_list|(
name|numstr
argument_list|)
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|numshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If we get here, we've calculated the length of "n n n ... n ".  Add 4 	 * here for "{ " and "}\0". 	 */
name|string_length
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|mem_alloc
argument_list|(
name|string_length
argument_list|)
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
name|number
operator|=
operator|(
name|unsigned
name|long
operator|)
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%ld "
argument_list|,
name|number
operator|/
literal|40
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bp
argument_list|,
name|numstr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%ld "
argument_list|,
name|number
operator|%
literal|40
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bp
argument_list|,
name|numstr
argument_list|)
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|oid
operator|->
name|elements
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|oid
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|number
operator|=
operator|(
name|number
operator|<<
literal|7
operator|)
operator||
operator|(
name|cp
index|[
name|i
index|]
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
index|[
name|i
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%ld "
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bp
argument_list|,
name|numstr
argument_list|)
expr_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|bp
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|oid_str
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|oid_str
operator|->
name|value
operator|=
operator|(
name|void
operator|*
operator|)
name|bp
expr_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|svc_rpc_gss_build_ucred
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|,
specifier|const
name|gss_name_t
name|name
parameter_list|)
block|{
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|rpc_gss_ucred_t
modifier|*
name|uc
init|=
operator|&
name|client
operator|->
name|cl_ucred
decl_stmt|;
name|int
name|numgroups
decl_stmt|;
name|uc
operator|->
name|uid
operator|=
literal|65534
expr_stmt|;
name|uc
operator|->
name|gid
operator|=
literal|65534
expr_stmt|;
name|uc
operator|->
name|gidlist
operator|=
name|client
operator|->
name|cl_gid_storage
expr_stmt|;
name|numgroups
operator|=
name|RPCAUTH_UNIXGIDS
expr_stmt|;
name|maj_stat
operator|=
name|gss_pname_to_unix_cred
argument_list|(
operator|&
name|min_stat
argument_list|,
name|name
argument_list|,
name|client
operator|->
name|cl_mech
argument_list|,
operator|&
name|uc
operator|->
name|uid
argument_list|,
operator|&
name|uc
operator|->
name|gid
argument_list|,
operator|&
name|numgroups
argument_list|,
operator|&
name|uc
operator|->
name|gidlist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|maj_stat
argument_list|)
condition|)
name|uc
operator|->
name|gidlen
operator|=
literal|0
expr_stmt|;
else|else
name|uc
operator|->
name|gidlen
operator|=
name|numgroups
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|svc_rpc_gss_set_flavor
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|)
block|{
specifier|static
name|gss_OID_desc
name|krb5_mech_oid
init|=
block|{
literal|9
block|,
operator|(
name|void
operator|*
operator|)
literal|"\x2a\x86\x48\x86\xf7\x12\x01\x02\x02"
block|}
decl_stmt|;
comment|/* 	 * Attempt to translate mech type and service into a 	 * 'pseudo flavor'. Hardwire in krb5 support for now. 	 */
if|if
condition|(
name|kgss_oid_equal
argument_list|(
name|client
operator|->
name|cl_mech
argument_list|,
operator|&
name|krb5_mech_oid
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|client
operator|->
name|cl_rawcred
operator|.
name|service
condition|)
block|{
case|case
name|rpc_gss_svc_default
case|:
case|case
name|rpc_gss_svc_none
case|:
name|client
operator|->
name|cl_rpcflavor
operator|=
name|RPCSEC_GSS_KRB5
expr_stmt|;
break|break;
case|case
name|rpc_gss_svc_integrity
case|:
name|client
operator|->
name|cl_rpcflavor
operator|=
name|RPCSEC_GSS_KRB5I
expr_stmt|;
break|break;
case|case
name|rpc_gss_svc_privacy
case|:
name|client
operator|->
name|cl_rpcflavor
operator|=
name|RPCSEC_GSS_KRB5P
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|client
operator|->
name|cl_rpcflavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool_t
name|svc_rpc_gss_accept_sec_context
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqst
parameter_list|,
name|struct
name|rpc_gss_init_res
modifier|*
name|gr
parameter_list|,
name|struct
name|rpc_gss_cred
modifier|*
name|gc
parameter_list|)
block|{
name|gss_buffer_desc
name|recv_tok
decl_stmt|;
name|gss_OID
name|mech
decl_stmt|;
name|OM_uint32
name|maj_stat
init|=
literal|0
decl_stmt|,
name|min_stat
init|=
literal|0
decl_stmt|,
name|ret_flags
decl_stmt|;
name|OM_uint32
name|cred_lifetime
decl_stmt|;
name|struct
name|svc_rpc_gss_svc_name
modifier|*
name|sname
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_accept_context()"
argument_list|)
expr_stmt|;
comment|/* Deserialize arguments. */
name|memset
argument_list|(
operator|&
name|recv_tok
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|recv_tok
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|rqst
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|recv_tok
argument_list|)
condition|)
block|{
name|client
operator|->
name|cl_state
operator|=
name|CLIENT_STALE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * First time round, try all the server names we have until 	 * one matches. Afterwards, stick with that one. 	 */
name|sx_xlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|cl_sname
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|sname
argument_list|,
argument|&svc_rpc_gss_svc_names
argument_list|,
argument|sn_link
argument_list|)
block|{
if|if
condition|(
name|sname
operator|->
name|sn_program
operator|==
name|rqst
operator|->
name|rq_prog
operator|&&
name|sname
operator|->
name|sn_version
operator|==
name|rqst
operator|->
name|rq_vers
condition|)
block|{
name|retry
label|:
name|gr
operator|->
name|gr_major
operator|=
name|gss_accept_sec_context
argument_list|(
operator|&
name|gr
operator|->
name|gr_minor
argument_list|,
operator|&
name|client
operator|->
name|cl_ctx
argument_list|,
name|sname
operator|->
name|sn_cred
argument_list|,
operator|&
name|recv_tok
argument_list|,
name|GSS_C_NO_CHANNEL_BINDINGS
argument_list|,
operator|&
name|client
operator|->
name|cl_cname
argument_list|,
operator|&
name|mech
argument_list|,
operator|&
name|gr
operator|->
name|gr_token
argument_list|,
operator|&
name|ret_flags
argument_list|,
operator|&
name|cred_lifetime
argument_list|,
operator|&
name|client
operator|->
name|cl_creds
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_major
operator|==
name|GSS_S_CREDENTIALS_EXPIRED
condition|)
block|{
comment|/* 					 * Either our creds really did 					 * expire or gssd was 					 * restarted. 					 */
if|if
condition|(
name|rpc_gss_acquire_svc_cred
argument_list|(
name|sname
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
name|client
operator|->
name|cl_sname
operator|=
name|sname
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|sname
condition|)
block|{
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|recv_tok
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
name|gr
operator|->
name|gr_major
operator|=
name|gss_accept_sec_context
argument_list|(
operator|&
name|gr
operator|->
name|gr_minor
argument_list|,
operator|&
name|client
operator|->
name|cl_ctx
argument_list|,
name|client
operator|->
name|cl_sname
operator|->
name|sn_cred
argument_list|,
operator|&
name|recv_tok
argument_list|,
name|GSS_C_NO_CHANNEL_BINDINGS
argument_list|,
operator|&
name|client
operator|->
name|cl_cname
argument_list|,
operator|&
name|mech
argument_list|,
operator|&
name|gr
operator|->
name|gr_token
argument_list|,
operator|&
name|ret_flags
argument_list|,
operator|&
name|cred_lifetime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|svc_rpc_gss_lock
argument_list|)
expr_stmt|;
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|recv_tok
argument_list|)
expr_stmt|;
comment|/* 	 * If we get an error from gss_accept_sec_context, send the 	 * reply anyway so that the client gets a chance to see what 	 * is wrong. 	 */
if|if
condition|(
name|gr
operator|->
name|gr_major
operator|!=
name|GSS_S_COMPLETE
operator|&&
name|gr
operator|->
name|gr_major
operator|!=
name|GSS_S_CONTINUE_NEEDED
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"accept_sec_context"
argument_list|,
name|client
operator|->
name|cl_mech
argument_list|,
name|gr
operator|->
name|gr_major
argument_list|,
name|gr
operator|->
name|gr_minor
argument_list|)
expr_stmt|;
name|client
operator|->
name|cl_state
operator|=
name|CLIENT_STALE
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|gr
operator|->
name|gr_handle
operator|.
name|value
operator|=
operator|&
name|client
operator|->
name|cl_id
expr_stmt|;
name|gr
operator|->
name|gr_handle
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|client
operator|->
name|cl_id
argument_list|)
expr_stmt|;
name|gr
operator|->
name|gr_win
operator|=
name|SVC_RPC_GSS_SEQWINDOW
expr_stmt|;
comment|/* Save client info. */
name|client
operator|->
name|cl_mech
operator|=
name|mech
expr_stmt|;
name|client
operator|->
name|cl_qop
operator|=
name|GSS_C_QOP_DEFAULT
expr_stmt|;
name|client
operator|->
name|cl_done_callback
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_major
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_buffer_desc
name|export_name
decl_stmt|;
comment|/* 		 * Change client expiration time to be near when the 		 * client creds expire (or 24 hours if we can't figure 		 * that out). 		 */
if|if
condition|(
name|cred_lifetime
operator|==
name|GSS_C_INDEFINITE
condition|)
name|cred_lifetime
operator|=
name|time_uptime
operator|+
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|client
operator|->
name|cl_expiration
operator|=
name|time_uptime
operator|+
name|cred_lifetime
expr_stmt|;
comment|/* 		 * Fill in cred details in the rawcred structure. 		 */
name|client
operator|->
name|cl_rawcred
operator|.
name|version
operator|=
name|RPCSEC_GSS_VERSION
expr_stmt|;
name|rpc_gss_oid_to_mech
argument_list|(
name|mech
argument_list|,
operator|&
name|client
operator|->
name|cl_rawcred
operator|.
name|mechanism
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_export_name
argument_list|(
operator|&
name|min_stat
argument_list|,
name|client
operator|->
name|cl_cname
argument_list|,
operator|&
name|export_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_export_name"
argument_list|,
name|client
operator|->
name|cl_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
argument_list|)
operator|+
name|export_name
operator|.
name|length
argument_list|)
expr_stmt|;
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
operator|->
name|len
operator|=
name|export_name
operator|.
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
operator|->
name|name
argument_list|,
name|export_name
operator|.
name|value
argument_list|,
name|export_name
operator|.
name|length
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|export_name
argument_list|)
expr_stmt|;
name|client
operator|->
name|cl_rawcred
operator|.
name|svc_principal
operator|=
name|client
operator|->
name|cl_sname
operator|->
name|sn_principal
expr_stmt|;
name|client
operator|->
name|cl_rawcred
operator|.
name|service
operator|=
name|gc
operator|->
name|gc_svc
expr_stmt|;
comment|/* 		 * Use gss_pname_to_uid to map to unix creds. For 		 * kerberos5, this uses krb5_aname_to_localname. 		 */
name|svc_rpc_gss_build_ucred
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|cl_cname
argument_list|)
expr_stmt|;
name|svc_rpc_gss_set_flavor
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|client
operator|->
name|cl_cname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|gss_buffer_desc
name|mechname
decl_stmt|;
name|gss_oid_to_str
argument_list|(
operator|&
name|min_stat
argument_list|,
name|mech
argument_list|,
operator|&
name|mechname
argument_list|)
expr_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"accepted context for %s with "
literal|"<mech %.*s, qop %d, svc %d>"
argument_list|,
name|client
operator|->
name|cl_rawcred
operator|.
name|client_principal
operator|->
name|name
argument_list|,
name|mechname
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mechname
operator|.
name|value
argument_list|,
name|client
operator|->
name|cl_qop
argument_list|,
name|client
operator|->
name|cl_rawcred
operator|.
name|service
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|mechname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|svc_rpc_gss_validate
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|,
name|struct
name|rpc_msg
modifier|*
name|msg
parameter_list|,
name|gss_qop_t
modifier|*
name|qop
parameter_list|,
name|rpc_gss_proc_t
name|gcproc
parameter_list|)
block|{
name|struct
name|opaque_auth
modifier|*
name|oa
decl_stmt|;
name|gss_buffer_desc
name|rpcbuf
decl_stmt|,
name|checksum
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|gss_qop_t
name|qop_state
decl_stmt|;
name|int32_t
name|rpchdr
index|[
literal|128
operator|/
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
index|]
decl_stmt|;
name|int32_t
modifier|*
name|buf
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_validate()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rpchdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rpchdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reconstruct RPC header for signing (from xdr_callmsg). */
name|buf
operator|=
name|rpchdr
expr_stmt|;
name|IXDR_PUT_LONG
argument_list|(
name|buf
argument_list|,
name|msg
operator|->
name|rm_xid
argument_list|)
expr_stmt|;
name|IXDR_PUT_ENUM
argument_list|(
name|buf
argument_list|,
name|msg
operator|->
name|rm_direction
argument_list|)
expr_stmt|;
name|IXDR_PUT_LONG
argument_list|(
name|buf
argument_list|,
name|msg
operator|->
name|rm_call
operator|.
name|cb_rpcvers
argument_list|)
expr_stmt|;
name|IXDR_PUT_LONG
argument_list|(
name|buf
argument_list|,
name|msg
operator|->
name|rm_call
operator|.
name|cb_prog
argument_list|)
expr_stmt|;
name|IXDR_PUT_LONG
argument_list|(
name|buf
argument_list|,
name|msg
operator|->
name|rm_call
operator|.
name|cb_vers
argument_list|)
expr_stmt|;
name|IXDR_PUT_LONG
argument_list|(
name|buf
argument_list|,
name|msg
operator|->
name|rm_call
operator|.
name|cb_proc
argument_list|)
expr_stmt|;
name|oa
operator|=
operator|&
name|msg
operator|->
name|rm_call
operator|.
name|cb_cred
expr_stmt|;
name|IXDR_PUT_ENUM
argument_list|(
name|buf
argument_list|,
name|oa
operator|->
name|oa_flavor
argument_list|)
expr_stmt|;
name|IXDR_PUT_LONG
argument_list|(
name|buf
argument_list|,
name|oa
operator|->
name|oa_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|oa
operator|->
name|oa_length
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|oa
operator|->
name|oa_base
argument_list|,
name|oa
operator|->
name|oa_length
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|RNDUP
argument_list|(
name|oa
operator|->
name|oa_length
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
block|}
name|rpcbuf
operator|.
name|value
operator|=
name|rpchdr
expr_stmt|;
name|rpcbuf
operator|.
name|length
operator|=
operator|(
name|u_char
operator|*
operator|)
name|buf
operator|-
operator|(
name|u_char
operator|*
operator|)
name|rpchdr
expr_stmt|;
name|checksum
operator|.
name|value
operator|=
name|msg
operator|->
name|rm_call
operator|.
name|cb_verf
operator|.
name|oa_base
expr_stmt|;
name|checksum
operator|.
name|length
operator|=
name|msg
operator|->
name|rm_call
operator|.
name|cb_verf
operator|.
name|oa_length
expr_stmt|;
name|maj_stat
operator|=
name|gss_verify_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|client
operator|->
name|cl_ctx
argument_list|,
operator|&
name|rpcbuf
argument_list|,
operator|&
name|checksum
argument_list|,
operator|&
name|qop_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_verify_mic"
argument_list|,
name|client
operator|->
name|cl_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
comment|/* 		 * A bug in some versions of the Linux client generates a 		 * Destroy operation with a bogus encrypted checksum. Deleting 		 * the credential handle for that case causes the mount to fail. 		 * Since the checksum is bogus (gss_verify_mic() failed), it 		 * doesn't make sense to destroy the handle and not doing so 		 * fixes the Linux mount. 		 */
if|if
condition|(
name|gcproc
operator|!=
name|RPCSEC_GSS_DESTROY
condition|)
name|client
operator|->
name|cl_state
operator|=
name|CLIENT_STALE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|qop
operator|=
name|qop_state
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|svc_rpc_gss_nextverf
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqst
parameter_list|,
name|u_int
name|seq
parameter_list|)
block|{
name|gss_buffer_desc
name|signbuf
decl_stmt|;
name|gss_buffer_desc
name|mic
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|uint32_t
name|nseq
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_nextverf()"
argument_list|)
expr_stmt|;
name|nseq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|signbuf
operator|.
name|value
operator|=
operator|&
name|nseq
expr_stmt|;
name|signbuf
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|nseq
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_get_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|client
operator|->
name|cl_ctx
argument_list|,
name|client
operator|->
name|cl_qop
argument_list|,
operator|&
name|signbuf
argument_list|,
operator|&
name|mic
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_get_mic"
argument_list|,
name|client
operator|->
name|cl_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
name|client
operator|->
name|cl_state
operator|=
name|CLIENT_STALE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|mic
operator|.
name|length
operator|<=
name|MAX_AUTH_BYTES
argument_list|,
operator|(
literal|"MIC too large for RPCSEC_GSS"
operator|)
argument_list|)
expr_stmt|;
name|rqst
operator|->
name|rq_verf
operator|.
name|oa_flavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
name|rqst
operator|->
name|rq_verf
operator|.
name|oa_length
operator|=
name|mic
operator|.
name|length
expr_stmt|;
name|bcopy
argument_list|(
name|mic
operator|.
name|value
argument_list|,
name|rqst
operator|->
name|rq_verf
operator|.
name|oa_base
argument_list|,
name|mic
operator|.
name|length
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|mic
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|svc_rpc_gss_callback
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqst
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_callback
modifier|*
name|scb
decl_stmt|;
name|rpc_gss_lock_t
name|lock
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|bool_t
name|cb_res
decl_stmt|;
name|bool_t
name|result
decl_stmt|;
comment|/* 	 * See if we have a callback for this guy. 	 */
name|result
operator|=
name|TRUE
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|scb
argument_list|,
argument|&svc_rpc_gss_callbacks
argument_list|,
argument|cb_link
argument_list|)
block|{
if|if
condition|(
name|scb
operator|->
name|cb_callback
operator|.
name|program
operator|==
name|rqst
operator|->
name|rq_prog
operator|&&
name|scb
operator|->
name|cb_callback
operator|.
name|version
operator|==
name|rqst
operator|->
name|rq_vers
condition|)
block|{
comment|/* 			 * This one matches. Call the callback and see 			 * if it wants to veto or something. 			 */
name|lock
operator|.
name|locked
operator|=
name|FALSE
expr_stmt|;
name|lock
operator|.
name|raw_cred
operator|=
operator|&
name|client
operator|->
name|cl_rawcred
expr_stmt|;
name|cb_res
operator|=
name|scb
operator|->
name|cb_callback
operator|.
name|callback
argument_list|(
name|rqst
argument_list|,
name|client
operator|->
name|cl_creds
argument_list|,
name|client
operator|->
name|cl_ctx
argument_list|,
operator|&
name|lock
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb_res
condition|)
block|{
name|client
operator|->
name|cl_state
operator|=
name|CLIENT_STALE
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* 			 * The callback accepted the connection - it 			 * is responsible for freeing client->cl_creds 			 * now. 			 */
name|client
operator|->
name|cl_creds
operator|=
name|GSS_C_NO_CREDENTIAL
expr_stmt|;
name|client
operator|->
name|cl_locked
operator|=
name|lock
operator|.
name|locked
expr_stmt|;
name|client
operator|->
name|cl_cookie
operator|=
name|cookie
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* 	 * Either no callback exists for this program/version or one 	 * of the callbacks rejected the connection. We just need to 	 * clean up the delegated client creds, if any. 	 */
if|if
condition|(
name|client
operator|->
name|cl_creds
condition|)
block|{
name|OM_uint32
name|min_ver
decl_stmt|;
name|gss_release_cred
argument_list|(
operator|&
name|min_ver
argument_list|,
operator|&
name|client
operator|->
name|cl_creds
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|svc_rpc_gss_check_replay
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|u_int32_t
name|offset
decl_stmt|;
name|int
name|word
decl_stmt|,
name|bit
decl_stmt|;
name|bool_t
name|result
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|<=
name|client
operator|->
name|cl_seqlast
condition|)
block|{
comment|/* 		 * The request sequence number is less than 		 * the largest we have seen so far. If it is 		 * outside the window or if we have seen a 		 * request with this sequence before, silently 		 * discard it. 		 */
name|offset
operator|=
name|client
operator|->
name|cl_seqlast
operator|-
name|seq
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|SVC_RPC_GSS_SEQWINDOW
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|word
operator|=
name|offset
operator|/
literal|32
expr_stmt|;
name|bit
operator|=
name|offset
operator|%
literal|32
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_seqmask
index|[
name|word
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
condition|)
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|result
operator|=
name|TRUE
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svc_rpc_gss_update_seq
parameter_list|(
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|int
name|offset
decl_stmt|,
name|i
decl_stmt|,
name|word
decl_stmt|,
name|bit
decl_stmt|;
name|uint32_t
name|carry
decl_stmt|,
name|newcarry
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|>
name|client
operator|->
name|cl_seqlast
condition|)
block|{
comment|/* 		 * This request has a sequence number greater 		 * than any we have seen so far. Advance the 		 * seq window and set bit zero of the window 		 * (which corresponds to the new sequence 		 * number) 		 */
name|offset
operator|=
name|seq
operator|-
name|client
operator|->
name|cl_seqlast
expr_stmt|;
while|while
condition|(
name|offset
operator|>
literal|32
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|SVC_RPC_GSS_SEQWINDOW
operator|/
literal|32
operator|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|client
operator|->
name|cl_seqmask
index|[
name|i
index|]
operator|=
name|client
operator|->
name|cl_seqmask
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|client
operator|->
name|cl_seqmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|offset
operator|-=
literal|32
expr_stmt|;
block|}
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVC_RPC_GSS_SEQWINDOW
operator|/
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|newcarry
operator|=
name|client
operator|->
name|cl_seqmask
index|[
name|i
index|]
operator|>>
operator|(
literal|32
operator|-
name|offset
operator|)
expr_stmt|;
name|client
operator|->
name|cl_seqmask
index|[
name|i
index|]
operator|=
operator|(
name|client
operator|->
name|cl_seqmask
index|[
name|i
index|]
operator|<<
name|offset
operator|)
operator||
name|carry
expr_stmt|;
name|carry
operator|=
name|newcarry
expr_stmt|;
block|}
name|client
operator|->
name|cl_seqmask
index|[
literal|0
index|]
operator||=
literal|1
expr_stmt|;
name|client
operator|->
name|cl_seqlast
operator|=
name|seq
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|client
operator|->
name|cl_seqlast
operator|-
name|seq
expr_stmt|;
name|word
operator|=
name|offset
operator|/
literal|32
expr_stmt|;
name|bit
operator|=
name|offset
operator|%
literal|32
expr_stmt|;
name|client
operator|->
name|cl_seqmask
index|[
name|word
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|auth_stat
name|svc_rpc_gss
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqst
parameter_list|,
name|struct
name|rpc_msg
modifier|*
name|msg
parameter_list|)
block|{
name|OM_uint32
name|min_stat
decl_stmt|;
name|XDR
name|xdrs
decl_stmt|;
name|struct
name|svc_rpc_gss_cookedcred
modifier|*
name|cc
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|struct
name|rpc_gss_cred
name|gc
decl_stmt|;
name|struct
name|rpc_gss_init_res
name|gr
decl_stmt|;
name|gss_qop_t
name|qop
decl_stmt|;
name|int
name|call_stat
decl_stmt|;
name|enum
name|auth_stat
name|result
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss()"
argument_list|)
expr_stmt|;
comment|/* Garbage collect old clients. */
name|svc_rpc_gss_timeout_clients
argument_list|()
expr_stmt|;
comment|/* Initialize reply. */
name|rqst
operator|->
name|rq_verf
operator|=
name|_null_auth
expr_stmt|;
comment|/* Deserialize client credentials. */
if|if
condition|(
name|rqst
operator|->
name|rq_cred
operator|.
name|oa_length
operator|<=
literal|0
condition|)
return|return
operator|(
name|AUTH_BADCRED
operator|)
return|;
name|memset
argument_list|(
operator|&
name|gc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gc
argument_list|)
argument_list|)
expr_stmt|;
name|xdrmem_create
argument_list|(
operator|&
name|xdrs
argument_list|,
name|rqst
operator|->
name|rq_cred
operator|.
name|oa_base
argument_list|,
name|rqst
operator|->
name|rq_cred
operator|.
name|oa_length
argument_list|,
name|XDR_DECODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_rpc_gss_cred
argument_list|(
operator|&
name|xdrs
argument_list|,
operator|&
name|gc
argument_list|)
condition|)
block|{
name|XDR_DESTROY
argument_list|(
operator|&
name|xdrs
argument_list|)
expr_stmt|;
return|return
operator|(
name|AUTH_BADCRED
operator|)
return|;
block|}
name|XDR_DESTROY
argument_list|(
operator|&
name|xdrs
argument_list|)
expr_stmt|;
name|client
operator|=
name|NULL
expr_stmt|;
comment|/* Check version. */
if|if
condition|(
name|gc
operator|.
name|gc_version
operator|!=
name|RPCSEC_GSS_VERSION
condition|)
block|{
name|result
operator|=
name|AUTH_BADCRED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check the proc and find the client (or create it) */
if|if
condition|(
name|gc
operator|.
name|gc_proc
operator|==
name|RPCSEC_GSS_INIT
condition|)
block|{
if|if
condition|(
name|gc
operator|.
name|gc_handle
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|AUTH_BADCRED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|client
operator|=
name|svc_rpc_gss_create_client
argument_list|()
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|client
operator|->
name|cl_refs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|svc_rpc_gss_clientid
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|gc
operator|.
name|gc_handle
operator|.
name|length
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|result
operator|=
name|AUTH_BADCRED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|p
operator|=
name|gc
operator|.
name|gc_handle
operator|.
name|value
expr_stmt|;
name|client
operator|=
name|svc_rpc_gss_find_client
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
block|{
comment|/* 			 * Can't find the client - we may have 			 * destroyed it - tell the other side to 			 * re-authenticate. 			 */
name|result
operator|=
name|RPCSEC_GSS_CREDPROBLEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|cc
operator|=
name|rqst
operator|->
name|rq_clntcred
expr_stmt|;
name|cc
operator|->
name|cc_client
operator|=
name|client
expr_stmt|;
name|cc
operator|->
name|cc_service
operator|=
name|gc
operator|.
name|gc_svc
expr_stmt|;
name|cc
operator|->
name|cc_seq
operator|=
name|gc
operator|.
name|gc_seq
expr_stmt|;
comment|/* 	 * The service and sequence number must be ignored for 	 * RPCSEC_GSS_INIT and RPCSEC_GSS_CONTINUE_INIT. 	 */
if|if
condition|(
name|gc
operator|.
name|gc_proc
operator|!=
name|RPCSEC_GSS_INIT
operator|&&
name|gc
operator|.
name|gc_proc
operator|!=
name|RPCSEC_GSS_CONTINUE_INIT
condition|)
block|{
comment|/* 		 * Check for sequence number overflow. 		 */
if|if
condition|(
name|gc
operator|.
name|gc_seq
operator|>=
name|MAXSEQ
condition|)
block|{
name|result
operator|=
name|RPCSEC_GSS_CTXPROBLEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Check for valid service. 		 */
if|if
condition|(
name|gc
operator|.
name|gc_svc
operator|!=
name|rpc_gss_svc_none
operator|&&
name|gc
operator|.
name|gc_svc
operator|!=
name|rpc_gss_svc_integrity
operator|&&
name|gc
operator|.
name|gc_svc
operator|!=
name|rpc_gss_svc_privacy
condition|)
block|{
name|result
operator|=
name|AUTH_BADCRED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Handle RPCSEC_GSS control procedure. */
switch|switch
condition|(
name|gc
operator|.
name|gc_proc
condition|)
block|{
case|case
name|RPCSEC_GSS_INIT
case|:
case|case
name|RPCSEC_GSS_CONTINUE_INIT
case|:
if|if
condition|(
name|rqst
operator|->
name|rq_proc
operator|!=
name|NULLPROC
condition|)
block|{
name|result
operator|=
name|AUTH_REJECTEDCRED
expr_stmt|;
break|break;
block|}
name|memset
argument_list|(
operator|&
name|gr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_rpc_gss_accept_sec_context
argument_list|(
name|client
argument_list|,
name|rqst
argument_list|,
operator|&
name|gr
argument_list|,
operator|&
name|gc
argument_list|)
condition|)
block|{
name|result
operator|=
name|AUTH_REJECTEDCRED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gr
operator|.
name|gr_major
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
comment|/* 			 * We borrow the space for the call verf to 			 * pack our reply verf. 			 */
name|rqst
operator|->
name|rq_verf
operator|=
name|msg
operator|->
name|rm_call
operator|.
name|cb_verf
expr_stmt|;
if|if
condition|(
operator|!
name|svc_rpc_gss_nextverf
argument_list|(
name|client
argument_list|,
name|rqst
argument_list|,
name|gr
operator|.
name|gr_win
argument_list|)
condition|)
block|{
name|result
operator|=
name|AUTH_REJECTEDCRED
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|rqst
operator|->
name|rq_verf
operator|=
name|_null_auth
expr_stmt|;
block|}
name|call_stat
operator|=
name|svc_sendreply
argument_list|(
name|rqst
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_rpc_gss_init_res
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gr
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gr
operator|.
name|gr_token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|call_stat
condition|)
block|{
name|result
operator|=
name|AUTH_FAILED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gr
operator|.
name|gr_major
operator|==
name|GSS_S_COMPLETE
condition|)
name|client
operator|->
name|cl_state
operator|=
name|CLIENT_ESTABLISHED
expr_stmt|;
name|result
operator|=
name|RPCSEC_GSS_NODISPATCH
expr_stmt|;
break|break;
case|case
name|RPCSEC_GSS_DATA
case|:
case|case
name|RPCSEC_GSS_DESTROY
case|:
if|if
condition|(
operator|!
name|svc_rpc_gss_check_replay
argument_list|(
name|client
argument_list|,
name|gc
operator|.
name|gc_seq
argument_list|)
condition|)
block|{
name|result
operator|=
name|RPCSEC_GSS_NODISPATCH
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|svc_rpc_gss_validate
argument_list|(
name|client
argument_list|,
name|msg
argument_list|,
operator|&
name|qop
argument_list|,
name|gc
operator|.
name|gc_proc
argument_list|)
condition|)
block|{
name|result
operator|=
name|RPCSEC_GSS_CREDPROBLEM
expr_stmt|;
break|break;
block|}
comment|/* 		 * We borrow the space for the call verf to pack our 		 * reply verf. 		 */
name|rqst
operator|->
name|rq_verf
operator|=
name|msg
operator|->
name|rm_call
operator|.
name|cb_verf
expr_stmt|;
if|if
condition|(
operator|!
name|svc_rpc_gss_nextverf
argument_list|(
name|client
argument_list|,
name|rqst
argument_list|,
name|gc
operator|.
name|gc_seq
argument_list|)
condition|)
block|{
name|result
operator|=
name|RPCSEC_GSS_CTXPROBLEM
expr_stmt|;
break|break;
block|}
name|svc_rpc_gss_update_seq
argument_list|(
name|client
argument_list|,
name|gc
operator|.
name|gc_seq
argument_list|)
expr_stmt|;
comment|/* 		 * Change the SVCAUTH ops on the request to point at 		 * our own code so that we can unwrap the arguments 		 * and wrap the result. The caller will re-set this on 		 * every request to point to a set of null wrap/unwrap 		 * methods. Acquire an extra reference to the client 		 * which will be released by svc_rpc_gss_release() 		 * after the request has finished processing. 		 */
name|refcount_acquire
argument_list|(
operator|&
name|client
operator|->
name|cl_refs
argument_list|)
expr_stmt|;
name|rqst
operator|->
name|rq_auth
operator|.
name|svc_ah_ops
operator|=
operator|&
name|svc_auth_gss_ops
expr_stmt|;
name|rqst
operator|->
name|rq_auth
operator|.
name|svc_ah_private
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|gc
operator|.
name|gc_proc
operator|==
name|RPCSEC_GSS_DATA
condition|)
block|{
comment|/* 			 * We might be ready to do a callback to the server to 			 * see if it wants to accept/reject the connection. 			 */
name|sx_xlock
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|cl_done_callback
condition|)
block|{
name|client
operator|->
name|cl_done_callback
operator|=
name|TRUE
expr_stmt|;
name|client
operator|->
name|cl_qop
operator|=
name|qop
expr_stmt|;
name|client
operator|->
name|cl_rawcred
operator|.
name|qop
operator|=
name|_rpc_gss_num_to_qop
argument_list|(
name|client
operator|->
name|cl_rawcred
operator|.
name|mechanism
argument_list|,
name|qop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_rpc_gss_callback
argument_list|(
name|client
argument_list|,
name|rqst
argument_list|)
condition|)
block|{
name|result
operator|=
name|AUTH_REJECTEDCRED
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|client
operator|->
name|cl_lock
argument_list|)
expr_stmt|;
comment|/* 			 * If the server has locked this client to a 			 * particular service+qop pair, enforce that 			 * restriction now. 			 */
if|if
condition|(
name|client
operator|->
name|cl_locked
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|cl_rawcred
operator|.
name|service
operator|!=
name|gc
operator|.
name|gc_svc
condition|)
block|{
name|result
operator|=
name|AUTH_FAILED
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|client
operator|->
name|cl_qop
operator|!=
name|qop
condition|)
block|{
name|result
operator|=
name|AUTH_BADVERF
expr_stmt|;
break|break;
block|}
block|}
comment|/* 			 * If the qop changed, look up the new qop 			 * name for rawcred. 			 */
if|if
condition|(
name|client
operator|->
name|cl_qop
operator|!=
name|qop
condition|)
block|{
name|client
operator|->
name|cl_qop
operator|=
name|qop
expr_stmt|;
name|client
operator|->
name|cl_rawcred
operator|.
name|qop
operator|=
name|_rpc_gss_num_to_qop
argument_list|(
name|client
operator|->
name|cl_rawcred
operator|.
name|mechanism
argument_list|,
name|qop
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Make sure we use the right service value 			 * for unwrap/wrap. 			 */
if|if
condition|(
name|client
operator|->
name|cl_rawcred
operator|.
name|service
operator|!=
name|gc
operator|.
name|gc_svc
condition|)
block|{
name|client
operator|->
name|cl_rawcred
operator|.
name|service
operator|=
name|gc
operator|.
name|gc_svc
expr_stmt|;
name|svc_rpc_gss_set_flavor
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|AUTH_OK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rqst
operator|->
name|rq_proc
operator|!=
name|NULLPROC
condition|)
block|{
name|result
operator|=
name|AUTH_REJECTEDCRED
expr_stmt|;
break|break;
block|}
name|call_stat
operator|=
name|svc_sendreply
argument_list|(
name|rqst
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
operator|(
name|caddr_t
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|call_stat
condition|)
block|{
name|result
operator|=
name|AUTH_FAILED
expr_stmt|;
break|break;
block|}
name|svc_rpc_gss_forget_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|RPCSEC_GSS_NODISPATCH
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|result
operator|=
name|AUTH_BADCRED
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|client
condition|)
name|svc_rpc_gss_release_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_rpc_gss_cred
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gc
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|svc_rpc_gss_wrap
parameter_list|(
name|SVCAUTH
modifier|*
name|auth
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_cookedcred
modifier|*
name|cc
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_wrap()"
argument_list|)
expr_stmt|;
name|cc
operator|=
operator|(
expr|struct
name|svc_rpc_gss_cookedcred
operator|*
operator|)
name|auth
operator|->
name|svc_ah_private
expr_stmt|;
name|client
operator|=
name|cc
operator|->
name|cc_client
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_state
operator|!=
name|CLIENT_ESTABLISHED
operator|||
name|cc
operator|->
name|cc_service
operator|==
name|rpc_gss_svc_none
operator|||
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|xdr_rpc_gss_wrap_data
argument_list|(
name|mp
argument_list|,
name|client
operator|->
name|cl_ctx
argument_list|,
name|client
operator|->
name|cl_qop
argument_list|,
name|cc
operator|->
name|cc_service
argument_list|,
name|cc
operator|->
name|cc_seq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|svc_rpc_gss_unwrap
parameter_list|(
name|SVCAUTH
modifier|*
name|auth
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_cookedcred
modifier|*
name|cc
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_unwrap()"
argument_list|)
expr_stmt|;
name|cc
operator|=
operator|(
expr|struct
name|svc_rpc_gss_cookedcred
operator|*
operator|)
name|auth
operator|->
name|svc_ah_private
expr_stmt|;
name|client
operator|=
name|cc
operator|->
name|cc_client
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|cl_state
operator|!=
name|CLIENT_ESTABLISHED
operator|||
name|cc
operator|->
name|cc_service
operator|==
name|rpc_gss_svc_none
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|xdr_rpc_gss_unwrap_data
argument_list|(
name|mp
argument_list|,
name|client
operator|->
name|cl_ctx
argument_list|,
name|client
operator|->
name|cl_qop
argument_list|,
name|cc
operator|->
name|cc_service
argument_list|,
name|cc
operator|->
name|cc_seq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|svc_rpc_gss_release
parameter_list|(
name|SVCAUTH
modifier|*
name|auth
parameter_list|)
block|{
name|struct
name|svc_rpc_gss_cookedcred
modifier|*
name|cc
decl_stmt|;
name|struct
name|svc_rpc_gss_client
modifier|*
name|client
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in svc_rpc_gss_release()"
argument_list|)
expr_stmt|;
name|cc
operator|=
operator|(
expr|struct
name|svc_rpc_gss_cookedcred
operator|*
operator|)
name|auth
operator|->
name|svc_ah_private
expr_stmt|;
name|client
operator|=
name|cc
operator|->
name|cc_client
expr_stmt|;
name|svc_rpc_gss_release_client
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

