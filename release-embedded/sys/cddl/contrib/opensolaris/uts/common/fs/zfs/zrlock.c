begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_comment
comment|/*  * A Zero Reference Lock (ZRL) is a reference count that can lock out new  * references only when the count is zero and only without waiting if the count  * is not already zero. It is similar to a read-write lock in that it allows  * multiple readers and only a single writer, but it does not allow a writer to  * block while waiting for readers to exit, and therefore the question of  * reader/writer priority is moot (no WRWANT bit). Since the equivalent of  * rw_enter(&lock, RW_WRITER) is disallowed and only tryenter() is allowed, it  * is perfectly safe for the same reader to acquire the same lock multiple  * times. The fact that a ZRL is reentrant for readers (through multiple calls  * to zrl_add()) makes it convenient for determining whether something is  * actively referenced without the fuss of flagging lock ownership across  * function calls.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zrlock.h>
end_include

begin_comment
comment|/*  * A ZRL can be locked only while there are zero references, so ZRL_LOCKED is  * treated as zero references.  */
end_comment

begin_define
define|#
directive|define
name|ZRL_LOCKED
value|((uint32_t)-1)
end_define

begin_define
define|#
directive|define
name|ZRL_DESTROYED
value|-2
end_define

begin_function
name|void
name|zrl_init
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|zrl
operator|->
name|zr_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zrl
operator|->
name|zr_refcount
operator|=
literal|0
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zrl
operator|->
name|zr_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|zrl
operator|->
name|zr_owner
operator|=
name|NULL
expr_stmt|;
name|zrl
operator|->
name|zr_caller
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|zrl_destroy
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_refcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zrl
operator|->
name|zr_mtx
argument_list|)
expr_stmt|;
name|zrl
operator|->
name|zr_refcount
operator|=
name|ZRL_DESTROYED
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zrl
operator|->
name|zr_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|zrl_add_debug
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|,
specifier|const
name|char
modifier|*
name|zc
parameter_list|)
else|#
directive|else
function|zrl_add
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
endif|#
directive|endif
block|{
name|uint32_t
name|n
init|=
operator|(
name|uint32_t
operator|)
name|zrl
operator|->
name|zr_refcount
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|ZRL_LOCKED
condition|)
block|{
name|uint32_t
name|cas
init|=
name|atomic_cas_32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|zrl
operator|->
name|zr_refcount
argument_list|,
name|n
argument_list|,
name|n
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|cas
operator|==
name|n
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|int32_t
operator|)
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
if|if
condition|(
name|zrl
operator|->
name|zr_owner
operator|==
name|curthread
condition|)
block|{
name|DTRACE_PROBE2
argument_list|(
name|zrlock__reentry
argument_list|,
name|zrlock_t
operator|*
argument_list|,
name|zrl
argument_list|,
name|uint32_t
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|zrl
operator|->
name|zr_owner
operator|=
name|curthread
expr_stmt|;
name|zrl
operator|->
name|zr_caller
operator|=
name|zc
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|n
operator|=
name|cas
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zrl
operator|->
name|zr_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|zrl
operator|->
name|zr_refcount
operator|==
name|ZRL_LOCKED
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|zrl
operator|->
name|zr_cv
argument_list|,
operator|&
name|zrl
operator|->
name|zr_mtx
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_refcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|zrl
operator|->
name|zr_refcount
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|zrl
operator|->
name|zr_owner
operator|=
name|curthread
expr_stmt|;
name|zrl
operator|->
name|zr_caller
operator|=
name|zc
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|zrl
operator|->
name|zr_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zrl_remove
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|uint32_t
name|n
decl_stmt|;
name|n
operator|=
name|atomic_dec_32_nv
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|zrl
operator|->
name|zr_refcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|int32_t
operator|)
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
if|if
condition|(
name|zrl
operator|->
name|zr_owner
operator|==
name|curthread
condition|)
block|{
name|zrl
operator|->
name|zr_owner
operator|=
name|NULL
expr_stmt|;
name|zrl
operator|->
name|zr_caller
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|zrl_tryenter
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|uint32_t
name|n
init|=
operator|(
name|uint32_t
operator|)
name|zrl
operator|->
name|zr_refcount
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|cas
init|=
name|atomic_cas_32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|zrl
operator|->
name|zr_refcount
argument_list|,
literal|0
argument_list|,
name|ZRL_LOCKED
argument_list|)
decl_stmt|;
if|if
condition|(
name|cas
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_owner
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zrl
operator|->
name|zr_owner
operator|=
name|curthread
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
operator|(
name|int32_t
operator|)
name|n
operator|>
name|ZRL_DESTROYED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zrl_exit
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_refcount
operator|==
name|ZRL_LOCKED
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zrl
operator|->
name|zr_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_owner
operator|==
name|curthread
argument_list|)
expr_stmt|;
name|zrl
operator|->
name|zr_owner
operator|=
name|NULL
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
comment|/* make sure the owner store happens first */
endif|#
directive|endif
name|zrl
operator|->
name|zr_refcount
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zrl
operator|->
name|zr_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zrl
operator|->
name|zr_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zrl_refcount
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_refcount
operator|>
name|ZRL_DESTROYED
argument_list|)
expr_stmt|;
name|int
name|n
init|=
operator|(
name|int
operator|)
name|zrl
operator|->
name|zr_refcount
decl_stmt|;
return|return
operator|(
name|n
operator|<=
literal|0
condition|?
literal|0
else|:
name|n
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zrl_is_zero
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_refcount
operator|>
name|ZRL_DESTROYED
argument_list|)
expr_stmt|;
return|return
operator|(
name|zrl
operator|->
name|zr_refcount
operator|<=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zrl_is_locked
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zrl
operator|->
name|zr_refcount
operator|>
name|ZRL_DESTROYED
argument_list|)
expr_stmt|;
return|return
operator|(
name|zrl
operator|->
name|zr_refcount
operator|==
name|ZRL_LOCKED
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_function
name|kthread_t
modifier|*
name|zrl_owner
parameter_list|(
name|zrlock_t
modifier|*
name|zrl
parameter_list|)
block|{
return|return
operator|(
name|zrl
operator|->
name|zr_owner
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

