begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * LZ4 - Fast LZ compression algorithm  * Header File  * Copyright (C) 2011-2013, Yann Collet.  * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *     * Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  * copyright notice, this list of conditions and the following disclaimer  * in the documentation and/or other materials provided with the  * distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * You can contact the author at :  * - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html  * - LZ4 source repository : http://code.google.com/p/lz4/  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_function_decl
specifier|static
name|int
name|real_LZ4_compress
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|osize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LZ4_compressBound
parameter_list|(
name|int
name|isize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LZ4_uncompress_unknownOutputSize
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|maxOutputSize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LZ4_compressCtx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|osize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LZ4_compress64kCtx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|osize
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|lz4_ctx_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|size_t
name|lz4_compress
parameter_list|(
name|void
modifier|*
name|s_start
parameter_list|,
name|void
modifier|*
name|d_start
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32_t
name|bufsiz
decl_stmt|;
name|char
modifier|*
name|dest
init|=
name|d_start
decl_stmt|;
name|ASSERT
argument_list|(
name|d_len
operator|>=
sizeof|sizeof
argument_list|(
name|bufsiz
argument_list|)
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
name|real_LZ4_compress
argument_list|(
name|s_start
argument_list|,
operator|&
name|dest
index|[
sizeof|sizeof
argument_list|(
name|bufsiz
argument_list|)
index|]
argument_list|,
name|s_len
argument_list|,
name|d_len
operator|-
sizeof|sizeof
argument_list|(
name|bufsiz
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Signal an error if the compression routine returned zero. */
if|if
condition|(
name|bufsiz
operator|==
literal|0
condition|)
return|return
operator|(
name|s_len
operator|)
return|;
comment|/* 	 * Encode the compresed buffer size at the start. We'll need this in 	 * decompression to counter the effects of padding which might be 	 * added to the compressed buffer and which, if unhandled, would 	 * confuse the hell out of our decompression function. 	 */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|dest
operator|=
name|BE_32
argument_list|(
name|bufsiz
argument_list|)
expr_stmt|;
return|return
operator|(
name|bufsiz
operator|+
sizeof|sizeof
argument_list|(
name|bufsiz
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|lz4_decompress
parameter_list|(
name|void
modifier|*
name|s_start
parameter_list|,
name|void
modifier|*
name|d_start
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src
init|=
name|s_start
decl_stmt|;
name|uint32_t
name|bufsiz
init|=
name|BE_IN32
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* invalid compressed buffer size encoded at start */
if|if
condition|(
name|bufsiz
operator|+
sizeof|sizeof
argument_list|(
name|bufsiz
argument_list|)
operator|>
name|s_len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Returns 0 on success (decompression function returned non-negative) 	 * and non-zero on failure (decompression function returned negative. 	 */
return|return
operator|(
name|LZ4_uncompress_unknownOutputSize
argument_list|(
operator|&
name|src
index|[
sizeof|sizeof
argument_list|(
name|bufsiz
argument_list|)
index|]
argument_list|,
name|d_start
argument_list|,
name|bufsiz
argument_list|,
name|d_len
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LZ4 API Description:  *  * Simple Functions:  * real_LZ4_compress() :  * 	isize  : is the input size. Max supported value is ~1.9GB  * 	return : the number of bytes written in buffer dest  *		 or 0 if the compression fails (if LZ4_COMPRESSMIN is set).  * 	note : destination buffer must be already allocated.  * 		destination buffer must be sized to handle worst cases  * 		situations (input data not compressible) worst case size  * 		evaluation is provided by function LZ4_compressBound().  *  * Advanced Functions  *  * LZ4_compressBound() :  * 	Provides the maximum size that LZ4 may output in a "worst case"  * 	scenario (input data not compressible) primarily useful for memory  * 	allocation of output buffer.  *  * 	isize  : is the input size. Max supported value is ~1.9GB  * 	return : maximum output size in a "worst case" scenario  * 	note : this function is limited by "int" range (2^31-1)  *  * LZ4_uncompress_unknownOutputSize() :  * 	isize  : is the input size, therefore the compressed size  * 	maxOutputSize : is the size of the destination buffer (which must be  * 		already allocated)  * 	return : the number of bytes decoded in the destination buffer  * 		(necessarily<= maxOutputSize). If the source stream is  * 		malformed, the function will stop decoding and return a  * 		negative result, indicating the byte position of the faulty  * 		instruction. This function never writes beyond dest +  * 		maxOutputSize, and is therefore protected against malicious  * 		data packets.  * 	note   : Destination buffer must be already allocated.  *  * LZ4_compressCtx() :  * 	This function explicitly handles the CTX memory structure.  *  * 	ILLUMOS CHANGES: the CTX memory structure must be explicitly allocated  * 	by the caller (either on the stack or using kmem_zalloc). Passing NULL  * 	isn't valid.  *  * LZ4_compress64kCtx() :  * 	Same as LZ4_compressCtx(), but specific to small inputs (<64KB).  * 	isize *Must* be<64KB, otherwise the output will be corrupted.  *  * 	ILLUMOS CHANGES: the CTX memory structure must be explicitly allocated  * 	by the caller (either on the stack or using kmem_zalloc). Passing NULL  * 	isn't valid.  */
end_comment

begin_comment
comment|/*  * Tuning parameters  */
end_comment

begin_comment
comment|/*  * COMPRESSIONLEVEL: Increasing this value improves compression ratio  *	 Lowering this value reduces memory usage. Reduced memory usage  *	typically improves speed, due to cache effect (ex: L1 32KB for Intel,  *	L1 64KB for AMD). Memory usage formula : N->2^(N+2) Bytes  *	(examples : 12 -> 16KB ; 17 -> 512KB)  */
end_comment

begin_define
define|#
directive|define
name|COMPRESSIONLEVEL
value|12
end_define

begin_comment
comment|/*  * NOTCOMPRESSIBLE_CONFIRMATION: Decreasing this value will make the  *	algorithm skip faster data segments considered "incompressible".  *	This may decrease compression ratio dramatically, but will be  *	faster on incompressible data. Increasing this value will make  *	the algorithm search more before declaring a segment "incompressible".  *	This could improve compression a bit, but will be slower on  *	incompressible data. The default value (6) is recommended.  */
end_comment

begin_define
define|#
directive|define
name|NOTCOMPRESSIBLE_CONFIRMATION
value|6
end_define

begin_comment
comment|/*  * BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE: This will provide a boost to  * performance for big endian cpu, but the resulting compressed stream  * will be incompatible with little-endian CPU. You can set this option  * to 1 in situations where data will stay within closed environment.  * This option is useless on Little_Endian CPU (such as x86).  */
end_comment

begin_comment
comment|/* #define	BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE 1 */
end_comment

begin_comment
comment|/*  * CPU Feature Detection  */
end_comment

begin_comment
comment|/* 32 or 64 bits ? */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__amd64
argument_list|)
operator|||
name|defined
argument_list|(
name|__ppc64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN64
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__LP64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_LP64
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|LZ4_ARCH64
value|1
end_define

begin_comment
comment|/*  * Illumos: On amd64 we have 20k of stack and 24k on sun4u and sun4v, so we  * can spend 16k on the algorithm  */
end_comment

begin_comment
comment|/* FreeBSD: Use heap for all platforms for now */
end_comment

begin_define
define|#
directive|define
name|STACKLIMIT
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LZ4_ARCH64
value|0
end_define

begin_comment
comment|/*  * Illumos: On i386 we only have 12k of stack, so in order to maintain the  * same COMPRESSIONLEVEL we have to use heap allocation. Performance will  * suck, but alas, it's ZFS on 32-bit we're talking about, so...  */
end_comment

begin_define
define|#
directive|define
name|STACKLIMIT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Little Endian or Big Endian?  * Note: overwrite the below #define if you know your architecture endianess.  */
end_comment

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|LZ4_BIG_ENDIAN
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Little Endian assumed. PDP Endian and other very rare endian format  * are unsupported.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Unaligned memory access is automatically enabled for "common" CPU,  * such as x86. For others CPU, the compiler will be more cautious, and  * insert extra code to ensure aligned access is respected. If you know  * your target CPU supports unaligned memory access, you may want to  * force this option manually to improve performance  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ARM_FEATURE_UNALIGNED
argument_list|)
end_if

begin_define
define|#
directive|define
name|LZ4_FORCE_UNALIGNED_ACCESS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * FreeBSD: can't use GCC's __builtin_ctz when using sparc64 because  * gcc currently rely on libcompiler_rt.  *  * TODO: revisit this when situation changes.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sparc64__
argument_list|)
end_if

begin_define
define|#
directive|define
name|LZ4_FORCE_SW_BITCOUNT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compiler Options  */
end_comment

begin_if
if|#
directive|if
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_comment
comment|/* "restrict" is a known keyword */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Disable restrict */
end_comment

begin_define
define|#
directive|define
name|restrict
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|lz4_bswap16
parameter_list|(
name|x
parameter_list|)
value|((unsigned short int) ((((x)>> 8)& 0xffu) | \ 	(((x)& 0xffu)<< 8)))
end_define

begin_define
define|#
directive|define
name|expect
parameter_list|(
name|expr
parameter_list|,
name|value
parameter_list|)
value|(__builtin_expect((expr), (value)))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|likely
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|likely
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unlikely
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|unlikely
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|likely
parameter_list|(
name|expr
parameter_list|)
value|expect((expr) != 0, 1)
end_define

begin_define
define|#
directive|define
name|unlikely
parameter_list|(
name|expr
parameter_list|)
value|expect((expr) != 0, 0)
end_define

begin_comment
comment|/* Basic types */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|uint8_t
end_define

begin_define
define|#
directive|define
name|U16
value|uint16_t
end_define

begin_define
define|#
directive|define
name|U32
value|uint32_t
end_define

begin_define
define|#
directive|define
name|S32
value|int32_t
end_define

begin_define
define|#
directive|define
name|U64
value|uint64_t
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|LZ4_FORCE_UNALIGNED_ACCESS
end_ifndef

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|1
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|_U16_S
block|{
name|U16
name|v
decl_stmt|;
block|}
name|U16_S
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_U32_S
block|{
name|U32
name|v
decl_stmt|;
block|}
name|U32_S
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_U64_S
block|{
name|U64
name|v
decl_stmt|;
block|}
name|U64_S
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|LZ4_FORCE_UNALIGNED_ACCESS
end_ifndef

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|A64
parameter_list|(
name|x
parameter_list|)
value|(((U64_S *)(x))->v)
end_define

begin_define
define|#
directive|define
name|A32
parameter_list|(
name|x
parameter_list|)
value|(((U32_S *)(x))->v)
end_define

begin_define
define|#
directive|define
name|A16
parameter_list|(
name|x
parameter_list|)
value|(((U16_S *)(x))->v)
end_define

begin_comment
comment|/*  * Constants  */
end_comment

begin_define
define|#
directive|define
name|MINMATCH
value|4
end_define

begin_define
define|#
directive|define
name|HASH_LOG
value|COMPRESSIONLEVEL
end_define

begin_define
define|#
directive|define
name|HASHTABLESIZE
value|(1<< HASH_LOG)
end_define

begin_define
define|#
directive|define
name|HASH_MASK
value|(HASHTABLESIZE - 1)
end_define

begin_define
define|#
directive|define
name|SKIPSTRENGTH
value|(NOTCOMPRESSIBLE_CONFIRMATION> 2 ? \ 	NOTCOMPRESSIBLE_CONFIRMATION : 2)
end_define

begin_comment
comment|/*  * Defines if memory is allocated into the stack (local variable),  * or into the heap (kmem_alloc()).  */
end_comment

begin_define
define|#
directive|define
name|HEAPMODE
value|(HASH_LOG> STACKLIMIT)
end_define

begin_define
define|#
directive|define
name|COPYLENGTH
value|8
end_define

begin_define
define|#
directive|define
name|LASTLITERALS
value|5
end_define

begin_define
define|#
directive|define
name|MFLIMIT
value|(COPYLENGTH + MINMATCH)
end_define

begin_define
define|#
directive|define
name|MINLENGTH
value|(MFLIMIT + 1)
end_define

begin_define
define|#
directive|define
name|MAXD_LOG
value|16
end_define

begin_define
define|#
directive|define
name|MAX_DISTANCE
value|((1<< MAXD_LOG) - 1)
end_define

begin_define
define|#
directive|define
name|ML_BITS
value|4
end_define

begin_define
define|#
directive|define
name|ML_MASK
value|((1U<<ML_BITS)-1)
end_define

begin_define
define|#
directive|define
name|RUN_BITS
value|(8-ML_BITS)
end_define

begin_define
define|#
directive|define
name|RUN_MASK
value|((1U<<RUN_BITS)-1)
end_define

begin_comment
comment|/*  * Architecture-specific macros  */
end_comment

begin_if
if|#
directive|if
name|LZ4_ARCH64
end_if

begin_define
define|#
directive|define
name|STEPSIZE
value|8
end_define

begin_define
define|#
directive|define
name|UARCH
value|U64
end_define

begin_define
define|#
directive|define
name|AARCH
value|A64
end_define

begin_define
define|#
directive|define
name|LZ4_COPYSTEP
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
value|A64(d) = A64(s); d += 8; s += 8;
end_define

begin_define
define|#
directive|define
name|LZ4_COPYPACKET
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
value|LZ4_COPYSTEP(s, d)
end_define

begin_define
define|#
directive|define
name|LZ4_SECURECOPY
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|if (d< e) LZ4_WILDCOPY(s, d, e)
end_define

begin_define
define|#
directive|define
name|HTYPE
value|U32
end_define

begin_define
define|#
directive|define
name|INITBASE
parameter_list|(
name|base
parameter_list|)
value|const BYTE* const base = ip
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !LZ4_ARCH64 */
end_comment

begin_define
define|#
directive|define
name|STEPSIZE
value|4
end_define

begin_define
define|#
directive|define
name|UARCH
value|U32
end_define

begin_define
define|#
directive|define
name|AARCH
value|A32
end_define

begin_define
define|#
directive|define
name|LZ4_COPYSTEP
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
value|A32(d) = A32(s); d += 4; s += 4;
end_define

begin_define
define|#
directive|define
name|LZ4_COPYPACKET
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
value|LZ4_COPYSTEP(s, d); LZ4_COPYSTEP(s, d);
end_define

begin_define
define|#
directive|define
name|LZ4_SECURECOPY
value|LZ4_WILDCOPY
end_define

begin_define
define|#
directive|define
name|HTYPE
value|const BYTE *
end_define

begin_define
define|#
directive|define
name|INITBASE
parameter_list|(
name|base
parameter_list|)
value|const int base = 0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !LZ4_ARCH64 */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|LZ4_BIG_ENDIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BIG_ENDIAN_NATIVE_BUT_INCOMPATIBLE
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|LZ4_READ_LITTLEENDIAN_16
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|p
parameter_list|)
define|\
value|{ U16 v = A16(p); v = lz4_bswap16(v); d = (s) - v; }
end_define

begin_define
define|#
directive|define
name|LZ4_WRITE_LITTLEENDIAN_16
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|)
define|\
value|{ U16 v = (U16)(i); v = lz4_bswap16(v); A16(p) = v; p += 2; }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LZ4_READ_LITTLEENDIAN_16
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|p
parameter_list|)
value|{ d = (s) - A16(p); }
end_define

begin_define
define|#
directive|define
name|LZ4_WRITE_LITTLEENDIAN_16
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|{ A16(p) = v; p += 2; }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local structures */
end_comment

begin_struct
struct|struct
name|refTables
block|{
name|HTYPE
name|hashTable
index|[
name|HASHTABLESIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Macros */
end_comment

begin_define
define|#
directive|define
name|LZ4_HASH_FUNCTION
parameter_list|(
name|i
parameter_list|)
value|(((i) * 2654435761U)>> ((MINMATCH * 8) - \ 	HASH_LOG))
end_define

begin_define
define|#
directive|define
name|LZ4_HASH_VALUE
parameter_list|(
name|p
parameter_list|)
value|LZ4_HASH_FUNCTION(A32(p))
end_define

begin_define
define|#
directive|define
name|LZ4_WILDCOPY
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|do { LZ4_COPYPACKET(s, d) } while (d< e);
end_define

begin_define
define|#
directive|define
name|LZ4_BLINDCOPY
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|l
parameter_list|)
value|{ BYTE* e = (d) + l; LZ4_WILDCOPY(s, d, e); \ 	d = e; }
end_define

begin_comment
comment|/* Private functions */
end_comment

begin_if
if|#
directive|if
name|LZ4_ARCH64
end_if

begin_function
specifier|static
specifier|inline
name|int
name|LZ4_NbCommonBytes
parameter_list|(
specifier|register
name|U64
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|LZ4_BIG_ENDIAN
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LZ4_FORCE_SW_BITCOUNT
argument_list|)
return|return
operator|(
name|__builtin_clzll
argument_list|(
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|>>
literal|32
operator|)
condition|)
block|{
name|r
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
name|val
operator|>>=
literal|32
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|val
operator|>>
literal|16
operator|)
condition|)
block|{
name|r
operator|+=
literal|2
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|val
operator|>>=
literal|24
expr_stmt|;
block|}
name|r
operator|+=
operator|(
operator|!
name|val
operator|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LZ4_FORCE_SW_BITCOUNT
argument_list|)
return|return
operator|(
name|__builtin_ctzll
argument_list|(
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
specifier|static
specifier|const
name|int
name|DeBruijnBytePos
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|2
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|2
block|,
literal|6
block|,
literal|5
block|,
literal|7
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|}
decl_stmt|;
return|return
name|DeBruijnBytePos
index|[
operator|(
call|(
name|U64
call|)
argument_list|(
operator|(
name|val
operator|&
operator|-
name|val
operator|)
operator|*
literal|0x0218A392CDABBD3F
argument_list|)
operator|)
operator|>>
literal|58
index|]
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|int
name|LZ4_NbCommonBytes
parameter_list|(
specifier|register
name|U32
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|LZ4_BIG_ENDIAN
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LZ4_FORCE_SW_BITCOUNT
argument_list|)
return|return
operator|(
name|__builtin_clz
argument_list|(
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|>>
literal|16
operator|)
condition|)
block|{
name|r
operator|=
literal|2
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
name|val
operator|>>=
literal|24
expr_stmt|;
block|}
name|r
operator|+=
operator|(
operator|!
name|val
operator|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LZ4_FORCE_SW_BITCOUNT
argument_list|)
return|return
operator|(
name|__builtin_ctz
argument_list|(
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
specifier|static
specifier|const
name|int
name|DeBruijnBytePos
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
return|return
name|DeBruijnBytePos
index|[
operator|(
call|(
name|U32
call|)
argument_list|(
operator|(
name|val
operator|&
operator|-
operator|(
name|S32
operator|)
name|val
operator|)
operator|*
literal|0x077CB531U
argument_list|)
operator|)
operator|>>
literal|27
index|]
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Public functions */
end_comment

begin_function
specifier|static
name|int
name|LZ4_compressBound
parameter_list|(
name|int
name|isize
parameter_list|)
block|{
return|return
operator|(
name|isize
operator|+
operator|(
name|isize
operator|/
literal|255
operator|)
operator|+
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compression functions */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|LZ4_compressCtx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|osize
parameter_list|)
block|{
if|#
directive|if
name|HEAPMODE
name|struct
name|refTables
modifier|*
name|srt
init|=
operator|(
expr|struct
name|refTables
operator|*
operator|)
name|ctx
decl_stmt|;
name|HTYPE
modifier|*
name|HashTable
init|=
operator|(
name|HTYPE
operator|*
operator|)
operator|(
name|srt
operator|->
name|hashTable
operator|)
decl_stmt|;
else|#
directive|else
name|HTYPE
name|HashTable
index|[
name|HASHTABLESIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
endif|#
directive|endif
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
name|BYTE
operator|*
operator|)
name|source
decl_stmt|;
name|INITBASE
argument_list|(
name|base
argument_list|)
expr_stmt|;
specifier|const
name|BYTE
modifier|*
name|anchor
init|=
name|ip
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|isize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|oend
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dest
operator|+
name|osize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|mflimit
init|=
name|iend
operator|-
name|MFLIMIT
decl_stmt|;
define|#
directive|define
name|matchlimit
value|(iend - LASTLITERALS)
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dest
decl_stmt|;
name|int
name|len
decl_stmt|,
name|length
decl_stmt|;
specifier|const
name|int
name|skipStrength
init|=
name|SKIPSTRENGTH
decl_stmt|;
name|U32
name|forwardH
decl_stmt|;
comment|/* Init */
if|if
condition|(
name|isize
operator|<
name|MINLENGTH
condition|)
goto|goto
name|_last_literals
goto|;
comment|/* First Byte */
name|HashTable
index|[
name|LZ4_HASH_VALUE
argument_list|(
name|ip
argument_list|)
index|]
operator|=
name|ip
operator|-
name|base
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|forwardH
operator|=
name|LZ4_HASH_VALUE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* Main Loop */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|findMatchAttempts
init|=
operator|(
literal|1U
operator|<<
name|skipStrength
operator|)
operator|+
literal|3
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|forwardIp
init|=
name|ip
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ref
decl_stmt|;
name|BYTE
modifier|*
name|token
decl_stmt|;
comment|/* Find a match */
do|do
block|{
name|U32
name|h
init|=
name|forwardH
decl_stmt|;
name|int
name|step
init|=
name|findMatchAttempts
operator|++
operator|>>
name|skipStrength
decl_stmt|;
name|ip
operator|=
name|forwardIp
expr_stmt|;
name|forwardIp
operator|=
name|ip
operator|+
name|step
expr_stmt|;
if|if unlikely
condition|(
name|forwardIp
operator|>
name|mflimit
condition|)
block|{
goto|goto
name|_last_literals
goto|;
block|}
name|forwardH
operator|=
name|LZ4_HASH_VALUE
argument_list|(
name|forwardIp
argument_list|)
expr_stmt|;
name|ref
operator|=
name|base
operator|+
name|HashTable
index|[
name|h
index|]
expr_stmt|;
name|HashTable
index|[
name|h
index|]
operator|=
name|ip
operator|-
name|base
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ref
operator|<
name|ip
operator|-
name|MAX_DISTANCE
operator|)
operator|||
operator|(
name|A32
argument_list|(
name|ref
argument_list|)
operator|!=
name|A32
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
do|;
comment|/* Catch up */
while|while
condition|(
operator|(
name|ip
operator|>
name|anchor
operator|)
operator|&&
operator|(
name|ref
operator|>
operator|(
name|BYTE
operator|*
operator|)
name|source
operator|)
operator|&&
name|unlikely
argument_list|(
name|ip
index|[
operator|-
literal|1
index|]
operator|==
name|ref
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|ip
operator|--
expr_stmt|;
name|ref
operator|--
expr_stmt|;
block|}
comment|/* Encode Literal length */
name|length
operator|=
name|ip
operator|-
name|anchor
expr_stmt|;
name|token
operator|=
name|op
operator|++
expr_stmt|;
comment|/* Check output limit */
if|if unlikely
condition|(
name|op
operator|+
name|length
operator|+
operator|(
literal|2
operator|+
literal|1
operator|+
name|LASTLITERALS
operator|)
operator|+
operator|(
name|length
operator|>>
literal|8
operator|)
operator|>
name|oend
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|length
operator|>=
operator|(
name|int
operator|)
name|RUN_MASK
condition|)
block|{
operator|*
name|token
operator|=
operator|(
name|RUN_MASK
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
name|len
operator|=
name|length
operator|-
name|RUN_MASK
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|254
condition|;
name|len
operator|-=
literal|255
control|)
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|BYTE
operator|)
name|len
expr_stmt|;
block|}
else|else
operator|*
name|token
operator|=
operator|(
name|length
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
comment|/* Copy Literals */
name|LZ4_BLINDCOPY
argument_list|(
name|anchor
argument_list|,
name|op
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|_next_match
label|:
comment|/* Encode Offset */
name|LZ4_WRITE_LITTLEENDIAN_16
argument_list|(
name|op
argument_list|,
name|ip
operator|-
name|ref
argument_list|)
expr_stmt|;
comment|/* Start Counting */
name|ip
operator|+=
name|MINMATCH
expr_stmt|;
name|ref
operator|+=
name|MINMATCH
expr_stmt|;
comment|/* MinMatch verified */
name|anchor
operator|=
name|ip
expr_stmt|;
while|while likely
condition|(
name|ip
operator|<
name|matchlimit
operator|-
operator|(
name|STEPSIZE
operator|-
literal|1
operator|)
condition|)
block|{
name|UARCH
name|diff
init|=
name|AARCH
argument_list|(
name|ref
argument_list|)
operator|^
name|AARCH
argument_list|(
name|ip
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|diff
condition|)
block|{
name|ip
operator|+=
name|STEPSIZE
expr_stmt|;
name|ref
operator|+=
name|STEPSIZE
expr_stmt|;
continue|continue;
block|}
name|ip
operator|+=
name|LZ4_NbCommonBytes
argument_list|(
name|diff
argument_list|)
expr_stmt|;
goto|goto
name|_endCount
goto|;
block|}
if|#
directive|if
name|LZ4_ARCH64
if|if
condition|(
operator|(
name|ip
operator|<
operator|(
name|matchlimit
operator|-
literal|3
operator|)
operator|)
operator|&&
operator|(
name|A32
argument_list|(
name|ref
argument_list|)
operator|==
name|A32
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|+=
literal|4
expr_stmt|;
name|ref
operator|+=
literal|4
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ip
operator|<
operator|(
name|matchlimit
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|A16
argument_list|(
name|ref
argument_list|)
operator|==
name|A16
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|+=
literal|2
expr_stmt|;
name|ref
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ip
operator|<
name|matchlimit
operator|)
operator|&&
operator|(
operator|*
name|ref
operator|==
operator|*
name|ip
operator|)
condition|)
name|ip
operator|++
expr_stmt|;
name|_endCount
label|:
comment|/* Encode MatchLength */
name|len
operator|=
operator|(
name|ip
operator|-
name|anchor
operator|)
expr_stmt|;
comment|/* Check output limit */
if|if unlikely
condition|(
name|op
operator|+
operator|(
literal|1
operator|+
name|LASTLITERALS
operator|)
operator|+
operator|(
name|len
operator|>>
literal|8
operator|)
operator|>
name|oend
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|>=
operator|(
name|int
operator|)
name|ML_MASK
condition|)
block|{
operator|*
name|token
operator|+=
name|ML_MASK
expr_stmt|;
name|len
operator|-=
name|ML_MASK
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|509
condition|;
name|len
operator|-=
literal|510
control|)
block|{
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|254
condition|)
block|{
name|len
operator|-=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
operator|(
name|BYTE
operator|)
name|len
expr_stmt|;
block|}
else|else
operator|*
name|token
operator|+=
name|len
expr_stmt|;
comment|/* Test end of chunk */
if|if
condition|(
name|ip
operator|>
name|mflimit
condition|)
block|{
name|anchor
operator|=
name|ip
expr_stmt|;
break|break;
block|}
comment|/* Fill table */
name|HashTable
index|[
name|LZ4_HASH_VALUE
argument_list|(
name|ip
operator|-
literal|2
argument_list|)
index|]
operator|=
name|ip
operator|-
literal|2
operator|-
name|base
expr_stmt|;
comment|/* Test next position */
name|ref
operator|=
name|base
operator|+
name|HashTable
index|[
name|LZ4_HASH_VALUE
argument_list|(
name|ip
argument_list|)
index|]
expr_stmt|;
name|HashTable
index|[
name|LZ4_HASH_VALUE
argument_list|(
name|ip
argument_list|)
index|]
operator|=
name|ip
operator|-
name|base
expr_stmt|;
if|if
condition|(
operator|(
name|ref
operator|>
name|ip
operator|-
operator|(
name|MAX_DISTANCE
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
name|A32
argument_list|(
name|ref
argument_list|)
operator|==
name|A32
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
block|{
name|token
operator|=
name|op
operator|++
expr_stmt|;
operator|*
name|token
operator|=
literal|0
expr_stmt|;
goto|goto
name|_next_match
goto|;
block|}
comment|/* Prepare next loop */
name|anchor
operator|=
name|ip
operator|++
expr_stmt|;
name|forwardH
operator|=
name|LZ4_HASH_VALUE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|_last_literals
label|:
comment|/* Encode Last Literals */
block|{
name|int
name|lastRun
init|=
name|iend
operator|-
name|anchor
decl_stmt|;
if|if
condition|(
name|op
operator|+
name|lastRun
operator|+
literal|1
operator|+
operator|(
operator|(
name|lastRun
operator|+
literal|255
operator|-
name|RUN_MASK
operator|)
operator|/
literal|255
operator|)
operator|>
name|oend
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lastRun
operator|>=
operator|(
name|int
operator|)
name|RUN_MASK
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|(
name|RUN_MASK
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
name|lastRun
operator|-=
name|RUN_MASK
expr_stmt|;
for|for
control|(
init|;
name|lastRun
operator|>
literal|254
condition|;
name|lastRun
operator|-=
literal|255
control|)
block|{
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
operator|(
name|BYTE
operator|)
name|lastRun
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
operator|(
name|lastRun
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|op
argument_list|,
name|anchor
argument_list|,
name|iend
operator|-
name|anchor
argument_list|)
expr_stmt|;
name|op
operator|+=
name|iend
operator|-
name|anchor
expr_stmt|;
block|}
comment|/* End */
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|op
operator|)
operator|-
name|dest
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Note : this function is valid only if isize< LZ4_64KLIMIT */
end_comment

begin_define
define|#
directive|define
name|LZ4_64KLIMIT
value|((1<< 16) + (MFLIMIT - 1))
end_define

begin_define
define|#
directive|define
name|HASHLOG64K
value|(HASH_LOG + 1)
end_define

begin_define
define|#
directive|define
name|HASH64KTABLESIZE
value|(1U<< HASHLOG64K)
end_define

begin_define
define|#
directive|define
name|LZ4_HASH64K_FUNCTION
parameter_list|(
name|i
parameter_list|)
value|(((i) * 2654435761U)>> ((MINMATCH*8) - \ 	HASHLOG64K))
end_define

begin_define
define|#
directive|define
name|LZ4_HASH64K_VALUE
parameter_list|(
name|p
parameter_list|)
value|LZ4_HASH64K_FUNCTION(A32(p))
end_define

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|LZ4_compress64kCtx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|osize
parameter_list|)
block|{
if|#
directive|if
name|HEAPMODE
name|struct
name|refTables
modifier|*
name|srt
init|=
operator|(
expr|struct
name|refTables
operator|*
operator|)
name|ctx
decl_stmt|;
name|U16
modifier|*
name|HashTable
init|=
operator|(
name|U16
operator|*
operator|)
operator|(
name|srt
operator|->
name|hashTable
operator|)
decl_stmt|;
else|#
directive|else
name|U16
name|HashTable
index|[
name|HASH64KTABLESIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
endif|#
directive|endif
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
name|BYTE
operator|*
operator|)
name|source
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|anchor
init|=
name|ip
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
name|ip
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|isize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|oend
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dest
operator|+
name|osize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|mflimit
init|=
name|iend
operator|-
name|MFLIMIT
decl_stmt|;
define|#
directive|define
name|matchlimit
value|(iend - LASTLITERALS)
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dest
decl_stmt|;
name|int
name|len
decl_stmt|,
name|length
decl_stmt|;
specifier|const
name|int
name|skipStrength
init|=
name|SKIPSTRENGTH
decl_stmt|;
name|U32
name|forwardH
decl_stmt|;
comment|/* Init */
if|if
condition|(
name|isize
operator|<
name|MINLENGTH
condition|)
goto|goto
name|_last_literals
goto|;
comment|/* First Byte */
name|ip
operator|++
expr_stmt|;
name|forwardH
operator|=
name|LZ4_HASH64K_VALUE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* Main Loop */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|findMatchAttempts
init|=
operator|(
literal|1U
operator|<<
name|skipStrength
operator|)
operator|+
literal|3
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|forwardIp
init|=
name|ip
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ref
decl_stmt|;
name|BYTE
modifier|*
name|token
decl_stmt|;
comment|/* Find a match */
do|do
block|{
name|U32
name|h
init|=
name|forwardH
decl_stmt|;
name|int
name|step
init|=
name|findMatchAttempts
operator|++
operator|>>
name|skipStrength
decl_stmt|;
name|ip
operator|=
name|forwardIp
expr_stmt|;
name|forwardIp
operator|=
name|ip
operator|+
name|step
expr_stmt|;
if|if
condition|(
name|forwardIp
operator|>
name|mflimit
condition|)
block|{
goto|goto
name|_last_literals
goto|;
block|}
name|forwardH
operator|=
name|LZ4_HASH64K_VALUE
argument_list|(
name|forwardIp
argument_list|)
expr_stmt|;
name|ref
operator|=
name|base
operator|+
name|HashTable
index|[
name|h
index|]
expr_stmt|;
name|HashTable
index|[
name|h
index|]
operator|=
name|ip
operator|-
name|base
expr_stmt|;
block|}
do|while
condition|(
name|A32
argument_list|(
name|ref
argument_list|)
operator|!=
name|A32
argument_list|(
name|ip
argument_list|)
condition|)
do|;
comment|/* Catch up */
while|while
condition|(
operator|(
name|ip
operator|>
name|anchor
operator|)
operator|&&
operator|(
name|ref
operator|>
operator|(
name|BYTE
operator|*
operator|)
name|source
operator|)
operator|&&
operator|(
name|ip
index|[
operator|-
literal|1
index|]
operator|==
name|ref
index|[
operator|-
literal|1
index|]
operator|)
condition|)
block|{
name|ip
operator|--
expr_stmt|;
name|ref
operator|--
expr_stmt|;
block|}
comment|/* Encode Literal length */
name|length
operator|=
name|ip
operator|-
name|anchor
expr_stmt|;
name|token
operator|=
name|op
operator|++
expr_stmt|;
comment|/* Check output limit */
if|if unlikely
condition|(
name|op
operator|+
name|length
operator|+
operator|(
literal|2
operator|+
literal|1
operator|+
name|LASTLITERALS
operator|)
operator|+
operator|(
name|length
operator|>>
literal|8
operator|)
operator|>
name|oend
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|length
operator|>=
operator|(
name|int
operator|)
name|RUN_MASK
condition|)
block|{
operator|*
name|token
operator|=
operator|(
name|RUN_MASK
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
name|len
operator|=
name|length
operator|-
name|RUN_MASK
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|254
condition|;
name|len
operator|-=
literal|255
control|)
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|BYTE
operator|)
name|len
expr_stmt|;
block|}
else|else
operator|*
name|token
operator|=
operator|(
name|length
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
comment|/* Copy Literals */
name|LZ4_BLINDCOPY
argument_list|(
name|anchor
argument_list|,
name|op
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|_next_match
label|:
comment|/* Encode Offset */
name|LZ4_WRITE_LITTLEENDIAN_16
argument_list|(
name|op
argument_list|,
name|ip
operator|-
name|ref
argument_list|)
expr_stmt|;
comment|/* Start Counting */
name|ip
operator|+=
name|MINMATCH
expr_stmt|;
name|ref
operator|+=
name|MINMATCH
expr_stmt|;
comment|/* MinMatch verified */
name|anchor
operator|=
name|ip
expr_stmt|;
while|while
condition|(
name|ip
operator|<
name|matchlimit
operator|-
operator|(
name|STEPSIZE
operator|-
literal|1
operator|)
condition|)
block|{
name|UARCH
name|diff
init|=
name|AARCH
argument_list|(
name|ref
argument_list|)
operator|^
name|AARCH
argument_list|(
name|ip
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|diff
condition|)
block|{
name|ip
operator|+=
name|STEPSIZE
expr_stmt|;
name|ref
operator|+=
name|STEPSIZE
expr_stmt|;
continue|continue;
block|}
name|ip
operator|+=
name|LZ4_NbCommonBytes
argument_list|(
name|diff
argument_list|)
expr_stmt|;
goto|goto
name|_endCount
goto|;
block|}
if|#
directive|if
name|LZ4_ARCH64
if|if
condition|(
operator|(
name|ip
operator|<
operator|(
name|matchlimit
operator|-
literal|3
operator|)
operator|)
operator|&&
operator|(
name|A32
argument_list|(
name|ref
argument_list|)
operator|==
name|A32
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|+=
literal|4
expr_stmt|;
name|ref
operator|+=
literal|4
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ip
operator|<
operator|(
name|matchlimit
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|A16
argument_list|(
name|ref
argument_list|)
operator|==
name|A16
argument_list|(
name|ip
argument_list|)
operator|)
condition|)
block|{
name|ip
operator|+=
literal|2
expr_stmt|;
name|ref
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ip
operator|<
name|matchlimit
operator|)
operator|&&
operator|(
operator|*
name|ref
operator|==
operator|*
name|ip
operator|)
condition|)
name|ip
operator|++
expr_stmt|;
name|_endCount
label|:
comment|/* Encode MatchLength */
name|len
operator|=
operator|(
name|ip
operator|-
name|anchor
operator|)
expr_stmt|;
comment|/* Check output limit */
if|if unlikely
condition|(
name|op
operator|+
operator|(
literal|1
operator|+
name|LASTLITERALS
operator|)
operator|+
operator|(
name|len
operator|>>
literal|8
operator|)
operator|>
name|oend
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|>=
operator|(
name|int
operator|)
name|ML_MASK
condition|)
block|{
operator|*
name|token
operator|+=
name|ML_MASK
expr_stmt|;
name|len
operator|-=
name|ML_MASK
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|509
condition|;
name|len
operator|-=
literal|510
control|)
block|{
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|254
condition|)
block|{
name|len
operator|-=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
block|}
operator|*
name|op
operator|++
operator|=
operator|(
name|BYTE
operator|)
name|len
expr_stmt|;
block|}
else|else
operator|*
name|token
operator|+=
name|len
expr_stmt|;
comment|/* Test end of chunk */
if|if
condition|(
name|ip
operator|>
name|mflimit
condition|)
block|{
name|anchor
operator|=
name|ip
expr_stmt|;
break|break;
block|}
comment|/* Fill table */
name|HashTable
index|[
name|LZ4_HASH64K_VALUE
argument_list|(
name|ip
operator|-
literal|2
argument_list|)
index|]
operator|=
name|ip
operator|-
literal|2
operator|-
name|base
expr_stmt|;
comment|/* Test next position */
name|ref
operator|=
name|base
operator|+
name|HashTable
index|[
name|LZ4_HASH64K_VALUE
argument_list|(
name|ip
argument_list|)
index|]
expr_stmt|;
name|HashTable
index|[
name|LZ4_HASH64K_VALUE
argument_list|(
name|ip
argument_list|)
index|]
operator|=
name|ip
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|A32
argument_list|(
name|ref
argument_list|)
operator|==
name|A32
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|token
operator|=
name|op
operator|++
expr_stmt|;
operator|*
name|token
operator|=
literal|0
expr_stmt|;
goto|goto
name|_next_match
goto|;
block|}
comment|/* Prepare next loop */
name|anchor
operator|=
name|ip
operator|++
expr_stmt|;
name|forwardH
operator|=
name|LZ4_HASH64K_VALUE
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|_last_literals
label|:
comment|/* Encode Last Literals */
block|{
name|int
name|lastRun
init|=
name|iend
operator|-
name|anchor
decl_stmt|;
if|if
condition|(
name|op
operator|+
name|lastRun
operator|+
literal|1
operator|+
operator|(
operator|(
name|lastRun
operator|+
literal|255
operator|-
name|RUN_MASK
operator|)
operator|/
literal|255
operator|)
operator|>
name|oend
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lastRun
operator|>=
operator|(
name|int
operator|)
name|RUN_MASK
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|(
name|RUN_MASK
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
name|lastRun
operator|-=
name|RUN_MASK
expr_stmt|;
for|for
control|(
init|;
name|lastRun
operator|>
literal|254
condition|;
name|lastRun
operator|-=
literal|255
control|)
operator|*
name|op
operator|++
operator|=
literal|255
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|BYTE
operator|)
name|lastRun
expr_stmt|;
block|}
else|else
operator|*
name|op
operator|++
operator|=
operator|(
name|lastRun
operator|<<
name|ML_BITS
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|op
argument_list|,
name|anchor
argument_list|,
name|iend
operator|-
name|anchor
argument_list|)
expr_stmt|;
name|op
operator|+=
name|iend
operator|-
name|anchor
expr_stmt|;
block|}
comment|/* End */
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|op
operator|)
operator|-
name|dest
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|real_LZ4_compress
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|osize
parameter_list|)
block|{
if|#
directive|if
name|HEAPMODE
name|void
modifier|*
name|ctx
init|=
name|kmem_cache_alloc
argument_list|(
name|lz4_ctx_cache
argument_list|,
name|KM_NOSLEEP
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* 	 * out of kernel memory, gently fall through - this will disable 	 * compression in zio_compress_data 	 */
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refTables
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isize
operator|<
name|LZ4_64KLIMIT
condition|)
name|result
operator|=
name|LZ4_compress64kCtx
argument_list|(
name|ctx
argument_list|,
name|source
argument_list|,
name|dest
argument_list|,
name|isize
argument_list|,
name|osize
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|LZ4_compressCtx
argument_list|(
name|ctx
argument_list|,
name|source
argument_list|,
name|dest
argument_list|,
name|isize
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|lz4_ctx_cache
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|isize
operator|<
operator|(
name|int
operator|)
name|LZ4_64KLIMIT
condition|)
return|return
operator|(
name|LZ4_compress64kCtx
argument_list|(
name|NULL
argument_list|,
name|source
argument_list|,
name|dest
argument_list|,
name|isize
argument_list|,
name|osize
argument_list|)
operator|)
return|;
return|return
operator|(
name|LZ4_compressCtx
argument_list|(
name|NULL
argument_list|,
name|source
argument_list|,
name|dest
argument_list|,
name|isize
argument_list|,
name|osize
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Decompression functions */
end_comment

begin_comment
comment|/*  * Note: The decoding functionLZ4_uncompress_unknownOutputSize() is safe  *	against "buffer overflow" attack type. They will never write nor  *	read outside of the provided output buffers.  *	LZ4_uncompress_unknownOutputSize() also insures that it will never  *	read outside of the input buffer.  A corrupted input will produce  *	an error result, a negative int, indicating the position of the  *	error within input stream.  */
end_comment

begin_function
specifier|static
name|int
name|LZ4_uncompress_unknownOutputSize
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|isize
parameter_list|,
name|int
name|maxOutputSize
parameter_list|)
block|{
comment|/* Local Variables */
specifier|const
name|BYTE
modifier|*
specifier|restrict
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|source
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|isize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ref
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dest
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|maxOutputSize
decl_stmt|;
name|BYTE
modifier|*
name|cpy
decl_stmt|;
name|size_t
name|dec32table
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|#
directive|if
name|LZ4_ARCH64
name|size_t
name|dec64table
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|size_t
operator|)
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* Main Loop */
while|while
condition|(
name|ip
operator|<
name|iend
condition|)
block|{
name|unsigned
name|token
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* get runlength */
name|token
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|=
operator|(
name|token
operator|>>
name|ML_BITS
operator|)
operator|)
operator|==
name|RUN_MASK
condition|)
block|{
name|int
name|s
init|=
literal|255
decl_stmt|;
while|while
condition|(
operator|(
name|ip
operator|<
name|iend
operator|)
operator|&&
operator|(
name|s
operator|==
literal|255
operator|)
condition|)
block|{
name|s
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|length
operator|+=
name|s
expr_stmt|;
block|}
block|}
comment|/* copy literals */
name|cpy
operator|=
name|op
operator|+
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|cpy
operator|>
name|oend
operator|-
name|COPYLENGTH
operator|)
operator|||
operator|(
name|ip
operator|+
name|length
operator|>
name|iend
operator|-
name|COPYLENGTH
operator|)
condition|)
block|{
if|if
condition|(
name|cpy
operator|>
name|oend
condition|)
comment|/* Error: writes beyond output buffer */
goto|goto
name|_output_error
goto|;
if|if
condition|(
name|ip
operator|+
name|length
operator|!=
name|iend
condition|)
comment|/* 				 * Error: LZ4 format requires to consume all 				 * input at this stage 				 */
goto|goto
name|_output_error
goto|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|op
argument_list|,
name|ip
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|op
operator|+=
name|length
expr_stmt|;
comment|/* Necessarily EOF, due to parsing restrictions */
break|break;
block|}
name|LZ4_WILDCOPY
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
name|cpy
argument_list|)
expr_stmt|;
name|ip
operator|-=
operator|(
name|op
operator|-
name|cpy
operator|)
expr_stmt|;
name|op
operator|=
name|cpy
expr_stmt|;
comment|/* get offset */
name|LZ4_READ_LITTLEENDIAN_16
argument_list|(
name|ref
argument_list|,
name|cpy
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ref
operator|<
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dest
condition|)
comment|/* 			 * Error: offset creates reference outside of 			 * destination buffer 			 */
goto|goto
name|_output_error
goto|;
comment|/* get matchlength */
if|if
condition|(
operator|(
name|length
operator|=
operator|(
name|token
operator|&
name|ML_MASK
operator|)
operator|)
operator|==
name|ML_MASK
condition|)
block|{
while|while
condition|(
name|ip
operator|<
name|iend
condition|)
block|{
name|int
name|s
init|=
operator|*
name|ip
operator|++
decl_stmt|;
name|length
operator|+=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|255
condition|)
continue|continue;
break|break;
block|}
block|}
comment|/* copy repeated sequence */
if|if unlikely
condition|(
name|op
operator|-
name|ref
operator|<
name|STEPSIZE
condition|)
block|{
if|#
directive|if
name|LZ4_ARCH64
name|size_t
name|dec64
init|=
name|dec64table
index|[
name|op
operator|-
name|ref
index|]
decl_stmt|;
else|#
directive|else
specifier|const
name|int
name|dec64
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|op
index|[
literal|0
index|]
operator|=
name|ref
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|ref
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|ref
index|[
literal|2
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|ref
index|[
literal|3
index|]
expr_stmt|;
name|op
operator|+=
literal|4
expr_stmt|;
name|ref
operator|+=
literal|4
expr_stmt|;
name|ref
operator|-=
name|dec32table
index|[
name|op
operator|-
name|ref
index|]
expr_stmt|;
name|A32
argument_list|(
name|op
argument_list|)
operator|=
name|A32
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|op
operator|+=
name|STEPSIZE
operator|-
literal|4
expr_stmt|;
name|ref
operator|-=
name|dec64
expr_stmt|;
block|}
else|else
block|{
name|LZ4_COPYSTEP
argument_list|(
name|ref
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|cpy
operator|=
name|op
operator|+
name|length
operator|-
operator|(
name|STEPSIZE
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|cpy
operator|>
name|oend
operator|-
name|COPYLENGTH
condition|)
block|{
if|if
condition|(
name|cpy
operator|>
name|oend
condition|)
comment|/* 				 * Error: request to write outside of 				 * destination buffer 				 */
goto|goto
name|_output_error
goto|;
name|LZ4_SECURECOPY
argument_list|(
name|ref
argument_list|,
name|op
argument_list|,
operator|(
name|oend
operator|-
name|COPYLENGTH
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|op
operator|<
name|cpy
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|ref
operator|++
expr_stmt|;
name|op
operator|=
name|cpy
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|oend
condition|)
comment|/* 				 * Check EOF (should never happen, since 				 * last 5 bytes are supposed to be literals) 				 */
goto|goto
name|_output_error
goto|;
continue|continue;
block|}
name|LZ4_SECURECOPY
argument_list|(
name|ref
argument_list|,
name|op
argument_list|,
name|cpy
argument_list|)
expr_stmt|;
name|op
operator|=
name|cpy
expr_stmt|;
comment|/* correction */
block|}
comment|/* end of decoding */
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|op
operator|)
operator|-
name|dest
argument_list|)
return|;
comment|/* write overflow error detected */
name|_output_error
label|:
return|return
call|(
name|int
call|)
argument_list|(
operator|-
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|)
operator|-
name|source
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|lz4_init
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|HEAPMODE
name|lz4_ctx_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"lz4_ctx"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|refTables
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|extern
name|void
name|lz4_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|HEAPMODE
name|kmem_cache_destroy
argument_list|(
name|lz4_ctx_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

