begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bptree.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_comment
comment|/*  * A bptree is a queue of root block pointers from destroyed datasets. When a  * dataset is destroyed its root block pointer is put on the end of the pool's  * bptree queue so the dataset's blocks can be freed asynchronously by  * dsl_scan_sync. This allows the delete operation to finish without traversing  * all the dataset's blocks.  *  * Note that while bt_begin and bt_end are only ever incremented in this code,  * they are effectively reset to 0 every time the entire bptree is freed because  * the bptree's object is destroyed and re-created.  */
end_comment

begin_struct
struct|struct
name|bptree_args
block|{
name|bptree_phys_t
modifier|*
name|ba_phys
decl_stmt|;
comment|/* data in bonus buffer, dirtied if freeing */
name|boolean_t
name|ba_free
decl_stmt|;
comment|/* true if freeing during traversal */
name|bptree_itor_t
modifier|*
name|ba_func
decl_stmt|;
comment|/* function to call for each blockpointer */
name|void
modifier|*
name|ba_arg
decl_stmt|;
comment|/* caller supplied argument to ba_func */
name|dmu_tx_t
modifier|*
name|ba_tx
decl_stmt|;
comment|/* caller supplied tx, NULL if not freeing */
block|}
name|bptree_args_t
struct|;
end_struct

begin_function
name|uint64_t
name|bptree_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|obj
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|bptree_phys_t
modifier|*
name|bt
decl_stmt|;
name|obj
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OTN_UINT64_METADATA
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|,
name|DMU_OTN_UINT64_METADATA
argument_list|,
sizeof|sizeof
argument_list|(
name|bptree_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Bonus buffer contents are already initialized to 0, but for 	 * readability we make it explicit. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bt
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|bt
operator|->
name|bt_begin
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_end
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_bytes
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_comp
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_uncomp
operator|=
literal|0
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bptree_free
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|bptree_phys_t
modifier|*
name|bt
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_begin
argument_list|,
operator|==
argument_list|,
name|bt
operator|->
name|bt_end
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bt
operator|->
name|bt_bytes
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bt
operator|->
name|bt_comp
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bt
operator|->
name|bt_uncomp
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bptree_add
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|birth_txg
parameter_list|,
name|uint64_t
name|bytes
parameter_list|,
name|uint64_t
name|comp
parameter_list|,
name|uint64_t
name|uncomp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|bptree_phys_t
modifier|*
name|bt
decl_stmt|;
name|bptree_entry_phys_t
name|bte
decl_stmt|;
comment|/* 	 * bptree objects are in the pool mos, therefore they can only be 	 * modified in syncing context. Furthermore, this is only modified 	 * by the sync thread, so no locking is necessary. 	 */
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|bte
operator|.
name|be_birth_txg
operator|=
name|birth_txg
expr_stmt|;
name|bte
operator|.
name|be_bp
operator|=
operator|*
name|bp
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bte
operator|.
name|be_zb
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
operator|.
name|be_zb
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|bt
operator|->
name|bt_end
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
operator|&
name|bte
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_end
operator|++
expr_stmt|;
name|bt
operator|->
name|bt_bytes
operator|+=
name|bytes
expr_stmt|;
name|bt
operator|->
name|bt_comp
operator|+=
name|comp
expr_stmt|;
name|bt
operator|->
name|bt_uncomp
operator|+=
name|uncomp
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|bptree_visit_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|bptree_args
modifier|*
name|ba
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|ba
operator|->
name|ba_func
argument_list|(
name|ba
operator|->
name|ba_arg
argument_list|,
name|bp
argument_list|,
name|ba
operator|->
name|ba_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|ba
operator|->
name|ba_free
condition|)
block|{
name|ba
operator|->
name|ba_phys
operator|->
name|bt_bytes
operator|-=
name|bp_get_dsize_sync
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ba
operator|->
name|ba_phys
operator|->
name|bt_comp
operator|-=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ba
operator|->
name|ba_phys
operator|->
name|bt_uncomp
operator|-=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bptree_iterate
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|boolean_t
name|free
parameter_list|,
name|bptree_itor_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|i
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|struct
name|bptree_args
name|ba
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|free
operator|||
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|free
condition|)
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ba
operator|.
name|ba_phys
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|ba
operator|.
name|ba_free
operator|=
name|free
expr_stmt|;
name|ba
operator|.
name|ba_func
operator|=
name|func
expr_stmt|;
name|ba
operator|.
name|ba_arg
operator|=
name|arg
expr_stmt|;
name|ba
operator|.
name|ba_tx
operator|=
name|tx
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
init|;
name|i
operator|<
name|ba
operator|.
name|ba_phys
operator|->
name|bt_end
condition|;
name|i
operator|++
control|)
block|{
name|bptree_entry_phys_t
name|bte
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|free
operator|||
name|i
operator|==
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
operator|&
name|bte
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
name|err
operator|=
name|traverse_dataset_destroyed
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
operator|&
name|bte
operator|.
name|be_bp
argument_list|,
name|bte
operator|.
name|be_birth_txg
argument_list|,
operator|&
name|bte
operator|.
name|be_zb
argument_list|,
name|TRAVERSE_PREFETCH_METADATA
operator||
name|TRAVERSE_POST
argument_list|,
name|bptree_visit_cb
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
condition|)
block|{
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ERESTART
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* save bookmark for future resume */
name|ASSERT3U
argument_list|(
name|bte
operator|.
name|be_zb
operator|.
name|zb_objset
argument_list|,
operator|==
argument_list|,
name|ZB_DESTROYED_OBJSET
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bte
operator|.
name|be_zb
operator|.
name|zb_level
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
operator|&
name|bte
argument_list|,
name|tx
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_range
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ASSERT
argument_list|(
operator|!
name|free
operator|||
name|err
operator|!=
literal|0
operator|||
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
operator|==
name|ba
operator|.
name|ba_phys
operator|->
name|bt_end
argument_list|)
expr_stmt|;
comment|/* if all blocks are free there should be no used space */
if|if
condition|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
operator|==
name|ba
operator|.
name|ba_phys
operator|->
name|bt_end
condition|)
block|{
name|ASSERT0
argument_list|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_bytes
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_comp
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_uncomp
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

