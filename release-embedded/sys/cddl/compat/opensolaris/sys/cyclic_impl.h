begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_COMPAT_OPENSOLARIS_SYS_CYCLIC_IMPL_H_
end_ifndef

begin_define
define|#
directive|define
name|_COMPAT_OPENSOLARIS_SYS_CYCLIC_IMPL_H_
end_define

begin_include
include|#
directive|include
file|<sys/cyclic.h>
end_include

begin_comment
comment|/*  *  Cyclic Subsystem Backend-supplied Interfaces  *  --------------------------------------------  *  *  0  Background  *  *    The design, implementation and interfaces of the cyclic subsystem are  *    covered in detail in block comments in the implementation.  This  *    comment covers the interface from the cyclic subsystem into the cyclic  *    backend.  The backend is specified by a structure of function pointers  *    defined below.  *  *  1  Overview  *  *      cyb_configure()<-- Configures the backend on the specified CPU  *      cyb_unconfigure()<-- Unconfigures the backend  *      cyb_enable()<-- Enables the CY_HIGH_LEVEL interrupt source  *      cyb_disable()<-- Disables the CY_HIGH_LEVEL interrupt source  *      cyb_reprogram()<-- Reprograms the CY_HIGH_LEVEL interrupt source  *      cyb_xcall()<-- Cross calls to the specified CPU  *  *  2  cyb_arg_t cyb_configure(cpu_t *)  *  *  2.1  Overview  *  *    cyb_configure() should configure the specified CPU for cyclic operation.  *  *  2.2  Arguments and notes  *  *    cyb_configure() should initialize any backend-specific per-CPU  *    structures for the specified CPU.  cyb_configure() will be called for  *    each CPU (including the boot CPU) during boot.  If the platform  *    supports dynamic reconfiguration, cyb_configure() will be called for  *    new CPUs as they are configured into the system.  *  *  2.3  Return value  *  *    cyb_configure() is expected to return a cookie (a cyb_arg_t, which is  *    of type void *) which will be used as the first argument for all future  *    cyclic calls into the backend on the specified CPU.  *  *  2.4  Caller's context  *  *    cpu_lock will be held.  The caller's CPU is unspecified, and may or  *    may not be the CPU specified to cyb_configure().  *  *  3  void cyb_unconfigure(cyb_arg_t arg)  *  *  3.1  Overview  *  *    cyb_unconfigure() should unconfigure the specified backend.  *  *  3.2  Arguments and notes  *  *    The only argument to cyb_unconfigure() is a cookie as returned from  *    cyb_configure().  *  *    cyb_unconfigure() should free any backend-specific per-CPU structures  *    for the specified backend.  cyb_unconfigure() will _only_ be called on  *    platforms which support dynamic reconfiguration.  If the platform does  *    not support dynamic reconfiguration, cyb_unconfigure() may panic.  *  *    After cyb_unconfigure() returns, the backend must not call cyclic_fire()  *    on the corresponding CPU; doing so will result in a bad trap.  *  *  3.3  Return value  *  *    None.  *  *  3.4  Caller's context  *  *    cpu_lock will be held.  The caller's CPU is unspecified, and may or  *    may not be the CPU specified to cyb_unconfigure().  The specified  *    CPU is guaranteed to exist at the time cyb_unconfigure() is called.  *    The cyclic subsystem is guaranteed to be suspended when cyb_unconfigure()  *    is called, and interrupts are guaranteed to be disabled.  *  *  4  void cyb_enable(cyb_arg_t arg)  *  *  4.1  Overview  *  *    cyb_enable() should enable the CY_HIGH_LEVEL interrupt source on  *    the specified backend.  *  *  4.2  Arguments and notes  *  *    The only argument to cyb_enable() is a backend cookie as returned from  *    cyb_configure().  *  *    cyb_enable() will only be called if a) the specified backend has never  *    been enabled or b) the specified backend has been explicitly disabled with  *    cyb_disable().  In either case, cyb_enable() will only be called if  *    the cyclic subsystem wishes to add a cyclic to the CPU corresponding  *    to the specified backend.  cyb_enable() will be called before  *    cyb_reprogram() for a given backend.  *  *    cyclic_fire() should not be called on a CPU which has not had its backend  *    explicitly cyb_enable()'d, but to do so does not constitute fatal error.  *  *  4.3  Return value  *  *    None.  *  *  4.4  Caller's context  *  *    cyb_enable() will only be called from CY_HIGH_LEVEL context on the CPU  *    corresponding to the specified backend.  *  *  5  void cyb_disable(cyb_arg_t arg)  *  *  5.1  Overview  *  *    cyb_disable() should disable the CY_HIGH_LEVEL interrupt source on  *    the specified backend.  *  *  5.2  Arguments and notes  *  *    The only argument to cyb_disable() is a backend cookie as returned from  *    cyb_configure().  *  *    cyb_disable() will only be called on backends which have been previously  *    been cyb_enable()'d.  cyb_disable() will be called when all cyclics have  *    been juggled away or removed from a cyb_enable()'d CPU.  *  *    cyclic_fire() should not be called on a CPU which has had its backend  *    explicitly cyb_disable()'d, but to do so does not constitute fatal  *    error.  cyb_disable() is thus not required to check for a pending  *    CY_HIGH_LEVEL interrupt.  *  *  5.3  Return value  *  *    None.  *  *  5.4  Caller's context  *  *    cyb_disable() will only be called from CY_HIGH_LEVEL context on the CPU  *    corresponding to the specified backend.  *  *  6  void cyb_reprogram(cyb_arg_t arg, hrtime_t time)  *  *  6.1  Overview  *  *    cyb_reprogram() should reprogram the CY_HIGH_LEVEL interrupt source  *    to fire at the absolute time specified.  *  *  6.2  Arguments and notes  *  *    The first argument to cyb_reprogram() is a backend cookie as returned from  *    cyb_configure().  *  *    The second argument is an absolute time at which the CY_HIGH_LEVEL  *    interrupt should fire.  The specified time _may_ be in the past (albeit  *    the very recent past).  If this is the case, the backend should generate  *    a CY_HIGH_LEVEL interrupt as soon as possible.  *  *    The platform should not assume that cyb_reprogram() will be called with  *    monotonically increasing values.  *  *    If the platform does not allow for interrupts at arbitrary times in the  *    future, cyb_reprogram() may do nothing -- as long as cyclic_fire() is  *    called periodically at CY_HIGH_LEVEL.  While this is clearly suboptimal  *    (cyclic granularity will be bounded by the length of the period between  *    cyclic_fire()'s), it allows the cyclic subsystem to be implemented on  *    inferior hardware.  *  *  6.3  Return value  *  *     None.  *  *  6.4  Caller's context  *  *    cyb_reprogram() will only be called from CY_HIGH_LEVEL context on the CPU  *    corresponding to the specified backend.  *  *  10  cyb_xcall(cyb_arg_t arg, cpu_t *, void(*func)(void *), void *farg)  *  *  10.1  Overview  *  *    cyb_xcall() should execute the specified function on the specified CPU.  *  *  10.2  Arguments and notes  *  *    The first argument to cyb_restore_level() is a backend cookie as returned  *    from cyb_configure().  The second argument is a CPU on which the third  *    argument, a function pointer, should be executed.  The fourth argument,  *    a void *, should be passed as the argument to the specified function.  *  *    cyb_xcall() must provide exactly-once semantics.  If the specified  *    function is called more than once, or not at all, the cyclic subsystem  *    will become internally inconsistent.  The specified function must be  *    be executed on the specified CPU, but may be executed in any context  *    (any interrupt context or kernel context).  *  *    cyb_xcall() cannot block.  Any resources which cyb_xcall() needs to  *    acquire must thus be protected by synchronization primitives which  *    never require the caller to block.  *  *  10.3  Return value  *  *    None.  *  *  10.4  Caller's context  *  *    cpu_lock will be held and kernel preemption may be disabled.  The caller  *    may be unable to block, giving rise to the constraint outlined in  *    10.2, above.  *  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cyc_backend
block|{
name|cyb_arg_t
function_decl|(
modifier|*
name|cyb_configure
function_decl|)
parameter_list|(
name|cpu_t
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|cyb_unconfigure
function_decl|)
parameter_list|(
name|cyb_arg_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|cyb_enable
function_decl|)
parameter_list|(
name|cyb_arg_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|cyb_disable
function_decl|)
parameter_list|(
name|cyb_arg_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|cyb_reprogram
function_decl|)
parameter_list|(
name|cyb_arg_t
parameter_list|,
name|hrtime_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|cyb_xcall
function_decl|)
parameter_list|(
name|cyb_arg_t
parameter_list|,
name|cpu_t
modifier|*
parameter_list|,
name|cyc_func_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|cyb_arg_t
name|cyb_arg
decl_stmt|;
block|}
name|cyc_backend_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CYF_FREE
value|0x0001
end_define

begin_typedef
typedef|typedef
struct|struct
name|cyclic
block|{
name|hrtime_t
name|cy_expire
decl_stmt|;
name|hrtime_t
name|cy_interval
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cy_handler
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|cy_arg
decl_stmt|;
name|uint16_t
name|cy_flags
decl_stmt|;
block|}
name|cyclic_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cyc_cpu
block|{
name|cpu_t
modifier|*
name|cyp_cpu
decl_stmt|;
name|cyc_index_t
modifier|*
name|cyp_heap
decl_stmt|;
name|cyclic_t
modifier|*
name|cyp_cyclics
decl_stmt|;
name|cyc_index_t
name|cyp_nelems
decl_stmt|;
name|cyc_index_t
name|cyp_size
decl_stmt|;
name|cyc_backend_t
modifier|*
name|cyp_backend
decl_stmt|;
name|struct
name|mtx
name|cyp_mtx
decl_stmt|;
block|}
name|cyc_cpu_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cyc_omni_cpu
block|{
name|cyc_cpu_t
modifier|*
name|cyo_cpu
decl_stmt|;
name|cyc_index_t
name|cyo_ndx
decl_stmt|;
name|void
modifier|*
name|cyo_arg
decl_stmt|;
name|struct
name|cyc_omni_cpu
modifier|*
name|cyo_next
decl_stmt|;
block|}
name|cyc_omni_cpu_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cyc_id
block|{
name|cyc_cpu_t
modifier|*
name|cyi_cpu
decl_stmt|;
name|cyc_index_t
name|cyi_ndx
decl_stmt|;
name|struct
name|cyc_id
modifier|*
name|cyi_prev
decl_stmt|;
name|struct
name|cyc_id
modifier|*
name|cyi_next
decl_stmt|;
name|cyc_omni_handler_t
name|cyi_omni_hdlr
decl_stmt|;
name|cyc_omni_cpu_t
modifier|*
name|cyi_omni_list
decl_stmt|;
block|}
name|cyc_id_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cyc_xcallarg
block|{
name|cyc_cpu_t
modifier|*
name|cyx_cpu
decl_stmt|;
name|cyc_handler_t
modifier|*
name|cyx_hdlr
decl_stmt|;
name|cyc_time_t
modifier|*
name|cyx_when
decl_stmt|;
name|cyc_index_t
name|cyx_ndx
decl_stmt|;
name|cyc_index_t
modifier|*
name|cyx_heap
decl_stmt|;
name|cyclic_t
modifier|*
name|cyx_cyclics
decl_stmt|;
name|cyc_index_t
name|cyx_size
decl_stmt|;
name|uint16_t
name|cyx_flags
decl_stmt|;
name|int
name|cyx_wait
decl_stmt|;
block|}
name|cyc_xcallarg_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CY_DEFAULT_PERCPU
value|1
end_define

begin_define
define|#
directive|define
name|CY_PASSIVE_LEVEL
value|-1
end_define

begin_define
define|#
directive|define
name|CY_WAIT
value|0
end_define

begin_define
define|#
directive|define
name|CY_NOWAIT
value|1
end_define

begin_define
define|#
directive|define
name|CYC_HEAP_PARENT
parameter_list|(
name|ndx
parameter_list|)
value|(((ndx) - 1)>> 1)
end_define

begin_define
define|#
directive|define
name|CYC_HEAP_RIGHT
parameter_list|(
name|ndx
parameter_list|)
value|(((ndx) + 1)<< 1)
end_define

begin_define
define|#
directive|define
name|CYC_HEAP_LEFT
parameter_list|(
name|ndx
parameter_list|)
value|((((ndx) + 1)<< 1) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

end_unit

