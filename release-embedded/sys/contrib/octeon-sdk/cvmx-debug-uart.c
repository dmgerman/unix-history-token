begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-debug.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-uart.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/octeon-boot-info.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-spinlock.h>
end_include

begin_decl_stmt
name|int
name|cvmx_debug_uart
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-debug.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-uart.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"octeon-boot-info.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * NOTE: CARE SHOULD BE TAKEN USING STD C LIBRARY FUNCTIONS IN  * THIS FILE IF SOMEONE PUTS A BREAKPOINT ON THOSE FUNCTIONS  * DEBUGGING WILL FAIL.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_TOOLCHAIN
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|weak
name|cvmx_uart_enable_intr
end_pragma

begin_decl_stmt
name|int
name|cvmx_debug_uart
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default to second uart port for backward compatibility.  The default (if    -debug does not set the uart number) can now be overridden with    CVMX_DEBUG_COMM_UART_NUM. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_DEBUG_COMM_UART_NUM
end_ifndef

begin_define
define|#
directive|define
name|CVMX_DEBUG_COMM_UART_NUM
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_debug_uart_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Interrupt handler for debugger Control-C interrupts.  *  * @param irq_number IRQ interrupt number  * @param registers  CPU registers at the time of the interrupt  * @param user_arg   Unused user argument  */
end_comment

begin_function
name|void
name|cvmx_debug_uart_process_debug_interrupt
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_uart_lsr_t
name|lsrval
decl_stmt|;
comment|/* Check for a Control-C interrupt from the debugger. This loop will eat         all input received on the uart */
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
name|cvmx_debug_uart
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|lsrval
operator|.
name|s
operator|.
name|dr
condition|)
block|{
name|int
name|c
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_RBR
argument_list|(
name|cvmx_debug_uart
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\003'
condition|)
block|{
specifier|register
name|uint64_t
name|tmp
decl_stmt|;
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pulse MCD0 signal on Ctrl-C to stop all the cores. Also                 set the MCD0 to be not masked by this core so we know                 the signal is received by someone */
asm|asm
specifier|volatile
asm|(                 "dmfc0 %0, $22\n"                 "ori   %0, %0, 0x1110\n"                 "dmtc0 %0, $22\n"                 : "=r" (tmp));
block|}
name|lsrval
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_UARTX_LSR
argument_list|(
name|cvmx_debug_uart
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_uart_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cvmx_debug_uart
operator|==
operator|-
literal|1
condition|)
name|cvmx_debug_uart
operator|=
name|CVMX_DEBUG_COMM_UART_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_uart_install_break_handler
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_TOOLCHAIN
if|if
condition|(
name|cvmx_uart_enable_intr
condition|)
endif|#
directive|endif
name|cvmx_uart_enable_intr
argument_list|(
name|cvmx_debug_uart
argument_list|,
name|cvmx_debug_uart_process_debug_interrupt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * Routines to handle hex data  *  * @param ch  * @return  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|cvmx_debug_uart_hex
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a packet from the UART, return 0 on failure and 1 on success. */
end_comment

begin_function
specifier|static
name|int
name|cvmx_debug_uart_getpacket
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|timedout
init|=
literal|0
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|ch
operator|=
name|cvmx_uart_read_byte_with_timeout
argument_list|(
name|cvmx_debug_uart
argument_list|,
operator|&
name|timedout
argument_list|,
name|__SHRT_MAX__
argument_list|)
expr_stmt|;
if|if
condition|(
name|timedout
condition|)
return|return
literal|0
return|;
comment|/* if this is not the start character, ignore it. */
if|if
condition|(
name|ch
operator|!=
literal|'$'
condition|)
continue|continue;
name|retry
label|:
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|size
condition|)
block|{
name|ch
operator|=
name|cvmx_uart_read_byte
argument_list|(
name|cvmx_debug_uart
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'$'
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|char
name|csumchars0
decl_stmt|,
name|csumchars1
decl_stmt|;
name|unsigned
name|xmitcsum
decl_stmt|;
name|int
name|n0
decl_stmt|,
name|n1
decl_stmt|;
name|csumchars0
operator|=
name|cvmx_uart_read_byte
argument_list|(
name|cvmx_debug_uart
argument_list|)
expr_stmt|;
name|csumchars1
operator|=
name|cvmx_uart_read_byte
argument_list|(
name|cvmx_debug_uart
argument_list|)
expr_stmt|;
name|n0
operator|=
name|cvmx_debug_uart_hex
argument_list|(
name|csumchars0
argument_list|)
expr_stmt|;
name|n1
operator|=
name|cvmx_debug_uart_hex
argument_list|(
name|csumchars1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n0
operator|==
operator|-
literal|1
operator|||
name|n1
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|xmitcsum
operator|=
operator|(
name|n0
operator|<<
literal|4
operator|)
operator||
name|n1
expr_stmt|;
return|return
name|checksum
operator|==
name|xmitcsum
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Put the hex value of t into str. */
end_comment

begin_function
specifier|static
name|void
name|cvmx_debug_uart_strhex
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|char
name|t
parameter_list|)
block|{
name|char
name|hexchar
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
name|hexchar
index|[
operator|(
name|t
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
name|hexchar
index|[
name|t
operator|&
literal|0xF
index|]
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvmx_debug_uart_putpacket
parameter_list|(
name|char
modifier|*
name|packet
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|packet
decl_stmt|;
name|char
name|csumstr
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|csum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|ptr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|ptr
index|[
name|i
index|]
expr_stmt|;
name|cvmx_debug_uart_strhex
argument_list|(
name|csumstr
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_debug_uart_lock
argument_list|)
expr_stmt|;
name|cvmx_uart_write_byte
argument_list|(
name|cvmx_debug_uart
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
name|cvmx_uart_write_string
argument_list|(
name|cvmx_debug_uart
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|cvmx_uart_write_byte
argument_list|(
name|cvmx_debug_uart
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|cvmx_uart_write_string
argument_list|(
name|cvmx_debug_uart
argument_list|,
name|csumstr
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_debug_uart_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_debug_uart_change_core
parameter_list|(
name|int
name|oldcore
parameter_list|,
name|int
name|newcore
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|cvmx_ciu_intx0_t
name|irq_control
decl_stmt|;
name|irq_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|newcore
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|irq_control
operator|.
name|s
operator|.
name|uart
operator||=
operator|(
literal|1u
operator|<<
name|cvmx_debug_uart
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|newcore
operator|*
literal|2
argument_list|)
argument_list|,
name|irq_control
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Disable interrupts to this core since he is about to die */
name|irq_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|oldcore
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|irq_control
operator|.
name|s
operator|.
name|uart
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|cvmx_debug_uart
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_INTX_EN0
argument_list|(
name|oldcore
operator|*
literal|2
argument_list|)
argument_list|,
name|irq_control
operator|.
name|u64
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|cvmx_debug_comm_t
name|cvmx_debug_uart_comm
init|=
block|{
operator|.
name|init
operator|=
name|cvmx_debug_uart_init
block|,
operator|.
name|install_break_handler
operator|=
name|cvmx_debug_uart_install_break_handler
block|,
operator|.
name|needs_proxy
operator|=
literal|1
block|,
operator|.
name|getpacket
operator|=
name|cvmx_debug_uart_getpacket
block|,
operator|.
name|putpacket
operator|=
name|cvmx_debug_uart_putpacket
block|,
operator|.
name|wait_for_resume
operator|=
name|NULL
block|,
operator|.
name|change_core
operator|=
name|cvmx_debug_uart_change_core
block|, }
decl_stmt|;
end_decl_stmt

end_unit

