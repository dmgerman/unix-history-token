begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-ndf-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon ndf.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_NDF_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_NDF_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_BT_PG_INFO
value|CVMX_NDF_BT_PG_INFO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_BT_PG_INFO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_BT_PG_INFO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_BT_PG_INFO
value|(CVMX_ADD_IO_SEG(0x0001070001000018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_CMD
value|CVMX_NDF_CMD_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_CMD_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_CMD not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_CMD
value|(CVMX_ADD_IO_SEG(0x0001070001000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_DRBELL
value|CVMX_NDF_DRBELL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_DRBELL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_DRBELL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_DRBELL
value|(CVMX_ADD_IO_SEG(0x0001070001000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_ECC_CNT
value|CVMX_NDF_ECC_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_ECC_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_ECC_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_ECC_CNT
value|(CVMX_ADD_IO_SEG(0x0001070001000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_INT
value|CVMX_NDF_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_INT
value|(CVMX_ADD_IO_SEG(0x0001070001000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_INT_EN
value|CVMX_NDF_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001070001000028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_MISC
value|CVMX_NDF_MISC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_MISC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_MISC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_MISC
value|(CVMX_ADD_IO_SEG(0x0001070001000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NDF_ST_REG
value|CVMX_NDF_ST_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NDF_ST_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NDF_ST_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070001000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NDF_ST_REG
value|(CVMX_ADD_IO_SEG(0x0001070001000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_ndf_bt_pg_info  *  * Notes:  * NDF_BT_PG_INFO provides page size and number of column plus row address cycles information. SW writes to this CSR  * during boot from Nand Flash. Additionally SW also writes the multiplier value for timing parameters. This value is  * used during boot, in the SET_TM_PARAM command. This information is used only by the boot load state machine and is  * otherwise a don't care, once boot is disabled. Also, boot dma's do not use this value.  *  * Bytes per Nand Flash page = 2 ** (SIZE + 1) times 256 bytes.  * 512, 1k, 2k, 4k, 8k, 16k, 32k and 64k are legal bytes per page values  *  * Legal values for ADR_CYC field are 3 through 8. SW CSR writes with a value less than 3 will write a 3 to this  * field, and a SW CSR write with a value greater than 8, will write an 8 to this field.  *  * Like all NDF_... registers, 64-bit operations must be used to access this register  */
end_comment

begin_union
union|union
name|cvmx_ndf_bt_pg_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_bt_pg_info_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|t_mult
range|:
literal|4
decl_stmt|;
comment|/**< Boot time TIM_MULT[3:0] field of SET__TM_PAR[63:0]                                                          command */
name|uint64_t
name|adr_cyc
range|:
literal|4
decl_stmt|;
comment|/**< # of column address cycles */
name|uint64_t
name|size
range|:
literal|3
decl_stmt|;
comment|/**< bytes per page in the nand device */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|3
decl_stmt|;
name|uint64_t
name|adr_cyc
range|:
literal|4
decl_stmt|;
name|uint64_t
name|t_mult
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ndf_bt_pg_info_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ndf_bt_pg_info_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_bt_pg_info_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_bt_pg_info_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_bt_pg_info_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_bt_pg_info_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_bt_pg_info
name|cvmx_ndf_bt_pg_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ndf_cmd  *  * Notes:  * When SW reads this csr, RD_VAL bit in NDF_MISC csr is cleared to 0. SW must always write all 8 bytes whenever it writes  * this csr. If there are fewer than 8 bytes left in the command sequence that SW wants the NAND flash controller to execute, it  * must insert Idle (WAIT) commands to make up 8 bytes. SW also must ensure there is enough vacancy in the command fifo to accept these  * 8 bytes, by first reading the FR_BYT field in the NDF_MISC csr.  *  * Like all NDF_... registers, 64-bit operations must be used to access this register  */
end_comment

begin_union
union|union
name|cvmx_ndf_cmd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_cmd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nf_cmd
range|:
literal|64
decl_stmt|;
comment|/**< 8 Command Bytes */
else|#
directive|else
name|uint64_t
name|nf_cmd
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ndf_cmd_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ndf_cmd_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_cmd_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_cmd_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_cmd_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_cmd_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_cmd
name|cvmx_ndf_cmd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ndf_drbell  *  * Notes:  * SW csr writes will increment CNT by the signed 8 bit value being written. SW csr reads return the current CNT value.  * HW will also modify the value of the CNT field. Everytime HW executes a BUS_ACQ[15:0] command, to arbitrate and win the  * flash bus, it decrements the CNT field by 1. If the CNT field is already 0 or negative, HW command execution unit will  * stall when it fetches the new BUS_ACQ[15:0] command, from the command fifo. Only when the SW writes to this CSR with a  * non-zero data value, can the execution unit come out of the stalled condition, and resume execution.  *  * The intended use of this doorbell CSR is to control execution of the Nand Flash commands. The NDF execution unit  * has to arbitrate for the flash bus, before it can enable a Nand Flash device connected to the Octeon chip, by  * asserting the device's chip enable. Therefore SW should first load the command fifo, with a full sequence of  * commands to perform a Nand Flash device task. This command sequence will start with a bus acquire command and  * the last command in the sequence will be a bus release command. The execution unit will start execution of  * the sequence only if the [CNT] field is non-zero when it fetches the bus acquire command, which is the first  * command in this sequence. SW can also, load multiple such sequences, each starting with a chip enable command  * and ending with a chip disable command, and then write a non-zero data value to this csr to increment the  * CNT field by the number of the command sequences, loaded to the command fifo.  *  * Like all NDF_... registers, 64-bit operations must be used to access this register  */
end_comment

begin_union
union|union
name|cvmx_ndf_drbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_drbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|8
decl_stmt|;
comment|/**< Doorbell count register, 2's complement 8 bit value */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ndf_drbell_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ndf_drbell_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_drbell_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_drbell_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_drbell_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_drbell_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_drbell
name|cvmx_ndf_drbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ndf_ecc_cnt  *  * Notes:  * XOR_ECC[31:8] = [ecc_gen_byt258, ecc_gen_byt257, ecc_gen_byt256] xor [ecc_258, ecc_257, ecc_256]  *         ecc_258, ecc_257 and ecc_256 are bytes stored in Nand Flash and read out during boot  *         ecc_gen_byt258, ecc_gen_byt257, ecc_gen_byt256 are generated from data read out from Nand Flash  *  * Like all NDF_... registers, 64-bit operations must be used to access this register  */
end_comment

begin_union
union|union
name|cvmx_ndf_ecc_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_ecc_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|xor_ecc
range|:
literal|24
decl_stmt|;
comment|/**< result of XOR of ecc read bytes and ecc genarated                                                          bytes. The value pertains to the last 1 bit ecc err */
name|uint64_t
name|ecc_err
range|:
literal|8
decl_stmt|;
comment|/**< Count = \# of 1 bit errors fixed during boot                                                          This count saturates instead of wrapping around. */
else|#
directive|else
name|uint64_t
name|ecc_err
range|:
literal|8
decl_stmt|;
name|uint64_t
name|xor_ecc
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ndf_ecc_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ndf_ecc_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_ecc_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_ecc_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_ecc_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_ecc_cnt_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_ecc_cnt
name|cvmx_ndf_ecc_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ndf_int  *  * Notes:  * FULL status is updated when the command fifo becomes full as a result of SW writing a new command to it.  *  * EMPTY status is updated when the command fifo becomes empty as a result of command execution unit fetching the  * last instruction out of the command fifo.  *  * Like all NDF_... registers, 64-bit operations must be used to access this register  */
end_comment

begin_union
union|union
name|cvmx_ndf_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|ovrf
range|:
literal|1
decl_stmt|;
comment|/**< NDF_CMD write when fifo is full. Generally a                                                          fatal error. */
name|uint64_t
name|ecc_mult
range|:
literal|1
decl_stmt|;
comment|/**< Multi bit ECC error detected during boot */
name|uint64_t
name|ecc_1bit
range|:
literal|1
decl_stmt|;
comment|/**< Single bit ECC error detected and fixed during boot */
name|uint64_t
name|sm_bad
range|:
literal|1
decl_stmt|;
comment|/**< One of the state machines in a bad state */
name|uint64_t
name|wdog
range|:
literal|1
decl_stmt|;
comment|/**< Watch Dog timer expired during command execution */
name|uint64_t
name|full
range|:
literal|1
decl_stmt|;
comment|/**< Command fifo is full */
name|uint64_t
name|empty
range|:
literal|1
decl_stmt|;
comment|/**< Command fifo is empty */
else|#
directive|else
name|uint64_t
name|empty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wdog
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sm_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_1bit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_mult
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ndf_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_int
name|cvmx_ndf_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ndf_int_en  *  * Notes:  * Like all NDF_... registers, 64-bit operations must be used to access this register  *  */
end_comment

begin_union
union|union
name|cvmx_ndf_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|ovrf
range|:
literal|1
decl_stmt|;
comment|/**< Wrote to a full command fifo */
name|uint64_t
name|ecc_mult
range|:
literal|1
decl_stmt|;
comment|/**< Multi bit ECC error detected during boot */
name|uint64_t
name|ecc_1bit
range|:
literal|1
decl_stmt|;
comment|/**< Single bit ECC error detected and fixed during boot */
name|uint64_t
name|sm_bad
range|:
literal|1
decl_stmt|;
comment|/**< One of the state machines in a bad state */
name|uint64_t
name|wdog
range|:
literal|1
decl_stmt|;
comment|/**< Watch Dog timer expired during command execution */
name|uint64_t
name|full
range|:
literal|1
decl_stmt|;
comment|/**< Command fifo is full */
name|uint64_t
name|empty
range|:
literal|1
decl_stmt|;
comment|/**< Command fifo is empty */
else|#
directive|else
name|uint64_t
name|empty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wdog
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sm_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_1bit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecc_mult
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ndf_int_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_int_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_int_en_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_int_en
name|cvmx_ndf_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ndf_misc  *  * Notes:  * NBR_HWM this field specifies the high water mark for the NCB outbound load/store commands receive fifo.  *   the fifo size is 16 entries.  *  * WAIT_CNT this field allows glitch filtering of the WAIT_n input to octeon, from Flash Memory. The count  *   represents number of eclk cycles.  *  * FR_BYT  this field specifies \# of unfilled bytes in the command fifo. Bytes become unfilled as commands  *   complete execution and exit. (fifo is 256 bytes when BT_DIS=0,  and 1536 bytes when BT_DIS=1)  *  * RD_DONE this W1C bit is set to 1 by HW when it reads the last 8 bytes out of the command fifo,  *   in response to RD_CMD bit being set to 1 by SW.  *  * RD_VAL  this read only bit is set to 1 by HW when it reads next 8 bytes from command fifo in response  *   to RD_CMD bit being set to 1. A SW read of NDF_CMD csr clears this bit to 0.  *  * RD_CMD  this R/W bit starts read out from the command fifo, 8 bytes at a time. SW should first read the  *   RD_VAL bit in  this csr to see if next 8 bytes from the command fifo are available in the  *   NDF_CMD csr. All command fifo reads start and end on an 8 byte boundary. A RD_CMD in the  *   middle of command execution will cause the execution to freeze until RD_DONE is set to 1. RD_CMD  *   bit will be cleared on any NDF_CMD csr write by SW.  *  * BT_DMA  this indicates to the NAND flash boot control state machine that boot dma read can begin.  *   SW should set this bit to 1 after SW has loaded the command fifo. HW sets the bit to 0  *   when boot dma command execution is complete. If chip enable 0 is not nand flash, this bit is  *   permanently 1'b0 with SW writes ignored. Whenever BT_DIS=1, this bit will be 0.  *  * BT_DIS  this R/W bit indicates to NAND flash boot control state machine that boot operation has ended.  *   whenever this bit changes from 0 to a 1, the command fifo is emptied as a side effect. This bit must  *   never be set when booting from nand flash and region zero is enabled.  *  * EX_DIS  When 1, command execution stops after completing execution of all commands currently in the command  *   fifo. Once command execution has stopped, and then new commands are loaded into the command fifo, execution  *   will not resume as long as this bit is 1. When this bit is 0, command execution will resume if command fifo  *   is not empty. EX_DIS should be set to 1, during boot i.e. when BT_DIS = 0.  *  * RST_FF  reset command fifo to make it empty, any command inflight is not aborted before reseting  *   the fifo. The fifo comes up empty at the end of power on reset.  *  * Like all NDF_... registers, 64-bit operations must be used to access this register  */
end_comment

begin_union
union|union
name|cvmx_ndf_misc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_misc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|mb_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable multibit error hangs and allow boot loads                                                          or boot dma's proceed as if no multi bit errors                                                          occured. HW will fix single bit errors as usual */
name|uint64_t
name|nbr_hwm
range|:
literal|3
decl_stmt|;
comment|/**< Hi Water mark for NBR fifo or load/stores */
name|uint64_t
name|wait_cnt
range|:
literal|6
decl_stmt|;
comment|/**< WAIT input filter count */
name|uint64_t
name|fr_byt
range|:
literal|11
decl_stmt|;
comment|/**< Number of unfilled Command fifo bytes */
name|uint64_t
name|rd_done
range|:
literal|1
decl_stmt|;
comment|/**< This W1C bit is set to 1 by HW when it completes                                                          command fifo read out, in response to RD_CMD */
name|uint64_t
name|rd_val
range|:
literal|1
decl_stmt|;
comment|/**< This RO bit is set to 1 by HW when it reads next 8                                                          bytes from Command fifo into the NDF_CMD csr                                                          SW reads NDF_CMD csr, HW clears this bit to 0 */
name|uint64_t
name|rd_cmd
range|:
literal|1
decl_stmt|;
comment|/**< When 1, HW reads out contents of the Command fifo 8                                                          bytes at a time into the NDF_CMD csr */
name|uint64_t
name|bt_dma
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, boot time dma is enabled */
name|uint64_t
name|bt_dis
range|:
literal|1
decl_stmt|;
comment|/**< When boot operation is over SW must set to 1                                                          causes boot state mchines to sleep */
name|uint64_t
name|ex_dis
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, suspends execution of commands at                                                          next command in the fifo. */
name|uint64_t
name|rst_ff
range|:
literal|1
decl_stmt|;
comment|/**< 1=reset command fifo to make it empty,                                                          0=normal operation */
else|#
directive|else
name|uint64_t
name|rst_ff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ex_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bt_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bt_dma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fr_byt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|wait_cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|nbr_hwm
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mb_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ndf_misc_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|nbr_hwm
range|:
literal|3
decl_stmt|;
comment|/**< Hi Water mark for NBR fifo or load/stores */
name|uint64_t
name|wait_cnt
range|:
literal|6
decl_stmt|;
comment|/**< WAIT input filter count */
name|uint64_t
name|fr_byt
range|:
literal|11
decl_stmt|;
comment|/**< Number of unfilled Command fifo bytes */
name|uint64_t
name|rd_done
range|:
literal|1
decl_stmt|;
comment|/**< This W1C bit is set to 1 by HW when it completes                                                          command fifo read out, in response to RD_CMD */
name|uint64_t
name|rd_val
range|:
literal|1
decl_stmt|;
comment|/**< This RO bit is set to 1 by HW when it reads next 8                                                          bytes from Command fifo into the NDF_CMD csr                                                          SW reads NDF_CMD csr, HW clears this bit to 0 */
name|uint64_t
name|rd_cmd
range|:
literal|1
decl_stmt|;
comment|/**< When 1, HW reads out contents of the Command fifo 8                                                          bytes at a time into the NDF_CMD csr */
name|uint64_t
name|bt_dma
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, boot time dma is enabled */
name|uint64_t
name|bt_dis
range|:
literal|1
decl_stmt|;
comment|/**< When boot operation is over SW must set to 1                                                          causes boot state mchines to sleep */
name|uint64_t
name|ex_dis
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, suspends execution of commands at                                                          next command in the fifo. */
name|uint64_t
name|rst_ff
range|:
literal|1
decl_stmt|;
comment|/**< 1=reset command fifo to make it empty,                                                          0=normal operation */
else|#
directive|else
name|uint64_t
name|rst_ff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ex_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bt_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bt_dma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fr_byt
range|:
literal|11
decl_stmt|;
name|uint64_t
name|wait_cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|nbr_hwm
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_ndf_misc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_misc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_misc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_misc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_misc_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_misc
name|cvmx_ndf_misc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ndf_st_reg  *  * Notes:  * This CSR aggregates all state machines used in nand flash controller for debug.  * Like all NDF_... registers, 64-bit operations must be used to access this register  */
end_comment

begin_union
union|union
name|cvmx_ndf_st_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ndf_st_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|exe_idle
range|:
literal|1
decl_stmt|;
comment|/**< Command Execution status 1=IDLE, 0=Busy                                                          1 means execution of command sequence is complete                                                          and command fifo is empty */
name|uint64_t
name|exe_sm
range|:
literal|4
decl_stmt|;
comment|/**< Command Execution State machine states */
name|uint64_t
name|bt_sm
range|:
literal|4
decl_stmt|;
comment|/**< Boot load and Boot dma State machine states */
name|uint64_t
name|rd_ff_bad
range|:
literal|1
decl_stmt|;
comment|/**< CMD fifo read back State machine in bad state */
name|uint64_t
name|rd_ff
range|:
literal|2
decl_stmt|;
comment|/**< CMD fifo read back State machine states */
name|uint64_t
name|main_bad
range|:
literal|1
decl_stmt|;
comment|/**< Main State machine in bad state */
name|uint64_t
name|main_sm
range|:
literal|3
decl_stmt|;
comment|/**< Main State machine states */
else|#
directive|else
name|uint64_t
name|main_sm
range|:
literal|3
decl_stmt|;
name|uint64_t
name|main_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_ff
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rd_ff_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bt_sm
range|:
literal|4
decl_stmt|;
name|uint64_t
name|exe_sm
range|:
literal|4
decl_stmt|;
name|uint64_t
name|exe_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ndf_st_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ndf_st_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ndf_st_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_ndf_st_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_ndf_st_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ndf_st_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ndf_st_reg
name|cvmx_ndf_st_reg_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

