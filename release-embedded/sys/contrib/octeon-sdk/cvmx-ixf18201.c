begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/* This file contains support functions for the Cortina IXF18201 SPI->XAUI dual ** MAC.  The IXF18201 has dual SPI and dual XAUI interfaces to provide 2 10 gigabit ** interfaces. ** This file supports the EBT5810 evaluation board.  To support a different board, ** the 16 bit read/write functions would need to be customized for that board, and the ** IXF18201 may need to be initialized differently as well. ** ** The IXF18201 and Octeon are configured for 2 SPI channels per interface (ports 0/1, and 16/17). ** Ports 0 and 16 are the ports that are connected to the XAUI MACs (which are connected to the SFP+ modules) ** Ports 1 and 17 are connected to the hairpin loopback port on the IXF SPI interface.  All packets sent out ** of these ports are looped back the same port they were sent on.  The loopback ports are always enabled. ** ** The MAC address filtering on the IXF is not enabled.  Link up/down events are not detected, only SPI status ** is monitored by default, which is independent of the XAUI/SFP+ link status. ** ** */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_define
define|#
directive|define
name|PAL_BASE
value|(1ull<< 63 | 0x1d030000)
end_define

begin_define
define|#
directive|define
name|IXF_ADDR_HI
value|(PAL_BASE + 0xa)
end_define

begin_define
define|#
directive|define
name|IXF_ADDR_LO
value|(PAL_BASE + 0xb)
end_define

begin_define
define|#
directive|define
name|IXF_ADDR_16
value|IXF_ADDR_HI
end_define

begin_comment
comment|/* 16 bit access */
end_comment

begin_define
define|#
directive|define
name|IXF_WR_DATA_HI
value|(PAL_BASE + 0xc)
end_define

begin_define
define|#
directive|define
name|IXF_WR_DATA_LO
value|(PAL_BASE + 0xd)
end_define

begin_define
define|#
directive|define
name|IXF_WR_DATA_16
value|IXF_WR_DATA_HI
end_define

begin_define
define|#
directive|define
name|IXF_RD_DATA_HI
value|(PAL_BASE + 0x10)
end_define

begin_define
define|#
directive|define
name|IXF_RD_DATA_LO
value|(PAL_BASE + 0x11)
end_define

begin_define
define|#
directive|define
name|IXF_RD_DATA_16
value|IXF_RD_DATA_HI
end_define

begin_define
define|#
directive|define
name|IXF_TRANS_TYPE
value|(PAL_BASE + 0xe)
end_define

begin_define
define|#
directive|define
name|IXF_TRANS_STATUS
value|(PAL_BASE + 0xf)
end_define

begin_function
name|uint16_t
name|cvmx_ixf18201_read16
parameter_list|(
name|uint16_t
name|reg_addr
parameter_list|)
block|{
name|cvmx_write64_uint16
argument_list|(
name|IXF_ADDR_16
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|cvmx_write64_uint8
argument_list|(
name|IXF_TRANS_TYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Do read
name|cvmx_wait
argument_list|(
literal|800000
argument_list|)
expr_stmt|;
comment|/* Read result */
return|return
operator|(
name|cvmx_read64_uint16
argument_list|(
name|IXF_RD_DATA_16
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_ixf18201_write16
parameter_list|(
name|uint16_t
name|reg_addr
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|cvmx_write64_uint16
argument_list|(
name|IXF_ADDR_16
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|cvmx_write64_uint16
argument_list|(
name|IXF_WR_DATA_16
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cvmx_write64_uint8
argument_list|(
name|IXF_TRANS_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|800000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|cvmx_ixf18201_read32
parameter_list|(
name|uint16_t
name|reg_addr
parameter_list|)
block|{
name|uint32_t
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
name|reg_addr
operator|&
literal|0x1
condition|)
block|{
return|return
operator|(
literal|0xdeadbeef
operator|)
return|;
block|}
name|lo
operator|=
name|cvmx_ixf18201_read16
argument_list|(
name|reg_addr
argument_list|)
expr_stmt|;
name|hi
operator|=
name|cvmx_ixf18201_read16
argument_list|(
name|reg_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|hi
operator|<<
literal|16
operator|)
operator||
name|lo
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_ixf18201_write32
parameter_list|(
name|uint16_t
name|reg_addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint16_t
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
name|reg_addr
operator|&
literal|0x1
condition|)
block|{
return|return;
block|}
name|lo
operator|=
name|data
operator|&
literal|0xFFFF
expr_stmt|;
name|hi
operator|=
name|data
operator|>>
literal|16
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
name|reg_addr
argument_list|,
name|lo
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
name|reg_addr
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IXF_REG_MDI_CMD_ADDR1
value|0x310E
end_define

begin_define
define|#
directive|define
name|IXF_REG_MDI_RD_WR1
value|0x3110
end_define

begin_function
name|void
name|cvmx_ixf18201_mii_write
parameter_list|(
name|int
name|mii_addr
parameter_list|,
name|int
name|mmd
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|uint32_t
name|cmd_val
init|=
literal|0
decl_stmt|;
name|cmd_val
operator|=
name|reg
expr_stmt|;
name|cmd_val
operator||=
literal|0x0
operator|<<
literal|26
expr_stmt|;
comment|// Set address operation
name|cmd_val
operator||=
operator|(
name|mii_addr
operator|&
literal|0x1f
operator|)
operator|<<
literal|21
expr_stmt|;
comment|// Set PHY addr
name|cmd_val
operator||=
operator|(
name|mmd
operator|&
literal|0x1f
operator|)
operator|<<
literal|16
expr_stmt|;
comment|// Set MMD
name|cmd_val
operator||=
literal|1
operator|<<
literal|30
expr_stmt|;
comment|// Do operation
name|cmd_val
operator||=
literal|1
operator|<<
literal|31
expr_stmt|;
comment|// enable in progress bit
comment|/* Set up address */
name|cvmx_ixf18201_write32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|,
name|cmd_val
argument_list|)
expr_stmt|;
while|while
condition|(
name|cvmx_ixf18201_read32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
empty_stmt|;
comment|/* Wait for operation to complete */
name|cvmx_ixf18201_write32
argument_list|(
name|IXF_REG_MDI_RD_WR1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Do read operation */
name|cmd_val
operator|=
literal|0
expr_stmt|;
name|cmd_val
operator||=
literal|0x1
operator|<<
literal|26
expr_stmt|;
comment|// Set write operation
name|cmd_val
operator||=
operator|(
name|mii_addr
operator|&
literal|0x1f
operator|)
operator|<<
literal|21
expr_stmt|;
comment|// Set PHY addr
name|cmd_val
operator||=
operator|(
name|mmd
operator|&
literal|0x1f
operator|)
operator|<<
literal|16
expr_stmt|;
comment|// Set MMD
name|cmd_val
operator||=
literal|1
operator|<<
literal|30
expr_stmt|;
comment|// Do operation
name|cmd_val
operator||=
literal|1
operator|<<
literal|31
expr_stmt|;
comment|// enable in progress bit
name|cvmx_ixf18201_write32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|,
name|cmd_val
argument_list|)
expr_stmt|;
while|while
condition|(
name|cvmx_ixf18201_read32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
empty_stmt|;
comment|/* Wait for operation to complete */
block|}
end_function

begin_function
name|int
name|cvmx_ixf18201_mii_read
parameter_list|(
name|int
name|mii_addr
parameter_list|,
name|int
name|mmd
parameter_list|,
name|uint16_t
name|reg
parameter_list|)
block|{
name|uint32_t
name|cmd_val
init|=
literal|0
decl_stmt|;
name|cmd_val
operator|=
name|reg
expr_stmt|;
name|cmd_val
operator||=
literal|0x0
operator|<<
literal|26
expr_stmt|;
comment|// Set address operation
name|cmd_val
operator||=
operator|(
name|mii_addr
operator|&
literal|0x1f
operator|)
operator|<<
literal|21
expr_stmt|;
comment|// Set PHY addr
name|cmd_val
operator||=
operator|(
name|mmd
operator|&
literal|0x1f
operator|)
operator|<<
literal|16
expr_stmt|;
comment|// Set MMD
name|cmd_val
operator||=
literal|1
operator|<<
literal|30
expr_stmt|;
comment|// Do operation
name|cmd_val
operator||=
literal|1
operator|<<
literal|31
expr_stmt|;
comment|// enable in progress bit
comment|/* Set up address */
name|cvmx_ixf18201_write32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|,
name|cmd_val
argument_list|)
expr_stmt|;
while|while
condition|(
name|cvmx_ixf18201_read32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
empty_stmt|;
comment|/* Wait for operation to complete */
comment|/* Do read operation */
name|cmd_val
operator|=
literal|0
expr_stmt|;
name|cmd_val
operator||=
literal|0x3
operator|<<
literal|26
expr_stmt|;
comment|// Set read operation
name|cmd_val
operator||=
operator|(
name|mii_addr
operator|&
literal|0x1f
operator|)
operator|<<
literal|21
expr_stmt|;
comment|// Set PHY addr
name|cmd_val
operator||=
operator|(
name|mmd
operator|&
literal|0x1f
operator|)
operator|<<
literal|16
expr_stmt|;
comment|// Set MMD
name|cmd_val
operator||=
literal|1
operator|<<
literal|30
expr_stmt|;
comment|// Do operation
name|cmd_val
operator||=
literal|1
operator|<<
literal|31
expr_stmt|;
comment|// enable in progress bit
name|cvmx_ixf18201_write32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|,
name|cmd_val
argument_list|)
expr_stmt|;
while|while
condition|(
name|cvmx_ixf18201_read32
argument_list|(
name|IXF_REG_MDI_CMD_ADDR1
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
empty_stmt|;
comment|/* Wait for operation to complete */
name|cmd_val
operator|=
name|cvmx_ixf18201_read32
argument_list|(
name|IXF_REG_MDI_RD_WR1
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd_val
operator|>>
literal|16
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_ixf18201_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
comment|/* For indexing the two 'ports' on ixf */
name|int
name|offset
decl_stmt|;
comment|/* Reset IXF, and take all blocks out of reset */
comment|/* Initializing... PP0:~CONSOLE-> Changing register value, addr 0x0003, old: 0x0000, new: 0x0001 PP0:~CONSOLE-> Changing register value, addr 0x0003, old: 0x0001, new: 0x0000 PP0:~CONSOLE->  **** LLM201(Lochlomond) Driver loaded **** PP0:~CONSOLE->  LLM201 Driver - Released on Tue Aug 28 09:51:30 2007. PP0:~CONSOLE-> retval is: 0 PP0:~CONSOLE-> Changing register value, addr 0x0003, old: 0x0000, new: 0x0001 PP0:~CONSOLE-> Changing register value, addr 0x0003, old: 0x0001, new: 0x0000 PP0:~CONSOLE-> Brought all blocks out of reset PP0:~CONSOLE-> Getting default config. */
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0003
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0003
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* PP0:~CONSOLE-> Changing register value, addr 0x0000, old: 0x4014, new: 0x4010 PP0:~CONSOLE-> Changing register value, addr 0x0000, old: 0x4010, new: 0x4014 PP0:~CONSOLE-> Changing register value, addr 0x0004, old: 0x01ff, new: 0x0140 PP0:~CONSOLE-> Changing register value, addr 0x0009, old: 0x007f, new: 0x0000     */
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0000
argument_list|,
literal|0x4010
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0000
argument_list|,
literal|0x4014
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0004
argument_list|,
literal|0x0140
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0009
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* PP0:~CONSOLE-> Changing register value, addr 0x000e, old: 0x0000, new: 0x000f PP0:~CONSOLE-> Changing register value, addr 0x000f, old: 0x0000, new: 0x0004 PP0:~CONSOLE-> Changing register value, addr 0x000f, old: 0x0004, new: 0x0006 PP0:~CONSOLE-> Changing register value, addr 0x000e, old: 0x000f, new: 0x00f0 PP0:~CONSOLE-> Changing register value, addr 0x000f, old: 0x0006, new: 0x0040 PP0:~CONSOLE-> Changing register value, addr 0x000f, old: 0x0040, new: 0x0060     */
comment|// skip GPIO, 0xe/0xf
comment|/* PP0:~CONSOLE-> Changing register value, addr 0x3100, old: 0x57fb, new: 0x7f7b PP0:~CONSOLE-> Changing register value, addr 0x3600, old: 0x57fb, new: 0x7f7b PP0:~CONSOLE-> Changing register value, addr 0x3005, old: 0x8010, new: 0x0040 PP0:~CONSOLE-> Changing register value, addr 0x3006, old: 0x061a, new: 0x0000 PP0:~CONSOLE-> Changing register value, addr 0x3505, old: 0x8010, new: 0x0040 PP0:~CONSOLE-> Changing register value, addr 0x3506, old: 0x061a, new: 0x0000     */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|2
condition|;
name|index
operator|++
control|)
block|{
name|offset
operator|=
literal|0x500
operator|*
name|index
expr_stmt|;
name|cvmx_ixf18201_write32
argument_list|(
literal|0x3100
operator|+
name|offset
argument_list|,
literal|0x47f7b
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3005
operator|+
name|offset
argument_list|,
literal|0x0040
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3006
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*PP0:~CONSOLE->   *** SPI soft reset ***, block id: 0 PP0:~CONSOLE-> Changing register value, addr 0x3007, old: 0xf980, new: 0xf9c0 PP0:~CONSOLE-> Changing register value, addr 0x3008, old: 0xa6f0, new: 0x36f0 PP0:~CONSOLE-> Changing register value, addr 0x3000, old: 0x0080, new: 0x0060 PP0:~CONSOLE-> Changing register value, addr 0x3002, old: 0x0200, new: 0x0040 PP0:~CONSOLE-> Changing register value, addr 0x3003, old: 0x0100, new: 0x0000 PP0:~CONSOLE-> Changing register value, addr 0x30c2, old: 0x0080, new: 0x0060 PP0:~CONSOLE-> Changing register value, addr 0x300a, old: 0x0800, new: 0x0000 PP0:~CONSOLE-> Changing register value, addr 0x3007, old: 0xf9c0, new: 0x89c0 PP0:~CONSOLE-> Changing register value, addr 0x3016, old: 0x0000, new: 0x0010 PP0:~CONSOLE-> Changing register value, addr 0x3008, old: 0x36f0, new: 0x3610 PP0:~CONSOLE-> Changing register value, addr 0x3012, old: 0x0000, new: 0x0010 PP0:~CONSOLE-> Changing register value, addr 0x3007, old: 0x89c0, new: 0x8980 PP0:~CONSOLE-> Changing register value, addr 0x3008, old: 0x3610, new: 0xa210 PP0:~CONSOLE->      */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|2
condition|;
name|index
operator|++
control|)
block|{
name|offset
operator|=
literal|0x500
operator|*
name|index
expr_stmt|;
name|int
name|cal_len_min_1
init|=
literal|0
decl_stmt|;
comment|/* Calendar length -1.  Must match number                                 ** of ports configured for interface.*/
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3007
operator|+
name|offset
argument_list|,
literal|0x81c0
operator||
operator|(
name|cal_len_min_1
operator|<<
literal|11
operator|)
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3008
operator|+
name|offset
argument_list|,
literal|0x3600
operator||
operator|(
name|cal_len_min_1
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3000
operator|+
name|offset
argument_list|,
literal|0x0060
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3002
operator|+
name|offset
argument_list|,
literal|0x0040
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3003
operator|+
name|offset
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x30c2
operator|+
name|offset
argument_list|,
literal|0x0060
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x300a
operator|+
name|offset
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3007
operator|+
name|offset
argument_list|,
literal|0x81c0
operator||
operator|(
name|cal_len_min_1
operator|<<
literal|11
operator|)
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3016
operator|+
name|offset
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3008
operator|+
name|offset
argument_list|,
literal|0x3600
operator||
operator|(
name|cal_len_min_1
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3012
operator|+
name|offset
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3007
operator|+
name|offset
argument_list|,
literal|0x8180
operator||
operator|(
name|cal_len_min_1
operator|<<
literal|11
operator|)
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3008
operator|+
name|offset
argument_list|,
literal|0xa200
operator||
operator|(
name|cal_len_min_1
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x3090
operator|+
name|offset
argument_list|,
literal|0x0301
argument_list|)
expr_stmt|;
comment|/* Enable hairpin loopback */
block|}
comment|/* PP0:~CONSOLE-> Changing register value, addr 0x0004, old: 0x0140, new: 0x1fff PP0:~CONSOLE-> Changing register value, addr 0x0009, old: 0x0000, new: 0x007f PP0:~CONSOLE-> Changing register value, addr 0x310b, old: 0x0004, new: 0xffff PP0:~CONSOLE-> Changing register value, addr 0x310a, old: 0x7f7b, new: 0xffff      */
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0004
argument_list|,
literal|0x1fff
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_write16
argument_list|(
literal|0x0009
argument_list|,
literal|0x007f
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* MDI autoscan */
block|cvmx_ixf18201_write16(0x310b, 0xffff);     cvmx_ixf18201_write16(0x310a, 0xffff);
endif|#
directive|endif
comment|/*     *** 32 bit register, trace only captures part of it... PP0:~CONSOLE-> Changing register value, addr 0x3100, old: 0x7f7b, new: 0x7f78 PP0:~CONSOLE-> Changing register value, addr 0x3600, old: 0x7f7b, new: 0x7f78     */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|2
condition|;
name|index
operator|++
control|)
block|{
name|offset
operator|=
literal|0x500
operator|*
name|index
expr_stmt|;
name|cvmx_ixf18201_write32
argument_list|(
literal|0x3100
operator|+
name|offset
argument_list|,
literal|0x47f7c
argument_list|)
expr_stmt|;
comment|/* Also enable jumbo frames */
comment|/* Set max packet size to 9600 bytes, max supported by IXF18201 */
name|cvmx_ixf18201_write32
argument_list|(
literal|0x3114
operator|+
name|offset
argument_list|,
literal|0x25800000
argument_list|)
expr_stmt|;
block|}
name|cvmx_wait
argument_list|(
literal|100000000
argument_list|)
expr_stmt|;
comment|/* Now reset the PCS blocks in the phy.  This seems to be required after     ** bringing up the Cortina. */
name|cvmx_ixf18201_mii_write
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|cvmx_ixf18201_mii_write
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

