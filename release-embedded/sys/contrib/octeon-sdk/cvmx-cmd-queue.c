begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Support functions for managing command queues used for  * various hardware blocks.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-bootmem.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-npei-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dpi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pko-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-fpa.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-cmd-queue.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-cmd-queue.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * This application uses this pointer to access the global queue  * state. It points to a bootmem named block.  */
end_comment

begin_decl_stmt
name|CVMX_SHARED
name|__cvmx_cmd_queue_all_state_t
modifier|*
name|__cvmx_cmd_queue_state_ptr
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|__cvmx_cmd_queue_state_ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Initialize the Global queue state pointer.  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
end_comment

begin_function
specifier|static
name|cvmx_cmd_queue_result_t
name|__cvmx_cmd_queue_init_state_ptr
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|alloc_name
init|=
literal|"cvmx_cmd_queues"
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CAVIUM_RESERVE32
argument_list|)
operator|&&
name|CONFIG_CAVIUM_RESERVE32
specifier|extern
name|uint64_t
name|octeon_reserve32_memory
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cvmx_likely
argument_list|(
name|__cvmx_cmd_queue_state_ptr
argument_list|)
condition|)
return|return
name|CVMX_CMD_QUEUE_SUCCESS
return|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CAVIUM_RESERVE32
argument_list|)
operator|&&
name|CONFIG_CAVIUM_RESERVE32
if|if
condition|(
name|octeon_reserve32_memory
condition|)
name|__cvmx_cmd_queue_state_ptr
operator|=
name|cvmx_bootmem_alloc_named_range
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|__cvmx_cmd_queue_state_ptr
argument_list|)
argument_list|,
name|octeon_reserve32_memory
argument_list|,
name|octeon_reserve32_memory
operator|+
operator|(
name|CONFIG_CAVIUM_RESERVE32
operator|<<
literal|20
operator|)
operator|-
literal|1
argument_list|,
literal|128
argument_list|,
name|alloc_name
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|__cvmx_cmd_queue_state_ptr
operator|=
name|cvmx_bootmem_alloc_named
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|__cvmx_cmd_queue_state_ptr
argument_list|)
argument_list|,
literal|128
argument_list|,
name|alloc_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|__cvmx_cmd_queue_state_ptr
operator|=
name|cvmx_bootmem_alloc_named
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|__cvmx_cmd_queue_state_ptr
argument_list|)
argument_list|,
literal|128
argument_list|,
name|alloc_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__cvmx_cmd_queue_state_ptr
condition|)
name|memset
argument_list|(
name|__cvmx_cmd_queue_state_ptr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|__cvmx_cmd_queue_state_ptr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|block_desc
init|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|alloc_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|block_desc
condition|)
name|__cvmx_cmd_queue_state_ptr
operator|=
name|cvmx_phys_to_ptr
argument_list|(
name|block_desc
operator|->
name|base_addr
argument_list|)
expr_stmt|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_initialize: Unable to get named block %s.\n"
argument_list|,
name|alloc_name
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_NO_MEMORY
return|;
block|}
block|}
return|return
name|CVMX_CMD_QUEUE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a command queue for use. The initial FPA buffer is  * allocated and the hardware unit is configured to point to the  * new command queue.  *  * @param queue_id  Hardware command queue to initialize.  * @param max_depth Maximum outstanding commands that can be queued.  * @param fpa_pool  FPA pool the command queues should come from.  * @param pool_size Size of each buffer in the FPA pool (bytes)  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
end_comment

begin_function
name|cvmx_cmd_queue_result_t
name|cvmx_cmd_queue_initialize
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|,
name|int
name|max_depth
parameter_list|,
name|int
name|fpa_pool
parameter_list|,
name|int
name|pool_size
parameter_list|)
block|{
name|__cvmx_cmd_queue_state_t
modifier|*
name|qstate
decl_stmt|;
name|cvmx_cmd_queue_result_t
name|result
init|=
name|__cvmx_cmd_queue_init_state_ptr
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|CVMX_CMD_QUEUE_SUCCESS
condition|)
return|return
name|result
return|;
name|qstate
operator|=
name|__cvmx_cmd_queue_get_state
argument_list|(
name|queue_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstate
operator|==
name|NULL
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
comment|/* We artificially limit max_depth to 1<<20 words. It is an arbitrary limit */
if|if
condition|(
name|CVMX_CMD_QUEUE_ENABLE_MAX_DEPTH
condition|)
block|{
if|if
condition|(
operator|(
name|max_depth
operator|<
literal|0
operator|)
operator|||
operator|(
name|max_depth
operator|>
literal|1
operator|<<
literal|20
operator|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
elseif|else
if|if
condition|(
name|max_depth
operator|!=
literal|0
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
if|if
condition|(
operator|(
name|fpa_pool
operator|<
literal|0
operator|)
operator|||
operator|(
name|fpa_pool
operator|>
literal|7
operator|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
if|if
condition|(
operator|(
name|pool_size
operator|<
literal|128
operator|)
operator|||
operator|(
name|pool_size
operator|>
literal|65536
operator|)
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
comment|/* See if someone else has already initialized the queue */
if|if
condition|(
name|qstate
operator|->
name|base_ptr_div128
condition|)
block|{
if|if
condition|(
name|max_depth
operator|!=
operator|(
name|int
operator|)
name|qstate
operator|->
name|max_depth
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_initialize: Queue already initialized with different max_depth (%d).\n"
argument_list|,
operator|(
name|int
operator|)
name|qstate
operator|->
name|max_depth
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
if|if
condition|(
name|fpa_pool
operator|!=
name|qstate
operator|->
name|fpa_pool
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_initialize: Queue already initialized with different FPA pool (%u).\n"
argument_list|,
name|qstate
operator|->
name|fpa_pool
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
if|if
condition|(
operator|(
name|pool_size
operator|>>
literal|3
operator|)
operator|-
literal|1
operator|!=
name|qstate
operator|->
name|pool_size_m1
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_initialize: Queue already initialized with different FPA pool size (%u).\n"
argument_list|,
operator|(
name|qstate
operator|->
name|pool_size_m1
operator|+
literal|1
operator|)
operator|<<
literal|3
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
name|CVMX_SYNCWS
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_ALREADY_SETUP
return|;
block|}
else|else
block|{
name|cvmx_fpa_ctl_status_t
name|status
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_FPA_CTL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|s
operator|.
name|enb
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_initialize: FPA is not enabled.\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_NO_MEMORY
return|;
block|}
name|buffer
operator|=
name|cvmx_fpa_alloc
argument_list|(
name|fpa_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_initialize: Unable to allocate initial buffer.\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_NO_MEMORY
return|;
block|}
name|memset
argument_list|(
name|qstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qstate
argument_list|)
argument_list|)
expr_stmt|;
name|qstate
operator|->
name|max_depth
operator|=
name|max_depth
expr_stmt|;
name|qstate
operator|->
name|fpa_pool
operator|=
name|fpa_pool
expr_stmt|;
name|qstate
operator|->
name|pool_size_m1
operator|=
operator|(
name|pool_size
operator|>>
literal|3
operator|)
operator|-
literal|1
expr_stmt|;
name|qstate
operator|->
name|base_ptr_div128
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|buffer
argument_list|)
operator|/
literal|128
expr_stmt|;
comment|/* We zeroed the now serving field so we need to also zero the ticket */
name|__cvmx_cmd_queue_state_ptr
operator|->
name|ticket
index|[
name|__cvmx_cmd_queue_get_index
argument_list|(
name|queue_id
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_SUCCESS
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Shutdown a queue a free it's command buffers to the FPA. The  * hardware connected to the queue must be stopped before this  * function is called.  *  * @param queue_id Queue to shutdown  *  * @return CVMX_CMD_QUEUE_SUCCESS or a failure code  */
end_comment

begin_function
name|cvmx_cmd_queue_result_t
name|cvmx_cmd_queue_shutdown
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
block|{
name|__cvmx_cmd_queue_state_t
modifier|*
name|qptr
init|=
name|__cvmx_cmd_queue_get_state
argument_list|(
name|queue_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|qptr
operator|==
name|NULL
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_shutdown: Unable to get queue information.\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
if|if
condition|(
name|cvmx_cmd_queue_length
argument_list|(
name|queue_id
argument_list|)
operator|>
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_cmd_queue_shutdown: Queue still has data in it.\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_FULL
return|;
block|}
name|__cvmx_cmd_queue_lock
argument_list|(
name|queue_id
argument_list|,
name|qptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|qptr
operator|->
name|base_ptr_div128
condition|)
block|{
name|cvmx_fpa_free
argument_list|(
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
argument_list|,
name|qptr
operator|->
name|fpa_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qptr
operator|->
name|base_ptr_div128
operator|=
literal|0
expr_stmt|;
block|}
name|__cvmx_cmd_queue_unlock
argument_list|(
name|qptr
argument_list|)
expr_stmt|;
return|return
name|CVMX_CMD_QUEUE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * Return the number of command words pending in the queue. This  * function may be relatively slow for some hardware units.  *  * @param queue_id Hardware command queue to query  *  * @return Number of outstanding commands  */
end_comment

begin_function
name|int
name|cvmx_cmd_queue_length
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
block|{
if|if
condition|(
name|CVMX_ENABLE_PARAMETER_CHECKING
condition|)
block|{
if|if
condition|(
name|__cvmx_cmd_queue_get_state
argument_list|(
name|queue_id
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
comment|/* The cast is here so gcc with check that all values in the         cvmx_cmd_queue_id_t enumeration are here */
switch|switch
condition|(
call|(
name|cvmx_cmd_queue_id_t
call|)
argument_list|(
name|queue_id
operator|&
literal|0xff0000
argument_list|)
condition|)
block|{
case|case
name|CVMX_CMD_QUEUE_PKO_BASE
case|:
comment|/* FIXME: Need atomic lock on CVMX_PKO_REG_READ_IDX. Right now we                 are normally called with the queue lock, so that is a SLIGHT                 amount of protection */
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_REG_READ_IDX
argument_list|,
name|queue_id
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|cvmx_pko_mem_debug9_t
name|debug9
decl_stmt|;
name|debug9
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_MEM_DEBUG9
argument_list|)
expr_stmt|;
return|return
name|debug9
operator|.
name|cn38xx
operator|.
name|doorbell
return|;
block|}
else|else
block|{
name|cvmx_pko_mem_debug8_t
name|debug8
decl_stmt|;
name|debug8
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_MEM_DEBUG8
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
return|return
name|debug8
operator|.
name|cn68xx
operator|.
name|doorbell
return|;
else|else
return|return
name|debug8
operator|.
name|cn58xx
operator|.
name|doorbell
return|;
block|}
case|case
name|CVMX_CMD_QUEUE_ZIP
case|:
case|case
name|CVMX_CMD_QUEUE_DFA
case|:
case|case
name|CVMX_CMD_QUEUE_RAID
case|:
comment|// FIXME: Implement other lengths
return|return
literal|0
return|;
case|case
name|CVMX_CMD_QUEUE_DMA_BASE
case|:
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_npei_dmax_counts_t
name|dmax_counts
decl_stmt|;
name|dmax_counts
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DMAX_COUNTS
argument_list|(
name|queue_id
operator|&
literal|0x7
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dmax_counts
operator|.
name|s
operator|.
name|dbell
return|;
block|}
else|else
block|{
name|cvmx_dpi_dmax_counts_t
name|dmax_counts
decl_stmt|;
name|dmax_counts
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_DMAX_COUNTS
argument_list|(
name|queue_id
operator|&
literal|0x7
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dmax_counts
operator|.
name|s
operator|.
name|dbell
return|;
block|}
case|case
name|CVMX_CMD_QUEUE_END
case|:
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
return|return
name|CVMX_CMD_QUEUE_INVALID_PARAM
return|;
block|}
end_function

begin_comment
comment|/**  * Return the command buffer to be written to. The purpose of this  * function is to allow CVMX routine access to the low level buffer  * for initial hardware setup. User applications should not call this  * function directly.  *  * @param queue_id Command queue to query  *  * @return Command buffer or NULL on failure  */
end_comment

begin_function
name|void
modifier|*
name|cvmx_cmd_queue_buffer
parameter_list|(
name|cvmx_cmd_queue_id_t
name|queue_id
parameter_list|)
block|{
name|__cvmx_cmd_queue_state_t
modifier|*
name|qptr
init|=
name|__cvmx_cmd_queue_get_state
argument_list|(
name|queue_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|qptr
operator|&&
name|qptr
operator|->
name|base_ptr_div128
condition|)
return|return
name|cvmx_phys_to_ptr
argument_list|(
operator|(
name|uint64_t
operator|)
name|qptr
operator|->
name|base_ptr_div128
operator|<<
literal|7
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

end_unit

