begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-npi-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon npi.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_NPI_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_NPI_DEFS_H__
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_INPUT0
value|CVMX_NPI_BASE_ADDR_INPUTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_INPUT1
value|CVMX_NPI_BASE_ADDR_INPUTX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_INPUT2
value|CVMX_NPI_BASE_ADDR_INPUTX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_INPUT3
value|CVMX_NPI_BASE_ADDR_INPUTX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_BASE_ADDR_INPUTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_BASE_ADDR_INPUTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000070ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_INPUTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F0000000070ull) + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_OUTPUT0
value|CVMX_NPI_BASE_ADDR_OUTPUTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_OUTPUT1
value|CVMX_NPI_BASE_ADDR_OUTPUTX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_OUTPUT2
value|CVMX_NPI_BASE_ADDR_OUTPUTX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_OUTPUT3
value|CVMX_NPI_BASE_ADDR_OUTPUTX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_BASE_ADDR_OUTPUTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_BASE_ADDR_OUTPUTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000000B8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_BASE_ADDR_OUTPUTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F00000000B8ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_BIST_STATUS
value|CVMX_NPI_BIST_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_BIST_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_BIST_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000003F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_BIST_STATUS
value|(CVMX_ADD_IO_SEG(0x00011F00000003F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPI_BUFF_SIZE_OUTPUT0
value|CVMX_NPI_BUFF_SIZE_OUTPUTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BUFF_SIZE_OUTPUT1
value|CVMX_NPI_BUFF_SIZE_OUTPUTX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BUFF_SIZE_OUTPUT2
value|CVMX_NPI_BUFF_SIZE_OUTPUTX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_BUFF_SIZE_OUTPUT3
value|CVMX_NPI_BUFF_SIZE_OUTPUTX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_BUFF_SIZE_OUTPUTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_BUFF_SIZE_OUTPUTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000000E0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_BUFF_SIZE_OUTPUTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F00000000E0ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_COMP_CTL
value|CVMX_NPI_COMP_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_COMP_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_COMP_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000218ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_COMP_CTL
value|(CVMX_ADD_IO_SEG(0x00011F0000000218ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_CTL_STATUS
value|CVMX_NPI_CTL_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_CTL_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_CTL_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_CTL_STATUS
value|(CVMX_ADD_IO_SEG(0x00011F0000000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_DBG_SELECT
value|CVMX_NPI_DBG_SELECT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_DBG_SELECT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_DBG_SELECT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_DBG_SELECT
value|(CVMX_ADD_IO_SEG(0x00011F0000000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_CONTROL
value|CVMX_NPI_DMA_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_DMA_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_DMA_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000128ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_CONTROL
value|(CVMX_ADD_IO_SEG(0x00011F0000000128ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_HIGHP_COUNTS
value|CVMX_NPI_DMA_HIGHP_COUNTS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_DMA_HIGHP_COUNTS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_DMA_HIGHP_COUNTS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000148ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_HIGHP_COUNTS
value|(CVMX_ADD_IO_SEG(0x00011F0000000148ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_HIGHP_NADDR
value|CVMX_NPI_DMA_HIGHP_NADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_DMA_HIGHP_NADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_DMA_HIGHP_NADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000158ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_HIGHP_NADDR
value|(CVMX_ADD_IO_SEG(0x00011F0000000158ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_LOWP_COUNTS
value|CVMX_NPI_DMA_LOWP_COUNTS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_DMA_LOWP_COUNTS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_DMA_LOWP_COUNTS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000140ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_LOWP_COUNTS
value|(CVMX_ADD_IO_SEG(0x00011F0000000140ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_LOWP_NADDR
value|CVMX_NPI_DMA_LOWP_NADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_DMA_LOWP_NADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_DMA_LOWP_NADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000150ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_DMA_LOWP_NADDR
value|(CVMX_ADD_IO_SEG(0x00011F0000000150ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_HIGHP_DBELL
value|CVMX_NPI_HIGHP_DBELL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_HIGHP_DBELL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_HIGHP_DBELL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000120ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_HIGHP_DBELL
value|(CVMX_ADD_IO_SEG(0x00011F0000000120ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_HIGHP_IBUFF_SADDR
value|CVMX_NPI_HIGHP_IBUFF_SADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_HIGHP_IBUFF_SADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_HIGHP_IBUFF_SADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000110ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_HIGHP_IBUFF_SADDR
value|(CVMX_ADD_IO_SEG(0x00011F0000000110ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_INPUT_CONTROL
value|CVMX_NPI_INPUT_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_INPUT_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_INPUT_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000138ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_INPUT_CONTROL
value|(CVMX_ADD_IO_SEG(0x00011F0000000138ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_INT_ENB
value|CVMX_NPI_INT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_INT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_INT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_INT_ENB
value|(CVMX_ADD_IO_SEG(0x00011F0000000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_INT_SUM
value|CVMX_NPI_INT_SUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_INT_SUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_INT_SUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_INT_SUM
value|(CVMX_ADD_IO_SEG(0x00011F0000000018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_LOWP_DBELL
value|CVMX_NPI_LOWP_DBELL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_LOWP_DBELL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_LOWP_DBELL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000118ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_LOWP_DBELL
value|(CVMX_ADD_IO_SEG(0x00011F0000000118ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_LOWP_IBUFF_SADDR
value|CVMX_NPI_LOWP_IBUFF_SADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_LOWP_IBUFF_SADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_LOWP_IBUFF_SADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000108ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_LOWP_IBUFF_SADDR
value|(CVMX_ADD_IO_SEG(0x00011F0000000108ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPI_MEM_ACCESS_SUBID3
value|CVMX_NPI_MEM_ACCESS_SUBIDX(3)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_MEM_ACCESS_SUBID4
value|CVMX_NPI_MEM_ACCESS_SUBIDX(4)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_MEM_ACCESS_SUBID5
value|CVMX_NPI_MEM_ACCESS_SUBIDX(5)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_MEM_ACCESS_SUBID6
value|CVMX_NPI_MEM_ACCESS_SUBIDX(6)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_MEM_ACCESS_SUBIDX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|6
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|6
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|6
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|6
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|3
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|6
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|3
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_MEM_ACCESS_SUBIDX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F0000000028ull) + ((offset)& 7) * 8 - 8*3)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_MSI_RCV
value|CVMX_NPI_MSI_RCV_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_MSI_RCV_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_MSI_RCV not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000190ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_MSI_RCV
value|(0x0000000000000190ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_NPI_MSI_RCV
value|CVMX_NPI_NPI_MSI_RCV_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_NPI_MSI_RCV_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_NPI_MSI_RCV not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001190ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_NPI_MSI_RCV
value|(CVMX_ADD_IO_SEG(0x00011F0000001190ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPI_NUM_DESC_OUTPUT0
value|CVMX_NPI_NUM_DESC_OUTPUTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_NUM_DESC_OUTPUT1
value|CVMX_NPI_NUM_DESC_OUTPUTX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_NUM_DESC_OUTPUT2
value|CVMX_NPI_NUM_DESC_OUTPUTX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_NUM_DESC_OUTPUT3
value|CVMX_NPI_NUM_DESC_OUTPUTX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_NUM_DESC_OUTPUTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_NUM_DESC_OUTPUTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_NUM_DESC_OUTPUTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F0000000050ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_OUTPUT_CONTROL
value|CVMX_NPI_OUTPUT_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_OUTPUT_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_OUTPUT_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000100ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_OUTPUT_CONTROL
value|(CVMX_ADD_IO_SEG(0x00011F0000000100ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPI_P0_DBPAIR_ADDR
value|CVMX_NPI_PX_DBPAIR_ADDR(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P0_INSTR_ADDR
value|CVMX_NPI_PX_INSTR_ADDR(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P0_INSTR_CNTS
value|CVMX_NPI_PX_INSTR_CNTS(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P0_PAIR_CNTS
value|CVMX_NPI_PX_PAIR_CNTS(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P1_DBPAIR_ADDR
value|CVMX_NPI_PX_DBPAIR_ADDR(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P1_INSTR_ADDR
value|CVMX_NPI_PX_INSTR_ADDR(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P1_INSTR_CNTS
value|CVMX_NPI_PX_INSTR_CNTS(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P1_PAIR_CNTS
value|CVMX_NPI_PX_PAIR_CNTS(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P2_DBPAIR_ADDR
value|CVMX_NPI_PX_DBPAIR_ADDR(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P2_INSTR_ADDR
value|CVMX_NPI_PX_INSTR_ADDR(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P2_INSTR_CNTS
value|CVMX_NPI_PX_INSTR_CNTS(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P2_PAIR_CNTS
value|CVMX_NPI_PX_PAIR_CNTS(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P3_DBPAIR_ADDR
value|CVMX_NPI_PX_DBPAIR_ADDR(3)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P3_INSTR_ADDR
value|CVMX_NPI_PX_INSTR_ADDR(3)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P3_INSTR_CNTS
value|CVMX_NPI_PX_INSTR_CNTS(3)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_P3_PAIR_CNTS
value|CVMX_NPI_PX_PAIR_CNTS(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_BAR1_INDEXX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_BAR1_INDEXX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001100ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|4
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_BAR1_INDEXX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F0000001100ull) + ((offset)& 31) * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_BIST_REG
value|CVMX_NPI_PCI_BIST_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_BIST_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_BIST_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000011C0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_BIST_REG
value|(CVMX_ADD_IO_SEG(0x00011F00000011C0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_BURST_SIZE
value|CVMX_NPI_PCI_BURST_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_BURST_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_BURST_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000000D8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_BURST_SIZE
value|(CVMX_ADD_IO_SEG(0x00011F00000000D8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG00
value|CVMX_NPI_PCI_CFG00_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG00_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG00 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001800ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG00
value|(CVMX_ADD_IO_SEG(0x00011F0000001800ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG01
value|CVMX_NPI_PCI_CFG01_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG01_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG01 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001804ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG01
value|(CVMX_ADD_IO_SEG(0x00011F0000001804ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG02
value|CVMX_NPI_PCI_CFG02_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG02_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG02 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001808ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG02
value|(CVMX_ADD_IO_SEG(0x00011F0000001808ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG03
value|CVMX_NPI_PCI_CFG03_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG03_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG03 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F000000180Cull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG03
value|(CVMX_ADD_IO_SEG(0x00011F000000180Cull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG04
value|CVMX_NPI_PCI_CFG04_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG04_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG04 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001810ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG04
value|(CVMX_ADD_IO_SEG(0x00011F0000001810ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG05
value|CVMX_NPI_PCI_CFG05_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG05_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG05 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001814ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG05
value|(CVMX_ADD_IO_SEG(0x00011F0000001814ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG06
value|CVMX_NPI_PCI_CFG06_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG06_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG06 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001818ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG06
value|(CVMX_ADD_IO_SEG(0x00011F0000001818ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG07
value|CVMX_NPI_PCI_CFG07_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG07_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG07 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F000000181Cull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG07
value|(CVMX_ADD_IO_SEG(0x00011F000000181Cull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG08
value|CVMX_NPI_PCI_CFG08_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG08_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG08 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001820ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG08
value|(CVMX_ADD_IO_SEG(0x00011F0000001820ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG09
value|CVMX_NPI_PCI_CFG09_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG09_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG09 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001824ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG09
value|(CVMX_ADD_IO_SEG(0x00011F0000001824ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG10
value|CVMX_NPI_PCI_CFG10_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG10_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG10 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001828ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG10
value|(CVMX_ADD_IO_SEG(0x00011F0000001828ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG11
value|CVMX_NPI_PCI_CFG11_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG11_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG11 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F000000182Cull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG11
value|(CVMX_ADD_IO_SEG(0x00011F000000182Cull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG12
value|CVMX_NPI_PCI_CFG12_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG12_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG12 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001830ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG12
value|(CVMX_ADD_IO_SEG(0x00011F0000001830ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG13
value|CVMX_NPI_PCI_CFG13_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG13_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG13 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001834ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG13
value|(CVMX_ADD_IO_SEG(0x00011F0000001834ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG15
value|CVMX_NPI_PCI_CFG15_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG15_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG15 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F000000183Cull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG15
value|(CVMX_ADD_IO_SEG(0x00011F000000183Cull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG16
value|CVMX_NPI_PCI_CFG16_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG16_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG16 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001840ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG16
value|(CVMX_ADD_IO_SEG(0x00011F0000001840ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG17
value|CVMX_NPI_PCI_CFG17_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG17_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG17 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001844ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG17
value|(CVMX_ADD_IO_SEG(0x00011F0000001844ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG18
value|CVMX_NPI_PCI_CFG18_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG18_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG18 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001848ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG18
value|(CVMX_ADD_IO_SEG(0x00011F0000001848ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG19
value|CVMX_NPI_PCI_CFG19_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG19_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG19 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F000000184Cull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG19
value|(CVMX_ADD_IO_SEG(0x00011F000000184Cull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG20
value|CVMX_NPI_PCI_CFG20_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG20_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG20 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001850ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG20
value|(CVMX_ADD_IO_SEG(0x00011F0000001850ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG21
value|CVMX_NPI_PCI_CFG21_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG21_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG21 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001854ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG21
value|(CVMX_ADD_IO_SEG(0x00011F0000001854ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG22
value|CVMX_NPI_PCI_CFG22_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG22_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG22 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001858ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG22
value|(CVMX_ADD_IO_SEG(0x00011F0000001858ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG56
value|CVMX_NPI_PCI_CFG56_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG56_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG56 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG56
value|(CVMX_ADD_IO_SEG(0x00011F00000018E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG57
value|CVMX_NPI_PCI_CFG57_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG57_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG57 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018E4ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG57
value|(CVMX_ADD_IO_SEG(0x00011F00000018E4ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG58
value|CVMX_NPI_PCI_CFG58_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG58_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG58 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG58
value|(CVMX_ADD_IO_SEG(0x00011F00000018E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG59
value|CVMX_NPI_PCI_CFG59_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG59_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG59 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018ECull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG59
value|(CVMX_ADD_IO_SEG(0x00011F00000018ECull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG60
value|CVMX_NPI_PCI_CFG60_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG60_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG60 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG60
value|(CVMX_ADD_IO_SEG(0x00011F00000018F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG61
value|CVMX_NPI_PCI_CFG61_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG61_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG61 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018F4ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG61
value|(CVMX_ADD_IO_SEG(0x00011F00000018F4ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG62
value|CVMX_NPI_PCI_CFG62_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG62_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG62 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG62
value|(CVMX_ADD_IO_SEG(0x00011F00000018F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG63
value|CVMX_NPI_PCI_CFG63_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CFG63_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CFG63 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000018FCull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CFG63
value|(CVMX_ADD_IO_SEG(0x00011F00000018FCull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CNT_REG
value|CVMX_NPI_PCI_CNT_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CNT_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CNT_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000011B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CNT_REG
value|(CVMX_ADD_IO_SEG(0x00011F00000011B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CTL_STATUS_2
value|CVMX_NPI_PCI_CTL_STATUS_2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_CTL_STATUS_2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_CTL_STATUS_2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F000000118Cull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_CTL_STATUS_2
value|(CVMX_ADD_IO_SEG(0x00011F000000118Cull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_INT_ARB_CFG
value|CVMX_NPI_PCI_INT_ARB_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_INT_ARB_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_INT_ARB_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000130ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_INT_ARB_CFG
value|(CVMX_ADD_IO_SEG(0x00011F0000000130ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_INT_ENB2
value|CVMX_NPI_PCI_INT_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_INT_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_INT_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000011A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_INT_ENB2
value|(CVMX_ADD_IO_SEG(0x00011F00000011A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_INT_SUM2
value|CVMX_NPI_PCI_INT_SUM2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_INT_SUM2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_INT_SUM2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001198ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_INT_SUM2
value|(CVMX_ADD_IO_SEG(0x00011F0000001198ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD
value|CVMX_NPI_PCI_READ_CMD_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_READ_CMD_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_READ_CMD not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000048ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD
value|(CVMX_ADD_IO_SEG(0x00011F0000000048ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD_6
value|CVMX_NPI_PCI_READ_CMD_6_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_READ_CMD_6_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_READ_CMD_6 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001180ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD_6
value|(CVMX_ADD_IO_SEG(0x00011F0000001180ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD_C
value|CVMX_NPI_PCI_READ_CMD_C_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_READ_CMD_C_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_READ_CMD_C not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001184ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD_C
value|(CVMX_ADD_IO_SEG(0x00011F0000001184ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD_E
value|CVMX_NPI_PCI_READ_CMD_E_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_READ_CMD_E_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_READ_CMD_E not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000001188ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_READ_CMD_E
value|(CVMX_ADD_IO_SEG(0x00011F0000001188ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_SCM_REG
value|CVMX_NPI_PCI_SCM_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_SCM_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_SCM_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000011A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_SCM_REG
value|(CVMX_ADD_IO_SEG(0x00011F00000011A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_TSR_REG
value|CVMX_NPI_PCI_TSR_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PCI_TSR_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PCI_TSR_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000011B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PCI_TSR_REG
value|(CVMX_ADD_IO_SEG(0x00011F00000011B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PORT32_INSTR_HDR
value|CVMX_NPI_PORT32_INSTR_HDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PORT32_INSTR_HDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PORT32_INSTR_HDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000001F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PORT32_INSTR_HDR
value|(CVMX_ADD_IO_SEG(0x00011F00000001F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PORT33_INSTR_HDR
value|CVMX_NPI_PORT33_INSTR_HDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PORT33_INSTR_HDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PORT33_INSTR_HDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000200ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PORT33_INSTR_HDR
value|(CVMX_ADD_IO_SEG(0x00011F0000000200ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PORT34_INSTR_HDR
value|CVMX_NPI_PORT34_INSTR_HDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PORT34_INSTR_HDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PORT34_INSTR_HDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000208ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PORT34_INSTR_HDR
value|(CVMX_ADD_IO_SEG(0x00011F0000000208ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PORT35_INSTR_HDR
value|CVMX_NPI_PORT35_INSTR_HDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PORT35_INSTR_HDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PORT35_INSTR_HDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000210ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PORT35_INSTR_HDR
value|(CVMX_ADD_IO_SEG(0x00011F0000000210ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_PORT_BP_CONTROL
value|CVMX_NPI_PORT_BP_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PORT_BP_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PORT_BP_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000001F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PORT_BP_CONTROL
value|(CVMX_ADD_IO_SEG(0x00011F00000001F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PX_DBPAIR_ADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PX_DBPAIR_ADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000180ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PX_DBPAIR_ADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F0000000180ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PX_INSTR_ADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PX_INSTR_ADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000001C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PX_INSTR_ADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F00000001C0ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PX_INSTR_CNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PX_INSTR_CNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000001A0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PX_INSTR_CNTS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F00000001A0ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_PX_PAIR_CNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_PX_PAIR_CNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000160ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_PX_PAIR_CNTS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F0000000160ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_RSL_INT_BLOCKS
value|CVMX_NPI_RSL_INT_BLOCKS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_RSL_INT_BLOCKS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_RSL_INT_BLOCKS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_RSL_INT_BLOCKS
value|(CVMX_ADD_IO_SEG(0x00011F0000000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_NPI_SIZE_INPUT0
value|CVMX_NPI_SIZE_INPUTX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_SIZE_INPUT1
value|CVMX_NPI_SIZE_INPUTX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_SIZE_INPUT2
value|CVMX_NPI_SIZE_INPUTX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_NPI_SIZE_INPUT3
value|CVMX_NPI_SIZE_INPUTX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_SIZE_INPUTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_SIZE_INPUTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F0000000078ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_SIZE_INPUTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011F0000000078ull) + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_NPI_WIN_READ_TO
value|CVMX_NPI_WIN_READ_TO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_NPI_WIN_READ_TO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_NPI_WIN_READ_TO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011F00000001E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_NPI_WIN_READ_TO
value|(CVMX_ADD_IO_SEG(0x00011F00000001E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_npi_base_addr_input#  *  * NPI_BASE_ADDR_INPUT0 = NPI's Base Address Input 0 Register  *  * The address to start reading Instructions from for Input-0.  */
end_comment

begin_union
union|union
name|cvmx_npi_base_addr_inputx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_base_addr_inputx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|baddr
range|:
literal|61
decl_stmt|;
comment|/**< The address to read Instruction from for output 0.                                                          This address is 8-byte aligned, for this reason                                                          address bits [2:0] will always be zero. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|baddr
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_base_addr_inputx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_inputx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_inputx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_inputx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_inputx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_inputx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_inputx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_base_addr_inputx
name|cvmx_npi_base_addr_inputx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_base_addr_output#  *  * NPI_BASE_ADDR_OUTPUT0 = NPI's Base Address Output 0 Register  *  * The address to start reading Instructions from for Output-0.  */
end_comment

begin_union
union|union
name|cvmx_npi_base_addr_outputx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_base_addr_outputx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|baddr
range|:
literal|61
decl_stmt|;
comment|/**< The address to read Instruction from for output 0.                                                          This address is 8-byte aligned, for this reason                                                          address bits [2:0] will always be zero. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|baddr
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_base_addr_outputx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_outputx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_outputx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_outputx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_outputx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_outputx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_base_addr_outputx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_base_addr_outputx
name|cvmx_npi_base_addr_outputx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_bist_status  *  * NPI_BIST_STATUS = NPI's BIST Status Register  *  * Results from BIST runs of NPI's memories.  */
end_comment

begin_union
union|union
name|cvmx_npi_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_bist_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|csr_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the csr_fifo */
name|uint64_t
name|dif_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dif_fifo */
name|uint64_t
name|rdp_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdp_fifo */
name|uint64_t
name|pcnc_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pcn_cnt_fifo */
name|uint64_t
name|pcn_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pcn_fifo */
name|uint64_t
name|rdn_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdn_fifo */
name|uint64_t
name|pcac_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pca_cmd_fifo */
name|uint64_t
name|pcad_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pca_data_fifo */
name|uint64_t
name|rdnl_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdn_length_fifo */
name|uint64_t
name|pgf_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pgf_fifo */
name|uint64_t
name|pig_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pig_fifo */
name|uint64_t
name|pof0_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pof0_fifo */
name|uint64_t
name|pof1_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pof1_fifo */
name|uint64_t
name|pof2_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pof2_fifo */
name|uint64_t
name|pof3_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pof3_fifo */
name|uint64_t
name|pos_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pos_fifo */
name|uint64_t
name|nus_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the nus_fifo */
name|uint64_t
name|dob_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dob_fifo */
name|uint64_t
name|pdf_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pdf_fifo */
name|uint64_t
name|dpi_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dpi_fifo */
else|#
directive|else
name|uint64_t
name|dpi_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dob_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nus_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pos_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pof3_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pof2_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pof1_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pof0_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pig_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgf_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdnl_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcad_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcac_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdn_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcn_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnc_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdp_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_bist_status_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|csr_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the csr_fifo */
name|uint64_t
name|dif_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dif_fifo */
name|uint64_t
name|rdp_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdp_fifo */
name|uint64_t
name|pcnc_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pcn_cnt_fifo */
name|uint64_t
name|pcn_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pcn_fifo */
name|uint64_t
name|rdn_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdn_fifo */
name|uint64_t
name|pcac_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pca_cmd_fifo */
name|uint64_t
name|pcad_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pca_data_fifo */
name|uint64_t
name|rdnl_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdn_length_fifo */
name|uint64_t
name|pgf_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pgf_fifo */
name|uint64_t
name|pig_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pig_fifo */
name|uint64_t
name|pof0_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pof0_fifo */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pos_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pos_fifo */
name|uint64_t
name|nus_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the nus_fifo */
name|uint64_t
name|dob_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dob_fifo */
name|uint64_t
name|pdf_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pdf_fifo */
name|uint64_t
name|dpi_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dpi_fifo */
else|#
directive|else
name|uint64_t
name|dpi_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dob_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nus_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pos_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pof0_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pig_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgf_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdnl_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcad_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcac_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdn_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcn_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnc_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdp_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_npi_bist_status_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_bist_status_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_bist_status_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_npi_bist_status_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|csr_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the csr_fifo */
name|uint64_t
name|dif_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dif_fifo */
name|uint64_t
name|rdp_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdp_fifo */
name|uint64_t
name|pcnc_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pcn_cnt_fifo */
name|uint64_t
name|pcn_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pcn_fifo */
name|uint64_t
name|rdn_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdn_fifo */
name|uint64_t
name|pcac_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pca_cmd_fifo */
name|uint64_t
name|pcad_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pca_data_fifo */
name|uint64_t
name|rdnl_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rdn_length_fifo */
name|uint64_t
name|pgf_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pgf_fifo */
name|uint64_t
name|pig_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pig_fifo */
name|uint64_t
name|pof0_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pof0_fifo */
name|uint64_t
name|pof1_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pof1_fifo */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pos_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pos_fifo */
name|uint64_t
name|nus_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the nus_fifo */
name|uint64_t
name|dob_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dob_fifo */
name|uint64_t
name|pdf_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pdf_fifo */
name|uint64_t
name|dpi_bs
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dpi_fifo */
else|#
directive|else
name|uint64_t
name|dpi_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dob_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nus_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pos_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pof1_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pof0_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pig_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgf_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdnl_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcad_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcac_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdn_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcn_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnc_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdp_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dif_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr_bs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_npi_bist_status_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_bist_status_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_bist_status
name|cvmx_npi_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_buff_size_output#  *  * NPI_BUFF_SIZE_OUTPUT0 = NPI's D/I Buffer Sizes For Output 0  *  * The size in bytes of the Data Bufffer and Information Buffer for output 0.  */
end_comment

begin_union
union|union
name|cvmx_npi_buff_size_outputx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_buff_size_outputx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|7
decl_stmt|;
comment|/**< The number of bytes to move to the Info-Pointer                                                          from the front of the packet.                                                          Legal values are 0-120. */
name|uint64_t
name|bsize
range|:
literal|16
decl_stmt|;
comment|/**< The size in bytes of the area pointed to by                                                          buffer pointer for output packet data. */
else|#
directive|else
name|uint64_t
name|bsize
range|:
literal|16
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_buff_size_outputx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_buff_size_outputx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_buff_size_outputx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_buff_size_outputx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_buff_size_outputx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_buff_size_outputx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_buff_size_outputx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_buff_size_outputx
name|cvmx_npi_buff_size_outputx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_comp_ctl  *  * NPI_COMP_CTL = PCI Compensation Control  *  * PCI Compensation Control  */
end_comment

begin_union
union|union
name|cvmx_npi_comp_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_comp_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< Bypass value for PCTL */
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< Bypass value for NCTL */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_comp_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_comp_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_comp_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_comp_ctl
name|cvmx_npi_comp_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_ctl_status  *  * NPI_CTL_STATUS = NPI's Control Status Register  *  * Contains control ans status for NPI.  * Writes to this register are not ordered with writes/reads to the PCI Memory space.  * To ensure that a write has completed the user must read the register before  * making an access(i.e. PCI memory space) that requires the value of this register to be updated.  */
end_comment

begin_union
union|union
name|cvmx_npi_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_ctl_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The revision of the N3. */
name|uint64_t
name|dis_pniw
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' access from the PNI Window                                                          Registers are disabled. */
name|uint64_t
name|out3_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the output3 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|out2_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the output2 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|out1_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the output1 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|out0_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the output0 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|ins3_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the gather3 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|ins2_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the gather2 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|ins1_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the gather1 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|ins0_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the gather0 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|ins3_64b
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the instructions read by the                                                          gather3 engine are 64-Byte instructions, when                                                          de-asserted '0' instructions are 32-byte. */
name|uint64_t
name|ins2_64b
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the instructions read by the                                                          gather2 engine are 64-Byte instructions, when                                                          de-asserted '0' instructions are 32-byte. */
name|uint64_t
name|ins1_64b
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the instructions read by the                                                          gather1 engine are 64-Byte instructions, when                                                          de-asserted '0' instructions are 32-byte. */
name|uint64_t
name|ins0_64b
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the instructions read by the                                                          gather0 engine are 64-Byte instructions, when                                                          de-asserted '0' instructions are 32-byte. */
name|uint64_t
name|pci_wdis
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access to registers in                                                          PNI address range 0x1000 - 0x17FF from the PCI. */
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the NPI to wait for a commit                                                          from the L2C before sending additional access to                                                          the L2C from the PCI. */
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|5
decl_stmt|;
comment|/**< The maximum number of words to merge into a single                                                          write operation from the PPs to the PCI. Legal                                                          values are 1 to 32, where a '0' is treated as 32. */
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
comment|/**< When the NPI starts a PP to PCI write it will wait                                                          no longer than the value of TIMER in eclks to                                                          merge additional writes from the PPs into 1                                                          large write. The values for this field is 1 to                                                          1024 where a value of '0' is treated as 1024. */
else|#
directive|else
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_wdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins0_64b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins1_64b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins2_64b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins3_64b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins1_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins3_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out1_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out2_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out3_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dis_pniw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_ctl_status_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The revision of the N3. */
name|uint64_t
name|dis_pniw
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' access from the PNI Window                                                          Registers are disabled. */
name|uint64_t
name|reserved_51_53
range|:
literal|3
decl_stmt|;
name|uint64_t
name|out0_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the output0 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|reserved_47_49
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ins0_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the gather0 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|reserved_43_45
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ins0_64b
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the instructions read by the                                                          gather0 engine are 64-Byte instructions, when                                                          de-asserted '0' instructions are 32-byte. */
name|uint64_t
name|pci_wdis
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access to registers in                                                          PNI address range 0x1000 - 0x17FF from the PCI. */
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the NPI to wait for a commit                                                          from the L2C before sending additional access to                                                          the L2C from the PCI. */
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|5
decl_stmt|;
comment|/**< The maximum number of words to merge into a single                                                          write operation from the PPs to the PCI. Legal                                                          values are 1 to 32, where a '0' is treated as 32. */
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
comment|/**< When the NPI starts a PP to PCI write it will wait                                                          no longer than the value of TIMER in eclks to                                                          merge additional writes from the PPs into 1                                                          large write. The values for this field is 1 to                                                          1024 where a value of '0' is treated as 1024. */
else|#
directive|else
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_wdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins0_64b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_43_45
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ins0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_49
range|:
literal|3
decl_stmt|;
name|uint64_t
name|out0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_51_53
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dis_pniw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_npi_ctl_status_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The revision of the N3.                                                          0 => pass1.x, 1 => 2.0 */
name|uint64_t
name|dis_pniw
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' access from the PNI Window                                                          Registers are disabled. */
name|uint64_t
name|reserved_52_53
range|:
literal|2
decl_stmt|;
name|uint64_t
name|out1_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the output1 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|out0_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the output0 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|reserved_48_49
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ins1_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the gather1 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|ins0_enb
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the gather0 engine is enabled.                                                          After enabling the values of the associated                                                          Address and Size Register should not be changed. */
name|uint64_t
name|reserved_44_45
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ins1_64b
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the instructions read by the                                                          gather1 engine are 64-Byte instructions, when                                                          de-asserted '0' instructions are 32-byte. */
name|uint64_t
name|ins0_64b
range|:
literal|1
decl_stmt|;
comment|/**< When asserted '1' the instructions read by the                                                          gather0 engine are 64-Byte instructions, when                                                          de-asserted '0' instructions are 32-byte. */
name|uint64_t
name|pci_wdis
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access to registers in                                                          PNI address range 0x1000 - 0x17FF from the PCI. */
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the NPI to wait for a commit                                                          from the L2C before sending additional access to                                                          the L2C from the PCI. */
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|5
decl_stmt|;
comment|/**< The maximum number of words to merge into a single                                                          write operation from the PPs to the PCI. Legal                                                          values are 1 to 32, where a '0' is treated as 32. */
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
comment|/**< When the NPI starts a PP to PCI write it will wait                                                          no longer than the value of TIMER in eclks to                                                          merge additional writes from the PPs into 1                                                          large write. The values for this field is 1 to                                                          1024 where a value of '0' is treated as 1024. */
else|#
directive|else
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_31
range|:
literal|22
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_wdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins0_64b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins1_64b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_45
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ins0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ins1_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_49
range|:
literal|2
decl_stmt|;
name|uint64_t
name|out0_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out1_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_52_53
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dis_pniw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_npi_ctl_status_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_ctl_status_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_ctl_status_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_ctl_status_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_ctl_status_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_ctl_status
name|cvmx_npi_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_dbg_select  *  * NPI_DBG_SELECT = Debug Select Register  *  * Contains the debug select value in last written to the RSLs.  */
end_comment

begin_union
union|union
name|cvmx_npi_dbg_select
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_dbg_select_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dbg_sel
range|:
literal|16
decl_stmt|;
comment|/**< When this register is written its value is sent to                                                          all RSLs. */
else|#
directive|else
name|uint64_t
name|dbg_sel
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_dbg_select_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_dbg_select_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_dbg_select_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_dbg_select_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_dbg_select_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_dbg_select_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_dbg_select_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_dbg_select
name|cvmx_npi_dbg_select_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_dma_control  *  * NPI_DMA_CONTROL = DMA Control Register  *  * Controls operation of the DMA IN/OUT of the NPI.  */
end_comment

begin_union
union|union
name|cvmx_npi_dma_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_dma_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' and the NPI is in the mode to write                                                          0 to L2C memory when a DMA is done, the address                                                          to be written to will be treated as a Little                                                          Endian address. This field is new to PASS-2. */
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the NPI will send a value in the DWB                                                          field for a free page operation for the memory                                                          that contained the data in N3. */
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
comment|/**< When Instruction Chunks for DMA operations are freed                                                          this value is used for the DWB field of the                                                          operation. */
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
comment|/**< The FPA queue that the instruction-chunk page will                                                          be returned to when used. */
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' 1 will be added to the DMA counters,                                                          if '0' then the number of bytes in the dma transfer                                                          will be added to the count register. */
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Mode for DMA. */
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
comment|/**< Nosnoop For DMA. */
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode for DMA. */
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
comment|/**< Select PCI_POINTER MODE to be used.                                                          '1' use pointer values for address and register                                                          values for RO, ES, and NS, '0' use register                                                          values for address and pointer values for                                                          RO, ES, and NS. */
name|uint64_t
name|hp_enb
range|:
literal|1
decl_stmt|;
comment|/**< Enables the High Priority DMA.                                                          While this bit is disabled '0' then the value                                                          in the NPI_HIGHP_IBUFF_SADDR is re-loaded to the                                                          starting address of the High Priority DMA engine.                                                          CSIZE field will be reloaded, for the High Priority                                                          DMA Engine. */
name|uint64_t
name|lp_enb
range|:
literal|1
decl_stmt|;
comment|/**< Enables the Low Priority DMA.                                                          While this bit is disabled '0' then the value                                                          in the NPI_LOWP_IBUFF_SADDR is re-loaded to the                                                          starting address of the Low Priority DMA engine.                                                          PASS-2: When this bit is '0' the value in the                                                          CSIZE field will be reloaded, for the Low Priority                                                          DMA Engine. */
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
comment|/**< The size in words of the DMA Instruction Chunk.                                                          This value should only be written once. After                                                          writing this value a new value will not be                                                          recognized until the end of the DMA I-Chunk is                                                          reached. */
else|#
directive|else
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
name|uint64_t
name|lp_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hp_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_dma_control_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_control_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_control_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_control_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_dma_control_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_control_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_control_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_dma_control
name|cvmx_npi_dma_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_dma_highp_counts  *  * NPI_DMA_HIGHP_COUNTS = NPI's High Priority DMA Counts  *  * Values for determing the number of instructions for High Priority DMA in the NPI.  */
end_comment

begin_union
union|union
name|cvmx_npi_dma_highp_counts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_dma_highp_counts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
comment|/**< Number of words in the Instruction FIFO. */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Number of available words of Instructions to read. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_dma_highp_counts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_counts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_counts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_counts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_counts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_counts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_counts_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_dma_highp_counts
name|cvmx_npi_dma_highp_counts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_dma_highp_naddr  *  * NPI_DMA_HIGHP_NADDR = NPI's High Priority DMA Next Ichunk Address  *  * Place NPI will read the next Ichunk data from. This is valid when state is 0  */
end_comment

begin_union
union|union
name|cvmx_npi_dma_highp_naddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_dma_highp_naddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|state
range|:
literal|4
decl_stmt|;
comment|/**< The DMA instruction engine state vector.                                                          Typical value is 0 (IDLE). */
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< The next L2C address to read DMA instructions                                                          from for the High Priority DMA engine. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|state
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_dma_highp_naddr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_naddr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_naddr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_naddr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_naddr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_naddr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_highp_naddr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_dma_highp_naddr
name|cvmx_npi_dma_highp_naddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_dma_lowp_counts  *  * NPI_DMA_LOWP_COUNTS = NPI's Low Priority DMA Counts  *  * Values for determing the number of instructions for Low Priority DMA in the NPI.  */
end_comment

begin_union
union|union
name|cvmx_npi_dma_lowp_counts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_dma_lowp_counts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
comment|/**< Number of words in the Instruction FIFO. */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Number of available words of Instructions to read. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_dma_lowp_counts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_counts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_counts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_counts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_counts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_counts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_counts_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_dma_lowp_counts
name|cvmx_npi_dma_lowp_counts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_dma_lowp_naddr  *  * NPI_DMA_LOWP_NADDR = NPI's Low Priority DMA Next Ichunk Address  *  * Place NPI will read the next Ichunk data from. This is valid when state is 0  */
end_comment

begin_union
union|union
name|cvmx_npi_dma_lowp_naddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_dma_lowp_naddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|state
range|:
literal|4
decl_stmt|;
comment|/**< The DMA instruction engine state vector.                                                          Typical value is 0 (IDLE). */
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< The next L2C address to read DMA instructions                                                          from for the Low Priority DMA engine. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|state
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_dma_lowp_naddr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_naddr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_naddr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_naddr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_naddr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_naddr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_dma_lowp_naddr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_dma_lowp_naddr
name|cvmx_npi_dma_lowp_naddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_highp_dbell  *  * NPI_HIGHP_DBELL = High Priority Door Bell  *  * The door bell register for the high priority DMA queue.  */
end_comment

begin_union
union|union
name|cvmx_npi_highp_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_highp_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dbell
range|:
literal|16
decl_stmt|;
comment|/**< The value written to this register is added to the                                                          number of 8byte words to be read and processes for                                                          the high priority dma queue. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_highp_dbell_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_dbell_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_dbell_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_dbell_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_highp_dbell_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_dbell_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_dbell_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_highp_dbell
name|cvmx_npi_highp_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_highp_ibuff_saddr  *  * NPI_HIGHP_IBUFF_SADDR = DMA High Priority Instruction Buffer Starting Address  *  * The address to start reading Instructions from for HIGHP.  */
end_comment

begin_union
union|union
name|cvmx_npi_highp_ibuff_saddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_highp_ibuff_saddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|36
decl_stmt|;
comment|/**< The starting address to read the first instruction. */
else|#
directive|else
name|uint64_t
name|saddr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_highp_ibuff_saddr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_ibuff_saddr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_ibuff_saddr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_ibuff_saddr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_highp_ibuff_saddr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_ibuff_saddr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_highp_ibuff_saddr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_highp_ibuff_saddr
name|cvmx_npi_highp_ibuff_saddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_input_control  *  * NPI_INPUT_CONTROL = NPI's Input Control Register  *  * Control for reads for gather list and instructions.  */
end_comment

begin_union
union|union
name|cvmx_npi_input_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_input_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the input packet selection will be                                                          made with a Round Robin arbitration. When '0'                                                          the input packet port is fixed in priority,                                                          where the lower port number has higher priority.                                                          PASS3 Field */
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
comment|/**< Field when in [PBP] is set to be used in                                                          calculating a DPTR. */
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for reading of                                                          gather data. */
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for reading of                                                          gather data. */
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for reading of                                                          gather data. */
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the csr value will be used for                                                          ROR, ESR, and NSR. When clear '0' the value in                                                          DPTR will be used. In turn the bits not used for                                                          ROR, ESR, and NSR, will be used for bits [63:60]                                                          of the address used to fetch packet data. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for reading of                                                          gather list and gather instruction. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for reading of                                                          gather list and gather instruction. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for reading of                                                          gather list and gather instruction. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_input_control_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
comment|/**< Field when in [PBP] is set to be used in                                                          calculating a DPTR. */
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for reading of                                                          gather data. */
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for reading of                                                          gather data. */
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for reading of                                                          gather data. */
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the csr value will be used for                                                          ROR, ESR, and NSR. When clear '0' the value in                                                          DPTR will be used. In turn the bits not used for                                                          ROR, ESR, and NSR, will be used for bits [63:60]                                                          of the address used to fetch packet data. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for reading of                                                          gather list and gather instruction. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for reading of                                                          gather list and gather instruction. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for reading of                                                          gather list and gather instruction. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_npi_input_control_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_input_control_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_input_control_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_input_control_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_input_control_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_input_control_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_input_control
name|cvmx_npi_input_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_int_enb  *  * NPI_INTERRUPT_ENB = NPI's Interrupt Enable Register  *  * Used to enable the various interrupting conditions of NPI  */
end_comment

begin_union
union|union
name|cvmx_npi_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_int_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q1_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q1_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PDF_P_F] to generate an                                                          interrupt. */
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PDF_P_E] to generate an                                                          interrupt. */
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCF_P_F] to generate an                                                          interrupt. */
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCF_P_E] to generate an                                                          interrupt. */
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RDX_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RWX_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PNC_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PNC_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[COM_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[COM_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q3_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q3_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q2_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q2_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCR_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCR_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[FCR_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[FCR_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[IOBDMA] to generate an                                                          interrupt. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P_DPERR] to generate an                                                          interrupt. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[WIN_RTO] to generate an                                                          interrupt. */
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I3_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I2_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G3_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G2_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I3_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I2_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I3_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I2_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO3_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO2_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO1_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO0_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCI_RSL] to generate an                                                          interrupt. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_WTO] to generate an                                                          interrupt. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_RTO] to generate an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_int_enb_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q1_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q1_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PDF_P_F] to generate an                                                          interrupt. */
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PDF_P_E] to generate an                                                          interrupt. */
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCF_P_F] to generate an                                                          interrupt. */
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCF_P_E] to generate an                                                          interrupt. */
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RDX_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RWX_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PNC_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PNC_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[COM_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[COM_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q3_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q3_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q2_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q2_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCR_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCR_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[FCR_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[FCR_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[IOBDMA] to generate an                                                          interrupt. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P_DPERR] to generate an                                                          interrupt. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[WIN_RTO] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_36_38
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_32_34
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_28_30
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_24_26
range|:
literal|3
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_20_22
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_12_14
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_8_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO0_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCI_RSL] to generate an                                                          interrupt. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_WTO] to generate an                                                          interrupt. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_RTO] to generate an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_14
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_22
range|:
literal|3
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_26
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_30
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_34
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_38
range|:
literal|3
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_npi_int_enb_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q1_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q1_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PDF_P_F] to generate an                                                          interrupt. */
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PDF_P_E] to generate an                                                          interrupt. */
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCF_P_F] to generate an                                                          interrupt. */
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCF_P_E] to generate an                                                          interrupt. */
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RDX_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RWX_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PNC_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PNC_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[COM_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[COM_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q3_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q3_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q2_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[Q2_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCR_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCR_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[FCR_A_F] to generate an                                                          interrupt. */
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[FCR_S_E] to generate an                                                          interrupt. */
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[IOBDMA] to generate an                                                          interrupt. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P_DPERR] to generate an                                                          interrupt. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[WIN_RTO] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_37_38
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_33_34
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_21_22
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_17_18
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO1_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO0_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCI_RSL] to generate an                                                          interrupt. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_WTO] to generate an                                                          interrupt. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_RTO] to generate an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_18
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_22
range|:
literal|2
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_34
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_38
range|:
literal|2
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_npi_int_enb_s
name|cn38xx
decl_stmt|;
struct|struct
name|cvmx_npi_int_enb_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[IOBDMA] to generate an                                                          interrupt. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P_DPERR] to generate an                                                          interrupt. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[WIN_RTO] to generate an                                                          interrupt. */
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I3_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I2_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PPERR] to generate an                                                          interrupt. */
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G3_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G2_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[G0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_PERR] to generate an                                                          interrupt. */
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P3_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P2_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[P0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I3_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I2_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_OVERF] to generate an                                                          interrupt. */
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I3_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I2_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I1_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[I0_RTOUT] to generate an                                                          interrupt. */
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO3_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO2_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO1_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PO0_2SML] to generate an                                                          interrupt. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[PCI_RSL] to generate an                                                          interrupt. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_WTO] to generate an                                                          interrupt. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Enables NPI_INT_SUM[RML_RTO] to generate an                                                          interrupt. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_npi_int_enb_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_int_enb_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_int_enb_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_int_enb
name|cvmx_npi_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_int_sum  *  * NPI_INTERRUPT_SUM = NPI Interrupt Summary Register  *  * Set when an interrupt condition occurs, write '1' to clear.  */
end_comment

begin_union
union|union
name|cvmx_npi_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_int_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-1 FIFO is full.                                                          PASS3 Field. */
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-1 FIFO is empty.                                                          PASS3 Field. */
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to push a full PCN-DATA-FIFO.                                                          PASS3 Field. */
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to pop an empty PCN-DATA-FIFO.                                                          PASS3 Field. */
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to push a full PCN-CNT-FIFO.                                                          PASS3 Field. */
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to pop an empty PCN-CNT-FIFO.                                                          PASS3 Field. */
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when DPI-XFR-Wait count is 0.                                                          PASS3 Field. */
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when RDN-XFR-Wait count is 0.                                                          PASS3 Field. */
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when PNI-NPI Credits are max.                                                          PASS3 Field. */
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when PNI-NPI Credits are 0.                                                          PASS3 Field. */
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when PCN-Commit Counter is max.                                                          PASS3 Field. */
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when PCN-Commit Counter is 0.                                                          PASS3 Field. */
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-3 FIFO is full.                                                          PASS3 Field. */
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-3 FIFO is empty.                                                          PASS3 Field. */
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-2 FIFO is full.                                                          PASS3 Field. */
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-2 FIFO is empty.                                                          PASS3 Field. */
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when POW Credits is full.                                                          PASS3 Field. */
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when POW Credits is empty.                                                          PASS3 Field. */
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when FPA Credits is full.                                                          PASS3 Field. */
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when FPA Credits is empty.                                                          PASS3 Field. */
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Requested IOBDMA read size exceeded 128 words. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on data written to L2C                                                          from the PCI this bit may be set. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Windowed Load Timed Out. */
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port3 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT3[ISIZE] field. */
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port2 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT2[ISIZE] field. */
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port1 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT1[ISIZE] field. */
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port0 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT0[ISIZE] field. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< This '1' when a bit in PCI_INT_SUM2 is SET and the                                                          corresponding bit in the PCI_INT_ENB2 is SET. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive a commit                                                          back from a RSL after sending a write command to                                                          a RSL. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive read data                                                          back from a RSL after sending a read command to                                                          a RSL. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_int_sum_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-1 FIFO is full. */
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-1 FIFO is empty. */
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to push a full PCN-DATA-FIFO. */
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to pop an empty PCN-DATA-FIFO. */
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to push a full PCN-CNT-FIFO. */
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to pop an empty PCN-CNT-FIFO. */
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when DPI-XFR-Wait count is 0. */
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when RDN-XFR-Wait count is 0. */
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when PNI-NPI Credits are max. */
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when PNI-NPI Credits are 0. */
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when PCN-Commit Counter is max. */
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when PCN-Commit Counter is 0. */
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-3 FIFO is full. */
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-3 FIFO is empty. */
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-2 FIFO is full. */
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-2 FIFO is empty. */
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when POW Credits is full. */
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when POW Credits is empty. */
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when FPA Credits is full. */
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when FPA Credits is empty. */
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Requested IOBDMA read size exceeded 128 words. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on data written to L2C                                                          from the PCI this bit may be set. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Windowed Load Timed Out. */
name|uint64_t
name|reserved_36_38
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|reserved_32_34
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|reserved_28_30
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|reserved_24_26
range|:
literal|3
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|reserved_20_22
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|reserved_12_14
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|reserved_8_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port0 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT0[ISIZE] field. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< This '1' when a bit in PCI_INT_SUM2 is SET and the                                                          corresponding bit in the PCI_INT_ENB2 is SET. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive a commit                                                          back from a RSL after sending a write command to                                                          a RSL. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive read data                                                          back from a RSL after sending a read command to                                                          a RSL. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_10
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_14
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_22
range|:
literal|3
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_26
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_30
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_34
range|:
literal|3
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_38
range|:
literal|3
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_npi_int_sum_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-1 FIFO is full. */
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-1 FIFO is empty. */
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to push a full PCN-DATA-FIFO. */
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to pop an empty PCN-DATA-FIFO. */
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to push a full PCN-CNT-FIFO. */
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to pop an empty PCN-CNT-FIFO. */
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when DPI-XFR-Wait count is 0. */
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when RDN-XFR-Wait count is 0. */
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when PNI-NPI Credits are max. */
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when PNI-NPI Credits are 0. */
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when PCN-Commit Counter is max. */
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when PCN-Commit Counter is 0. */
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-3 FIFO is full. */
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-3 FIFO is empty. */
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when Queue-2 FIFO is full. */
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when Queue-2 FIFO is empty. */
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when POW Credits is full. */
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when POW Credits is empty. */
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to add when FPA Credits is full. */
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
comment|/**< Attempted to subtract when FPA Credits is empty. */
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Requested IOBDMA read size exceeded 128 words. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on data written to L2C                                                          from the PCI this bit may be set. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Windowed Load Timed Out. */
name|uint64_t
name|reserved_37_38
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|reserved_33_34
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|reserved_21_22
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|reserved_17_18
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port1 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT1[ISIZE] field. */
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port0 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT0[ISIZE] field. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< This '1' when a bit in PCI_INT_SUM2 is SET and the                                                          corresponding bit in the PCI_INT_ENB2 is SET. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive a commit                                                          back from a RSL after sending a write command to                                                          a RSL. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive read data                                                          back from a RSL after sending a read command to                                                          a RSL. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_10
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_18
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_22
range|:
literal|2
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_34
range|:
literal|2
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_38
range|:
literal|2
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcr_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q2_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q3_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|com_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnc_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rwx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdx_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdf_p_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_s_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|q1_a_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_npi_int_sum_s
name|cn38xx
decl_stmt|;
struct|struct
name|cvmx_npi_int_sum_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
comment|/**< Requested IOBDMA read size exceeded 128 words. */
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on data written to L2C                                                          from the PCI this bit may be set. */
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
comment|/**< Windowed Load Timed Out. */
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's instruction                                                          this bit may be set. */
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 output had a read timeout on a DATA/INFO                                                          pair. */
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port DATA/INFO                                                          pointer-pair, this bit may be set. */
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read a gather list. */
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
comment|/**< If a parity error occured on the port's packet                                                          data this bit may be set. */
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read packet data. */
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a doorbell overflow. Bit[31] of the                                                          doorbell count was set. */
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-3 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-2 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-1 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
comment|/**< Port-0 had a read timeout while attempting to                                                          read instructions. */
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port3 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT3[ISIZE] field. */
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port2 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT2[ISIZE] field. */
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port1 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT1[ISIZE] field. */
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
comment|/**< The packet being sent out on Port0 is smaller                                                          than the NPI_BUFF_SIZE_OUTPUT0[ISIZE] field. */
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
comment|/**< This '1' when a bit in PCI_INT_SUM2 is SET and the                                                          corresponding bit in the PCI_INT_ENB2 is SET. */
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive a commit                                                          back from a RSL after sending a write command to                                                          a RSL. */
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when the RML does not receive read data                                                          back from a RSL after sending a read command to                                                          a RSL. */
else|#
directive|else
name|uint64_t
name|rml_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_wto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pci_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po0_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po1_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po2_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|po3_2sml
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_overf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g0_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g1_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g2_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|g3_rtout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_ptout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i0_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i1_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i2_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|i3_pperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|win_rto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_dperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iobdma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_npi_int_sum_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_int_sum_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_int_sum_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_int_sum
name|cvmx_npi_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_lowp_dbell  *  * NPI_LOWP_DBELL = Low Priority Door Bell  *  * The door bell register for the low priority DMA queue.  */
end_comment

begin_union
union|union
name|cvmx_npi_lowp_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_lowp_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dbell
range|:
literal|16
decl_stmt|;
comment|/**< The value written to this register is added to the                                                          number of 8byte words to be read and processes for                                                          the low priority dma queue. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_lowp_dbell_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_dbell_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_dbell_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_dbell_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_lowp_dbell_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_dbell_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_dbell_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_lowp_dbell
name|cvmx_npi_lowp_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_lowp_ibuff_saddr  *  * NPI_LOWP_IBUFF_SADDR = DMA Low Priority's Instruction Buffer Starting Address  *  * The address to start reading Instructions from for LOWP.  */
end_comment

begin_union
union|union
name|cvmx_npi_lowp_ibuff_saddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_lowp_ibuff_saddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|36
decl_stmt|;
comment|/**< The starting address to read the first instruction. */
else|#
directive|else
name|uint64_t
name|saddr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_lowp_ibuff_saddr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_ibuff_saddr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_ibuff_saddr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_ibuff_saddr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_lowp_ibuff_saddr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_ibuff_saddr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_lowp_ibuff_saddr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_lowp_ibuff_saddr
name|cvmx_npi_lowp_ibuff_saddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_mem_access_subid#  *  * NPI_MEM_ACCESS_SUBID3 = Memory Access SubId 3Register  *  * Carries Read/Write parameters for PP access to PCI memory that use NPI SubId3.  * Writes to this register are not ordered with writes/reads to the PCI Memory space.  * To ensure that a write has completed the user must read the register before  * making an access(i.e. PCI memory space) that requires the value of this register to be updated.  */
end_comment

begin_union
union|union
name|cvmx_npi_mem_access_subidx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_mem_access_subidx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|shortl
range|:
literal|1
decl_stmt|;
comment|/**< Generate CMD-6 on PCI(x) when '1'.                                                          Loads from the cores to the corresponding subid                                                          that are 32-bits or smaller:                                                          - Will generate the PCI-X "Memory Read DWORD"                                                            command in PCI-X mode. (Note that "Memory                                                            Read DWORD" appears much like an IO read on                                                            the PCI-X bus.)                                                          - Will generate the PCI "Memory Read" command                                                            in PCI-X mode, irrespective of the                                                            NPI_PCI_READ_CMD[CMD_SIZE] value.                                                          NOT IN PASS 1 NOR PASS 2 */
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
comment|/**< No Merge. (NOT IN PASS 1 NOR PASS 2) */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< Endian-Swap on read. */
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
comment|/**< Endian-Swap on write. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< No-Snoop on read. */
name|uint64_t
name|nsw
range|:
literal|1
decl_stmt|;
comment|/**< No-Snoop on write. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< Relax Read on read. */
name|uint64_t
name|row
range|:
literal|1
decl_stmt|;
comment|/**< Relax Order on write. */
name|uint64_t
name|ba
range|:
literal|28
decl_stmt|;
comment|/**< PCI Address bits [63:36]. */
else|#
directive|else
name|uint64_t
name|ba
range|:
literal|28
decl_stmt|;
name|uint64_t
name|row
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|shortl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_mem_access_subidx_s
name|cn30xx
decl_stmt|;
struct|struct
name|cvmx_npi_mem_access_subidx_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< Endian-Swap on read. */
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
comment|/**< Endian-Swap on write. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< No-Snoop on read. */
name|uint64_t
name|nsw
range|:
literal|1
decl_stmt|;
comment|/**< No-Snoop on write. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< Relax Read on read. */
name|uint64_t
name|row
range|:
literal|1
decl_stmt|;
comment|/**< Relax Order on write. */
name|uint64_t
name|ba
range|:
literal|28
decl_stmt|;
comment|/**< PCI Address bits [63:36]. */
else|#
directive|else
name|uint64_t
name|ba
range|:
literal|28
decl_stmt|;
name|uint64_t
name|row
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_npi_mem_access_subidx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_mem_access_subidx_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_mem_access_subidx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_mem_access_subidx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_mem_access_subidx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_mem_access_subidx
name|cvmx_npi_mem_access_subidx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_msi_rcv  *  * NPI_MSI_RCV = NPI MSI Receive Vector Register  *  * A bit is set in this register relative to the vector received during a MSI. And cleared by a W1 to the register.  */
end_comment

begin_union
union|union
name|cvmx_npi_msi_rcv
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_msi_rcv_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|int_vec
range|:
literal|64
decl_stmt|;
comment|/**< Refer to PCI_MSI_RCV */
else|#
directive|else
name|uint64_t
name|int_vec
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_msi_rcv_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_msi_rcv_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_msi_rcv_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_msi_rcv_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_msi_rcv_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_msi_rcv_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_msi_rcv_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_msi_rcv
name|cvmx_npi_msi_rcv_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_num_desc_output#  *  * NUM_DESC_OUTPUT0 = Number Of Descriptors Available For Output 0  *  * The size of the Buffer/Info Pointer Pair ring for Output-0.  */
end_comment

begin_union
union|union
name|cvmx_npi_num_desc_outputx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_num_desc_outputx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|size
range|:
literal|32
decl_stmt|;
comment|/**< The size of the Buffer/Info Pointer Pair ring. */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_num_desc_outputx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_num_desc_outputx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_num_desc_outputx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_num_desc_outputx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_num_desc_outputx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_num_desc_outputx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_num_desc_outputx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_num_desc_outputx
name|cvmx_npi_num_desc_outputx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_output_control  *  * NPI_OUTPUT_CONTROL = NPI's Output Control Register  *  * The address to start reading Instructions from for Output-3.  */
end_comment

begin_union
union|union
name|cvmx_npi_output_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_output_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the output packet selection will be                                                          made with a Round Robin arbitration. When '0'                                                          the output packet port is fixed in priority,                                                          where the lower port number has higher priority.                                                          PASS3 Field */
name|uint64_t
name|p3_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT3 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p2_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT2 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT1 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT0 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|o3_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output3 Data. */
name|uint64_t
name|o3_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output3 Data. */
name|uint64_t
name|o3_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output3 Data. */
name|uint64_t
name|o2_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output2 Data. */
name|uint64_t
name|o2_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output2 Data. */
name|uint64_t
name|o2_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output2 Data. */
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output1 Data. */
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output1 Data. */
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output1 Data. */
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output0 Data. */
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output0 Data. */
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output0 Data. */
name|uint64_t
name|o3_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O3_ES,                                                          O3_NS, O3_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O3_ES[1:0], O3_NS, O3_RO. For Output Port-3. */
name|uint64_t
name|o2_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O2_ES,                                                          O2_NS, O2_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O2_ES[1:0], O2_NS, O2_RO. For Output Port-2. */
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O1_ES,                                                          O1_NS, O1_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O1_ES[1:0], O1_NS, O1_RO. For Output Port-1. */
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O0_ES,                                                          O0_NS, O0_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O0_ES[1:0], O0_NS, O0_RO. For Output Port-0. */
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|iptr_o3
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-3. */
name|uint64_t
name|iptr_o2
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-2. */
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-1. */
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-0. */
name|uint64_t
name|esr_sl3
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist3 reads. */
name|uint64_t
name|nsr_sl3
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist3 reads. */
name|uint64_t
name|ror_sl3
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist3 reads. */
name|uint64_t
name|esr_sl2
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist2 reads. */
name|uint64_t
name|nsr_sl2
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist2 reads. */
name|uint64_t
name|ror_sl2
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist2 reads. */
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist1 reads. */
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist1 reads. */
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist1 reads. */
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist0 reads. */
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist0 reads. */
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist0 reads. */
else|#
directive|else
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o2_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o3_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o2_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o2_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o2_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o3_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o3_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o3_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_output_control_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT0 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|reserved_32_43
range|:
literal|12
decl_stmt|;
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output0 Data. */
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output0 Data. */
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output0 Data. */
name|uint64_t
name|reserved_25_27
range|:
literal|3
decl_stmt|;
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O0_ES,                                                          O0_NS, O0_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O0_ES[1:0], O0_NS, O0_RO. For Output Port-0. */
name|uint64_t
name|reserved_17_23
range|:
literal|7
decl_stmt|;
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-0. */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist0 reads. */
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist0 reads. */
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist0 reads. */
else|#
directive|else
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_23
range|:
literal|7
decl_stmt|;
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_27
range|:
literal|3
decl_stmt|;
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_32_43
range|:
literal|12
decl_stmt|;
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_npi_output_control_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT1 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT0 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|reserved_36_43
range|:
literal|8
decl_stmt|;
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output1 Data. */
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output1 Data. */
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output1 Data. */
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output0 Data. */
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output0 Data. */
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output0 Data. */
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O1_ES,                                                          O1_NS, O1_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O1_ES[1:0], O1_NS, O1_RO. For Output Port-1. */
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O0_ES,                                                          O0_NS, O0_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O0_ES[1:0], O0_NS, O0_RO. For Output Port-0. */
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-1. */
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-0. */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist1 reads. */
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist1 reads. */
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist1 reads. */
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist0 reads. */
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist0 reads. */
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist0 reads. */
else|#
directive|else
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_43
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_npi_output_control_s
name|cn38xx
decl_stmt|;
struct|struct
name|cvmx_npi_output_control_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|p3_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT3 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p2_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT2 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT1 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT0 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|o3_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output3 Data. */
name|uint64_t
name|o3_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output3 Data. */
name|uint64_t
name|o3_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output3 Data. */
name|uint64_t
name|o2_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output2 Data. */
name|uint64_t
name|o2_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output2 Data. */
name|uint64_t
name|o2_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output2 Data. */
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output1 Data. */
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output1 Data. */
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output1 Data. */
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output0 Data. */
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output0 Data. */
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output0 Data. */
name|uint64_t
name|o3_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O3_ES,                                                          O3_NS, O3_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O3_ES[1:0], O3_NS, O3_RO. For Output Port-3. */
name|uint64_t
name|o2_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O2_ES,                                                          O2_NS, O2_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O2_ES[1:0], O2_NS, O2_RO. For Output Port-2. */
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O1_ES,                                                          O1_NS, O1_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O1_ES[1:0], O1_NS, O1_RO. For Output Port-1. */
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O0_ES,                                                          O0_NS, O0_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O0_ES[1:0], O0_NS, O0_RO. For Output Port-0. */
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|iptr_o3
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-3. */
name|uint64_t
name|iptr_o2
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-2. */
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-1. */
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-0. */
name|uint64_t
name|esr_sl3
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist3 reads. */
name|uint64_t
name|nsr_sl3
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist3 reads. */
name|uint64_t
name|ror_sl3
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist3 reads. */
name|uint64_t
name|esr_sl2
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist2 reads. */
name|uint64_t
name|nsr_sl2
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist2 reads. */
name|uint64_t
name|ror_sl2
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist2 reads. */
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist1 reads. */
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist1 reads. */
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist1 reads. */
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist0 reads. */
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist0 reads. */
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist0 reads. */
else|#
directive|else
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_23
range|:
literal|4
decl_stmt|;
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o2_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o3_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o2_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o2_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o2_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o3_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o3_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o3_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
struct|struct
name|cvmx_npi_output_control_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the output packet selection will be                                                          made with a Round Robin arbitration. When '0'                                                          the output packet port is fixed in priority,                                                          where the lower port number has higher priority.                                                          PASS2 Field */
name|uint64_t
name|reserved_46_47
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT1 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' PCI_PKTS_SENT0 register will be                                                          updated with the number of bytes in the packet                                                          sent, when '0' the register will have a value                                                          of '1' added. */
name|uint64_t
name|reserved_36_43
range|:
literal|8
decl_stmt|;
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output1 Data. */
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output1 Data. */
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output1 Data. */
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap for Output0 Data. */
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
comment|/**< NoSnoop Enable for Output0 Data. */
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Enable for Output0 Data. */
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O1_ES,                                                          O1_NS, O1_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O1_ES[1:0], O1_NS, O1_RO. For Output Port-1. */
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the address[63:60] to write packet data,                                                          comes from the DPTR[63:60] in the scatter-list pair,                                                          and the RO, NS, ES values come from the O0_ES,                                                          O0_NS, O0_RO. When '0' the RO == DPTR[60],                                                          NS == DPTR[61], ES == DPTR[63:62], the address the                                                          packet will be written to is ADDR[63:60] ==                                                          O0_ES[1:0], O0_NS, O0_RO. For Output Port-0. */
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-1. */
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
comment|/**< Uses the Info-Pointer to store length and data                                                          for output-0. */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist1 reads. */
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist1 reads. */
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist1 reads. */
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
comment|/**< The Endian-Swap-Mode for Slist0 reads. */
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' NoSnoop for Slist0 reads. */
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
comment|/**< Enables '1' Relaxed Ordering for Slist0 reads. */
else|#
directive|else
name|uint64_t
name|ror_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl0
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ror_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nsr_sl1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr_sl1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|iptr_o0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iptr_o1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|o0_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_csrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o0_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o0_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o1_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o1_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_43
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_bmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_46_47
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_npi_output_control_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_output_control_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_output_control
name|cvmx_npi_output_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_p#_dbpair_addr  *  * NPI_P0_DBPAIR_ADDR = NPI's Port-0 DATA-BUFFER Pair Next Read Address.  *  * Contains the next address to read for Port's-0 Data/Buffer Pair.  */
end_comment

begin_union
union|union
name|cvmx_npi_px_dbpair_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_px_dbpair_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
name|uint64_t
name|state
range|:
literal|2
decl_stmt|;
comment|/**< POS state machine vector. Used to tell when NADDR                                                          is valid (when STATE == 0). */
name|uint64_t
name|naddr
range|:
literal|61
decl_stmt|;
comment|/**< Bits [63:3] of the next Data-Info Pair to read.                                                          Value is only valid when STATE == 0. */
else|#
directive|else
name|uint64_t
name|naddr
range|:
literal|61
decl_stmt|;
name|uint64_t
name|state
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_63_63
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_px_dbpair_addr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_px_dbpair_addr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_px_dbpair_addr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_px_dbpair_addr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_px_dbpair_addr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_px_dbpair_addr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_px_dbpair_addr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_px_dbpair_addr
name|cvmx_npi_px_dbpair_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_p#_instr_addr  *  * NPI_P0_INSTR_ADDR = NPI's Port-0 Instruction Next Read Address.  *  * Contains the next address to read for Port's-0 Instructions.  */
end_comment

begin_union
union|union
name|cvmx_npi_px_instr_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_px_instr_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|state
range|:
literal|3
decl_stmt|;
comment|/**< Gather engine state vector. Used to tell when                                                          NADDR is valid (when STATE == 0). */
name|uint64_t
name|naddr
range|:
literal|61
decl_stmt|;
comment|/**< Bits [63:3] of the next Instruction to read.                                                          Value is only valid when STATE == 0. */
else|#
directive|else
name|uint64_t
name|naddr
range|:
literal|61
decl_stmt|;
name|uint64_t
name|state
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_px_instr_addr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_addr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_addr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_addr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_addr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_addr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_addr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_px_instr_addr
name|cvmx_npi_px_instr_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_p#_instr_cnts  *  * NPI_P0_INSTR_CNTS = NPI's Port-0 Instruction Counts For Packets In.  *  * Used to determine the number of instruction in the NPI and to be fetched for Input-Packets.  */
end_comment

begin_union
union|union
name|cvmx_npi_px_instr_cnts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_px_instr_cnts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|6
decl_stmt|;
comment|/**< Number entries in the Instruction FIFO. */
name|uint64_t
name|avail
range|:
literal|32
decl_stmt|;
comment|/**< Doorbell count to be read. */
else|#
directive|else
name|uint64_t
name|avail
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_px_instr_cnts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_cnts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_cnts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_cnts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_cnts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_cnts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_px_instr_cnts_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_px_instr_cnts
name|cvmx_npi_px_instr_cnts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_p#_pair_cnts  *  * NPI_P0_PAIR_CNTS = NPI's Port-0 Instruction Counts For Packets Out.  *  * Used to determine the number of instruction in the NPI and to be fetched for Output-Packets.  */
end_comment

begin_union
union|union
name|cvmx_npi_px_pair_cnts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_px_pair_cnts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|5
decl_stmt|;
comment|/**< 16 - number entries in the D/I Pair FIFO. */
name|uint64_t
name|avail
range|:
literal|32
decl_stmt|;
comment|/**< Doorbell count to be read. */
else|#
directive|else
name|uint64_t
name|avail
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_px_pair_cnts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_px_pair_cnts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_px_pair_cnts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_px_pair_cnts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_px_pair_cnts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_px_pair_cnts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_px_pair_cnts_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_px_pair_cnts
name|cvmx_npi_px_pair_cnts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_pci_burst_size  *  * NPI_PCI_BURST_SIZE = NPI PCI Burst Size Register  *  * Control the number of words the NPI will attempt to read / write to/from the PCI.  */
end_comment

begin_union
union|union
name|cvmx_npi_pci_burst_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_pci_burst_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|wr_brst
range|:
literal|7
decl_stmt|;
comment|/**< The number of 8B words to write to PCI in any one                                                          write operation. A zero is equal to 128. This                                                          value is used the packet reads and is clamped at                                                          a max of 112 for dma writes. */
name|uint64_t
name|rd_brst
range|:
literal|7
decl_stmt|;
comment|/**< Number of 8B words to read from PCI in any one                                                          read operation. Legal values are 1 to 127, where                                                          a 0 will be treated as a 1.                                                          "For reading of packet data value is limited to 64                                                          in PASS-2."                                                          This value does not control the size of a read                                                          caused by an IOBDMA from a PP. */
else|#
directive|else
name|uint64_t
name|rd_brst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|wr_brst
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_pci_burst_size_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_burst_size_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_burst_size_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_burst_size_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_pci_burst_size_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_burst_size_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_burst_size_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_pci_burst_size
name|cvmx_npi_pci_burst_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_pci_int_arb_cfg  *  * NPI_PCI_INT_ARB_CFG = Configuration For PCI Arbiter  *  * Controls operation of the Internal PCI Arbiter.  This register should  * only be written when PRST# is asserted.  NPI_PCI_INT_ARB_CFG[EN] should  * only be set when Octane is a host.  */
end_comment

begin_union
union|union
name|cvmx_npi_pci_int_arb_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_pci_int_arb_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|hostmode
range|:
literal|1
decl_stmt|;
comment|/**< PCI Host Mode Pin (sampled for use by software).                                                          This bit reflects the sampled PCI_HOSTMODE pin.                                                          In HOST Mode, OCTEON drives the PCI_CLK_OUT and                                                          PCI initialization pattern during PCI_RST_N deassertion). */
name|uint64_t
name|pci_ovr
range|:
literal|4
decl_stmt|;
comment|/**< PCI Host Mode Bus Speed/Type Override                                                           When in Host Mode(PCI_HOSTMODE pin =1), OCTEON acting                                                           as the PCI Central Agent, samples the PCI_PCI100,                                                           PCI_M66EN and PCI_PCIXCAP pins to determine the                                                           'sampled' PCI Bus speed and Bus Type (PCI or PCIX).                                                           (see: PCI_CNT_REG[HM_SPEED,HM_PCIX])                                                           However, in some cases, SW may want to override the                                                           the 'sampled' PCI Bus Type/Speed, and use some                                                           SLOWER Bus frequency.                                                           The PCI_OVR field encoding represents the 'override'                                                           PCI Bus Type/Speed which will be used to generate the                                                           PCI_CLK_OUT and determines the PCI initialization pattern                                                           driven during PCI_RST_N deassertion.                                                               PCI_OVR[3]: OVERRIDE (0:DISABLE/1:ENABLE)                                                               PCI_OVR[2]: BUS TYPE(0:PCI/1:PCIX)                                                               PCI_OVR[1:0]: BUS SPEED(0:33/1:66/2:100/3:133)                                                          OVERRIDE TYPE SPEED |  Override Configuration                                                             [3]   [2]  [1:0] | TYPE       SPEED                                                            ------------------+-------------------------------                                                              0     x      xx | No override(uses 'sampled'                                                                              | Bus Speed(HM_SPEED) and Bus Type(HM_PCIX)                                                              1     0      00 | PCI Mode    33MHz                                                              1     0      01 | PCI Mode    66MHz                                                              1     0      10 | RESERVED (DO NOT USE)                                                              1     0      11 | RESERVED (DO NOT USE)                                                              1     1      00 | RESERVED (DO NOT USE)                                                              1     1      01 | PCIX Mode   66MHz                                                              1     1      10 | PCIX Mode  100MHz                                                              1     1      11 | PCIX Mode  133MHz                                                           NOTES:                                                           - NPI_PCI_INT_ARB_CFG[PCI_OVR] has NO EFFECT on                                                             PCI_CNT_REG[HM_SPEED,HM_PCIX] (ie: the sampled PCI Bus                                                             Type/Speed), but WILL EFFECT PCI_CTL_STATUS_2[AP_PCIX]                                                             which reflects the actual PCI Bus Type(0:PCI/1:PCIX).                                                           - Software should never 'up' configure the recommended values.                                                             In other words, if the 'sampled' Bus Type=PCI(HM_PCIX=0),                                                             then SW should NOT attempt to set TYPE[2]=1 for PCIX Mode.                                                             Likewise, if the sampled Bus Speed=66MHz(HM_SPEED=01),                                                             then SW should NOT attempt to 'speed up' the bus [ie:                                                             SPEED[1:0]=10(100MHz)].                                                           - If PCI_OVR<3> is set prior to PCI reset de-assertion                                                             in host mode, NPI_PCI_INT_ARB_CFG[PCI_OVR]                                                             indicates the Bus Type/Speed that OCTEON drove on the                                                             DEVSEL/STOP/TRDY pins during reset de-assertion. (user                                                             should then ignore the 'sampled' Bus Type/Speed                                                             contained in the PCI_CNT_REG[HM_PCIX, HM_SPEED]) fields.                                                           - If PCI_OVR<3> is clear prior to PCI reset de-assertion                                                             in host mode, PCI_CNT_REG[HM_PCIX,HM_SPEED])                                                             indicates the Bus Type/Speed that OCTEON drove on the                                                             DEVSEL/STOP/TRDY pins during reset de-assertion. */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Internal arbiter enable. */
name|uint64_t
name|park_mod
range|:
literal|1
decl_stmt|;
comment|/**< Bus park mode. 0=park on last, 1=park on device. */
name|uint64_t
name|park_dev
range|:
literal|3
decl_stmt|;
comment|/**< Bus park device. 0-3 External device, 4 = Octane. */
else|#
directive|else
name|uint64_t
name|park_dev
range|:
literal|3
decl_stmt|;
name|uint64_t
name|park_mod
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pci_ovr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|hostmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_pci_int_arb_cfg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Internal arbiter enable. */
name|uint64_t
name|park_mod
range|:
literal|1
decl_stmt|;
comment|/**< Bus park mode. 0=park on last, 1=park on device. */
name|uint64_t
name|park_dev
range|:
literal|3
decl_stmt|;
comment|/**< Bus park device. 0-3 External device, 4 = Octane. */
else|#
directive|else
name|uint64_t
name|park_dev
range|:
literal|3
decl_stmt|;
name|uint64_t
name|park_mod
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_npi_pci_int_arb_cfg_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_int_arb_cfg_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_int_arb_cfg_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_pci_int_arb_cfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_int_arb_cfg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_int_arb_cfg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_pci_int_arb_cfg
name|cvmx_npi_pci_int_arb_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_pci_read_cmd  *  * NPI_PCI_READ_CMD = NPI PCI Read Command Register  *  * Controls the type of read command sent.  * Writes to this register are not ordered with writes/reads to the PCI Memory space.  * To ensure that a write has completed the user must read the register before  * making an access(i.e. PCI memory space) that requires the value of this register to be updated.  * Also any previously issued reads/writes to PCI memory space, still stored in the outbound  * FIFO will use the value of this register after it has been updated.  */
end_comment

begin_union
union|union
name|cvmx_npi_pci_read_cmd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_pci_read_cmd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|cmd_size
range|:
literal|11
decl_stmt|;
comment|/**< Number bytes to be read is equal to or exceeds this                                                          size will cause the PCI in PCI mode to use a                                                          Memory-Read-Multiple. This register has a value                                                          from 8 to 2048. A value of 0-7 will be treated as                                                          a value of 2048. */
else|#
directive|else
name|uint64_t
name|cmd_size
range|:
literal|11
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_pci_read_cmd_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_read_cmd_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_read_cmd_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_read_cmd_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_pci_read_cmd_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_read_cmd_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_pci_read_cmd_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_pci_read_cmd
name|cvmx_npi_pci_read_cmd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_port32_instr_hdr  *  * NPI_PORT32_INSTR_HDR = NPI Port 32 Instruction Header  *  * Contains bits [62:42] of the Instruction Header for port 32.  */
end_comment

begin_union
union|union
name|cvmx_npi_port32_instr_hdr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_port32_instr_hdr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
comment|/**< Enable Packet-by-packet mode. */
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the instruction header will be sent                                                          as part of the packet data, regardless of the                                                          value of bit [63] of the instruction header.                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
comment|/**< Reserved                                                          instruction header sent to IPD. */
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_port32_instr_hdr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_port32_instr_hdr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_port32_instr_hdr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_port32_instr_hdr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_port32_instr_hdr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_port32_instr_hdr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_port32_instr_hdr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_port32_instr_hdr
name|cvmx_npi_port32_instr_hdr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_port33_instr_hdr  *  * NPI_PORT33_INSTR_HDR = NPI Port 33 Instruction Header  *  * Contains bits [62:42] of the Instruction Header for port 33.  */
end_comment

begin_union
union|union
name|cvmx_npi_port33_instr_hdr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_port33_instr_hdr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
comment|/**< Enable Packet-by-packet mode. */
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the instruction header will be sent                                                          as part of the packet data, regardless of the                                                          value of bit [63] of the instruction header.                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
comment|/**< Reserved                                                          instruction header sent to IPD. */
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_port33_instr_hdr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_port33_instr_hdr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_port33_instr_hdr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_port33_instr_hdr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_port33_instr_hdr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_port33_instr_hdr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_port33_instr_hdr
name|cvmx_npi_port33_instr_hdr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_port34_instr_hdr  *  * NPI_PORT34_INSTR_HDR = NPI Port 34 Instruction Header  *  * Contains bits [62:42] of the Instruction Header for port 34. Added for PASS-2.  */
end_comment

begin_union
union|union
name|cvmx_npi_port34_instr_hdr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_port34_instr_hdr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
comment|/**< Enable Packet-by-packet mode. */
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the instruction header will be sent                                                          as part of the packet data, regardless of the                                                          value of bit [63] of the instruction header.                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
comment|/**< Reserved                                                          instruction header sent to IPD. */
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_port34_instr_hdr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_port34_instr_hdr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_port34_instr_hdr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_port34_instr_hdr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_port34_instr_hdr
name|cvmx_npi_port34_instr_hdr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_port35_instr_hdr  *  * NPI_PORT35_INSTR_HDR = NPI Port 35 Instruction Header  *  * Contains bits [62:42] of the Instruction Header for port 35. Added for PASS-2.  */
end_comment

begin_union
union|union
name|cvmx_npi_port35_instr_hdr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_port35_instr_hdr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
comment|/**< Enable Packet-by-packet mode. */
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when packet is raw and PBP==0. */
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the instruction header will be sent                                                          as part of the packet data, regardless of the                                                          value of bit [63] of the instruction header.                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
comment|/**< Reserved                                                          instruction header sent to IPD. */
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Used when USE_IHDR is set and packet                                                          is not raw and PBP is not set. */
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint64_t
name|rsv_a
range|:
literal|6
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_c
range|:
literal|5
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsv_d
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rsv_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsv_f
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_port35_instr_hdr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_port35_instr_hdr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_port35_instr_hdr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_port35_instr_hdr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_port35_instr_hdr
name|cvmx_npi_port35_instr_hdr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_port_bp_control  *  * NPI_PORT_BP_CONTROL = Port Backpressure Control  *  * Enables Port Level Backpressure  */
end_comment

begin_union
union|union
name|cvmx_npi_port_bp_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_port_bp_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|bp_on
range|:
literal|4
decl_stmt|;
comment|/**< Port 35-32 port level backpressure applied. */
name|uint64_t
name|enb
range|:
literal|4
decl_stmt|;
comment|/**< Enables port level backpressure from the IPD. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bp_on
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_port_bp_control_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_port_bp_control_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_port_bp_control_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_port_bp_control_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_port_bp_control_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_port_bp_control_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_port_bp_control_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_port_bp_control
name|cvmx_npi_port_bp_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_rsl_int_blocks  *  * RSL_INT_BLOCKS = RSL Interrupt Blocks Register  *  * Reading this register will return a vector with a bit set '1' for a corresponding RSL block  * that presently has an interrupt pending. The Field Description below supplies the name of the  * register that software should read to find out why that intterupt bit is set.  */
end_comment

begin_union
union|union
name|cvmx_npi_rsl_int_blocks
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_rsl_int_blocks_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rint_31
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
comment|/**< IOB_INT_SUM */
name|uint64_t
name|reserved_28_29
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rint_27
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_26
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_25
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_24
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
comment|/**< ASX1_INT_REG */
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
comment|/**< ASX0_INT_REG */
name|uint64_t
name|rint_21
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
comment|/**< PIP_INT_REG. */
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
comment|/**< SPX1_INT_REG& STX1_INT_REG */
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
comment|/**< SPX0_INT_REG& STX0_INT_REG */
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
comment|/**< LMC_MEM_CFG0 */
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
comment|/**< L2T_ERR& L2D_ERR */
name|uint64_t
name|rint_15
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
comment|/**< POW_ECC_ERR */
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
comment|/**< TIM_REG_ERROR */
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
comment|/**< PKO_REG_ERROR */
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
comment|/**< IPD_INT_SUM */
name|uint64_t
name|rint_8
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
comment|/**< ZIP_ERROR */
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
comment|/**< DFA_ERR */
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
comment|/**< FPA_INT_SUM */
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
comment|/**< KEY_INT_SUM */
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
comment|/**< NPI_INT_SUM */
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
comment|/**< GMX1_RX*_INT_REG& GMX1_TX_INT_REG */
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
comment|/**< GMX0_RX*_INT_REG& GMX0_TX_INT_REG */
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
comment|/**< MIO_BOOT_ERR */
else|#
directive|else
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rint_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_21
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_29
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_npi_rsl_int_blocks_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rint_31
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
comment|/**< IOB_INT_SUM */
name|uint64_t
name|rint_29
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_28
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_27
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_26
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_25
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_24
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
comment|/**< ASX1_INT_REG */
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
comment|/**< ASX0_INT_REG */
name|uint64_t
name|rint_21
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
comment|/**< PIP_INT_REG. */
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
comment|/**< SPX1_INT_REG& STX1_INT_REG */
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
comment|/**< SPX0_INT_REG& STX0_INT_REG */
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
comment|/**< LMC_MEM_CFG0 */
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
comment|/**< L2T_ERR& L2D_ERR */
name|uint64_t
name|rint_15
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_14
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|usb
range|:
literal|1
decl_stmt|;
comment|/**< USBN_INT_SUM */
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
comment|/**< POW_ECC_ERR */
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
comment|/**< TIM_REG_ERROR */
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
comment|/**< PKO_REG_ERROR */
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
comment|/**< IPD_INT_SUM */
name|uint64_t
name|rint_8
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
comment|/**< ZIP_ERROR */
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
comment|/**< DFA_ERR */
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
comment|/**< FPA_INT_SUM */
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
comment|/**< NPI_INT_SUM */
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
comment|/**< GMX1_RX*_INT_REG& GMX1_TX_INT_REG */
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
comment|/**< GMX0_RX*_INT_REG& GMX0_TX_INT_REG */
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
comment|/**< MIO_BOOT_ERR */
else|#
directive|else
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_21
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_28
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_npi_rsl_int_blocks_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_npi_rsl_int_blocks_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rint_31
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
comment|/**< IOB_INT_SUM */
name|uint64_t
name|rint_29
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_28
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_27
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_26
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_25
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_24
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
comment|/**< ASX1_INT_REG */
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
comment|/**< ASX0_INT_REG */
name|uint64_t
name|rint_21
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
comment|/**< PIP_INT_REG. */
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
comment|/**< SPX1_INT_REG& STX1_INT_REG */
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
comment|/**< SPX0_INT_REG& STX0_INT_REG */
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
comment|/**< LMC_MEM_CFG0 */
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
comment|/**< L2T_ERR& L2D_ERR */
name|uint64_t
name|rint_15
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_14
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|rint_13
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
comment|/**< POW_ECC_ERR */
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
comment|/**< TIM_REG_ERROR */
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
comment|/**< PKO_REG_ERROR */
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
comment|/**< IPD_INT_SUM */
name|uint64_t
name|rint_8
range|:
literal|1
decl_stmt|;
comment|/**< Set '1' when RSL bLock has an interrupt. */
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
comment|/**< ZIP_ERROR */
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
comment|/**< DFA_ERR */
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
comment|/**< FPA_INT_SUM */
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
comment|/**< KEY_INT_SUM */
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
comment|/**< NPI_INT_SUM */
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
comment|/**< GMX1_RX*_INT_REG& GMX1_TX_INT_REG */
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
comment|/**< GMX0_RX*_INT_REG& GMX0_TX_INT_REG */
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
comment|/**< MIO_BOOT_ERR */
else|#
directive|else
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_21
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_28
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_29
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rint_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_npi_rsl_int_blocks_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_npi_rsl_int_blocks_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
comment|/**< IOB_INT_SUM */
name|uint64_t
name|lmc1
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|agl
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|reserved_24_27
range|:
literal|4
decl_stmt|;
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
comment|/**< ASX0_INT_REG */
name|uint64_t
name|reserved_21_21
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
comment|/**< PIP_INT_REG. */
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
comment|/**< LMC_MEM_CFG0 */
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
comment|/**< L2T_ERR& L2D_ERR */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rad
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|usb
range|:
literal|1
decl_stmt|;
comment|/**< USBN_INT_SUM */
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
comment|/**< POW_ECC_ERR */
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
comment|/**< TIM_REG_ERROR */
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
comment|/**< PKO_REG_ERROR */
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
comment|/**< IPD_INT_SUM */
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
comment|/**< FPA_INT_SUM */
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
comment|/**< NPI_INT_SUM */
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
comment|/**< Always reads as zero */
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
comment|/**< GMX0_RX*_INT_REG& GMX0_TX_INT_REG */
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
comment|/**< MIO_BOOT_ERR */
else|#
directive|else
name|uint64_t
name|mio
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|npi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|key
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pow
range|:
literal|1
decl_stmt|;
name|uint64_t
name|usb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_21
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|asx1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_27
range|:
literal|4
decl_stmt|;
name|uint64_t
name|agl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lmc1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_npi_rsl_int_blocks_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_rsl_int_blocks_cn38xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_rsl_int_blocks
name|cvmx_npi_rsl_int_blocks_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_size_input#  *  * NPI_SIZE_INPUT0 = NPI's Size for Input 0 Register  *  * The size (in instructions) of Instruction Queue-0.  */
end_comment

begin_union
union|union
name|cvmx_npi_size_inputx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_size_inputx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|size
range|:
literal|32
decl_stmt|;
comment|/**< The size of the Instruction Queue used by Octane.                                                          The value [SIZE] is in Instructions.                                                          A value of 0 in this field is illegal. */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_size_inputx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_size_inputx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_size_inputx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_size_inputx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_size_inputx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_size_inputx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_size_inputx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_size_inputx
name|cvmx_npi_size_inputx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_npi_win_read_to  *  * NPI_WIN_READ_TO = NPI WINDOW READ Timeout Register  *  * Number of core clocks to wait before timing out on a WINDOW-READ to the NCB.  */
end_comment

begin_union
union|union
name|cvmx_npi_win_read_to
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_npi_win_read_to_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
comment|/**< Time to wait in core clocks. A value of 0 will                                                          cause no timeouts. */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_npi_win_read_to_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_npi_win_read_to_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_npi_win_read_to_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_npi_win_read_to_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_npi_win_read_to_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_npi_win_read_to_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_npi_win_read_to_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_npi_win_read_to
name|cvmx_npi_win_read_to_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

