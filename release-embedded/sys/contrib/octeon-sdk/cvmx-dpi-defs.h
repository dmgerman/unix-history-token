begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-dpi-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon dpi.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_DPI_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_DPI_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_BIST_STATUS
value|CVMX_DPI_BIST_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_BIST_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_BIST_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_BIST_STATUS
value|(CVMX_ADD_IO_SEG(0x0001DF0000000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_CTL
value|CVMX_DPI_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000040ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_CTL
value|(CVMX_ADD_IO_SEG(0x0001DF0000000040ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_COUNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_COUNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000300ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_COUNTS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000300ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_DBELL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_DBELL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000200ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_DBELL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000200ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_ERR_RSP_STATUS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_ERR_RSP_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000A80ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_ERR_RSP_STATUS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000A80ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_IBUFF_SADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_IBUFF_SADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000280ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_IBUFF_SADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000280ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_IFLIGHT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_IFLIGHT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000A00ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_IFLIGHT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000A00ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_NADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_NADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000380ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_NADDR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000380ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_REQBNK0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_REQBNK0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000400ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_REQBNK0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000400ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMAX_REQBNK1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMAX_REQBNK1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000480ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMAX_REQBNK1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000480ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_DMA_CONTROL
value|CVMX_DPI_DMA_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMA_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMA_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000048ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMA_CONTROL
value|(CVMX_ADD_IO_SEG(0x0001DF0000000048ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMA_ENGX_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMA_ENGX_EN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMA_ENGX_EN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000080ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_DMA_PPX_CNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_DMA_PPX_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000B00ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_DMA_PPX_CNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000B00ull) + ((offset)& 31) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_ENGX_BUF
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_ENGX_BUF(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000880ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_ENGX_BUF
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000880ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_INFO_REG
value|CVMX_DPI_INFO_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_INFO_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_INFO_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000980ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_INFO_REG
value|(CVMX_ADD_IO_SEG(0x0001DF0000000980ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_INT_EN
value|CVMX_DPI_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001DF0000000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_INT_REG
value|CVMX_DPI_INT_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_INT_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_INT_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_INT_REG
value|(CVMX_ADD_IO_SEG(0x0001DF0000000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_NCBX_CFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_NCBX_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000800ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_NCBX_CFG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000800ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_PINT_INFO
value|CVMX_DPI_PINT_INFO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_PINT_INFO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_PINT_INFO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000830ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_PINT_INFO
value|(CVMX_ADD_IO_SEG(0x0001DF0000000830ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_PKT_ERR_RSP
value|CVMX_DPI_PKT_ERR_RSP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_PKT_ERR_RSP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_PKT_ERR_RSP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000078ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_PKT_ERR_RSP
value|(CVMX_ADD_IO_SEG(0x0001DF0000000078ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RSP
value|CVMX_DPI_REQ_ERR_RSP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_REQ_ERR_RSP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_REQ_ERR_RSP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000058ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RSP
value|(CVMX_ADD_IO_SEG(0x0001DF0000000058ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RSP_EN
value|CVMX_DPI_REQ_ERR_RSP_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_REQ_ERR_RSP_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_REQ_ERR_RSP_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000068ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RSP_EN
value|(CVMX_ADD_IO_SEG(0x0001DF0000000068ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RST
value|CVMX_DPI_REQ_ERR_RST_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_REQ_ERR_RST_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_REQ_ERR_RST not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000060ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RST
value|(CVMX_ADD_IO_SEG(0x0001DF0000000060ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RST_EN
value|CVMX_DPI_REQ_ERR_RST_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_REQ_ERR_RST_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_REQ_ERR_RST_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000070ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_RST_EN
value|(CVMX_ADD_IO_SEG(0x0001DF0000000070ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_SKIP_COMP
value|CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_REQ_ERR_SKIP_COMP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_REQ_ERR_SKIP_COMP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000838ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_ERR_SKIP_COMP
value|(CVMX_ADD_IO_SEG(0x0001DF0000000838ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_GBL_EN
value|CVMX_DPI_REQ_GBL_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_REQ_GBL_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_REQ_GBL_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000050ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_REQ_GBL_EN
value|(CVMX_ADD_IO_SEG(0x0001DF0000000050ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_SLI_PRTX_CFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_SLI_PRTX_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000900ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_SLI_PRTX_CFG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000900ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_SLI_PRTX_ERR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|offset
operator|<=
literal|3
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000920ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX_PASS1
argument_list|)
condition|)
if|if
condition|(
operator|(
name|offset
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000928ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX_PASS2
argument_list|)
condition|)
if|if
condition|(
operator|(
name|offset
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000920ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
if|if
condition|(
operator|(
name|offset
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000920ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|offset
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000928ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_SLI_PRTX_ERR (offset = %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000920ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DPI_SLI_PRTX_ERR_INFO
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DPI_SLI_PRTX_ERR_INFO(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001DF0000000940ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DPI_SLI_PRTX_ERR_INFO
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001DF0000000940ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_dpi_bist_status  */
end_comment

begin_union
union|union
name|cvmx_dpi_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_bist_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|bist
range|:
literal|47
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          BIST. */
else|#
directive|else
name|uint64_t
name|bist
range|:
literal|47
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_bist_status_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_dpi_bist_status_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
name|uint64_t
name|bist
range|:
literal|45
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          BIST. */
else|#
directive|else
name|uint64_t
name|bist
range|:
literal|45
decl_stmt|;
name|uint64_t
name|reserved_45_63
range|:
literal|19
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
struct|struct
name|cvmx_dpi_bist_status_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|bist
range|:
literal|37
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          BIST. */
else|#
directive|else
name|uint64_t
name|bist
range|:
literal|37
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dpi_bist_status_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_bist_status_cn63xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_bist_status_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_bist_status_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_bist_status
name|cvmx_dpi_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_ctl  */
end_comment

begin_union
union|union
name|cvmx_dpi_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|clk
range|:
literal|1
decl_stmt|;
comment|/**< Status bit that indicates that the clks are running */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Turns on the DMA and Packet state machines */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dpi_ctl_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Turns on the DMA and Packet state machines */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_dpi_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_ctl_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_ctl
name|cvmx_dpi_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_counts  *  * DPI_DMA[0..7]_COUNTS = DMA Instruction Counts  *  * Values for determing the number of instructions for DMA[0..7] in the DPI.  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_counts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_counts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
comment|/**< Number of words in the Instruction FIFO locally                                                          cached within DPI. */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Number of available words of Instructions to read. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dmax_counts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_counts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_counts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_counts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_counts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_counts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_counts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_counts
name|cvmx_dpi_dmax_counts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_dbell  *  * DPI_DMA_DBELL[0..7] = DMA Door Bell  *  * The door bell register for DMA[0..7] queue.  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dbell
range|:
literal|16
decl_stmt|;
comment|/**< The value written to this register is added to the                                                          number of 8byte words to be read and processes for                                                          the low priority dma queue. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dmax_dbell_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_dbell_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_dbell_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_dbell_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_dbell_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_dbell_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_dbell_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_dbell
name|cvmx_dpi_dmax_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_err_rsp_status  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_err_rsp_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_err_rsp_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|status
range|:
literal|6
decl_stmt|;
comment|/**< QUE captures the ErrorResponse status of the last                                                          6 instructions for each instruction queue.                                                          STATUS<5> represents the status for first                                                          instruction in instruction order while STATUS<0>                                                          represents the last or most recent instruction.                                                          If STATUS<n> is set, then the nth instruction in                                                          the given queue experienced an ErrorResponse.                                                          Otherwise, it completed normally. */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dmax_err_rsp_status_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_err_rsp_status_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_err_rsp_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_err_rsp_status_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_err_rsp_status_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_err_rsp_status
name|cvmx_dpi_dmax_err_rsp_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_ibuff_saddr  *  * DPI_DMA[0..7]_IBUFF_SADDR = DMA Instruction Buffer Starting Address  *  * The address to start reading Instructions from for DMA[0..7].  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_ibuff_saddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_ibuff_saddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
comment|/**< The size in 8B words of the DMA Instruction Chunk.                                                          This value should only be written at known times                                                          in order to prevent corruption of the instruction                                                          queue.  The minimum CSIZE is 16 (one cacheblock). */
name|uint64_t
name|reserved_41_47
range|:
literal|7
decl_stmt|;
name|uint64_t
name|idle
range|:
literal|1
decl_stmt|;
comment|/**< DMA Request Queue is IDLE */
name|uint64_t
name|saddr
range|:
literal|33
decl_stmt|;
comment|/**< The 128 byte aligned starting or chunk address.                                                          SADDR is address bit 35:7 of the starting                                                          instructions address. When new chunks are fetched                                                          by the HW, SADDR will be updated to reflect the                                                          address of the current chunk.                                                          A write to SADDR resets both the queue's doorbell                                                          (DPI_DMAx_COUNTS[DBELL) and its tail pointer                                                          (DPI_DMAx_NADDR[ADDR]). */
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|33
decl_stmt|;
name|uint64_t
name|idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_41_47
range|:
literal|7
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dpi_dmax_ibuff_saddr_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
comment|/**< The size in 8B words of the DMA Instruction Chunk.                                                          This value should only be written at known times                                                          in order to prevent corruption of the instruction                                                          queue.  The minimum CSIZE is 16 (one cacheblock). */
name|uint64_t
name|reserved_41_47
range|:
literal|7
decl_stmt|;
name|uint64_t
name|idle
range|:
literal|1
decl_stmt|;
comment|/**< DMA Request Queue is IDLE */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|29
decl_stmt|;
comment|/**< The 128 byte aligned starting or chunk address.                                                          SADDR is address bit 35:7 of the starting                                                          instructions address. When new chunks are fetched                                                          by the HW, SADDR will be updated to reflect the                                                          address of the current chunk.                                                          A write to SADDR resets both the queue's doorbell                                                          (DPI_DMAx_COUNTS[DBELL) and its tail pointer                                                          (DPI_DMAx_NADDR[ADDR]). */
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_6
range|:
literal|7
decl_stmt|;
name|uint64_t
name|saddr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_41_47
range|:
literal|7
decl_stmt|;
name|uint64_t
name|csize
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_dpi_dmax_ibuff_saddr_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_ibuff_saddr_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_ibuff_saddr_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_ibuff_saddr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_ibuff_saddr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_ibuff_saddr_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_ibuff_saddr
name|cvmx_dpi_dmax_ibuff_saddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_iflight  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_iflight
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_iflight_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|3
decl_stmt|;
comment|/**< The number of instructions from a given queue that                                                          can be inflight to the DMA engines at a time.                                                          Reset value matches the number of DMA engines. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dmax_iflight_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_iflight_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_iflight_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_iflight_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_iflight_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_iflight
name|cvmx_dpi_dmax_iflight_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_naddr  *  * DPI_DMA[0..7]_NADDR = DMA Next Ichunk Address  *  * Place DPI will read the next Ichunk data from.  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_naddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_naddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|40
decl_stmt|;
comment|/**< The next L2C address to read DMA# instructions                                                          from. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|40
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dpi_dmax_naddr_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
comment|/**< The next L2C address to read DMA# instructions                                                          from. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_dpi_dmax_naddr_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_naddr_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_naddr_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_naddr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_naddr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_naddr_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_naddr
name|cvmx_dpi_dmax_naddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_reqbnk0  *  * DPI_DMA[0..7]_REQBNK0 = DMA Request State Bank0  *  * Current contents of the request state machine - bank0  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_reqbnk0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_reqbnk0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|state
range|:
literal|64
decl_stmt|;
comment|/**< State */
else|#
directive|else
name|uint64_t
name|state
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dmax_reqbnk0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_reqbnk0
name|cvmx_dpi_dmax_reqbnk0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma#_reqbnk1  *  * DPI_DMA[0..7]_REQBNK1 = DMA Request State Bank1  *  * Current contents of the request state machine - bank1  */
end_comment

begin_union
union|union
name|cvmx_dpi_dmax_reqbnk1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dmax_reqbnk1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|state
range|:
literal|64
decl_stmt|;
comment|/**< State */
else|#
directive|else
name|uint64_t
name|state
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dmax_reqbnk1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dmax_reqbnk1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dmax_reqbnk1
name|cvmx_dpi_dmax_reqbnk1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma_control  *  * DPI_DMA_CONTROL = DMA Control Register  *  * Controls operation of the DMA IN/OUT.  */
end_comment

begin_union
union|union
name|cvmx_dpi_dma_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dma_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dici_mode
range|:
literal|1
decl_stmt|;
comment|/**< DMA Instruction Completion Interrupt Mode                                                          turns on mode to increment DPI_DMA_PPx_CNT                                                          counters. */
name|uint64_t
name|pkt_en1
range|:
literal|1
decl_stmt|;
comment|/**< Enables the 2nd packet interface.                                                          When the packet interface is enabled, engine 4                                                          is used for packets and is not available for DMA.                                                          The packet interfaces must be enabled in order.                                                          When PKT_EN1=1, then PKT_EN=1.                                                          When PKT_EN1=1, then DMA_ENB<4>=0. */
name|uint64_t
name|ffp_dis
range|:
literal|1
decl_stmt|;
comment|/**< Force forward progress disable                                                          The DMA engines will compete for shared resources.                                                          If the HW detects that particular engines are not                                                          able to make requests to an interface, the HW                                                          will periodically trade-off throughput for                                                          fairness. */
name|uint64_t
name|commit_mode
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine Commit Mode                                                           When COMMIT_MODE=0, DPI considers an instruction                                                          complete when the HW internally generates the                                                          final write for the current instruction.                                                           When COMMIT_MODE=1, DPI additionally waits for                                                          the final write to reach the interface coherency                                                          point to declare the instructions complete.                                                           Please note: when COMMIT_MODE == 0, DPI may not                                                          follow the HRM ordering rules.                                                           DPI hardware performance may be better with                                                          COMMIT_MODE == 0 than with COMMIT_MODE == 1 due                                                          to the relaxed ordering rules.                                                           If the HRM ordering rules are required, set                                                          COMMIT_MODE == 1. */
name|uint64_t
name|pkt_hp
range|:
literal|1
decl_stmt|;
comment|/**< High-Priority Mode for Packet Interface.                                                          This mode has been deprecated. */
name|uint64_t
name|pkt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables 1st the packet interface.                                                          When the packet interface is enabled, engine 5                                                          is used for packets and is not available for DMA.                                                          When PKT_EN=1, then DMA_ENB<5>=0.                                                          When PKT_EN1=1, then PKT_EN=1. */
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dma_enb
range|:
literal|6
decl_stmt|;
comment|/**< DMA engine enable. Enables the operation of the                                                          DMA engine. After being enabled an engine should                                                          not be disabled while processing instructions.                                                          When PKT_EN=1,  then DMA_ENB<5>=0.                                                          When PKT_EN1=1, then DMA_ENB<4>=0. */
name|uint64_t
name|reserved_34_47
range|:
literal|14
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' and the DPI is in the mode to write                                                          0 to L2C memory when a DMA is done, the address                                                          to be written to will be treated as a Little                                                          Endian address. */
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1', DPI will send a value in the DWB                                                          field for a free page operation for the memory                                                          that contained the data. */
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
comment|/**< When Instruction Chunks for DMA operations are                                                          freed this value is used for the DWB field of the                                                          operation. */
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
comment|/**< The FPA queue that the instruction-chunk page will                                                          be returned to when used. */
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' 1 will be added to the SLI_DMAX_CNT                                                          DMA counters, if '0' then the number of bytes                                                          in the dma transfer will be added to the                                                          SLI_DMAX_CNT count register. */
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Mode for DMA. */
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
comment|/**< Nosnoop For DMA. */
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode for DMA. */
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
comment|/**< Select PCI_POINTER MODE to be used.                                                          0=DPTR format 1 is used                                                            use register values for address and pointer                                                            values for ES, NS, RO                                                          1=DPTR format 0 is used                                                            use pointer values for address and register                                                            values for ES, NS, RO */
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_47
range|:
literal|14
decl_stmt|;
name|uint64_t
name|dma_enb
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_hp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|commit_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ffp_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_en1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dici_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dma_control_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_dpi_dma_control_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pkt_en1
range|:
literal|1
decl_stmt|;
comment|/**< Enables the 2nd packet interface.                                                          When the packet interface is enabled, engine 4                                                          is used for packets and is not available for DMA.                                                          The packet interfaces must be enabled in order.                                                          When PKT_EN1=1, then PKT_EN=1.                                                          When PKT_EN1=1, then DMA_ENB<4>=0. */
name|uint64_t
name|ffp_dis
range|:
literal|1
decl_stmt|;
comment|/**< Force forward progress disable                                                          The DMA engines will compete for shared resources.                                                          If the HW detects that particular engines are not                                                          able to make requests to an interface, the HW                                                          will periodically trade-off throughput for                                                          fairness. */
name|uint64_t
name|commit_mode
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine Commit Mode                                                           When COMMIT_MODE=0, DPI considers an instruction                                                          complete when the HW internally generates the                                                          final write for the current instruction.                                                           When COMMIT_MODE=1, DPI additionally waits for                                                          the final write to reach the interface coherency                                                          point to declare the instructions complete.                                                           Please note: when COMMIT_MODE == 0, DPI may not                                                          follow the HRM ordering rules.                                                           DPI hardware performance may be better with                                                          COMMIT_MODE == 0 than with COMMIT_MODE == 1 due                                                          to the relaxed ordering rules.                                                           If the HRM ordering rules are required, set                                                          COMMIT_MODE == 1. */
name|uint64_t
name|pkt_hp
range|:
literal|1
decl_stmt|;
comment|/**< High-Priority Mode for Packet Interface.                                                          This mode has been deprecated. */
name|uint64_t
name|pkt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables 1st the packet interface.                                                          When the packet interface is enabled, engine 5                                                          is used for packets and is not available for DMA.                                                          When PKT_EN=1, then DMA_ENB<5>=0.                                                          When PKT_EN1=1, then PKT_EN=1. */
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dma_enb
range|:
literal|6
decl_stmt|;
comment|/**< DMA engine enable. Enables the operation of the                                                          DMA engine. After being enabled an engine should                                                          not be disabled while processing instructions.                                                          When PKT_EN=1,  then DMA_ENB<5>=0.                                                          When PKT_EN1=1, then DMA_ENB<4>=0. */
name|uint64_t
name|reserved_34_47
range|:
literal|14
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' and the DPI is in the mode to write                                                          0 to L2C memory when a DMA is done, the address                                                          to be written to will be treated as a Little                                                          Endian address. */
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1', DPI will send a value in the DWB                                                          field for a free page operation for the memory                                                          that contained the data. */
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
comment|/**< When Instruction Chunks for DMA operations are                                                          freed this value is used for the DWB field of the                                                          operation. */
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
comment|/**< The FPA queue that the instruction-chunk page will                                                          be returned to when used. */
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' 1 will be added to the DMA counters,                                                          if '0' then the number of bytes in the dma                                                          transfer will be added to the count register. */
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Mode for DMA. */
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
comment|/**< Nosnoop For DMA. */
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode for DMA. */
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
comment|/**< Select PCI_POINTER MODE to be used.                                                          0=DPTR format 1 is used                                                            use register values for address and pointer                                                            values for ES, NS, RO                                                          1=DPTR format 0 is used                                                            use pointer values for address and register                                                            values for ES, NS, RO */
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_47
range|:
literal|14
decl_stmt|;
name|uint64_t
name|dma_enb
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_hp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|commit_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ffp_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_en1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
struct|struct
name|cvmx_dpi_dma_control_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
name|uint64_t
name|commit_mode
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine Commit Mode                                                           When COMMIT_MODE=0, DPI considers an instruction                                                          complete when the HW internally generates the                                                          final write for the current instruction.                                                           When COMMIT_MODE=1, DPI additionally waits for                                                          the final write to reach the interface coherency                                                          point to declare the instructions complete.                                                           Please note: when COMMIT_MODE == 0, DPI may not                                                          follow the HRM ordering rules.                                                           DPI hardware performance may be better with                                                          COMMIT_MODE == 0 than with COMMIT_MODE == 1 due                                                          to the relaxed ordering rules.                                                           If the HRM ordering rules are required, set                                                          COMMIT_MODE == 1. */
name|uint64_t
name|pkt_hp
range|:
literal|1
decl_stmt|;
comment|/**< High-Priority Mode for Packet Interface.                                                          Engine 5 will be serviced more frequently to                                                          deliver more bandwidth to packet interface.                                                          When PKT_EN=0, then PKT_HP=0. */
name|uint64_t
name|pkt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables the packet interface.                                                          When the packet interface is enabled, engine 5                                                          is used for packets and is not available for DMA.                                                          When PKT_EN=1, then DMA_ENB<5>=0.                                                          When PKT_EN=0, then PKT_HP=0. */
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dma_enb
range|:
literal|6
decl_stmt|;
comment|/**< DMA engine enable. Enables the operation of the                                                          DMA engine. After being enabled an engine should                                                          not be disabled while processing instructions.                                                          When PKT_EN=1, then DMA_ENB<5>=0. */
name|uint64_t
name|reserved_34_47
range|:
literal|14
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' and the DPI is in the mode to write                                                          0 to L2C memory when a DMA is done, the address                                                          to be written to will be treated as a Little                                                          Endian address. */
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1', DPI will send a value in the DWB                                                          field for a free page operation for the memory                                                          that contained the data. */
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
comment|/**< When Instruction Chunks for DMA operations are                                                          freed this value is used for the DWB field of the                                                          operation. */
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
comment|/**< The FPA queue that the instruction-chunk page will                                                          be returned to when used. */
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' 1 will be added to the DMA counters,                                                          if '0' then the number of bytes in the dma                                                          transfer will be added to the count register. */
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed Ordering Mode for DMA. */
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
comment|/**< Nosnoop For DMA. */
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
comment|/**< Endian Swap Mode for DMA. */
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
comment|/**< Select PCI_POINTER MODE to be used.                                                          0=DPTR format 1 is used                                                            use register values for address and pointer                                                            values for ES, NS, RO                                                          1=DPTR format 0 is used                                                            use pointer values for address and register                                                            values for ES, NS, RO */
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
name|uint64_t
name|o_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_es
range|:
literal|2
decl_stmt|;
name|uint64_t
name|o_ns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_add1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpa_que
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwb_ichk
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dwb_denb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|b0_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_47
range|:
literal|14
decl_stmt|;
name|uint64_t
name|dma_enb
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_hp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|commit_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dpi_dma_control_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_control_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_control_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dma_control_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dma_control
name|cvmx_dpi_dma_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma_eng#_en  */
end_comment

begin_union
union|union
name|cvmx_dpi_dma_engx_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dma_engx_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|qen
range|:
literal|8
decl_stmt|;
comment|/**< Controls which logical instruction queues can be                                                          serviced by the DMA engine. Setting QEN==0                                                          effectively disables the engine.                                                          When DPI_DMA_CONTROL[PKT_EN] = 1, then                                                          DPI_DMA_ENG5_EN[QEN] must be zero.                                                          When DPI_DMA_CONTROL[PKT_EN1] = 1, then                                                          DPI_DMA_ENG4_EN[QEN] must be zero. */
else|#
directive|else
name|uint64_t
name|qen
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dma_engx_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_engx_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_engx_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dma_engx_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_engx_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_engx_en_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_dma_engx_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dma_engx_en
name|cvmx_dpi_dma_engx_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_dma_pp#_cnt  *  * DPI_DMA_PP[0..3]_CNT  = DMA per PP Instr Done Counter  *  * When DMA Instruction Completion Interrupt Mode DPI_DMA_CONTROL.DICI_MODE is enabled, every dma instruction  * that has the WQP=0 and a PTR value of 1..4 will incremrement DPI_DMA_PPx_CNT value-1 counter.  * Instructions with WQP=0 and PTR values higher then 0x3F will still send a zero byte write.  * Hardware reserves that values 5..63 for future use and will treat them as a PTR of 0 and do nothing.  */
end_comment

begin_union
union|union
name|cvmx_dpi_dma_ppx_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_dma_ppx_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Counter incremented according to conditions                                                          described above and decremented by values written                                                          to this field.  A CNT of non zero, will cause                                                          an interrupt in the CIU_SUM1_PPX_IPX register */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_dma_ppx_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_ppx_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_dma_ppx_cnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_dma_ppx_cnt
name|cvmx_dpi_dma_ppx_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_eng#_buf  *  * Notes:  * The total amount of storage allocated to the 6 DPI DMA engines (via DPI_ENG*_BUF[BLKS]) must not exceed 8KB.  *  */
end_comment

begin_union
union|union
name|cvmx_dpi_engx_buf
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_engx_buf_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|compblks
range|:
literal|5
decl_stmt|;
comment|/**< Computed engine block size */
name|uint64_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
name|uint64_t
name|base
range|:
literal|5
decl_stmt|;
comment|/**< The base address in 512B blocks of the engine fifo */
name|uint64_t
name|blks
range|:
literal|4
decl_stmt|;
comment|/**< The size of the engine fifo                                                          Legal values are 0-10.                                                          0  = Engine is disabled                                                          1  = 0.5KB buffer                                                          2  = 1.0KB buffer                                                          3  = 1.5KB buffer                                                          4  = 2.0KB buffer                                                          5  = 2.5KB buffer                                                          6  = 3.0KB buffer                                                          7  = 3.5KB buffer                                                          8  = 4.0KB buffer                                                          9  = 6.0KB buffer                                                          10 = 8.0KB buffer */
else|#
directive|else
name|uint64_t
name|blks
range|:
literal|4
decl_stmt|;
name|uint64_t
name|base
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
name|uint64_t
name|compblks
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_engx_buf_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_dpi_engx_buf_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|base
range|:
literal|4
decl_stmt|;
comment|/**< The base address in 512B blocks of the engine fifo */
name|uint64_t
name|blks
range|:
literal|4
decl_stmt|;
comment|/**< The size in 512B blocks of the engine fifo                                                          Legal values are 0-8.                                                          0 = Engine is disabled                                                          1 = 0.5KB buffer                                                          2 = 1.0KB buffer                                                          3 = 1.5KB buffer                                                          4 = 2.0KB buffer                                                          5 = 2.5KB buffer                                                          6 = 3.0KB buffer                                                          7 = 3.5KB buffer                                                          8 = 4.0KB buffer */
else|#
directive|else
name|uint64_t
name|blks
range|:
literal|4
decl_stmt|;
name|uint64_t
name|base
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dpi_engx_buf_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_engx_buf_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_engx_buf_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_engx_buf_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_engx_buf_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_engx_buf
name|cvmx_dpi_engx_buf_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_info_reg  */
end_comment

begin_union
union|union
name|cvmx_dpi_info_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_info_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ffp
range|:
literal|4
decl_stmt|;
comment|/**< Force Forward Progress Indicator */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
comment|/**< NCB Register Access                                                          This interrupt will fire in normal operation                                                          when SW reads a DPI register through the NCB                                                          interface. */
name|uint64_t
name|rsl
range|:
literal|1
decl_stmt|;
comment|/**< RSL Register Access                                                          This interrupt will fire in normal operation                                                          when SW reads a DPI register through the RSL                                                          interface. */
else|#
directive|else
name|uint64_t
name|rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ffp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_info_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_info_reg_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_dpi_info_reg_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
comment|/**< NCB Register Access                                                          This interrupt will fire in normal operation                                                          when SW reads a DPI register through the NCB                                                          interface. */
name|uint64_t
name|rsl
range|:
literal|1
decl_stmt|;
comment|/**< RSL Register Access                                                          This interrupt will fire in normal operation                                                          when SW reads a DPI register through the RSL                                                          interface. */
else|#
directive|else
name|uint64_t
name|rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dpi_info_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_info_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_info_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_info_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_info_reg
name|cvmx_dpi_info_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_int_en  */
end_comment

begin_union
union|union
name|cvmx_dpi_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|sprt3_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt2_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction unexpected fill */
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with NULL pointer */
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with bad instruction */
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO underflow */
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO overflow */
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with length */
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with bad pointer */
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
comment|/**< DMAx doorbell overflow. */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
comment|/**< CSR Fifo Overflow */
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
comment|/**< NCB Decode Error */
else|#
directive|else
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_int_en_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_dpi_int_en_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction unexpected fill */
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with NULL pointer */
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with bad instruction */
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO underflow */
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO overflow */
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with length */
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with bad pointer */
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
comment|/**< DMAx doorbell overflow. */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
comment|/**< CSR Fifo Overflow */
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
comment|/**< NCB Decode Error */
else|#
directive|else
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dpi_int_en_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_int_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_int_en_cn63xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_int_en_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_int_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_int_en
name|cvmx_dpi_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_int_reg  */
end_comment

begin_union
union|union
name|cvmx_dpi_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_int_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|sprt3_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt2_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction unexpected fill                                                          Instruction fill when none outstanding. */
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with NULL pointer                                                          Next pointer was NULL. */
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with bad instruction                                                          Fetched instruction word was 0. */
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO underflow                                                          DPI tracks outstanding instructions fetches.                                                          Interrupt will fire when FIFO underflows. */
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO overflow                                                          DPI tracks outstanding instructions fetches.                                                          Interrupt will fire when FIFO overflows. */
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with length                                                          Interrupt will fire if DPI forms an instruction                                                          fetch with length of zero. */
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with bad pointer                                                          Interrupt will fire if DPI forms an instruction                                                          fetch to the NULL pointer. */
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
comment|/**< DMAx doorbell overflow.                                                          DPI has a 32-bit counter for each request's queue                                                          outstanding doorbell counts. Interrupt will fire                                                          if the count overflows. */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
comment|/**< CSR Fifo Overflow                                                          DPI can store upto 16 CSR request.  The FIFO will                                                          overflow if that number is exceeded. */
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
comment|/**< NCB Decode Error                                                          DPI received a NCB transaction on the outbound                                                          bus to the DPI deviceID, but the command was not                                                          recognized. */
else|#
directive|else
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_int_reg_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_dpi_int_reg_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction was dropped because the source or                                                           destination port was in reset.                                                          this bit is set. */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction unexpected fill                                                          Instruction fill when none outstanding. */
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with NULL pointer                                                          Next pointer was NULL. */
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction filled with bad instruction                                                          Fetched instruction word was 0. */
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO underflow                                                          DPI tracks outstanding instructions fetches.                                                          Interrupt will fire when FIFO underflows. */
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction FIFO overflow                                                          DPI tracks outstanding instructions fetches.                                                          Interrupt will fire when FIFO overflows. */
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with length                                                          Interrupt will fire if DPI forms an instruction                                                          fetch with length of zero. */
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
comment|/**< DMA instruction fetch with bad pointer                                                          Interrupt will fire if DPI forms an instruction                                                          fetch to the NULL pointer. */
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
comment|/**< DMAx doorbell overflow.                                                          DPI has a 32-bit counter for each request's queue                                                          outstanding doorbell counts. Interrupt will fire                                                          if the count overflows. */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
comment|/**< CSR Fifo Overflow                                                          DPI can store upto 16 CSR request.  The FIFO will                                                          overflow if that number is exceeded. */
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
comment|/**< NCB Decode Error                                                          DPI received a NCB transaction on the outbound                                                          bus to the DPI deviceID, but the command was not                                                          recognized. */
else|#
directive|else
name|uint64_t
name|nderr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nfovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dmadbo
range|:
literal|8
decl_stmt|;
name|uint64_t
name|req_badadr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badlen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_ovrflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_undflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_anull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_inull
range|:
literal|1
decl_stmt|;
name|uint64_t
name|req_badfil
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dpi_int_reg_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_int_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_int_reg_cn63xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_int_reg_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_int_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_int_reg
name|cvmx_dpi_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_ncb#_cfg  */
end_comment

begin_union
union|union
name|cvmx_dpi_ncbx_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_ncbx_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|molr
range|:
literal|6
decl_stmt|;
comment|/**< Max Outstanding Load Requests                                                          Limits the number of oustanding load requests on                                                          the NCB interface.  This value can range from 1                                                          to 32. Setting a value of 0 will halt all read                                                          traffic to the NCB interface.  There are no                                                          restrictions on when this value can be changed. */
else|#
directive|else
name|uint64_t
name|molr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_ncbx_cfg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_ncbx_cfg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_ncbx_cfg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_ncbx_cfg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_ncbx_cfg
name|cvmx_dpi_ncbx_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_pint_info  *  * DPI_PINT_INFO = DPI Packet Interrupt Info  *  * DPI Packet Interrupt Info.  */
end_comment

begin_union
union|union
name|cvmx_dpi_pint_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_pint_info_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|iinfo
range|:
literal|6
decl_stmt|;
comment|/**< Packet Instruction Doorbell count overflow info */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sinfo
range|:
literal|6
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell count overflow info */
else|#
directive|else
name|uint64_t
name|sinfo
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iinfo
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_pint_info_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_pint_info_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_pint_info_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_pint_info_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_pint_info_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_pint_info_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_pint_info_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_pint_info
name|cvmx_dpi_pint_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_pkt_err_rsp  */
end_comment

begin_union
union|union
name|cvmx_dpi_pkt_err_rsp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_pkt_err_rsp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|pkterr
range|:
literal|1
decl_stmt|;
comment|/**< Indicates that an ErrorResponse was received from                                                          the I/O subsystem. */
else|#
directive|else
name|uint64_t
name|pkterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_pkt_err_rsp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_pkt_err_rsp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_pkt_err_rsp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_pkt_err_rsp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_pkt_err_rsp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_pkt_err_rsp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_pkt_err_rsp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_pkt_err_rsp
name|cvmx_dpi_pkt_err_rsp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_req_err_rsp  */
end_comment

begin_union
union|union
name|cvmx_dpi_req_err_rsp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_req_err_rsp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|qerr
range|:
literal|8
decl_stmt|;
comment|/**< Indicates which instruction queue received an                                                          ErrorResponse from the I/O subsystem.                                                          SW must clear the bit before the the cooresponding                                                          instruction queue will continue processing                                                          instructions if DPI_REQ_ERR_RSP_EN[EN] is set. */
else|#
directive|else
name|uint64_t
name|qerr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_req_err_rsp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_req_err_rsp
name|cvmx_dpi_req_err_rsp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_req_err_rsp_en  */
end_comment

begin_union
union|union
name|cvmx_dpi_req_err_rsp_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_req_err_rsp_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
comment|/**< Indicates which instruction queues should stop                                                          dispatching instructions when an  ErrorResponse                                                          is received from the I/O subsystem. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_req_err_rsp_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_en_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rsp_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_req_err_rsp_en
name|cvmx_dpi_req_err_rsp_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_req_err_rst  */
end_comment

begin_union
union|union
name|cvmx_dpi_req_err_rst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_req_err_rst_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|qerr
range|:
literal|8
decl_stmt|;
comment|/**< Indicates which instruction queue dropped an                                                          instruction because the source or destination                                                          was in reset.                                                          SW must clear the bit before the the cooresponding                                                          instruction queue will continue processing                                                          instructions if DPI_REQ_ERR_RST_EN[EN] is set. */
else|#
directive|else
name|uint64_t
name|qerr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_req_err_rst_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_req_err_rst
name|cvmx_dpi_req_err_rst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_req_err_rst_en  */
end_comment

begin_union
union|union
name|cvmx_dpi_req_err_rst_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_req_err_rst_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
comment|/**< Indicates which instruction queues should stop                                                          dispatching instructions when an instruction                                                          is dropped because the source or destination port                                                          is in reset. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_req_err_rst_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_en_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_rst_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_req_err_rst_en
name|cvmx_dpi_req_err_rst_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_req_err_skip_comp  */
end_comment

begin_union
union|union
name|cvmx_dpi_req_err_skip_comp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_req_err_skip_comp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|en_rst
range|:
literal|8
decl_stmt|;
comment|/**< Indicates which instruction queue should skip the                                                          completion  phase once an port reset is                                                          detected as indicated by DPI_REQ_ERR_RST.  All                                                          completions to the effected instruction queue                                                          will be skipped as long as                                                          DPI_REQ_ERR_RSP[QERR<ique>]& EN_RSP<ique> or                                                          DPI_REQ_ERR_RST[QERR<ique>]& EN_RST<ique> are                                                          set. */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|en_rsp
range|:
literal|8
decl_stmt|;
comment|/**< Indicates which instruction queue should skip the                                                          completion  phase once an ErrorResponse is                                                          detected as indicated by DPI_REQ_ERR_RSP.  All                                                          completions to the effected instruction queue                                                          will be skipped as long as                                                          DPI_REQ_ERR_RSP[QERR<ique>]& EN_RSP<ique> or                                                          DPI_REQ_ERR_RST[QERR<ique>]& EN_RST<ique> are                                                          set. */
else|#
directive|else
name|uint64_t
name|en_rsp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|en_rst
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_req_err_skip_comp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_skip_comp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_skip_comp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_skip_comp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_err_skip_comp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_req_err_skip_comp
name|cvmx_dpi_req_err_skip_comp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_req_gbl_en  */
end_comment

begin_union
union|union
name|cvmx_dpi_req_gbl_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_req_gbl_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|qen
range|:
literal|8
decl_stmt|;
comment|/**< Indicates which instruction queues are enabled and                                                          can dispatch instructions to a requesting engine. */
else|#
directive|else
name|uint64_t
name|qen
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_req_gbl_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_gbl_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_gbl_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_gbl_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_gbl_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_req_gbl_en_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_req_gbl_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_req_gbl_en
name|cvmx_dpi_req_gbl_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_sli_prt#_cfg  *  * DPI_SLI_PRTx_CFG = DPI SLI Port Configuration  *  * Configures the Max Read Request Size, Max Paylod Size, and Max Number of SLI Tags in use  */
end_comment

begin_union
union|union
name|cvmx_dpi_sli_prtx_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_sli_prtx_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|halt
range|:
literal|1
decl_stmt|;
comment|/**< When set, HALT indicates that the MAC has detected                                                          a reset condition. No further instructions that                                                          reference the MAC from any instruction Q will be                                                          issued until the MAC comes out of reset and HALT                                                          is cleared in SLI_CTL_PORTx[DIS_PORT]. */
name|uint64_t
name|qlm_cfg
range|:
literal|4
decl_stmt|;
comment|/**< QLM_CFG is a function of MIO_QLMx_CFG[QLM_CFG]                                                          QLM_CFG may contain values that are not normally                                                          used for DMA and/or packet operations.                                                          QLM_CFG does not indicate if a port is disabled.                                                          MIO_QLMx_CFG can be used for more complete QLM                                                          configuration information.                                                          0000 = MAC is PCIe 1x4 (QLM) or 1x2 (DLM)                                                          0001 = MAC is PCIe 2x1 (DLM only)                                                          0010 = MAC is SGMII                                                          0011 = MAC is XAUI                                                          all other encodings are RESERVED */
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rd_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Mode                                                          0=Exact Read Mode                                                            If the port is a PCIe port, the HW reads on a                                                            4B granularity.  In this mode, the HW may break                                                            a given read into 3 operations to satisify                                                            PCIe rules.                                                            If the port is a SRIO port, the HW follows the                                                            SRIO read rules from the SRIO specification and                                                             only issues 32*n, 16, and 8 byte  operations                                                             on the SRIO bus.                                                          1=Block Mode                                                            The HW will read more data than requested in                                                            order to minimize the number of operations                                                            necessary to complete the operation.                                                            The memory region must be memory like. */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|molr
range|:
literal|6
decl_stmt|;
comment|/**< Max Outstanding Load Requests                                                          Limits the number of oustanding load requests on                                                          the port by restricting the number of tags                                                          used by the SLI to track load responses.  This                                                          value can range from 1 to 32 depending on the MAC                                                          type and number of lanes.                                                          MAC == PCIe:           Max is 32                                                          MAC == sRio / 4 lanes: Max is 32                                                          MAC == sRio / 2 lanes: Max is 16                                                          MAC == sRio / 1 lane:  Max is  8                                                          Reset value is computed based on the MAC config.                                                          Setting MOLR to a value of 0 will halt all read                                                          traffic to the port.  There are no restrictions                                                          on when this value can be changed. */
name|uint64_t
name|mps_lim
range|:
literal|1
decl_stmt|;
comment|/**< MAC memory space write requests cannot cross the                                                          (naturally-aligned) MPS boundary.                                                          When clear, DPI is allowed to issue a MAC memory                                                          space read that crosses the naturally-aligned                                                          boundary of size defined by MPS. (DPI will still                                                          only cross the boundary when it would eliminate a                                                          write by doing so.)                                                          When set, DPI will never issue a MAC memory space                                                          write that crosses the naturally-aligned boundary                                                          of size defined by MPS. */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mps
range|:
literal|1
decl_stmt|;
comment|/**< Max Payload Size                                                                  0 = 128B                                                                  1 = 256B                                                          For PCIe MACs, this MPS size must not exceed                                                                the size selected by PCIE*_CFG030[MPS].                                                          For sRIO MACs, all MPS values are allowed. */
name|uint64_t
name|mrrs_lim
range|:
literal|1
decl_stmt|;
comment|/**< MAC memory space read requests cannot cross the                                                          (naturally-aligned) MRRS boundary.                                                          When clear, DPI is allowed to issue a MAC memory                                                          space read that crosses the naturally-aligned                                                          boundary of size defined by MRRS. (DPI will still                                                          only cross the boundary when it would eliminate a                                                          read by doing so.)                                                          When set, DPI will never issue a MAC memory space                                                          read that crosses the naturally-aligned boundary                                                          of size defined by MRRS. */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrrs
range|:
literal|2
decl_stmt|;
comment|/**< Max Read Request Size                                                                  0 = 128B                                                                  1 = 256B                                                                  2 = 512B                                                                  3 = 1024B                                                          For PCIe MACs, this MRRS size must not exceed                                                                the size selected by PCIE*_CFG030[MRRS].                                                          For sRIO MACs, this MRRS size must be<= 256B. */
else|#
directive|else
name|uint64_t
name|mrrs
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrrs_lim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mps
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mps_lim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|molr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rd_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|4
decl_stmt|;
name|uint64_t
name|halt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_sli_prtx_cfg_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_dpi_sli_prtx_cfg_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|halt
range|:
literal|1
decl_stmt|;
comment|/**< When set, HALT indicates that the MAC has detected                                                          a reset condition. No further instructions that                                                          reference the MAC from any instruction Q will be                                                          issued until the MAC comes out of reset and HALT                                                          is cleared in SLI_CTL_PORTx[DIS_PORT]. */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|1
decl_stmt|;
comment|/**< Read only copy of the QLM CFG pin                                                          Since QLM_CFG is simply a copy of the QLM CFG                                                          pins, it may reflect values that are not normal                                                          for DMA or packet operations. QLM_CFG does not                                                          indicate if a port is disabled.                                                          0= MAC is PCIe                                                          1= MAC is SRIO */
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rd_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Mode                                                          0=Exact Read Mode                                                            If the port is a PCIe port, the HW reads on a                                                            4B granularity.  In this mode, the HW may break                                                            a given read into 3 operations to satisify                                                            PCIe rules.                                                            If the port is a SRIO port, the HW follows the                                                            SRIO read rules from the SRIO specification and                                                             only issues 32*n, 16, and 8 byte  operations                                                             on the SRIO bus.                                                          1=Block Mode                                                            The HW will read more data than requested in                                                            order to minimize the number of operations                                                            necessary to complete the operation.                                                            The memory region must be memory like. */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|molr
range|:
literal|6
decl_stmt|;
comment|/**< Max Outstanding Load Requests                                                          Limits the number of oustanding load requests on                                                          the port by restricting the number of tags                                                          used by the SLI to track load responses.  This                                                          value can range from 1 to 32. Setting a value of                                                          0 will halt all read traffic to the port.  There                                                          are no restrictions on when this value                                                          can be changed. */
name|uint64_t
name|mps_lim
range|:
literal|1
decl_stmt|;
comment|/**< MAC memory space write requests cannot cross the                                                          (naturally-aligned) MPS boundary.                                                          When clear, DPI is allowed to issue a MAC memory                                                          space read that crosses the naturally-aligned                                                          boundary of size defined by MPS. (DPI will still                                                          only cross the boundary when it would eliminate a                                                          write by doing so.)                                                          When set, DPI will never issue a MAC memory space                                                          write that crosses the naturally-aligned boundary                                                          of size defined by MPS. */
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mps
range|:
literal|1
decl_stmt|;
comment|/**< Max Payload Size                                                                  0 = 128B                                                                  1 = 256B                                                          For PCIe MACs, this MPS size must not exceed                                                                the size selected by PCIE*_CFG030[MPS].                                                          For sRIO MACs, all MPS values are allowed. */
name|uint64_t
name|mrrs_lim
range|:
literal|1
decl_stmt|;
comment|/**< MAC memory space read requests cannot cross the                                                          (naturally-aligned) MRRS boundary.                                                          When clear, DPI is allowed to issue a MAC memory                                                          space read that crosses the naturally-aligned                                                          boundary of size defined by MRRS. (DPI will still                                                          only cross the boundary when it would eliminate a                                                          read by doing so.)                                                          When set, DPI will never issue a MAC memory space                                                          read that crosses the naturally-aligned boundary                                                          of size defined by MRRS. */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrrs
range|:
literal|2
decl_stmt|;
comment|/**< Max Read Request Size                                                                  0 = 128B                                                                  1 = 256B                                                                  2 = 512B                                                                  3 = 1024B                                                          For PCIe MACs, this MRRS size must not exceed                                                                the size selected by PCIE*_CFG030[MRRS].                                                          For sRIO MACs, this MRRS size must be<= 256B. */
else|#
directive|else
name|uint64_t
name|mrrs
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrrs_lim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mps
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mps_lim
range|:
literal|1
decl_stmt|;
name|uint64_t
name|molr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rd_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|halt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dpi_sli_prtx_cfg_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_cfg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_cfg_cn63xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_cfg_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_cfg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_sli_prtx_cfg
name|cvmx_dpi_sli_prtx_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_sli_prt#_err  *  * DPI_SLI_PRTx_ERR = DPI SLI Port Error Info  *  * Logs the Address and Request Queue associated with the reported SLI error response  */
end_comment

begin_union
union|union
name|cvmx_dpi_sli_prtx_err
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_sli_prtx_err_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|addr
range|:
literal|61
decl_stmt|;
comment|/**< Address of the failed load request.                                                          Address is locked along with the                                                          DPI_SLI_PRTx_ERR_INFO register.                                                          See the DPI_SLI_PRTx_ERR_INFO[LOCK] description                                                          for further information. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_sli_prtx_err_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_sli_prtx_err
name|cvmx_dpi_sli_prtx_err_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dpi_sli_prt#_err_info  *  * DPI_SLI_PRTx_ERR_INFO = DPI SLI Port Error Info  *  * Logs the Address and Request Queue associated with the reported SLI error response  */
end_comment

begin_union
union|union
name|cvmx_dpi_sli_prtx_err_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dpi_sli_prtx_err_info_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|lock
range|:
literal|1
decl_stmt|;
comment|/**< DPI_SLI_PRTx_ERR and DPI_SLI_PRTx_ERR_INFO have                                                          captured and locked contents.                                                          When Octeon first detects an ErrorResponse, the                                                          TYPE, REQQ, and ADDR of the error is saved and an                                                          internal lock state is set so the data associated                                                          with the initial error is perserved.                                                          Subsequent ErrorResponses will optionally raise                                                          an interrupt, but will not modify the TYPE, REQQ,                                                          or ADDR fields until the internal lock state is                                                          cleared.                                                          SW can clear the internal lock state by writting                                                          a '1' to the appropriate bit in either                                                          DPI_REQ_ERR_RSP or DPI_PKT_ERR_RSP depending on                                                          the TYPE field.                                                          Once the internal lock state is cleared,                                                          the next ErrorResponse will set the TYPE, REQQ,                                                          and ADDR for the new transaction. */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
comment|/**< Type of transaction that caused the ErrorResponse.                                                          0=DMA Instruction                                                          1=PKT Instruction */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reqq
range|:
literal|3
decl_stmt|;
comment|/**< Request queue that made the failed load request. */
else|#
directive|else
name|uint64_t
name|reqq
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|type
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lock
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dpi_sli_prtx_err_info_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_info_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_info_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_info_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_info_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_info_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_dpi_sli_prtx_err_info_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dpi_sli_prtx_err_info
name|cvmx_dpi_sli_prtx_err_info_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

