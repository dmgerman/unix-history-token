begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pcsx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pcsx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PCSX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PCSX_DEFS_H__
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_ANX_ADV_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_ANX_ADV_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_ANX_EXT_ST_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001028ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001028ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001028ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001028ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_ANX_EXT_ST_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001028ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_ANX_LP_ABIL_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_ANX_LP_ABIL_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001018ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_ANX_RESULTS_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_ANX_RESULTS_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_INTX_EN_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_INTX_EN_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001088ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_INTX_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_INTX_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_LINKX_TIMER_COUNT_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_LINKX_TIMER_COUNT_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_LOG_ANLX_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_LOG_ANLX_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001090ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_MISCX_CTL_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001078ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001078ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001078ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001078ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_MISCX_CTL_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001078ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_MRX_CONTROL_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_MRX_CONTROL_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_MRX_STATUS_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_MRX_STATUS_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001008ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_RXX_STATES_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_RXX_STATES_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001058ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_RXX_SYNC_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_RXX_SYNC_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001050ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_SGMX_AN_ADV_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_SGMX_AN_ADV_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001068ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_SGMX_LP_ADV_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001070ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001070ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001070ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001070ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_SGMX_LP_ADV_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001070ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_TXX_STATES_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001060ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001060ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001060ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001060ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_TXX_STATES_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001060ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSX_TX_RXX_POLARITY_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CNF71XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x4000ull
operator|)
operator|*
literal|1024
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSX_TX_RXX_POLARITY_REG (%lu, %lu) not supported on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0001048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x20000ull
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_comment
comment|/**  * cvmx_pcs#_an#_adv_reg  *  * Bits [15:9] in the Status Register indicate ability to operate as per those signalling specification,  * when misc ctl reg MAC_PHY bit is set to MAC mode. Bits [15:9] will all, always read 1'b0, indicating  * that the chip cannot operate in the corresponding modes.  *  * Bit [4] RM_FLT is a don't care when the selected mode is SGMII.  *  *  *  * PCS_AN_ADV_REG = AN Advertisement Register4  */
end_comment

begin_union
union|union
name|cvmx_pcsx_anx_adv_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_anx_adv_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|np
range|:
literal|1
decl_stmt|;
comment|/**< Always 0, no next page capability supported */
name|uint64_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rem_flt
range|:
literal|2
decl_stmt|;
comment|/**< [<13>,<12>]                                                          0    0  Link OK  XMIT=DATA                                                          0    1  Link failure (loss of sync, XMIT!= DATA)                                                          1    0  local device Offline                                                          1    1  AN Error failure to complete AN                                                                  AN Error is set if resolution function                                                                  precludes operation with link partner */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|2
decl_stmt|;
comment|/**< [<8>,<7>] Pause frame flow capability across link                                                                   Exchanged during Auto Negotiation                                                          0    0  No Pause                                                          0    1  Symmetric pause                                                          1    0  Asymmetric Pause                                                          1    1  Both symm and asymm pause to local device */
name|uint64_t
name|hfd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means local device Half Duplex capable */
name|uint64_t
name|fd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means local device Full Duplex capable */
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|fd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hfd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rem_flt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|np
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_adv_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_anx_adv_reg
name|cvmx_pcsx_anx_adv_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_an#_ext_st_reg  *  * NOTE:  * an_results_reg is don't care when AN_OVRD is set to 1. If AN_OVRD=0 and AN_CPT=1  * the an_results_reg is valid.  *  *  * PCS_AN_EXT_ST_REG = AN Extended Status Register15  * as per IEEE802.3 Clause 22  */
end_comment

begin_union
union|union
name|cvmx_pcsx_anx_ext_st_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_anx_ext_st_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|thou_xfd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means PHY is 1000BASE-X Full Dup capable */
name|uint64_t
name|thou_xhd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means PHY is 1000BASE-X Half Dup capable */
name|uint64_t
name|thou_tfd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means PHY is 1000BASE-T Full Dup capable */
name|uint64_t
name|thou_thd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means PHY is 1000BASE-T Half Dup capable */
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
name|uint64_t
name|thou_thd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|thou_tfd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|thou_xhd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|thou_xfd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_ext_st_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_anx_ext_st_reg
name|cvmx_pcsx_anx_ext_st_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_an#_lp_abil_reg  *  * PCS_AN_LP_ABIL_REG = AN link Partner Ability Register5  * as per IEEE802.3 Clause 37  */
end_comment

begin_union
union|union
name|cvmx_pcsx_anx_lp_abil_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|np
range|:
literal|1
decl_stmt|;
comment|/**< 1=lp next page capable, 0=lp not next page capable */
name|uint64_t
name|ack
range|:
literal|1
decl_stmt|;
comment|/**< 1=Acknowledgement received */
name|uint64_t
name|rem_flt
range|:
literal|2
decl_stmt|;
comment|/**< [<13>,<12>] Link Partner's link status                                                          0    0  Link OK                                                          0    1  Offline                                                          1    0  Link failure                                                          1    1  AN Error */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|2
decl_stmt|;
comment|/**< [<8>,<7>] Link Partner Pause setting                                                          0    0  No Pause                                                          0    1  Symmetric pause                                                          1    0  Asymmetric Pause                                                          1    1  Both symm and asymm pause to local device */
name|uint64_t
name|hfd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means link partner Half Duplex capable */
name|uint64_t
name|fd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means link partner Full Duplex capable */
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|fd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hfd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rem_flt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ack
range|:
literal|1
decl_stmt|;
name|uint64_t
name|np
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_lp_abil_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_anx_lp_abil_reg
name|cvmx_pcsx_anx_lp_abil_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_an#_results_reg  *  * PCS_AN_RESULTS_REG = AN Results Register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_anx_results_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_anx_results_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|2
decl_stmt|;
comment|/**< [<6>,<5>] PAUSE Selection (Don't care for SGMII)                                                          0    0  Disable Pause, TX and RX                                                          0    1  Enable pause frames RX only                                                          1    0  Enable Pause frames TX only                                                          1    1  Enable pause frames TX and RX */
name|uint64_t
name|spd
range|:
literal|2
decl_stmt|;
comment|/**< [<4>,<3>] Link Speed Selection                                                          0    0  10Mb/s                                                          0    1  100Mb/s                                                          1    0  1000Mb/s                                                          1    1  NS */
name|uint64_t
name|an_cpt
range|:
literal|1
decl_stmt|;
comment|/**< 1=AN Completed, 0=AN not completed or failed */
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< 1=Full Duplex, 0=Half Duplex */
name|uint64_t
name|link_ok
range|:
literal|1
decl_stmt|;
comment|/**< 1=Link up(OK), 0=Link down */
else|#
directive|else
name|uint64_t
name|link_ok
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_cpt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_anx_results_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_anx_results_reg
name|cvmx_pcsx_anx_results_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_int#_en_reg  *  * NOTE: RXERR and TXERR conditions to be discussed with Dan before finalising  *      DBG_SYNC interrupt fires when code group synchronization state machine makes a transition from  *      SYNC_ACQUIRED_1 state to SYNC_ACQUIRED_2 state(See IEEE 802.3-2005 figure 37-9). It is an indication that a bad code group  *      was received after code group synchronizaton was achieved. This interrupt should be disabled during normal link operation.  *      Use it as a debug help feature only.  *  *  * PCS Interrupt Enable Register  */
end_comment

begin_union
union|union
name|cvmx_pcsx_intx_en_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_intx_en_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|dbg_sync_en
range|:
literal|1
decl_stmt|;
comment|/**< Code Group sync failure debug help */
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< Enable duplex mode changed interrupt */
name|uint64_t
name|sync_bad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable rx sync st machine in bad state interrupt */
name|uint64_t
name|an_bad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable AN state machine bad state interrupt */
name|uint64_t
name|rxlock_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable rx code group sync/bit lock failure interrupt */
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable rx state machine in bad state interrupt */
name|uint64_t
name|rxerr_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable RX error condition interrupt */
name|uint64_t
name|txbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable tx state machine in bad state interrupt */
name|uint64_t
name|txfifo_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable tx fifo overflow condition interrupt */
name|uint64_t
name|txfifu_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable tx fifo underflow condition intrrupt */
name|uint64_t
name|an_err_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable AN Error condition interrupt */
name|uint64_t
name|xmit_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable XMIT variable state change interrupt */
name|uint64_t
name|lnkspd_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable Link Speed has changed interrupt */
else|#
directive|else
name|uint64_t
name|lnkspd_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmit_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_err_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifu_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifo_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxlock_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_bad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sync_bad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbg_sync_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pcsx_intx_en_reg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< Enable duplex mode changed interrupt */
name|uint64_t
name|sync_bad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable rx sync st machine in bad state interrupt */
name|uint64_t
name|an_bad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable AN state machine bad state interrupt */
name|uint64_t
name|rxlock_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable rx code group sync/bit lock failure interrupt */
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable rx state machine in bad state interrupt */
name|uint64_t
name|rxerr_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable RX error condition interrupt */
name|uint64_t
name|txbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable tx state machine in bad state interrupt */
name|uint64_t
name|txfifo_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable tx fifo overflow condition interrupt */
name|uint64_t
name|txfifu_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable tx fifo underflow condition intrrupt */
name|uint64_t
name|an_err_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable AN Error condition interrupt */
name|uint64_t
name|xmit_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable XMIT variable state change interrupt */
name|uint64_t
name|lnkspd_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable Link Speed has changed interrupt */
else|#
directive|else
name|uint64_t
name|lnkspd_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmit_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_err_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifu_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifo_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxlock_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_bad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sync_bad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pcsx_intx_en_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_en_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_intx_en_reg
name|cvmx_pcsx_intx_en_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_int#_reg  *  * SGMII bit [12] is really a misnomer, it is a decode  of pi_qlm_cfg pins to indicate SGMII or 1000Base-X modes.  *  * Note: MODE bit  * When MODE=1,  1000Base-X mode is selected. Auto negotiation will follow IEEE 802.3 clause 37.  * When MODE=0,  SGMII mode is selected and the following note will apply.  * Repeat note from SGM_AN_ADV register  * NOTE: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if the MAC_PHY mode bit in misc_ctl_reg  * is set (1=PHY mode). If the bit is not set (0=MAC mode), the tx_config_reg[14] becomes ACK bit and [0] is always 1.  * All other bits in tx_config_reg sent will be 0. The PHY dictates the Auto Negotiation results.  *  * PCS Interrupt Register  */
end_comment

begin_union
union|union
name|cvmx_pcsx_intx_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_intx_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|dbg_sync
range|:
literal|1
decl_stmt|;
comment|/**< Code Group sync failure debug help */
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever Duplex mode changes on the link */
name|uint64_t
name|sync_bad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever rx sync st machine reaches a bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|an_bad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever AN st machine reaches a bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|rxlock
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever code group Sync or bit lock                                                          failure occurs                                                          Cannot fire in loopback1 mode */
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever rx st machine reaches a  bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|rxerr
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever RX receives a code group error in                                                          10 bit to 8 bit decode logic                                                          Cannot fire in loopback1 mode */
name|uint64_t
name|txbad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever tx st machine reaches a bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|txfifo
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever HW detects a TX fifo overflow                                                          condition */
name|uint64_t
name|txfifu
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever HW detects a TX fifo underflowflow                                                          condition */
name|uint64_t
name|an_err
range|:
literal|1
decl_stmt|;
comment|/**< AN Error, AN resolution function failed */
name|uint64_t
name|xmit
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever HW detects a change in the XMIT                                                          variable. XMIT variable states are IDLE, CONFIG and                                                          DATA */
name|uint64_t
name|lnkspd
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever Link Speed has changed */
else|#
directive|else
name|uint64_t
name|lnkspd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxlock
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sync_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbg_sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pcsx_intx_reg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever Duplex mode changes on the link */
name|uint64_t
name|sync_bad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever rx sync st machine reaches a bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|an_bad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever AN st machine reaches a bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|rxlock
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever code group Sync or bit lock                                                          failure occurs                                                          Cannot fire in loopback1 mode */
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever rx st machine reaches a  bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|rxerr
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever RX receives a code group error in                                                          10 bit to 8 bit decode logic                                                          Cannot fire in loopback1 mode */
name|uint64_t
name|txbad
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever tx st machine reaches a bad                                                          state. Should never be set during normal operation */
name|uint64_t
name|txfifo
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever HW detects a TX fifo overflow                                                          condition */
name|uint64_t
name|txfifu
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever HW detects a TX fifo underflowflow                                                          condition */
name|uint64_t
name|an_err
range|:
literal|1
decl_stmt|;
comment|/**< AN Error, AN resolution function failed */
name|uint64_t
name|xmit
range|:
literal|1
decl_stmt|;
comment|/**< Set whenever HW detects a change in the XMIT                                                          variable. XMIT variable states are IDLE, CONFIG and                                                          DATA */
name|uint64_t
name|lnkspd
range|:
literal|1
decl_stmt|;
comment|/**< Set by HW whenever Link Speed has changed */
else|#
directive|else
name|uint64_t
name|lnkspd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfifo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxlock
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sync_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pcsx_intx_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_intx_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_intx_reg
name|cvmx_pcsx_intx_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_link#_timer_count_reg  *  * PCS_LINK_TIMER_COUNT_REG = 1.6ms nominal link timer register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_linkx_timer_count_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|count
range|:
literal|16
decl_stmt|;
comment|/**< (core clock period times 1024) times "COUNT" should                                                          be 1.6ms(SGMII)/10ms(otherwise) which is the link                                                          timer used in auto negotiation.                                                          Reset assums a 700MHz eclk for 1.6ms link timer */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_linkx_timer_count_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_linkx_timer_count_reg
name|cvmx_pcsx_linkx_timer_count_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_log_anl#_reg  *  * PCS Logic Analyzer Register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_log_anlx_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_log_anlx_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|lafifovfl
range|:
literal|1
decl_stmt|;
comment|/**< 1=logic analyser fif overflowed during packetization                                                          Write 1 to clear this bit */
name|uint64_t
name|la_en
range|:
literal|1
decl_stmt|;
comment|/**< 1= Logic Analyzer enabled, 0=Logic Analyzer disabled */
name|uint64_t
name|pkt_sz
range|:
literal|2
decl_stmt|;
comment|/**< [<1>,<0>]  Logic Analyzer Packet Size                                                          0    0   Packet size 1k bytes                                                          0    1   Packet size 4k bytes                                                          1    0   Packet size 8k bytes                                                          1    1   Packet size 16k bytes */
else|#
directive|else
name|uint64_t
name|pkt_sz
range|:
literal|2
decl_stmt|;
name|uint64_t
name|la_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lafifovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_log_anlx_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_log_anlx_reg
name|cvmx_pcsx_log_anlx_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_misc#_ctl_reg  *  * SGMII Misc Control Register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_miscx_ctl_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_miscx_ctl_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|sgmii
range|:
literal|1
decl_stmt|;
comment|/**< 1=SGMII or 1000Base-X mode selected,                                                          0=XAUI or PCIE mode selected                                                          This bit represents pi_qlm1/3_cfg[1:0] pin status */
name|uint64_t
name|gmxeno
range|:
literal|1
decl_stmt|;
comment|/**< GMX Enable override. When set to 1, forces GMX to                                                          appear disabled. The enable/disable status of GMX                                                          is checked only at SOP of every packet. */
name|uint64_t
name|loopbck2
range|:
literal|1
decl_stmt|;
comment|/**< Sets external loopback mode to return rx data back                                                          out via tx data path. 0=no loopback, 1=loopback */
name|uint64_t
name|mac_phy
range|:
literal|1
decl_stmt|;
comment|/**< 0=MAC, 1=PHY decides the tx_config_reg value to be                                                          sent during auto negotiation.                                                          See SGMII spec ENG-46158 from CISCO */
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
comment|/**< 0=SGMII or 1= 1000 Base X */
name|uint64_t
name|an_ovrd
range|:
literal|1
decl_stmt|;
comment|/**< 0=disable, 1= enable over ride AN results                                                          Auto negotiation is allowed to happen but the                                                          results are ignored when set. Duplex and Link speed                                                          values are set from the pcs_mr_ctrl reg */
name|uint64_t
name|samp_pt
range|:
literal|7
decl_stmt|;
comment|/**< Byte# in elongated frames for 10/100Mb/s operation                                                          for data sampling on RX side in PCS.                                                          Recommended values are 0x5 for 100Mb/s operation                                                          and 0x32 for 10Mb/s operation.                                                          For 10Mb/s operaton this field should be set to a                                                          value less than 99 and greater than 0. If set out                                                          of this range a value of 50 will be used for actual                                                          sampling internally without affecting the CSR field                                                          For 100Mb/s operation this field should be set to a                                                          value less than 9 and greater than 0. If set out of                                                          this range a value of 5 will be used for actual                                                          sampling internally without affecting the CSR field */
else|#
directive|else
name|uint64_t
name|samp_pt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|an_ovrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac_phy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopbck2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gmxeno
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sgmii
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_miscx_ctl_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_miscx_ctl_reg
name|cvmx_pcsx_miscx_ctl_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_mr#_control_reg  *  * PCS_MR_CONTROL_REG = Control Register0  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_mrx_control_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_mrx_control_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< 1=SW Reset, the bit will return to 0 after pcs has                                                          been reset. Takes 32 eclk cycles to reset pcs */
name|uint64_t
name|loopbck1
range|:
literal|1
decl_stmt|;
comment|/**< 0=normal operation, 1=loopback. The loopback mode                                                          will return(loopback) tx data from GMII tx back to                                                          GMII rx interface. The loopback happens in the pcs                                                          module. Auto Negotiation will be disabled even if                                                          the AN_EN bit is set, during loopback */
name|uint64_t
name|spdlsb
range|:
literal|1
decl_stmt|;
comment|/**< See bit 6 description */
name|uint64_t
name|an_en
range|:
literal|1
decl_stmt|;
comment|/**< 1=AN Enable, 0=AN Disable */
name|uint64_t
name|pwr_dn
range|:
literal|1
decl_stmt|;
comment|/**< 1=Power Down(HW reset), 0=Normal operation */
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_an
range|:
literal|1
decl_stmt|;
comment|/**< If bit 12 is set and bit 3 of status reg is 1                                                          Auto Negotiation begins. Else,SW writes are ignored                                                          and this bit remians at 0. This bit clears itself                                                          to 0, when AN starts. */
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< 1=full duplex, 0=half duplex; effective only if AN                                                          disabled. If status register bits [15:9] and and                                                          extended status reg bits [15:12] allow only one                                                          duplex mode|, this bit will correspond to that                                                          value and any attempt to write will be ignored. */
name|uint64_t
name|coltst
range|:
literal|1
decl_stmt|;
comment|/**< 1=enable COL signal test, 0=disable test                                                          During COL test, the COL signal will reflect the                                                          GMII TX_EN signal with less than 16BT delay */
name|uint64_t
name|spdmsb
range|:
literal|1
decl_stmt|;
comment|/**< [<6>,<13>]Link Speed effective only if AN disabled                                                          0    0  10Mb/s                                                          0    1  100Mb/s                                                          1    0  1000Mb/s                                                          1    1  NS */
name|uint64_t
name|uni
range|:
literal|1
decl_stmt|;
comment|/**< Unidirectional (Std 802.3-2005, Clause 66.2)                                                          This bit will override the AN_EN bit and disable                                                          auto-negotiation variable mr_an_enable, when set                                                          Used in both 1000Base-X and SGMII modes */
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|uni
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spdmsb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coltst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_an
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwr_dn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spdlsb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopbck1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_control_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_mrx_control_reg
name|cvmx_pcsx_mrx_control_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_mr#_status_reg  *  * NOTE:  * Whenever AN_EN bit[12] is set, Auto negotiation is allowed to happen. The results  * of the auto negotiation process set the fields in the AN_RESULTS reg. When AN_EN is not set,  * AN_RESULTS reg is don't care. The effective SPD, DUP etc.. get their values  * from the pcs_mr_ctrl reg.  *  *  PCS_MR_STATUS_REG = Status Register1  */
end_comment

begin_union
union|union
name|cvmx_pcsx_mrx_status_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_mrx_status_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|hun_t4
range|:
literal|1
decl_stmt|;
comment|/**< 1 means 100Base-T4 capable */
name|uint64_t
name|hun_xfd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means 100Base-X Full Duplex */
name|uint64_t
name|hun_xhd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means 100Base-X Half Duplex */
name|uint64_t
name|ten_fd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means 10Mb/s Full Duplex */
name|uint64_t
name|ten_hd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means 10Mb/s Half Duplex */
name|uint64_t
name|hun_t2fd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means 100Base-T2 Full Duplex */
name|uint64_t
name|hun_t2hd
range|:
literal|1
decl_stmt|;
comment|/**< 1 means 100Base-T2 Half Duplex */
name|uint64_t
name|ext_st
range|:
literal|1
decl_stmt|;
comment|/**< 1 means extended status info in reg15 */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prb_sup
range|:
literal|1
decl_stmt|;
comment|/**< 1 means able to work without preamble bytes at the                                                          beginning of frames. 0 means not able to accept                                                          frames without preamble bytes preceding them. */
name|uint64_t
name|an_cpt
range|:
literal|1
decl_stmt|;
comment|/**< 1 means Auto Negotiation is complete and the                                                          contents of the an_results_reg are valid. */
name|uint64_t
name|rm_flt
range|:
literal|1
decl_stmt|;
comment|/**< Set to 1 when remote flt condition occurs. This bit                                                          implements a latching Hi behavior. It is cleared by                                                          SW read of this reg or when reset bit [15] in                                                          Control Reg is asserted.                                                          See an adv reg[13:12] for flt conditions */
name|uint64_t
name|an_abil
range|:
literal|1
decl_stmt|;
comment|/**< 1 means Auto Negotiation capable */
name|uint64_t
name|lnk_st
range|:
literal|1
decl_stmt|;
comment|/**< 1=link up, 0=link down. Set during AN process                                                          Set whenever XMIT=DATA. Latching Lo behavior when                                                          link goes down. Link down value of the bit stays                                                          low until SW reads the reg. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|extnd
range|:
literal|1
decl_stmt|;
comment|/**< Always 0, no extended capability regs present */
else|#
directive|else
name|uint64_t
name|extnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_st
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_abil
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rm_flt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|an_cpt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prb_sup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_st
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hun_t2hd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hun_t2fd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ten_hd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ten_fd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hun_xhd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hun_xfd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hun_t4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_mrx_status_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_mrx_status_reg
name|cvmx_pcsx_mrx_status_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_rx#_states_reg  *  * PCS_RX_STATES_REG = RX State Machines states register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_rxx_states_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_rxx_states_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|rx_bad
range|:
literal|1
decl_stmt|;
comment|/**< Receive state machine in an illegal state */
name|uint64_t
name|rx_st
range|:
literal|5
decl_stmt|;
comment|/**< Receive state machine state */
name|uint64_t
name|sync_bad
range|:
literal|1
decl_stmt|;
comment|/**< Receive synchronization SM in an illegal state */
name|uint64_t
name|sync
range|:
literal|4
decl_stmt|;
comment|/**< Receive synchronization SM state */
name|uint64_t
name|an_bad
range|:
literal|1
decl_stmt|;
comment|/**< Auto Negotiation state machine in an illegal state */
name|uint64_t
name|an_st
range|:
literal|4
decl_stmt|;
comment|/**< Auto Negotiation state machine state */
else|#
directive|else
name|uint64_t
name|an_st
range|:
literal|4
decl_stmt|;
name|uint64_t
name|an_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sync
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sync_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_st
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rx_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_states_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_rxx_states_reg
name|cvmx_pcsx_rxx_states_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_rx#_sync_reg  *  * Note:  * r_tx_rx_polarity_reg bit [2] will show correct polarity needed on the link receive path after code grp synchronization is achieved.  *  *  *  PCS_RX_SYNC_REG = Code Group synchronization reg  */
end_comment

begin_union
union|union
name|cvmx_pcsx_rxx_sync_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_rxx_sync_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|sync
range|:
literal|1
decl_stmt|;
comment|/**< 1 means code group synchronization achieved */
name|uint64_t
name|bit_lock
range|:
literal|1
decl_stmt|;
comment|/**< 1 means bit lock achieved */
else|#
directive|else
name|uint64_t
name|bit_lock
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_rxx_sync_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_rxx_sync_reg
name|cvmx_pcsx_rxx_sync_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_sgm#_an_adv_reg  *  * SGMII AN Advertisement Register (sent out as tx_config_reg)  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_sgmx_an_adv_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|link
range|:
literal|1
decl_stmt|;
comment|/**< Link status 1 Link Up, 0 Link Down */
name|uint64_t
name|ack
range|:
literal|1
decl_stmt|;
comment|/**< Auto negotiation ack */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< Duplex mode 1=full duplex, 0=half duplex */
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
comment|/**< Link Speed                                                          0    0  10Mb/s                                                          0    1  100Mb/s                                                          1    0  1000Mb/s                                                          1    1  NS */
name|uint64_t
name|reserved_1_9
range|:
literal|9
decl_stmt|;
name|uint64_t
name|one
range|:
literal|1
decl_stmt|;
comment|/**< Always set to match tx_config_reg<0> */
else|#
directive|else
name|uint64_t
name|one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_9
range|:
literal|9
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ack
range|:
literal|1
decl_stmt|;
name|uint64_t
name|link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_an_adv_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_sgmx_an_adv_reg
name|cvmx_pcsx_sgmx_an_adv_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_sgm#_lp_adv_reg  *  * NOTE: The SGMII AN Advertisement Register above will be sent during Auto Negotiation if the MAC_PHY mode bit in misc_ctl_reg  * is set (1=PHY mode). If the bit is not set (0=MAC mode), the tx_config_reg[14] becomes ACK bit and [0] is always 1.  * All other bits in tx_config_reg sent will be 0. The PHY dictates the Auto Negotiation results.  *  * SGMII LP Advertisement Register (received as rx_config_reg)  */
end_comment

begin_union
union|union
name|cvmx_pcsx_sgmx_lp_adv_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|link
range|:
literal|1
decl_stmt|;
comment|/**< Link status 1 Link Up, 0 Link Down */
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
comment|/**< Duplex mode 1=full duplex, 0=half duplex */
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
comment|/**< Link Speed                                                          0    0  10Mb/s                                                          0    1  100Mb/s                                                          1    0  1000Mb/s                                                          1    1  NS */
name|uint64_t
name|reserved_1_9
range|:
literal|9
decl_stmt|;
name|uint64_t
name|one
range|:
literal|1
decl_stmt|;
comment|/**< Always set to match tx_config_reg<0> */
else|#
directive|else
name|uint64_t
name|one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_9
range|:
literal|9
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dup
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_sgmx_lp_adv_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_sgmx_lp_adv_reg
name|cvmx_pcsx_sgmx_lp_adv_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_tx#_states_reg  *  * PCS_TX_STATES_REG = TX State Machines states register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_txx_states_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_txx_states_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|xmit
range|:
literal|2
decl_stmt|;
comment|/**< 0=undefined, 1=config, 2=idle, 3=data */
name|uint64_t
name|tx_bad
range|:
literal|1
decl_stmt|;
comment|/**< Xmit state machine in a bad state */
name|uint64_t
name|ord_st
range|:
literal|4
decl_stmt|;
comment|/**< Xmit ordered set state machine state */
else|#
directive|else
name|uint64_t
name|ord_st
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tx_bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmit
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_txx_states_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_txx_states_reg
name|cvmx_pcsx_txx_states_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcs#_tx_rx#_polarity_reg  *  * PCS_POLARITY_REG = TX_RX polarity reg  *  */
end_comment

begin_union
union|union
name|cvmx_pcsx_tx_rxx_polarity_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|rxovrd
range|:
literal|1
decl_stmt|;
comment|/**< When 0,<2> determines polarity                                                          when 1,<1> determines polarity */
name|uint64_t
name|autorxpl
range|:
literal|1
decl_stmt|;
comment|/**< Auto RX polarity detected. 1=inverted, 0=normal                                                          This bit always represents the correct rx polarity                                                          setting needed for successful rx path operartion,                                                          once a successful code group sync is obtained */
name|uint64_t
name|rxplrt
range|:
literal|1
decl_stmt|;
comment|/**< 1 is inverted polarity, 0 is normal polarity */
name|uint64_t
name|txplrt
range|:
literal|1
decl_stmt|;
comment|/**< 1 is inverted polarity, 0 is normal polarity */
else|#
directive|else
name|uint64_t
name|txplrt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxplrt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|autorxpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxovrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_pcsx_tx_rxx_polarity_reg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsx_tx_rxx_polarity_reg
name|cvmx_pcsx_tx_rxx_polarity_reg_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

