begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-usbcx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon usbcx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_USBCX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_USBCX_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DAINT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DAINT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000818ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DAINT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000818ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DAINTMSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DAINTMSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F001000081Cull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DAINTMSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F001000081Cull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DCFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DCFG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000800ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DCFG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000800ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DCTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DCTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000804ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DCTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000804ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DIEPCTLX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DIEPCTLX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000900ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DIEPCTLX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000900ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DIEPINTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DIEPINTX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000908ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DIEPINTX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000908ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DIEPMSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DIEPMSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000810ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DIEPMSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000810ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DIEPTSIZX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DIEPTSIZX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000910ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DIEPTSIZX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000910ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DOEPCTLX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DOEPCTLX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000B00ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DOEPCTLX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000B00ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DOEPINTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DOEPINTX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000B08ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DOEPINTX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000B08ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DOEPMSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DOEPMSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000814ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DOEPMSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000814ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DOEPTSIZX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DOEPTSIZX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000B10ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DOEPTSIZX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000B10ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DPTXFSIZX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DPTXFSIZX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000100ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x40000000000ull
operator|)
operator|*
literal|4
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DPTXFSIZX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000100ull) + (((offset)& 7) + ((block_id)& 1) * 0x40000000000ull) * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DSTS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DSTS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000808ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DSTS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000808ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DTKNQR1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DTKNQR1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000820ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DTKNQR1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000820ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DTKNQR2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DTKNQR2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000824ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DTKNQR2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000824ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DTKNQR3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DTKNQR3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000830ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DTKNQR3
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000830ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_DTKNQR4
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_DTKNQR4(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000834ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_DTKNQR4
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000834ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GAHBCFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GAHBCFG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000008ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GAHBCFG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000008ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GHWCFG1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GHWCFG1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000044ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GHWCFG1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000044ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GHWCFG2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GHWCFG2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000048ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GHWCFG2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000048ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GHWCFG3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GHWCFG3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F001000004Cull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GHWCFG3
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F001000004Cull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GHWCFG4
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GHWCFG4(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000050ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GHWCFG4
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000050ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GINTMSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GINTMSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000018ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GINTMSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000018ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GINTSTS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GINTSTS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000014ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GINTSTS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000014ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GNPTXFSIZ
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GNPTXFSIZ(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000028ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GNPTXFSIZ
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000028ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GNPTXSTS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GNPTXSTS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F001000002Cull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GNPTXSTS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F001000002Cull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GOTGCTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GOTGCTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000000ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GOTGCTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000000ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GOTGINT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GOTGINT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000004ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GOTGINT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000004ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GRSTCTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GRSTCTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000010ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GRSTCTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000010ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GRXFSIZ
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GRXFSIZ(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000024ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GRXFSIZ
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000024ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GRXSTSPD
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GRXSTSPD(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010040020ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GRXSTSPD
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010040020ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GRXSTSPH
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GRXSTSPH(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000020ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GRXSTSPH
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000020ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GRXSTSRD
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GRXSTSRD(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F001004001Cull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GRXSTSRD
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F001004001Cull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GRXSTSRH
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GRXSTSRH(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F001000001Cull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GRXSTSRH
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F001000001Cull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GSNPSID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GSNPSID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000040ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GSNPSID
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000040ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_GUSBCFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_GUSBCFG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F001000000Cull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_GUSBCFG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F001000000Cull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HAINT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HAINT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000414ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HAINT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000414ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HAINTMSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HAINTMSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000418ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HAINTMSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000418ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HCCHARX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HCCHARX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000500ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HCCHARX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000500ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HCFG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HCFG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000400ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HCFG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000400ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HCINTMSKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HCINTMSKX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F001000050Cull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HCINTMSKX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F001000050Cull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HCINTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HCINTX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000508ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HCINTX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000508ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HCSPLTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HCSPLTX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000504ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HCSPLTX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000504ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HCTSIZX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HCTSIZX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000510ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000000ull
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HCTSIZX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000510ull) + (((offset)& 7) + ((block_id)& 1) * 0x8000000000ull) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HFIR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HFIR(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000404ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HFIR
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000404ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HFNUM
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HFNUM(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000408ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HFNUM
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000408ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HPRT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HPRT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000440ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HPRT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000440ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HPTXFSIZ
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HPTXFSIZ(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000100ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HPTXFSIZ
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000100ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_HPTXSTS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_HPTXSTS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000410ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_HPTXSTS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000410ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_NPTXDFIFOX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_NPTXDFIFOX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010001000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000ull
operator|)
operator|*
literal|4096
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_NPTXDFIFOX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010001000ull) + (((offset)& 7) + ((block_id)& 1) * 0x100000000ull) * 4096)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_USBCX_PCGCCTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_USBCX_PCGCCTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00016F0010000E00ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x100000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_USBCX_PCGCCTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00016F0010000E00ull) + ((block_id)& 1) * 0x100000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_usbc#_daint  *  * Device All Endpoints Interrupt Register (DAINT)  *  * When a significant event occurs on an endpoint, a Device All Endpoints Interrupt register  * interrupts the application using the Device OUT Endpoints Interrupt bit or Device IN Endpoints  * Interrupt bit of the Core Interrupt register (GINTSTS.OEPInt or GINTSTS.IEPInt, respectively).  * There is one interrupt bit per endpoint, up to a maximum of 16 bits for OUT endpoints and 16  * bits for IN endpoints. For a bidirectional endpoint, the corresponding IN and OUT interrupt  * bits are used. Bits in this register are set and cleared when the application sets and clears  * bits in the corresponding Device Endpoint-n Interrupt register (DIEPINTn/DOEPINTn).  */
end_comment

begin_union
union|union
name|cvmx_usbcx_daint
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_daint_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|outepint
range|:
literal|16
decl_stmt|;
comment|/**< OUT Endpoint Interrupt Bits (OutEPInt)                                                          One bit per OUT endpoint:                                                          Bit 16 for OUT endpoint 0, bit 31 for OUT endpoint 15 */
name|uint32_t
name|inepint
range|:
literal|16
decl_stmt|;
comment|/**< IN Endpoint Interrupt Bits (InEpInt)                                                          One bit per IN Endpoint:                                                          Bit 0 for IN endpoint 0, bit 15 for endpoint 15 */
else|#
directive|else
name|uint32_t
name|inepint
range|:
literal|16
decl_stmt|;
name|uint32_t
name|outepint
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_daint_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daint_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daint_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daint_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daint_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_daint_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daint_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_daint
name|cvmx_usbcx_daint_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_daintmsk  *  * Device All Endpoints Interrupt Mask Register (DAINTMSK)  *  * The Device Endpoint Interrupt Mask register works with the Device Endpoint Interrupt register  * to interrupt the application when an event occurs on a device endpoint. However, the Device  * All Endpoints Interrupt (DAINT) register bit corresponding to that interrupt will still be set.  * Mask Interrupt: 1'b0 Unmask Interrupt: 1'b1  */
end_comment

begin_union
union|union
name|cvmx_usbcx_daintmsk
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_daintmsk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|outepmsk
range|:
literal|16
decl_stmt|;
comment|/**< OUT EP Interrupt Mask Bits (OutEpMsk)                                                          One per OUT Endpoint:                                                          Bit 16 for OUT EP 0, bit 31 for OUT EP 15 */
name|uint32_t
name|inepmsk
range|:
literal|16
decl_stmt|;
comment|/**< IN EP Interrupt Mask Bits (InEpMsk)                                                          One bit per IN Endpoint:                                                          Bit 0 for IN EP 0, bit 15 for IN EP 15 */
else|#
directive|else
name|uint32_t
name|inepmsk
range|:
literal|16
decl_stmt|;
name|uint32_t
name|outepmsk
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_daintmsk_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daintmsk_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daintmsk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daintmsk_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daintmsk_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_daintmsk_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_daintmsk_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_daintmsk
name|cvmx_usbcx_daintmsk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dcfg  *  * Device Configuration Register (DCFG)  *  * This register configures the core in Device mode after power-on or after certain control  * commands or enumeration. Do not make changes to this register after initial programming.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dcfg
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dcfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
name|uint32_t
name|epmiscnt
range|:
literal|5
decl_stmt|;
comment|/**< IN Endpoint Mismatch Count (EPMisCnt)                                                          The application programs this filed with a count that determines                                                          when the core generates an Endpoint Mismatch interrupt                                                          (GINTSTS.EPMis). The core loads this value into an internal                                                          counter and decrements it. The counter is reloaded whenever                                                          there is a match or when the counter expires. The width of this                                                          counter depends on the depth of the Token Queue. */
name|uint32_t
name|reserved_13_17
range|:
literal|5
decl_stmt|;
name|uint32_t
name|perfrint
range|:
literal|2
decl_stmt|;
comment|/**< Periodic Frame Interval (PerFrInt)                                                          Indicates the time within a (micro)frame at which the application                                                          must be notified using the End Of Periodic Frame Interrupt. This                                                          can be used to determine if all the isochronous traffic for that                                                          (micro)frame is complete.                                                          * 2'b00: 80% of the (micro)frame interval                                                          * 2'b01: 85%                                                          * 2'b10: 90%                                                          * 2'b11: 95% */
name|uint32_t
name|devaddr
range|:
literal|7
decl_stmt|;
comment|/**< Device Address (DevAddr)                                                          The application must program this field after every SetAddress                                                          control command. */
name|uint32_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nzstsouthshk
range|:
literal|1
decl_stmt|;
comment|/**< Non-Zero-Length Status OUT Handshake (NZStsOUTHShk)                                                          The application can use this field to select the handshake the                                                          core sends on receiving a nonzero-length data packet during                                                          the OUT transaction of a control transfer's Status stage.                                                          * 1'b1: Send a STALL handshake on a nonzero-length status                                                                  OUT transaction and do not send the received OUT packet to                                                                  the application.                                                          * 1'b0: Send the received OUT packet to the application (zero-                                                                  length or nonzero-length) and send a handshake based on                                                                  the NAK and STALL bits for the endpoint in the Device                                                                  Endpoint Control register. */
name|uint32_t
name|devspd
range|:
literal|2
decl_stmt|;
comment|/**< Device Speed (DevSpd)                                                          Indicates the speed at which the application requires the core to                                                          enumerate, or the maximum speed the application can support.                                                          However, the actual bus speed is determined only after the                                                          chirp sequence is completed, and is based on the speed of the                                                          USB host to which the core is connected. See "Device                                                          Initialization" on page 249 for details.                                                          * 2'b00: High speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)                                                          * 2'b01: Full speed (USB 2.0 PHY clock is 30 MHz or 60 MHz)                                                          * 2'b10: Low speed (USB 1.1 transceiver clock is 6 MHz). If                                                                   you select 6 MHz LS mode, you must do a soft reset.                                                          * 2'b11: Full speed (USB 1.1 transceiver clock is 48 MHz) */
else|#
directive|else
name|uint32_t
name|devspd
range|:
literal|2
decl_stmt|;
name|uint32_t
name|nzstsouthshk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint32_t
name|devaddr
range|:
literal|7
decl_stmt|;
name|uint32_t
name|perfrint
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_13_17
range|:
literal|5
decl_stmt|;
name|uint32_t
name|epmiscnt
range|:
literal|5
decl_stmt|;
name|uint32_t
name|reserved_23_31
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dcfg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dcfg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dcfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dcfg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dcfg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dcfg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dcfg_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dcfg
name|cvmx_usbcx_dcfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dctl  *  * Device Control Register (DCTL)  *  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_12_31
range|:
literal|20
decl_stmt|;
name|uint32_t
name|pwronprgdone
range|:
literal|1
decl_stmt|;
comment|/**< Power-On Programming Done (PWROnPrgDone)                                                          The application uses this bit to indicate that register                                                          programming is completed after a wake-up from Power Down                                                          mode. For more information, see "Device Mode Suspend and                                                          Resume With Partial Power-Down" on page 357. */
name|uint32_t
name|cgoutnak
range|:
literal|1
decl_stmt|;
comment|/**< Clear Global OUT NAK (CGOUTNak)                                                          A write to this field clears the Global OUT NAK. */
name|uint32_t
name|sgoutnak
range|:
literal|1
decl_stmt|;
comment|/**< Set Global OUT NAK (SGOUTNak)                                                          A write to this field sets the Global OUT NAK.                                                          The application uses this bit to send a NAK handshake on all                                                          OUT endpoints.                                                          The application should set the this bit only after making sure                                                          that the Global OUT NAK Effective bit in the Core Interrupt                                                          Register (GINTSTS.GOUTNakEff) is cleared. */
name|uint32_t
name|cgnpinnak
range|:
literal|1
decl_stmt|;
comment|/**< Clear Global Non-Periodic IN NAK (CGNPInNak)                                                          A write to this field clears the Global Non-Periodic IN NAK. */
name|uint32_t
name|sgnpinnak
range|:
literal|1
decl_stmt|;
comment|/**< Set Global Non-Periodic IN NAK (SGNPInNak)                                                          A write to this field sets the Global Non-Periodic IN NAK.The                                                          application uses this bit to send a NAK handshake on all non-                                                          periodic IN endpoints. The core can also set this bit when a                                                          timeout condition is detected on a non-periodic endpoint.                                                          The application should set this bit only after making sure that                                                          the Global IN NAK Effective bit in the Core Interrupt Register                                                          (GINTSTS.GINNakEff) is cleared. */
name|uint32_t
name|tstctl
range|:
literal|3
decl_stmt|;
comment|/**< Test Control (TstCtl)                                                          * 3'b000: Test mode disabled                                                          * 3'b001: Test_J mode                                                          * 3'b010: Test_K mode                                                          * 3'b011: Test_SE0_NAK mode                                                          * 3'b100: Test_Packet mode                                                          * 3'b101: Test_Force_Enable                                                          * Others: Reserved */
name|uint32_t
name|goutnaksts
range|:
literal|1
decl_stmt|;
comment|/**< Global OUT NAK Status (GOUTNakSts)                                                          * 1'b0: A handshake is sent based on the FIFO Status and the                                                                  NAK and STALL bit settings.                                                          * 1'b1: No data is written to the RxFIFO, irrespective of space                                                                  availability. Sends a NAK handshake on all packets, except                                                                  on SETUP transactions. All isochronous OUT packets are                                                                  dropped. */
name|uint32_t
name|gnpinnaksts
range|:
literal|1
decl_stmt|;
comment|/**< Global Non-Periodic IN NAK Status (GNPINNakSts)                                                          * 1'b0: A handshake is sent out based on the data availability                                                                  in the transmit FIFO.                                                          * 1'b1: A NAK handshake is sent out on all non-periodic IN                                                                  endpoints, irrespective of the data availability in the transmit                                                                  FIFO. */
name|uint32_t
name|sftdiscon
range|:
literal|1
decl_stmt|;
comment|/**< Soft Disconnect (SftDiscon)                                                          The application uses this bit to signal the O2P USB core to do a                                                          soft disconnect. As long as this bit is set, the host will not see                                                          that the device is connected, and the device will not receive                                                          signals on the USB. The core stays in the disconnected state                                                          until the application clears this bit.                                                          The minimum duration for which the core must keep this bit set                                                          is specified in Minimum Duration for Soft Disconnect  .                                                          * 1'b0: Normal operation. When this bit is cleared after a soft                                                          disconnect, the core drives the phy_opmode_o signal on the                                                          UTMI+ to 2'b00, which generates a device connect event to                                                          the USB host. When the device is reconnected, the USB host                                                          restarts device enumeration.                                                          * 1'b1: The core drives the phy_opmode_o signal on the                                                          UTMI+ to 2'b01, which generates a device disconnect event                                                          to the USB host. */
name|uint32_t
name|rmtwkupsig
range|:
literal|1
decl_stmt|;
comment|/**< Remote Wakeup Signaling (RmtWkUpSig)                                                          When the application sets this bit, the core initiates remote                                                          signaling to wake up the USB host.The application must set this                                                          bit to get the core out of Suspended state and must clear this bit                                                          after the core comes out of Suspended state. */
else|#
directive|else
name|uint32_t
name|rmtwkupsig
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sftdiscon
range|:
literal|1
decl_stmt|;
name|uint32_t
name|gnpinnaksts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|goutnaksts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tstctl
range|:
literal|3
decl_stmt|;
name|uint32_t
name|sgnpinnak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cgnpinnak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sgoutnak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|cgoutnak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pwronprgdone
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_12_31
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dctl
name|cvmx_usbcx_dctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_diepctl#  *  * Device IN Endpoint-n Control Register (DIEPCTLn)  *  * The application uses the register to control the behaviour of each logical endpoint other than endpoint 0.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_diepctlx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_diepctlx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|epena
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Enable (EPEna)                                                          Indicates that data is ready to be transmitted on the endpoint.                                                          The core clears this bit before setting any of the following                                                          interrupts on this endpoint:                                                          * Endpoint Disabled                                                          * Transfer Completed */
name|uint32_t
name|epdis
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Disable (EPDis)                                                          The application sets this bit to stop transmitting data on an                                                          endpoint, even before the transfer for that endpoint is complete.                                                          The application must wait for the Endpoint Disabled interrupt                                                          before treating the endpoint as disabled. The core clears this bit                                                          before setting the Endpoint Disabled Interrupt. The application                                                          should set this bit only if Endpoint Enable is already set for this                                                          endpoint. */
name|uint32_t
name|setd1pid
range|:
literal|1
decl_stmt|;
comment|/**< For Interrupt/BULK enpoints:                                                           Set DATA1 PID (SetD1PID)                                                           Writing to this field sets the Endpoint Data Pid (DPID) field in                                                           this register to DATA1.                                                          For Isochronous endpoints:                                                           Set Odd (micro)frame (SetOddFr)                                                           Writing to this field sets the Even/Odd (micro)frame (EO_FrNum)                                                           field to odd (micro)frame. */
name|uint32_t
name|setd0pid
range|:
literal|1
decl_stmt|;
comment|/**< For Interrupt/BULK enpoints:                                                           Writing to this field sets the Endpoint Data Pid (DPID) field in                                                           this register to DATA0.                                                          For Isochronous endpoints:                                                           Set Odd (micro)frame (SetEvenFr)                                                           Writing to this field sets the Even/Odd (micro)frame (EO_FrNum)                                                           field to even (micro)frame. */
name|uint32_t
name|snak
range|:
literal|1
decl_stmt|;
comment|/**< Set NAK (SNAK)                                                          A write to this bit sets the NAK bit for the endpoint.                                                          Using this bit, the application can control the transmission of                                                          NAK handshakes on an endpoint. The core can also set this bit                                                          for an endpoint after a SETUP packet is received on the                                                          endpoint. */
name|uint32_t
name|cnak
range|:
literal|1
decl_stmt|;
comment|/**< Clear NAK (CNAK)                                                          A write to this bit clears the NAK bit for the endpoint. */
name|uint32_t
name|txfnum
range|:
literal|4
decl_stmt|;
comment|/**< TxFIFO Number (TxFNum)                                                          Non-periodic endpoints must set this bit to zero.  Periodic                                                          endpoints must map this to the corresponding Periodic TxFIFO                                                          number.                                                          * 4'h0: Non-Periodic TxFIFO                                                          * Others: Specified Periodic TxFIFO number */
name|uint32_t
name|stall
range|:
literal|1
decl_stmt|;
comment|/**< STALL Handshake (Stall)                                                          For non-control, non-isochronous endpoints:                                                           The application sets this bit to stall all tokens from the USB host                                                           to this endpoint.  If a NAK bit, Global Non-Periodic IN NAK, or                                                           Global OUT NAK is set along with this bit, the STALL bit takes                                                           priority.  Only the application can clear this bit, never the core.                                                          For control endpoints:                                                           The application can only set this bit, and the core clears it, when                                                           a SETUP token i received for this endpoint.  If a NAK bit, Global                                                           Non-Periodic IN NAK, or Global OUT NAK is set along with this                                                           bit, the STALL bit takes priority.  Irrespective of this bit's setting,                                                           the core always responds to SETUP data packets with an ACK handshake. */
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eptype
range|:
literal|2
decl_stmt|;
comment|/**< Endpoint Type (EPType)                                                          This is the transfer type supported by this logical endpoint.                                                          * 2'b00: Control                                                          * 2'b01: Isochronous                                                          * 2'b10: Bulk                                                          * 2'b11: Interrupt */
name|uint32_t
name|naksts
range|:
literal|1
decl_stmt|;
comment|/**< NAK Status (NAKSts)                                                          Indicates the following:                                                          * 1'b0: The core is transmitting non-NAK handshakes based                                                                  on the FIFO status                                                          * 1'b1: The core is transmitting NAK handshakes on this                                                                  endpoint.                                                          When either the application or the core sets this bit:                                                          * For non-isochronous IN endpoints: The core stops                                                            transmitting any data on an IN endpoint, even if data is                                                            available in the TxFIFO.                                                          * For isochronous IN endpoints: The core sends out a zero-                                                            length data packet, even if data is available in the TxFIFO.                                                          Irrespective of this bit's setting, the core always responds to                                                          SETUP data packets with an ACK handshake. */
name|uint32_t
name|dpid
range|:
literal|1
decl_stmt|;
comment|/**< For interrupt/bulk IN and OUT endpoints:                                                           Endpoint Data PID (DPID)                                                           Contains the PID of the packet to be received or transmitted on                                                           this endpoint.  The application should program the PID of the first                                                           packet to be received or transmitted on this endpoint, after the                                                           endpoint is activated.  Applications use the SetD1PID and                                                           SetD0PID fields of this register to program either DATA0 or                                                           DATA1 PID.                                                           * 1'b0: DATA0                                                           * 1'b1: DATA1                                                          For isochronous IN and OUT endpoints:                                                           Even/Odd (Micro)Frame (EO_FrNum)                                                           Indicates the (micro)frame number in which the core transmits/                                                           receives isochronous data for this endpoint.  The application                                                           should program the even/odd (micro) frame number in which it                                                           intends to transmit/receive isochronous data for this endpoint                                                           using the SetEvnFr and SetOddFr fields in this register.                                                           * 1'b0: Even (micro)frame                                                           * 1'b1: Odd (micro)frame */
name|uint32_t
name|usbactep
range|:
literal|1
decl_stmt|;
comment|/**< USB Active Endpoint (USBActEP)                                                          Indicates whether this endpoint is active in the current                                                          configuration and interface.  The core clears this bit for all                                                          endpoints (other than EP 0) after detecting a USB reset.  After                                                          receiving the SetConfiguration and SetInterface commands, the                                                          application must program endpoint registers accordingly and set                                                          this bit. */
name|uint32_t
name|nextep
range|:
literal|4
decl_stmt|;
comment|/**< Next Endpoint (NextEp)                                                          Applies to non-periodic IN endpoints only.                                                          Indicates the endpoint number to be fetched after the data for                                                          the current endpoint is fetched. The core can access this field,                                                          even when the Endpoint Enable (EPEna) bit is not set. This                                                          field is not valid in Slave mode. */
name|uint32_t
name|mps
range|:
literal|11
decl_stmt|;
comment|/**< Maximum Packet Size (MPS)                                                          Applies to IN and OUT endpoints.                                                          The application must program this field with the maximum                                                          packet size for the current logical endpoint.  This value is in                                                          bytes. */
else|#
directive|else
name|uint32_t
name|mps
range|:
literal|11
decl_stmt|;
name|uint32_t
name|nextep
range|:
literal|4
decl_stmt|;
name|uint32_t
name|usbactep
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dpid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|naksts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eptype
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint32_t
name|stall
range|:
literal|1
decl_stmt|;
name|uint32_t
name|txfnum
range|:
literal|4
decl_stmt|;
name|uint32_t
name|cnak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|snak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|setd0pid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|setd1pid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epdis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epena
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_diepctlx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepctlx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepctlx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepctlx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepctlx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_diepctlx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepctlx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_diepctlx
name|cvmx_usbcx_diepctlx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_diepint#  *  * Device Endpoint-n Interrupt Register (DIEPINTn)  *  * This register indicates the status of an endpoint with respect to  * USB- and AHB-related events. The application must read this register  * when the OUT Endpoints Interrupt bit or IN Endpoints Interrupt bit of  * the Core Interrupt register (GINTSTS.OEPInt or GINTSTS.IEPInt,  * respectively) is set. Before the application can read this register,  * it must first read the Device All Endpoints Interrupt (DAINT) register  * to get the exact endpoint number for the Device Endpoint-n Interrupt  * register. The application must clear the appropriate bit in this register  * to clear the corresponding bits in the DAINT and GINTSTS registers.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_diepintx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_diepintx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_7_31
range|:
literal|25
decl_stmt|;
name|uint32_t
name|inepnakeff
range|:
literal|1
decl_stmt|;
comment|/**< IN Endpoint NAK Effective (INEPNakEff)                                                          Applies to periodic IN endpoints only.                                                          Indicates that the IN endpoint NAK bit set by the application has                                                          taken effect in the core. This bit can be cleared when the                                                          application clears the IN endpoint NAK by writing to                                                          DIEPCTLn.CNAK.                                                          This interrupt indicates that the core has sampled the NAK bit                                                          set (either by the application or by the core).                                                          This interrupt does not necessarily mean that a NAK handshake                                                          is sent on the USB. A STALL bit takes priority over a NAK bit. */
name|uint32_t
name|intknepmis
range|:
literal|1
decl_stmt|;
comment|/**< IN Token Received with EP Mismatch (INTknEPMis)                                                          Applies to non-periodic IN endpoints only.                                                          Indicates that the data in the top of the non-periodic TxFIFO                                                          belongs to an endpoint other than the one for which the IN                                                          token was received. This interrupt is asserted on the endpoint                                                          for which the IN token was received. */
name|uint32_t
name|intkntxfemp
range|:
literal|1
decl_stmt|;
comment|/**< IN Token Received When TxFIFO is Empty (INTknTXFEmp)                                                          Applies only to non-periodic IN endpoints.                                                          Indicates that an IN token was received when the associated                                                          TxFIFO (periodic/non-periodic) was empty. This interrupt is                                                          asserted on the endpoint for which the IN token was received. */
name|uint32_t
name|timeout
range|:
literal|1
decl_stmt|;
comment|/**< Timeout Condition (TimeOUT)                                                          Applies to non-isochronous IN endpoints only.                                                          Indicates that the core has detected a timeout condition on the                                                          USB for the last IN token on this endpoint. */
name|uint32_t
name|ahberr
range|:
literal|1
decl_stmt|;
comment|/**< AHB Error (AHBErr)                                                          This is generated only in Internal DMA mode when there is an                                                          AHB error during an AHB read/write. The application can read                                                          the corresponding endpoint DMA address register to get the                                                          error address. */
name|uint32_t
name|epdisbld
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Disabled Interrupt (EPDisbld)                                                          This bit indicates that the endpoint is disabled per the                                                          application's request. */
name|uint32_t
name|xfercompl
range|:
literal|1
decl_stmt|;
comment|/**< Transfer Completed Interrupt (XferCompl)                                                          Indicates that the programmed transfer is complete on the AHB                                                          as well as on the USB, for this endpoint. */
else|#
directive|else
name|uint32_t
name|xfercompl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epdisbld
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahberr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|timeout
range|:
literal|1
decl_stmt|;
name|uint32_t
name|intkntxfemp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|intknepmis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|inepnakeff
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_7_31
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_diepintx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepintx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepintx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepintx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepintx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_diepintx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepintx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_diepintx
name|cvmx_usbcx_diepintx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_diepmsk  *  * Device IN Endpoint Common Interrupt Mask Register (DIEPMSK)  *  * This register works with each of the Device IN Endpoint Interrupt (DIEPINTn) registers  * for all endpoints to generate an interrupt per IN endpoint. The IN endpoint interrupt  * for a specific status in the DIEPINTn register can be masked by writing to the corresponding  * bit in this register. Status bits are masked by default.  * Mask interrupt: 1'b0 Unmask interrupt: 1'b1  */
end_comment

begin_union
union|union
name|cvmx_usbcx_diepmsk
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_diepmsk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_7_31
range|:
literal|25
decl_stmt|;
name|uint32_t
name|inepnakeffmsk
range|:
literal|1
decl_stmt|;
comment|/**< IN Endpoint NAK Effective Mask (INEPNakEffMsk) */
name|uint32_t
name|intknepmismsk
range|:
literal|1
decl_stmt|;
comment|/**< IN Token received with EP Mismatch Mask (INTknEPMisMsk) */
name|uint32_t
name|intkntxfempmsk
range|:
literal|1
decl_stmt|;
comment|/**< IN Token Received When TxFIFO Empty Mask                                                          (INTknTXFEmpMsk) */
name|uint32_t
name|timeoutmsk
range|:
literal|1
decl_stmt|;
comment|/**< Timeout Condition Mask (TimeOUTMsk)                                                          (Non-isochronous endpoints) */
name|uint32_t
name|ahberrmsk
range|:
literal|1
decl_stmt|;
comment|/**< AHB Error Mask (AHBErrMsk) */
name|uint32_t
name|epdisbldmsk
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Disabled Interrupt Mask (EPDisbldMsk) */
name|uint32_t
name|xfercomplmsk
range|:
literal|1
decl_stmt|;
comment|/**< Transfer Completed Interrupt Mask (XferComplMsk) */
else|#
directive|else
name|uint32_t
name|xfercomplmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epdisbldmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahberrmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|timeoutmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|intkntxfempmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|intknepmismsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|inepnakeffmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_7_31
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_diepmsk_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepmsk_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepmsk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepmsk_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepmsk_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_diepmsk_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_diepmsk_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_diepmsk
name|cvmx_usbcx_diepmsk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dieptsiz#  *  * Device Endpoint-n Transfer Size Register (DIEPTSIZn)  *  * The application must modify this register before enabling the endpoint.  * Once the endpoint is enabled using Endpoint Enable bit of the Device Endpoint-n Control registers (DIEPCTLn.EPEna/DOEPCTLn.EPEna),  * the core modifies this register. The application can only read this register once the core has cleared the Endpoint Enable bit.  * This register is used only for endpoints other than Endpoint 0.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dieptsizx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dieptsizx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mc
range|:
literal|2
decl_stmt|;
comment|/**< Multi Count (MC)                                                          Applies to IN endpoints only.                                                          For periodic IN endpoints, this field indicates the number of                                                          packets that must be transmitted per microframe on the USB.                                                          The core uses this field to calculate the data PID for                                                          isochronous IN endpoints.                                                          * 2'b01: 1 packet                                                          * 2'b10: 2 packets                                                          * 2'b11: 3 packets                                                          For non-periodic IN endpoints, this field is valid only in Internal                                                          DMA mode. It specifies the number of packets the core should                                                          fetch for an IN endpoint before it switches to the endpoint                                                          pointed to by the Next Endpoint field of the Device Endpoint-n                                                          Control register (DIEPCTLn.NextEp) */
name|uint32_t
name|pktcnt
range|:
literal|10
decl_stmt|;
comment|/**< Packet Count (PktCnt)                                                          Indicates the total number of USB packets that constitute the                                                          Transfer Size amount of data for this endpoint.                                                          IN Endpoints: This field is decremented every time a packet                                                          (maximum size or short packet) is read from the TxFIFO. */
name|uint32_t
name|xfersize
range|:
literal|19
decl_stmt|;
comment|/**< Transfer Size (XferSize)                                                          This field contains the transfer size in bytes for the current                                                          endpoint.                                                          The core only interrupts the application after it has exhausted                                                          the transfer size amount of data. The transfer size can be set to                                                          the maximum packet size of the endpoint, to be interrupted at                                                          the end of each packet.                                                          IN Endpoints: The core decrements this field every time a                                                          packet from the external memory is written to the TxFIFO. */
else|#
directive|else
name|uint32_t
name|xfersize
range|:
literal|19
decl_stmt|;
name|uint32_t
name|pktcnt
range|:
literal|10
decl_stmt|;
name|uint32_t
name|mc
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dieptsizx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dieptsizx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dieptsizx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dieptsizx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dieptsizx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dieptsizx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dieptsizx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dieptsizx
name|cvmx_usbcx_dieptsizx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_doepctl#  *  * Device OUT Endpoint-n Control Register (DOEPCTLn)  *  * The application uses the register to control the behaviour of each logical endpoint other than endpoint 0.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_doepctlx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_doepctlx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|epena
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Enable (EPEna)                                                          Indicates that the application has allocated the memory tp start                                                          receiving data from the USB.                                                          The core clears this bit before setting any of the following                                                          interrupts on this endpoint:                                                          * SETUP Phase Done                                                          * Endpoint Disabled                                                          * Transfer Completed                                                          For control OUT endpoints in DMA mode, this bit must be set                                                          to be able to transfer SETUP data packets in memory. */
name|uint32_t
name|epdis
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Disable (EPDis)                                                          The application sets this bit to stop transmitting data on an                                                          endpoint, even before the transfer for that endpoint is complete.                                                          The application must wait for the Endpoint Disabled interrupt                                                          before treating the endpoint as disabled. The core clears this bit                                                          before setting the Endpoint Disabled Interrupt. The application                                                          should set this bit only if Endpoint Enable is already set for this                                                          endpoint. */
name|uint32_t
name|setd1pid
range|:
literal|1
decl_stmt|;
comment|/**< For Interrupt/BULK enpoints:                                                           Set DATA1 PID (SetD1PID)                                                           Writing to this field sets the Endpoint Data Pid (DPID) field in                                                           this register to DATA1.                                                          For Isochronous endpoints:                                                           Set Odd (micro)frame (SetOddFr)                                                           Writing to this field sets the Even/Odd (micro)frame (EO_FrNum)                                                           field to odd (micro)frame. */
name|uint32_t
name|setd0pid
range|:
literal|1
decl_stmt|;
comment|/**< For Interrupt/BULK enpoints:                                                           Writing to this field sets the Endpoint Data Pid (DPID) field in                                                           this register to DATA0.                                                          For Isochronous endpoints:                                                           Set Odd (micro)frame (SetEvenFr)                                                           Writing to this field sets the Even/Odd (micro)frame (EO_FrNum)                                                           field to even (micro)frame. */
name|uint32_t
name|snak
range|:
literal|1
decl_stmt|;
comment|/**< Set NAK (SNAK)                                                          A write to this bit sets the NAK bit for the endpoint.                                                          Using this bit, the application can control the transmission of                                                          NAK handshakes on an endpoint. The core can also set this bit                                                          for an endpoint after a SETUP packet is received on the                                                          endpoint. */
name|uint32_t
name|cnak
range|:
literal|1
decl_stmt|;
comment|/**< Clear NAK (CNAK)                                                          A write to this bit clears the NAK bit for the endpoint. */
name|uint32_t
name|reserved_22_25
range|:
literal|4
decl_stmt|;
name|uint32_t
name|stall
range|:
literal|1
decl_stmt|;
comment|/**< STALL Handshake (Stall)                                                          For non-control, non-isochronous endpoints:                                                           The application sets this bit to stall all tokens from the USB host                                                           to this endpoint.  If a NAK bit, Global Non-Periodic IN NAK, or                                                           Global OUT NAK is set along with this bit, the STALL bit takes                                                           priority.  Only the application can clear this bit, never the core.                                                          For control endpoints:                                                           The application can only set this bit, and the core clears it, when                                                           a SETUP token i received for this endpoint.  If a NAK bit, Global                                                           Non-Periodic IN NAK, or Global OUT NAK is set along with this                                                           bit, the STALL bit takes priority.  Irrespective of this bit's setting,                                                           the core always responds to SETUP data packets with an ACK handshake. */
name|uint32_t
name|snp
range|:
literal|1
decl_stmt|;
comment|/**< Snoop Mode (Snp)                                                          This bit configures the endpoint to Snoop mode.  In Snoop mode,                                                          the core does not check the correctness of OUT packets before                                                          transferring them to application memory. */
name|uint32_t
name|eptype
range|:
literal|2
decl_stmt|;
comment|/**< Endpoint Type (EPType)                                                          This is the transfer type supported by this logical endpoint.                                                          * 2'b00: Control                                                          * 2'b01: Isochronous                                                          * 2'b10: Bulk                                                          * 2'b11: Interrupt */
name|uint32_t
name|naksts
range|:
literal|1
decl_stmt|;
comment|/**< NAK Status (NAKSts)                                                          Indicates the following:                                                          * 1'b0: The core is transmitting non-NAK handshakes based                                                                  on the FIFO status                                                          * 1'b1: The core is transmitting NAK handshakes on this                                                                  endpoint.                                                          When either the application or the core sets this bit:                                                          * The core stops receiving any data on an OUT endpoint, even                                                            if there is space in the RxFIFO to accomodate the incoming                                                            packet. */
name|uint32_t
name|dpid
range|:
literal|1
decl_stmt|;
comment|/**< For interrupt/bulk IN and OUT endpoints:                                                           Endpoint Data PID (DPID)                                                           Contains the PID of the packet to be received or transmitted on                                                           this endpoint.  The application should program the PID of the first                                                           packet to be received or transmitted on this endpoint, after the                                                           endpoint is activated.  Applications use the SetD1PID and                                                           SetD0PID fields of this register to program either DATA0 or                                                           DATA1 PID.                                                           * 1'b0: DATA0                                                           * 1'b1: DATA1                                                          For isochronous IN and OUT endpoints:                                                           Even/Odd (Micro)Frame (EO_FrNum)                                                           Indicates the (micro)frame number in which the core transmits/                                                           receives isochronous data for this endpoint.  The application                                                           should program the even/odd (micro) frame number in which it                                                           intends to transmit/receive isochronous data for this endpoint                                                           using the SetEvnFr and SetOddFr fields in this register.                                                           * 1'b0: Even (micro)frame                                                           * 1'b1: Odd (micro)frame */
name|uint32_t
name|usbactep
range|:
literal|1
decl_stmt|;
comment|/**< USB Active Endpoint (USBActEP)                                                          Indicates whether this endpoint is active in the current                                                          configuration and interface.  The core clears this bit for all                                                          endpoints (other than EP 0) after detecting a USB reset.  After                                                          receiving the SetConfiguration and SetInterface commands, the                                                          application must program endpoint registers accordingly and set                                                          this bit. */
name|uint32_t
name|reserved_11_14
range|:
literal|4
decl_stmt|;
name|uint32_t
name|mps
range|:
literal|11
decl_stmt|;
comment|/**< Maximum Packet Size (MPS)                                                          Applies to IN and OUT endpoints.                                                          The application must program this field with the maximum                                                          packet size for the current logical endpoint.  This value is in                                                          bytes. */
else|#
directive|else
name|uint32_t
name|mps
range|:
literal|11
decl_stmt|;
name|uint32_t
name|reserved_11_14
range|:
literal|4
decl_stmt|;
name|uint32_t
name|usbactep
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dpid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|naksts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eptype
range|:
literal|2
decl_stmt|;
name|uint32_t
name|snp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|stall
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_22_25
range|:
literal|4
decl_stmt|;
name|uint32_t
name|cnak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|snak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|setd0pid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|setd1pid
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epdis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epena
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_doepctlx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepctlx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepctlx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepctlx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepctlx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_doepctlx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepctlx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_doepctlx
name|cvmx_usbcx_doepctlx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_doepint#  *  * Device Endpoint-n Interrupt Register (DOEPINTn)  *  * This register indicates the status of an endpoint with respect to USB- and AHB-related events.  * The application must read this register when the OUT Endpoints Interrupt bit or IN Endpoints  * Interrupt bit of the Core Interrupt register (GINTSTS.OEPInt or GINTSTS.IEPInt, respectively)  * is set. Before the application can read this register, it must first read the Device All  * Endpoints Interrupt (DAINT) register to get the exact endpoint number for the Device Endpoint-n  * Interrupt register. The application must clear the appropriate bit in this register to clear the  * corresponding bits in the DAINT and GINTSTS registers.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_doepintx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_doepintx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
name|uint32_t
name|outtknepdis
range|:
literal|1
decl_stmt|;
comment|/**< OUT Token Received When Endpoint Disabled (OUTTknEPdis)                                                          Applies only to control OUT endpoints.                                                          Indicates that an OUT token was received when the endpoint                                                          was not yet enabled. This interrupt is asserted on the endpoint                                                          for which the OUT token was received. */
name|uint32_t
name|setup
range|:
literal|1
decl_stmt|;
comment|/**< SETUP Phase Done (SetUp)                                                          Applies to control OUT endpoints only.                                                          Indicates that the SETUP phase for the control endpoint is                                                          complete and no more back-to-back SETUP packets were                                                          received for the current control transfer. On this interrupt, the                                                          application can decode the received SETUP data packet. */
name|uint32_t
name|ahberr
range|:
literal|1
decl_stmt|;
comment|/**< AHB Error (AHBErr)                                                          This is generated only in Internal DMA mode when there is an                                                          AHB error during an AHB read/write. The application can read                                                          the corresponding endpoint DMA address register to get the                                                          error address. */
name|uint32_t
name|epdisbld
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Disabled Interrupt (EPDisbld)                                                          This bit indicates that the endpoint is disabled per the                                                          application's request. */
name|uint32_t
name|xfercompl
range|:
literal|1
decl_stmt|;
comment|/**< Transfer Completed Interrupt (XferCompl)                                                          Indicates that the programmed transfer is complete on the AHB                                                          as well as on the USB, for this endpoint. */
else|#
directive|else
name|uint32_t
name|xfercompl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epdisbld
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahberr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|setup
range|:
literal|1
decl_stmt|;
name|uint32_t
name|outtknepdis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_doepintx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepintx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepintx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepintx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepintx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_doepintx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepintx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_doepintx
name|cvmx_usbcx_doepintx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_doepmsk  *  * Device OUT Endpoint Common Interrupt Mask Register (DOEPMSK)  *  * This register works with each of the Device OUT Endpoint Interrupt (DOEPINTn) registers  * for all endpoints to generate an interrupt per OUT endpoint. The OUT endpoint interrupt  * for a specific status in the DOEPINTn register can be masked by writing into the  * corresponding bit in this register. Status bits are masked by default.  * Mask interrupt: 1'b0 Unmask interrupt: 1'b1  */
end_comment

begin_union
union|union
name|cvmx_usbcx_doepmsk
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_doepmsk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
name|uint32_t
name|outtknepdismsk
range|:
literal|1
decl_stmt|;
comment|/**< OUT Token Received when Endpoint Disabled Mask                                                          (OUTTknEPdisMsk)                                                          Applies to control OUT endpoints only. */
name|uint32_t
name|setupmsk
range|:
literal|1
decl_stmt|;
comment|/**< SETUP Phase Done Mask (SetUPMsk)                                                          Applies to control endpoints only. */
name|uint32_t
name|ahberrmsk
range|:
literal|1
decl_stmt|;
comment|/**< AHB Error (AHBErrMsk) */
name|uint32_t
name|epdisbldmsk
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Disabled Interrupt Mask (EPDisbldMsk) */
name|uint32_t
name|xfercomplmsk
range|:
literal|1
decl_stmt|;
comment|/**< Transfer Completed Interrupt Mask (XferComplMsk) */
else|#
directive|else
name|uint32_t
name|xfercomplmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epdisbldmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahberrmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|setupmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|outtknepdismsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_doepmsk_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepmsk_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepmsk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepmsk_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepmsk_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_doepmsk_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doepmsk_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_doepmsk
name|cvmx_usbcx_doepmsk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_doeptsiz#  *  * Device Endpoint-n Transfer Size Register (DOEPTSIZn)  *  * The application must modify this register before enabling the endpoint.  * Once the endpoint is enabled using Endpoint Enable bit of the Device Endpoint-n Control  * registers (DOEPCTLn.EPEna/DOEPCTLn.EPEna), the core modifies this register. The application  * can only read this register once the core has cleared the Endpoint Enable bit.  * This register is used only for endpoints other than Endpoint 0.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_doeptsizx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_doeptsizx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint32_t
name|mc
range|:
literal|2
decl_stmt|;
comment|/**< Multi Count (MC)                                                          Received Data PID (RxDPID)                                                          Applies to isochronous OUT endpoints only.                                                          This is the data PID received in the last packet for this endpoint.                                                          2'b00: DATA0                                                          2'b01: DATA1                                                          2'b10: DATA2                                                          2'b11: MDATA                                                          SETUP Packet Count (SUPCnt)                                                          Applies to control OUT Endpoints only.                                                          This field specifies the number of back-to-back SETUP data                                                          packets the endpoint can receive.                                                          2'b01: 1 packet                                                          2'b10: 2 packets                                                          2'b11: 3 packets */
name|uint32_t
name|pktcnt
range|:
literal|10
decl_stmt|;
comment|/**< Packet Count (PktCnt)                                                          Indicates the total number of USB packets that constitute the                                                          Transfer Size amount of data for this endpoint.                                                          OUT Endpoints: This field is decremented every time a                                                          packet (maximum size or short packet) is written to the                                                          RxFIFO. */
name|uint32_t
name|xfersize
range|:
literal|19
decl_stmt|;
comment|/**< Transfer Size (XferSize)                                                          This field contains the transfer size in bytes for the current                                                          endpoint.                                                          The core only interrupts the application after it has exhausted                                                          the transfer size amount of data. The transfer size can be set to                                                          the maximum packet size of the endpoint, to be interrupted at                                                          the end of each packet.                                                          OUT Endpoints: The core decrements this field every time a                                                          packet is read from the RxFIFO and written to the external                                                          memory. */
else|#
directive|else
name|uint32_t
name|xfersize
range|:
literal|19
decl_stmt|;
name|uint32_t
name|pktcnt
range|:
literal|10
decl_stmt|;
name|uint32_t
name|mc
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_doeptsizx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doeptsizx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doeptsizx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doeptsizx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doeptsizx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_doeptsizx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_doeptsizx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_doeptsizx
name|cvmx_usbcx_doeptsizx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dptxfsiz#  *  * Device Periodic Transmit FIFO-n Size Register (DPTXFSIZ)  *  * This register holds the memory start address of each periodic TxFIFO to implemented  * in Device mode. Each periodic FIFO holds the data for one periodic IN endpoint.  * This register is repeated for each periodic FIFO instantiated.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dptxfsizx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dptxfsizx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|dptxfsize
range|:
literal|16
decl_stmt|;
comment|/**< Device Periodic TxFIFO Size (DPTxFSize)                                                          This value is in terms of 32-bit words.                                                          * Minimum value is 4                                                          * Maximum value is 768 */
name|uint32_t
name|dptxfstaddr
range|:
literal|16
decl_stmt|;
comment|/**< Device Periodic TxFIFO RAM Start Address (DPTxFStAddr)                                                          Holds the start address in the RAM for this periodic FIFO. */
else|#
directive|else
name|uint32_t
name|dptxfstaddr
range|:
literal|16
decl_stmt|;
name|uint32_t
name|dptxfsize
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dptxfsizx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dptxfsizx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dptxfsizx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dptxfsizx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dptxfsizx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dptxfsizx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dptxfsizx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dptxfsizx
name|cvmx_usbcx_dptxfsizx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dsts  *  * Device Status Register (DSTS)  *  * This register indicates the status of the core with respect to USB-related events.  * It must be read on interrupts from Device All Interrupts (DAINT) register.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dsts
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dsts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_22_31
range|:
literal|10
decl_stmt|;
name|uint32_t
name|soffn
range|:
literal|14
decl_stmt|;
comment|/**< Frame or Microframe Number of the Received SOF (SOFFN)                                                          When the core is operating at high speed, this field contains a                                                          microframe number. When the core is operating at full or low                                                          speed, this field contains a frame number. */
name|uint32_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint32_t
name|errticerr
range|:
literal|1
decl_stmt|;
comment|/**< Erratic Error (ErrticErr)                                                          The core sets this bit to report any erratic errors                                                          (phy_rxvalid_i/phy_rxvldh_i or phy_rxactive_i is asserted for at                                                          least 2 ms, due to PHY error) seen on the UTMI+.                                                          Due to erratic errors, the O2P USB core goes into Suspended                                                          state and an interrupt is generated to the application with Early                                                          Suspend bit of the Core Interrupt register (GINTSTS.ErlySusp).                                                          If the early suspend is asserted due to an erratic error, the                                                          application can only perform a soft disconnect recover. */
name|uint32_t
name|enumspd
range|:
literal|2
decl_stmt|;
comment|/**< Enumerated Speed (EnumSpd)                                                          Indicates the speed at which the O2P USB core has come up                                                          after speed detection through a chirp sequence.                                                          * 2'b00: High speed (PHY clock is running at 30 or 60 MHz)                                                          * 2'b01: Full speed (PHY clock is running at 30 or 60 MHz)                                                          * 2'b10: Low speed (PHY clock is running at 6 MHz)                                                          * 2'b11: Full speed (PHY clock is running at 48 MHz)                                                          Low speed is not supported for devices using a UTMI+ PHY. */
name|uint32_t
name|suspsts
range|:
literal|1
decl_stmt|;
comment|/**< Suspend Status (SuspSts)                                                          In Device mode, this bit is set as long as a Suspend condition is                                                          detected on the USB. The core enters the Suspended state                                                          when there is no activity on the phy_line_state_i signal for an                                                          extended period of time. The core comes out of the suspend:                                                          * When there is any activity on the phy_line_state_i signal                                                          * When the application writes to the Remote Wakeup Signaling                                                            bit in the Device Control register (DCTL.RmtWkUpSig). */
else|#
directive|else
name|uint32_t
name|suspsts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enumspd
range|:
literal|2
decl_stmt|;
name|uint32_t
name|errticerr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint32_t
name|soffn
range|:
literal|14
decl_stmt|;
name|uint32_t
name|reserved_22_31
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dsts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dsts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dsts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dsts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dsts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dsts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dsts_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dsts
name|cvmx_usbcx_dsts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dtknqr1  *  * Device IN Token Sequence Learning Queue Read Register 1 (DTKNQR1)  *  * The depth of the IN Token Sequence Learning Queue is specified for Device Mode IN Token  * Sequence Learning Queue Depth. The queue is 4 bits wide to store the endpoint number.  * A read from this register returns the first 5 endpoint entries of the IN Token Sequence  * Learning Queue. When the queue is full, the new token is pushed into the queue and oldest  * token is discarded.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dtknqr1
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dtknqr1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|eptkn
range|:
literal|24
decl_stmt|;
comment|/**< Endpoint Token (EPTkn)                                                          Four bits per token represent the endpoint number of the token:                                                          * Bits [31:28]: Endpoint number of Token 5                                                          * Bits [27:24]: Endpoint number of Token 4                                                          - .......                                                          * Bits [15:12]: Endpoint number of Token 1                                                          * Bits [11:8]: Endpoint number of Token 0 */
name|uint32_t
name|wrapbit
range|:
literal|1
decl_stmt|;
comment|/**< Wrap Bit (WrapBit)                                                          This bit is set when the write pointer wraps. It is cleared when                                                          the learning queue is cleared. */
name|uint32_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint32_t
name|intknwptr
range|:
literal|5
decl_stmt|;
comment|/**< IN Token Queue Write Pointer (INTknWPtr) */
else|#
directive|else
name|uint32_t
name|intknwptr
range|:
literal|5
decl_stmt|;
name|uint32_t
name|reserved_5_6
range|:
literal|2
decl_stmt|;
name|uint32_t
name|wrapbit
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eptkn
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dtknqr1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dtknqr1
name|cvmx_usbcx_dtknqr1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dtknqr2  *  * Device IN Token Sequence Learning Queue Read Register 2 (DTKNQR2)  *  * A read from this register returns the next 8 endpoint entries of the learning queue.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dtknqr2
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dtknqr2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|eptkn
range|:
literal|32
decl_stmt|;
comment|/**< Endpoint Token (EPTkn)                                                          Four bits per token represent the endpoint number of the token:                                                          * Bits [31:28]: Endpoint number of Token 13                                                          * Bits [27:24]: Endpoint number of Token 12                                                          - .......                                                          * Bits [7:4]: Endpoint number of Token 7                                                          * Bits [3:0]: Endpoint number of Token 6 */
else|#
directive|else
name|uint32_t
name|eptkn
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dtknqr2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dtknqr2
name|cvmx_usbcx_dtknqr2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dtknqr3  *  * Device IN Token Sequence Learning Queue Read Register 3 (DTKNQR3)  *  * A read from this register returns the next 8 endpoint entries of the learning queue.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dtknqr3
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dtknqr3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|eptkn
range|:
literal|32
decl_stmt|;
comment|/**< Endpoint Token (EPTkn)                                                          Four bits per token represent the endpoint number of the token:                                                          * Bits [31:28]: Endpoint number of Token 21                                                          * Bits [27:24]: Endpoint number of Token 20                                                          - .......                                                          * Bits [7:4]: Endpoint number of Token 15                                                          * Bits [3:0]: Endpoint number of Token 14 */
else|#
directive|else
name|uint32_t
name|eptkn
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dtknqr3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dtknqr3
name|cvmx_usbcx_dtknqr3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_dtknqr4  *  * Device IN Token Sequence Learning Queue Read Register 4 (DTKNQR4)  *  * A read from this register returns the last 8 endpoint entries of the learning queue.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_dtknqr4
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_dtknqr4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|eptkn
range|:
literal|32
decl_stmt|;
comment|/**< Endpoint Token (EPTkn)                                                          Four bits per token represent the endpoint number of the token:                                                          * Bits [31:28]: Endpoint number of Token 29                                                          * Bits [27:24]: Endpoint number of Token 28                                                          - .......                                                          * Bits [7:4]: Endpoint number of Token 23                                                          * Bits [3:0]: Endpoint number of Token 22 */
else|#
directive|else
name|uint32_t
name|eptkn
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_dtknqr4_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr4_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_dtknqr4_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_dtknqr4
name|cvmx_usbcx_dtknqr4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gahbcfg  *  * Core AHB Configuration Register (GAHBCFG)  *  * This register can be used to configure the core after power-on or a change in mode of operation.  * This register mainly contains AHB system-related configuration parameters. The AHB is the processor  * interface to the O2P USB core. In general, software need not know about this interface except to  * program the values as specified.  *  * The application must program this register as part of the O2P USB core initialization.  * Do not change this register after the initial programming.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gahbcfg
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gahbcfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
name|uint32_t
name|ptxfemplvl
range|:
literal|1
decl_stmt|;
comment|/**< Periodic TxFIFO Empty Level (PTxFEmpLvl)                                                          Software should set this bit to 0x1.                                                          Indicates when the Periodic TxFIFO Empty Interrupt bit in the                                                          Core Interrupt register (GINTSTS.PTxFEmp) is triggered. This                                                          bit is used only in Slave mode.                                                          * 1'b0: GINTSTS.PTxFEmp interrupt indicates that the Periodic                                                            TxFIFO is half empty                                                          * 1'b1: GINTSTS.PTxFEmp interrupt indicates that the Periodic                                                            TxFIFO is completely empty */
name|uint32_t
name|nptxfemplvl
range|:
literal|1
decl_stmt|;
comment|/**< Non-Periodic TxFIFO Empty Level (NPTxFEmpLvl)                                                          Software should set this bit to 0x1.                                                          Indicates when the Non-Periodic TxFIFO Empty Interrupt bit in                                                          the Core Interrupt register (GINTSTS.NPTxFEmp) is triggered.                                                          This bit is used only in Slave mode.                                                          * 1'b0: GINTSTS.NPTxFEmp interrupt indicates that the Non-                                                             Periodic TxFIFO is half empty                                                          * 1'b1: GINTSTS.NPTxFEmp interrupt indicates that the Non-                                                             Periodic TxFIFO is completely empty */
name|uint32_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dmaen
range|:
literal|1
decl_stmt|;
comment|/**< DMA Enable (DMAEn)                                                          * 1'b0: Core operates in Slave mode                                                          * 1'b1: Core operates in a DMA mode */
name|uint32_t
name|hbstlen
range|:
literal|4
decl_stmt|;
comment|/**< Burst Length/Type (HBstLen)                                                          This field has not effect and should be left as 0x0. */
name|uint32_t
name|glblintrmsk
range|:
literal|1
decl_stmt|;
comment|/**< Global Interrupt Mask (GlblIntrMsk)                                                          Software should set this field to 0x1.                                                          The application uses this bit to mask  or unmask the interrupt                                                          line assertion to itself. Irrespective of this bit's setting, the                                                          interrupt status registers are updated by the core.                                                          * 1'b0: Mask the interrupt assertion to the application.                                                          * 1'b1: Unmask the interrupt assertion to the application. */
else|#
directive|else
name|uint32_t
name|glblintrmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hbstlen
range|:
literal|4
decl_stmt|;
name|uint32_t
name|dmaen
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nptxfemplvl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ptxfemplvl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_9_31
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gahbcfg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gahbcfg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gahbcfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gahbcfg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gahbcfg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gahbcfg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gahbcfg_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gahbcfg
name|cvmx_usbcx_gahbcfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_ghwcfg1  *  * User HW Config1 Register (GHWCFG1)  *  * This register contains the logical endpoint direction(s) of the O2P USB core.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_ghwcfg1
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_ghwcfg1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|epdir
range|:
literal|32
decl_stmt|;
comment|/**< Endpoint Direction (epdir)                                                          Two bits per endpoint represent the direction.                                                          * 2'b00: BIDIR (IN and OUT) endpoint                                                          * 2'b01: IN endpoint                                                          * 2'b10: OUT endpoint                                                          * 2'b11: Reserved                                                          Bits [31:30]: Endpoint 15 direction                                                          Bits [29:28]: Endpoint 14 direction                                                          - ...                                                          Bits [3:2]: Endpoint 1 direction                                                          Bits[1:0]: Endpoint 0 direction (always BIDIR) */
else|#
directive|else
name|uint32_t
name|epdir
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_ghwcfg1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_ghwcfg1
name|cvmx_usbcx_ghwcfg1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_ghwcfg2  *  * User HW Config2 Register (GHWCFG2)  *  * This register contains configuration options of the O2P USB core.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_ghwcfg2
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_ghwcfg2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint32_t
name|tknqdepth
range|:
literal|5
decl_stmt|;
comment|/**< Device Mode IN Token Sequence Learning Queue Depth                                                          (TknQDepth)                                                          Range: 0-30 */
name|uint32_t
name|ptxqdepth
range|:
literal|2
decl_stmt|;
comment|/**< Host Mode Periodic Request Queue Depth (PTxQDepth)                                                          * 2'b00: 2                                                          * 2'b01: 4                                                          * 2'b10: 8                                                          * Others: Reserved */
name|uint32_t
name|nptxqdepth
range|:
literal|2
decl_stmt|;
comment|/**< Non-Periodic Request Queue Depth (NPTxQDepth)                                                          * 2'b00: 2                                                          * 2'b01: 4                                                          * 2'b10: 8                                                          * Others: Reserved */
name|uint32_t
name|reserved_20_21
range|:
literal|2
decl_stmt|;
name|uint32_t
name|dynfifosizing
range|:
literal|1
decl_stmt|;
comment|/**< Dynamic FIFO Sizing Enabled (DynFifoSizing)                                                          * 1'b0: No                                                          * 1'b1: Yes */
name|uint32_t
name|periosupport
range|:
literal|1
decl_stmt|;
comment|/**< Periodic OUT Channels Supported in Host Mode                                                          (PerioSupport)                                                          * 1'b0: No                                                          * 1'b1: Yes */
name|uint32_t
name|numhstchnl
range|:
literal|4
decl_stmt|;
comment|/**< Number of Host Channels (NumHstChnl)                                                          Indicates the number of host channels supported by the core in                                                          Host mode. The range of this field is 0-15: 0 specifies 1                                                          channel, 15 specifies 16 channels. */
name|uint32_t
name|numdeveps
range|:
literal|4
decl_stmt|;
comment|/**< Number of Device Endpoints (NumDevEps)                                                          Indicates the number of device endpoints supported by the core                                                          in Device mode in addition to control endpoint 0. The range of                                                          this field is 1-15. */
name|uint32_t
name|fsphytype
range|:
literal|2
decl_stmt|;
comment|/**< Full-Speed PHY Interface Type (FSPhyType)                                                          * 2'b00: Full-speed interface not supported                                                          * 2'b01: Dedicated full-speed interface                                                          * 2'b10: FS pins shared with UTMI+ pins                                                          * 2'b11: FS pins shared with ULPI pins */
name|uint32_t
name|hsphytype
range|:
literal|2
decl_stmt|;
comment|/**< High-Speed PHY Interface Type (HSPhyType)                                                          * 2'b00: High-Speed interface not supported                                                          * 2'b01: UTMI+                                                          * 2'b10: ULPI                                                          * 2'b11: UTMI+ and ULPI */
name|uint32_t
name|singpnt
range|:
literal|1
decl_stmt|;
comment|/**< Point-to-Point (SingPnt)                                                          * 1'b0: Multi-point application                                                          * 1'b1: Single-point application */
name|uint32_t
name|otgarch
range|:
literal|2
decl_stmt|;
comment|/**< Architecture (OtgArch)                                                          * 2'b00: Slave-Only                                                          * 2'b01: External DMA                                                          * 2'b10: Internal DMA                                                          * Others: Reserved */
name|uint32_t
name|otgmode
range|:
literal|3
decl_stmt|;
comment|/**< Mode of Operation (OtgMode)                                                          * 3'b000: HNP- and SRP-Capable OTG (Host& Device)                                                          * 3'b001: SRP-Capable OTG (Host& Device)                                                          * 3'b010: Non-HNP and Non-SRP Capable OTG (Host&                                                          Device)                                                          * 3'b011: SRP-Capable Device                                                          * 3'b100: Non-OTG Device                                                          * 3'b101: SRP-Capable Host                                                          * 3'b110: Non-OTG Host                                                          * Others: Reserved */
else|#
directive|else
name|uint32_t
name|otgmode
range|:
literal|3
decl_stmt|;
name|uint32_t
name|otgarch
range|:
literal|2
decl_stmt|;
name|uint32_t
name|singpnt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hsphytype
range|:
literal|2
decl_stmt|;
name|uint32_t
name|fsphytype
range|:
literal|2
decl_stmt|;
name|uint32_t
name|numdeveps
range|:
literal|4
decl_stmt|;
name|uint32_t
name|numhstchnl
range|:
literal|4
decl_stmt|;
name|uint32_t
name|periosupport
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dynfifosizing
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_20_21
range|:
literal|2
decl_stmt|;
name|uint32_t
name|nptxqdepth
range|:
literal|2
decl_stmt|;
name|uint32_t
name|ptxqdepth
range|:
literal|2
decl_stmt|;
name|uint32_t
name|tknqdepth
range|:
literal|5
decl_stmt|;
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_ghwcfg2_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg2_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_ghwcfg2
name|cvmx_usbcx_ghwcfg2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_ghwcfg3  *  * User HW Config3 Register (GHWCFG3)  *  * This register contains the configuration options of the O2P USB core.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_ghwcfg3
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_ghwcfg3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|dfifodepth
range|:
literal|16
decl_stmt|;
comment|/**< DFIFO Depth (DfifoDepth)                                                          This value is in terms of 32-bit words.                                                          * Minimum value is 32                                                          * Maximum value is 32768 */
name|uint32_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint32_t
name|ahbphysync
range|:
literal|1
decl_stmt|;
comment|/**< AHB and PHY Synchronous (AhbPhySync)                                                          Indicates whether AHB and PHY clocks are synchronous to                                                          each other.                                                          * 1'b0: No                                                          * 1'b1: Yes                                                          This bit is tied to 1. */
name|uint32_t
name|rsttype
range|:
literal|1
decl_stmt|;
comment|/**< Reset Style for Clocked always Blocks in RTL (RstType)                                                          * 1'b0: Asynchronous reset is used in the core                                                          * 1'b1: Synchronous reset is used in the core */
name|uint32_t
name|optfeature
range|:
literal|1
decl_stmt|;
comment|/**< Optional Features Removed (OptFeature)                                                          Indicates whether the User ID register, GPIO interface ports,                                                          and SOF toggle and counter ports were removed for gate count                                                          optimization. */
name|uint32_t
name|vendor_control_interface_support
range|:
literal|1
decl_stmt|;
comment|/**< Vendor Control Interface Support                                                          * 1'b0: Vendor Control Interface is not available on the core.                                                          * 1'b1: Vendor Control Interface is available. */
name|uint32_t
name|i2c_selection
range|:
literal|1
decl_stmt|;
comment|/**< I2C Selection                                                          * 1'b0: I2C Interface is not available on the core.                                                          * 1'b1: I2C Interface is available on the core. */
name|uint32_t
name|otgen
range|:
literal|1
decl_stmt|;
comment|/**< OTG Function Enabled (OtgEn)                                                          The application uses this bit to indicate the O2P USB core's                                                          OTG capabilities.                                                          * 1'b0: Not OTG capable                                                          * 1'b1: OTG Capable */
name|uint32_t
name|pktsizewidth
range|:
literal|3
decl_stmt|;
comment|/**< Width of Packet Size Counters (PktSizeWidth)                                                          * 3'b000: 4 bits                                                          * 3'b001: 5 bits                                                          * 3'b010: 6 bits                                                          * 3'b011: 7 bits                                                          * 3'b100: 8 bits                                                          * 3'b101: 9 bits                                                          * 3'b110: 10 bits                                                          * Others: Reserved */
name|uint32_t
name|xfersizewidth
range|:
literal|4
decl_stmt|;
comment|/**< Width of Transfer Size Counters (XferSizeWidth)                                                          * 4'b0000: 11 bits                                                          * 4'b0001: 12 bits                                                          - ...                                                          * 4'b1000: 19 bits                                                          * Others: Reserved */
else|#
directive|else
name|uint32_t
name|xfersizewidth
range|:
literal|4
decl_stmt|;
name|uint32_t
name|pktsizewidth
range|:
literal|3
decl_stmt|;
name|uint32_t
name|otgen
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i2c_selection
range|:
literal|1
decl_stmt|;
name|uint32_t
name|vendor_control_interface_support
range|:
literal|1
decl_stmt|;
name|uint32_t
name|optfeature
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rsttype
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahbphysync
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint32_t
name|dfifodepth
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_ghwcfg3_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg3_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_ghwcfg3
name|cvmx_usbcx_ghwcfg3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_ghwcfg4  *  * User HW Config4 Register (GHWCFG4)  *  * This register contains the configuration options of the O2P USB core.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_ghwcfg4
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_ghwcfg4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint32_t
name|numdevmodinend
range|:
literal|4
decl_stmt|;
comment|/**< Enable dedicatd transmit FIFO for device IN endpoints. */
name|uint32_t
name|endedtrfifo
range|:
literal|1
decl_stmt|;
comment|/**< Enable dedicatd transmit FIFO for device IN endpoints. */
name|uint32_t
name|sessendfltr
range|:
literal|1
decl_stmt|;
comment|/**< "session_end" Filter Enabled (SessEndFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|bvalidfltr
range|:
literal|1
decl_stmt|;
comment|/**< "b_valid" Filter Enabled (BValidFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|avalidfltr
range|:
literal|1
decl_stmt|;
comment|/**< "a_valid" Filter Enabled (AValidFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|vbusvalidfltr
range|:
literal|1
decl_stmt|;
comment|/**< "vbus_valid" Filter Enabled (VBusValidFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|iddgfltr
range|:
literal|1
decl_stmt|;
comment|/**< "iddig" Filter Enable (IddgFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|numctleps
range|:
literal|4
decl_stmt|;
comment|/**< Number of Device Mode Control Endpoints in Addition to                                                          Endpoint 0 (NumCtlEps)                                                          Range: 1-15 */
name|uint32_t
name|phydatawidth
range|:
literal|2
decl_stmt|;
comment|/**< UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width                                                          (PhyDataWidth)                                                          When a ULPI PHY is used, an internal wrapper converts ULPI                                                          to UTMI+.                                                          * 2'b00: 8 bits                                                          * 2'b01: 16 bits                                                          * 2'b10: 8/16 bits, software selectable                                                          * Others: Reserved */
name|uint32_t
name|reserved_6_13
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ahbfreq
range|:
literal|1
decl_stmt|;
comment|/**< Minimum AHB Frequency Less Than 60 MHz (AhbFreq)                                                          * 1'b0: No                                                          * 1'b1: Yes */
name|uint32_t
name|enablepwropt
range|:
literal|1
decl_stmt|;
comment|/**< Enable Power Optimization? (EnablePwrOpt)                                                          * 1'b0: No                                                          * 1'b1: Yes */
name|uint32_t
name|numdevperioeps
range|:
literal|4
decl_stmt|;
comment|/**< Number of Device Mode Periodic IN Endpoints                                                          (NumDevPerioEps)                                                          Range: 0-15 */
else|#
directive|else
name|uint32_t
name|numdevperioeps
range|:
literal|4
decl_stmt|;
name|uint32_t
name|enablepwropt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahbfreq
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_13
range|:
literal|8
decl_stmt|;
name|uint32_t
name|phydatawidth
range|:
literal|2
decl_stmt|;
name|uint32_t
name|numctleps
range|:
literal|4
decl_stmt|;
name|uint32_t
name|iddgfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|vbusvalidfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|avalidfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bvalidfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sessendfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|endedtrfifo
range|:
literal|1
decl_stmt|;
name|uint32_t
name|numdevmodinend
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_usbcx_ghwcfg4_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint32_t
name|sessendfltr
range|:
literal|1
decl_stmt|;
comment|/**< "session_end" Filter Enabled (SessEndFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|bvalidfltr
range|:
literal|1
decl_stmt|;
comment|/**< "b_valid" Filter Enabled (BValidFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|avalidfltr
range|:
literal|1
decl_stmt|;
comment|/**< "a_valid" Filter Enabled (AValidFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|vbusvalidfltr
range|:
literal|1
decl_stmt|;
comment|/**< "vbus_valid" Filter Enabled (VBusValidFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|iddgfltr
range|:
literal|1
decl_stmt|;
comment|/**< "iddig" Filter Enable (IddgFltr)                                                          * 1'b0: No filter                                                          * 1'b1: Filter */
name|uint32_t
name|numctleps
range|:
literal|4
decl_stmt|;
comment|/**< Number of Device Mode Control Endpoints in Addition to                                                          Endpoint 0 (NumCtlEps)                                                          Range: 1-15 */
name|uint32_t
name|phydatawidth
range|:
literal|2
decl_stmt|;
comment|/**< UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width                                                          (PhyDataWidth)                                                          When a ULPI PHY is used, an internal wrapper converts ULPI                                                          to UTMI+.                                                          * 2'b00: 8 bits                                                          * 2'b01: 16 bits                                                          * 2'b10: 8/16 bits, software selectable                                                          * Others: Reserved */
name|uint32_t
name|reserved_6_13
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ahbfreq
range|:
literal|1
decl_stmt|;
comment|/**< Minimum AHB Frequency Less Than 60 MHz (AhbFreq)                                                          * 1'b0: No                                                          * 1'b1: Yes */
name|uint32_t
name|enablepwropt
range|:
literal|1
decl_stmt|;
comment|/**< Enable Power Optimization? (EnablePwrOpt)                                                          * 1'b0: No                                                          * 1'b1: Yes */
name|uint32_t
name|numdevperioeps
range|:
literal|4
decl_stmt|;
comment|/**< Number of Device Mode Periodic IN Endpoints                                                          (NumDevPerioEps)                                                          Range: 0-15 */
else|#
directive|else
name|uint32_t
name|numdevperioeps
range|:
literal|4
decl_stmt|;
name|uint32_t
name|enablepwropt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahbfreq
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_6_13
range|:
literal|8
decl_stmt|;
name|uint32_t
name|phydatawidth
range|:
literal|2
decl_stmt|;
name|uint32_t
name|numctleps
range|:
literal|4
decl_stmt|;
name|uint32_t
name|iddgfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|vbusvalidfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|avalidfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bvalidfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sessendfltr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_usbcx_ghwcfg4_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_ghwcfg4_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_ghwcfg4
name|cvmx_usbcx_ghwcfg4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gintmsk  *  * Core Interrupt Mask Register (GINTMSK)  *  * This register works with the Core Interrupt register to interrupt the application.  * When an interrupt bit is masked, the interrupt associated with that bit will not be generated.  * However, the Core Interrupt (GINTSTS) register bit corresponding to that interrupt will still be set.  * Mask interrupt: 1'b0, Unmask interrupt: 1'b1  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gintmsk
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gintmsk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|wkupintmsk
range|:
literal|1
decl_stmt|;
comment|/**< Resume/Remote Wakeup Detected Interrupt Mask                                                          (WkUpIntMsk) */
name|uint32_t
name|sessreqintmsk
range|:
literal|1
decl_stmt|;
comment|/**< Session Request/New Session Detected Interrupt Mask                                                          (SessReqIntMsk) */
name|uint32_t
name|disconnintmsk
range|:
literal|1
decl_stmt|;
comment|/**< Disconnect Detected Interrupt Mask (DisconnIntMsk) */
name|uint32_t
name|conidstschngmsk
range|:
literal|1
decl_stmt|;
comment|/**< Connector ID Status Change Mask (ConIDStsChngMsk) */
name|uint32_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ptxfempmsk
range|:
literal|1
decl_stmt|;
comment|/**< Periodic TxFIFO Empty Mask (PTxFEmpMsk) */
name|uint32_t
name|hchintmsk
range|:
literal|1
decl_stmt|;
comment|/**< Host Channels Interrupt Mask (HChIntMsk) */
name|uint32_t
name|prtintmsk
range|:
literal|1
decl_stmt|;
comment|/**< Host Port Interrupt Mask (PrtIntMsk) */
name|uint32_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fetsuspmsk
range|:
literal|1
decl_stmt|;
comment|/**< Data Fetch Suspended Mask (FetSuspMsk) */
name|uint32_t
name|incomplpmsk
range|:
literal|1
decl_stmt|;
comment|/**< Incomplete Periodic Transfer Mask (incomplPMsk)                                                          Incomplete Isochronous OUT Transfer Mask                                                          (incompISOOUTMsk) */
name|uint32_t
name|incompisoinmsk
range|:
literal|1
decl_stmt|;
comment|/**< Incomplete Isochronous IN Transfer Mask (incompISOINMsk) */
name|uint32_t
name|oepintmsk
range|:
literal|1
decl_stmt|;
comment|/**< OUT Endpoints Interrupt Mask (OEPIntMsk) */
name|uint32_t
name|inepintmsk
range|:
literal|1
decl_stmt|;
comment|/**< IN Endpoints Interrupt Mask (INEPIntMsk) */
name|uint32_t
name|epmismsk
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Mismatch Interrupt Mask (EPMisMsk) */
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eopfmsk
range|:
literal|1
decl_stmt|;
comment|/**< End of Periodic Frame Interrupt Mask (EOPFMsk) */
name|uint32_t
name|isooutdropmsk
range|:
literal|1
decl_stmt|;
comment|/**< Isochronous OUT Packet Dropped Interrupt Mask                                                          (ISOOutDropMsk) */
name|uint32_t
name|enumdonemsk
range|:
literal|1
decl_stmt|;
comment|/**< Enumeration Done Mask (EnumDoneMsk) */
name|uint32_t
name|usbrstmsk
range|:
literal|1
decl_stmt|;
comment|/**< USB Reset Mask (USBRstMsk) */
name|uint32_t
name|usbsuspmsk
range|:
literal|1
decl_stmt|;
comment|/**< USB Suspend Mask (USBSuspMsk) */
name|uint32_t
name|erlysuspmsk
range|:
literal|1
decl_stmt|;
comment|/**< Early Suspend Mask (ErlySuspMsk) */
name|uint32_t
name|i2cint
range|:
literal|1
decl_stmt|;
comment|/**< I2C Interrupt Mask (I2CINT) */
name|uint32_t
name|ulpickintmsk
range|:
literal|1
decl_stmt|;
comment|/**< ULPI Carkit Interrupt Mask (ULPICKINTMsk)                                                          I2C Carkit Interrupt Mask (I2CCKINTMsk) */
name|uint32_t
name|goutnakeffmsk
range|:
literal|1
decl_stmt|;
comment|/**< Global OUT NAK Effective Mask (GOUTNakEffMsk) */
name|uint32_t
name|ginnakeffmsk
range|:
literal|1
decl_stmt|;
comment|/**< Global Non-Periodic IN NAK Effective Mask (GINNakEffMsk) */
name|uint32_t
name|nptxfempmsk
range|:
literal|1
decl_stmt|;
comment|/**< Non-Periodic TxFIFO Empty Mask (NPTxFEmpMsk) */
name|uint32_t
name|rxflvlmsk
range|:
literal|1
decl_stmt|;
comment|/**< Receive FIFO Non-Empty Mask (RxFLvlMsk) */
name|uint32_t
name|sofmsk
range|:
literal|1
decl_stmt|;
comment|/**< Start of (micro)Frame Mask (SofMsk) */
name|uint32_t
name|otgintmsk
range|:
literal|1
decl_stmt|;
comment|/**< OTG Interrupt Mask (OTGIntMsk) */
name|uint32_t
name|modemismsk
range|:
literal|1
decl_stmt|;
comment|/**< Mode Mismatch Interrupt Mask (ModeMisMsk) */
name|uint32_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint32_t
name|modemismsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|otgintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sofmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rxflvlmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nptxfempmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ginnakeffmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|goutnakeffmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ulpickintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i2cint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|erlysuspmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|usbsuspmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|usbrstmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enumdonemsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|isooutdropmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eopfmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epmismsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|inepintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|oepintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|incompisoinmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|incomplpmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fetsuspmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hchintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ptxfempmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint32_t
name|conidstschngmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|disconnintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sessreqintmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|wkupintmsk
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gintmsk_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintmsk_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintmsk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintmsk_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintmsk_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gintmsk_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintmsk_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gintmsk
name|cvmx_usbcx_gintmsk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gintsts  *  * Core Interrupt Register (GINTSTS)  *  * This register interrupts the application for system-level events in the current mode of operation  * (Device mode or Host mode). It is shown in Interrupt. Some of the bits in this register are valid only in Host mode,  * while others are valid in Device mode only. This register also indicates the current mode of operation.  * In order to clear the interrupt status bits of type R_SS_WC, the application must write 1'b1 into the bit.  * The FIFO status interrupts are read only; once software reads from or writes to the FIFO while servicing these  * interrupts, FIFO interrupt conditions are cleared automatically.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gintsts
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gintsts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|wkupint
range|:
literal|1
decl_stmt|;
comment|/**< Resume/Remote Wakeup Detected Interrupt (WkUpInt)                                                          In Device mode, this interrupt is asserted when a resume is                                                          detected on the USB. In Host mode, this interrupt is asserted                                                          when a remote wakeup is detected on the USB.                                                          For more information on how to use this interrupt, see "Partial                                                          Power-Down and Clock Gating Programming Model" on                                                          page 353. */
name|uint32_t
name|sessreqint
range|:
literal|1
decl_stmt|;
comment|/**< Session Request/New Session Detected Interrupt (SessReqInt)                                                          In Host mode, this interrupt is asserted when a session request                                                          is detected from the device. In Device mode, this interrupt is                                                          asserted when the utmiotg_bvalid signal goes high.                                                          For more information on how to use this interrupt, see "Partial                                                          Power-Down and Clock Gating Programming Model" on                                                          page 353. */
name|uint32_t
name|disconnint
range|:
literal|1
decl_stmt|;
comment|/**< Disconnect Detected Interrupt (DisconnInt)                                                          Asserted when a device disconnect is detected. */
name|uint32_t
name|conidstschng
range|:
literal|1
decl_stmt|;
comment|/**< Connector ID Status Change (ConIDStsChng)                                                          The core sets this bit when there is a change in connector ID                                                          status. */
name|uint32_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ptxfemp
range|:
literal|1
decl_stmt|;
comment|/**< Periodic TxFIFO Empty (PTxFEmp)                                                          Asserted when the Periodic Transmit FIFO is either half or                                                          completely empty and there is space for at least one entry to be                                                          written in the Periodic Request Queue. The half or completely                                                          empty status is determined by the Periodic TxFIFO Empty Level                                                          bit in the Core AHB Configuration register                                                          (GAHBCFG.PTxFEmpLvl). */
name|uint32_t
name|hchint
range|:
literal|1
decl_stmt|;
comment|/**< Host Channels Interrupt (HChInt)                                                          The core sets this bit to indicate that an interrupt is pending on                                                          one of the channels of the core (in Host mode). The application                                                          must read the Host All Channels Interrupt (HAINT) register to                                                          determine the exact number of the channel on which the                                                          interrupt occurred, and then read the corresponding Host                                                          Channel-n Interrupt (HCINTn) register to determine the exact                                                          cause of the interrupt. The application must clear the                                                          appropriate status bit in the HCINTn register to clear this bit. */
name|uint32_t
name|prtint
range|:
literal|1
decl_stmt|;
comment|/**< Host Port Interrupt (PrtInt)                                                          The core sets this bit to indicate a change in port status of one                                                          of the O2P USB core ports in Host mode. The application must                                                          read the Host Port Control and Status (HPRT) register to                                                          determine the exact event that caused this interrupt. The                                                          application must clear the appropriate status bit in the Host Port                                                          Control and Status register to clear this bit. */
name|uint32_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fetsusp
range|:
literal|1
decl_stmt|;
comment|/**< Data Fetch Suspended (FetSusp)                                                          This interrupt is valid only in DMA mode. This interrupt indicates                                                          that the core has stopped fetching data for IN endpoints due to                                                          the unavailability of TxFIFO space or Request Queue space.                                                          This interrupt is used by the application for an endpoint                                                          mismatch algorithm. */
name|uint32_t
name|incomplp
range|:
literal|1
decl_stmt|;
comment|/**< Incomplete Periodic Transfer (incomplP)                                                          In Host mode, the core sets this interrupt bit when there are                                                          incomplete periodic transactions still pending which are                                                          scheduled for the current microframe.                                                          Incomplete Isochronous OUT Transfer (incompISOOUT)                                                          The Device mode, the core sets this interrupt to indicate that                                                          there is at least one isochronous OUT endpoint on which the                                                          transfer is not completed in the current microframe. This                                                          interrupt is asserted along with the End of Periodic Frame                                                          Interrupt (EOPF) bit in this register. */
name|uint32_t
name|incompisoin
range|:
literal|1
decl_stmt|;
comment|/**< Incomplete Isochronous IN Transfer (incompISOIN)                                                          The core sets this interrupt to indicate that there is at least one                                                          isochronous IN endpoint on which the transfer is not completed                                                          in the current microframe. This interrupt is asserted along with                                                          the End of Periodic Frame Interrupt (EOPF) bit in this register. */
name|uint32_t
name|oepint
range|:
literal|1
decl_stmt|;
comment|/**< OUT Endpoints Interrupt (OEPInt)                                                          The core sets this bit to indicate that an interrupt is pending on                                                          one of the OUT endpoints of the core (in Device mode). The                                                          application must read the Device All Endpoints Interrupt                                                          (DAINT) register to determine the exact number of the OUT                                                          endpoint on which the interrupt occurred, and then read the                                                          corresponding Device OUT Endpoint-n Interrupt (DOEPINTn)                                                          register to determine the exact cause of the interrupt. The                                                          application must clear the appropriate status bit in the                                                          corresponding DOEPINTn register to clear this bit. */
name|uint32_t
name|iepint
range|:
literal|1
decl_stmt|;
comment|/**< IN Endpoints Interrupt (IEPInt)                                                          The core sets this bit to indicate that an interrupt is pending on                                                          one of the IN endpoints of the core (in Device mode). The                                                          application must read the Device All Endpoints Interrupt                                                          (DAINT) register to determine the exact number of the IN                                                          endpoint on which the interrupt occurred, and then read the                                                          corresponding Device IN Endpoint-n Interrupt (DIEPINTn)                                                          register to determine the exact cause of the interrupt. The                                                          application must clear the appropriate status bit in the                                                          corresponding DIEPINTn register to clear this bit. */
name|uint32_t
name|epmis
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Mismatch Interrupt (EPMis)                                                          Indicates that an IN token has been received for a non-periodic                                                          endpoint, but the data for another endpoint is present in the top                                                          of the Non-Periodic Transmit FIFO and the IN endpoint                                                          mismatch count programmed by the application has expired. */
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eopf
range|:
literal|1
decl_stmt|;
comment|/**< End of Periodic Frame Interrupt (EOPF)                                                          Indicates that the period specified in the Periodic Frame Interval                                                          field of the Device Configuration register (DCFG.PerFrInt) has                                                          been reached in the current microframe. */
name|uint32_t
name|isooutdrop
range|:
literal|1
decl_stmt|;
comment|/**< Isochronous OUT Packet Dropped Interrupt (ISOOutDrop)                                                          The core sets this bit when it fails to write an isochronous OUT                                                          packet into the RxFIFO because the RxFIFO doesn't have                                                          enough space to accommodate a maximum packet size packet                                                          for the isochronous OUT endpoint. */
name|uint32_t
name|enumdone
range|:
literal|1
decl_stmt|;
comment|/**< Enumeration Done (EnumDone)                                                          The core sets this bit to indicate that speed enumeration is                                                          complete. The application must read the Device Status (DSTS)                                                          register to obtain the enumerated speed. */
name|uint32_t
name|usbrst
range|:
literal|1
decl_stmt|;
comment|/**< USB Reset (USBRst)                                                          The core sets this bit to indicate that a reset is detected on the                                                          USB. */
name|uint32_t
name|usbsusp
range|:
literal|1
decl_stmt|;
comment|/**< USB Suspend (USBSusp)                                                          The core sets this bit to indicate that a suspend was detected                                                          on the USB. The core enters the Suspended state when there                                                          is no activity on the phy_line_state_i signal for an extended                                                          period of time. */
name|uint32_t
name|erlysusp
range|:
literal|1
decl_stmt|;
comment|/**< Early Suspend (ErlySusp)                                                          The core sets this bit to indicate that an Idle state has been                                                          detected on the USB for 3 ms. */
name|uint32_t
name|i2cint
range|:
literal|1
decl_stmt|;
comment|/**< I2C Interrupt (I2CINT)                                                          This bit is always 0x0. */
name|uint32_t
name|ulpickint
range|:
literal|1
decl_stmt|;
comment|/**< ULPI Carkit Interrupt (ULPICKINT)                                                          This bit is always 0x0. */
name|uint32_t
name|goutnakeff
range|:
literal|1
decl_stmt|;
comment|/**< Global OUT NAK Effective (GOUTNakEff)                                                          Indicates that the Set Global OUT NAK bit in the Device Control                                                          register (DCTL.SGOUTNak), set by the application, has taken                                                          effect in the core. This bit can be cleared by writing the Clear                                                          Global OUT NAK bit in the Device Control register                                                          (DCTL.CGOUTNak). */
name|uint32_t
name|ginnakeff
range|:
literal|1
decl_stmt|;
comment|/**< Global IN Non-Periodic NAK Effective (GINNakEff)                                                          Indicates that the Set Global Non-Periodic IN NAK bit in the                                                          Device Control register (DCTL.SGNPInNak), set by the                                                          application, has taken effect in the core. That is, the core has                                                          sampled the Global IN NAK bit set by the application. This bit                                                          can be cleared by clearing the Clear Global Non-Periodic IN                                                          NAK bit in the Device Control register (DCTL.CGNPInNak).                                                          This interrupt does not necessarily mean that a NAK handshake                                                          is sent out on the USB. The STALL bit takes precedence over                                                          the NAK bit. */
name|uint32_t
name|nptxfemp
range|:
literal|1
decl_stmt|;
comment|/**< Non-Periodic TxFIFO Empty (NPTxFEmp)                                                          This interrupt is asserted when the Non-Periodic TxFIFO is                                                          either half or completely empty, and there is space for at least                                                          one entry to be written to the Non-Periodic Transmit Request                                                          Queue. The half or completely empty status is determined by                                                          the Non-Periodic TxFIFO Empty Level bit in the Core AHB                                                          Configuration register (GAHBCFG.NPTxFEmpLvl). */
name|uint32_t
name|rxflvl
range|:
literal|1
decl_stmt|;
comment|/**< RxFIFO Non-Empty (RxFLvl)                                                          Indicates that there is at least one packet pending to be read                                                          from the RxFIFO. */
name|uint32_t
name|sof
range|:
literal|1
decl_stmt|;
comment|/**< Start of (micro)Frame (Sof)                                                          In Host mode, the core sets this bit to indicate that an SOF                                                          (FS), micro-SOF (HS), or Keep-Alive (LS) is transmitted on the                                                          USB. The application must write a 1 to this bit to clear the                                                          interrupt.                                                          In Device mode, in the core sets this bit to indicate that an SOF                                                          token has been received on the USB. The application can read                                                          the Device Status register to get the current (micro)frame                                                          number. This interrupt is seen only when the core is operating                                                          at either HS or FS. */
name|uint32_t
name|otgint
range|:
literal|1
decl_stmt|;
comment|/**< OTG Interrupt (OTGInt)                                                          The core sets this bit to indicate an OTG protocol event. The                                                          application must read the OTG Interrupt Status (GOTGINT)                                                          register to determine the exact event that caused this interrupt.                                                          The application must clear the appropriate status bit in the                                                          GOTGINT register to clear this bit. */
name|uint32_t
name|modemis
range|:
literal|1
decl_stmt|;
comment|/**< Mode Mismatch Interrupt (ModeMis)                                                          The core sets this bit when the application is trying to access:                                                          * A Host mode register, when the core is operating in Device                                                          mode                                                          * A Device mode register, when the core is operating in Host                                                            mode                                                            The register access is completed on the AHB with an OKAY                                                            response, but is ignored by the core internally and doesn't                                                          affect the operation of the core. */
name|uint32_t
name|curmod
range|:
literal|1
decl_stmt|;
comment|/**< Current Mode of Operation (CurMod)                                                          Indicates the current mode of operation.                                                          * 1'b0: Device mode                                                          * 1'b1: Host mode */
else|#
directive|else
name|uint32_t
name|curmod
range|:
literal|1
decl_stmt|;
name|uint32_t
name|modemis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|otgint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sof
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rxflvl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nptxfemp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ginnakeff
range|:
literal|1
decl_stmt|;
name|uint32_t
name|goutnakeff
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ulpickint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|i2cint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|erlysusp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|usbsusp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|usbrst
range|:
literal|1
decl_stmt|;
name|uint32_t
name|enumdone
range|:
literal|1
decl_stmt|;
name|uint32_t
name|isooutdrop
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eopf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epmis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|iepint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|oepint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|incompisoin
range|:
literal|1
decl_stmt|;
name|uint32_t
name|incomplp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fetsusp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hchint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ptxfemp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint32_t
name|conidstschng
range|:
literal|1
decl_stmt|;
name|uint32_t
name|disconnint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sessreqint
range|:
literal|1
decl_stmt|;
name|uint32_t
name|wkupint
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gintsts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintsts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintsts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintsts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintsts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gintsts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gintsts_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gintsts
name|cvmx_usbcx_gintsts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gnptxfsiz  *  * Non-Periodic Transmit FIFO Size Register (GNPTXFSIZ)  *  * The application can program the RAM size and the memory start address for the Non-Periodic TxFIFO.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gnptxfsiz
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gnptxfsiz_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|nptxfdep
range|:
literal|16
decl_stmt|;
comment|/**< Non-Periodic TxFIFO Depth (NPTxFDep)                                                          This value is in terms of 32-bit words.                                                          Minimum value is 16                                                          Maximum value is 32768 */
name|uint32_t
name|nptxfstaddr
range|:
literal|16
decl_stmt|;
comment|/**< Non-Periodic Transmit RAM Start Address (NPTxFStAddr)                                                          This field contains the memory start address for Non-Periodic                                                          Transmit FIFO RAM. */
else|#
directive|else
name|uint32_t
name|nptxfstaddr
range|:
literal|16
decl_stmt|;
name|uint32_t
name|nptxfdep
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gnptxfsiz_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxfsiz_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxfsiz_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxfsiz_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxfsiz_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxfsiz_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxfsiz_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gnptxfsiz
name|cvmx_usbcx_gnptxfsiz_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gnptxsts  *  * Non-Periodic Transmit FIFO/Queue Status Register (GNPTXSTS)  *  * This read-only register contains the free space information for the Non-Periodic TxFIFO and  * the Non-Periodic Transmit Request Queue  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gnptxsts
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gnptxsts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nptxqtop
range|:
literal|7
decl_stmt|;
comment|/**< Top of the Non-Periodic Transmit Request Queue (NPTxQTop)                                                          Entry in the Non-Periodic Tx Request Queue that is currently                                                          being processed by the MAC.                                                          * Bits [30:27]: Channel/endpoint number                                                          * Bits [26:25]:                                                            - 2'b00: IN/OUT token                                                            - 2'b01: Zero-length transmit packet (device IN/host OUT)                                                            - 2'b10: PING/CSPLIT token                                                            - 2'b11: Channel halt command                                                          * Bit [24]: Terminate (last entry for selected channel/endpoint) */
name|uint32_t
name|nptxqspcavail
range|:
literal|8
decl_stmt|;
comment|/**< Non-Periodic Transmit Request Queue Space Available                                                          (NPTxQSpcAvail)                                                          Indicates the amount of free space available in the Non-                                                          Periodic Transmit Request Queue. This queue holds both IN                                                          and OUT requests in Host mode. Device mode has only IN                                                          requests.                                                          * 8'h0: Non-Periodic Transmit Request Queue is full                                                          * 8'h1: 1 location available                                                          * 8'h2: 2 locations available                                                          * n: n locations available (0..8)                                                          * Others: Reserved */
name|uint32_t
name|nptxfspcavail
range|:
literal|16
decl_stmt|;
comment|/**< Non-Periodic TxFIFO Space Avail (NPTxFSpcAvail)                                                          Indicates the amount of free space available in the Non-                                                          Periodic TxFIFO.                                                          Values are in terms of 32-bit words.                                                          * 16'h0: Non-Periodic TxFIFO is full                                                          * 16'h1: 1 word available                                                          * 16'h2: 2 words available                                                          * 16'hn: n words available (where 0..32768)                                                          * 16'h8000: 32768 words available                                                          * Others: Reserved */
else|#
directive|else
name|uint32_t
name|nptxfspcavail
range|:
literal|16
decl_stmt|;
name|uint32_t
name|nptxqspcavail
range|:
literal|8
decl_stmt|;
name|uint32_t
name|nptxqtop
range|:
literal|7
decl_stmt|;
name|uint32_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gnptxsts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxsts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxsts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxsts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxsts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxsts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gnptxsts_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gnptxsts
name|cvmx_usbcx_gnptxsts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gotgctl  *  * OTG Control and Status Register (GOTGCTL)  *  * The OTG Control and Status register controls the behavior and reflects the status of the OTG function of the core.:  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gotgctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gotgctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint32_t
name|bsesvld
range|:
literal|1
decl_stmt|;
comment|/**< B-Session Valid (BSesVld)                                                          Valid only when O2P USB core is configured as a USB device.                                                          Indicates the Device mode transceiver status.                                                          * 1'b0: B-session is not valid.                                                          * 1'b1: B-session is valid. */
name|uint32_t
name|asesvld
range|:
literal|1
decl_stmt|;
comment|/**< A-Session Valid (ASesVld)                                                          Valid only when O2P USB core is configured as a USB host.                                                          Indicates the Host mode transceiver status.                                                          * 1'b0: A-session is not valid                                                          * 1'b1: A-session is valid */
name|uint32_t
name|dbnctime
range|:
literal|1
decl_stmt|;
comment|/**< Long/Short Debounce Time (DbncTime)                                                          In the present version of the core this bit will only read as '0'. */
name|uint32_t
name|conidsts
range|:
literal|1
decl_stmt|;
comment|/**< Connector ID Status (ConIDSts)                                                          Indicates the connector ID status on a connect event.                                                          * 1'b0: The O2P USB core is in A-device mode                                                          * 1'b1: The O2P USB core is in B-device mode */
name|uint32_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint32_t
name|devhnpen
range|:
literal|1
decl_stmt|;
comment|/**< Device HNP Enabled (DevHNPEn)                                                          Since O2P USB core is not HNP capable this bit is 0x0. */
name|uint32_t
name|hstsethnpen
range|:
literal|1
decl_stmt|;
comment|/**< Host Set HNP Enable (HstSetHNPEn)                                                          Since O2P USB core is not HNP capable this bit is 0x0. */
name|uint32_t
name|hnpreq
range|:
literal|1
decl_stmt|;
comment|/**< HNP Request (HNPReq)                                                          Since O2P USB core is not HNP capable this bit is 0x0. */
name|uint32_t
name|hstnegscs
range|:
literal|1
decl_stmt|;
comment|/**< Host Negotiation Success (HstNegScs)                                                          Since O2P USB core is not HNP capable this bit is 0x0. */
name|uint32_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint32_t
name|sesreq
range|:
literal|1
decl_stmt|;
comment|/**< Session Request (SesReq)                                                          Since O2P USB core is not SRP capable this bit is 0x0. */
name|uint32_t
name|sesreqscs
range|:
literal|1
decl_stmt|;
comment|/**< Session Request Success (SesReqScs)                                                          Since O2P USB core is not SRP capable this bit is 0x0. */
else|#
directive|else
name|uint32_t
name|sesreqscs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|sesreq
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint32_t
name|hstnegscs
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hnpreq
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hstsethnpen
range|:
literal|1
decl_stmt|;
name|uint32_t
name|devhnpen
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint32_t
name|conidsts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dbnctime
range|:
literal|1
decl_stmt|;
name|uint32_t
name|asesvld
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bsesvld
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gotgctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gotgctl
name|cvmx_usbcx_gotgctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gotgint  *  * OTG Interrupt Register (GOTGINT)  *  * The application reads this register whenever there is an OTG interrupt and clears the bits in this register  * to clear the OTG interrupt. It is shown in Interrupt .:  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gotgint
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gotgint_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint32_t
name|dbncedone
range|:
literal|1
decl_stmt|;
comment|/**< Debounce Done (DbnceDone)                                                          In the present version of the code this bit is tied to '0'. */
name|uint32_t
name|adevtoutchg
range|:
literal|1
decl_stmt|;
comment|/**< A-Device Timeout Change (ADevTOUTChg)                                                          Since O2P USB core is not HNP or SRP capable this bit is always 0x0. */
name|uint32_t
name|hstnegdet
range|:
literal|1
decl_stmt|;
comment|/**< Host Negotiation Detected (HstNegDet)                                                          Since O2P USB core is not HNP or SRP capable this bit is always 0x0. */
name|uint32_t
name|reserved_10_16
range|:
literal|7
decl_stmt|;
name|uint32_t
name|hstnegsucstschng
range|:
literal|1
decl_stmt|;
comment|/**< Host Negotiation Success Status Change (HstNegSucStsChng)                                                          Since O2P USB core is not HNP or SRP capable this bit is always 0x0. */
name|uint32_t
name|sesreqsucstschng
range|:
literal|1
decl_stmt|;
comment|/**< Session Request Success Status Change                                                          Since O2P USB core is not HNP or SRP capable this bit is always 0x0. */
name|uint32_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint32_t
name|sesenddet
range|:
literal|1
decl_stmt|;
comment|/**< Session End Detected (SesEndDet)                                                          Since O2P USB core is not HNP or SRP capable this bit is always 0x0. */
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint32_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint32_t
name|sesenddet
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint32_t
name|sesreqsucstschng
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hstnegsucstschng
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_10_16
range|:
literal|7
decl_stmt|;
name|uint32_t
name|hstnegdet
range|:
literal|1
decl_stmt|;
name|uint32_t
name|adevtoutchg
range|:
literal|1
decl_stmt|;
name|uint32_t
name|dbncedone
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gotgint_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgint_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgint_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgint_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgint_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgint_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gotgint_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gotgint
name|cvmx_usbcx_gotgint_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_grstctl  *  * Core Reset Register (GRSTCTL)  *  * The application uses this register to reset various hardware features inside the core.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_grstctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_grstctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|ahbidle
range|:
literal|1
decl_stmt|;
comment|/**< AHB Master Idle (AHBIdle)                                                          Indicates that the AHB Master State Machine is in the IDLE                                                          condition. */
name|uint32_t
name|dmareq
range|:
literal|1
decl_stmt|;
comment|/**< DMA Request Signal (DMAReq)                                                          Indicates that the DMA request is in progress. Used for debug. */
name|uint32_t
name|reserved_11_29
range|:
literal|19
decl_stmt|;
name|uint32_t
name|txfnum
range|:
literal|5
decl_stmt|;
comment|/**< TxFIFO Number (TxFNum)                                                          This is the FIFO number that must be flushed using the TxFIFO                                                          Flush bit. This field must not be changed until the core clears                                                          the TxFIFO Flush bit.                                                          * 5'h0: Non-Periodic TxFIFO flush                                                          * 5'h1: Periodic TxFIFO 1 flush in Device mode or Periodic                                                          TxFIFO flush in Host mode                                                          * 5'h2: Periodic TxFIFO 2 flush in Device mode                                                          - ...                                                          * 5'hF: Periodic TxFIFO 15 flush in Device mode                                                          * 5'h10: Flush all the Periodic and Non-Periodic TxFIFOs in the                                                          core */
name|uint32_t
name|txfflsh
range|:
literal|1
decl_stmt|;
comment|/**< TxFIFO Flush (TxFFlsh)                                                          This bit selectively flushes a single or all transmit FIFOs, but                                                          cannot do so if the core is in the midst of a transaction.                                                          The application must only write this bit after checking that the                                                          core is neither writing to the TxFIFO nor reading from the                                                          TxFIFO.                                                          The application must wait until the core clears this bit before                                                          performing any operations. This bit takes 8 clocks (of phy_clk or                                                          hclk, whichever is slower) to clear. */
name|uint32_t
name|rxfflsh
range|:
literal|1
decl_stmt|;
comment|/**< RxFIFO Flush (RxFFlsh)                                                          The application can flush the entire RxFIFO using this bit, but                                                          must first ensure that the core is not in the middle of a                                                          transaction.                                                          The application must only write to this bit after checking that the                                                          core is neither reading from the RxFIFO nor writing to the                                                          RxFIFO.                                                          The application must wait until the bit is cleared before                                                          performing any other operations. This bit will take 8 clocks                                                          (slowest of PHY or AHB clock) to clear. */
name|uint32_t
name|intknqflsh
range|:
literal|1
decl_stmt|;
comment|/**< IN Token Sequence Learning Queue Flush (INTknQFlsh)                                                          The application writes this bit to flush the IN Token Sequence                                                          Learning Queue. */
name|uint32_t
name|frmcntrrst
range|:
literal|1
decl_stmt|;
comment|/**< Host Frame Counter Reset (FrmCntrRst)                                                          The application writes this bit to reset the (micro)frame number                                                          counter inside the core. When the (micro)frame counter is reset,                                                          the subsequent SOF sent out by the core will have a                                                          (micro)frame number of 0. */
name|uint32_t
name|hsftrst
range|:
literal|1
decl_stmt|;
comment|/**< HClk Soft Reset (HSftRst)                                                          The application uses this bit to flush the control logic in the AHB                                                          Clock domain. Only AHB Clock Domain pipelines are reset.                                                          * FIFOs are not flushed with this bit.                                                          * All state machines in the AHB clock domain are reset to the                                                            Idle state after terminating the transactions on the AHB,                                                            following the protocol.                                                          * CSR control bits used by the AHB clock domain state                                                            machines are cleared.                                                          * To clear this interrupt, status mask bits that control the                                                            interrupt status and are generated by the AHB clock domain                                                            state machine are cleared.                                                          * Because interrupt status bits are not cleared, the application                                                            can get the status of any core events that occurred after it set                                                            this bit.                                                            This is a self-clearing bit that the core clears after all necessary                                                            logic is reset in the core. This may take several clocks,                                                            depending on the core's current state. */
name|uint32_t
name|csftrst
range|:
literal|1
decl_stmt|;
comment|/**< Core Soft Reset (CSftRst)                                                          Resets the hclk and phy_clock domains as follows:                                                          * Clears the interrupts and all the CSR registers except the                                                            following register bits:                                                            - PCGCCTL.RstPdwnModule                                                            - PCGCCTL.GateHclk                                                            - PCGCCTL.PwrClmp                                                            - PCGCCTL.StopPPhyLPwrClkSelclk                                                            - GUSBCFG.PhyLPwrClkSel                                                            - GUSBCFG.DDRSel                                                            - GUSBCFG.PHYSel                                                            - GUSBCFG.FSIntf                                                            - GUSBCFG.ULPI_UTMI_Sel                                                            - GUSBCFG.PHYIf                                                            - HCFG.FSLSPclkSel                                                            - DCFG.DevSpd                                                          * All module state machines (except the AHB Slave Unit) are                                                            reset to the IDLE state, and all the transmit FIFOs and the                                                            receive FIFO are flushed.                                                          * Any transactions on the AHB Master are terminated as soon                                                            as possible, after gracefully completing the last data phase of                                                            an AHB transfer. Any transactions on the USB are terminated                                                            immediately.                                                            The application can write to this bit any time it wants to reset                                                            the core. This is a self-clearing bit and the core clears this bit                                                            after all the necessary logic is reset in the core, which may take                                                            several clocks, depending on the current state of the core.                                                            Once this bit is cleared software should wait at least 3 PHY                                                            clocks before doing any access to the PHY domain                                                            (synchronization delay). Software should also should check that                                                            bit 31 of this register is 1 (AHB Master is IDLE) before starting                                                            any operation.                                                            Typically software reset is used during software development                                                            and also when you dynamically change the PHY selection bits                                                            in the USB configuration registers listed above. When you                                                            change the PHY, the corresponding clock for the PHY is                                                            selected and used in the PHY domain. Once a new clock is                                                            selected, the PHY domain has to be reset for proper operation. */
else|#
directive|else
name|uint32_t
name|csftrst
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hsftrst
range|:
literal|1
decl_stmt|;
name|uint32_t
name|frmcntrrst
range|:
literal|1
decl_stmt|;
name|uint32_t
name|intknqflsh
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rxfflsh
range|:
literal|1
decl_stmt|;
name|uint32_t
name|txfflsh
range|:
literal|1
decl_stmt|;
name|uint32_t
name|txfnum
range|:
literal|5
decl_stmt|;
name|uint32_t
name|reserved_11_29
range|:
literal|19
decl_stmt|;
name|uint32_t
name|dmareq
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahbidle
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_grstctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grstctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grstctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grstctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grstctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_grstctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grstctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_grstctl
name|cvmx_usbcx_grstctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_grxfsiz  *  * Receive FIFO Size Register (GRXFSIZ)  *  * The application can program the RAM size that must be allocated to the RxFIFO.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_grxfsiz
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_grxfsiz_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|rxfdep
range|:
literal|16
decl_stmt|;
comment|/**< RxFIFO Depth (RxFDep)                                                          This value is in terms of 32-bit words.                                                          * Minimum value is 16                                                          * Maximum value is 32768 */
else|#
directive|else
name|uint32_t
name|rxfdep
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_grxfsiz_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxfsiz_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxfsiz_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxfsiz_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxfsiz_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_grxfsiz_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxfsiz_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_grxfsiz
name|cvmx_usbcx_grxfsiz_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_grxstspd  *  * Receive Status Debug Read Register, Device Mode (GRXSTSPD)  *  * A read to the Receive Status Read and Pop register returns and additionally pops the top data entry out of the RxFIFO.  * This Description is only valid when the core is in Device Mode.  For Host Mode use USBC_GRXSTSPH instead.  * NOTE: GRXSTSPH and GRXSTSPD are physically the same register and share the same offset in the O2P USB core.  *       The offset difference shown in this document is for software clarity and is actually ignored by the  *       hardware.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_grxstspd
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_grxstspd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint32_t
name|fn
range|:
literal|4
decl_stmt|;
comment|/**< Frame Number (FN)                                                          This is the least significant 4 bits of the (micro)frame number in                                                          which the packet is received on the USB.  This field is supported                                                          only when the isochronous OUT endpoints are supported. */
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
comment|/**< Packet Status (PktSts)                                                          Indicates the status of the received packet                                                          * 4'b0001: Glogal OUT NAK (triggers an interrupt)                                                          * 4'b0010: OUT data packet received                                                          * 4'b0100: SETUP transaction completed (triggers an interrupt)                                                          * 4'b0110: SETUP data packet received                                                          * Others: Reserved */
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
comment|/**< Data PID (DPID)                                                          * 2'b00: DATA0                                                          * 2'b10: DATA1                                                          * 2'b01: DATA2                                                          * 2'b11: MDATA */
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
comment|/**< Byte Count (BCnt)                                                          Indicates the byte count of the received data packet */
name|uint32_t
name|epnum
range|:
literal|4
decl_stmt|;
comment|/**< Endpoint Number (EPNum)                                                          Indicates the endpoint number to which the current received                                                          packet belongs. */
else|#
directive|else
name|uint32_t
name|epnum
range|:
literal|4
decl_stmt|;
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
name|uint32_t
name|fn
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_grxstspd_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstspd_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstspd_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstspd_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstspd_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstspd_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstspd_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_grxstspd
name|cvmx_usbcx_grxstspd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_grxstsph  *  * Receive Status Read and Pop Register, Host Mode (GRXSTSPH)  *  * A read to the Receive Status Read and Pop register returns and additionally pops the top data entry out of the RxFIFO.  * This Description is only valid when the core is in Host Mode.  For Device Mode use USBC_GRXSTSPD instead.  * NOTE: GRXSTSPH and GRXSTSPD are physically the same register and share the same offset in the O2P USB core.  *       The offset difference shown in this document is for software clarity and is actually ignored by the  *       hardware.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_grxstsph
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_grxstsph_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
comment|/**< Packet Status (PktSts)                                                          Indicates the status of the received packet                                                          * 4'b0010: IN data packet received                                                          * 4'b0011: IN transfer completed (triggers an interrupt)                                                          * 4'b0101: Data toggle error (triggers an interrupt)                                                          * 4'b0111: Channel halted (triggers an interrupt)                                                          * Others: Reserved */
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
comment|/**< Data PID (DPID)                                                          * 2'b00: DATA0                                                          * 2'b10: DATA1                                                          * 2'b01: DATA2                                                          * 2'b11: MDATA */
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
comment|/**< Byte Count (BCnt)                                                          Indicates the byte count of the received IN data packet */
name|uint32_t
name|chnum
range|:
literal|4
decl_stmt|;
comment|/**< Channel Number (ChNum)                                                          Indicates the channel number to which the current received                                                          packet belongs. */
else|#
directive|else
name|uint32_t
name|chnum
range|:
literal|4
decl_stmt|;
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_grxstsph_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsph_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsph_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsph_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsph_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsph_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsph_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_grxstsph
name|cvmx_usbcx_grxstsph_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_grxstsrd  *  * Receive Status Debug Read Register, Device Mode (GRXSTSRD)  *  * A read to the Receive Status Debug Read register returns the contents of the top of the Receive FIFO.  * This Description is only valid when the core is in Device Mode.  For Host Mode use USBC_GRXSTSRH instead.  * NOTE: GRXSTSRH and GRXSTSRD are physically the same register and share the same offset in the O2P USB core.  *       The offset difference shown in this document is for software clarity and is actually ignored by the  *       hardware.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_grxstsrd
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_grxstsrd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint32_t
name|fn
range|:
literal|4
decl_stmt|;
comment|/**< Frame Number (FN)                                                          This is the least significant 4 bits of the (micro)frame number in                                                          which the packet is received on the USB.  This field is supported                                                          only when the isochronous OUT endpoints are supported. */
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
comment|/**< Packet Status (PktSts)                                                          Indicates the status of the received packet                                                          * 4'b0001: Glogal OUT NAK (triggers an interrupt)                                                          * 4'b0010: OUT data packet received                                                          * 4'b0100: SETUP transaction completed (triggers an interrupt)                                                          * 4'b0110: SETUP data packet received                                                          * Others: Reserved */
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
comment|/**< Data PID (DPID)                                                          * 2'b00: DATA0                                                          * 2'b10: DATA1                                                          * 2'b01: DATA2                                                          * 2'b11: MDATA */
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
comment|/**< Byte Count (BCnt)                                                          Indicates the byte count of the received data packet */
name|uint32_t
name|epnum
range|:
literal|4
decl_stmt|;
comment|/**< Endpoint Number (EPNum)                                                          Indicates the endpoint number to which the current received                                                          packet belongs. */
else|#
directive|else
name|uint32_t
name|epnum
range|:
literal|4
decl_stmt|;
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
name|uint32_t
name|fn
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_grxstsrd_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrd_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrd_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrd_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrd_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrd_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrd_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_grxstsrd
name|cvmx_usbcx_grxstsrd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_grxstsrh  *  * Receive Status Debug Read Register, Host Mode (GRXSTSRH)  *  * A read to the Receive Status Debug Read register returns the contents of the top of the Receive FIFO.  * This Description is only valid when the core is in Host Mode.  For Device Mode use USBC_GRXSTSRD instead.  * NOTE: GRXSTSRH and GRXSTSRD are physically the same register and share the same offset in the O2P USB core.  *       The offset difference shown in this document is for software clarity and is actually ignored by the  *       hardware.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_grxstsrh
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_grxstsrh_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
comment|/**< Packet Status (PktSts)                                                          Indicates the status of the received packet                                                          * 4'b0010: IN data packet received                                                          * 4'b0011: IN transfer completed (triggers an interrupt)                                                          * 4'b0101: Data toggle error (triggers an interrupt)                                                          * 4'b0111: Channel halted (triggers an interrupt)                                                          * Others: Reserved */
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
comment|/**< Data PID (DPID)                                                          * 2'b00: DATA0                                                          * 2'b10: DATA1                                                          * 2'b01: DATA2                                                          * 2'b11: MDATA */
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
comment|/**< Byte Count (BCnt)                                                          Indicates the byte count of the received IN data packet */
name|uint32_t
name|chnum
range|:
literal|4
decl_stmt|;
comment|/**< Channel Number (ChNum)                                                          Indicates the channel number to which the current received                                                          packet belongs. */
else|#
directive|else
name|uint32_t
name|chnum
range|:
literal|4
decl_stmt|;
name|uint32_t
name|bcnt
range|:
literal|11
decl_stmt|;
name|uint32_t
name|dpid
range|:
literal|2
decl_stmt|;
name|uint32_t
name|pktsts
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_21_31
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_grxstsrh_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrh_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrh_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrh_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrh_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrh_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_grxstsrh_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_grxstsrh
name|cvmx_usbcx_grxstsrh_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gsnpsid  *  * Synopsys ID Register (GSNPSID)  *  * This is a read-only register that contains the release number of the core being used.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gsnpsid
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gsnpsid_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|synopsysid
range|:
literal|32
decl_stmt|;
comment|/**< 0x4F54\<version\>A, release number of the core being used.                                                          0x4F54220A => pass1.x,  0x4F54240A => pass2.x */
else|#
directive|else
name|uint32_t
name|synopsysid
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gsnpsid_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gsnpsid_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gsnpsid_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gsnpsid_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gsnpsid_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gsnpsid_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gsnpsid_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gsnpsid
name|cvmx_usbcx_gsnpsid_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_gusbcfg  *  * Core USB Configuration Register (GUSBCFG)  *  * This register can be used to configure the core after power-on or a changing to Host mode or Device mode.  * It contains USB and USB-PHY related configuration parameters. The application must program this register  * before starting any transactions on either the AHB or the USB.  * Do not make changes to this register after the initial programming.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_gusbcfg
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_gusbcfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint32_t
name|otgi2csel
range|:
literal|1
decl_stmt|;
comment|/**< UTMIFS or I2C Interface Select (OtgI2CSel)                                                          This bit is always 0x0. */
name|uint32_t
name|phylpwrclksel
range|:
literal|1
decl_stmt|;
comment|/**< PHY Low-Power Clock Select (PhyLPwrClkSel)                                                          Software should set this bit to 0x0.                                                          Selects either 480-MHz or 48-MHz (low-power) PHY mode. In                                                          FS and LS modes, the PHY can usually operate on a 48-MHz                                                          clock to save power.                                                          * 1'b0: 480-MHz Internal PLL clock                                                          * 1'b1: 48-MHz External Clock                                                          In 480 MHz mode, the UTMI interface operates at either 60 or                                                          30-MHz, depending upon whether 8- or 16-bit data width is                                                          selected. In 48-MHz mode, the UTMI interface operates at 48                                                          MHz in FS mode and at either 48 or 6 MHz in LS mode                                                          (depending on the PHY vendor).                                                          This bit drives the utmi_fsls_low_power core output signal, and                                                          is valid only for UTMI+ PHYs. */
name|uint32_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint32_t
name|usbtrdtim
range|:
literal|4
decl_stmt|;
comment|/**< USB Turnaround Time (USBTrdTim)                                                          Sets the turnaround time in PHY clocks.                                                          Specifies the response time for a MAC request to the Packet                                                          FIFO Controller (PFC) to fetch data from the DFIFO (SPRAM).                                                          This must be programmed to 0x5. */
name|uint32_t
name|hnpcap
range|:
literal|1
decl_stmt|;
comment|/**< HNP-Capable (HNPCap)                                                          This bit is always 0x0. */
name|uint32_t
name|srpcap
range|:
literal|1
decl_stmt|;
comment|/**< SRP-Capable (SRPCap)                                                          This bit is always 0x0. */
name|uint32_t
name|ddrsel
range|:
literal|1
decl_stmt|;
comment|/**< ULPI DDR Select (DDRSel)                                                          Software should set this bit to 0x0. */
name|uint32_t
name|physel
range|:
literal|1
decl_stmt|;
comment|/**< USB 2.0 High-Speed PHY or USB 1.1 Full-Speed Serial                                                          Software should set this bit to 0x0. */
name|uint32_t
name|fsintf
range|:
literal|1
decl_stmt|;
comment|/**< Full-Speed Serial Interface Select (FSIntf)                                                          Software should set this bit to 0x0. */
name|uint32_t
name|ulpi_utmi_sel
range|:
literal|1
decl_stmt|;
comment|/**< ULPI or UTMI+ Select (ULPI_UTMI_Sel)                                                          This bit is always 0x0. */
name|uint32_t
name|phyif
range|:
literal|1
decl_stmt|;
comment|/**< PHY Interface (PHYIf)                                                          This bit is always 0x1. */
name|uint32_t
name|toutcal
range|:
literal|3
decl_stmt|;
comment|/**< HS/FS Timeout Calibration (TOutCal)                                                          The number of PHY clocks that the application programs in this                                                          field is added to the high-speed/full-speed interpacket timeout                                                          duration in the core to account for any additional delays                                                          introduced by the PHY. This may be required, since the delay                                                          introduced by the PHY in generating the linestate condition may                                                          vary from one PHY to another.                                                          The USB standard timeout value for high-speed operation is                                                          736 to 816 (inclusive) bit times. The USB standard timeout                                                          value for full-speed operation is 16 to 18 (inclusive) bit times.                                                          The application must program this field based on the speed of                                                          enumeration. The number of bit times added per PHY clock are:                                                          High-speed operation:                                                          * One 30-MHz PHY clock = 16 bit times                                                          * One 60-MHz PHY clock = 8 bit times                                                          Full-speed operation:                                                          * One 30-MHz PHY clock = 0.4 bit times                                                          * One 60-MHz PHY clock = 0.2 bit times                                                          * One 48-MHz PHY clock = 0.25 bit times */
else|#
directive|else
name|uint32_t
name|toutcal
range|:
literal|3
decl_stmt|;
name|uint32_t
name|phyif
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ulpi_utmi_sel
range|:
literal|1
decl_stmt|;
name|uint32_t
name|fsintf
range|:
literal|1
decl_stmt|;
name|uint32_t
name|physel
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ddrsel
range|:
literal|1
decl_stmt|;
name|uint32_t
name|srpcap
range|:
literal|1
decl_stmt|;
name|uint32_t
name|hnpcap
range|:
literal|1
decl_stmt|;
name|uint32_t
name|usbtrdtim
range|:
literal|4
decl_stmt|;
name|uint32_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint32_t
name|phylpwrclksel
range|:
literal|1
decl_stmt|;
name|uint32_t
name|otgi2csel
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_gusbcfg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gusbcfg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gusbcfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gusbcfg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gusbcfg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_gusbcfg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_gusbcfg_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_gusbcfg
name|cvmx_usbcx_gusbcfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_haint  *  * Host All Channels Interrupt Register (HAINT)  *  * When a significant event occurs on a channel, the Host All Channels Interrupt register  * interrupts the application using the Host Channels Interrupt bit of the Core Interrupt  * register (GINTSTS.HChInt). This is shown in Interrupt . There is one interrupt bit per  * channel, up to a maximum of 16 bits. Bits in this register are set and cleared when the  * application sets and clears bits in the corresponding Host Channel-n Interrupt register.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_haint
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_haint_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|haint
range|:
literal|16
decl_stmt|;
comment|/**< Channel Interrupts (HAINT)                                                          One bit per channel: Bit 0 for Channel 0, bit 15 for Channel 15 */
else|#
directive|else
name|uint32_t
name|haint
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_haint_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haint_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haint_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haint_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haint_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_haint_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haint_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_haint
name|cvmx_usbcx_haint_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_haintmsk  *  * Host All Channels Interrupt Mask Register (HAINTMSK)  *  * The Host All Channel Interrupt Mask register works with the Host All Channel Interrupt  * register to interrupt the application when an event occurs on a channel. There is one  * interrupt mask bit per channel, up to a maximum of 16 bits.  * Mask interrupt: 1'b0 Unmask interrupt: 1'b1  */
end_comment

begin_union
union|union
name|cvmx_usbcx_haintmsk
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_haintmsk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|haintmsk
range|:
literal|16
decl_stmt|;
comment|/**< Channel Interrupt Mask (HAINTMsk)                                                          One bit per channel: Bit 0 for channel 0, bit 15 for channel 15 */
else|#
directive|else
name|uint32_t
name|haintmsk
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_haintmsk_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haintmsk_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haintmsk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haintmsk_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haintmsk_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_haintmsk_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_haintmsk_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_haintmsk
name|cvmx_usbcx_haintmsk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hcchar#  *  * Host Channel-n Characteristics Register (HCCHAR)  *  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hccharx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hccharx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|chena
range|:
literal|1
decl_stmt|;
comment|/**< Channel Enable (ChEna)                                                          This field is set by the application and cleared by the OTG host.                                                          * 1'b0: Channel disabled                                                          * 1'b1: Channel enabled */
name|uint32_t
name|chdis
range|:
literal|1
decl_stmt|;
comment|/**< Channel Disable (ChDis)                                                          The application sets this bit to stop transmitting/receiving data                                                          on a channel, even before the transfer for that channel is                                                          complete. The application must wait for the Channel Disabled                                                          interrupt before treating the channel as disabled. */
name|uint32_t
name|oddfrm
range|:
literal|1
decl_stmt|;
comment|/**< Odd Frame (OddFrm)                                                          This field is set (reset) by the application to indicate that the                                                          OTG host must perform a transfer in an odd (micro)frame. This                                                          field is applicable for only periodic (isochronous and interrupt)                                                          transactions.                                                          * 1'b0: Even (micro)frame                                                          * 1'b1: Odd (micro)frame */
name|uint32_t
name|devaddr
range|:
literal|7
decl_stmt|;
comment|/**< Device Address (DevAddr)                                                          This field selects the specific device serving as the data source                                                          or sink. */
name|uint32_t
name|ec
range|:
literal|2
decl_stmt|;
comment|/**< Multi Count (MC) / Error Count (EC)                                                          When the Split Enable bit of the Host Channel-n Split Control                                                          register (HCSPLTn.SpltEna) is reset (1'b0), this field indicates                                                          to the host the number of transactions that should be executed                                                          per microframe for this endpoint.                                                          * 2'b00: Reserved. This field yields undefined results.                                                          * 2'b01: 1 transaction                                                          * 2'b10: 2 transactions to be issued for this endpoint per                                                                   microframe                                                          * 2'b11: 3 transactions to be issued for this endpoint per                                                                   microframe                                                          When HCSPLTn.SpltEna is set (1'b1), this field indicates the                                                          number of immediate retries to be performed for a periodic split                                                          transactions on transaction errors. This field must be set to at                                                          least 2'b01. */
name|uint32_t
name|eptype
range|:
literal|2
decl_stmt|;
comment|/**< Endpoint Type (EPType)                                                          Indicates the transfer type selected.                                                          * 2'b00: Control                                                          * 2'b01: Isochronous                                                          * 2'b10: Bulk                                                          * 2'b11: Interrupt */
name|uint32_t
name|lspddev
range|:
literal|1
decl_stmt|;
comment|/**< Low-Speed Device (LSpdDev)                                                          This field is set by the application to indicate that this channel is                                                          communicating to a low-speed device. */
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|epdir
range|:
literal|1
decl_stmt|;
comment|/**< Endpoint Direction (EPDir)                                                          Indicates whether the transaction is IN or OUT.                                                          * 1'b0: OUT                                                          * 1'b1: IN */
name|uint32_t
name|epnum
range|:
literal|4
decl_stmt|;
comment|/**< Endpoint Number (EPNum)                                                          Indicates the endpoint number on the device serving as the                                                          data source or sink. */
name|uint32_t
name|mps
range|:
literal|11
decl_stmt|;
comment|/**< Maximum Packet Size (MPS)                                                          Indicates the maximum packet size of the associated endpoint. */
else|#
directive|else
name|uint32_t
name|mps
range|:
literal|11
decl_stmt|;
name|uint32_t
name|epnum
range|:
literal|4
decl_stmt|;
name|uint32_t
name|epdir
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_16_16
range|:
literal|1
decl_stmt|;
name|uint32_t
name|lspddev
range|:
literal|1
decl_stmt|;
name|uint32_t
name|eptype
range|:
literal|2
decl_stmt|;
name|uint32_t
name|ec
range|:
literal|2
decl_stmt|;
name|uint32_t
name|devaddr
range|:
literal|7
decl_stmt|;
name|uint32_t
name|oddfrm
range|:
literal|1
decl_stmt|;
name|uint32_t
name|chdis
range|:
literal|1
decl_stmt|;
name|uint32_t
name|chena
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hccharx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hccharx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hccharx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hccharx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hccharx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hccharx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hccharx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hccharx
name|cvmx_usbcx_hccharx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hcfg  *  * Host Configuration Register (HCFG)  *  * This register configures the core after power-on. Do not make changes to this register after initializing the host.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hcfg
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hcfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
name|uint32_t
name|fslssupp
range|:
literal|1
decl_stmt|;
comment|/**< FS- and LS-Only Support (FSLSSupp)                                                          The application uses this bit to control the core's enumeration                                                          speed. Using this bit, the application can make the core                                                          enumerate as a FS host, even if the connected device supports                                                          HS traffic. Do not make changes to this field after initial                                                          programming.                                                          * 1'b0: HS/FS/LS, based on the maximum speed supported by                                                            the connected device                                                          * 1'b1: FS/LS-only, even if the connected device can support HS */
name|uint32_t
name|fslspclksel
range|:
literal|2
decl_stmt|;
comment|/**< FS/LS PHY Clock Select (FSLSPclkSel)                                                          When the core is in FS Host mode                                                          * 2'b00: PHY clock is running at 30/60 MHz                                                          * 2'b01: PHY clock is running at 48 MHz                                                          * Others: Reserved                                                          When the core is in LS Host mode                                                          * 2'b00: PHY clock is running at 30/60 MHz. When the                                                                   UTMI+/ULPI PHY Low Power mode is not selected, use                                                                   30/60 MHz.                                                          * 2'b01: PHY clock is running at 48 MHz. When the UTMI+                                                                   PHY Low Power mode is selected, use 48MHz if the PHY                                                                   supplies a 48 MHz clock during LS mode.                                                          * 2'b10: PHY clock is running at 6 MHz. In USB 1.1 FS mode,                                                                   use 6 MHz when the UTMI+ PHY Low Power mode is                                                                   selected and the PHY supplies a 6 MHz clock during LS                                                                   mode. If you select a 6 MHz clock during LS mode, you must                                                                   do a soft reset.                                                          * 2'b11: Reserved */
else|#
directive|else
name|uint32_t
name|fslspclksel
range|:
literal|2
decl_stmt|;
name|uint32_t
name|fslssupp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_3_31
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hcfg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcfg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcfg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcfg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hcfg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcfg_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hcfg
name|cvmx_usbcx_hcfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hcint#  *  * Host Channel-n Interrupt Register (HCINT)  *  * This register indicates the status of a channel with respect to USB- and AHB-related events.  * The application must read this register when the Host Channels Interrupt bit of the Core Interrupt  * register (GINTSTS.HChInt) is set. Before the application can read this register, it must first read  * the Host All Channels Interrupt (HAINT) register to get the exact channel number for the Host Channel-n  * Interrupt register. The application must clear the appropriate bit in this register to clear the  * corresponding bits in the HAINT and GINTSTS registers.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hcintx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hcintx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_11_31
range|:
literal|21
decl_stmt|;
name|uint32_t
name|datatglerr
range|:
literal|1
decl_stmt|;
comment|/**< Data Toggle Error (DataTglErr) */
name|uint32_t
name|frmovrun
range|:
literal|1
decl_stmt|;
comment|/**< Frame Overrun (FrmOvrun) */
name|uint32_t
name|bblerr
range|:
literal|1
decl_stmt|;
comment|/**< Babble Error (BblErr) */
name|uint32_t
name|xacterr
range|:
literal|1
decl_stmt|;
comment|/**< Transaction Error (XactErr) */
name|uint32_t
name|nyet
range|:
literal|1
decl_stmt|;
comment|/**< NYET Response Received Interrupt (NYET) */
name|uint32_t
name|ack
range|:
literal|1
decl_stmt|;
comment|/**< ACK Response Received Interrupt (ACK) */
name|uint32_t
name|nak
range|:
literal|1
decl_stmt|;
comment|/**< NAK Response Received Interrupt (NAK) */
name|uint32_t
name|stall
range|:
literal|1
decl_stmt|;
comment|/**< STALL Response Received Interrupt (STALL) */
name|uint32_t
name|ahberr
range|:
literal|1
decl_stmt|;
comment|/**< This bit is always 0x0. */
name|uint32_t
name|chhltd
range|:
literal|1
decl_stmt|;
comment|/**< Channel Halted (ChHltd)                                                          Indicates the transfer completed abnormally either because of                                                          any USB transaction error or in response to disable request by                                                          the application. */
name|uint32_t
name|xfercompl
range|:
literal|1
decl_stmt|;
comment|/**< Transfer Completed (XferCompl)                                                          Transfer completed normally without any errors. */
else|#
directive|else
name|uint32_t
name|xfercompl
range|:
literal|1
decl_stmt|;
name|uint32_t
name|chhltd
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahberr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|stall
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nak
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ack
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nyet
range|:
literal|1
decl_stmt|;
name|uint32_t
name|xacterr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bblerr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|frmovrun
range|:
literal|1
decl_stmt|;
name|uint32_t
name|datatglerr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_11_31
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hcintx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hcintx
name|cvmx_usbcx_hcintx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hcintmsk#  *  * Host Channel-n Interrupt Mask Register (HCINTMSKn)  *  * This register reflects the mask for each channel status described in the previous section.  * Mask interrupt: 1'b0 Unmask interrupt: 1'b1  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hcintmskx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hcintmskx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_11_31
range|:
literal|21
decl_stmt|;
name|uint32_t
name|datatglerrmsk
range|:
literal|1
decl_stmt|;
comment|/**< Data Toggle Error Mask (DataTglErrMsk) */
name|uint32_t
name|frmovrunmsk
range|:
literal|1
decl_stmt|;
comment|/**< Frame Overrun Mask (FrmOvrunMsk) */
name|uint32_t
name|bblerrmsk
range|:
literal|1
decl_stmt|;
comment|/**< Babble Error Mask (BblErrMsk) */
name|uint32_t
name|xacterrmsk
range|:
literal|1
decl_stmt|;
comment|/**< Transaction Error Mask (XactErrMsk) */
name|uint32_t
name|nyetmsk
range|:
literal|1
decl_stmt|;
comment|/**< NYET Response Received Interrupt Mask (NyetMsk) */
name|uint32_t
name|ackmsk
range|:
literal|1
decl_stmt|;
comment|/**< ACK Response Received Interrupt Mask (AckMsk) */
name|uint32_t
name|nakmsk
range|:
literal|1
decl_stmt|;
comment|/**< NAK Response Received Interrupt Mask (NakMsk) */
name|uint32_t
name|stallmsk
range|:
literal|1
decl_stmt|;
comment|/**< STALL Response Received Interrupt Mask (StallMsk) */
name|uint32_t
name|ahberrmsk
range|:
literal|1
decl_stmt|;
comment|/**< AHB Error Mask (AHBErrMsk) */
name|uint32_t
name|chhltdmsk
range|:
literal|1
decl_stmt|;
comment|/**< Channel Halted Mask (ChHltdMsk) */
name|uint32_t
name|xfercomplmsk
range|:
literal|1
decl_stmt|;
comment|/**< Transfer Completed Mask (XferComplMsk) */
else|#
directive|else
name|uint32_t
name|xfercomplmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|chhltdmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ahberrmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|stallmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nakmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|ackmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|nyetmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|xacterrmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|bblerrmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|frmovrunmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|datatglerrmsk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_11_31
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hcintmskx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintmskx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintmskx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintmskx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintmskx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintmskx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcintmskx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hcintmskx
name|cvmx_usbcx_hcintmskx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hcsplt#  *  * Host Channel-n Split Control Register (HCSPLT)  *  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hcspltx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hcspltx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|spltena
range|:
literal|1
decl_stmt|;
comment|/**< Split Enable (SpltEna)                                                          The application sets this field to indicate that this channel is                                                          enabled to perform split transactions. */
name|uint32_t
name|reserved_17_30
range|:
literal|14
decl_stmt|;
name|uint32_t
name|compsplt
range|:
literal|1
decl_stmt|;
comment|/**< Do Complete Split (CompSplt)                                                          The application sets this field to request the OTG host to                                                          perform a complete split transaction. */
name|uint32_t
name|xactpos
range|:
literal|2
decl_stmt|;
comment|/**< Transaction Position (XactPos)                                                          This field is used to determine whether to send all, first, middle,                                                          or last payloads with each OUT transaction.                                                          * 2'b11: All. This is the entire data payload is of this transaction                                                                   (which is less than or equal to 188 bytes).                                                          * 2'b10: Begin. This is the first data payload of this transaction                                                                   (which is larger than 188 bytes).                                                          * 2'b00: Mid. This is the middle payload of this transaction                                                                   (which is larger than 188 bytes).                                                          * 2'b01: End. This is the last payload of this transaction (which                                                                   is larger than 188 bytes). */
name|uint32_t
name|hubaddr
range|:
literal|7
decl_stmt|;
comment|/**< Hub Address (HubAddr)                                                          This field holds the device address of the transaction                                                          translator's hub. */
name|uint32_t
name|prtaddr
range|:
literal|7
decl_stmt|;
comment|/**< Port Address (PrtAddr)                                                          This field is the port number of the recipient transaction                                                          translator. */
else|#
directive|else
name|uint32_t
name|prtaddr
range|:
literal|7
decl_stmt|;
name|uint32_t
name|hubaddr
range|:
literal|7
decl_stmt|;
name|uint32_t
name|xactpos
range|:
literal|2
decl_stmt|;
name|uint32_t
name|compsplt
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_17_30
range|:
literal|14
decl_stmt|;
name|uint32_t
name|spltena
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hcspltx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcspltx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcspltx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcspltx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcspltx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hcspltx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hcspltx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hcspltx
name|cvmx_usbcx_hcspltx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hctsiz#  *  * Host Channel-n Transfer Size Register (HCTSIZ)  *  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hctsizx
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hctsizx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|dopng
range|:
literal|1
decl_stmt|;
comment|/**< Do Ping (DoPng)                                                          Setting this field to 1 directs the host to do PING protocol. */
name|uint32_t
name|pid
range|:
literal|2
decl_stmt|;
comment|/**< PID (Pid)                                                          The application programs this field with the type of PID to use                                                          for the initial transaction. The host will maintain this field for the                                                          rest of the transfer.                                                          * 2'b00: DATA0                                                          * 2'b01: DATA2                                                          * 2'b10: DATA1                                                          * 2'b11: MDATA (non-control)/SETUP (control) */
name|uint32_t
name|pktcnt
range|:
literal|10
decl_stmt|;
comment|/**< Packet Count (PktCnt)                                                          This field is programmed by the application with the expected                                                          number of packets to be transmitted (OUT) or received (IN).                                                          The host decrements this count on every successful                                                          transmission or reception of an OUT/IN packet. Once this count                                                          reaches zero, the application is interrupted to indicate normal                                                          completion. */
name|uint32_t
name|xfersize
range|:
literal|19
decl_stmt|;
comment|/**< Transfer Size (XferSize)                                                          For an OUT, this field is the number of data bytes the host will                                                          send during the transfer.                                                          For an IN, this field is the buffer size that the application has                                                          reserved for the transfer. The application is expected to                                                          program this field as an integer multiple of the maximum packet                                                          size for IN transactions (periodic and non-periodic). */
else|#
directive|else
name|uint32_t
name|xfersize
range|:
literal|19
decl_stmt|;
name|uint32_t
name|pktcnt
range|:
literal|10
decl_stmt|;
name|uint32_t
name|pid
range|:
literal|2
decl_stmt|;
name|uint32_t
name|dopng
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hctsizx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hctsizx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hctsizx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hctsizx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hctsizx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hctsizx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hctsizx_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hctsizx
name|cvmx_usbcx_hctsizx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hfir  *  * Host Frame Interval Register (HFIR)  *  * This register stores the frame interval information for the current speed to which the O2P USB core has enumerated.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hfir
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hfir_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint32_t
name|frint
range|:
literal|16
decl_stmt|;
comment|/**< Frame Interval (FrInt)                                                          The value that the application programs to this field specifies                                                          the interval between two consecutive SOFs (FS) or micro-                                                          SOFs (HS) or Keep-Alive tokens (HS). This field contains the                                                          number of PHY clocks that constitute the required frame                                                          interval. The default value set in this field for a FS operation                                                          when the PHY clock frequency is 60 MHz. The application can                                                          write a value to this register only after the Port Enable bit of                                                          the Host Port Control and Status register (HPRT.PrtEnaPort)                                                          has been set. If no value is programmed, the core calculates                                                          the value based on the PHY clock specified in the FS/LS PHY                                                          Clock Select field of the Host Configuration register                                                          (HCFG.FSLSPclkSel). Do not change the value of this field                                                          after the initial configuration.                                                          * 125 us (PHY clock frequency for HS)                                                          * 1 ms (PHY clock frequency for FS/LS) */
else|#
directive|else
name|uint32_t
name|frint
range|:
literal|16
decl_stmt|;
name|uint32_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hfir_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfir_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfir_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfir_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfir_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hfir_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfir_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hfir
name|cvmx_usbcx_hfir_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hfnum  *  * Host Frame Number/Frame Time Remaining Register (HFNUM)  *  * This register indicates the current frame number.  * It also indicates the time remaining (in terms of the number of PHY clocks)  * in the current (micro)frame.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hfnum
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hfnum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|frrem
range|:
literal|16
decl_stmt|;
comment|/**< Frame Time Remaining (FrRem)                                                          Indicates the amount of time remaining in the current                                                          microframe (HS) or frame (FS/LS), in terms of PHY clocks.                                                          This field decrements on each PHY clock. When it reaches                                                          zero, this field is reloaded with the value in the Frame Interval                                                          register and a new SOF is transmitted on the USB. */
name|uint32_t
name|frnum
range|:
literal|16
decl_stmt|;
comment|/**< Frame Number (FrNum)                                                          This field increments when a new SOF is transmitted on the                                                          USB, and is reset to 0 when it reaches 16'h3FFF. */
else|#
directive|else
name|uint32_t
name|frnum
range|:
literal|16
decl_stmt|;
name|uint32_t
name|frrem
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hfnum_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfnum_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfnum_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfnum_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfnum_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hfnum_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hfnum_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hfnum
name|cvmx_usbcx_hfnum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hprt  *  * Host Port Control and Status Register (HPRT)  *  * This register is available in both Host and Device modes.  * Currently, the OTG Host supports only one port.  * A single register holds USB port-related information such as USB reset, enable, suspend, resume,  * connect status, and test mode for each port. The R_SS_WC bits in this register can trigger an  * interrupt to the application through the Host Port Interrupt bit of the Core Interrupt  * register (GINTSTS.PrtInt). On a Port Interrupt, the application must read this register and clear  * the bit that caused the interrupt. For the R_SS_WC bits, the application must write a 1 to the bit  * to clear the interrupt.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hprt
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hprt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_19_31
range|:
literal|13
decl_stmt|;
name|uint32_t
name|prtspd
range|:
literal|2
decl_stmt|;
comment|/**< Port Speed (PrtSpd)                                                          Indicates the speed of the device attached to this port.                                                          * 2'b00: High speed                                                          * 2'b01: Full speed                                                          * 2'b10: Low speed                                                          * 2'b11: Reserved */
name|uint32_t
name|prttstctl
range|:
literal|4
decl_stmt|;
comment|/**< Port Test Control (PrtTstCtl)                                                          The application writes a nonzero value to this field to put                                                          the port into a Test mode, and the corresponding pattern is                                                          signaled on the port.                                                          * 4'b0000: Test mode disabled                                                          * 4'b0001: Test_J mode                                                          * 4'b0010: Test_K mode                                                          * 4'b0011: Test_SE0_NAK mode                                                          * 4'b0100: Test_Packet mode                                                          * 4'b0101: Test_Force_Enable                                                          * Others: Reserved                                                          PrtSpd must be zero (i.e. the interface must be in high-speed                                                          mode) to use the PrtTstCtl test modes. */
name|uint32_t
name|prtpwr
range|:
literal|1
decl_stmt|;
comment|/**< Port Power (PrtPwr)                                                          The application uses this field to control power to this port,                                                          and the core clears this bit on an overcurrent condition.                                                          * 1'b0: Power off                                                          * 1'b1: Power on */
name|uint32_t
name|prtlnsts
range|:
literal|2
decl_stmt|;
comment|/**< Port Line Status (PrtLnSts)                                                          Indicates the current logic level USB data lines                                                          * Bit [10]: Logic level of D-                                                          * Bit [11]: Logic level of D+ */
name|uint32_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtrst
range|:
literal|1
decl_stmt|;
comment|/**< Port Reset (PrtRst)                                                          When the application sets this bit, a reset sequence is                                                          started on this port. The application must time the reset                                                          period and clear this bit after the reset sequence is                                                          complete.                                                          * 1'b0: Port not in reset                                                          * 1'b1: Port in reset                                                          The application must leave this bit set for at least a                                                          minimum duration mentioned below to start a reset on the                                                          port. The application can leave it set for another 10 ms in                                                          addition to the required minimum duration, before clearing                                                          the bit, even though there is no maximum limit set by the                                                          USB standard.                                                          * High speed: 50 ms                                                          * Full speed/Low speed: 10 ms */
name|uint32_t
name|prtsusp
range|:
literal|1
decl_stmt|;
comment|/**< Port Suspend (PrtSusp)                                                          The application sets this bit to put this port in Suspend                                                          mode. The core only stops sending SOFs when this is set.                                                          To stop the PHY clock, the application must set the Port                                                          Clock Stop bit, which will assert the suspend input pin of                                                          the PHY.                                                          The read value of this bit reflects the current suspend                                                          status of the port. This bit is cleared by the core after a                                                          remote wakeup signal is detected or the application sets                                                          the Port Reset bit or Port Resume bit in this register or the                                                          Resume/Remote Wakeup Detected Interrupt bit or                                                          Disconnect Detected Interrupt bit in the Core Interrupt                                                          register (GINTSTS.WkUpInt or GINTSTS.DisconnInt,                                                          respectively).                                                          * 1'b0: Port not in Suspend mode                                                          * 1'b1: Port in Suspend mode */
name|uint32_t
name|prtres
range|:
literal|1
decl_stmt|;
comment|/**< Port Resume (PrtRes)                                                          The application sets this bit to drive resume signaling on                                                          the port. The core continues to drive the resume signal                                                          until the application clears this bit.                                                          If the core detects a USB remote wakeup sequence, as                                                          indicated by the Port Resume/Remote Wakeup Detected                                                          Interrupt bit of the Core Interrupt register                                                          (GINTSTS.WkUpInt), the core starts driving resume                                                          signaling without application intervention and clears this bit                                                          when it detects a disconnect condition. The read value of                                                          this bit indicates whether the core is currently driving                                                          resume signaling.                                                          * 1'b0: No resume driven                                                          * 1'b1: Resume driven */
name|uint32_t
name|prtovrcurrchng
range|:
literal|1
decl_stmt|;
comment|/**< Port Overcurrent Change (PrtOvrCurrChng)                                                          The core sets this bit when the status of the Port                                                          Overcurrent Active bit (bit 4) in this register changes. */
name|uint32_t
name|prtovrcurract
range|:
literal|1
decl_stmt|;
comment|/**< Port Overcurrent Active (PrtOvrCurrAct)                                                          Indicates the overcurrent condition of the port.                                                          * 1'b0: No overcurrent condition                                                          * 1'b1: Overcurrent condition */
name|uint32_t
name|prtenchng
range|:
literal|1
decl_stmt|;
comment|/**< Port Enable/Disable Change (PrtEnChng)                                                          The core sets this bit when the status of the Port Enable bit                                                          [2] of this register changes. */
name|uint32_t
name|prtena
range|:
literal|1
decl_stmt|;
comment|/**< Port Enable (PrtEna)                                                          A port is enabled only by the core after a reset sequence,                                                          and is disabled by an overcurrent condition, a disconnect                                                          condition, or by the application clearing this bit. The                                                          application cannot set this bit by a register write. It can only                                                          clear it to disable the port. This bit does not trigger any                                                          interrupt to the application.                                                          * 1'b0: Port disabled                                                          * 1'b1: Port enabled */
name|uint32_t
name|prtconndet
range|:
literal|1
decl_stmt|;
comment|/**< Port Connect Detected (PrtConnDet)                                                          The core sets this bit when a device connection is detected                                                          to trigger an interrupt to the application using the Host Port                                                          Interrupt bit of the Core Interrupt register (GINTSTS.PrtInt).                                                          The application must write a 1 to this bit to clear the                                                          interrupt. */
name|uint32_t
name|prtconnsts
range|:
literal|1
decl_stmt|;
comment|/**< Port Connect Status (PrtConnSts)                                                          * 0: No device is attached to the port.                                                          * 1: A device is attached to the port. */
else|#
directive|else
name|uint32_t
name|prtconnsts
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtconndet
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtena
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtenchng
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtovrcurract
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtovrcurrchng
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtres
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtsusp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtrst
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prtlnsts
range|:
literal|2
decl_stmt|;
name|uint32_t
name|prtpwr
range|:
literal|1
decl_stmt|;
name|uint32_t
name|prttstctl
range|:
literal|4
decl_stmt|;
name|uint32_t
name|prtspd
range|:
literal|2
decl_stmt|;
name|uint32_t
name|reserved_19_31
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hprt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hprt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hprt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hprt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hprt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hprt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hprt_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hprt
name|cvmx_usbcx_hprt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hptxfsiz  *  * Host Periodic Transmit FIFO Size Register (HPTXFSIZ)  *  * This register holds the size and the memory start address of the Periodic TxFIFO, as shown in Figures 310 and 311.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hptxfsiz
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hptxfsiz_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|ptxfsize
range|:
literal|16
decl_stmt|;
comment|/**< Host Periodic TxFIFO Depth (PTxFSize)                                                          This value is in terms of 32-bit words.                                                          * Minimum value is 16                                                          * Maximum value is 32768 */
name|uint32_t
name|ptxfstaddr
range|:
literal|16
decl_stmt|;
comment|/**< Host Periodic TxFIFO Start Address (PTxFStAddr) */
else|#
directive|else
name|uint32_t
name|ptxfstaddr
range|:
literal|16
decl_stmt|;
name|uint32_t
name|ptxfsize
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hptxfsiz_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxfsiz_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxfsiz_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxfsiz_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxfsiz_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxfsiz_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxfsiz_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hptxfsiz
name|cvmx_usbcx_hptxfsiz_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_hptxsts  *  * Host Periodic Transmit FIFO/Queue Status Register (HPTXSTS)  *  * This read-only register contains the free space information for the Periodic TxFIFO and  * the Periodic Transmit Request Queue  */
end_comment

begin_union
union|union
name|cvmx_usbcx_hptxsts
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_hptxsts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|ptxqtop
range|:
literal|8
decl_stmt|;
comment|/**< Top of the Periodic Transmit Request Queue (PTxQTop)                                                          This indicates the entry in the Periodic Tx Request Queue that                                                          is currently being processes by the MAC.                                                          This register is used for debugging.                                                          * Bit [31]: Odd/Even (micro)frame                                                            - 1'b0: send in even (micro)frame                                                            - 1'b1: send in odd (micro)frame                                                          * Bits [30:27]: Channel/endpoint number                                                          * Bits [26:25]: Type                                                            - 2'b00: IN/OUT                                                            - 2'b01: Zero-length packet                                                            - 2'b10: CSPLIT                                                            - 2'b11: Disable channel command                                                          * Bit [24]: Terminate (last entry for the selected                                                            channel/endpoint) */
name|uint32_t
name|ptxqspcavail
range|:
literal|8
decl_stmt|;
comment|/**< Periodic Transmit Request Queue Space Available                                                          (PTxQSpcAvail)                                                          Indicates the number of free locations available to be written in                                                          the Periodic Transmit Request Queue. This queue holds both                                                          IN and OUT requests.                                                          * 8'h0: Periodic Transmit Request Queue is full                                                          * 8'h1: 1 location available                                                          * 8'h2: 2 locations available                                                          * n: n locations available (0..8)                                                          * Others: Reserved */
name|uint32_t
name|ptxfspcavail
range|:
literal|16
decl_stmt|;
comment|/**< Periodic Transmit Data FIFO Space Available (PTxFSpcAvail)                                                          Indicates the number of free locations available to be written to                                                          in the Periodic TxFIFO.                                                          Values are in terms of 32-bit words                                                          * 16'h0: Periodic TxFIFO is full                                                          * 16'h1: 1 word available                                                          * 16'h2: 2 words available                                                          * 16'hn: n words available (where 0..32768)                                                          * 16'h8000: 32768 words available                                                          * Others: Reserved */
else|#
directive|else
name|uint32_t
name|ptxfspcavail
range|:
literal|16
decl_stmt|;
name|uint32_t
name|ptxqspcavail
range|:
literal|8
decl_stmt|;
name|uint32_t
name|ptxqtop
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_hptxsts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxsts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxsts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxsts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxsts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxsts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_hptxsts_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_hptxsts
name|cvmx_usbcx_hptxsts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_nptxdfifo#  *  * NPTX Data Fifo (NPTXDFIFO)  *  * A slave mode application uses this register to access the Tx FIFO for channel n.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_nptxdfifox
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_nptxdfifox_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|data
range|:
literal|32
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint32_t
name|data
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_nptxdfifox_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_nptxdfifox_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_nptxdfifox_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_nptxdfifox_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_nptxdfifox_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_nptxdfifox_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_nptxdfifox_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_nptxdfifox
name|cvmx_usbcx_nptxdfifox_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_usbc#_pcgcctl  *  * Power and Clock Gating Control Register (PCGCCTL)  *  * The application can use this register to control the core's power-down and clock gating features.  */
end_comment

begin_union
union|union
name|cvmx_usbcx_pcgcctl
block|{
name|uint32_t
name|u32
decl_stmt|;
struct|struct
name|cvmx_usbcx_pcgcctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
name|uint32_t
name|physuspended
range|:
literal|1
decl_stmt|;
comment|/**< PHY Suspended. (PhySuspended)                                                          Indicates that the PHY has been suspended. After the                                                          application sets the Stop Pclk bit (bit 0), this bit is updated once                                                          the PHY is suspended.                                                          Since the UTMI+ PHY suspend is controlled through a port, the                                                          UTMI+ PHY is suspended immediately after Stop Pclk is set.                                                          However, the ULPI PHY takes a few clocks to suspend,                                                          because the suspend information is conveyed through the ULPI                                                          protocol to the ULPI PHY. */
name|uint32_t
name|rstpdwnmodule
range|:
literal|1
decl_stmt|;
comment|/**< Reset Power-Down Modules (RstPdwnModule)                                                          This bit is valid only in Partial Power-Down mode. The                                                          application sets this bit when the power is turned off. The                                                          application clears this bit after the power is turned on and the                                                          PHY clock is up. */
name|uint32_t
name|pwrclmp
range|:
literal|1
decl_stmt|;
comment|/**< Power Clamp (PwrClmp)                                                          This bit is only valid in Partial Power-Down mode. The                                                          application sets this bit before the power is turned off to clamp                                                          the signals between the power-on modules and the power-off                                                          modules. The application clears the bit to disable the clamping                                                          before the power is turned on. */
name|uint32_t
name|gatehclk
range|:
literal|1
decl_stmt|;
comment|/**< Gate Hclk (GateHclk)                                                          The application sets this bit to gate hclk to modules other than                                                          the AHB Slave and Master and wakeup logic when the USB is                                                          suspended or the session is not valid. The application clears                                                          this bit when the USB is resumed or a new session starts. */
name|uint32_t
name|stoppclk
range|:
literal|1
decl_stmt|;
comment|/**< Stop Pclk (StopPclk)                                                          The application sets this bit to stop the PHY clock (phy_clk)                                                          when the USB is suspended, the session is not valid, or the                                                          device is disconnected. The application clears this bit when the                                                          USB is resumed or a new session starts. */
else|#
directive|else
name|uint32_t
name|stoppclk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|gatehclk
range|:
literal|1
decl_stmt|;
name|uint32_t
name|pwrclmp
range|:
literal|1
decl_stmt|;
name|uint32_t
name|rstpdwnmodule
range|:
literal|1
decl_stmt|;
name|uint32_t
name|physuspended
range|:
literal|1
decl_stmt|;
name|uint32_t
name|reserved_5_31
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_usbcx_pcgcctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_usbcx_pcgcctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_usbcx_pcgcctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_usbcx_pcgcctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_usbcx_pcgcctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_usbcx_pcgcctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_usbcx_pcgcctl_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_usbcx_pcgcctl
name|cvmx_usbcx_pcgcctl_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

