begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * "cvmx-usbd.c" defines a set of low level USB functions to help  * developers create Octeon USB devices for various operating  * systems. These functions provide a generic API to the Octeon  * USB blocks, hiding the internal hardware specific  * operations.  *  *<hr>$Revision: 32636 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sysinfo.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-usbnx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-usbcx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-usbd.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-swap.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-board.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-clock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-usbd.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_comment
comment|/**  * @INTERNAL  * Read a USB 32bit CSR. It performs the necessary address swizzle for 32bit  * CSRs.  *  * @param usb     USB device state populated by  *                cvmx_usbd_initialize().  * @param address 64bit address to read  *  * @return Result of the read  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|__cvmx_usbd_read_csr32
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|)
block|{
name|uint32_t
name|result
init|=
name|cvmx_read64_uint32
argument_list|(
name|address
operator|^
literal|4
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a USB 32bit CSR. It performs the necessary address swizzle for 32bit  * CSRs.  *  * @param usb     USB device state populated by  *                cvmx_usbd_initialize().  * @param address 64bit address to write  * @param value   Value to write  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_usbd_write_csr32
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|cvmx_write64_uint32
argument_list|(
name|address
operator|^
literal|4
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|cvmx_read64_uint64
argument_list|(
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Calls the user supplied callback when an event happens.  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param reason Reason for the callback  * @param endpoint_num  *               Endpoint number  * @param bytes_transferred  *               Bytes transferred  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_usbd_callback
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usbd_callback_t
name|reason
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|int
name|bytes_transferred
parameter_list|)
block|{
if|if
condition|(
name|usb
operator|->
name|callback
index|[
name|reason
index|]
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Calling callback reason=%d endpoint=%d bytes=%d func=%p data=%p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reason
argument_list|,
name|endpoint_num
argument_list|,
name|bytes_transferred
argument_list|,
name|usb
operator|->
name|callback
index|[
name|reason
index|]
argument_list|,
name|usb
operator|->
name|callback_data
index|[
name|reason
index|]
argument_list|)
expr_stmt|;
name|usb
operator|->
name|callback
index|[
name|reason
index|]
operator|(
name|reason
operator|,
name|endpoint_num
operator|,
name|bytes_transferred
operator|,
name|usb
operator|->
name|callback_data
index|[
name|reason
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: No callback for reason=%d endpoint=%d bytes=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reason
argument_list|,
name|endpoint_num
argument_list|,
name|bytes_transferred
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Perform USB device mode initialization after a reset completes.  * This should be called after USBC0/1_GINTSTS[USBRESET] and  * corresponds to section 22.6.1.1, "Initialization on USB Reset",  * in the manual.  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  *  * @return Zero or negative on error.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usbd_device_reset_complete
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_ghwcfg2_t
name|usbcx_ghwcfg2
decl_stmt|;
name|cvmx_usbcx_ghwcfg3_t
name|usbcx_ghwcfg3
decl_stmt|;
name|cvmx_usbcx_doepmsk_t
name|usbcx_doepmsk
decl_stmt|;
name|cvmx_usbcx_diepmsk_t
name|usbcx_diepmsk
decl_stmt|;
name|cvmx_usbcx_daintmsk_t
name|usbc_daintmsk
decl_stmt|;
name|cvmx_usbcx_gnptxfsiz_t
name|gnptxfsiz
decl_stmt|;
name|int
name|fifo_space
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Processing reset\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|usbcx_ghwcfg2
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GHWCFG2
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_ghwcfg3
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GHWCFG3
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the data FIFO RAM for each of the FIFOs */
name|fifo_space
operator|=
name|usbcx_ghwcfg3
operator|.
name|s
operator|.
name|dfifodepth
expr_stmt|;
comment|/* Start at the top of the FIFO and assign space for each periodic fifo */
for|for
control|(
name|i
operator|=
name|usbcx_ghwcfg2
operator|.
name|s
operator|.
name|numdeveps
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|cvmx_usbcx_dptxfsizx_t
name|siz
decl_stmt|;
name|siz
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DPTXFSIZX
argument_list|(
name|i
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|fifo_space
operator|-=
name|siz
operator|.
name|s
operator|.
name|dptxfsize
expr_stmt|;
name|siz
operator|.
name|s
operator|.
name|dptxfstaddr
operator|=
name|fifo_space
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DPTXFSIZX
argument_list|(
name|i
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|siz
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Assign half the leftover space to the non periodic tx fifo */
name|gnptxfsiz
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|gnptxfsiz
operator|.
name|s
operator|.
name|nptxfdep
operator|=
name|fifo_space
operator|/
literal|2
expr_stmt|;
name|fifo_space
operator|-=
name|gnptxfsiz
operator|.
name|s
operator|.
name|nptxfdep
expr_stmt|;
name|gnptxfsiz
operator|.
name|s
operator|.
name|nptxfstaddr
operator|=
name|fifo_space
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GNPTXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|gnptxfsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Assign the remain space to the RX fifo */
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GRXFSIZ
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|fifo_space
argument_list|)
expr_stmt|;
comment|/* Unmask the common endpoint interrupts */
name|usbcx_doepmsk
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbcx_doepmsk
operator|.
name|s
operator|.
name|setupmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_doepmsk
operator|.
name|s
operator|.
name|epdisbldmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_doepmsk
operator|.
name|s
operator|.
name|xfercomplmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_doepmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbcx_diepmsk
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbcx_diepmsk
operator|.
name|s
operator|.
name|epdisbldmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_diepmsk
operator|.
name|s
operator|.
name|xfercomplmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_diepmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbc_daintmsk
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_daintmsk
operator|.
name|s
operator|.
name|inepmsk
operator|=
operator|-
literal|1
expr_stmt|;
name|usbc_daintmsk
operator|.
name|s
operator|.
name|outepmsk
operator|=
operator|-
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DAINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_daintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Set all endpoints to NAK */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|usbcx_ghwcfg2
operator|.
name|s
operator|.
name|numdeveps
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_usbcx_doepctlx_t
name|usbc_doepctl
decl_stmt|;
name|usbc_doepctl
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|snak
operator|=
literal|1
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|usbactep
operator|=
literal|1
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|mps
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|64
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPCTLX
argument_list|(
name|i
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doepctl
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a USB port for use. This must be called before any  * other access to the Octeon USB port is made. The port starts  * off in the disabled state.  *  * @param usb    Pointer to an empty cvmx_usbd_state_t structure  *               that will be populated by the initialize call.  *               This structure is then passed to all other USB  *               functions.  * @param usb_port_number  *               Which Octeon USB port to initialize.  * @param flags  Flags to control hardware initialization. See  *               cvmx_usbd_initialize_flags_t for the flag  *               definitions. Some flags are mandatory.  *  * @return Zero or a negative on error.  */
end_comment

begin_function
name|int
name|cvmx_usbd_initialize
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|usb_port_number
parameter_list|,
name|cvmx_usbd_initialize_flags_t
name|flags
parameter_list|)
block|{
name|cvmx_usbnx_clk_ctl_t
name|usbn_clk_ctl
decl_stmt|;
name|cvmx_usbnx_usbp_ctl_status_t
name|usbn_usbp_ctl_status
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Called\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|usb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|usb
argument_list|)
argument_list|)
expr_stmt|;
name|usb
operator|->
name|init_flags
operator|=
name|flags
expr_stmt|;
name|usb
operator|->
name|index
operator|=
name|usb_port_number
expr_stmt|;
comment|/* Try to determine clock type automatically */
if|if
condition|(
operator|(
name|usb
operator|->
name|init_flags
operator|&
operator|(
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_XO_XI
operator||
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_XO_GND
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|__cvmx_helper_board_usb_get_clock_type
argument_list|()
operator|==
name|USB_CLOCK_TYPE_CRYSTAL_12
condition|)
name|usb
operator|->
name|init_flags
operator||=
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_XO_XI
expr_stmt|;
comment|/* Only 12 MHZ crystals are supported */
else|else
name|usb
operator|->
name|init_flags
operator||=
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_XO_GND
expr_stmt|;
block|}
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_XO_GND
condition|)
block|{
comment|/* Check for auto ref clock frequency */
if|if
condition|(
operator|!
operator|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_MHZ_MASK
operator|)
condition|)
switch|switch
condition|(
name|__cvmx_helper_board_usb_get_clock_type
argument_list|()
condition|)
block|{
case|case
name|USB_CLOCK_TYPE_REF_12
case|:
name|usb
operator|->
name|init_flags
operator||=
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_12MHZ
expr_stmt|;
break|break;
case|case
name|USB_CLOCK_TYPE_REF_24
case|:
name|usb
operator|->
name|init_flags
operator||=
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_24MHZ
expr_stmt|;
break|break;
case|case
name|USB_CLOCK_TYPE_REF_48
case|:
default|default:
name|usb
operator|->
name|init_flags
operator||=
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_48MHZ
expr_stmt|;
break|break;
block|}
block|}
comment|/* Power On Reset and PHY Initialization */
comment|/* 1. Wait for DCOK to assert (nothing to do) */
comment|/* 2a. Write USBN0/1_CLK_CTL[POR] = 1 and         USBN0/1_CLK_CTL[HRST,PRST,HCLK_RST] = 0 */
name|usbn_clk_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
comment|/* 2b. Select the USB reference clock/crystal parameters by writing         appropriate values to USBN0/1_CLK_CTL[P_C_SEL, P_RTYPE, P_COM_ON] */
if|if
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_XO_GND
condition|)
block|{
comment|/* The USB port uses 12/24/48MHz 2.5V board clock             source at USB_XO. USB_XI should be tied to GND.             Most Octeon evaluation boards require this setting */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_rclk
operator|=
literal|1
expr_stmt|;
comment|/* From CN31XX,CN30XX manual */
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_xenbn
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|usbn_clk_ctl
operator|.
name|cn56xx
operator|.
name|p_rtype
operator|=
literal|2
expr_stmt|;
comment|/* From CN56XX,CN50XX manual */
else|else
name|usbn_clk_ctl
operator|.
name|cn52xx
operator|.
name|p_rtype
operator|=
literal|1
expr_stmt|;
comment|/* From CN52XX manual */
switch|switch
condition|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_MHZ_MASK
condition|)
block|{
case|case
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_12MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_24MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_USBD_INITIALIZE_FLAGS_CLOCK_48MHZ
case|:
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* The USB port uses a 12MHz crystal as clock source             at USB_XO and USB_XI */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_rclk
operator|=
literal|1
expr_stmt|;
comment|/* From CN31XX,CN30XX manual */
name|usbn_clk_ctl
operator|.
name|cn31xx
operator|.
name|p_xenbn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|usbn_clk_ctl
operator|.
name|cn56xx
operator|.
name|p_rtype
operator|=
literal|0
expr_stmt|;
comment|/* From CN56XX,CN50XX manual */
else|else
name|usbn_clk_ctl
operator|.
name|cn52xx
operator|.
name|p_rtype
operator|=
literal|0
expr_stmt|;
comment|/* From CN52XX manual */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|p_c_sel
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 2c. Select the HCLK via writing USBN0/1_CLK_CTL[DIVIDE, DIVIDE2] and         setting USBN0/1_CLK_CTL[ENABLE] = 1.  Divide the core clock down such         that USB is as close as possible to 125Mhz */
block|{
name|int
name|divisor
init|=
operator|(
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|+
literal|125000000
operator|-
literal|1
operator|)
operator|/
literal|125000000
decl_stmt|;
if|if
condition|(
name|divisor
operator|<
literal|4
condition|)
comment|/* Lower than 4 doesn't seem to work properly */
name|divisor
operator|=
literal|4
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|divide
operator|=
name|divisor
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|divide2
operator|=
literal|0
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 2d. Write USBN0/1_CLK_CTL[HCLK_RST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 2e.  Wait 64 core-clock cycles for HCLK to stabilize */
name|cvmx_wait
argument_list|(
literal|64
argument_list|)
expr_stmt|;
comment|/* 3. Program the power-on reset field in the USBN clock-control register:         USBN_CLK_CTL[POR] = 0 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 4. Wait 1 ms for PHY clock to start */
name|cvmx_wait_usec
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 5. Program the Reset input from automatic test equipment field in the         USBP control and status register: USBN_USBP_CTL_STATUS[ATE_RESET] = 1 */
name|usbn_usbp_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|ate_reset
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 6. Wait 10 cycles */
name|cvmx_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* 7. Clear ATE_RESET field in the USBN clock-control register:         USBN_USBP_CTL_STATUS[ATE_RESET] = 0 */
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|ate_reset
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 8. Program the PHY reset field in the USBN clock-control register:         USBN_CLK_CTL[PRST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 9. Program the USBP control and status register to select host or         device mode. USBN_USBP_CTL_STATUS[HST_MODE] = 0 for host, = 1 for         device */
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|hst_mode
operator|=
literal|1
expr_stmt|;
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|dm_pulld
operator|=
literal|0
expr_stmt|;
name|usbn_usbp_ctl_status
operator|.
name|s
operator|.
name|dp_pulld
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_USBP_CTL_STATUS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_usbp_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 10. Wait 1 µs */
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 11. Program the hreset_n field in the USBN clock-control register:         USBN_CLK_CTL[HRST] = 1 */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 12. Proceed to USB core initialization */
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Program the following fields in the global AHB configuration         register (USBC_GAHBCFG)         DMA mode, USBC_GAHBCFG[DMAEn]: 1 = DMA mode, 0 = slave mode         Burst length, USBC_GAHBCFG[HBSTLEN] = 0         Nonperiodic TxFIFO empty level (slave mode only),         USBC_GAHBCFG[NPTXFEMPLVL]         Periodic TxFIFO empty level (slave mode only),         USBC_GAHBCFG[PTXFEMPLVL]         Global interrupt mask, USBC_GAHBCFG[GLBLINTRMSK] = 1 */
block|{
name|cvmx_usbcx_gahbcfg_t
name|usbcx_gahbcfg
decl_stmt|;
name|usbcx_gahbcfg
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|dmaen
operator|=
literal|1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|hbstlen
operator|=
literal|0
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|nptxfemplvl
operator|=
literal|1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|ptxfemplvl
operator|=
literal|1
expr_stmt|;
name|usbcx_gahbcfg
operator|.
name|s
operator|.
name|glblintrmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GAHBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gahbcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Program the following fields in USBC_GUSBCFG register.         HS/FS timeout calibration, USBC_GUSBCFG[TOUTCAL] = 0         ULPI DDR select, USBC_GUSBCFG[DDRSEL] = 0         USB turnaround time, USBC_GUSBCFG[USBTRDTIM] = 0x5         PHY low-power clock select, USBC_GUSBCFG[PHYLPWRCLKSEL] = 0 */
block|{
name|cvmx_usbcx_gusbcfg_t
name|usbcx_gusbcfg
decl_stmt|;
name|usbcx_gusbcfg
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GUSBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|toutcal
operator|=
literal|0
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|ddrsel
operator|=
literal|0
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|usbtrdtim
operator|=
literal|0x5
expr_stmt|;
name|usbcx_gusbcfg
operator|.
name|s
operator|.
name|phylpwrclksel
operator|=
literal|0
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GUSBCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gusbcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Program the following fields in the USBC0/1_DCFG register:         Device speed, USBC0/1_DCFG[DEVSPD] = 0 (high speed)         Non-zero-length status OUT handshake, USBC0/1_DCFG[NZSTSOUTHSHK]=0         Periodic frame interval (if periodic endpoints are supported),         USBC0/1_DCFG[PERFRINT] = 1 */
block|{
name|cvmx_usbcx_dcfg_t
name|usbcx_dcfg
decl_stmt|;
name|usbcx_dcfg
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_dcfg
operator|.
name|s
operator|.
name|devspd
operator|=
literal|0
expr_stmt|;
name|usbcx_dcfg
operator|.
name|s
operator|.
name|nzstsouthshk
operator|=
literal|0
expr_stmt|;
name|usbcx_dcfg
operator|.
name|s
operator|.
name|perfrint
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_dcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Program the USBC0/1_GINTMSK register */
block|{
name|cvmx_usbcx_gintmsk_t
name|usbcx_gintmsk
decl_stmt|;
name|usbcx_gintmsk
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|oepintmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|inepintmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|enumdonemsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|usbrstmsk
operator|=
literal|1
expr_stmt|;
name|usbcx_gintmsk
operator|.
name|s
operator|.
name|usbsuspmsk
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_gintmsk
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
name|cvmx_usbd_disable
argument_list|(
name|usb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_initialize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Shutdown a USB port after a call to cvmx_usbd_initialize().  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  *  * @return Zero or a negative on error.  */
end_comment

begin_function
name|int
name|cvmx_usbd_shutdown
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbnx_clk_ctl_t
name|usbn_clk_ctl
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Called\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Disable the clocks and put them in power on reset */
name|usbn_clk_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|por
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hclk_rst
operator|=
literal|1
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|prst
operator|=
literal|0
expr_stmt|;
name|usbn_clk_ctl
operator|.
name|s
operator|.
name|hrst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_CLK_CTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbn_clk_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_shutdown
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Enable a USB port. After this call succeeds, the USB port is  * online and servicing requests.  *  * @param usb  USB device state populated by  *               cvmx_usb_initialize().  *  * @return Zero or negative on error.  */
end_comment

begin_function
name|int
name|cvmx_usbd_enable
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_dctl_t
name|usbcx_dctl
decl_stmt|;
name|usbcx_dctl
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_dctl
operator|.
name|s
operator|.
name|cgoutnak
operator|=
literal|1
expr_stmt|;
name|usbcx_dctl
operator|.
name|s
operator|.
name|sftdiscon
operator|=
literal|0
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_dctl
operator|.
name|u32
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Disable a USB port. After this call the USB port will not  * generate data transfers and will not generate events.  *  * @param usb    USB device state populated by  *               cvmx_usb_initialize().  *  * @return Zero or negative on error.  */
end_comment

begin_function
name|int
name|cvmx_usbd_disable
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_dctl_t
name|usbcx_dctl
decl_stmt|;
name|usbcx_dctl
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_dctl
operator|.
name|s
operator|.
name|sgoutnak
operator|=
literal|1
expr_stmt|;
name|usbcx_dctl
operator|.
name|s
operator|.
name|sftdiscon
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCTL
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_dctl
operator|.
name|u32
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Register a callback function to process USB events  *  * @param usb       USB device state populated by  *                  cvmx_usbd_initialize().  * @param reason    The reason this callback should be called  * @param func      Function to call  * @param user_data User supplied data for the callback  *  * @return Zero on succes, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_usbd_register
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usbd_callback_t
name|reason
parameter_list|,
name|cvmx_usbd_callback_func_t
name|func
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Register reason=%d func=%p data=%p\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reason
argument_list|,
name|func
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
name|usb
operator|->
name|callback
index|[
name|reason
index|]
operator|=
name|func
expr_stmt|;
name|usb
operator|->
name|callback_data
index|[
name|reason
index|]
operator|=
name|user_data
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_register
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Poll a device mode endpoint for status  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param endpoint_num  *               Endpoint to poll  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usbd_poll_in_endpoint
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usbcx_diepintx_t
name|usbc_diepint
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: endpoint=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|usbc_diepint
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_diepint
operator|.
name|u32
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|epdisbld
condition|)
block|{
comment|/* Endpoint Disabled Interrupt (EPDisbld)             This bit indicates that the endpoint is disabled per the             application's request. */
comment|/* Nothing to do */
block|}
if|if
condition|(
name|usbc_diepint
operator|.
name|s
operator|.
name|xfercompl
condition|)
block|{
name|cvmx_usbcx_dieptsizx_t
name|usbc_dieptsiz
decl_stmt|;
name|int
name|bytes_transferred
decl_stmt|;
comment|/* Transfer Completed Interrupt (XferCompl)             Indicates that the programmed transfer is complete on the AHB             as well as on the USB, for this endpoint. */
name|usbc_dieptsiz
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPTSIZX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_transferred
operator|=
name|usb
operator|->
name|endpoint
index|[
name|endpoint_num
index|]
operator|.
name|buffer_length
operator|-
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|xfersize
expr_stmt|;
name|__cvmx_usbd_callback
argument_list|(
name|usb
argument_list|,
name|CVMX_USBD_CALLBACK_IN_COMPLETE
argument_list|,
name|endpoint_num
argument_list|,
name|bytes_transferred
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Poll a device mode endpoint for status  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param endpoint_num  *               Endpoint to poll  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_usbd_poll_out_endpoint
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usbcx_doepintx_t
name|usbc_doepint
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: endpoint=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|usbc_doepint
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doepint
operator|.
name|u32
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|setup
condition|)
block|{
comment|/* SETUP Phase Done (SetUp)             Applies to control OUT endpoints only.             Indicates that the SETUP phase for the control endpoint is             complete and no more back-to-back SETUP packets were             received for the current control transfer. On this interrupt, the             application can decode the received SETUP data packet. */
name|__cvmx_usbd_callback
argument_list|(
name|usb
argument_list|,
name|CVMX_USBD_CALLBACK_DEVICE_SETUP
argument_list|,
name|endpoint_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|epdisbld
condition|)
block|{
comment|/* Endpoint Disabled Interrupt (EPDisbld)             This bit indicates that the endpoint is disabled per the             application's request. */
comment|/* Nothing to do */
block|}
if|if
condition|(
name|usbc_doepint
operator|.
name|s
operator|.
name|xfercompl
condition|)
block|{
name|cvmx_usbcx_doeptsizx_t
name|usbc_doeptsiz
decl_stmt|;
name|int
name|bytes_transferred
decl_stmt|;
comment|/* Transfer Completed Interrupt (XferCompl)             Indicates that the programmed transfer is complete on the AHB             as well as on the USB, for this endpoint. */
name|usbc_doeptsiz
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPTSIZX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_transferred
operator|=
name|usb
operator|->
name|endpoint
index|[
name|endpoint_num
index|]
operator|.
name|buffer_length
operator|-
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|xfersize
expr_stmt|;
name|__cvmx_usbd_callback
argument_list|(
name|usb
argument_list|,
name|CVMX_USBD_CALLBACK_OUT_COMPLETE
argument_list|,
name|endpoint_num
argument_list|,
name|bytes_transferred
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Poll the USB block for status and call all needed callback  * handlers. This function is meant to be called in the interrupt  * handler for the USB controller. It can also be called  * periodically in a loop for non-interrupt based operation.  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  *  * @return Zero or negative on error.  */
end_comment

begin_function
name|int
name|cvmx_usbd_poll
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_gintsts_t
name|usbc_gintsts
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Called\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Read the pending interrupts */
name|usbc_gintsts
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_gintsts
operator|.
name|u32
operator|&=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTMSK
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear the interrupts now that we know about them */
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_GINTSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_gintsts
operator|.
name|u32
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|usbsusp
condition|)
name|__cvmx_usbd_callback
argument_list|(
name|usb
argument_list|,
name|CVMX_USBD_CALLBACK_SUSPEND
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|enumdone
condition|)
name|__cvmx_usbd_callback
argument_list|(
name|usb
argument_list|,
name|CVMX_USBD_CALLBACK_ENUM_COMPLETE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|usbrst
condition|)
block|{
comment|/* USB Reset (USBRst)             The core sets this bit to indicate that a reset is             detected on the USB. */
name|__cvmx_usbd_device_reset_complete
argument_list|(
name|usb
argument_list|)
expr_stmt|;
name|__cvmx_usbd_callback
argument_list|(
name|usb
argument_list|,
name|CVMX_USBD_CALLBACK_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usbc_gintsts
operator|.
name|s
operator|.
name|oepint
operator|||
name|usbc_gintsts
operator|.
name|s
operator|.
name|iepint
condition|)
block|{
name|cvmx_usbcx_daint_t
name|usbc_daint
decl_stmt|;
name|usbc_daint
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DAINT
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_daint
operator|.
name|s
operator|.
name|inepint
condition|)
block|{
name|int
name|active_endpoints
init|=
name|usbc_daint
operator|.
name|s
operator|.
name|inepint
decl_stmt|;
while|while
condition|(
name|active_endpoints
condition|)
block|{
name|int
name|endpoint
decl_stmt|;
name|CVMX_CLZ
argument_list|(
name|endpoint
argument_list|,
name|active_endpoints
argument_list|)
expr_stmt|;
name|endpoint
operator|=
literal|31
operator|-
name|endpoint
expr_stmt|;
name|__cvmx_usbd_poll_in_endpoint
argument_list|(
name|usb
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
name|active_endpoints
operator|^=
literal|1
operator|<<
name|endpoint
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usbc_daint
operator|.
name|s
operator|.
name|outepint
condition|)
block|{
name|int
name|active_endpoints
init|=
name|usbc_daint
operator|.
name|s
operator|.
name|outepint
decl_stmt|;
while|while
condition|(
name|active_endpoints
condition|)
block|{
name|int
name|endpoint
decl_stmt|;
name|CVMX_CLZ
argument_list|(
name|endpoint
argument_list|,
name|active_endpoints
argument_list|)
expr_stmt|;
name|endpoint
operator|=
literal|31
operator|-
name|endpoint
expr_stmt|;
name|__cvmx_usbd_poll_out_endpoint
argument_list|(
name|usb
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
name|active_endpoints
operator|^=
literal|1
operator|<<
name|endpoint
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_poll
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Get the current USB address  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  *  * @return The USB address  */
end_comment

begin_function
name|int
name|cvmx_usbd_get_address
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_dcfg_t
name|usbc_dcfg
decl_stmt|;
name|usbc_dcfg
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|usbc_dcfg
operator|.
name|s
operator|.
name|devaddr
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_get_address
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Set the current USB address  *  * @param usb     USB device state populated by  *                cvmx_usbd_initialize().  * @param address Address to set  */
end_comment

begin_function
name|void
name|cvmx_usbd_set_address
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|address
parameter_list|)
block|{
name|cvmx_usbcx_dcfg_t
name|usbc_dcfg
decl_stmt|;
name|usbc_dcfg
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_dcfg
operator|.
name|s
operator|.
name|devaddr
operator|=
name|address
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_dcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_set_address
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Get the current USB speed  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  *  * @return The USB speed  */
end_comment

begin_function
name|cvmx_usbd_speed_t
name|cvmx_usbd_get_speed
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|)
block|{
name|cvmx_usbcx_dsts_t
name|usbcx_dsts
decl_stmt|;
name|usbcx_dsts
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DSTS
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|usbcx_dsts
operator|.
name|s
operator|.
name|enumspd
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_get_speed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Set the current USB speed  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param speed  The requested speed  */
end_comment

begin_function
name|void
name|cvmx_usbd_set_speed
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|cvmx_usbd_speed_t
name|speed
parameter_list|)
block|{
name|cvmx_usbcx_dcfg_t
name|usbcx_dcfg
decl_stmt|;
name|usbcx_dcfg
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|usbcx_dcfg
operator|.
name|s
operator|.
name|devspd
operator|=
name|speed
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DCFG
argument_list|(
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbcx_dcfg
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_set_speed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Enable an endpoint to respond to an OUT transaction  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param endpoint_num  *               Endpoint number to enable  * @param transfer_type  *               Transfer type for the endpoint  * @param max_packet_size  *               Maximum packet size for the endpoint  * @param buffer Buffer to receive the data  * @param buffer_length  *               Length of the buffer in bytes  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_usbd_out_endpoint_enable
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|cvmx_usbd_transfer_t
name|transfer_type
parameter_list|,
name|int
name|max_packet_size
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|cvmx_usbcx_doepctlx_t
name|usbc_doepctl
decl_stmt|;
name|cvmx_usbcx_doeptsizx_t
name|usbc_doeptsiz
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: endpoint=%d buffer=0x%llx length=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|,
operator|(
name|ULL
operator|)
name|buffer
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|usb
operator|->
name|endpoint
index|[
name|endpoint_num
index|]
operator|.
name|buffer_length
operator|=
name|buffer_length
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
comment|/* Flush out pending writes before enable */
comment|/* Clear any pending interrupts */
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the locations the DMA engines use  */
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_DMA0_INB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|endpoint_num
operator|*
literal|8
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|usbc_doeptsiz
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|mc
operator|=
literal|1
expr_stmt|;
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
operator|(
name|buffer_length
operator|+
name|max_packet_size
operator|-
literal|1
operator|)
operator|/
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|==
literal|0
condition|)
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
literal|1
expr_stmt|;
name|usbc_doeptsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|buffer_length
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPTSIZX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doeptsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbc_doepctl
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|epena
operator|=
literal|1
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|setd1pid
operator|=
literal|0
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|setd0pid
operator|=
literal|0
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|cnak
operator|=
literal|1
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|eptype
operator|=
name|transfer_type
expr_stmt|;
name|usbc_doepctl
operator|.
name|s
operator|.
name|usbactep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|endpoint_num
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|max_packet_size
condition|)
block|{
case|case
literal|8
case|:
name|usbc_doepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|usbc_doepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|usbc_doepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usbc_doepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|usbc_doepctl
operator|.
name|s
operator|.
name|mps
operator|=
name|max_packet_size
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doepctl
operator|.
name|u32
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_out_endpoint_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Disable an OUT endpoint  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param endpoint_num  *               Endpoint number to disable  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_usbd_out_endpoint_disable
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usbcx_doepctlx_t
name|usbc_doepctl
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: endpoint=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|usbc_doepctl
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_doepctl
operator|.
name|s
operator|.
name|epena
operator|&&
operator|!
name|usbc_doepctl
operator|.
name|s
operator|.
name|epdis
condition|)
block|{
name|usbc_doepctl
operator|.
name|s
operator|.
name|epdis
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DOEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_doepctl
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_out_endpoint_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Enable an endpoint to respond to an IN transaction  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param endpoint_num  *               Endpoint number to enable  * @param transfer_type  *               Transfer type for the endpoint  * @param max_packet_size  *               Maximum packet size for the endpoint  * @param buffer Buffer to send  * @param buffer_length  *               Length of the buffer in bytes  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_usbd_in_endpoint_enable
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|endpoint_num
parameter_list|,
name|cvmx_usbd_transfer_t
name|transfer_type
parameter_list|,
name|int
name|max_packet_size
parameter_list|,
name|uint64_t
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|cvmx_usbcx_diepctlx_t
name|usbc_diepctl
decl_stmt|;
name|cvmx_usbcx_dieptsizx_t
name|usbc_dieptsiz
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: endpoint=%d buffer=0x%llx length=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|,
operator|(
name|ULL
operator|)
name|buffer
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|usb
operator|->
name|endpoint
index|[
name|endpoint_num
index|]
operator|.
name|buffer_length
operator|=
name|buffer_length
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
comment|/* Flush out pending writes before enable */
comment|/* Clear any pending interrupts */
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPINTX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|mc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_USBNX_DMA0_OUTB_CHN0
argument_list|(
name|usb
operator|->
name|index
argument_list|)
operator|+
name|endpoint_num
operator|*
literal|8
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
operator|(
name|buffer_length
operator|+
name|max_packet_size
operator|-
literal|1
operator|)
operator|/
name|max_packet_size
expr_stmt|;
if|if
condition|(
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|==
literal|0
condition|)
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
literal|1
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
name|buffer_length
expr_stmt|;
block|}
else|else
block|{
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|pktcnt
operator|=
literal|0
expr_stmt|;
name|usbc_dieptsiz
operator|.
name|s
operator|.
name|xfersize
operator|=
literal|0
expr_stmt|;
block|}
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPTSIZX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_dieptsiz
operator|.
name|u32
argument_list|)
expr_stmt|;
name|usbc_diepctl
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|epena
operator|=
operator|(
name|buffer
operator|!=
literal|0
operator|)
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|setd1pid
operator|=
literal|0
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|setd0pid
operator|=
operator|(
name|buffer
operator|==
literal|0
operator|)
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|cnak
operator|=
literal|1
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|txfnum
operator|=
name|endpoint_num
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|eptype
operator|=
name|transfer_type
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|usbactep
operator|=
literal|1
expr_stmt|;
name|usbc_diepctl
operator|.
name|s
operator|.
name|nextep
operator|=
name|endpoint_num
expr_stmt|;
if|if
condition|(
name|endpoint_num
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|max_packet_size
condition|)
block|{
case|case
literal|8
case|:
name|usbc_diepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|usbc_diepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|usbc_diepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usbc_diepctl
operator|.
name|s
operator|.
name|mps
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|usbc_diepctl
operator|.
name|s
operator|.
name|mps
operator|=
name|max_packet_size
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_diepctl
operator|.
name|u32
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_in_endpoint_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Disable an IN endpoint  *  * @param usb    USB device state populated by  *               cvmx_usbd_initialize().  * @param endpoint_num  *               Endpoint number to disable  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_usbd_in_endpoint_disable
parameter_list|(
name|cvmx_usbd_state_t
modifier|*
name|usb
parameter_list|,
name|int
name|endpoint_num
parameter_list|)
block|{
name|cvmx_usbcx_diepctlx_t
name|usbc_diepctl
decl_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|usb
operator|->
name|init_flags
operator|&
name|CVMX_USBD_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: endpoint=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|endpoint_num
argument_list|)
expr_stmt|;
name|usbc_diepctl
operator|.
name|u32
operator|=
name|__cvmx_usbd_read_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|usbc_diepctl
operator|.
name|s
operator|.
name|epena
operator|&&
operator|!
name|usbc_diepctl
operator|.
name|s
operator|.
name|epdis
condition|)
block|{
name|usbc_diepctl
operator|.
name|s
operator|.
name|epdis
operator|=
literal|1
expr_stmt|;
name|__cvmx_usbd_write_csr32
argument_list|(
name|usb
argument_list|,
name|CVMX_USBCX_DIEPCTLX
argument_list|(
name|endpoint_num
argument_list|,
name|usb
operator|->
name|index
argument_list|)
argument_list|,
name|usbc_diepctl
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_usbd_in_endpoint_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

