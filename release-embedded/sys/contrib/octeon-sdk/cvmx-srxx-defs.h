begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-srxx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon srxx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_SRXX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_SRXX_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRXX_COM_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRXX_COM_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000200ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRXX_COM_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000200ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRXX_IGN_RX_FULL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRXX_IGN_RX_FULL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000218ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRXX_IGN_RX_FULL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000218ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRXX_SPI4_CALX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRXX_SPI4_CALX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000000ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRXX_SPI4_CALX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000000ull) + (((offset)& 31) + ((block_id)& 1) * 0x1000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRXX_SPI4_STAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRXX_SPI4_STAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000208ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRXX_SPI4_STAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000208ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRXX_SW_TICK_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRXX_SW_TICK_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000220ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRXX_SW_TICK_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000220ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SRXX_SW_TICK_DAT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SRXX_SW_TICK_DAT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180090000228ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SRXX_SW_TICK_DAT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180090000228ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_srx#_com_ctl  *  * SRX_COM_CTL - Spi receive common control  *  *  * Notes:  * Restrictions:  * Both the calendar table and the LEN and M parameters must be completely  * setup before writing the Interface enable (INF_EN) and Status channel  * enabled (ST_EN) asserted.  */
end_comment

begin_union
union|union
name|cvmx_srxx_com_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_srxx_com_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|prts
range|:
literal|4
decl_stmt|;
comment|/**< Number of ports in the receiver (write: ports - 1)                                                          - 0:  1 port                                                          - 1:  2 ports                                                          - 2:  3 ports                                                           - ...                                                           - 15: 16 ports */
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
comment|/**< Status channel enabled                                                          This is to allow configs without a status channel.                                                          This bit should not be modified once the                                                          interface is enabled. */
name|uint64_t
name|reserved_1_2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inf_en
range|:
literal|1
decl_stmt|;
comment|/**< Interface enable                                                          The master switch that enables the entire                                                          interface. SRX will not validiate any data until                                                          this bit is set. This bit should not be modified                                                          once the interface is enabled. */
else|#
directive|else
name|uint64_t
name|inf_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prts
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_srxx_com_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_srxx_com_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_srxx_com_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_srxx_com_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_srxx_com_ctl
name|cvmx_srxx_com_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_srx#_ign_rx_full  *  * SRX_IGN_RX_FULL - Ignore RX FIFO backpressure  *  *  * Notes:  * * IGNORE  * If a device can not or should not assert backpressure, then setting DROP  * will force STARVING status on the status channel for all ports.  This  * eliminates any back pressure from N2.  *  * This implies that it's ok drop packets when the FIFOS fill up.  *  * A side effect of this mode is that the TPA Watcher will effectively be  * disabled.  Since the DROP mode forces all TPA lines asserted, the TPA  * Watcher will never find a cycle where the TPA for the selected port is  * deasserted in order to increment its count.  */
end_comment

begin_union
union|union
name|cvmx_srxx_ign_rx_full
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_srxx_ign_rx_full_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|ignore
range|:
literal|16
decl_stmt|;
comment|/**< This port should ignore backpressure hints from                                                           GMX when the RX FIFO fills up                                                          - 0: Use GMX backpressure                                                          - 1: Ignore GMX backpressure */
else|#
directive|else
name|uint64_t
name|ignore
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_srxx_ign_rx_full_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_srxx_ign_rx_full_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_srxx_ign_rx_full_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_srxx_ign_rx_full_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_srxx_ign_rx_full
name|cvmx_srxx_ign_rx_full_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_srx#_spi4_cal#  *  * specify the RSL base addresses for the block  * SRX_SPI4_CAL - Spi4 Calender table  * direct_calendar_write / direct_calendar_read  *  * Notes:  * There are 32 calendar table CSR's, each containing 4 entries for a  *     total of 128 entries.  In the above definition...  *  *           n = calendar table offset * 4  *  *        Example, offset 0x00 contains the calendar table entries 0, 1, 2, 3  *        (with n == 0).  Offset 0x10 is the 16th entry in the calendar table  *        and would contain entries (16*4) = 64, 65, 66, and 67.  *  * Restrictions:  *          Calendar table entry accesses (read or write) can only occur  *          if the interface is disabled.  All other accesses will be  *          unpredictable.  *  *          Both the calendar table and the LEN and M parameters must be  *          completely setup before writing the Interface enable (INF_EN) and  *          Status channel enabled (ST_EN) asserted.  */
end_comment

begin_union
union|union
name|cvmx_srxx_spi4_calx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_srxx_spi4_calx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|oddpar
range|:
literal|1
decl_stmt|;
comment|/**< Odd parity over SRX_SPI4_CAL[15:0]                                                          (^SRX_SPI4_CAL[16:0] === 1'b1)                  |   $NS       NS */
name|uint64_t
name|prt3
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+3 */
name|uint64_t
name|prt2
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+2 */
name|uint64_t
name|prt1
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+1 */
name|uint64_t
name|prt0
range|:
literal|4
decl_stmt|;
comment|/**< Status for port n+0 */
else|#
directive|else
name|uint64_t
name|prt0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prt1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prt2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prt3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|oddpar
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_srxx_spi4_calx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_srxx_spi4_calx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_srxx_spi4_calx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_srxx_spi4_calx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_srxx_spi4_calx
name|cvmx_srxx_spi4_calx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_srx#_spi4_stat  *  * SRX_SPI4_STAT - Spi4 status channel control  *  *  * Notes:  * Restrictions:  *    Both the calendar table and the LEN and M parameters must be  *    completely setup before writing the Interface enable (INF_EN) and  *    Status channel enabled (ST_EN) asserted.  *  * Current rev only supports LVTTL status IO  */
end_comment

begin_union
union|union
name|cvmx_srxx_spi4_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_srxx_spi4_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|m
range|:
literal|8
decl_stmt|;
comment|/**< CALENDAR_M (from spi4.2 spec) */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
comment|/**< CALENDAR_LEN (from spi4.2 spec) */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_srxx_spi4_stat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_srxx_spi4_stat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_srxx_spi4_stat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_srxx_spi4_stat_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_srxx_spi4_stat
name|cvmx_srxx_spi4_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_srx#_sw_tick_ctl  *  * SRX_SW_TICK_CTL - Create a software tick of Spi4 data.  A write to this register will create a data tick.  *  */
end_comment

begin_union
union|union
name|cvmx_srxx_sw_tick_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_srxx_sw_tick_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|eop
range|:
literal|1
decl_stmt|;
comment|/**< SW Tick EOP                                                          (PASS3 only) */
name|uint64_t
name|sop
range|:
literal|1
decl_stmt|;
comment|/**< SW Tick SOP                                                          (PASS3 only) */
name|uint64_t
name|mod
range|:
literal|4
decl_stmt|;
comment|/**< SW Tick MOD - valid byte count                                                          (PASS3 only) */
name|uint64_t
name|opc
range|:
literal|4
decl_stmt|;
comment|/**< SW Tick ERR - packet had an error                                                          (PASS3 only) */
name|uint64_t
name|adr
range|:
literal|4
decl_stmt|;
comment|/**< SW Tick port address                                                          (PASS3 only) */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|opc
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mod
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|eop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_srxx_sw_tick_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_srxx_sw_tick_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_srxx_sw_tick_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_srxx_sw_tick_ctl
name|cvmx_srxx_sw_tick_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_srx#_sw_tick_dat  *  * SRX_SW_TICK_DAT - Create a software tick of Spi4 data  *  */
end_comment

begin_union
union|union
name|cvmx_srxx_sw_tick_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_srxx_sw_tick_dat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
comment|/**< Data tick when SRX_SW_TICK_CTL is written                                                          (PASS3 only) */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_srxx_sw_tick_dat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_srxx_sw_tick_dat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_srxx_sw_tick_dat_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_srxx_sw_tick_dat
name|cvmx_srxx_sw_tick_dat_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

