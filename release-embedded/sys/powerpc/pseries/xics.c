begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2011 Nathan Whitehorn  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/rtas.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|"phyp-hvcall.h"
end_include

begin_include
include|#
directive|include
file|"pic_if.h"
end_include

begin_define
define|#
directive|define
name|XICP_PRIORITY
value|5
end_define

begin_comment
comment|/* Random non-zero number */
end_comment

begin_define
define|#
directive|define
name|XICP_IPI
value|2
end_define

begin_define
define|#
directive|define
name|MAX_XICP_IRQS
value|(1<<24)
end_define

begin_comment
comment|/* 24-bit XIRR field */
end_comment

begin_function_decl
specifier|static
name|int
name|xicp_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xicp_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xics_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xics_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xicp_bind
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|,
name|cpuset_t
name|cpumask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xicp_dispatch
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|trapframe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xicp_enable
parameter_list|(
name|device_t
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xicp_eoi
parameter_list|(
name|device_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xicp_ipi
parameter_list|(
name|device_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xicp_mask
parameter_list|(
name|device_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xicp_unmask
parameter_list|(
name|device_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|xicp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xicp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xicp_attach
argument_list|)
block|,
comment|/* PIC interface */
name|DEVMETHOD
argument_list|(
name|pic_bind
argument_list|,
name|xicp_bind
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_dispatch
argument_list|,
name|xicp_dispatch
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_enable
argument_list|,
name|xicp_enable
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_eoi
argument_list|,
name|xicp_eoi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_ipi
argument_list|,
name|xicp_ipi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_mask
argument_list|,
name|xicp_mask
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_unmask
argument_list|,
name|xicp_unmask
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|xics_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xics_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xics_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|xicp_softc
block|{
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|int
name|ibm_int_on
decl_stmt|;
name|int
name|ibm_int_off
decl_stmt|;
name|int
name|ibm_get_xive
decl_stmt|;
name|int
name|ibm_set_xive
decl_stmt|;
comment|/* XXX: inefficient -- hash table? tree? */
struct|struct
block|{
name|int
name|irq
decl_stmt|;
name|int
name|vector
decl_stmt|;
block|}
name|intvecs
index|[
literal|256
index|]
struct|;
name|int
name|nintvecs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|driver_t
name|xicp_driver
init|=
block|{
literal|"xicp"
block|,
name|xicp_methods
block|,
expr|sizeof
operator|(
expr|struct
name|xicp_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xics_driver
init|=
block|{
literal|"xics"
block|,
name|xics_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|xicp_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|xics_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|xicp
argument_list|,
name|ofwbus
argument_list|,
name|xicp_driver
argument_list|,
name|xicp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_INTERRUPT
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|xics
argument_list|,
name|ofwbus
argument_list|,
name|xics_driver
argument_list|,
name|xics_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_INTERRUPT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|xicp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|ofw_bus_get_name
argument_list|(
name|dev
argument_list|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|ofw_bus_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"interrupt-controller"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"ibm,ppc-xicp"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PAPR virtual interrupt controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xics_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|ofw_bus_get_name
argument_list|(
name|dev
argument_list|)
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|ofw_bus_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"interrupt-controller"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"ibm,ppc-xics"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"PAPR virtual interrupt source"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xicp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|xicp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|phandle_t
name|phandle
init|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"XICP"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nintvecs
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ibm_int_on
operator|=
name|rtas_token_lookup
argument_list|(
literal|"ibm,int-on"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ibm_int_off
operator|=
name|rtas_token_lookup
argument_list|(
literal|"ibm,int-off"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ibm_set_xive
operator|=
name|rtas_token_lookup
argument_list|(
literal|"ibm,set-xive"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ibm_get_xive
operator|=
name|rtas_token_lookup
argument_list|(
literal|"ibm,get-xive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getproplen
argument_list|(
name|phandle
argument_list|,
literal|"ibm,phandle"
argument_list|)
operator|>
literal|0
condition|)
name|OF_getprop
argument_list|(
name|phandle
argument_list|,
literal|"ibm,phandle"
argument_list|,
operator|&
name|phandle
argument_list|,
sizeof|sizeof
argument_list|(
name|phandle
argument_list|)
argument_list|)
expr_stmt|;
name|powerpc_register_pic
argument_list|(
name|dev
argument_list|,
name|phandle
argument_list|,
name|MAX_XICP_IRQS
argument_list|,
literal|1
comment|/* Number of IPIs */
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|root_pic
operator|=
name|dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xics_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|phandle_t
name|phandle
init|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|OF_getproplen
argument_list|(
name|phandle
argument_list|,
literal|"ibm,phandle"
argument_list|)
operator|>
literal|0
condition|)
name|OF_getprop
argument_list|(
name|phandle
argument_list|,
literal|"ibm,phandle"
argument_list|,
operator|&
name|phandle
argument_list|,
sizeof|sizeof
argument_list|(
name|phandle
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The XICP (root PIC) will handle all our interrupts */
name|powerpc_register_pic
argument_list|(
name|root_pic
argument_list|,
name|phandle
argument_list|,
name|MAX_XICP_IRQS
argument_list|,
literal|1
comment|/* Number of IPIs */
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PIC I/F methods.  */
end_comment

begin_function
specifier|static
name|void
name|xicp_bind
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|,
name|cpuset_t
name|cpumask
parameter_list|)
block|{
name|struct
name|xicp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cell_t
name|status
decl_stmt|,
name|cpu
decl_stmt|;
comment|/* 	 * This doesn't appear to actually support affinity groups, so just 	 * use the first CPU. 	 */
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|cpumask
argument_list|)
condition|)
break|break;
name|rtas_call_method
argument_list|(
name|sc
operator|->
name|ibm_set_xive
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|irq
argument_list|,
name|cpu
argument_list|,
name|XICP_PRIORITY
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xicp_dispatch
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|struct
name|xicp_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|xirr
decl_stmt|,
name|junk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Return value in R4, use the PFT call */
name|phyp_pft_hcall
argument_list|(
name|H_XIRR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|xirr
argument_list|,
operator|&
name|junk
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|xirr
operator|&=
literal|0x00ffffff
expr_stmt|;
if|if
condition|(
name|xirr
operator|==
literal|0
condition|)
block|{
comment|/* No more pending interrupts? */
name|phyp_hcall
argument_list|(
name|H_CPPR
argument_list|,
operator|(
name|uint64_t
operator|)
literal|0xff
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xirr
operator|==
name|XICP_IPI
condition|)
block|{
comment|/* Magic number for IPIs */
name|xirr
operator|=
name|MAX_XICP_IRQS
expr_stmt|;
comment|/* Map to FreeBSD magic */
name|phyp_hcall
argument_list|(
name|H_IPI
argument_list|,
call|(
name|uint64_t
call|)
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Clear IPI */
block|}
comment|/* XXX: super inefficient */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nintvecs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|intvecs
index|[
name|i
index|]
operator|.
name|irq
operator|==
name|xirr
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|i
operator|<
name|sc
operator|->
name|nintvecs
argument_list|,
operator|(
literal|"Unmapped XIRR"
operator|)
argument_list|)
expr_stmt|;
name|powerpc_dispatch_intr
argument_list|(
name|sc
operator|->
name|intvecs
index|[
name|i
index|]
operator|.
name|vector
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xicp_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|,
name|u_int
name|vector
parameter_list|)
block|{
name|struct
name|xicp_softc
modifier|*
name|sc
decl_stmt|;
name|cell_t
name|status
decl_stmt|,
name|cpu
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|nintvecs
operator|+
literal|1
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|intvecs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|intvecs
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
literal|"Too many XICP interrupts"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intvecs
index|[
name|sc
operator|->
name|nintvecs
index|]
operator|.
name|irq
operator|=
name|irq
expr_stmt|;
name|sc
operator|->
name|intvecs
index|[
name|sc
operator|->
name|nintvecs
index|]
operator|.
name|vector
operator|=
name|vector
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|sc
operator|->
name|nintvecs
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
comment|/* IPIs are also enabled */
if|if
condition|(
name|irq
operator|==
name|MAX_XICP_IRQS
condition|)
return|return;
comment|/* Bind to this CPU to start: distrib. ID is last entry in gserver# */
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|rtas_call_method
argument_list|(
name|sc
operator|->
name|ibm_set_xive
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|irq
argument_list|,
name|cpu
argument_list|,
name|XICP_PRIORITY
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|xicp_unmask
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xicp_eoi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|uint64_t
name|xirr
decl_stmt|;
if|if
condition|(
name|irq
operator|==
name|MAX_XICP_IRQS
condition|)
comment|/* Remap IPI interrupt to internal value */
name|irq
operator|=
name|XICP_IPI
expr_stmt|;
name|xirr
operator|=
name|irq
operator||
operator|(
name|XICP_PRIORITY
operator|<<
literal|24
operator|)
expr_stmt|;
name|phyp_hcall
argument_list|(
name|H_EOI
argument_list|,
name|xirr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xicp_ipi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|cpu
parameter_list|)
block|{
name|phyp_hcall
argument_list|(
name|H_IPI
argument_list|,
operator|(
name|uint64_t
operator|)
name|cpu
argument_list|,
name|XICP_PRIORITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xicp_mask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|struct
name|xicp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cell_t
name|status
decl_stmt|;
if|if
condition|(
name|irq
operator|==
name|MAX_XICP_IRQS
condition|)
return|return;
name|rtas_call_method
argument_list|(
name|sc
operator|->
name|ibm_int_off
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|irq
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xicp_unmask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|struct
name|xicp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cell_t
name|status
decl_stmt|;
if|if
condition|(
name|irq
operator|==
name|MAX_XICP_IRQS
condition|)
return|return;
name|rtas_call_method
argument_list|(
name|sc
operator|->
name|ibm_int_on
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|irq
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

