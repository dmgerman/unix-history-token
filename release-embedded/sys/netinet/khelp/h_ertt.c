begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2010  * 	Swinburne University of Technology, Melbourne, Australia  * Copyright (c) 2010 Lawrence Stewart<lstewart@freebsd.org>  * Copyright (c) 2010-2011 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed at the Centre for Advanced Internet  * Architectures, Swinburne University of Technology, by David Hayes, made  * possible in part by a grant from the Cisco University Research Program Fund  * at Community Foundation Silicon Valley.  *  * Portions of this software were developed at the Centre for Advanced  * Internet Architectures, Swinburne University of Technology, Melbourne,  * Australia by David Hayes under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/hhook.h>
end_include

begin_include
include|#
directive|include
file|<sys/khelp.h>
end_include

begin_include
include|#
directive|include
file|<sys/module_khelp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockopt.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/khelp/h_ertt.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
name|uma_zone_t
name|txseginfo_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Smoothing factor for delayed ack guess. */
end_comment

begin_define
define|#
directive|define
name|DLYACK_SMOOTH
value|5
end_define

begin_comment
comment|/* Max number of time stamp errors allowed in a session. */
end_comment

begin_define
define|#
directive|define
name|MAX_TS_ERR
value|10
end_define

begin_function_decl
specifier|static
name|int
name|ertt_packet_measurement_hook
parameter_list|(
name|int
name|hhook_type
parameter_list|,
name|int
name|hhook_id
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|ctx_data
parameter_list|,
name|void
modifier|*
name|hdata
parameter_list|,
name|struct
name|osd
modifier|*
name|hosd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ertt_add_tx_segment_info_hook
parameter_list|(
name|int
name|hhook_type
parameter_list|,
name|int
name|hhook_id
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|ctx_data
parameter_list|,
name|void
modifier|*
name|hdata
parameter_list|,
name|struct
name|osd
modifier|*
name|hosd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ertt_mod_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ertt_mod_destroy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ertt_uma_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ertt_uma_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Contains information about the sent segment for comparison with the  * corresponding ack.  */
end_comment

begin_struct
struct|struct
name|txseginfo
block|{
comment|/* Segment length. */
name|long
name|len
decl_stmt|;
comment|/* Segment sequence number. */
name|tcp_seq
name|seq
decl_stmt|;
comment|/* Time stamp indicating when the packet was sent. */
name|uint32_t
name|tx_ts
decl_stmt|;
comment|/* Last received receiver ts (if the TCP option is used). */
name|uint32_t
name|rx_ts
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|txseginfo
argument_list|)
name|txsegi_lnk
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Flags for struct txseginfo. */
end_comment

begin_define
define|#
directive|define
name|TXSI_TSO
value|0x01
end_define

begin_comment
comment|/* TSO was used for this entry. */
end_comment

begin_define
define|#
directive|define
name|TXSI_RTT_MEASURE_START
value|0x02
end_define

begin_comment
comment|/* Start a per RTT measurement. */
end_comment

begin_define
define|#
directive|define
name|TXSI_RX_MEASURE_END
value|0x04
end_define

begin_comment
comment|/* Measure the rx rate until this txsi. */
end_comment

begin_decl_stmt
name|struct
name|helper
name|ertt_helper
init|=
block|{
operator|.
name|mod_init
operator|=
name|ertt_mod_init
block|,
operator|.
name|mod_destroy
operator|=
name|ertt_mod_destroy
block|,
operator|.
name|h_flags
operator|=
name|HELPER_NEEDS_OSD
block|,
operator|.
name|h_classes
operator|=
name|HELPER_CLASS_TCP
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the helper hook info required by ERTT. */
end_comment

begin_decl_stmt
name|struct
name|hookinfo
name|ertt_hooks
index|[]
init|=
block|{
block|{
operator|.
name|hook_type
operator|=
name|HHOOK_TYPE_TCP
block|,
operator|.
name|hook_id
operator|=
name|HHOOK_TCP_EST_IN
block|,
operator|.
name|hook_udata
operator|=
name|NULL
block|,
operator|.
name|hook_func
operator|=
operator|&
name|ertt_packet_measurement_hook
block|}
block|,
block|{
operator|.
name|hook_type
operator|=
name|HHOOK_TYPE_TCP
block|,
operator|.
name|hook_id
operator|=
name|HHOOK_TCP_EST_OUT
block|,
operator|.
name|hook_udata
operator|=
name|NULL
block|,
operator|.
name|hook_func
operator|=
operator|&
name|ertt_add_tx_segment_info_hook
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags to indicate how marked_packet_rtt should handle this txsi. */
end_comment

begin_define
define|#
directive|define
name|MULTI_ACK
value|0x01
end_define

begin_comment
comment|/* More than this txsi is acked. */
end_comment

begin_define
define|#
directive|define
name|OLD_TXSI
value|0x02
end_define

begin_comment
comment|/* TXSI is old according to timestamps. */
end_comment

begin_define
define|#
directive|define
name|CORRECT_ACK
value|0X04
end_define

begin_comment
comment|/* Acks this TXSI. */
end_comment

begin_define
define|#
directive|define
name|FORCED_MEASUREMENT
value|0X08
end_define

begin_comment
comment|/* Force an RTT measurement. */
end_comment

begin_comment
comment|/*  * This fuction measures the RTT of a particular segment/ack pair, or the next  * closest if this will yield an inaccurate result due to delayed acking or  * other issues.  */
end_comment

begin_function
specifier|static
name|void
specifier|inline
name|marked_packet_rtt
parameter_list|(
name|struct
name|txseginfo
modifier|*
name|txsi
parameter_list|,
name|struct
name|ertt
modifier|*
name|e_t
parameter_list|,
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|uint32_t
modifier|*
name|pmeasurenext
parameter_list|,
name|int
modifier|*
name|pmeasurenext_len
parameter_list|,
name|int
modifier|*
name|prtt_bytes_adjust
parameter_list|,
name|int
name|mflag
parameter_list|)
block|{
comment|/* 	 * If we can't measure this one properly due to delayed acking adjust 	 * byte counters and flag to measure next txsi. Note that since the 	 * marked packet's transmitted bytes are measured we need to subtract the 	 * transmitted bytes. Then pretend the next txsi was marked. 	 */
if|if
condition|(
name|mflag
operator|&
operator|(
name|MULTI_ACK
operator||
name|OLD_TXSI
operator|)
condition|)
block|{
operator|*
name|pmeasurenext
operator|=
name|txsi
operator|->
name|tx_ts
expr_stmt|;
operator|*
name|pmeasurenext_len
operator|=
name|txsi
operator|->
name|len
expr_stmt|;
operator|*
name|prtt_bytes_adjust
operator|+=
operator|*
name|pmeasurenext_len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mflag
operator|&
name|FORCED_MEASUREMENT
condition|)
block|{
name|e_t
operator|->
name|markedpkt_rtt
operator|=
name|tcp_ts_getticks
argument_list|()
operator|-
operator|*
name|pmeasurenext
operator|+
literal|1
expr_stmt|;
name|e_t
operator|->
name|bytes_tx_in_marked_rtt
operator|=
name|e_t
operator|->
name|bytes_tx_in_rtt
operator|+
operator|*
name|pmeasurenext_len
operator|-
operator|*
name|prtt_bytes_adjust
expr_stmt|;
block|}
else|else
block|{
name|e_t
operator|->
name|markedpkt_rtt
operator|=
name|tcp_ts_getticks
argument_list|()
operator|-
name|txsi
operator|->
name|tx_ts
operator|+
literal|1
expr_stmt|;
name|e_t
operator|->
name|bytes_tx_in_marked_rtt
operator|=
name|e_t
operator|->
name|bytes_tx_in_rtt
operator|-
operator|*
name|prtt_bytes_adjust
expr_stmt|;
block|}
name|e_t
operator|->
name|marked_snd_cwnd
operator|=
name|tp
operator|->
name|snd_cwnd
expr_stmt|;
comment|/* 		 * Reset the ERTT_MEASUREMENT_IN_PROGRESS flag to indicate to 		 * add_tx_segment_info that a new measurement should be started. 		 */
name|e_t
operator|->
name|flags
operator|&=
operator|~
name|ERTT_MEASUREMENT_IN_PROGRESS
expr_stmt|;
comment|/* 		 * Set ERTT_NEW_MEASUREMENT to tell the congestion control 		 * algorithm that a new marked RTT measurement has has been made 		 * and is available for use. 		 */
name|e_t
operator|->
name|flags
operator||=
name|ERTT_NEW_MEASUREMENT
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TSO
condition|)
block|{
comment|/* Temporarily disable TSO to aid a new measurment. */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_TSO
expr_stmt|;
comment|/* Keep track that we've disabled it. */
name|e_t
operator|->
name|flags
operator||=
name|ERTT_TSO_DISABLED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Ertt_packet_measurements uses a small amount of state kept on each packet  * sent to match incoming acknowledgements. This enables more accurate and  * secure round trip time measurements. The resulting measurement is used for  * congestion control algorithms which require a more accurate time.  * Ertt_packet_measurements is called via the helper hook in tcp_input.c  */
end_comment

begin_function
specifier|static
name|int
name|ertt_packet_measurement_hook
parameter_list|(
name|int
name|hhook_type
parameter_list|,
name|int
name|hhook_id
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|ctx_data
parameter_list|,
name|void
modifier|*
name|hdata
parameter_list|,
name|struct
name|osd
modifier|*
name|hosd
parameter_list|)
block|{
name|struct
name|ertt
modifier|*
name|e_t
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|tcpopt
modifier|*
name|to
decl_stmt|;
name|struct
name|tcp_hhook_data
modifier|*
name|thdp
decl_stmt|;
name|struct
name|txseginfo
modifier|*
name|txsi
decl_stmt|;
name|int
name|acked
decl_stmt|,
name|measurenext_len
decl_stmt|,
name|multiack
decl_stmt|,
name|new_sacked_bytes
decl_stmt|,
name|rtt_bytes_adjust
decl_stmt|;
name|uint32_t
name|measurenext
decl_stmt|,
name|rts
decl_stmt|;
name|tcp_seq
name|ack
decl_stmt|;
name|KASSERT
argument_list|(
name|ctx_data
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ctx_data is NULL!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|hdata
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: hdata is NULL!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|e_t
operator|=
operator|(
expr|struct
name|ertt
operator|*
operator|)
name|hdata
expr_stmt|;
name|thdp
operator|=
name|ctx_data
expr_stmt|;
name|tp
operator|=
name|thdp
operator|->
name|tp
expr_stmt|;
name|th
operator|=
name|thdp
operator|->
name|th
expr_stmt|;
name|to
operator|=
name|thdp
operator|->
name|to
expr_stmt|;
name|new_sacked_bytes
operator|=
operator|(
name|tp
operator|->
name|sackhint
operator|.
name|last_sack_ack
operator|!=
literal|0
operator|)
expr_stmt|;
name|measurenext
operator|=
name|measurenext_len
operator|=
name|multiack
operator|=
name|rts
operator|=
name|rtt_bytes_adjust
operator|=
literal|0
expr_stmt|;
name|acked
operator|=
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* Packet has provided new acknowledgements. */
if|if
condition|(
name|acked
operator|>
literal|0
operator|||
name|new_sacked_bytes
condition|)
block|{
if|if
condition|(
name|acked
operator|==
literal|0
operator|&&
name|new_sacked_bytes
condition|)
block|{
comment|/* Use last sacked data. */
name|ack
operator|=
name|tp
operator|->
name|sackhint
operator|.
name|last_sack_ack
expr_stmt|;
block|}
else|else
name|ack
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|txsi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|)
expr_stmt|;
while|while
condition|(
name|txsi
operator|!=
name|NULL
condition|)
block|{
name|rts
operator|=
literal|0
expr_stmt|;
comment|/* Acknowledgement is acking more than this txsi. */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|ack
argument_list|,
name|txsi
operator|->
name|seq
operator|+
name|txsi
operator|->
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|txsi
operator|->
name|flags
operator|&
name|TXSI_RTT_MEASURE_START
operator|||
name|measurenext
condition|)
block|{
name|marked_packet_rtt
argument_list|(
name|txsi
argument_list|,
name|e_t
argument_list|,
name|tp
argument_list|,
operator|&
name|measurenext
argument_list|,
operator|&
name|measurenext_len
argument_list|,
operator|&
name|rtt_bytes_adjust
argument_list|,
name|MULTI_ACK
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|,
name|txsi
argument_list|,
name|txsegi_lnk
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|txseginfo_zone
argument_list|,
name|txsi
argument_list|)
expr_stmt|;
name|txsi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Guess if delayed acks are being used by the receiver. 			 * 			 * XXXDH: A simple heuristic that could be improved 			 */
if|if
condition|(
operator|!
name|new_sacked_bytes
condition|)
block|{
if|if
condition|(
name|acked
operator|>
name|tp
operator|->
name|t_maxseg
condition|)
block|{
name|e_t
operator|->
name|dlyack_rx
operator|+=
operator|(
name|e_t
operator|->
name|dlyack_rx
operator|<
name|DLYACK_SMOOTH
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|multiack
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acked
operator|>
name|txsi
operator|->
name|len
condition|)
block|{
name|multiack
operator|=
literal|1
expr_stmt|;
name|e_t
operator|->
name|dlyack_rx
operator|+=
operator|(
name|e_t
operator|->
name|dlyack_rx
operator|<
name|DLYACK_SMOOTH
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|acked
operator|==
name|tp
operator|->
name|t_maxseg
operator|||
name|acked
operator|==
name|txsi
operator|->
name|len
condition|)
block|{
name|e_t
operator|->
name|dlyack_rx
operator|-=
operator|(
name|e_t
operator|->
name|dlyack_rx
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
comment|/* Otherwise leave dlyack_rx the way it was. */
block|}
comment|/* 			 * Time stamps are only to help match the txsi with the 			 * received acknowledgements. 			 */
if|if
condition|(
name|e_t
operator|->
name|timestamp_errors
operator|<
name|MAX_TS_ERR
operator|&&
operator|(
name|to
operator|->
name|to_flags
operator|&
name|TOF_TS
operator|)
operator|!=
literal|0
operator|&&
name|to
operator|->
name|to_tsecr
condition|)
block|{
comment|/* 				 * Note: All packets sent with the offload will 				 * have the same time stamp. If we are sending 				 * on a fast interface and the t_maxseg is much 				 * smaller than one tick, this will be fine. The 				 * time stamp would be the same whether we were 				 * using tso or not. However, if the interface 				 * is slow, this will cause problems with the 				 * calculations. If the interface is slow, there 				 * is not reason to be using tso, and it should 				 * be turned off. 				 */
comment|/* 				 * If there are too many time stamp errors, time 				 * stamps won't be trusted 				 */
name|rts
operator|=
name|to
operator|->
name|to_tsecr
expr_stmt|;
comment|/* Before this packet. */
if|if
condition|(
operator|!
name|e_t
operator|->
name|dlyack_rx
operator|&&
name|TSTMP_LT
argument_list|(
name|rts
argument_list|,
name|txsi
operator|->
name|tx_ts
argument_list|)
condition|)
comment|/* When delayed acking is used, the 					 * reflected time stamp is of the first 					 * packet and thus may be before 					 * txsi->tx_ts. 					 */
break|break;
if|if
condition|(
name|TSTMP_GT
argument_list|(
name|rts
argument_list|,
name|txsi
operator|->
name|tx_ts
argument_list|)
condition|)
block|{
comment|/* 					 * If reflected time stamp is later than 					 * tx_tsi, then this txsi is old. 					 */
if|if
condition|(
name|txsi
operator|->
name|flags
operator|&
name|TXSI_RTT_MEASURE_START
operator|||
name|measurenext
condition|)
block|{
name|marked_packet_rtt
argument_list|(
name|txsi
argument_list|,
name|e_t
argument_list|,
name|tp
argument_list|,
operator|&
name|measurenext
argument_list|,
operator|&
name|measurenext_len
argument_list|,
operator|&
name|rtt_bytes_adjust
argument_list|,
name|OLD_TXSI
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|,
name|txsi
argument_list|,
name|txsegi_lnk
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|txseginfo_zone
argument_list|,
name|txsi
argument_list|)
expr_stmt|;
name|txsi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rts
operator|==
name|txsi
operator|->
name|tx_ts
operator|&&
name|TSTMP_LT
argument_list|(
name|to
operator|->
name|to_tsval
argument_list|,
name|txsi
operator|->
name|rx_ts
argument_list|)
condition|)
block|{
comment|/* 					 * Segment received before sent! 					 * Something is wrong with the received 					 * timestamps so increment errors. If 					 * this keeps up we will ignore 					 * timestamps. 					 */
name|e_t
operator|->
name|timestamp_errors
operator|++
expr_stmt|;
block|}
block|}
comment|/* 			 * Acknowledging a sequence number before this txsi. 			 * If it is an old txsi that may have had the same seq 			 * numbers, it should have been removed if time stamps 			 * are being used. 			 */
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|ack
argument_list|,
name|txsi
operator|->
name|seq
argument_list|)
condition|)
break|break;
comment|/* Before first packet in txsi. */
comment|/* 			 * Only ack> txsi->seq and ack<= txsi->seq+txsi->len 			 * past this point. 			 * 			 * If delayed acks are being used, an acknowledgement 			 * for a single segment will have been delayed by the 			 * receiver and will yield an inaccurate measurement. In 			 * this case, we only make the measurement if more than 			 * one segment is being acknowledged or sack is 			 * currently being used. 			 */
if|if
condition|(
operator|!
name|e_t
operator|->
name|dlyack_rx
operator|||
name|multiack
operator|||
name|new_sacked_bytes
condition|)
block|{
comment|/* Make an accurate new measurement. */
name|e_t
operator|->
name|rtt
operator|=
name|tcp_ts_getticks
argument_list|()
operator|-
name|txsi
operator|->
name|tx_ts
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|e_t
operator|->
name|rtt
operator|<
name|e_t
operator|->
name|minrtt
operator|||
name|e_t
operator|->
name|minrtt
operator|==
literal|0
condition|)
name|e_t
operator|->
name|minrtt
operator|=
name|e_t
operator|->
name|rtt
expr_stmt|;
if|if
condition|(
name|e_t
operator|->
name|rtt
operator|>
name|e_t
operator|->
name|maxrtt
operator|||
name|e_t
operator|->
name|maxrtt
operator|==
literal|0
condition|)
name|e_t
operator|->
name|maxrtt
operator|=
name|e_t
operator|->
name|rtt
expr_stmt|;
block|}
if|if
condition|(
name|txsi
operator|->
name|flags
operator|&
name|TXSI_RTT_MEASURE_START
operator|||
name|measurenext
condition|)
name|marked_packet_rtt
argument_list|(
name|txsi
argument_list|,
name|e_t
argument_list|,
name|tp
argument_list|,
operator|&
name|measurenext
argument_list|,
operator|&
name|measurenext_len
argument_list|,
operator|&
name|rtt_bytes_adjust
argument_list|,
name|CORRECT_ACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|txsi
operator|->
name|flags
operator|&
name|TXSI_TSO
condition|)
block|{
name|txsi
operator|->
name|len
operator|-=
name|acked
expr_stmt|;
if|if
condition|(
name|txsi
operator|->
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 					 * This presumes ack for first bytes in 					 * txsi, this may not be true but it 					 * shouldn't cause problems for the 					 * timing. 					 * 					 * We remeasure RTT even though we only 					 * have a single txsi. The rationale 					 * behind this is that it is better to 					 * have a slightly inaccurate 					 * measurement than no additional 					 * measurement for the rest of the bulk 					 * transfer. Since TSO is only used on 					 * high speed interface cards, so the 					 * packets should be transmitted at line 					 * rate back to back with little 					 * difference in transmission times (in 					 * ticks). 					 */
name|txsi
operator|->
name|seq
operator|+=
name|acked
expr_stmt|;
comment|/* 					 * Reset txsi measure flag so we don't 					 * use it for another RTT measurement. 					 */
name|txsi
operator|->
name|flags
operator|&=
operator|~
name|TXSI_RTT_MEASURE_START
expr_stmt|;
comment|/* 					 * There is still more data to be acked 					 * from tso bulk transmission, so we 					 * won't remove it from the TAILQ yet. 					 */
break|break;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|,
name|txsi
argument_list|,
name|txsegi_lnk
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|txseginfo_zone
argument_list|,
name|txsi
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|measurenext
condition|)
block|{
comment|/* 			 * We need to do a RTT measurement. It won't be the best 			 * if we do it here. 			 */
name|marked_packet_rtt
argument_list|(
name|txsi
argument_list|,
name|e_t
argument_list|,
name|tp
argument_list|,
operator|&
name|measurenext
argument_list|,
operator|&
name|measurenext_len
argument_list|,
operator|&
name|rtt_bytes_adjust
argument_list|,
name|FORCED_MEASUREMENT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add information about a transmitted segment to a list.  * This is called via the helper hook in tcp_output.c  */
end_comment

begin_function
specifier|static
name|int
name|ertt_add_tx_segment_info_hook
parameter_list|(
name|int
name|hhook_type
parameter_list|,
name|int
name|hhook_id
parameter_list|,
name|void
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|ctx_data
parameter_list|,
name|void
modifier|*
name|hdata
parameter_list|,
name|struct
name|osd
modifier|*
name|hosd
parameter_list|)
block|{
name|struct
name|ertt
modifier|*
name|e_t
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|tcpopt
modifier|*
name|to
decl_stmt|;
name|struct
name|tcp_hhook_data
modifier|*
name|thdp
decl_stmt|;
name|struct
name|txseginfo
modifier|*
name|txsi
decl_stmt|;
name|long
name|len
decl_stmt|;
name|int
name|tso
decl_stmt|;
name|KASSERT
argument_list|(
name|ctx_data
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ctx_data is NULL!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|hdata
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: hdata is NULL!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|e_t
operator|=
operator|(
expr|struct
name|ertt
operator|*
operator|)
name|hdata
expr_stmt|;
name|thdp
operator|=
name|ctx_data
expr_stmt|;
name|tp
operator|=
name|thdp
operator|->
name|tp
expr_stmt|;
name|th
operator|=
name|thdp
operator|->
name|th
expr_stmt|;
name|to
operator|=
name|thdp
operator|->
name|to
expr_stmt|;
name|len
operator|=
name|thdp
operator|->
name|len
expr_stmt|;
name|tso
operator|=
name|thdp
operator|->
name|tso
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|txsi
operator|=
name|uma_zalloc
argument_list|(
name|txseginfo_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|txsi
operator|!=
name|NULL
condition|)
block|{
comment|/* Construct txsi setting the necessary flags. */
name|txsi
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Needs to be initialised. */
name|txsi
operator|->
name|seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|txsi
operator|->
name|len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|tso
condition|)
name|txsi
operator|->
name|flags
operator||=
name|TXSI_TSO
expr_stmt|;
elseif|else
if|if
condition|(
name|e_t
operator|->
name|flags
operator|&
name|ERTT_TSO_DISABLED
condition|)
block|{
name|tp
operator|->
name|t_flags
operator||=
name|TF_TSO
expr_stmt|;
name|e_t
operator|->
name|flags
operator|&=
operator|~
name|ERTT_TSO_DISABLED
expr_stmt|;
block|}
if|if
condition|(
name|e_t
operator|->
name|flags
operator|&
name|ERTT_MEASUREMENT_IN_PROGRESS
condition|)
block|{
name|e_t
operator|->
name|bytes_tx_in_rtt
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|txsi
operator|->
name|flags
operator||=
name|TXSI_RTT_MEASURE_START
expr_stmt|;
name|e_t
operator|->
name|flags
operator||=
name|ERTT_MEASUREMENT_IN_PROGRESS
expr_stmt|;
name|e_t
operator|->
name|bytes_tx_in_rtt
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NOOPT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|to
operator|->
name|to_flags
operator|&
name|TOF_TS
operator|)
condition|)
block|{
name|txsi
operator|->
name|tx_ts
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_tsval
argument_list|)
operator|-
name|tp
operator|->
name|ts_offset
expr_stmt|;
name|txsi
operator|->
name|rx_ts
operator|=
name|ntohl
argument_list|(
name|to
operator|->
name|to_tsecr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txsi
operator|->
name|tx_ts
operator|=
name|tcp_ts_getticks
argument_list|()
expr_stmt|;
name|txsi
operator|->
name|rx_ts
operator|=
literal|0
expr_stmt|;
comment|/* No received time stamp. */
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|,
name|txsi
argument_list|,
name|txsegi_lnk
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ertt_mod_init
parameter_list|(
name|void
parameter_list|)
block|{
name|txseginfo_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"ertt_txseginfo"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|txseginfo
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ertt_mod_destroy
parameter_list|(
name|void
parameter_list|)
block|{
name|uma_zdestroy
argument_list|(
name|txseginfo_zone
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ertt_uma_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ertt
modifier|*
name|e_t
decl_stmt|;
name|e_t
operator|=
name|mem
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|)
expr_stmt|;
name|e_t
operator|->
name|timestamp_errors
operator|=
literal|0
expr_stmt|;
name|e_t
operator|->
name|minrtt
operator|=
literal|0
expr_stmt|;
name|e_t
operator|->
name|maxrtt
operator|=
literal|0
expr_stmt|;
name|e_t
operator|->
name|rtt
operator|=
literal|0
expr_stmt|;
name|e_t
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|e_t
operator|->
name|dlyack_rx
operator|=
literal|0
expr_stmt|;
name|e_t
operator|->
name|bytes_tx_in_rtt
operator|=
literal|0
expr_stmt|;
name|e_t
operator|->
name|markedpkt_rtt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ertt_uma_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ertt
modifier|*
name|e_t
decl_stmt|;
name|struct
name|txseginfo
modifier|*
name|n_txsi
decl_stmt|,
modifier|*
name|txsi
decl_stmt|;
name|e_t
operator|=
name|mem
expr_stmt|;
name|txsi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|e_t
operator|->
name|txsegi_q
argument_list|)
expr_stmt|;
while|while
condition|(
name|txsi
operator|!=
name|NULL
condition|)
block|{
name|n_txsi
operator|=
name|TAILQ_NEXT
argument_list|(
name|txsi
argument_list|,
name|txsegi_lnk
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|txseginfo_zone
argument_list|,
name|txsi
argument_list|)
expr_stmt|;
name|txsi
operator|=
name|n_txsi
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|KHELP_DECLARE_MOD_UMA
argument_list|(
name|ertt
argument_list|,
operator|&
name|ertt_helper
argument_list|,
name|ertt_hooks
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ertt
argument_list|)
argument_list|,
name|ertt_uma_ctor
argument_list|,
name|ertt_uma_dtor
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

