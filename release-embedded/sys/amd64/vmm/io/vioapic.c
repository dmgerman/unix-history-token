begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Tycho Nightingale<tycho.nightingale@pluribusnetworks.com>  * Copyright (c) 2013 Neel Natu<neel@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY NETAPP, INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL NETAPP, INC OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmm.h>
end_include

begin_include
include|#
directive|include
file|"vmm_ktr.h"
end_include

begin_include
include|#
directive|include
file|"vmm_lapic.h"
end_include

begin_include
include|#
directive|include
file|"vlapic.h"
end_include

begin_include
include|#
directive|include
file|"vioapic.h"
end_include

begin_define
define|#
directive|define
name|IOREGSEL
value|0x00
end_define

begin_define
define|#
directive|define
name|IOWIN
value|0x10
end_define

begin_define
define|#
directive|define
name|REDIR_ENTRIES
value|24
end_define

begin_define
define|#
directive|define
name|RTBL_RO_BITS
value|((uint64_t)(IOART_REM_IRR | IOART_DELIVS))
end_define

begin_struct
struct|struct
name|vioapic
block|{
name|struct
name|vm
modifier|*
name|vm
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|ioregsel
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|reg
decl_stmt|;
name|int
name|acnt
decl_stmt|;
comment|/* sum of pin asserts (+1) and deasserts (-1) */
block|}
name|rtbl
index|[
name|REDIR_ENTRIES
index|]
struct|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VIOAPIC_LOCK
parameter_list|(
name|vioapic
parameter_list|)
value|mtx_lock_spin(&((vioapic)->mtx))
end_define

begin_define
define|#
directive|define
name|VIOAPIC_UNLOCK
parameter_list|(
name|vioapic
parameter_list|)
value|mtx_unlock_spin(&((vioapic)->mtx))
end_define

begin_define
define|#
directive|define
name|VIOAPIC_LOCKED
parameter_list|(
name|vioapic
parameter_list|)
value|mtx_owned(&((vioapic)->mtx))
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VIOAPIC
argument_list|,
literal|"vioapic"
argument_list|,
literal|"bhyve virtual ioapic"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|VIOAPIC_CTR1
parameter_list|(
name|vioapic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|)
define|\
value|VM_CTR1((vioapic)->vm, fmt, a1)
end_define

begin_define
define|#
directive|define
name|VIOAPIC_CTR2
parameter_list|(
name|vioapic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|VM_CTR2((vioapic)->vm, fmt, a1, a2)
end_define

begin_define
define|#
directive|define
name|VIOAPIC_CTR3
parameter_list|(
name|vioapic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
define|\
value|VM_CTR3((vioapic)->vm, fmt, a1, a2, a3)
end_define

begin_define
define|#
directive|define
name|VIOAPIC_CTR4
parameter_list|(
name|vioapic
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|)
define|\
value|VM_CTR4((vioapic)->vm, fmt, a1, a2, a3, a4)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pinstate_str
parameter_list|(
name|bool
name|asserted
parameter_list|)
block|{
if|if
condition|(
name|asserted
condition|)
return|return
operator|(
literal|"asserted"
operator|)
return|;
else|else
return|return
operator|(
literal|"deasserted"
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|vioapic_send_intr
parameter_list|(
name|struct
name|vioapic
modifier|*
name|vioapic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|vector
decl_stmt|,
name|delmode
decl_stmt|;
name|uint32_t
name|low
decl_stmt|,
name|high
decl_stmt|,
name|dest
decl_stmt|;
name|bool
name|level
decl_stmt|,
name|phys
decl_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|>=
literal|0
operator|&&
name|pin
operator|<
name|REDIR_ENTRIES
argument_list|,
operator|(
literal|"vioapic_set_pinstate: invalid pin number %d"
operator|,
name|pin
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|VIOAPIC_LOCKED
argument_list|(
name|vioapic
argument_list|)
argument_list|,
operator|(
literal|"vioapic_set_pinstate: vioapic is not locked"
operator|)
argument_list|)
expr_stmt|;
name|low
operator|=
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
expr_stmt|;
name|high
operator|=
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|low
operator|&
name|IOART_INTMASK
operator|)
operator|==
name|IOART_INTMSET
condition|)
block|{
name|VIOAPIC_CTR1
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: masked"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
return|return;
block|}
name|phys
operator|=
operator|(
operator|(
name|low
operator|&
name|IOART_DESTMOD
operator|)
operator|==
name|IOART_DESTPHY
operator|)
expr_stmt|;
name|delmode
operator|=
name|low
operator|&
name|IOART_DELMOD
expr_stmt|;
name|level
operator|=
name|low
operator|&
name|IOART_TRGRLVL
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator||=
name|IOART_REM_IRR
expr_stmt|;
name|vector
operator|=
name|low
operator|&
name|IOART_INTVEC
expr_stmt|;
name|dest
operator|=
name|high
operator|>>
name|APIC_ID_SHIFT
expr_stmt|;
name|vlapic_deliver_intr
argument_list|(
name|vioapic
operator|->
name|vm
argument_list|,
name|level
argument_list|,
name|dest
argument_list|,
name|phys
argument_list|,
name|delmode
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vioapic_set_pinstate
parameter_list|(
name|struct
name|vioapic
modifier|*
name|vioapic
parameter_list|,
name|int
name|pin
parameter_list|,
name|bool
name|newstate
parameter_list|)
block|{
name|int
name|oldcnt
decl_stmt|,
name|newcnt
decl_stmt|;
name|bool
name|needintr
decl_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|>=
literal|0
operator|&&
name|pin
operator|<
name|REDIR_ENTRIES
argument_list|,
operator|(
literal|"vioapic_set_pinstate: invalid pin number %d"
operator|,
name|pin
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|VIOAPIC_LOCKED
argument_list|(
name|vioapic
argument_list|)
argument_list|,
operator|(
literal|"vioapic_set_pinstate: vioapic is not locked"
operator|)
argument_list|)
expr_stmt|;
name|oldcnt
operator|=
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
expr_stmt|;
if|if
condition|(
name|newstate
condition|)
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
operator|++
expr_stmt|;
else|else
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
operator|--
expr_stmt|;
name|newcnt
operator|=
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
expr_stmt|;
if|if
condition|(
name|newcnt
operator|<
literal|0
condition|)
block|{
name|VIOAPIC_CTR2
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: bad acnt %d"
argument_list|,
name|pin
argument_list|,
name|newcnt
argument_list|)
expr_stmt|;
block|}
name|needintr
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|oldcnt
operator|==
literal|0
operator|&&
name|newcnt
operator|==
literal|1
condition|)
block|{
name|needintr
operator|=
name|true
expr_stmt|;
name|VIOAPIC_CTR1
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: asserted"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldcnt
operator|==
literal|1
operator|&&
name|newcnt
operator|==
literal|0
condition|)
block|{
name|VIOAPIC_CTR1
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: deasserted"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VIOAPIC_CTR3
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: %s, ignored, acnt %d"
argument_list|,
name|pin
argument_list|,
name|pinstate_str
argument_list|(
name|newstate
argument_list|)
argument_list|,
name|newcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needintr
condition|)
name|vioapic_send_intr
argument_list|(
name|vioapic
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
name|irqstate
block|{
name|IRQSTATE_ASSERT
block|,
name|IRQSTATE_DEASSERT
block|,
name|IRQSTATE_PULSE
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|vioapic_set_irqstate
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|,
name|enum
name|irqstate
name|irqstate
parameter_list|)
block|{
name|struct
name|vioapic
modifier|*
name|vioapic
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>=
name|REDIR_ENTRIES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vioapic
operator|=
name|vm_ioapic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VIOAPIC_LOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irqstate
condition|)
block|{
case|case
name|IRQSTATE_ASSERT
case|:
name|vioapic_set_pinstate
argument_list|(
name|vioapic
argument_list|,
name|irq
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRQSTATE_DEASSERT
case|:
name|vioapic_set_pinstate
argument_list|(
name|vioapic
argument_list|,
name|irq
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|IRQSTATE_PULSE
case|:
name|vioapic_set_pinstate
argument_list|(
name|vioapic
argument_list|,
name|irq
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|vioapic_set_pinstate
argument_list|(
name|vioapic
argument_list|,
name|irq
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"vioapic_set_irqstate: invalid irqstate %d"
argument_list|,
name|irqstate
argument_list|)
expr_stmt|;
block|}
name|VIOAPIC_UNLOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vioapic_assert_irq
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
return|return
operator|(
name|vioapic_set_irqstate
argument_list|(
name|vm
argument_list|,
name|irq
argument_list|,
name|IRQSTATE_ASSERT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vioapic_deassert_irq
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
return|return
operator|(
name|vioapic_set_irqstate
argument_list|(
name|vm
argument_list|,
name|irq
argument_list|,
name|IRQSTATE_DEASSERT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vioapic_pulse_irq
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
return|return
operator|(
name|vioapic_set_irqstate
argument_list|(
name|vm
argument_list|,
name|irq
argument_list|,
name|IRQSTATE_PULSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the vlapic's trigger-mode register to reflect the ioapic pin  * configuration.  */
end_comment

begin_function
specifier|static
name|void
name|vioapic_update_tmr
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vioapic
modifier|*
name|vioapic
decl_stmt|;
name|struct
name|vlapic
modifier|*
name|vlapic
decl_stmt|;
name|uint32_t
name|low
decl_stmt|,
name|high
decl_stmt|,
name|dest
decl_stmt|;
name|int
name|delmode
decl_stmt|,
name|pin
decl_stmt|,
name|vector
decl_stmt|;
name|bool
name|level
decl_stmt|,
name|phys
decl_stmt|;
name|vlapic
operator|=
name|vm_lapic
argument_list|(
name|vm
argument_list|,
name|vcpuid
argument_list|)
expr_stmt|;
name|vioapic
operator|=
name|vm_ioapic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VIOAPIC_LOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
comment|/* 	 * Reset all vectors to be edge-triggered. 	 */
name|vlapic_reset_tmr
argument_list|(
name|vlapic
argument_list|)
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
name|REDIR_ENTRIES
condition|;
name|pin
operator|++
control|)
block|{
name|low
operator|=
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
expr_stmt|;
name|high
operator|=
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|>>
literal|32
expr_stmt|;
name|level
operator|=
name|low
operator|&
name|IOART_TRGRLVL
condition|?
name|true
else|:
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|level
condition|)
continue|continue;
comment|/* 		 * For a level-triggered 'pin' let the vlapic figure out if 		 * an assertion on this 'pin' would result in an interrupt 		 * being delivered to it. If yes, then it will modify the 		 * TMR bit associated with this vector to level-triggered. 		 */
name|phys
operator|=
operator|(
operator|(
name|low
operator|&
name|IOART_DESTMOD
operator|)
operator|==
name|IOART_DESTPHY
operator|)
expr_stmt|;
name|delmode
operator|=
name|low
operator|&
name|IOART_DELMOD
expr_stmt|;
name|vector
operator|=
name|low
operator|&
name|IOART_INTVEC
expr_stmt|;
name|dest
operator|=
name|high
operator|>>
name|APIC_ID_SHIFT
expr_stmt|;
name|vlapic_set_tmr_level
argument_list|(
name|vlapic
argument_list|,
name|dest
argument_list|,
name|phys
argument_list|,
name|delmode
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
name|VIOAPIC_UNLOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|vioapic_read
parameter_list|(
name|struct
name|vioapic
modifier|*
name|vioapic
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|,
name|pin
decl_stmt|,
name|rshift
decl_stmt|;
name|regnum
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|IOAPIC_ID
case|:
return|return
operator|(
name|vioapic
operator|->
name|id
operator|)
return|;
break|break;
case|case
name|IOAPIC_VER
case|:
return|return
operator|(
operator|(
operator|(
name|REDIR_ENTRIES
operator|-
literal|1
operator|)
operator|<<
name|MAXREDIRSHIFT
operator|)
operator||
literal|0x11
operator|)
return|;
break|break;
case|case
name|IOAPIC_ARB
case|:
return|return
operator|(
name|vioapic
operator|->
name|id
operator|)
return|;
break|break;
default|default:
break|break;
block|}
comment|/* redirection table entries */
if|if
condition|(
name|regnum
operator|>=
name|IOAPIC_REDTBL
operator|&&
name|regnum
operator|<
name|IOAPIC_REDTBL
operator|+
name|REDIR_ENTRIES
operator|*
literal|2
condition|)
block|{
name|pin
operator|=
operator|(
name|regnum
operator|-
name|IOAPIC_REDTBL
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|-
name|IOAPIC_REDTBL
operator|)
operator|%
literal|2
condition|)
name|rshift
operator|=
literal|32
expr_stmt|;
else|else
name|rshift
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|>>
name|rshift
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vioapic_write
parameter_list|(
name|struct
name|vioapic
modifier|*
name|vioapic
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint64_t
name|data64
decl_stmt|,
name|mask64
decl_stmt|;
name|uint64_t
name|last
decl_stmt|,
name|changed
decl_stmt|;
name|int
name|regnum
decl_stmt|,
name|pin
decl_stmt|,
name|lshift
decl_stmt|;
name|cpuset_t
name|allvcpus
decl_stmt|;
name|regnum
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|IOAPIC_ID
case|:
name|vioapic
operator|->
name|id
operator|=
name|data
operator|&
name|APIC_ID_MASK
expr_stmt|;
break|break;
case|case
name|IOAPIC_VER
case|:
case|case
name|IOAPIC_ARB
case|:
comment|/* readonly */
break|break;
default|default:
break|break;
block|}
comment|/* redirection table entries */
if|if
condition|(
name|regnum
operator|>=
name|IOAPIC_REDTBL
operator|&&
name|regnum
operator|<
name|IOAPIC_REDTBL
operator|+
name|REDIR_ENTRIES
operator|*
literal|2
condition|)
block|{
name|pin
operator|=
operator|(
name|regnum
operator|-
name|IOAPIC_REDTBL
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|-
name|IOAPIC_REDTBL
operator|)
operator|%
literal|2
condition|)
name|lshift
operator|=
literal|32
expr_stmt|;
else|else
name|lshift
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
expr_stmt|;
name|data64
operator|=
operator|(
name|uint64_t
operator|)
name|data
operator|<<
name|lshift
expr_stmt|;
name|mask64
operator|=
operator|(
name|uint64_t
operator|)
literal|0xffffffff
operator|<<
name|lshift
expr_stmt|;
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|&=
operator|~
name|mask64
operator||
name|RTBL_RO_BITS
expr_stmt|;
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator||=
name|data64
operator|&
operator|~
name|RTBL_RO_BITS
expr_stmt|;
name|VIOAPIC_CTR2
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: redir table entry %#lx"
argument_list|,
name|pin
argument_list|,
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
comment|/* 		 * If any fields in the redirection table entry (except mask 		 * or polarity) have changed then rendezvous all the vcpus 		 * to update their vlapic trigger-mode registers. 		 */
name|changed
operator|=
name|last
operator|^
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
expr_stmt|;
if|if
condition|(
name|changed
operator|&
operator|~
operator|(
name|IOART_INTMASK
operator||
name|IOART_INTPOL
operator|)
condition|)
block|{
name|VIOAPIC_CTR1
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: recalculate "
literal|"vlapic trigger-mode register"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
name|VIOAPIC_UNLOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
name|allvcpus
operator|=
name|vm_active_cpus
argument_list|(
name|vioapic
operator|->
name|vm
argument_list|)
expr_stmt|;
name|vm_smp_rendezvous
argument_list|(
name|vioapic
operator|->
name|vm
argument_list|,
name|vcpuid
argument_list|,
name|allvcpus
argument_list|,
name|vioapic_update_tmr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VIOAPIC_LOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Generate an interrupt if the following conditions are met: 		 * - pin is not masked 		 * - previous interrupt has been EOIed 		 * - pin level is asserted 		 */
if|if
condition|(
operator|(
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|&
name|IOART_INTMASK
operator|)
operator|==
name|IOART_INTMCLR
operator|&&
operator|(
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|&
name|IOART_REM_IRR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
operator|>
literal|0
operator|)
condition|)
block|{
name|VIOAPIC_CTR2
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: asserted at rtbl "
literal|"write, acnt %d"
argument_list|,
name|pin
argument_list|,
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
argument_list|)
expr_stmt|;
name|vioapic_send_intr
argument_list|(
name|vioapic
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vioapic_mmio_rw
parameter_list|(
name|struct
name|vioapic
modifier|*
name|vioapic
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|,
name|int
name|size
parameter_list|,
name|bool
name|doread
parameter_list|)
block|{
name|uint64_t
name|offset
decl_stmt|;
name|offset
operator|=
name|gpa
operator|-
name|VIOAPIC_BASE
expr_stmt|;
comment|/* 	 * The IOAPIC specification allows 32-bit wide accesses to the 	 * IOREGSEL (offset 0) and IOWIN (offset 16) registers. 	 */
if|if
condition|(
name|size
operator|!=
literal|4
operator|||
operator|(
name|offset
operator|!=
name|IOREGSEL
operator|&&
name|offset
operator|!=
name|IOWIN
operator|)
condition|)
block|{
if|if
condition|(
name|doread
condition|)
operator|*
name|data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VIOAPIC_LOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|IOREGSEL
condition|)
block|{
if|if
condition|(
name|doread
condition|)
operator|*
name|data
operator|=
name|vioapic
operator|->
name|ioregsel
expr_stmt|;
else|else
name|vioapic
operator|->
name|ioregsel
operator|=
operator|*
name|data
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|doread
condition|)
block|{
operator|*
name|data
operator|=
name|vioapic_read
argument_list|(
name|vioapic
argument_list|,
name|vcpuid
argument_list|,
name|vioapic
operator|->
name|ioregsel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vioapic_write
argument_list|(
name|vioapic
argument_list|,
name|vcpuid
argument_list|,
name|vioapic
operator|->
name|ioregsel
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|VIOAPIC_UNLOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vioapic_mmio_read
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
modifier|*
name|rval
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vioapic
modifier|*
name|vioapic
decl_stmt|;
name|vioapic
operator|=
name|vm_ioapic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|error
operator|=
name|vioapic_mmio_rw
argument_list|(
name|vioapic
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
name|rval
argument_list|,
name|size
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vioapic_mmio_write
parameter_list|(
name|void
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|uint64_t
name|gpa
parameter_list|,
name|uint64_t
name|wval
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vioapic
modifier|*
name|vioapic
decl_stmt|;
name|vioapic
operator|=
name|vm_ioapic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|error
operator|=
name|vioapic_mmio_rw
argument_list|(
name|vioapic
argument_list|,
name|vcpuid
argument_list|,
name|gpa
argument_list|,
operator|&
name|wval
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vioapic_process_eoi
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|,
name|int
name|vcpuid
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
name|struct
name|vioapic
modifier|*
name|vioapic
decl_stmt|;
name|int
name|pin
decl_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
literal|0
operator|&&
name|vector
operator|<
literal|256
argument_list|,
operator|(
literal|"vioapic_process_eoi: invalid vector %d"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|vioapic
operator|=
name|vm_ioapic
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|VIOAPIC_CTR1
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic processing eoi for vector %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* 	 * XXX keep track of the pins associated with this vector instead 	 * of iterating on every single pin each time. 	 */
name|VIOAPIC_LOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
name|REDIR_ENTRIES
condition|;
name|pin
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|&
name|IOART_REM_IRR
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|&
name|IOART_INTVEC
operator|)
operator|!=
name|vector
condition|)
continue|continue;
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|reg
operator|&=
operator|~
name|IOART_REM_IRR
expr_stmt|;
if|if
condition|(
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
operator|>
literal|0
condition|)
block|{
name|VIOAPIC_CTR2
argument_list|(
name|vioapic
argument_list|,
literal|"ioapic pin%d: asserted at eoi, "
literal|"acnt %d"
argument_list|,
name|pin
argument_list|,
name|vioapic
operator|->
name|rtbl
index|[
name|pin
index|]
operator|.
name|acnt
argument_list|)
expr_stmt|;
name|vioapic_send_intr
argument_list|(
name|vioapic
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
block|}
name|VIOAPIC_UNLOCK
argument_list|(
name|vioapic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|vioapic
modifier|*
name|vioapic_init
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vioapic
modifier|*
name|vioapic
decl_stmt|;
name|vioapic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vioapic
argument_list|)
argument_list|,
name|M_VIOAPIC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vioapic
operator|->
name|vm
operator|=
name|vm
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|vioapic
operator|->
name|mtx
argument_list|,
literal|"vioapic lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Initialize all redirection entries to mask all interrupts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REDIR_ENTRIES
condition|;
name|i
operator|++
control|)
name|vioapic
operator|->
name|rtbl
index|[
name|i
index|]
operator|.
name|reg
operator|=
literal|0x0001000000010000UL
expr_stmt|;
return|return
operator|(
name|vioapic
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vioapic_cleanup
parameter_list|(
name|struct
name|vioapic
modifier|*
name|vioapic
parameter_list|)
block|{
name|free
argument_list|(
name|vioapic
argument_list|,
name|M_VIOAPIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vioapic_pincount
parameter_list|(
name|struct
name|vm
modifier|*
name|vm
parameter_list|)
block|{
return|return
operator|(
name|REDIR_ENTRIES
operator|)
return|;
block|}
end_function

end_unit

