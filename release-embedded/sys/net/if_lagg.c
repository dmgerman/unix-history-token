begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_trunk.c,v 1.30 2007/01/31 06:20:19 reyk Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2006 Reyk Floeter<reyk@openbsd.org>  * Copyright (c) 2007 Andrew Thompson<thompsa@FreeBSD.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_lagg.h>
end_include

begin_include
include|#
directive|include
file|<net/ieee8023ad_lacp.h>
end_include

begin_comment
comment|/* Special flags we should propagate to the lagg ports. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|flag
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|lagg_pflags
index|[]
init|=
block|{
block|{
name|IFF_PROMISC
block|,
name|ifpromisc
block|}
block|,
block|{
name|IFF_ALLMULTI
block|,
name|if_allmulti
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_macro
name|SLIST_HEAD
argument_list|(
argument|__trhead
argument_list|,
argument|lagg_softc
argument_list|)
end_macro

begin_expr_stmt
name|lagg_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list of laggs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|lagg_list_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|eventhandler_tag
name|lagg_detach_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|lagg_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|if_clone
modifier|*
name|lagg_cloner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|laggname
index|[]
init|=
literal|"lagg"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|lagg_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_capabilities
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_lladdr
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_setlladdr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_create
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_input
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_linkstate
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|route
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LAGG_PORT_STACKING
end_ifdef

begin_function_decl
specifier|static
name|int
name|lagg_port_checkstacking
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|lagg_port2req
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|lagg_reqport
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_stop
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ether_setmulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ether_cmdmulti
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_setflag
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_setflags
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|lagg_port
modifier|*
name|lagg_link_active
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|lagg_gethdr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_sysctl_active
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Simple round robin */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_rr_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_rr_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_rr_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_rr_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Active failover */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_fail_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_fail_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_fail_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_fail_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Loadbalancing */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_lb_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_port_create
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lb_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lb_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_porttable
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 802.3ad LACP */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_lacp_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lacp_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lacp_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lacp_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lacp_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_callout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* lagg protocol table */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|ti_proto
decl_stmt|;
name|int
function_decl|(
modifier|*
name|ti_attach
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
block|}
name|lagg_protos
index|[]
init|=
block|{
block|{
name|LAGG_PROTO_ROUNDROBIN
block|,
name|lagg_rr_attach
block|}
block|,
block|{
name|LAGG_PROTO_FAILOVER
block|,
name|lagg_fail_attach
block|}
block|,
block|{
name|LAGG_PROTO_LOADBALANCE
block|,
name|lagg_lb_attach
block|}
block|,
block|{
name|LAGG_PROTO_ETHERCHANNEL
block|,
name|lagg_lb_attach
block|}
block|,
block|{
name|LAGG_PROTO_LACP
block|,
name|lagg_lacp_attach
block|}
block|,
block|{
name|LAGG_PROTO_NONE
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_link
argument_list|,
name|OID_AUTO
argument_list|,
name|lagg
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Link Aggregation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|lagg_failover_rx_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allow input on any failover links */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_lagg
argument_list|,
name|OID_AUTO
argument_list|,
name|failover_rx_all
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lagg_failover_rx_all
argument_list|,
literal|0
argument_list|,
literal|"Accept input from any interface in a failover lagg"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|def_use_flowid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default value for using M_FLOWID */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.link.lagg.default_use_flowid"
argument_list|,
operator|&
name|def_use_flowid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_lagg
argument_list|,
name|OID_AUTO
argument_list|,
name|default_use_flowid
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|def_use_flowid
argument_list|,
literal|0
argument_list|,
literal|"Default setting for using flow id for load sharing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|def_flowid_shift
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default value for using M_FLOWID */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.link.lagg.default_flowid_shift"
argument_list|,
operator|&
name|def_flowid_shift
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_lagg
argument_list|,
name|OID_AUTO
argument_list|,
name|default_flowid_shift
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|def_flowid_shift
argument_list|,
literal|0
argument_list|,
literal|"Default setting for flowid shift for load sharing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|lagg_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|,
literal|"if_lagg list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lagg_list
argument_list|)
expr_stmt|;
name|lagg_cloner
operator|=
name|if_clone_simple
argument_list|(
name|laggname
argument_list|,
name|lagg_clone_create
argument_list|,
name|lagg_clone_destroy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lagg_input_p
operator|=
name|lagg_input
expr_stmt|;
name|lagg_linkstate_p
operator|=
name|lagg_port_state
expr_stmt|;
name|lagg_detach_cookie
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|lagg_port_ifdetach
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|lagg_detach_cookie
argument_list|)
expr_stmt|;
name|if_clone_detach
argument_list|(
name|lagg_cloner
argument_list|)
expr_stmt|;
name|lagg_input_p
operator|=
name|NULL
expr_stmt|;
name|lagg_linkstate_p
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|lagg_mod
init|=
block|{
literal|"if_lagg"
block|,
name|lagg_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_lagg
argument_list|,
name|lagg_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_lagg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This routine is run via an vlan  * config EVENT  */
end_comment

begin_function
specifier|static
name|void
name|lagg_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int16_t
name|vtag
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|vlan_config
argument_list|,
name|lp
operator|->
name|lp_ifp
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is run via an vlan  * unconfig EVENT  */
end_comment

begin_function
specifier|static
name|void
name|lagg_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int16_t
name|vtag
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|vlan_unconfig
argument_list|,
name|lp
operator|->
name|lp_ifp
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 00:00:00:00:00:00 */
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|char
name|num
index|[
literal|14
index|]
decl_stmt|;
comment|/* sufficient for 32 bits */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ipackets
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opackets
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ibytes
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_obytes
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|use_flowid
operator|=
name|def_use_flowid
expr_stmt|;
name|sc
operator|->
name|flowid_shift
operator|=
name|def_flowid_shift
expr_stmt|;
name|sc
operator|->
name|sc_oid
operator|=
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
operator|&
name|SYSCTL_NODE_CHILDREN
argument_list|(
name|_net_link
argument_list|,
name|lagg
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|num
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"use_flowid"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|use_flowid
argument_list|,
name|sc
operator|->
name|use_flowid
argument_list|,
literal|"Use flow id for load sharing"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"flowid_shift"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|flowid_shift
argument_list|,
name|sc
operator|->
name|flowid_shift
argument_list|,
literal|"Shift flowid bits to prevent multiqueue collisions"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"count"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_count
argument_list|,
name|sc
operator|->
name|sc_count
argument_list|,
literal|"Total number of ports"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"active"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|lagg_sysctl_active
argument_list|,
literal|"I"
argument_list|,
literal|"Total number of active ports"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"flapping"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_flapping
argument_list|,
name|sc
operator|->
name|sc_flapping
argument_list|,
literal|"Total number of port change events"
argument_list|)
expr_stmt|;
comment|/* Hash all layers by default */
name|sc
operator|->
name|sc_flags
operator|=
name|LAGG_F_HASHL2
operator||
name|LAGG_F_HASHL3
operator||
name|LAGG_F_HASHL4
expr_stmt|;
name|sc
operator|->
name|sc_proto
operator|=
name|LAGG_PROTO_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|!=
name|LAGG_PROTO_NONE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|==
name|LAGG_PROTO_DEFAULT
condition|)
block|{
name|sc
operator|->
name|sc_proto
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_attach
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
block|}
block|}
name|LAGG_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_CALLOUT_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_lladdr_task
argument_list|,
literal|0
argument_list|,
name|lagg_port_setlladdr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * This uses the callout lock rather than the rmlock; one can't 	 * hold said rmlock during SWI. 	 */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
operator|&
name|sc
operator|->
name|sc_call_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialise pseudo media types */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|lagg_media_change
argument_list|,
name|lagg_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|laggname
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|lagg_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|lagg_qflush
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|lagg_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lagg_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWSTATS
expr_stmt|;
comment|/* 	 * Attach as an ordinary ethernet device, children will be attached 	 * as special device IFT_IEEE8023ADLAG. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|lagg_register_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|lagg_unregister_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* Insert into the global list of laggs */
name|mtx_lock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lagg_list
argument_list|,
name|sc
argument_list|,
name|sc_entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|hz
argument_list|,
name|lagg_callout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|sc
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|sc
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
comment|/* Shutdown and remove lagg ports */
while|while
condition|(
operator|(
name|lp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unhook the aggregation protocol */
if|if
condition|(
name|sc
operator|->
name|sc_detach
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_detach
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* This grabs sc_callout_mtx, serialising it correctly */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
comment|/* At this point it's drained; we can free this */
name|counter_u64_free
argument_list|(
name|sc
operator|->
name|sc_ipackets
argument_list|)
expr_stmt|;
name|counter_u64_free
argument_list|(
name|sc
operator|->
name|sc_opackets
argument_list|)
expr_stmt|;
name|counter_u64_free
argument_list|(
name|sc
operator|->
name|sc_ibytes
argument_list|)
expr_stmt|;
name|counter_u64_free
argument_list|(
name|sc
operator|->
name|sc_obytes
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|lagg_list
argument_list|,
name|sc
argument_list|,
name|lagg_softc
argument_list|,
name|sc_entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_lladdr_task
argument_list|)
expr_stmt|;
name|LAGG_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_CALLOUT_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Let the protocol know the MAC has changed */
if|if
condition|(
name|sc
operator|->
name|sc_lladdr
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_lladdr
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|iflladdr_event
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_capabilities
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|cap
init|=
operator|~
literal|0
decl_stmt|,
name|ena
init|=
operator|~
literal|0
decl_stmt|;
name|u_long
name|hwa
init|=
operator|~
literal|0UL
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get capabilities from the lagg ports */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
name|cap
operator|&=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ena
operator|&=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_capenable
expr_stmt|;
name|hwa
operator|&=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_hwassist
expr_stmt|;
block|}
name|cap
operator|=
operator|(
name|cap
operator|==
operator|~
literal|0
condition|?
literal|0
else|:
name|cap
operator|)
expr_stmt|;
name|ena
operator|=
operator|(
name|ena
operator|==
operator|~
literal|0
condition|?
literal|0
else|:
name|ena
operator|)
expr_stmt|;
name|hwa
operator|=
operator|(
name|hwa
operator|==
operator|~
literal|0
condition|?
literal|0
else|:
name|hwa
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capabilities
operator|!=
name|cap
operator|||
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capenable
operator|!=
name|ena
operator|||
name|sc
operator|->
name|sc_ifp
operator|->
name|if_hwassist
operator|!=
name|hwa
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capabilities
operator|=
name|cap
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capenable
operator|=
name|ena
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_hwassist
operator|=
name|hwa
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"capabilities 0x%08x enabled 0x%08x\n"
argument_list|,
name|cap
argument_list|,
name|ena
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_lladdr
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|struct
name|lagg_llq
modifier|*
name|llq
decl_stmt|;
name|int
name|pending
init|=
literal|0
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lp_detaching
operator|||
name|memcmp
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Check to make sure its not already queued to be changed */
name|SLIST_FOREACH
argument_list|(
argument|llq
argument_list|,
argument|&sc->sc_llq_head
argument_list|,
argument|llq_entries
argument_list|)
block|{
if|if
condition|(
name|llq
operator|->
name|llq_ifp
operator|==
name|ifp
condition|)
block|{
name|pending
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pending
condition|)
block|{
name|llq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_llq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|llq
operator|==
name|NULL
condition|)
comment|/* XXX what to do */
return|return;
block|}
comment|/* Update the lladdr even if pending, it may have changed */
name|llq
operator|->
name|llq_ifp
operator|=
name|ifp
expr_stmt|;
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|llq
operator|->
name|llq_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pending
condition|)
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|,
name|llq
argument_list|,
name|llq_entries
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_lladdr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the interface MAC address from a taskqueue to avoid a LOR.  */
end_comment

begin_function
specifier|static
name|void
name|lagg_port_setlladdr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|lagg_llq
modifier|*
name|llq
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Grab a local reference of the queue and remove it from the softc */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|head
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|)
expr_stmt|;
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Traverse the queue and set the lladdr on each ifp. It is safe to do 	 * unlocked as we have the only reference to it. 	 */
for|for
control|(
name|llq
operator|=
name|head
init|;
name|llq
operator|!=
name|NULL
condition|;
name|llq
operator|=
name|head
control|)
block|{
name|ifp
operator|=
name|llq
operator|->
name|llq_ifp
expr_stmt|;
comment|/* Set the link layer address */
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
name|if_setlladdr
argument_list|(
name|ifp
argument_list|,
name|llq
operator|->
name|llq_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"%s: setlladdr failed on %s\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|head
operator|=
name|SLIST_NEXT
argument_list|(
name|llq
argument_list|,
name|llq_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|llq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_create
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc_ptr
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Limit the maximal number of lagg ports */
if|if
condition|(
name|sc
operator|->
name|sc_count
operator|>=
name|LAGG_MAX_PORTS
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Check if port has already been associated to a lagg */
if|if
condition|(
name|ifp
operator|->
name|if_lagg
operator|!=
name|NULL
condition|)
block|{
comment|/* Port is already in the current lagg? */
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|ifp
operator|->
name|if_lagg
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lp_softc
operator|==
name|sc
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* XXX Disallow non-ethernet interfaces (this should be any of 802) */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_ETHER
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
ifdef|#
directive|ifdef
name|INET6
comment|/* 	 * The member interface should not have inet6 address because 	 * two interfaces with a valid link-local scope zone must not be 	 * merged in any form.  This restriction is needed to 	 * prevent violation of link-local scope zone.  Attempts to 	 * add a member interface which has inet6 addresses triggers 	 * removal of all inet6 addresses on the member interface. 	 */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|in6ifa_llaonifp
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|)
condition|)
block|{
name|in6_ifdetach
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"IPv6 addresses on %s have been removed "
literal|"before adding it as a member to prevent "
literal|"IPv6 address scope violation.\n"
argument_list|,
name|lp
operator|->
name|lp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in6ifa_llaonifp
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|in6_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"IPv6 addresses on %s have been removed "
literal|"before adding it as a member to prevent "
literal|"IPv6 address scope violation.\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Allow the first Ethernet member to define the MTU */
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|!=
name|ifp
operator|->
name|if_mtu
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"invalid MTU for %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_port
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Check if port is a stacked lagg */
name|mtx_lock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sc_ptr
argument_list|,
argument|&lagg_list
argument_list|,
argument|sc_entries
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|sc_ptr
operator|->
name|sc_ifp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX disable stacking for the moment, its untested */
ifdef|#
directive|ifdef
name|LAGG_PORT_STACKING
name|lp
operator|->
name|lp_flags
operator||=
name|LAGG_PORT_STACK
expr_stmt|;
if|if
condition|(
name|lagg_port_checkstacking
argument_list|(
name|sc_ptr
argument_list|)
operator|>=
name|LAGG_MAX_STACKING
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
endif|#
directive|endif
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
comment|/* Change the interface type */
name|lp
operator|->
name|lp_iftype
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_IEEE8023ADLAG
expr_stmt|;
name|ifp
operator|->
name|if_lagg
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|lp_ioctl
operator|=
name|ifp
operator|->
name|if_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lagg_port_ioctl
expr_stmt|;
name|lp
operator|->
name|lp_output
operator|=
name|ifp
operator|->
name|if_output
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|lagg_port_output
expr_stmt|;
name|lp
operator|->
name|lp_ifp
operator|=
name|ifp
expr_stmt|;
name|lp
operator|->
name|lp_softc
operator|=
name|sc
expr_stmt|;
comment|/* Save port link layer address */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|lp
operator|->
name|lp_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_primary
operator|=
name|lp
expr_stmt|;
name|lagg_lladdr
argument_list|(
name|sc
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update link layer address for this port */
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert into the list of ports */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|,
name|lp
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|++
expr_stmt|;
comment|/* Update lagg capabilities */
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_linkstate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Add multicast addresses and interface flags to this port */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_port_create
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_port_create
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* remove the port again, without calling sc_port_destroy */
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LAGG_PORT_STACKING
end_ifdef

begin_function
specifier|static
name|int
name|lagg_port_checkstacking
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc_ptr
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|lp_flags
operator|&
name|LAGG_PORT_STACK
condition|)
block|{
name|sc_ptr
operator|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|lp
operator|->
name|lp_ifp
operator|->
name|if_softc
expr_stmt|;
name|m
operator|=
name|MAX
argument_list|(
name|m
argument_list|,
name|lagg_port_checkstacking
argument_list|(
name|sc_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|lagg_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|runpd
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp_ptr
decl_stmt|;
name|struct
name|lagg_llq
modifier|*
name|llq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|runpd
operator|&&
name|sc
operator|->
name|sc_port_destroy
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_port_destroy
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove multicast addresses and interface flags from this port and 	 * reset the MAC address, skip if the interface is being detached. 	 */
if|if
condition|(
operator|!
name|lp
operator|->
name|lp_detaching
condition|)
block|{
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|lp
operator|->
name|lp_lladdr
argument_list|)
expr_stmt|;
block|}
comment|/* Restore interface */
name|ifp
operator|->
name|if_type
operator|=
name|lp
operator|->
name|lp_iftype
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lp
operator|->
name|lp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|lp
operator|->
name|lp_output
expr_stmt|;
name|ifp
operator|->
name|if_lagg
operator|=
name|NULL
expr_stmt|;
comment|/* Finally, remove the port from the lagg */
name|SLIST_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|,
name|lp
argument_list|,
name|lagg_port
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|--
expr_stmt|;
comment|/* Update the primary interface */
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
condition|)
block|{
name|uint8_t
name|lladdr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|lp_ptr
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|lp_ptr
operator|->
name|lp_lladdr
argument_list|,
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|lagg_lladdr
argument_list|(
name|sc
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_primary
operator|=
name|lp_ptr
expr_stmt|;
comment|/* Update link layer address for each port */
name|SLIST_FOREACH
argument_list|(
argument|lp_ptr
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_port_lladdr
argument_list|(
name|lp_ptr
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
block|}
comment|/* Remove any pending lladdr changes from the queue */
if|if
condition|(
name|lp
operator|->
name|lp_detaching
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|llq
argument_list|,
argument|&sc->sc_llq_head
argument_list|,
argument|llq_entries
argument_list|)
block|{
if|if
condition|(
name|llq
operator|->
name|llq_ifp
operator|==
name|ifp
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|,
name|llq
argument_list|,
name|lagg_llq
argument_list|,
name|llq_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|llq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
comment|/* Only appears once */
block|}
block|}
block|}
if|if
condition|(
name|lp
operator|->
name|lp_ifflags
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: lp_ifflags unclean\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Update lagg capabilities */
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_linkstate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lagg_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|lagg_reqport
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
comment|/* Should be checked by the caller */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_IEEE8023ADLAG
operator|||
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|=
name|lp
operator|->
name|lp_softc
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fallback
goto|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGLAGGPORT
case|:
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|!=
name|ifp
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_softc
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
block|}
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
if|if
condition|(
name|lp
operator|->
name|lp_ioctl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|lp
operator|->
name|lp_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* Update lagg interface capabilities */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* Do not allow the MTU to be changed once joined */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
goto|goto
name|fallback
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
name|fallback
label|:
if|if
condition|(
name|lp
operator|->
name|lp_ioctl
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|lp
operator|->
name|lp_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For direct output to child ports.  */
end_comment

begin_function
specifier|static
name|int
name|lagg_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|ifp
operator|->
name|if_lagg
decl_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
case|case
name|pseudo_AF_HDRCMPLT
case|:
case|case
name|AF_UNSPEC
case|:
return|return
operator|(
call|(
modifier|*
name|lp
operator|->
name|lp_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|ro
argument_list|)
operator|)
return|;
block|}
comment|/* drop any other frames */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* If the ifnet is just being renamed, don't do anything. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RENAMING
condition|)
return|return;
name|sc
operator|=
name|lp
operator|->
name|lp_softc
expr_stmt|;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lp
operator|->
name|lp_detaching
operator|=
literal|1
expr_stmt|;
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port2req
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|lagg_reqport
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|,
name|lp
operator|->
name|lp_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_prio
operator|=
name|lp
operator|->
name|lp_prio
expr_stmt|;
name|rp
operator|->
name|rp_flags
operator|=
name|lp
operator|->
name|lp_flags
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_portreq
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_portreq
call|)
argument_list|(
name|lp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rp
operator|->
name|rp_psc
argument_list|)
expr_stmt|;
comment|/* Add protocol specific flags */
switch|switch
condition|(
name|sc
operator|->
name|sc_proto
condition|)
block|{
case|case
name|LAGG_PROTO_FAILOVER
case|:
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_MASTER
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_primary
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_ROUNDROBIN
case|:
case|case
name|LAGG_PROTO_LOADBALANCE
case|:
case|case
name|LAGG_PROTO_ETHERCHANNEL
case|:
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_LACP
case|:
comment|/* LACP has a different definition of active */
if|if
condition|(
name|lacp_isactive
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
if|if
condition|(
name|lacp_iscollecting
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_COLLECTING
expr_stmt|;
if|if
condition|(
name|lacp_isdistributing
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_DISTRIBUTING
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Update the port lladdrs */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_init
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_stop
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stop
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_stop
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_reqall
modifier|*
name|ra
init|=
operator|(
expr|struct
name|lagg_reqall
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|lagg_reqport
operator|*
operator|)
name|data
decl_stmt|,
name|rpbuf
decl_stmt|;
name|struct
name|lagg_reqflags
modifier|*
name|rf
init|=
operator|(
expr|struct
name|lagg_reqflags
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|tpif
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|count
decl_stmt|,
name|buflen
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|rpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGLAGG
case|:
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|count
operator|++
expr_stmt|;
name|buflen
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_reqport
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_proto
operator|=
name|sc
operator|->
name|sc_proto
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_req
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_req
call|)
argument_list|(
name|sc
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ra
operator|->
name|ra_psc
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|outbuf
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|ra
operator|->
name|ra_size
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
condition|)
break|break;
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
operator|&
name|rpbuf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|rpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_ports
operator|=
name|count
expr_stmt|;
name|ra
operator|->
name|ra_size
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|outbuf
argument_list|,
name|ra
operator|->
name|ra_port
argument_list|,
name|ra
operator|->
name|ra_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGG
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ra
operator|->
name|ra_proto
operator|>=
name|LAGG_PROTO_MAX
condition|)
block|{
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|!=
name|LAGG_PROTO_NONE
condition|)
block|{
comment|/* Reset protocol first in case detach unlocks */
name|sc
operator|->
name|sc_proto
operator|=
name|LAGG_PROTO_NONE
expr_stmt|;
name|error
operator|=
name|sc
operator|->
name|sc_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_detach
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_linkstate
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_init
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_stop
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_lladdr
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_req
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_portreq
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_input
operator|!=
name|NULL
condition|)
block|{
comment|/* Still detaching */
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|lagg_protos
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lagg_protos
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|==
name|ra
operator|->
name|ra_proto
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: using proto %u\n"
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_proto
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|!=
name|LAGG_PROTO_NONE
condition|)
name|error
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCGLAGGFLAGS
case|:
name|rf
operator|->
name|rf_flags
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGHASH
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|(
name|rf
operator|->
name|rf_flags
operator|&
name|LAGG_F_HASHMASK
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|LAGG_F_HASHMASK
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|rf
operator|->
name|rf_flags
operator|&
name|LAGG_F_HASHMASK
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGLAGGPORT
case|:
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|tpif
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_softc
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
block|}
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|lagg_port_create
argument_list|(
name|sc
argument_list|,
name|tpif
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGDELPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|tpif
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_softc
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* Set flags on ports too */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop and disable it. 			 */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|lagg_ether_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
case|case
name|SIOCSIFMTU
case|:
comment|/* Do not allow the MTU or caps to be directly changed */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ether_setmulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
comment|/* First, remove any existing filter entries. */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* copy all addresses from the lagg interface to the port */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ether_cmdmulti
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|scifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_mc
modifier|*
name|mc
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|,
modifier|*
name|rifma
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sdl
argument_list|,
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_len
operator|=
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_family
operator|=
name|AF_LINK
expr_stmt|;
name|sdl
operator|.
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|.
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|.
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&scifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|LLADDR
argument_list|(
operator|&
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdl
argument_list|,
operator|&
name|rifma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_mc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mc
operator|->
name|mc_ifma
operator|=
name|rifma
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|,
name|mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|mc
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|,
name|mc
argument_list|,
name|lagg_mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
name|if_delmulti_ifma
argument_list|(
name|mc
operator|->
name|mc_ifma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a ref counted flag that should be set on the lagg port as well */
end_comment

begin_function
specifier|static
name|int
name|lagg_setflag
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|status
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|scifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|status
condition|?
operator|(
name|scifp
operator|->
name|if_flags
operator|&
name|flag
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Now "status" contains the flag value or 0 */
comment|/* 	 * See if recorded ports status is different from what 	 * we want it to be.  If it is, flip it.  We record ports 	 * status in lp_ifflags so that we won't clear ports flag 	 * we haven't set.  In fact, we don't clear or set ports 	 * flags directly, but get or release references to them. 	 * That's why we can be sure that recorded flags still are 	 * in accord with actual ports flags. 	 */
if|if
condition|(
name|status
operator|!=
operator|(
name|lp
operator|->
name|lp_ifflags
operator|&
name|flag
operator|)
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|ifp
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|lp
operator|->
name|lp_ifflags
operator|&=
operator|~
name|flag
expr_stmt|;
name|lp
operator|->
name|lp_ifflags
operator||=
name|status
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle IFF_* flags that require certain changes on the lagg port  * if "status" is true, update ports flags respective to the lagg  * if "status" is false, forcedly clear the flags set on port.  */
end_comment

begin_function
specifier|static
name|int
name|lagg_setflags
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|flag
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|lagg_setflag
argument_list|(
name|lp
argument_list|,
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|flag
argument_list|,
name|status
argument_list|,
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|mcast
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mcast
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_MCAST
operator||
name|M_BCAST
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
comment|/* We need a Tx algorithm and at least one port */
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|==
name|LAGG_PROTO_NONE
operator|||
name|sc
operator|->
name|sc_count
operator|==
literal|0
condition|)
block|{
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|counter_u64_add
argument_list|(
name|sc
operator|->
name|sc_opackets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|sc
operator|->
name|sc_obytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_omcasts
operator|+=
name|mcast
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ifp->if_qflush entry point for lagg(4) is no-op.  */
end_comment

begin_function
specifier|static
name|void
name|lagg_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|ifp
operator|->
name|if_lagg
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|scifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|lp
operator|->
name|lp_flags
operator|&
name|LAGG_PORT_DISABLED
operator|)
operator|||
name|sc
operator|->
name|sc_proto
operator|==
name|LAGG_PROTO_NONE
condition|)
block|{
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ETHER_BPF_MTAP
argument_list|(
name|scifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_input
call|)
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|counter_u64_add
argument_list|(
name|sc
operator|->
name|sc_ipackets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|sc
operator|->
name|sc_ibytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|scifp
operator|->
name|if_flags
operator|&
name|IFF_MONITOR
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Ignore */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|imr
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|imr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_linkstate
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|new_link
init|=
name|LINK_STATE_DOWN
decl_stmt|;
name|uint64_t
name|speed
decl_stmt|;
comment|/* Our link is considered up if at least one of our ports is active */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|lp_link_state
operator|==
name|LINK_STATE_UP
condition|)
block|{
name|new_link
operator|=
name|LINK_STATE_UP
expr_stmt|;
break|break;
block|}
block|}
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|new_link
argument_list|)
expr_stmt|;
comment|/* Update if_baudrate to reflect the max possible speed */
switch|switch
condition|(
name|sc
operator|->
name|sc_proto
condition|)
block|{
case|case
name|LAGG_PROTO_FAILOVER
case|:
name|sc
operator|->
name|sc_ifp
operator|->
name|if_baudrate
operator|=
name|sc
operator|->
name|sc_primary
operator|!=
name|NULL
condition|?
name|sc
operator|->
name|sc_primary
operator|->
name|lp_ifp
operator|->
name|if_baudrate
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_ROUNDROBIN
case|:
case|case
name|LAGG_PROTO_LOADBALANCE
case|:
case|case
name|LAGG_PROTO_ETHERCHANNEL
case|:
name|speed
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|speed
operator|+=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_baudrate
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_baudrate
operator|=
name|speed
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_LACP
case|:
comment|/* LACP updates if_baudrate itself */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|ifp
operator|->
name|if_lagg
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
name|sc
operator|=
name|lp
operator|->
name|lp_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_linkstate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_linkstate
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_linkstate
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|lagg_port
modifier|*
name|lagg_link_active
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp_next
decl_stmt|,
modifier|*
name|rval
init|=
name|NULL
decl_stmt|;
comment|// int new_link = LINK_STATE_DOWN;
name|LAGG_RLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Search a port which reports an active link state. 	 */
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
goto|goto
name|search
goto|;
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
operator|(
name|lp_next
operator|=
name|SLIST_NEXT
argument_list|(
name|lp
argument_list|,
name|lp_entries
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|LAGG_PORTACTIVE
argument_list|(
name|lp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|search
label|:
name|SLIST_FOREACH
argument_list|(
argument|lp_next
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|found
label|:
if|if
condition|(
name|rval
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The IEEE 802.1D standard assumes that a lagg with 		 * multiple ports is always full duplex. This is valid 		 * for load sharing laggs and if at least two links 		 * are active. Unfortunately, checking the latter would 		 * be too expensive at this point. 		 XXX 		if ((sc->sc_capabilities& IFCAP_LAGG_FULLDUPLEX)&& 		    (sc->sc_count> 1)) 			new_link = LINK_STATE_FULL_DUPLEX; 		else 			new_link = rval->lp_link_state; 		 */
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|lagg_gethdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|len
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
operator|(
name|off
operator|+
name|len
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
operator|(
name|off
operator|+
name|len
operator|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_sysctl_active
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* LACP tracks active links automatically, the others do not */
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|!=
name|LAGG_PROTO_LACP
condition|)
block|{
name|sc
operator|->
name|sc_active
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|sc
operator|->
name|sc_active
operator|+=
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|sc
operator|->
name|sc_active
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|lagg_hashmbuf
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|key
parameter_list|)
block|{
name|uint16_t
name|etype
decl_stmt|;
name|uint32_t
name|p
init|=
name|key
decl_stmt|;
name|int
name|off
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
specifier|const
name|struct
name|ether_vlan_header
modifier|*
name|vlan
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|ports
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|uint32_t
name|flow
decl_stmt|;
endif|#
directive|endif
union|union
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
name|ip
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
name|ip6
decl_stmt|;
endif|#
directive|endif
name|struct
name|ether_vlan_header
name|vlan
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
block|}
name|buf
union|;
name|off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|off
condition|)
goto|goto
name|out
goto|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|LAGG_F_HASHL2
condition|)
block|{
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Special handling for encapsulating VLAN frames */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|LAGG_F_HASHL2
operator|)
condition|)
block|{
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
name|vlan
operator|=
name|lagg_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vlan
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|LAGG_F_HASHL2
condition|)
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|vlan
operator|->
name|evl_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|vlan
operator|->
name|evl_tag
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|vlan
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|vlan
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
name|lagg_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|LAGG_F_HASHL3
condition|)
block|{
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|LAGG_F_HASHL4
operator|)
condition|)
break|break;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
case|case
name|IPPROTO_UDP
case|:
case|case
name|IPPROTO_SCTP
case|:
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|iphlen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
break|break;
name|off
operator|+=
name|iphlen
expr_stmt|;
name|ports
operator|=
name|lagg_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ports
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ports
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|hash32_buf
argument_list|(
name|ports
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ports
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|LAGG_F_HASHL3
operator|)
condition|)
break|break;
name|ip6
operator|=
name|lagg_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|flow
operator|=
name|ip6
operator|->
name|ip6_flow
operator|&
name|IPV6_FLOWLABEL_MASK
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|flow
argument_list|,
sizeof|sizeof
argument_list|(
name|flow
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* IPv6 flow label */
break|break;
endif|#
directive|endif
block|}
name|out
label|:
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lagg_enqueue
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
call|(
name|ifp
operator|->
name|if_transmit
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple round robin aggregation  */
end_comment

begin_function
specifier|static
name|int
name|lagg_rr_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_rr_detach
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_rr_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_rr_input
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_capabilities
operator|=
name|IFCAP_LAGG_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|sc_seq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_rr_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_rr_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|uint32_t
name|p
decl_stmt|;
name|p
operator|=
name|atomic_fetchadd_32
argument_list|(
operator|&
name|sc
operator|->
name|sc_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|%=
name|sc
operator|->
name|sc_count
expr_stmt|;
name|lp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|--
condition|)
name|lp
operator|=
name|SLIST_NEXT
argument_list|(
name|lp
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
comment|/* 	 * Check the port's link state. This will return the next active 	 * port if the link is down or the port is NULL. 	 */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_rr_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
comment|/* Just pass in the packet to our lagg device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Active failover  */
end_comment

begin_function
specifier|static
name|int
name|lagg_fail_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_fail_detach
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_fail_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_fail_input
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_fail_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_fail_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
comment|/* Use the master port if active or the next available port */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_primary
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_fail_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|tmp_tp
decl_stmt|;
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
operator|||
name|lagg_failover_rx_all
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|LAGG_PORTACTIVE
argument_list|(
name|sc
operator|->
name|sc_primary
argument_list|)
condition|)
block|{
name|tmp_tp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_primary
argument_list|)
expr_stmt|;
comment|/* 		 * If tmp_tp is null, we've recieved a packet when all 		 * our links are down. Weird, but process it anyways. 		 */
if|if
condition|(
operator|(
name|tmp_tp
operator|==
name|NULL
operator|||
name|tmp_tp
operator|==
name|lp
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadbalancing  */
end_comment

begin_function
specifier|static
name|int
name|lagg_lb_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|lagg_lb
modifier|*
name|lb
decl_stmt|;
if|if
condition|(
operator|(
name|lb
operator|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_lb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_lb_detach
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_lb_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_lb_input
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|lagg_lb_port_create
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|lagg_lb_port_destroy
expr_stmt|;
name|sc
operator|->
name|sc_capabilities
operator|=
name|IFCAP_LAGG_FULLDUPLEX
expr_stmt|;
name|lb
operator|->
name|lb_key
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_psc
operator|=
operator|(
name|caddr_t
operator|)
name|lb
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_lb_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
if|if
condition|(
name|lb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_porttable
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp_next
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|lb
operator|->
name|lb_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|lb
operator|->
name|lb_ports
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp_next
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp_next
operator|==
name|lp
condition|)
continue|continue;
if|if
condition|(
name|i
operator|>=
name|LAGG_MAX_PORTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: port %s at index %d\n"
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
name|lp_next
operator|->
name|lp_ifname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_ports
index|[
name|i
operator|++
index|]
operator|=
name|lp_next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_port_create
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
return|return
operator|(
name|lagg_lb_porttable
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lb_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|lagg_lb_porttable
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|use_flowid
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
operator|)
condition|)
name|p
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|>>
name|sc
operator|->
name|flowid_shift
expr_stmt|;
else|else
name|p
operator|=
name|lagg_hashmbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|lb
operator|->
name|lb_key
argument_list|)
expr_stmt|;
name|p
operator|%=
name|sc
operator|->
name|sc_count
expr_stmt|;
name|lp
operator|=
name|lb
operator|->
name|lb_ports
index|[
name|p
index|]
expr_stmt|;
comment|/* 	 * Check the port's link state. This will return the next active 	 * port if the link is down or the port is NULL. 	 */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lb_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
comment|/* Just pass in the packet to our lagg device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 802.3ad LACP  */
end_comment

begin_function
specifier|static
name|int
name|lagg_lacp_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_lacp_detach
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|lacp_port_create
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|lacp_port_destroy
expr_stmt|;
name|sc
operator|->
name|sc_linkstate
operator|=
name|lacp_linkstate
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_lacp_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_lacp_input
expr_stmt|;
name|sc
operator|->
name|sc_init
operator|=
name|lacp_init
expr_stmt|;
name|sc
operator|->
name|sc_stop
operator|=
name|lacp_stop
expr_stmt|;
name|sc
operator|->
name|sc_lladdr
operator|=
name|lagg_lacp_lladdr
expr_stmt|;
name|sc
operator|->
name|sc_req
operator|=
name|lacp_req
expr_stmt|;
name|sc
operator|->
name|sc_portreq
operator|=
name|lacp_portreq
expr_stmt|;
name|error
operator|=
name|lacp_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lacp_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* unlocking is safe here */
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|lacp_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lacp_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
comment|/* purge all the lacp ports */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* add them back in */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lacp_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|lacp_select_tx_port
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lacp_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* Tap off LACP control messages */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|==
literal|0
operator|&&
name|etype
operator|==
name|ETHERTYPE_SLOW
condition|)
block|{
name|m
operator|=
name|lacp_input
argument_list|(
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If the port is not collecting or not in the active aggregator then 	 * free and return. 	 */
if|if
condition|(
name|lacp_iscollecting
argument_list|(
name|lp
argument_list|)
operator|==
literal|0
operator|||
name|lacp_isactive
argument_list|(
name|lp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|=
name|counter_u64_fetch
argument_list|(
name|sc
operator|->
name|sc_ipackets
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|counter_u64_fetch
argument_list|(
name|sc
operator|->
name|sc_opackets
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|counter_u64_fetch
argument_list|(
name|sc
operator|->
name|sc_ibytes
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|counter_u64_fetch
argument_list|(
name|sc
operator|->
name|sc_obytes
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|hz
argument_list|,
name|lagg_callout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

