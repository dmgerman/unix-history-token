begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: cd9660_write.c,v 1.14 2011/01/04 09:48:21 wiz Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005 Daniel Watt, Walter Deignan, Ryan Gabrys, Alan  * Perez-Rathke and Ram Vedam.  All rights reserved.  *  * This code was written by Daniel Watt, Walter Deignan, Ryan Gabrys,  * Alan Perez-Rathke and Ram Vedam.  *  * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY DANIEL WATT, WALTER DEIGNAN, RYAN  * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL DANIEL WATT, WALTER DEIGNAN, RYAN  * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"cd9660.h"
end_include

begin_include
include|#
directive|include
file|"iso9660_rrip.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|cd9660_write_volume_descriptors
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_write_path_table
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_write_path_tables
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_write_file
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_write_filedata
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|off_t
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int cd9660_write_buffered(FILE *, off_t, int, const unsigned char *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|cd9660_write_rr
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Write the image  * Writes the entire image  * @param const char* The filename for the image  * @returns int 1 on success, 0 on failure  */
end_comment

begin_function
name|int
name|cd9660_write_image
parameter_list|(
specifier|const
name|char
modifier|*
name|image
parameter_list|)
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|buf
index|[
name|CD9660_SECTOR_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|image
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: Can't open `%s' for writing"
argument_list|,
name|__func__
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diskStructure
operator|.
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Writing image\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|.
name|has_generic_bootimage
condition|)
block|{
name|status
operator|=
name|cd9660_copy_file
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|diskStructure
operator|.
name|generic_bootimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: Error writing generic boot image"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_bad_image
goto|;
block|}
block|}
comment|/* Write the volume descriptors */
name|status
operator|=
name|cd9660_write_volume_descriptors
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: Error writing volume descriptors to image"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_bad_image
goto|;
block|}
if|if
condition|(
name|diskStructure
operator|.
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Volume descriptors written\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Write the path tables: there are actually four, but right 	 * now we are only concearned with two. 	 */
name|status
operator|=
name|cd9660_write_path_tables
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: Error writing path tables to image"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_bad_image
goto|;
block|}
if|if
condition|(
name|diskStructure
operator|.
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Path tables written\n"
argument_list|)
expr_stmt|;
comment|/* Write the directories and files */
name|status
operator|=
name|cd9660_write_file
argument_list|(
name|fd
argument_list|,
name|diskStructure
operator|.
name|rootNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: Error writing files to image"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_bad_image
goto|;
block|}
if|if
condition|(
name|diskStructure
operator|.
name|is_bootable
condition|)
block|{
name|cd9660_write_boot
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* Write padding bits. This is temporary */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|CD9660_SECTOR_SIZE
argument_list|)
expr_stmt|;
name|cd9660_write_filedata
argument_list|(
name|fd
argument_list|,
name|diskStructure
operator|.
name|totalSectors
operator|-
literal|1
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|.
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Files written\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|.
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Image closed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|cleanup_bad_image
label|:
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diskStructure
operator|.
name|keep_bad_images
condition|)
name|unlink
argument_list|(
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|.
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Bad image cleaned up\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_write_volume_descriptors
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|volume_descriptor
modifier|*
name|vd_temp
init|=
name|diskStructure
operator|.
name|firstVolumeDescriptor
decl_stmt|;
name|int
name|pos
decl_stmt|;
while|while
condition|(
name|vd_temp
operator|!=
name|NULL
condition|)
block|{
name|pos
operator|=
name|vd_temp
operator|->
name|sector
operator|*
name|diskStructure
operator|.
name|sectorSize
expr_stmt|;
name|cd9660_write_filedata
argument_list|(
name|fd
argument_list|,
name|vd_temp
operator|->
name|sector
argument_list|,
name|vd_temp
operator|->
name|volumeDescriptorData
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vd_temp
operator|=
name|vd_temp
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Write out an individual path table  * Used just to keep redundant code to a minimum  * @param FILE *fd Valid file pointer  * @param int Sector to start writing path table to  * @param int Endian mode : BIG_ENDIAN or LITTLE_ENDIAN  * @returns int 1 on success, 0 on failure  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_write_path_table
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|off_t
name|sector
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|path_table_sectors
init|=
name|CD9660_BLOCKS
argument_list|(
name|diskStructure
operator|.
name|sectorSize
argument_list|,
name|diskStructure
operator|.
name|pathTableLength
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer_head
decl_stmt|;
name|int
name|len
decl_stmt|;
name|path_table_entry
name|temp_entry
decl_stmt|;
name|cd9660node
modifier|*
name|ptcur
decl_stmt|;
name|buffer
operator|=
name|malloc
argument_list|(
name|diskStructure
operator|.
name|sectorSize
operator|*
name|path_table_sectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: Memory allocation error allocating buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|buffer_head
operator|=
name|buffer
expr_stmt|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|diskStructure
operator|.
name|sectorSize
operator|*
name|path_table_sectors
argument_list|)
expr_stmt|;
name|ptcur
operator|=
name|diskStructure
operator|.
name|rootNode
expr_stmt|;
while|while
condition|(
name|ptcur
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
operator|&
name|temp_entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_table_entry
argument_list|)
argument_list|)
expr_stmt|;
name|temp_entry
operator|.
name|length
index|[
literal|0
index|]
operator|=
name|ptcur
operator|->
name|isoDirRecord
operator|->
name|name_len
index|[
literal|0
index|]
expr_stmt|;
name|temp_entry
operator|.
name|extended_attribute_length
index|[
literal|0
index|]
operator|=
name|ptcur
operator|->
name|isoDirRecord
operator|->
name|ext_attr_length
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|temp_entry
operator|.
name|name
argument_list|,
name|ptcur
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|temp_entry
operator|.
name|length
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* round up */
name|len
operator|=
name|temp_entry
operator|.
name|length
index|[
literal|0
index|]
operator|+
literal|8
operator|+
operator|(
name|temp_entry
operator|.
name|length
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
expr_stmt|;
comment|/* todo: function pointers instead */
if|if
condition|(
name|mode
operator|==
name|LITTLE_ENDIAN
condition|)
block|{
name|cd9660_731
argument_list|(
name|ptcur
operator|->
name|fileDataSector
argument_list|,
name|temp_entry
operator|.
name|first_sector
argument_list|)
expr_stmt|;
name|cd9660_721
argument_list|(
operator|(
name|ptcur
operator|->
name|parent
operator|==
name|NULL
condition|?
literal|1
else|:
name|ptcur
operator|->
name|parent
operator|->
name|ptnumber
operator|)
argument_list|,
name|temp_entry
operator|.
name|parent_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cd9660_732
argument_list|(
name|ptcur
operator|->
name|fileDataSector
argument_list|,
name|temp_entry
operator|.
name|first_sector
argument_list|)
expr_stmt|;
name|cd9660_722
argument_list|(
operator|(
name|ptcur
operator|->
name|parent
operator|==
name|NULL
condition|?
literal|1
else|:
name|ptcur
operator|->
name|parent
operator|->
name|ptnumber
operator|)
argument_list|,
name|temp_entry
operator|.
name|parent_number
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buffer
argument_list|,
operator|&
name|temp_entry
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|len
expr_stmt|;
name|ptcur
operator|=
name|ptcur
operator|->
name|ptnext
expr_stmt|;
block|}
return|return
name|cd9660_write_filedata
argument_list|(
name|fd
argument_list|,
name|sector
argument_list|,
name|buffer_head
argument_list|,
name|path_table_sectors
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out the path tables to disk  * Each file descriptor should be pointed to by the PVD, so we know which  * sector to copy them to. One thing to watch out for: the only path tables  * stored are in the endian mode that the application is compiled for. So,  * the first thing to do is write out that path table, then to write the one  * in the other endian mode requires to convert the endianness of each entry  * in the table. The best way to do this would be to create a temporary  * path_table_entry structure, then for each path table entry, copy it to  * the temporary entry, translate, then copy that to disk.  *  * @param FILE* Valid file descriptor  * @returns int 0 on failure, 1 on success  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_write_path_tables
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
if|if
condition|(
name|cd9660_write_path_table
argument_list|(
name|fd
argument_list|,
name|diskStructure
operator|.
name|primaryLittleEndianTableSector
argument_list|,
name|LITTLE_ENDIAN
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cd9660_write_path_table
argument_list|(
name|fd
argument_list|,
name|diskStructure
operator|.
name|primaryBigEndianTableSector
argument_list|,
name|BIG_ENDIAN
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* @TODO: handle remaining two path tables */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Write a file to disk  * Writes a file, its directory record, and its data to disk  * This file is designed to be called RECURSIVELY, so initially call it  * with the root node. All of the records should store what sector the  * file goes in, so no computation should be  necessary.  *  * @param int fd Valid file descriptor  * @param struct cd9660node* writenode Pointer to the file to be written  * @returns int 0 on failure, 1 on success  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_write_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|cd9660node
modifier|*
name|writenode
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|temp_file_name
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|off_t
name|working_sector
decl_stmt|;
name|int
name|cur_sector_offset
decl_stmt|;
name|int
name|written
decl_stmt|;
name|iso_directory_record_cd9660
name|temp_record
decl_stmt|;
name|cd9660node
modifier|*
name|temp
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* Todo : clean up variables */
name|temp_file_name
operator|=
name|malloc
argument_list|(
name|CD9660MAXPATH
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_file_name
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: malloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_file_name
argument_list|,
literal|0
argument_list|,
name|CD9660MAXPATH
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|diskStructure
operator|.
name|sectorSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: malloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|writenode
operator|->
name|level
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|writenode
operator|->
name|node
operator|->
name|type
operator|&
name|S_IFDIR
operator|)
condition|)
block|{
name|fsinode
modifier|*
name|inode
init|=
name|writenode
operator|->
name|node
operator|->
name|inode
decl_stmt|;
comment|/* Only attempt to write unwritten files that have length. */
if|if
condition|(
operator|(
name|inode
operator|->
name|flags
operator|&
name|FI_WRITTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|INODE_WARNX
argument_list|(
operator|(
literal|"%s: skipping written inode %d"
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|inode
operator|->
name|st
operator|.
name|st_ino
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|writenode
operator|->
name|fileDataLength
operator|>
literal|0
condition|)
block|{
name|INODE_WARNX
argument_list|(
operator|(
literal|"%s: writing inode %d blocks at %"
name|PRIu32
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|inode
operator|->
name|st
operator|.
name|st_ino
operator|,
name|inode
operator|->
name|ino
operator|)
argument_list|)
expr_stmt|;
name|inode
operator|->
name|flags
operator||=
name|FI_WRITTEN
expr_stmt|;
if|if
condition|(
name|writenode
operator|->
name|node
operator|->
name|contents
operator|==
name|NULL
condition|)
name|cd9660_compute_full_filename
argument_list|(
name|writenode
argument_list|,
name|temp_file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cd9660_copy_file
argument_list|(
name|fd
argument_list|,
name|writenode
operator|->
name|fileDataSector
argument_list|,
operator|(
name|writenode
operator|->
name|node
operator|->
name|contents
operator|!=
name|NULL
operator|)
condition|?
name|writenode
operator|->
name|node
operator|->
name|contents
else|:
name|temp_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Here is a new revelation that ECMA didn't explain 		 * (at least not well). 		 * ALL . and .. records store the name "\0" and "\1" 		 * respectively. So, for each directory, we have to 		 * make a new node. 		 * 		 * This is where it gets kinda messy, since we have to 		 * be careful of sector boundaries 		 */
name|cur_sector_offset
operator|=
literal|0
expr_stmt|;
name|working_sector
operator|=
name|writenode
operator|->
name|fileDataSector
expr_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|working_sector
operator|*
name|diskStructure
operator|.
name|sectorSize
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
comment|/* 		 * Now loop over children, writing out their directory 		 * records - beware of sector boundaries 	 	 */
name|TAILQ_FOREACH
argument_list|(
argument|temp
argument_list|,
argument|&writenode->cn_children
argument_list|,
argument|cn_next_child
argument_list|)
block|{
comment|/* 			 * Copy the temporary record and adjust its size 			 * if necessary 			 */
name|memcpy
argument_list|(
operator|&
name|temp_record
argument_list|,
name|temp
operator|->
name|isoDirRecord
argument_list|,
sizeof|sizeof
argument_list|(
name|iso_directory_record_cd9660
argument_list|)
argument_list|)
expr_stmt|;
name|temp_record
operator|.
name|length
index|[
literal|0
index|]
operator|=
name|cd9660_compute_record_size
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_record
operator|.
name|length
index|[
literal|0
index|]
operator|+
name|cur_sector_offset
operator|>=
name|diskStructure
operator|.
name|sectorSize
condition|)
block|{
name|cur_sector_offset
operator|=
literal|0
expr_stmt|;
name|working_sector
operator|++
expr_stmt|;
comment|/* Seek to the next sector. */
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|working_sector
operator|*
name|diskStructure
operator|.
name|sectorSize
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the basic ISO directory record */
name|written
operator|=
name|fwrite
argument_list|(
operator|&
name|temp_record
argument_list|,
literal|1
argument_list|,
name|temp
operator|->
name|isoDirRecord
operator|->
name|length
index|[
literal|0
index|]
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|.
name|rock_ridge_enabled
condition|)
block|{
name|cd9660_write_rr
argument_list|(
name|fd
argument_list|,
name|temp
argument_list|,
name|cur_sector_offset
argument_list|,
name|working_sector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|working_sector
operator|*
name|diskStructure
operator|.
name|sectorSize
operator|+
name|cur_sector_offset
operator|+
name|temp_record
operator|.
name|length
index|[
literal|0
index|]
operator|-
name|temp
operator|->
name|su_tail_size
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|su_tail_size
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|temp
operator|->
name|su_tail_data
argument_list|,
literal|1
argument_list|,
name|temp
operator|->
name|su_tail_size
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: write error"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cur_sector_offset
operator|+=
name|temp_record
operator|.
name|length
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 		 * Recurse on children. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|temp
argument_list|,
argument|&writenode->cn_children
argument_list|,
argument|cn_next_child
argument_list|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|cd9660_write_file
argument_list|(
name|fd
argument_list|,
name|temp
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|rv
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|temp_file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper function to write a buffer (one sector) to disk.  * Seeks and writes the buffer.  * NOTE: You dont NEED to use this function, but it might make your  * life easier if you have to write things that align to a sector  * (such as volume descriptors).  *  * @param int fd Valid file descriptor  * @param int sector Sector number to write to  * @param const unsigned char* Buffer to write. This should be the  *                             size of a sector, and if only a portion  *                             is written, the rest should be set to 0.  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_write_filedata
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|off_t
name|sector
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|numsecs
parameter_list|)
block|{
name|off_t
name|curpos
decl_stmt|;
name|size_t
name|success
decl_stmt|;
name|curpos
operator|=
name|ftello
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|sector
operator|*
name|diskStructure
operator|.
name|sectorSize
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
name|success
operator|=
name|fwrite
argument_list|(
name|buf
argument_list|,
name|diskStructure
operator|.
name|sectorSize
operator|*
name|numsecs
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|curpos
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|1
condition|)
name|success
operator|=
name|diskStructure
operator|.
name|sectorSize
operator|*
name|numsecs
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int cd9660_write_buffered(FILE *fd, off_t offset, int buff_len, 		      const unsigned char* buffer) { 	static int working_sector = -1; 	static char buf[CD9660_SECTOR_SIZE];  	return 0; }
endif|#
directive|endif
end_endif

begin_function
name|int
name|cd9660_copy_file
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|off_t
name|start_sector
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|rf
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|off_t
name|sector
init|=
name|start_sector
decl_stmt|;
name|int
name|buf_size
init|=
name|diskStructure
operator|.
name|sectorSize
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: malloc"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rf
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: cannot open %s"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|diskStructure
operator|.
name|verbose_level
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"Writing file: %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|start_sector
operator|*
name|diskStructure
operator|.
name|sectorSize
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|rf
argument_list|)
condition|)
block|{
name|bytes_read
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|buf_size
argument_list|,
name|rf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|rf
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fread"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|bytes_read
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s: fwrite"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sector
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd9660_write_rr
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|cd9660node
modifier|*
name|writenode
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|sector
parameter_list|)
block|{
name|int
name|in_ca
init|=
literal|0
decl_stmt|;
name|struct
name|ISO_SUSP_ATTRIBUTES
modifier|*
name|myattr
decl_stmt|;
name|offset
operator|+=
name|writenode
operator|->
name|isoDirRecord
operator|->
name|length
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|sector
operator|*
name|diskStructure
operator|.
name|sectorSize
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
comment|/* Offset now points at the end of the record */
name|TAILQ_FOREACH
argument_list|(
argument|myattr
argument_list|,
argument|&writenode->head
argument_list|,
argument|rr_ll
argument_list|)
block|{
name|fwrite
argument_list|(
operator|&
operator|(
name|myattr
operator|->
name|attr
operator|)
argument_list|,
name|CD9660_SUSP_ENTRY_SIZE
argument_list|(
name|myattr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_ca
condition|)
block|{
name|offset
operator|+=
name|CD9660_SUSP_ENTRY_SIZE
argument_list|(
name|myattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|myattr
operator|->
name|last_in_suf
condition|)
block|{
comment|/* 				 * Point the offset to the start of this 				 * record's CE area 				 */
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|diskStructure
operator|.
name|susp_continuation_area_start_sector
operator|*
name|diskStructure
operator|.
name|sectorSize
operator|)
operator|+
name|writenode
operator|->
name|susp_entry_ce_start
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
name|in_ca
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we had to go to the continuation area, head back to 	 * where we should be. 	 */
if|if
condition|(
name|in_ca
condition|)
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
name|sector
operator|*
name|diskStructure
operator|.
name|sectorSize
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

