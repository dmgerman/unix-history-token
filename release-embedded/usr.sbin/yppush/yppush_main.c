begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/clnt.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_clnt.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/yp.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/ypclnt.h>
end_include

begin_include
include|#
directive|include
file|"ypxfr_extern.h"
end_include

begin_include
include|#
directive|include
file|"yppush_extern.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
literal|"yppush"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rpcpmstart
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yp_dir
init|=
name|_PATH_YP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yppush_mapname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map to transfer. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|yppush_domain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Domain in which map resides. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|yppush_master
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Master NIS server for said domain. */
end_comment

begin_decl_stmt
name|int
name|skip_master
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not attempt to push map to master. */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Toggle verbose mode. */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|yppush_transid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yppush_timeout
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default timeout. */
end_comment

begin_decl_stmt
name|int
name|yppush_jobs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of allowed concurrent jobs. */
end_comment

begin_decl_stmt
name|int
name|yppush_running_jobs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of currently running jobs. */
end_comment

begin_comment
comment|/* Structure for holding information about a running job. */
end_comment

begin_struct
struct|struct
name|jobs
block|{
name|unsigned
name|long
name|tid
decl_stmt|;
name|int
name|port
decl_stmt|;
name|ypxfrstat
name|stat
decl_stmt|;
name|unsigned
name|long
name|prognum
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|map
decl_stmt|;
name|int
name|polled
decl_stmt|;
name|struct
name|jobs
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|jobs
modifier|*
name|yppush_joblist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of running jobs. */
end_comment

begin_function_decl
specifier|static
name|int
name|yppush_svc_run
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Local error messages.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|yppusherr_string
parameter_list|(
name|int
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|YPPUSH_TIMEDOUT
case|:
return|return
operator|(
literal|"transfer or callback timed out"
operator|)
return|;
case|case
name|YPPUSH_YPSERV
case|:
return|return
operator|(
literal|"failed to contact ypserv"
operator|)
return|;
case|case
name|YPPUSH_NOHOST
case|:
return|return
operator|(
literal|"no such host"
operator|)
return|;
case|case
name|YPPUSH_PMAP
case|:
return|return
operator|(
literal|"portmapper failure"
operator|)
return|;
default|default:
return|return
operator|(
literal|"unknown error code"
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Report state of a job.  */
end_comment

begin_function
specifier|static
name|int
name|yppush_show_status
parameter_list|(
name|ypxfrstat
name|status
parameter_list|,
name|unsigned
name|long
name|tid
parameter_list|)
block|{
name|struct
name|jobs
modifier|*
name|job
decl_stmt|;
name|job
operator|=
name|yppush_joblist
expr_stmt|;
while|while
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|tid
operator|==
name|tid
condition|)
break|break;
name|job
operator|=
name|job
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"warning: received callback with invalid transaction ID: %lu"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|job
operator|->
name|polled
condition|)
block|{
name|yp_error
argument_list|(
literal|"warning: received callback with duplicate transaction ID: %lu"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"checking return status: transaction ID: %lu"
argument_list|,
name|job
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|YPPUSH_SUCC
operator|||
name|verbose
condition|)
block|{
name|yp_error
argument_list|(
literal|"transfer of map %s to server %s %s"
argument_list|,
name|job
operator|->
name|map
argument_list|,
name|job
operator|->
name|server
argument_list|,
name|status
operator|==
name|YPPUSH_SUCC
condition|?
literal|"succeeded"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
name|yp_error
argument_list|(
literal|"status returned by ypxfr: %s"
argument_list|,
name|status
operator|>
name|YPPUSH_AGE
condition|?
name|yppusherr_string
argument_list|(
name|status
argument_list|)
else|:
name|ypxfrerr_string
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
name|svc_unregister
argument_list|(
name|job
operator|->
name|prognum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|yppush_running_jobs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Exit routine. */
end_comment

begin_function
specifier|static
name|void
name|yppush_exit
parameter_list|(
name|int
name|now
parameter_list|)
block|{
name|struct
name|jobs
modifier|*
name|jptr
decl_stmt|;
name|int
name|still_pending
init|=
literal|1
decl_stmt|;
comment|/* Let all the information trickle in. */
while|while
condition|(
operator|!
name|now
operator|&&
name|still_pending
condition|)
block|{
name|jptr
operator|=
name|yppush_joblist
expr_stmt|;
name|still_pending
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|jptr
condition|)
block|{
if|if
condition|(
name|jptr
operator|->
name|polled
operator|==
literal|0
condition|)
block|{
name|still_pending
operator|++
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%s has not responded"
argument_list|,
name|jptr
operator|->
name|server
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%s has responded"
argument_list|,
name|jptr
operator|->
name|server
argument_list|)
expr_stmt|;
block|}
name|jptr
operator|=
name|jptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|still_pending
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%d transfer%sstill pending"
argument_list|,
name|still_pending
argument_list|,
name|still_pending
operator|>
literal|1
condition|?
literal|"s "
else|:
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|yppush_svc_run
argument_list|(
name|YPPUSH_RESPONSE_TIMEOUT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|yp_error
argument_list|(
literal|"timed out"
argument_list|)
expr_stmt|;
name|now
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|yp_error
argument_list|(
literal|"all transfers complete"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* All stats collected and reported -- kill all the stragglers. */
name|jptr
operator|=
name|yppush_joblist
expr_stmt|;
while|while
condition|(
name|jptr
condition|)
block|{
if|if
condition|(
operator|!
name|jptr
operator|->
name|polled
condition|)
name|yp_error
argument_list|(
literal|"warning: exiting with transfer \ to %s (transid = %lu) still pending"
argument_list|,
name|jptr
operator|->
name|server
argument_list|,
name|jptr
operator|->
name|tid
argument_list|)
expr_stmt|;
name|svc_unregister
argument_list|(
name|jptr
operator|->
name|prognum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jptr
operator|=
name|jptr
operator|->
name|next
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for 'normal' signals.  */
end_comment

begin_function
specifier|static
name|void
name|handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Dispatch loop for callback RPC services.  * Return value:  *   -1 error  *    0 timeout  *>0 request serviced  */
end_comment

begin_function
specifier|static
name|int
name|yppush_svc_run
parameter_list|(
name|int
name|timeout_secs
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|timeout_secs
expr_stmt|;
name|retry
label|:
name|readfds
operator|=
name|svc_fdset
expr_stmt|;
name|rc
operator|=
name|select
argument_list|(
name|svc_maxfd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|retry
goto|;
name|yp_error
argument_list|(
literal|"select failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|yp_error
argument_list|(
literal|"select() timed out"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|svc_getreqset
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * RPC service routines for callbacks.  */
end_comment

begin_function
name|void
modifier|*
name|yppushproc_null_1_svc
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Do nothing -- RPC conventions call for all a null proc. */
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|yppushproc_xfrresp_1_svc
parameter_list|(
name|yppushresp_xfr
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
name|yppush_show_status
argument_list|(
name|argp
operator|->
name|status
argument_list|,
name|argp
operator|->
name|transid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit a YPPROC_XFR request to ypserv.  */
end_comment

begin_function
specifier|static
name|int
name|yppush_send_xfr
parameter_list|(
name|struct
name|jobs
modifier|*
name|job
parameter_list|)
block|{
name|ypreq_xfr
name|req
decl_stmt|;
comment|/*	ypresp_xfr *resp; */
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|CLIENT
modifier|*
name|clnt
decl_stmt|;
name|struct
name|rpc_err
name|err
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The ypreq_xfr structure has a member of type map_parms, 	 * which seems to require the order number of the map. 	 * It isn't actually used at the other end (at least the 	 * FreeBSD ypserv doesn't use it) but we fill it in here 	 * for the sake of completeness. 	 */
name|key
operator|.
name|data
operator|=
literal|"YP_LAST_MODIFIED"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_LAST_MODIFIED"
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yp_get_record
argument_list|(
name|yppush_domain
argument_list|,
name|yppush_mapname
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to read order number from %s: %s: %s"
argument_list|,
name|yppush_mapname
argument_list|,
name|yperr_string
argument_list|(
name|yp_errno
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Fill in the request arguments */
name|req
operator|.
name|map_parms
operator|.
name|ordernum
operator|=
name|atoi
argument_list|(
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
name|req
operator|.
name|map_parms
operator|.
name|domain
operator|=
name|yppush_domain
expr_stmt|;
name|req
operator|.
name|map_parms
operator|.
name|peer
operator|=
name|yppush_master
expr_stmt|;
name|req
operator|.
name|map_parms
operator|.
name|map
operator|=
name|job
operator|->
name|map
expr_stmt|;
name|req
operator|.
name|transid
operator|=
name|job
operator|->
name|tid
expr_stmt|;
name|req
operator|.
name|prog
operator|=
name|job
operator|->
name|prognum
expr_stmt|;
name|req
operator|.
name|port
operator|=
name|job
operator|->
name|port
expr_stmt|;
comment|/* Get a handle to the remote ypserv. */
if|if
condition|(
operator|(
name|clnt
operator|=
name|clnt_create
argument_list|(
name|job
operator|->
name|server
argument_list|,
name|YPPROG
argument_list|,
name|YPVERS
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|job
operator|->
name|server
argument_list|,
name|clnt_spcreateerror
argument_list|(
literal|"couldn't \ create udp handle to NIS server"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rpc_createerr
operator|.
name|cf_stat
condition|)
block|{
case|case
name|RPC_UNKNOWNHOST
case|:
name|job
operator|->
name|stat
operator|=
name|YPPUSH_NOHOST
expr_stmt|;
break|break;
case|case
name|RPC_PMAPFAILURE
case|:
name|job
operator|->
name|stat
operator|=
name|YPPUSH_PMAP
expr_stmt|;
break|break;
default|default:
name|job
operator|->
name|stat
operator|=
name|YPPUSH_RPC
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Reduce timeout to nothing since we may not 	 * get a response from ypserv and we don't want to block. 	 */
if|if
condition|(
name|clnt_control
argument_list|(
name|clnt
argument_list|,
name|CLSET_TIMEOUT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|timeout
argument_list|)
operator|==
name|FALSE
condition|)
name|yp_error
argument_list|(
literal|"failed to set timeout on ypproc_xfr call"
argument_list|)
expr_stmt|;
comment|/* Invoke the ypproc_xfr service. */
if|if
condition|(
name|ypproc_xfr_2
argument_list|(
operator|&
name|req
argument_list|,
name|clnt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|clnt_geterr
argument_list|(
name|clnt
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|re_status
operator|!=
name|RPC_SUCCESS
operator|&&
name|err
operator|.
name|re_status
operator|!=
name|RPC_TIMEDOUT
condition|)
block|{
name|yp_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|job
operator|->
name|server
argument_list|,
name|clnt_sperror
argument_list|(
name|clnt
argument_list|,
literal|"yp_xfr failed"
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|stat
operator|=
name|YPPUSH_YPSERV
expr_stmt|;
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main driver function. Register the callback service, add the transfer  * request to the internal list, send the YPPROC_XFR request to ypserv  * do other magic things.  */
end_comment

begin_function
name|int
name|yp_push
parameter_list|(
name|char
modifier|*
name|server
parameter_list|,
name|char
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|tid
parameter_list|)
block|{
name|unsigned
name|long
name|prognum
decl_stmt|;
name|int
name|sock
init|=
name|RPC_ANYSOCK
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
name|struct
name|jobs
modifier|*
name|job
decl_stmt|;
comment|/* Register the job in our linked list of jobs. */
comment|/* First allocate job structure */
if|if
condition|(
operator|(
name|job
operator|=
operator|(
expr|struct
name|jobs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|jobs
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Register the callback service on the first free transient 	 * program number. 	 */
name|xprt
operator|=
name|svcudp_create
argument_list|(
name|sock
argument_list|)
expr_stmt|;
for|for
control|(
name|prognum
operator|=
literal|0x40000000
init|;
name|prognum
operator|<
literal|0x5FFFFFFF
condition|;
name|prognum
operator|++
control|)
block|{
if|if
condition|(
name|svc_register
argument_list|(
name|xprt
argument_list|,
name|prognum
argument_list|,
literal|1
argument_list|,
name|yppush_xfrrespprog_1
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|==
name|TRUE
condition|)
break|break;
block|}
if|if
condition|(
name|prognum
operator|==
literal|0x5FFFFFFF
condition|)
block|{
name|yp_error
argument_list|(
literal|"can't register yppush_xfrrespprog_1"
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the info for this job. */
name|job
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
name|job
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|job
operator|->
name|port
operator|=
name|xprt
operator|->
name|xp_port
expr_stmt|;
name|job
operator|->
name|server
operator|=
name|strdup
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|job
operator|->
name|map
operator|=
name|strdup
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|job
operator|->
name|prognum
operator|=
name|prognum
expr_stmt|;
name|job
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
name|job
operator|->
name|next
operator|=
name|yppush_joblist
expr_stmt|;
name|yppush_joblist
operator|=
name|job
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|yp_error
argument_list|(
literal|"initiating transfer: %s -> %s (transid = %lu)"
argument_list|,
name|yppush_mapname
argument_list|,
name|server
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send the XFR request to ypserv. We don't have to wait for 	 * a response here since we handle them asynchronously. 	 */
if|if
condition|(
name|yppush_send_xfr
argument_list|(
name|job
argument_list|)
condition|)
block|{
comment|/* Transfer request blew up. */
name|yppush_show_status
argument_list|(
name|job
operator|->
name|stat
condition|?
name|job
operator|->
name|stat
else|:
name|YPPUSH_YPSERV
argument_list|,
name|job
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%s has been called"
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called for each entry in the ypservers map from yp_get_map(), which  * is our private yp_all() routine.  */
end_comment

begin_function
name|int
name|yppush_foreach
parameter_list|(
name|int
name|status
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|int
name|keylen
parameter_list|,
name|char
modifier|*
name|val
parameter_list|,
name|int
name|vallen
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
name|char
name|server
index|[
name|YPMAXRECORD
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|YP_TRUE
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|snprintf
argument_list|(
name|server
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
name|vallen
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_master
operator|&&
name|strcasecmp
argument_list|(
name|server
argument_list|,
name|yppush_master
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Restrict the number of concurrent jobs: if yppush_jobs number 	 * of jobs have already been dispatched and are still pending, 	 * wait for one of them to finish so we can reuse its slot. 	 */
while|while
condition|(
name|yppush_running_jobs
operator|>=
name|yppush_jobs
operator|&&
operator|(
name|yppush_svc_run
argument_list|(
name|yppush_timeout
argument_list|)
operator|>
literal|0
operator|)
condition|)
empty_stmt|;
comment|/* Cleared for takeoff: set everything in motion. */
if|if
condition|(
name|yp_push
argument_list|(
name|server
argument_list|,
name|yppush_mapname
argument_list|,
name|yppush_transid
argument_list|)
condition|)
return|return
operator|(
name|yp_errno
operator|)
return|;
comment|/* Bump the job counter and transaction ID. */
name|yppush_running_jobs
operator|++
expr_stmt|;
name|yppush_transid
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: yppush [-d domain] [-t timeout] [-j #parallel jobs] [-h host]"
argument_list|,
literal|"              [-p path] mapname"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Entry point. (About time!)  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|char
name|myname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
struct|struct
name|hostlist
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|hostlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|hostlist
modifier|*
name|yppush_hostlist
init|=
name|NULL
decl_stmt|;
name|struct
name|hostlist
modifier|*
name|tmp
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:j:p:h:t:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|yppush_domain
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|yppush_jobs
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|yppush_jobs
operator|<=
literal|0
condition|)
name|yppush_jobs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|yp_dir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* we can handle multiple hosts */
if|if
condition|(
operator|(
name|tmp
operator|=
operator|(
expr|struct
name|hostlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hostlist
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|yppush_hostlist
expr_stmt|;
name|yppush_hostlist
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|yppush_timeout
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|yppush_mapname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|yppush_mapname
operator|==
name|NULL
condition|)
block|{
comment|/* "No guts, no glory." */
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * If no domain was specified, try to find the default 	 * domain. If we can't find that, we're doomed and must bail. 	 */
if|if
condition|(
name|yppush_domain
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|yppush_check_domain
decl_stmt|;
if|if
condition|(
operator|!
name|yp_get_default_domain
argument_list|(
operator|&
name|yppush_check_domain
argument_list|)
operator|&&
operator|!
name|_yp_check
argument_list|(
operator|&
name|yppush_check_domain
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"no domain specified and NIS not running"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
else|else
name|yp_get_default_domain
argument_list|(
operator|&
name|yppush_domain
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see that we are the master for this map. */
if|if
condition|(
name|gethostname
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to get name of local host: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|key
operator|.
name|data
operator|=
literal|"YP_MASTER_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_MASTER_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yp_get_record
argument_list|(
name|yppush_domain
argument_list|,
name|yppush_mapname
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"couldn't open %s map: %s"
argument_list|,
name|yppush_mapname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|myname
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|size
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* I am master server, and no explicit host list was 		   specified: do not push map to myself -- this will 		   fail with YPPUSH_AGE anyway. */
if|if
condition|(
name|yppush_hostlist
operator|==
name|NULL
condition|)
name|skip_master
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|yp_error
argument_list|(
literal|"warning: this host is not the master for %s"
argument_list|,
name|yppush_mapname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NITPICKY
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|yppush_master
operator|=
name|malloc
argument_list|(
name|data
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|yppush_master
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|size
argument_list|)
expr_stmt|;
name|yppush_master
index|[
name|data
operator|.
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Install some handy handlers. */
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|/* set initial transaction ID */
name|yppush_transid
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|yppush_hostlist
condition|)
block|{
comment|/* 	 * Host list was specified on the command line: 	 * kick off the transfers by hand. 	 */
name|tmp
operator|=
name|yppush_hostlist
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|yppush_foreach
argument_list|(
name|YP_TRUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|tmp
operator|->
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * Do a yp_all() on the ypservers map and initiate a ypxfr 	 * for each one. 	 */
name|ypxfr_get_map
argument_list|(
literal|"ypservers"
argument_list|,
name|yppush_domain
argument_list|,
literal|"localhost"
argument_list|,
name|yppush_foreach
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"all jobs dispatched"
argument_list|)
expr_stmt|;
comment|/* All done -- normal exit. */
name|yppush_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Just in case. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

