begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * CTF Declaration Stack  *  * In order to implement ctf_type_name(), we must convert a type graph back  * into a C type declaration.  Unfortunately, a type graph represents a storage  * class ordering of the type whereas a type declaration must obey the C rules  * for operator precedence, and the two orderings are frequently in conflict.  * For example, consider these CTF type graphs and their C declarations:  *  * CTF_K_POINTER -> CTF_K_FUNCTION -> CTF_K_INTEGER  : int (*)()  * CTF_K_POINTER -> CTF_K_ARRAY -> CTF_K_INTEGER     : int (*)[]  *  * In each case, parentheses are used to raise operator * to higher lexical  * precedence, so the string form of the C declaration cannot be constructed by  * walking the type graph links and forming the string from left to right.  *  * The functions in this file build a set of stacks from the type graph nodes  * corresponding to the C operator precedence levels in the appropriate order.  * The code in ctf_type_name() can then iterate over the levels and nodes in  * lexical precedence order and construct the final C declaration string.  */
end_comment

begin_include
include|#
directive|include
file|<ctf_impl.h>
end_include

begin_function
name|void
name|ctf_decl_init
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|cd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_decl_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CTF_PREC_BASE
init|;
name|i
operator|<
name|CTF_PREC_MAX
condition|;
name|i
operator|++
control|)
name|cd
operator|->
name|cd_order
index|[
name|i
index|]
operator|=
name|CTF_PREC_BASE
operator|-
literal|1
expr_stmt|;
name|cd
operator|->
name|cd_qualp
operator|=
name|CTF_PREC_BASE
expr_stmt|;
name|cd
operator|->
name|cd_ordp
operator|=
name|CTF_PREC_BASE
expr_stmt|;
name|cd
operator|->
name|cd_buf
operator|=
name|buf
expr_stmt|;
name|cd
operator|->
name|cd_ptr
operator|=
name|buf
expr_stmt|;
name|cd
operator|->
name|cd_end
operator|=
name|buf
operator|+
name|len
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ctf_decl_fini
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|)
block|{
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|CTF_PREC_BASE
init|;
name|i
operator|<
name|CTF_PREC_MAX
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cdp
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|i
index|]
argument_list|)
init|;
name|cdp
operator|!=
name|NULL
condition|;
name|cdp
operator|=
name|ndp
control|)
block|{
name|ndp
operator|=
name|ctf_list_next
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
name|ctf_free
argument_list|(
name|cdp
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_decl_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ctf_decl_push
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|;
name|ctf_decl_prec_t
name|prec
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|n
init|=
literal|1
decl_stmt|;
name|int
name|is_qual
init|=
literal|0
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ctf_arinfo_t
name|ar
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
operator|&
name|fp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|cd_err
operator|=
name|fp
operator|->
name|ctf_errno
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|kind
operator|=
name|LCTF_INFO_KIND
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_ARRAY
case|:
operator|(
name|void
operator|)
name|ctf_array_info
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|fp
argument_list|,
name|ar
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
name|n
operator|=
name|ar
operator|.
name|ctr_nelems
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_ARRAY
expr_stmt|;
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
if|if
condition|(
name|ctf_strptr
argument_list|(
name|fp
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|fp
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|prec
operator|=
name|CTF_PREC_BASE
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|fp
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_FUNCTION
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|fp
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_POINTER
expr_stmt|;
break|break;
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|fp
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|cd
operator|->
name|cd_qualp
expr_stmt|;
name|is_qual
operator|++
expr_stmt|;
break|break;
default|default:
name|prec
operator|=
name|CTF_PREC_BASE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cdp
operator|=
name|ctf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_decl_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|cd_err
operator|=
name|EAGAIN
expr_stmt|;
return|return;
block|}
name|cdp
operator|->
name|cd_type
operator|=
name|type
expr_stmt|;
name|cdp
operator|->
name|cd_kind
operator|=
name|kind
expr_stmt|;
name|cdp
operator|->
name|cd_n
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|cd
operator|->
name|cd_order
index|[
name|prec
index|]
operator|=
name|cd
operator|->
name|cd_ordp
operator|++
expr_stmt|;
comment|/* 	 * Reset cd_qualp to the highest precedence level that we've seen so 	 * far that can be qualified (CTF_PREC_BASE or CTF_PREC_POINTER). 	 */
if|if
condition|(
name|prec
operator|>
name|cd
operator|->
name|cd_qualp
operator|&&
name|prec
operator|<
name|CTF_PREC_ARRAY
condition|)
name|cd
operator|->
name|cd_qualp
operator|=
name|prec
expr_stmt|;
comment|/* 	 * C array declarators are ordered inside out so prepend them.  Also by 	 * convention qualifiers of base types precede the type specifier (e.g. 	 * const int vs. int const) even though the two forms are equivalent. 	 */
if|if
condition|(
name|kind
operator|==
name|CTF_K_ARRAY
operator|||
operator|(
name|is_qual
operator|&&
name|prec
operator|==
name|CTF_PREC_BASE
operator|)
condition|)
name|ctf_list_prepend
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
else|else
name|ctf_list_append
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE2*/
end_comment

begin_function
name|void
name|ctf_decl_sprintf
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|len
init|=
call|(
name|size_t
call|)
argument_list|(
name|cd
operator|->
name|cd_end
operator|-
name|cd
operator|->
name|cd_ptr
argument_list|)
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|n
operator|=
name|vsnprintf
argument_list|(
name|cd
operator|->
name|cd_ptr
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cd
operator|->
name|cd_ptr
operator|+=
name|MIN
argument_list|(
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cd
operator|->
name|cd_len
operator|+=
name|n
expr_stmt|;
block|}
end_function

end_unit

