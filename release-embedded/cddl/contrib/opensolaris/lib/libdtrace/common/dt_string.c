begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_comment
comment|/*  * Transform string s inline, converting each embedded C escape sequence string  * to the corresponding character.  For example, the substring "\n" is replaced  * by an inline '\n' character.  The length of the resulting string is returned.  */
end_comment

begin_function
name|size_t
name|stresc2chr
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|c
decl_stmt|;
name|int
name|esc
init|=
literal|0
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
name|p
operator|=
name|q
operator|=
name|s
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|esc
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|c
operator|-=
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|=
name|c
operator|*
literal|8
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
condition|)
name|c
operator|=
name|c
operator|*
literal|8
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
name|p
operator|--
expr_stmt|;
block|}
else|else
name|p
operator|--
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\a'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
for|for
control|(
name|x
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
operator|++
name|p
operator|)
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|x
operator|=
name|x
operator|*
literal|16
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|x
operator|=
name|x
operator|*
literal|16
operator|+
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|x
operator|=
name|x
operator|*
literal|16
operator|+
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|q
operator|++
operator|=
operator|(
name|char
operator|)
name|x
expr_stmt|;
name|p
operator|--
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
break|break;
default|default:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|esc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|esc
operator|=
name|c
operator|==
literal|'\\'
operator|)
operator|==
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a copy of string s in which certain unprintable or special characters  * have been converted to the string representation of their C escape sequence.  * For example, the newline character is expanded to the string "\n".  */
end_comment

begin_function
name|char
modifier|*
name|strchr2esc
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
name|c
decl_stmt|;
name|size_t
name|addl
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
name|p
operator|<
name|s
operator|+
name|n
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'\a'
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|addl
operator|++
expr_stmt|;
comment|/* 1 add'l char needed to follow \ */
break|break;
case|case
literal|' '
case|:
break|break;
default|default:
if|if
condition|(
name|c
operator|<
literal|'!'
operator|||
name|c
operator|>
literal|'~'
condition|)
name|addl
operator|+=
literal|3
expr_stmt|;
comment|/* 3 add'l chars following \ */
block|}
block|}
if|if
condition|(
operator|(
name|s2
operator|=
name|malloc
argument_list|(
name|n
operator|+
name|addl
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|s
operator|,
name|q
operator|=
name|s2
init|;
name|p
operator|<
name|s
operator|+
name|n
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'\0'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'\a'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'"'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|' '
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|<
literal|'!'
operator|||
name|c
operator|>
literal|'~'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|3
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
comment|/* don't continue past \0 even if p< s + n */
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|s2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the basename (name after final /) of the given string.  We use  * strbasename rather than basename to avoid conflicting with libgen.h's  * non-const function prototype.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|strbasename
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|s
operator|)
return|;
return|return
operator|(
operator|++
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function tests a string against the regular expression used for idents  * and integers in the D lexer, and should match the superset of RGX_IDENT and  * RGX_INT in dt_lex.l.  If an invalid character is found, the function returns  * a pointer to it.  Otherwise NULL is returned for a valid string.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|strbadidnum
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|errno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strtoull
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* matches RGX_INT */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|==
literal|0
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'`'
condition|)
return|return
operator|(
name|s
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* matches RGX_IDENT */
block|}
end_function

begin_comment
comment|/*  * Determine whether the string contains a glob matching pattern or is just a  * simple string.  See gmatch(3GEN) and sh(1) for the glob syntax definition.  */
end_comment

begin_function
name|int
name|strisglob
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'\\'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hyphenate a string in-place by converting any instances of "__" to "-",  * which we use for probe names to improve readability, and return the string.  */
end_comment

begin_function
name|char
modifier|*
name|strhyphenate
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|,
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
init|;
name|p
operator|<
name|q
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|p
operator|+
literal|1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

end_unit

