begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBUUTIL_IMPL_H
end_ifndef

begin_define
define|#
directive|define
name|_LIBUUTIL_IMPL_H
end_define

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<libuutil.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
name|void
name|uu_set_error
parameter_list|(
name|uint_t
parameter_list|)
function_decl|;
pragma|#
directive|pragma
name|rarely_called
name|(
name|uu_set_error
name|)
comment|/*PRINTFLIKE1*/
name|void
name|uu_panic
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
pragma|#
directive|pragma
name|rarely_called
name|(
name|uu_panic
name|)
struct|struct
name|uu_dprintf
block|{
name|char
modifier|*
name|uud_name
decl_stmt|;
name|uu_dprintf_severity_t
name|uud_severity
decl_stmt|;
name|uint_t
name|uud_flags
decl_stmt|;
block|}
struct|;
comment|/*  * For debugging purposes, libuutil keeps around linked lists of all uu_lists  * and uu_avls, along with pointers to their parents.  These can cause false  * negatives when looking for memory leaks, so we encode the pointers by  * storing them with swapped endianness;  this is not perfect, but it's about  * the best we can do without wasting a lot of space.  */
ifdef|#
directive|ifdef
name|_LP64
define|#
directive|define
name|UU_PTR_ENCODE
parameter_list|(
name|ptr
parameter_list|)
value|BSWAP_64((uintptr_t)(void *)(ptr))
else|#
directive|else
define|#
directive|define
name|UU_PTR_ENCODE
parameter_list|(
name|ptr
parameter_list|)
value|BSWAP_32((uintptr_t)(void *)(ptr))
endif|#
directive|endif
define|#
directive|define
name|UU_PTR_DECODE
parameter_list|(
name|ptr
parameter_list|)
value|((void *)UU_PTR_ENCODE(ptr))
comment|/*  * uu_list structures  */
typedef|typedef
struct|struct
name|uu_list_node_impl
block|{
name|struct
name|uu_list_node_impl
modifier|*
name|uln_next
decl_stmt|;
name|struct
name|uu_list_node_impl
modifier|*
name|uln_prev
decl_stmt|;
block|}
name|uu_list_node_impl_t
typedef|;
struct|struct
name|uu_list_walk
block|{
name|uu_list_walk_t
modifier|*
name|ulw_next
decl_stmt|;
name|uu_list_walk_t
modifier|*
name|ulw_prev
decl_stmt|;
name|uu_list_t
modifier|*
name|ulw_list
decl_stmt|;
name|int8_t
name|ulw_dir
decl_stmt|;
name|uint8_t
name|ulw_robust
decl_stmt|;
name|uu_list_node_impl_t
modifier|*
name|ulw_next_result
decl_stmt|;
block|}
struct|;
struct|struct
name|uu_list
block|{
name|uintptr_t
name|ul_next_enc
decl_stmt|;
name|uintptr_t
name|ul_prev_enc
decl_stmt|;
name|uu_list_pool_t
modifier|*
name|ul_pool
decl_stmt|;
name|uintptr_t
name|ul_parent_enc
decl_stmt|;
comment|/* encoded parent pointer */
name|size_t
name|ul_offset
decl_stmt|;
name|size_t
name|ul_numnodes
decl_stmt|;
name|uint8_t
name|ul_debug
decl_stmt|;
name|uint8_t
name|ul_sorted
decl_stmt|;
name|uint8_t
name|ul_index
decl_stmt|;
comment|/* mark for uu_list_index_ts */
name|uu_list_node_impl_t
name|ul_null_node
decl_stmt|;
name|uu_list_walk_t
name|ul_null_walk
decl_stmt|;
comment|/* for robust walkers */
block|}
struct|;
define|#
directive|define
name|UU_LIST_PTR
parameter_list|(
name|ptr
parameter_list|)
value|((uu_list_t *)UU_PTR_DECODE(ptr))
define|#
directive|define
name|UU_LIST_POOL_MAXNAME
value|64
struct|struct
name|uu_list_pool
block|{
name|uu_list_pool_t
modifier|*
name|ulp_next
decl_stmt|;
name|uu_list_pool_t
modifier|*
name|ulp_prev
decl_stmt|;
name|char
name|ulp_name
index|[
name|UU_LIST_POOL_MAXNAME
index|]
decl_stmt|;
name|size_t
name|ulp_nodeoffset
decl_stmt|;
name|size_t
name|ulp_objsize
decl_stmt|;
name|uu_compare_fn_t
modifier|*
name|ulp_cmp
decl_stmt|;
name|uint8_t
name|ulp_debug
decl_stmt|;
name|uint8_t
name|ulp_last_index
decl_stmt|;
name|pthread_mutex_t
name|ulp_lock
decl_stmt|;
comment|/* protects null_list */
name|uu_list_t
name|ulp_null_list
decl_stmt|;
block|}
struct|;
comment|/*  * uu_avl structures  */
typedef|typedef
name|struct
name|avl_node
name|uu_avl_node_impl_t
typedef|;
struct|struct
name|uu_avl_walk
block|{
name|uu_avl_walk_t
modifier|*
name|uaw_next
decl_stmt|;
name|uu_avl_walk_t
modifier|*
name|uaw_prev
decl_stmt|;
name|uu_avl_t
modifier|*
name|uaw_avl
decl_stmt|;
name|void
modifier|*
name|uaw_next_result
decl_stmt|;
name|int8_t
name|uaw_dir
decl_stmt|;
name|uint8_t
name|uaw_robust
decl_stmt|;
block|}
struct|;
struct|struct
name|uu_avl
block|{
name|uintptr_t
name|ua_next_enc
decl_stmt|;
name|uintptr_t
name|ua_prev_enc
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|ua_pool
decl_stmt|;
name|uintptr_t
name|ua_parent_enc
decl_stmt|;
name|uint8_t
name|ua_debug
decl_stmt|;
name|uint8_t
name|ua_index
decl_stmt|;
comment|/* mark for uu_avl_index_ts */
name|struct
name|avl_tree
name|ua_tree
decl_stmt|;
name|uu_avl_walk_t
name|ua_null_walk
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|UU_AVL_PTR
parameter_list|(
name|x
parameter_list|)
value|((uu_avl_t *)UU_PTR_DECODE(x))
define|#
directive|define
name|UU_AVL_POOL_MAXNAME
value|64
struct|struct
name|uu_avl_pool
block|{
name|uu_avl_pool_t
modifier|*
name|uap_next
decl_stmt|;
name|uu_avl_pool_t
modifier|*
name|uap_prev
decl_stmt|;
name|char
name|uap_name
index|[
name|UU_AVL_POOL_MAXNAME
index|]
decl_stmt|;
name|size_t
name|uap_nodeoffset
decl_stmt|;
name|size_t
name|uap_objsize
decl_stmt|;
name|uu_compare_fn_t
modifier|*
name|uap_cmp
decl_stmt|;
name|uint8_t
name|uap_debug
decl_stmt|;
name|uint8_t
name|uap_last_index
decl_stmt|;
name|pthread_mutex_t
name|uap_lock
decl_stmt|;
comment|/* protects null_avl */
name|uu_avl_t
name|uap_null_avl
decl_stmt|;
block|}
struct|;
comment|/*  * atfork() handlers  */
name|void
name|uu_avl_lockup
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|uu_avl_release
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|uu_list_lockup
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|uu_list_release
parameter_list|(
name|void
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBUUTIL_IMPL_H */
end_comment

end_unit

