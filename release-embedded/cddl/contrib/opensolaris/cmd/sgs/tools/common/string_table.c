begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<_string_table.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sgs.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  * This file provides the interfaces to build a Str_tbl suitable for use by  * either the sgsmsg message system, or a standard ELF string table (SHT_STRTAB)  * as created by ld(1).  *  * There are two modes which can be used when constructing a string table:  *  *	st_new(0)  *		standard string table - no compression.  This is the  *		traditional, fast method.  *  *	st_new(FLG_STTAB_COMPRESS)  *		builds a compressed string table which both eliminates  *		duplicate strings, and permits strings with common suffixes  *		(atexit vs. exit) to overlap in the table.  This provides space  *		savings for many string tables.  Although more work than the  *		traditional method, the algorithms used are designed to scale  *		and keep any overhead at a minimum.  *  * These string tables are built with a common interface in a two-pass manner.  * The first pass finds all of the strings required for the string-table and  * calculates the size required for the final string table.  *  * The second pass allocates the string table, populates the strings into the  * table and returns the offsets the strings have been assigned.  *  * The calling sequence to build and populate a string table is:  *  *		st_new();		// initialize strtab  *  *		st_insert(st1);		// first pass of strings ...  *					// calculates size required for  *					// string table  *  *		st_delstring(st?);	// remove string previously  *					// inserted  *		st_insert(stN);  *  *		st_getstrtab_sz();	// freezes strtab and computes  *					// size of table.  *  *		st_setstrbuf();		// associates a final destination  *					// for the string table  *  *		st_setstring(st1);	// populate the string table  *		...			// offsets are based off of second  *					// pass	through the string table  *		st_setstring(stN);  *  *		st_destroy();		// tear down string table  *					// structures.  *  * String Suffix Compression Algorithm:  *  *   Here's a quick high level overview of the Suffix String  *   compression algorithm used.  First - the heart of the algorithm  *   is a Hash table list which represents a dictionary of all unique  *   strings inserted into the string table.  The hash function for  *   this table is a standard string hash except that the hash starts  *   at the last character in the string (&str[n - 1]) and works towards  *   the first character in the function (&str[0]).  As we compute the  *   HASH value for a given string, we also compute the hash values  *   for all of the possible suffix strings for that string.  *  *   As we compute the hash - at each character see if the current  *   suffix string for that hash is already present in the table.  If  *   it is, and the string is a master string.  Then change that  *   string to a suffix string of the new string being inserted.  *  *   When the final hash value is found (hash for str[0...n]), check  *   to see if it is in the hash table - if so increment the reference  *   count for the string.  If it is not yet in the table, insert a  *   new hash table entry for a master string.  *  *   The above method will find all suffixes of a given string given  *   that the strings are inserted from shortest to longest.  That is  *   why this is a two phase method, we first collect all of the  *   strings and store them based off of their length in an AVL tree.  *   Once all of the strings have been submitted we then start the  *   hash table build by traversing the AVL tree in order and  *   inserting the strings from shortest to longest as described  *   above.  */
end_comment

begin_comment
comment|/* LINTLIBRARY */
end_comment

begin_function
specifier|static
name|int
name|avl_len_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
name|size_t
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|len1
operator|=
operator|(
operator|(
name|LenNode
operator|*
operator|)
name|n1
operator|)
operator|->
name|ln_strlen
expr_stmt|;
name|len2
operator|=
operator|(
operator|(
name|LenNode
operator|*
operator|)
name|n2
operator|)
operator|->
name|ln_strlen
expr_stmt|;
if|if
condition|(
name|len1
operator|==
name|len2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len2
operator|<
name|len1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|avl_str_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|str1
operator|=
operator|(
operator|(
name|StrNode
operator|*
operator|)
name|n1
operator|)
operator|->
name|sn_str
expr_stmt|;
name|str2
operator|=
operator|(
operator|(
name|StrNode
operator|*
operator|)
name|n2
operator|)
operator|->
name|sn_str
expr_stmt|;
name|rc
operator|=
name|strcmp
argument_list|(
name|str1
argument_list|,
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return an initialized Str_tbl - returns NULL on failure.  *  * flags:  *	FLG_STTAB_COMPRESS - build a compressed string table  */
end_comment

begin_function
name|Str_tbl
modifier|*
name|st_new
parameter_list|(
name|uint_t
name|flags
parameter_list|)
block|{
name|Str_tbl
modifier|*
name|stp
decl_stmt|;
if|if
condition|(
operator|(
name|stp
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Str_tbl
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Start with a leading '\0' - it's tradition. 	 */
name|stp
operator|->
name|st_strsize
operator|=
name|stp
operator|->
name|st_fullstrsize
operator|=
name|stp
operator|->
name|st_nextoff
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Do we compress this string table? 	 */
name|stp
operator|->
name|st_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COMPRESS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|stp
operator|)
return|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_lentree
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|avl_create
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|,
operator|&
name|avl_len_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|LenNode
argument_list|)
argument_list|,
name|SGSOFFSETOF
argument_list|(
name|LenNode
argument_list|,
name|ln_avlnode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|stp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a new string into the Str_tbl.  There are two AVL trees used.  *  *  .	The first LenNode AVL tree maintains a tree of nodes based on string  *	sizes.  *  .	Each LenNode maintains a StrNode AVL tree for each string.  Large  *	applications have been known to contribute thousands of strings of  *	the same size.  Should strings need to be removed (-z ignore), then  *	the string AVL tree makes this removal efficient and scalable.  */
end_comment

begin_function
name|int
name|st_insert
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|StrNode
modifier|*
name|snp
decl_stmt|,
name|sn
init|=
block|{
literal|0
block|}
decl_stmt|;
name|LenNode
modifier|*
name|lnp
decl_stmt|,
name|ln
init|=
block|{
literal|0
block|}
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
comment|/* 	 * String table can't have been cooked 	 */
name|assert
argument_list|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COOKED
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Null strings always point to the head of the string 	 * table - no reason to keep searching. 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|stp
operator|->
name|st_fullstrsize
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|stp
operator|->
name|st_strcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COMPRESS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * From the controlling string table, determine which LenNode AVL node 	 * provides for this string length.  If the node doesn't exist, insert 	 * a new node to represent this string length. 	 */
name|ln
operator|.
name|ln_strlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|lnp
operator|=
name|avl_find
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|,
operator|&
name|ln
argument_list|,
operator|&
name|where
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|lnp
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|LenNode
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lnp
operator|->
name|ln_strlen
operator|=
name|len
expr_stmt|;
name|avl_insert
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|,
name|lnp
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lnp
operator|->
name|ln_strtree
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|avl_create
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|,
operator|&
name|avl_str_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|StrNode
argument_list|)
argument_list|,
name|SGSOFFSETOF
argument_list|(
name|StrNode
argument_list|,
name|sn_avlnode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * From the string length AVL node determine whether a StrNode AVL node 	 * provides this string.  If the node doesn't exist, insert a new node 	 * to represent this string. 	 */
name|sn
operator|.
name|sn_str
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|(
name|snp
operator|=
name|avl_find
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|,
operator|&
name|sn
argument_list|,
operator|&
name|where
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|snp
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|StrNode
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|snp
operator|->
name|sn_str
operator|=
name|str
expr_stmt|;
name|avl_insert
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|,
name|snp
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
name|snp
operator|->
name|sn_refcnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a previously inserted string from the Str_tbl.  */
end_comment

begin_function
name|int
name|st_delstring
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|LenNode
modifier|*
name|lnp
decl_stmt|,
name|ln
init|=
block|{
literal|0
block|}
decl_stmt|;
name|StrNode
modifier|*
name|snp
decl_stmt|,
name|sn
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 	 * String table can't have been cooked 	 */
name|assert
argument_list|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COOKED
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_fullstrsize
operator|-=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COMPRESS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Determine which LenNode AVL node provides for this string length. 	 */
name|ln
operator|.
name|ln_strlen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|lnp
operator|=
name|avl_find
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|,
operator|&
name|ln
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sn
operator|.
name|sn_str
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|(
name|snp
operator|=
name|avl_find
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|,
operator|&
name|sn
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reduce the reference count, and if zero remove the 			 * node. 			 */
if|if
condition|(
operator|--
name|snp
operator|->
name|sn_refcnt
operator|==
literal|0
condition|)
name|avl_remove
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|,
name|snp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * No strings of this length, or no string itself - someone goofed. 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tear down a String_Table structure.  */
end_comment

begin_function
name|void
name|st_destroy
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|)
block|{
name|Str_hash
modifier|*
name|sthash
decl_stmt|,
modifier|*
name|psthash
decl_stmt|;
name|Str_master
modifier|*
name|mstr
decl_stmt|,
modifier|*
name|pmstr
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
comment|/* 	 * cleanup the master strings 	 */
for|for
control|(
name|mstr
operator|=
name|stp
operator|->
name|st_mstrlist
operator|,
name|pmstr
operator|=
literal|0
init|;
name|mstr
condition|;
name|mstr
operator|=
name|mstr
operator|->
name|sm_next
control|)
block|{
if|if
condition|(
name|pmstr
condition|)
name|free
argument_list|(
name|pmstr
argument_list|)
expr_stmt|;
name|pmstr
operator|=
name|mstr
expr_stmt|;
block|}
if|if
condition|(
name|pmstr
condition|)
name|free
argument_list|(
name|pmstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_hashbcks
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stp
operator|->
name|st_hbckcnt
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|sthash
operator|=
name|stp
operator|->
name|st_hashbcks
index|[
name|i
index|]
operator|,
name|psthash
operator|=
literal|0
init|;
name|sthash
condition|;
name|sthash
operator|=
name|sthash
operator|->
name|hi_next
control|)
block|{
if|if
condition|(
name|psthash
condition|)
name|free
argument_list|(
name|psthash
argument_list|)
expr_stmt|;
name|psthash
operator|=
name|sthash
expr_stmt|;
block|}
if|if
condition|(
name|psthash
condition|)
name|free
argument_list|(
name|psthash
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|stp
operator|->
name|st_hashbcks
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|stp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For a given string - copy it into the buffer associated with  * the string table - and return the offset it has been assigned.  *  * If a value of '-1' is returned - the string was not found in  * the Str_tbl.  */
end_comment

begin_function
name|int
name|st_setstring
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
modifier|*
name|stoff
parameter_list|)
block|{
name|size_t
name|stlen
decl_stmt|;
name|uint_t
name|hashval
decl_stmt|;
name|Str_hash
modifier|*
name|sthash
decl_stmt|;
name|Str_master
modifier|*
name|mstr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * String table *must* have been previously cooked 	 */
name|assert
argument_list|(
name|stp
operator|->
name|st_strbuf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COOKED
argument_list|)
expr_stmt|;
name|stlen
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* 	 * Null string always points to head of string table 	 */
if|if
condition|(
name|stlen
operator|==
literal|0
condition|)
block|{
operator|*
name|stoff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COMPRESS
operator|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|_stoff
decl_stmt|;
name|stlen
operator|++
expr_stmt|;
comment|/* count for trailing '\0' */
name|_stoff
operator|=
name|stp
operator|->
name|st_nextoff
expr_stmt|;
comment|/* 		 * Have we overflowed our assigned buffer? 		 */
if|if
condition|(
operator|(
name|_stoff
operator|+
name|stlen
operator|)
operator|>
name|stp
operator|->
name|st_fullstrsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|stp
operator|->
name|st_strbuf
operator|+
name|_stoff
argument_list|,
name|str
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
operator|*
name|stoff
operator|=
name|_stoff
expr_stmt|;
name|stp
operator|->
name|st_nextoff
operator|+=
name|stlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Calculate reverse hash for string. 	 */
name|hashval
operator|=
name|HASHSEED
expr_stmt|;
for|for
control|(
name|i
operator|=
name|stlen
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|hashval
operator|=
operator|(
operator|(
name|hashval
operator|<<
literal|5
operator|)
operator|+
name|hashval
operator|)
operator|+
name|str
index|[
name|i
index|]
expr_stmt|;
comment|/* h = ((h * 33) + c) */
block|}
for|for
control|(
name|sthash
operator|=
name|stp
operator|->
name|st_hashbcks
index|[
name|hashval
operator|%
name|stp
operator|->
name|st_hbckcnt
index|]
init|;
name|sthash
condition|;
name|sthash
operator|=
name|sthash
operator|->
name|hi_next
control|)
block|{
specifier|const
name|char
modifier|*
name|hstr
decl_stmt|;
if|if
condition|(
name|sthash
operator|->
name|hi_hashval
operator|!=
name|hashval
condition|)
continue|continue;
name|hstr
operator|=
operator|&
name|sthash
operator|->
name|hi_mstr
operator|->
name|sm_str
index|[
name|sthash
operator|->
name|hi_mstr
operator|->
name|sm_strlen
operator|-
name|sthash
operator|->
name|hi_strlen
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|hstr
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* 	 * Did we find the string? 	 */
if|if
condition|(
name|sthash
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Has this string been copied into the string table? 	 */
name|mstr
operator|=
name|sthash
operator|->
name|hi_mstr
expr_stmt|;
if|if
condition|(
name|mstr
operator|->
name|sm_stroff
operator|==
literal|0
condition|)
block|{
name|size_t
name|mstrlen
init|=
name|mstr
operator|->
name|sm_strlen
operator|+
literal|1
decl_stmt|;
name|mstr
operator|->
name|sm_stroff
operator|=
name|stp
operator|->
name|st_nextoff
expr_stmt|;
comment|/* 		 * Have we overflowed our assigned buffer? 		 */
if|if
condition|(
operator|(
name|mstr
operator|->
name|sm_stroff
operator|+
name|mstrlen
operator|)
operator|>
name|stp
operator|->
name|st_fullstrsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|stp
operator|->
name|st_strbuf
operator|+
name|mstr
operator|->
name|sm_stroff
argument_list|,
name|mstr
operator|->
name|sm_str
argument_list|,
name|mstrlen
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_nextoff
operator|+=
name|mstrlen
expr_stmt|;
block|}
comment|/* 	 * Calculate offset of (sub)string. 	 */
operator|*
name|stoff
operator|=
name|mstr
operator|->
name|sm_stroff
operator|+
name|mstr
operator|->
name|sm_strlen
operator|-
name|sthash
operator|->
name|hi_strlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|st_hash_insert
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint_t
name|hashval
init|=
name|HASHSEED
decl_stmt|;
name|uint_t
name|bckcnt
init|=
name|stp
operator|->
name|st_hbckcnt
decl_stmt|;
name|Str_hash
modifier|*
modifier|*
name|hashbcks
init|=
name|stp
operator|->
name|st_hashbcks
decl_stmt|;
name|Str_hash
modifier|*
name|sthash
decl_stmt|;
name|Str_master
modifier|*
name|mstr
init|=
literal|0
decl_stmt|;
comment|/* 	 * We use a classic 'Bernstein k=33' hash function.  But 	 * instead of hashing from the start of the string to the 	 * end, we do it in reverse. 	 * 	 * This way - we are essentially building all of the 	 * suffix hashvalues as we go.  We can check to see if 	 * any suffixes already exist in the tree as we generate 	 * the hash. 	 */
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|hashval
operator|=
operator|(
operator|(
name|hashval
operator|<<
literal|5
operator|)
operator|+
name|hashval
operator|)
operator|+
name|str
index|[
name|i
index|]
expr_stmt|;
comment|/* h = ((h * 33) + c) */
for|for
control|(
name|sthash
operator|=
name|hashbcks
index|[
name|hashval
operator|%
name|bckcnt
index|]
init|;
name|sthash
condition|;
name|sthash
operator|=
name|sthash
operator|->
name|hi_next
control|)
block|{
specifier|const
name|char
modifier|*
name|hstr
decl_stmt|;
name|Str_master
modifier|*
name|_mstr
decl_stmt|;
if|if
condition|(
name|sthash
operator|->
name|hi_hashval
operator|!=
name|hashval
condition|)
continue|continue;
name|_mstr
operator|=
name|sthash
operator|->
name|hi_mstr
expr_stmt|;
name|hstr
operator|=
operator|&
name|_mstr
operator|->
name|sm_str
index|[
name|_mstr
operator|->
name|sm_strlen
operator|-
name|sthash
operator|->
name|hi_strlen
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|str
index|[
name|i
index|]
argument_list|,
name|hstr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Entry already in table, increment refcnt and 				 * get out. 				 */
name|sthash
operator|->
name|hi_refcnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 				 * If this 'suffix' is presently a 'master 				 * string, then take over it's record. 				 */
if|if
condition|(
name|sthash
operator|->
name|hi_strlen
operator|==
name|_mstr
operator|->
name|sm_strlen
condition|)
block|{
comment|/* 					 * we should only do this once. 					 */
name|assert
argument_list|(
name|mstr
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mstr
operator|=
name|_mstr
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Do we need a new master string, or can we take over 	 * one we already found in the table? 	 */
if|if
condition|(
name|mstr
operator|==
literal|0
condition|)
block|{
comment|/* 		 * allocate a new master string 		 */
if|if
condition|(
operator|(
name|mstr
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Str_hash
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mstr
operator|->
name|sm_next
operator|=
name|stp
operator|->
name|st_mstrlist
expr_stmt|;
name|stp
operator|->
name|st_mstrlist
operator|=
name|mstr
expr_stmt|;
name|stp
operator|->
name|st_strsize
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We are taking over a existing master string, the string size 		 * only increments by the difference between the current string 		 * and the previous master. 		 */
name|assert
argument_list|(
name|len
operator|>
name|mstr
operator|->
name|sm_strlen
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_strsize
operator|+=
name|len
operator|-
name|mstr
operator|->
name|sm_strlen
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sthash
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Str_hash
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mstr
operator|->
name|sm_hashval
operator|=
name|sthash
operator|->
name|hi_hashval
operator|=
name|hashval
expr_stmt|;
name|mstr
operator|->
name|sm_strlen
operator|=
name|sthash
operator|->
name|hi_strlen
operator|=
name|len
expr_stmt|;
name|mstr
operator|->
name|sm_str
operator|=
name|str
expr_stmt|;
name|sthash
operator|->
name|hi_refcnt
operator|=
literal|1
expr_stmt|;
name|sthash
operator|->
name|hi_mstr
operator|=
name|mstr
expr_stmt|;
comment|/* 	 * Insert string element into head of hash list 	 */
name|hashval
operator|=
name|hashval
operator|%
name|bckcnt
expr_stmt|;
name|sthash
operator|->
name|hi_next
operator|=
name|hashbcks
index|[
name|hashval
index|]
expr_stmt|;
name|hashbcks
index|[
name|hashval
index|]
operator|=
name|sthash
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return amount of space required for the string table.  */
end_comment

begin_function
name|size_t
name|st_getstrtab_sz
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|)
block|{
name|assert
argument_list|(
name|stp
operator|->
name|st_fullstrsize
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COMPRESS
operator|)
operator|==
literal|0
condition|)
block|{
name|stp
operator|->
name|st_flags
operator||=
name|FLG_STTAB_COOKED
expr_stmt|;
return|return
operator|(
name|stp
operator|->
name|st_fullstrsize
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COOKED
operator|)
operator|==
literal|0
condition|)
block|{
name|LenNode
modifier|*
name|lnp
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|stp
operator|->
name|st_flags
operator||=
name|FLG_STTAB_COOKED
expr_stmt|;
comment|/* 		 * allocate a hash table about the size of # of 		 * strings input. 		 */
name|stp
operator|->
name|st_hbckcnt
operator|=
name|findprime
argument_list|(
name|stp
operator|->
name|st_strcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_hashbcks
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Str_hash
argument_list|)
argument_list|,
name|stp
operator|->
name|st_hbckcnt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * We now walk all of the strings in the list, from shortest to 		 * longest, and insert them into the hashtable. 		 */
if|if
condition|(
operator|(
name|lnp
operator|=
name|avl_first
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Is it possible we have an empty string table, if so, 			 * the table still contains '\0', so return the size. 			 */
if|if
condition|(
name|avl_numnodes
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|)
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|stp
operator|->
name|st_strsize
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|stp
operator|->
name|st_strsize
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|lnp
condition|)
block|{
name|StrNode
modifier|*
name|snp
decl_stmt|;
comment|/* 			 * Walk the string lists and insert them into the hash 			 * list.  Once a string is inserted we no longer need 			 * it's entry, so the string can be freed. 			 */
for|for
control|(
name|snp
operator|=
name|avl_first
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|)
init|;
name|snp
condition|;
name|snp
operator|=
name|AVL_NEXT
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|,
name|snp
argument_list|)
control|)
block|{
if|if
condition|(
name|st_hash_insert
argument_list|(
name|stp
argument_list|,
name|snp
operator|->
name|sn_str
argument_list|,
name|lnp
operator|->
name|ln_strlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * Now that the strings have been copied, walk the 			 * StrNode tree and free all the AVL nodes.  Note, 			 * avl_destroy_nodes() beats avl_remove() as the 			 * latter balances the nodes as they are removed. 			 * We just want to tear the whole thing down fast. 			 */
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|snp
operator|=
name|avl_destroy_nodes
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|snp
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lnp
operator|->
name|ln_strtree
argument_list|)
expr_stmt|;
name|lnp
operator|->
name|ln_strtree
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Move on to the next LenNode. 			 */
name|lnp
operator|=
name|AVL_NEXT
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|,
name|lnp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now that all of the strings have been freed, walk the 		 * LenNode tree and free all of the AVL nodes.  Note, 		 * avl_destroy_nodes() beats avl_remove() as the latter 		 * balances the nodes as they are removed. We just want to 		 * tear the whole thing down fast. 		 */
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|lnp
operator|=
name|avl_destroy_nodes
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lnp
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stp
operator|->
name|st_lentree
argument_list|)
expr_stmt|;
name|stp
operator|->
name|st_lentree
operator|=
literal|0
expr_stmt|;
block|}
name|assert
argument_list|(
name|stp
operator|->
name|st_strsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|stp
operator|->
name|st_fullstrsize
operator|>=
name|stp
operator|->
name|st_strsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|stp
operator|->
name|st_strsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Associate a buffer with a string table.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|st_getstrbuf
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|)
block|{
return|return
operator|(
name|stp
operator|->
name|st_strbuf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|st_setstrbuf
parameter_list|(
name|Str_tbl
modifier|*
name|stp
parameter_list|,
name|char
modifier|*
name|stbuf
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
block|{
name|assert
argument_list|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COOKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stp
operator|->
name|st_flags
operator|&
name|FLG_STTAB_COMPRESS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bufsize
operator|<
name|stp
operator|->
name|st_fullstrsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|bufsize
operator|<
name|stp
operator|->
name|st_strsize
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|stp
operator|->
name|st_strbuf
operator|=
name|stbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * for debug builds - start with a stringtable filled in 	 * with '0xff'.  This makes it very easy to find wholes 	 * which we failed to fill in - in the strtab. 	 */
name|memset
argument_list|(
name|stbuf
argument_list|,
literal|0xff
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|stbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
name|stbuf
argument_list|,
literal|0x0
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

