begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 David Schultz<das@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Tests for corner cases in the inverse trigonometric functions. Some  * accuracy tests are included as well, but these are very basic  * sanity checks, not intended to be comprehensive.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<fenv.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"test-utils.h"
end_include

begin_define
define|#
directive|define
name|LEN
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof((a)[0]))
end_define

begin_pragma
pragma|#
directive|pragma
name|STDC
name|FENV_ACCESS
name|ON
end_pragma

begin_comment
comment|/*  * Test that a function returns the correct value and sets the  * exception flags correctly. A tolerance specifying the maximum  * relative error allowed may be specified. For the 'testall'  * functions, the tolerance is specified in ulps.  *  * These are macros instead of functions so that assert provides more  * meaningful error messages.  */
end_comment

begin_define
define|#
directive|define
name|test_tol
parameter_list|(
name|func
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|tol
parameter_list|,
name|excepts
parameter_list|)
value|do {			\ 	volatile long double _in = (x), _out = (result);		\ 	assert(feclearexcept(FE_ALL_EXCEPT) == 0);			\ 	assert(fpequal_tol(func(_in), _out, (tol), CS_BOTH));		\ 	assert(((void)func, fetestexcept(ALL_STD_EXCEPT) == (excepts))); \ } while (0)
end_define

begin_define
define|#
directive|define
name|test
parameter_list|(
name|func
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|excepts
parameter_list|)
define|\
value|test_tol(func, (x), (result), 0, (excepts))
end_define

begin_define
define|#
directive|define
name|testall_tol
parameter_list|(
name|prefix
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|tol
parameter_list|,
name|excepts
parameter_list|)
value|do {		\ 	test_tol(prefix, (double)(x), (double)(result),			\ 		 (tol) * ldexp(1.0, 1 - DBL_MANT_DIG), (excepts));	\ 	test_tol(prefix##f, (float)(x), (float)(result),		\ 		 (tol) * ldexpf(1.0, 1 - FLT_MANT_DIG), (excepts));	\ 	test_tol(prefix##l, (x), (result),				\ 		 (tol) * ldexpl(1.0, 1 - LDBL_MANT_DIG), (excepts));	\ } while (0)
end_define

begin_define
define|#
directive|define
name|testall
parameter_list|(
name|prefix
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|excepts
parameter_list|)
define|\
value|testall_tol(prefix, (x), (result), 0, (excepts))
end_define

begin_define
define|#
directive|define
name|test2_tol
parameter_list|(
name|func
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|tol
parameter_list|,
name|excepts
parameter_list|)
value|do {		\ 	volatile long double _iny = (y), _inx = (x), _out = (result);	\ 	assert(feclearexcept(FE_ALL_EXCEPT) == 0);			\ 	assert(fpequal_tol(func(_iny, _inx), _out, (tol), CS_BOTH));	\ 	assert(((void)func, fetestexcept(ALL_STD_EXCEPT) == (excepts))); \ } while (0)
end_define

begin_define
define|#
directive|define
name|test2
parameter_list|(
name|func
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|excepts
parameter_list|)
define|\
value|test2_tol(func, (y), (x), (result), 0, (excepts))
end_define

begin_define
define|#
directive|define
name|testall2_tol
parameter_list|(
name|prefix
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|tol
parameter_list|,
name|excepts
parameter_list|)
value|do {		\ 	test2_tol(prefix, (double)(y), (double)(x), (double)(result),	\ 		  (tol) * ldexp(1.0, 1 - DBL_MANT_DIG), (excepts));	\ 	test2_tol(prefix##f, (float)(y), (float)(x), (float)(result),	\ 		  (tol) * ldexpf(1.0, 1 - FLT_MANT_DIG), (excepts));	\ 	test2_tol(prefix##l, (y), (x), (result),			\ 		  (tol) * ldexpl(1.0, 1 - LDBL_MANT_DIG), (excepts));	\ } while (0)
end_define

begin_define
define|#
directive|define
name|testall2
parameter_list|(
name|prefix
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|result
parameter_list|,
name|excepts
parameter_list|)
define|\
value|testall2_tol(prefix, (y), (x), (result), 0, (excepts))
end_define

begin_decl_stmt
name|long
name|double
name|pi
init|=
literal|3.14159265358979323846264338327950280e+00L
decl_stmt|,
name|pio3
init|=
literal|1.04719755119659774615421446109316766e+00L
decl_stmt|,
name|c3pi
init|=
literal|9.42477796076937971538793014983850839e+00L
decl_stmt|,
name|c5pi
init|=
literal|1.57079632679489661923132169163975140e+01L
decl_stmt|,
name|c7pi
init|=
literal|2.19911485751285526692385036829565196e+01L
decl_stmt|,
name|c5pio3
init|=
literal|5.23598775598298873077107230546583851e+00L
decl_stmt|,
name|sqrt2m1
init|=
literal|4.14213562373095048801688724209698081e-01L
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Test special case inputs in asin(), acos() and atan(): signed  * zeroes, infinities, and NaNs.  */
end_comment

begin_function
specifier|static
name|void
name|test_special
parameter_list|(
name|void
parameter_list|)
block|{
name|testall
argument_list|(
name|asin
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
literal|0.0
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|asin
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
operator|-
literal|0.0
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|asin
argument_list|,
name|INFINITY
argument_list|,
name|NAN
argument_list|,
name|FE_INVALID
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
name|INFINITY
argument_list|,
name|NAN
argument_list|,
name|FE_INVALID
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
name|INFINITY
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|asin
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|NAN
argument_list|,
name|FE_INVALID
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|NAN
argument_list|,
name|FE_INVALID
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|asin
argument_list|,
name|NAN
argument_list|,
name|NAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
name|NAN
argument_list|,
name|NAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
name|NAN
argument_list|,
name|NAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test special case inputs in atan2(), where the exact value of y/x is  * zero or non-finite.  */
end_comment

begin_function
specifier|static
name|void
name|test_special_atan2
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|double
name|z
decl_stmt|;
name|int
name|e
decl_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|0.0
argument_list|,
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
name|INFINITY
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|c3pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|-
name|c3pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|,
name|pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|INFINITY
argument_list|,
operator|-
name|pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
comment|/* Tests with one input in the range (0, Inf]. */
name|z
operator|=
literal|1.23456789L
expr_stmt|;
for|for
control|(
name|e
operator|=
name|FLT_MIN_EXP
operator|-
name|FLT_MANT_DIG
init|;
name|e
operator|<=
name|FLT_MAX_EXP
condition|;
name|e
operator|++
control|)
block|{
name|test2
argument_list|(
name|atan2f
argument_list|,
literal|0.0
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
literal|0.0
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
literal|0.0
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|float
operator|)
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
literal|0.0
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
operator|(
name|float
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|(
name|float
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|DBL_MIN_EXP
operator|-
name|DBL_MANT_DIG
init|;
name|e
operator|<=
name|DBL_MAX_EXP
condition|;
name|e
operator|++
control|)
block|{
name|test2
argument_list|(
name|atan2
argument_list|,
literal|0.0
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0.0
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
literal|0.0
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0.0
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
operator|(
name|double
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|(
name|double
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|LDBL_MIN_EXP
operator|-
name|LDBL_MANT_DIG
init|;
name|e
operator|<=
name|LDBL_MAX_EXP
condition|;
name|e
operator|++
control|)
block|{
name|test2
argument_list|(
name|atan2l
argument_list|,
literal|0.0
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
literal|0.0
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
literal|0.0
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
literal|0.0
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
literal|0.0
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
comment|/* Tests with one input in the range (0, Inf). */
for|for
control|(
name|e
operator|=
name|FLT_MIN_EXP
operator|-
name|FLT_MANT_DIG
init|;
name|e
operator|<=
name|FLT_MAX_EXP
operator|-
literal|1
condition|;
name|e
operator|++
control|)
block|{
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|INFINITY
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|INFINITY
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|(
name|float
operator|)
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|INFINITY
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|float
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
name|INFINITY
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|float
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|ldexpf
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|ldexpf
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|DBL_MIN_EXP
operator|-
name|DBL_MANT_DIG
init|;
name|e
operator|<=
name|DBL_MAX_EXP
operator|-
literal|1
condition|;
name|e
operator|++
control|)
block|{
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|INFINITY
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|INFINITY
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|(
name|double
operator|)
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|INFINITY
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
name|INFINITY
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|ldexp
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|ldexp
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|LDBL_MIN_EXP
operator|-
name|LDBL_MANT_DIG
init|;
name|e
operator|<=
name|LDBL_MAX_EXP
operator|-
literal|1
condition|;
name|e
operator|++
control|)
block|{
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|INFINITY
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|INFINITY
argument_list|,
operator|-
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|INFINITY
argument_list|,
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|INFINITY
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|INFINITY
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|ldexpl
argument_list|(
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
name|INFINITY
argument_list|,
name|ldexpl
argument_list|(
operator|-
name|z
argument_list|,
name|e
argument_list|)
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Test various inputs to asin(), acos() and atan() and verify that the  * results are accurate to within 1 ulp.  */
end_comment

begin_function
specifier|static
name|void
name|test_accuracy
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We expect correctly rounded results for these basic cases. */
name|testall
argument_list|(
name|asin
argument_list|,
literal|1.0
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
literal|1.0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
literal|1.0
argument_list|,
name|pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|asin
argument_list|,
operator|-
literal|1.0
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
operator|-
literal|1.0
argument_list|,
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
operator|-
literal|1.0
argument_list|,
operator|-
name|pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
comment|/* 	 * Here we expect answers to be within 1 ulp, although inexactness 	 * in the input, combined with double rounding, could cause larger 	 * errors. 	 */
name|testall_tol
argument_list|(
name|asin
argument_list|,
name|sqrtl
argument_list|(
literal|2
argument_list|)
operator|/
literal|2
argument_list|,
name|pi
operator|/
literal|4
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|acos
argument_list|,
name|sqrtl
argument_list|(
literal|2
argument_list|)
operator|/
literal|2
argument_list|,
name|pi
operator|/
literal|4
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|asin
argument_list|,
operator|-
name|sqrtl
argument_list|(
literal|2
argument_list|)
operator|/
literal|2
argument_list|,
operator|-
name|pi
operator|/
literal|4
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|acos
argument_list|,
operator|-
name|sqrtl
argument_list|(
literal|2
argument_list|)
operator|/
literal|2
argument_list|,
name|c3pi
operator|/
literal|4
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|asin
argument_list|,
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|/
literal|2
argument_list|,
name|pio3
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|acos
argument_list|,
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|/
literal|2
argument_list|,
name|pio3
operator|/
literal|2
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|atan
argument_list|,
name|sqrtl
argument_list|(
literal|3
argument_list|)
argument_list|,
name|pio3
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|asin
argument_list|,
operator|-
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|/
literal|2
argument_list|,
operator|-
name|pio3
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|acos
argument_list|,
operator|-
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|/
literal|2
argument_list|,
name|c5pio3
operator|/
literal|2
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|atan
argument_list|,
operator|-
name|sqrtl
argument_list|(
literal|3
argument_list|)
argument_list|,
operator|-
name|pio3
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|atan
argument_list|,
name|sqrt2m1
argument_list|,
name|pi
operator|/
literal|8
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|atan
argument_list|,
operator|-
name|sqrt2m1
argument_list|,
operator|-
name|pi
operator|/
literal|8
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test inputs to atan2() where x is a power of 2. These are easy cases  * because y/x is exact.  */
end_comment

begin_function
specifier|static
name|void
name|test_p2x_atan2
parameter_list|(
name|void
parameter_list|)
block|{
name|testall2
argument_list|(
name|atan2
argument_list|,
literal|1.0
argument_list|,
literal|1.0
argument_list|,
name|pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|,
name|c3pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|1.0
argument_list|,
literal|1.0
argument_list|,
operator|-
name|pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|,
operator|-
name|c3pi
operator|/
literal|4
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
name|sqrt2m1
operator|*
literal|2
argument_list|,
literal|2.0
argument_list|,
name|pi
operator|/
literal|8
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
name|sqrt2m1
operator|*
literal|2
argument_list|,
operator|-
literal|2.0
argument_list|,
name|c7pi
operator|/
literal|8
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
operator|-
name|sqrt2m1
operator|*
literal|2
argument_list|,
literal|2.0
argument_list|,
operator|-
name|pi
operator|/
literal|8
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
operator|-
name|sqrt2m1
operator|*
literal|2
argument_list|,
operator|-
literal|2.0
argument_list|,
operator|-
name|c7pi
operator|/
literal|8
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|*
literal|0.5
argument_list|,
literal|0.5
argument_list|,
name|pio3
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|*
literal|0.5
argument_list|,
operator|-
literal|0.5
argument_list|,
name|pio3
operator|*
literal|2
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
operator|-
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|*
literal|0.5
argument_list|,
literal|0.5
argument_list|,
operator|-
name|pio3
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall2_tol
argument_list|(
name|atan2
argument_list|,
operator|-
name|sqrtl
argument_list|(
literal|3
argument_list|)
operator|*
literal|0.5
argument_list|,
operator|-
literal|0.5
argument_list|,
operator|-
name|pio3
operator|*
literal|2
argument_list|,
literal|1
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test inputs very close to 0.  */
end_comment

begin_function
specifier|static
name|void
name|test_tiny
parameter_list|(
name|void
parameter_list|)
block|{
name|float
name|tiny
init|=
literal|0x1
literal|.23456p
operator|-
literal|120f
decl_stmt|;
name|testall
argument_list|(
name|asin
argument_list|,
name|tiny
argument_list|,
name|tiny
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
name|tiny
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
name|tiny
argument_list|,
name|tiny
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|asin
argument_list|,
operator|-
name|tiny
argument_list|,
operator|-
name|tiny
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|acos
argument_list|,
operator|-
name|tiny
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
operator|-
name|tiny
argument_list|,
operator|-
name|tiny
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
comment|/* Test inputs to atan2() that would cause y/x to underflow. */
name|test2
argument_list|(
name|atan2f
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
literal|0x1
literal|.0p100
argument_list|,
literal|0.0
argument_list|,
name|FE_INEXACT
operator||
name|FE_UNDERFLOW
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
literal|0x1
literal|.0p1000
argument_list|,
literal|0.0
argument_list|,
name|FE_INEXACT
operator||
name|FE_UNDERFLOW
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
literal|0.0
argument_list|,
name|FE_INEXACT
operator||
name|FE_UNDERFLOW
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
literal|0x1
literal|.0p100
argument_list|,
operator|-
literal|0.0
argument_list|,
name|FE_INEXACT
operator||
name|FE_UNDERFLOW
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
literal|0x1
literal|.0p1000
argument_list|,
operator|-
literal|0.0
argument_list|,
name|FE_INEXACT
operator||
name|FE_UNDERFLOW
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
operator|-
literal|0.0
argument_list|,
name|FE_INEXACT
operator||
name|FE_UNDERFLOW
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
operator|-
literal|0x1
literal|.0p100
argument_list|,
operator|(
name|float
operator|)
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
operator|-
literal|0x1
literal|.0p1000
argument_list|,
operator|(
name|double
operator|)
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
operator|-
literal|0x1
literal|.0p100
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
operator|-
literal|0x1
literal|.0p1000
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
operator|-
name|pi
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test very large inputs to atan().  */
end_comment

begin_function
specifier|static
name|void
name|test_atan_huge
parameter_list|(
name|void
parameter_list|)
block|{
name|float
name|huge
init|=
literal|0x1
literal|.23456p120
decl_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
name|huge
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall
argument_list|(
name|atan
argument_list|,
operator|-
name|huge
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
comment|/* Test inputs to atan2() that would cause y/x to overflow. */
name|test2
argument_list|(
name|atan2f
argument_list|,
literal|0x1
literal|.0p100
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
operator|(
name|float
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
literal|0x1
literal|.0p1000
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
operator|(
name|double
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
literal|0x1
literal|.0p100
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0x1
literal|.0p1000
argument_list|,
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
literal|0x1
literal|.0p100
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
operator|(
name|float
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
literal|0x1
literal|.0p1000
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
operator|(
name|double
operator|)
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2f
argument_list|,
operator|-
literal|0x1
literal|.0p100
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|100
argument_list|,
operator|(
name|float
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2
argument_list|,
operator|-
literal|0x1
literal|.0p1000
argument_list|,
operator|-
literal|0x1
literal|.0p
operator|-
literal|1000
argument_list|,
operator|(
name|double
operator|)
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|test2
argument_list|(
name|atan2l
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
name|LDBL_MAX_EXP
operator|-
literal|100
argument_list|)
argument_list|,
operator|-
name|ldexpl
argument_list|(
literal|1.0
argument_list|,
literal|100
operator|-
name|LDBL_MAX_EXP
argument_list|)
argument_list|,
operator|-
name|pi
operator|/
literal|2
argument_list|,
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test that sin(asin(x)) == x, and similarly for acos() and atan().  * You need to have a working sinl(), cosl(), and tanl() for these  * tests to pass.  */
end_comment

begin_function
specifier|static
name|long
name|double
name|sinasinf
parameter_list|(
name|float
name|x
parameter_list|)
block|{
return|return
operator|(
name|sinl
argument_list|(
name|asinf
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|sinasin
parameter_list|(
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|sinl
argument_list|(
name|asin
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|sinasinl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|sinl
argument_list|(
name|asinl
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|cosacosf
parameter_list|(
name|float
name|x
parameter_list|)
block|{
return|return
operator|(
name|cosl
argument_list|(
name|acosf
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|cosacos
parameter_list|(
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|cosl
argument_list|(
name|acos
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|cosacosl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|cosl
argument_list|(
name|acosl
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|tanatanf
parameter_list|(
name|float
name|x
parameter_list|)
block|{
return|return
operator|(
name|tanl
argument_list|(
name|atanf
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|tanatan
parameter_list|(
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|tanl
argument_list|(
name|atan
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|tanatanl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|tanl
argument_list|(
name|atanl
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_inverse
parameter_list|(
name|void
parameter_list|)
block|{
name|float
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<=
literal|1
condition|;
name|i
operator|+=
literal|0x1
literal|.0p
operator|-
literal|12f
control|)
block|{
name|testall_tol
argument_list|(
name|sinasin
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|2
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|0
else|:
name|FE_INEXACT
argument_list|)
expr_stmt|;
comment|/* The relative error for cosacos is very large near x=0. */
if|if
condition|(
name|fabsf
argument_list|(
name|i
argument_list|)
operator|>
literal|0x1
literal|.0p
operator|-
literal|4f
condition|)
name|testall_tol
argument_list|(
name|cosacos
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|16
argument_list|,
name|i
operator|==
literal|1
condition|?
literal|0
else|:
name|FE_INEXACT
argument_list|)
expr_stmt|;
name|testall_tol
argument_list|(
name|tanatan
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|2
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|0
else|:
name|FE_INEXACT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|printf
argument_list|(
literal|"1..7\n"
argument_list|)
expr_stmt|;
name|test_special
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ok 1 - special\n"
argument_list|)
expr_stmt|;
name|test_special_atan2
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ok 2 - atan2 special\n"
argument_list|)
expr_stmt|;
name|test_accuracy
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ok 3 - accuracy\n"
argument_list|)
expr_stmt|;
name|test_p2x_atan2
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ok 4 - atan2 p2x\n"
argument_list|)
expr_stmt|;
name|test_tiny
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ok 5 - tiny inputs\n"
argument_list|)
expr_stmt|;
name|test_atan_huge
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ok 6 - atan huge inputs\n"
argument_list|)
expr_stmt|;
name|test_inverse
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"ok 7 - inverse\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

