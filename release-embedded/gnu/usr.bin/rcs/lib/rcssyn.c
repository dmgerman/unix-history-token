begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RCS file syntactic analysis */
end_comment

begin_comment
comment|/******************************************************************************  *                       Syntax Analysis.  *                       Keyword table  *                       Testprogram: define SYNTEST  *                       Compatibility with Release 2: define COMPAT2=1  ******************************************************************************  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.15  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.14  1995/06/01 16:23:43  eggert  * (expand_names): Add "b" for -kb.  * (getdelta): Don't strip leading "19" from MKS RCS dates; see cmpdate.  *  * Revision 5.13  1994/03/20 04:52:58  eggert  * Remove lint.  *  * Revision 5.12  1993/11/03 17:42:27  eggert  * Parse MKS RCS dates; ignore \r in diff control lines.  * Don't discard ignored phrases.  Improve quality of diagnostics.  *  * Revision 5.11  1992/07/28  16:12:44  eggert  * Avoid `unsigned'.  Statement macro names now end in _.  *  * Revision 5.10  1992/01/24  18:44:19  eggert  * Move put routines to rcsgen.c.  *  * Revision 5.9  1992/01/06  02:42:34  eggert  * ULONG_MAX/10 -> ULONG_MAX_OVER_10  * while (E) ; -> while (E) continue;  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Tune.  *  * Revision 5.7  1991/04/21  11:58:29  eggert  * Disambiguate names on shortname hosts.  * Fix errno bug.  Add MS-DOS support.  *  * Revision 5.6  1991/02/28  19:18:51  eggert  * Fix null termination bug in reporting keyword expansion.  *  * Revision 5.5  1991/02/25  07:12:44  eggert  * Check diff output more carefully; avoid overflow.  *  * Revision 5.4  1990/11/01  05:28:48  eggert  * When ignoring unknown phrases, copy them to the output RCS file.  * Permit arbitrary data in logs and comment leaders.  * Don't check for nontext on initial checkin.  *  * Revision 5.3  1990/09/20  07:58:32  eggert  * Remove the test for non-text bytes; it caused more pain than it cured.  *  * Revision 5.2  1990/09/04  08:02:30  eggert  * Parse RCS files with no revisions.  * Don't strip leading white space from diff commands.  Count RCS lines better.  *  * Revision 5.1  1990/08/29  07:14:06  eggert  * Add -kkvl.  Clean old log messages too.  *  * Revision 5.0  1990/08/22  08:13:44  eggert  * Try to parse future RCS formats without barfing.  * Add -k.  Don't require final newline.  * Remove compile-time limits; use malloc instead.  * Don't output branch keyword if there's no default branch,  * because RCS version 3 doesn't understand it.  * Tune.  Remove lint.  * Add support for ISO 8859.  Ansify and Posixate.  * Check that a newly checked-in file is acceptable as input to 'diff'.  * Check diff's output.  *  * Revision 4.6  89/05/01  15:13:32  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.5  88/08/09  19:13:21  eggert  * Allow cc -R; remove lint.  *  * Revision 4.4  87/12/18  11:46:16  narten  * more lint cleanups (Guy Harris)  *  * Revision 4.3  87/10/18  10:39:36  narten  * Updating version numbers. Changes relative to 1.1 actually relative to  * 4.1  *  * Revision 1.3  87/09/24  14:00:49  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:40  jenkins  * Port to suns  *  * Revision 4.1  83/03/28  11:38:49  wft  * Added parsing and printing of default branch.  *  * Revision 3.6  83/01/15  17:46:50  wft  * Changed readdelta() to initialize selector and log-pointer.  * Changed puttree to check for selector==DELETE; putdtext() uses DELNUMFORM.  *  * Revision 3.5  82/12/08  21:58:58  wft  * renamed Commentleader to Commleader.  *  * Revision 3.4  82/12/04  13:24:40  wft  * Added routine gettree(), which updates keeplock after reading the  * delta tree.  *  * Revision 3.3  82/11/28  21:30:11  wft  * Reading and printing of Suffix removed; version COMPAT2 skips the  * Suffix for files of release 2 format. Fixed problems with printing nil.  *  * Revision 3.2  82/10/18  21:18:25  wft  * renamed putdeltatext to putdtext.  *  * Revision 3.1  82/10/11  19:45:11  wft  * made sure getc() returns into an integer.  */
end_comment

begin_comment
comment|/* version COMPAT2 reads files of the format of release 2 and 3, but  * generates files of release 3 format. Need not be defined if no  * old RCS files generated with release 2 exist.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|synId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|getkeyval
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|enum
name|tokens
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getdelta
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strn2expmode
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|getdnum
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|badDiffOutput
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
name|exiting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|diffLineNumberTooLarge
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
name|exiting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getsemi
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyword table */
end_comment

begin_decl_stmt
name|char
specifier|const
name|Kaccess
index|[]
init|=
literal|"access"
decl_stmt|,
name|Kauthor
index|[]
init|=
literal|"author"
decl_stmt|,
name|Kbranch
index|[]
init|=
literal|"branch"
decl_stmt|,
name|Kcomment
index|[]
init|=
literal|"comment"
decl_stmt|,
name|Kdate
index|[]
init|=
literal|"date"
decl_stmt|,
name|Kdesc
index|[]
init|=
literal|"desc"
decl_stmt|,
name|Kexpand
index|[]
init|=
literal|"expand"
decl_stmt|,
name|Khead
index|[]
init|=
literal|"head"
decl_stmt|,
name|Klocks
index|[]
init|=
literal|"locks"
decl_stmt|,
name|Klog
index|[]
init|=
literal|"log"
decl_stmt|,
name|Knext
index|[]
init|=
literal|"next"
decl_stmt|,
name|Kstate
index|[]
init|=
literal|"state"
decl_stmt|,
name|Kstrict
index|[]
init|=
literal|"strict"
decl_stmt|,
name|Ksymbols
index|[]
init|=
literal|"symbols"
decl_stmt|,
name|Ktext
index|[]
init|=
literal|"text"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
if|#
directive|if
name|COMPAT2
name|Ksuffix
index|[]
init|=
literal|"suffix"
decl_stmt|,
endif|#
directive|endif
name|K_branches
index|[]
init|=
literal|"branches"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
name|Commleader
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cbuf
name|Comment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cbuf
name|Ignored
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|access
modifier|*
name|AccessList
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|assoc
modifier|*
name|Symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rcslock
modifier|*
name|Locks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Expand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|StrictLocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|Head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|Dbranch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TotalDeltas
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|getsemi
parameter_list|(
name|key
parameter_list|)
name|char
specifier|const
modifier|*
name|key
decl_stmt|;
comment|/* Get a semicolon to finish off a phrase started by KEY.  */
block|{
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|SEMI
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"missing ';' after '%s'"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hshentry
modifier|*
name|getdnum
parameter_list|()
comment|/* Get a delta number.  */
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|delta
init|=
name|getnum
argument_list|()
decl_stmt|;
if|if
condition|(
name|delta
operator|&&
name|countnumflds
argument_list|(
name|delta
operator|->
name|num
argument_list|)
operator|&
literal|1
condition|)
name|fatserror
argument_list|(
literal|"%s isn't a delta number"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
end_function

begin_function
name|void
name|getadmin
parameter_list|()
comment|/* Read an<admin> and initialize the appropriate global variables.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|id
decl_stmt|;
name|struct
name|access
modifier|*
name|newaccess
decl_stmt|;
name|struct
name|assoc
modifier|*
name|newassoc
decl_stmt|;
name|struct
name|rcslock
modifier|*
name|newlock
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|struct
name|access
modifier|*
modifier|*
name|LastAccess
decl_stmt|;
name|struct
name|assoc
modifier|*
modifier|*
name|LastSymbol
decl_stmt|;
name|struct
name|rcslock
modifier|*
modifier|*
name|LastLock
decl_stmt|;
name|struct
name|buf
name|b
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
name|TotalDeltas
operator|=
literal|0
expr_stmt|;
name|getkey
argument_list|(
name|Khead
argument_list|)
expr_stmt|;
name|Head
operator|=
name|getdnum
argument_list|()
expr_stmt|;
name|getsemi
argument_list|(
name|Khead
argument_list|)
expr_stmt|;
name|Dbranch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getkeyopt
argument_list|(
name|Kbranch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
name|Dbranch
operator|=
name|delta
operator|->
name|num
expr_stmt|;
name|getsemi
argument_list|(
name|Kbranch
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|COMPAT2
comment|/* read suffix. Only in release 2 format */
if|if
condition|(
name|getkeyopt
argument_list|(
name|Ksuffix
argument_list|)
condition|)
block|{
if|if
condition|(
name|nexttok
operator|==
name|STRING
condition|)
block|{
name|readstring
argument_list|()
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
comment|/* Throw away the suffix.  */
block|}
elseif|else
if|if
condition|(
name|nexttok
operator|==
name|ID
condition|)
block|{
name|nextlex
argument_list|()
expr_stmt|;
block|}
name|getsemi
argument_list|(
name|Ksuffix
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|getkey
argument_list|(
name|Kaccess
argument_list|)
expr_stmt|;
name|LastAccess
operator|=
operator|&
name|AccessList
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|getid
argument_list|()
operator|)
condition|)
block|{
name|newaccess
operator|=
name|ftalloc
argument_list|(
expr|struct
name|access
argument_list|)
expr_stmt|;
name|newaccess
operator|->
name|login
operator|=
name|id
expr_stmt|;
operator|*
name|LastAccess
operator|=
name|newaccess
expr_stmt|;
name|LastAccess
operator|=
operator|&
name|newaccess
operator|->
name|nextaccess
expr_stmt|;
block|}
operator|*
name|LastAccess
operator|=
literal|0
expr_stmt|;
name|getsemi
argument_list|(
name|Kaccess
argument_list|)
expr_stmt|;
name|getkey
argument_list|(
name|Ksymbols
argument_list|)
expr_stmt|;
name|LastSymbol
operator|=
operator|&
name|Symbols
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|getid
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|COLON
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"missing ':' in symbolic name definition"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
name|fatserror
argument_list|(
literal|"missing number in symbolic name definition"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*add new pair to association list*/
name|newassoc
operator|=
name|ftalloc
argument_list|(
expr|struct
name|assoc
argument_list|)
expr_stmt|;
name|newassoc
operator|->
name|symbol
operator|=
name|id
expr_stmt|;
name|newassoc
operator|->
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
operator|*
name|LastSymbol
operator|=
name|newassoc
expr_stmt|;
name|LastSymbol
operator|=
operator|&
name|newassoc
operator|->
name|nextassoc
expr_stmt|;
block|}
block|}
operator|*
name|LastSymbol
operator|=
literal|0
expr_stmt|;
name|getsemi
argument_list|(
name|Ksymbols
argument_list|)
expr_stmt|;
name|getkey
argument_list|(
name|Klocks
argument_list|)
expr_stmt|;
name|LastLock
operator|=
operator|&
name|Locks
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|getid
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|getlex
argument_list|(
name|COLON
argument_list|)
condition|)
name|fatserror
argument_list|(
literal|"missing ':' in lock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|delta
operator|=
name|getdnum
argument_list|()
operator|)
condition|)
block|{
name|fatserror
argument_list|(
literal|"missing number in lock"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*add new pair to lock list*/
name|newlock
operator|=
name|ftalloc
argument_list|(
expr|struct
name|rcslock
argument_list|)
expr_stmt|;
name|newlock
operator|->
name|login
operator|=
name|id
expr_stmt|;
name|newlock
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
operator|*
name|LastLock
operator|=
name|newlock
expr_stmt|;
name|LastLock
operator|=
operator|&
name|newlock
operator|->
name|nextlock
expr_stmt|;
block|}
block|}
operator|*
name|LastLock
operator|=
literal|0
expr_stmt|;
name|getsemi
argument_list|(
name|Klocks
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|StrictLocks
operator|=
name|getkeyopt
argument_list|(
name|Kstrict
argument_list|)
operator|)
condition|)
name|getsemi
argument_list|(
name|Kstrict
argument_list|)
expr_stmt|;
name|clear_buf
argument_list|(
operator|&
name|Comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|getkeyopt
argument_list|(
name|Kcomment
argument_list|)
condition|)
block|{
if|if
condition|(
name|nexttok
operator|==
name|STRING
condition|)
block|{
name|Comment
operator|=
name|savestring
argument_list|(
operator|&
name|Commleader
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
block|}
name|getsemi
argument_list|(
name|Kcomment
argument_list|)
expr_stmt|;
block|}
name|Expand
operator|=
name|KEYVAL_EXPAND
expr_stmt|;
if|if
condition|(
name|getkeyopt
argument_list|(
name|Kexpand
argument_list|)
condition|)
block|{
if|if
condition|(
name|nexttok
operator|==
name|STRING
condition|)
block|{
name|bufautobegin
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|cb
operator|=
name|savestring
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Expand
operator|=
name|strn2expmode
argument_list|(
name|cb
operator|.
name|string
argument_list|,
name|cb
operator|.
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatserror
argument_list|(
literal|"unknown expand mode %.*s"
argument_list|,
operator|(
name|int
operator|)
name|cb
operator|.
name|size
argument_list|,
name|cb
operator|.
name|string
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
block|}
name|getsemi
argument_list|(
name|Kexpand
argument_list|)
expr_stmt|;
block|}
name|Ignored
operator|=
name|getphrases
argument_list|(
name|Kdesc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
specifier|const
modifier|*
specifier|const
name|expand_names
index|[]
init|=
block|{
comment|/* These must agree with *_EXPAND in rcsbase.h.  */
literal|"kv"
block|,
literal|"kvl"
block|,
literal|"k"
block|,
literal|"v"
block|,
literal|"o"
block|,
literal|"b"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|str2expmode
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Yield expand mode corresponding to S, or -1 if bad.  */
block|{
return|return
name|strn2expmode
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strn2expmode
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|expand_names
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|memcmp
argument_list|(
operator|*
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
operator|*
name|p
operator|)
index|[
name|n
index|]
condition|)
return|return
name|p
operator|-
name|expand_names
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ignorephrases
parameter_list|(
name|key
parameter_list|)
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
comment|/* * Ignore a series of phrases that do not start with KEY. * Stop when the next phrase starts with a token that is not an identifier, * or is KEY. */
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
name|nexttok
operator|!=
name|ID
operator|||
name|strcmp
argument_list|(
name|NextString
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|warnignore
argument_list|()
expr_stmt|;
name|hshenter
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
name|nextlex
argument_list|()
control|)
block|{
switch|switch
condition|(
name|nexttok
condition|)
block|{
case|case
name|SEMI
case|:
name|hshenter
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|ID
case|:
case|case
name|NUM
case|:
name|ffree1
argument_list|(
name|NextString
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|STRING
case|:
name|readstring
argument_list|()
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|getdelta
parameter_list|()
comment|/* Function: reads a delta block.  * returns false if the current block does not start with a number.  */
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|,
modifier|*
name|num
decl_stmt|;
name|struct
name|branchhead
modifier|*
modifier|*
name|LastBranch
decl_stmt|,
modifier|*
name|NewBranch
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Delta
operator|=
name|getdnum
argument_list|()
operator|)
condition|)
return|return
name|false
return|;
name|hshenter
operator|=
name|false
expr_stmt|;
comment|/*Don't enter dates into hashtable*/
name|Delta
operator|->
name|date
operator|=
name|getkeyval
argument_list|(
name|Kdate
argument_list|,
name|NUM
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|hshenter
operator|=
name|true
expr_stmt|;
comment|/*reset hshenter for revision numbers.*/
name|Delta
operator|->
name|author
operator|=
name|getkeyval
argument_list|(
name|Kauthor
argument_list|,
name|ID
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|state
operator|=
name|getkeyval
argument_list|(
name|Kstate
argument_list|,
name|ID
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|getkey
argument_list|(
name|K_branches
argument_list|)
expr_stmt|;
name|LastBranch
operator|=
operator|&
name|Delta
operator|->
name|branches
expr_stmt|;
while|while
condition|(
operator|(
name|num
operator|=
name|getdnum
argument_list|()
operator|)
condition|)
block|{
name|NewBranch
operator|=
name|ftalloc
argument_list|(
expr|struct
name|branchhead
argument_list|)
expr_stmt|;
name|NewBranch
operator|->
name|hsh
operator|=
name|num
expr_stmt|;
operator|*
name|LastBranch
operator|=
name|NewBranch
expr_stmt|;
name|LastBranch
operator|=
operator|&
name|NewBranch
operator|->
name|nextbranch
expr_stmt|;
block|}
operator|*
name|LastBranch
operator|=
literal|0
expr_stmt|;
name|getsemi
argument_list|(
name|K_branches
argument_list|)
expr_stmt|;
name|getkey
argument_list|(
name|Knext
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|next
operator|=
name|num
operator|=
name|getdnum
argument_list|()
expr_stmt|;
name|getsemi
argument_list|(
name|Knext
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|lockedby
operator|=
literal|0
expr_stmt|;
name|Delta
operator|->
name|log
operator|.
name|string
operator|=
literal|0
expr_stmt|;
name|Delta
operator|->
name|selector
operator|=
name|true
expr_stmt|;
name|Delta
operator|->
name|ig
operator|=
name|getphrases
argument_list|(
name|Kdesc
argument_list|)
expr_stmt|;
name|TotalDeltas
operator|++
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gettree
parameter_list|()
comment|/* Function: Reads in the delta tree with getdelta(), then  * updates the lockedby fields.  */
block|{
name|struct
name|rcslock
specifier|const
modifier|*
name|currlock
decl_stmt|;
while|while
condition|(
name|getdelta
argument_list|()
condition|)
continue|continue;
name|currlock
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|currlock
condition|)
block|{
name|currlock
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|currlock
operator|->
name|login
expr_stmt|;
name|currlock
operator|=
name|currlock
operator|->
name|nextlock
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|getdesc
parameter_list|(
name|prdesc
parameter_list|)
name|int
name|prdesc
decl_stmt|;
comment|/* Function: read in descriptive text  * nexttok is not advanced afterwards.  * If prdesc is set, the text is printed to stdout.  */
block|{
name|getkeystring
argument_list|(
name|Kdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prdesc
condition|)
name|printstring
argument_list|()
expr_stmt|;
comment|/*echo string*/
else|else
name|readstring
argument_list|()
expr_stmt|;
comment|/*skip string*/
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|getkeyval
parameter_list|(
name|keyword
parameter_list|,
name|token
parameter_list|,
name|optional
parameter_list|)
name|char
specifier|const
modifier|*
name|keyword
decl_stmt|;
name|enum
name|tokens
name|token
decl_stmt|;
name|int
name|optional
decl_stmt|;
comment|/* reads a pair of the form  *<keyword><token> ;  * where token is one of<id> or<num>. optional indicates whether  *<token> is optional. A pointer to  * the actual character string of<id> or<num> is returned.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|val
init|=
literal|0
decl_stmt|;
name|getkey
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|token
condition|)
block|{
name|val
operator|=
name|NextString
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|optional
condition|)
name|fatserror
argument_list|(
literal|"missing %s"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
block|}
name|getsemi
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|unexpected_EOF
parameter_list|()
block|{
name|rcsfaterror
argument_list|(
literal|"unexpected EOF in diff output"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initdiffcmd
parameter_list|(
name|dc
parameter_list|)
specifier|register
name|struct
name|diffcmd
modifier|*
name|dc
decl_stmt|;
comment|/* Initialize *dc suitably for getdiffcmd(). */
block|{
name|dc
operator|->
name|adprev
operator|=
literal|0
expr_stmt|;
name|dc
operator|->
name|dafter
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|badDiffOutput
parameter_list|(
name|buf
parameter_list|)
name|char
specifier|const
modifier|*
name|buf
decl_stmt|;
block|{
name|rcsfaterror
argument_list|(
literal|"bad diff output line: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|diffLineNumberTooLarge
parameter_list|(
name|buf
parameter_list|)
name|char
specifier|const
modifier|*
name|buf
decl_stmt|;
block|{
name|rcsfaterror
argument_list|(
literal|"diff line number too large: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|getdiffcmd
parameter_list|(
name|finfile
parameter_list|,
name|delimiter
parameter_list|,
name|foutfile
parameter_list|,
name|dc
parameter_list|)
name|RILE
modifier|*
name|finfile
decl_stmt|;
name|FILE
modifier|*
name|foutfile
decl_stmt|;
name|int
name|delimiter
decl_stmt|;
name|struct
name|diffcmd
modifier|*
name|dc
decl_stmt|;
comment|/* Get a editing command output by 'diff -n' from fin.  * The input is delimited by SDELIM if delimiter is set, EOF otherwise.  * Copy a clean version of the command to fout (if nonnull).  * Yield 0 for 'd', 1 for 'a', and -1 for EOF.  * Store the command's line number and length into dc->line1 and dc->nlines.  * Keep dc->adprev and dc->dafter up to date.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|long
name|line1
decl_stmt|,
name|nlines
decl_stmt|,
name|t
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fin
operator|=
name|finfile
expr_stmt|;
name|fout
operator|=
name|foutfile
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|{ if (delimiter) unexpected_EOF(); return -
literal|1
argument|; }
argument_list|)
if|if
condition|(
name|delimiter
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
name|cacheget_
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|badDiffOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|fout
condition|)
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%c%c"
argument_list|,
name|SDELIM
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|p
operator|=
name|buf
expr_stmt|;
do|do
block|{
if|if
condition|(
name|buf
operator|+
name|BUFSIZ
operator|-
literal|2
operator|<=
name|p
condition|)
block|{
name|rcsfaterror
argument_list|(
literal|"diff output command line too long"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|unexpected_EOF();
argument_list|)
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|delimiter
condition|)
operator|++
name|rcsline
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
operator|+
literal|1
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|' '
condition|;
control|)
continue|continue;
name|line1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|LONG_MAX
operator|/
literal|10
operator|<
name|line1
operator|||
operator|(
name|t
operator|=
name|line1
operator|*
literal|10
operator|,
operator|(
name|line1
operator|=
name|t
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|)
operator|<
name|t
operator|)
condition|)
name|diffLineNumberTooLarge
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|nlines
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|LONG_MAX
operator|/
literal|10
operator|<
name|nlines
operator|||
operator|(
name|t
operator|=
name|nlines
operator|*
literal|10
operator|,
operator|(
name|nlines
operator|=
name|t
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|)
operator|<
name|t
operator|)
condition|)
name|diffLineNumberTooLarge
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|||
operator|!
name|nlines
condition|)
block|{
name|badDiffOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line1
operator|+
name|nlines
operator|<
name|line1
condition|)
name|diffLineNumberTooLarge
argument_list|(
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|line1
operator|<
name|dc
operator|->
name|adprev
condition|)
block|{
name|rcsfaterror
argument_list|(
literal|"backward insertion in diff output: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|dc
operator|->
name|adprev
operator|=
name|line1
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|line1
operator|<
name|dc
operator|->
name|adprev
operator|||
name|line1
operator|<
name|dc
operator|->
name|dafter
condition|)
block|{
name|rcsfaterror
argument_list|(
literal|"backward deletion in diff output: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|dc
operator|->
name|adprev
operator|=
name|line1
expr_stmt|;
name|dc
operator|->
name|dafter
operator|=
name|line1
operator|+
name|nlines
expr_stmt|;
break|break;
default|default:
name|badDiffOutput
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fout
condition|)
block|{
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|dc
operator|->
name|line1
operator|=
name|line1
expr_stmt|;
name|dc
operator|->
name|nlines
operator|=
name|nlines
expr_stmt|;
return|return
name|buf
index|[
literal|0
index|]
operator|==
literal|'a'
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYNTEST
end_ifdef

begin_comment
comment|/* Input an RCS file and print its internal data structures.  */
end_comment

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|"syntest"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|aputs
argument_list|(
literal|"No input file\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|finptr
operator|=
name|Iopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|FOPEN_R
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"can't open input file %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
name|fdlock
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|putadmin
argument_list|()
expr_stmt|;
name|gettree
argument_list|()
expr_stmt|;
name|getdesc
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|eoflex
argument_list|()
condition|)
block|{
name|fatserror
argument_list|(
literal|"expecting EOF"
argument_list|)
expr_stmt|;
block|}
name|exitmain
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

