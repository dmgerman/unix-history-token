begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print log messages and other information about RCS files.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.18  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.17  1995/06/01 16:23:43  eggert  * (struct rcslockers): Renamed from `struct lockers'.  * (getnumericrev): Return error indication instead of ignoring errors.  * (main): Check it.  Don't use dateform.  * (recentdate, extdate): cmpnum -> cmpdate  *  * Revision 5.16  1994/04/13 16:30:34  eggert  * Fix bug; `rlog -lxxx' inverted the sense of -l.  *  * Revision 5.15  1994/03/17 14:05:48  eggert  * -d'<DATE' now excludes DATE; the new syntax -d'<=DATE' includes it.  * Emulate -V4's white space generation more precisely.  * Work around SVR4 stdio performance bug.  Remove lint.  *  * Revision 5.14  1993/11/09 17:40:15  eggert  * -V now prints version on stdout and exits.  *  * Revision 5.13  1993/11/03 17:42:27  eggert  * Add -N, -z.  Ignore -T.  *  * Revision 5.12  1992/07/28  16:12:44  eggert  * Don't miss B.0 when handling branch B.  Diagnose missing `,' in -r.  * Add -V.  Avoid `unsigned'.  Statement macro names now end in _.  *  * Revision 5.11  1992/01/24  18:44:19  eggert  * Don't duplicate unexpected_EOF's function.  lint -> RCS_lint  *  * Revision 5.10  1992/01/06  02:42:34  eggert  * Update usage string.  * while (E) ; -> while (E) continue;  *  * Revision 5.9  1991/09/17  19:07:40  eggert  * Getscript() didn't uncache partial lines.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Revision separator is `:', not `-'.  * Check for missing and duplicate logs.  Tune.  * Permit log messages that do not end in newline (including empty logs).  *  * Revision 5.7  1991/04/21  11:58:31  eggert  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.6  1991/02/26  17:07:17  eggert  * Survive RCS files with missing logs.  * strsave -> str_save (DG/UX name clash)  *  * Revision 5.5  1990/11/01  05:03:55  eggert  * Permit arbitrary data in logs and comment leaders.  *  * Revision 5.4  1990/10/04  06:30:22  eggert  * Accumulate exit status across files.  *  * Revision 5.3  1990/09/11  02:41:16  eggert  * Plug memory leak.  *  * Revision 5.2  1990/09/04  08:02:33  eggert  * Count RCS lines better.  *  * Revision 5.0  1990/08/22  08:13:48  eggert  * Remove compile-time limits; use malloc instead.  Add setuid support.  * Switch to GMT.  * Report dates in long form, to warn about dates past 1999/12/31.  * Change "added/del" message to make room for the longer dates.  * Don't generate trailing white space.  Add -V.  Ansify and Posixate.  *  * Revision 4.7  89/05/01  15:13:48  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.6  88/08/09  19:13:28  eggert  * Check for memory exhaustion; don't access freed storage.  * Shrink stdio code size; remove lint.  *  * Revision 4.5  87/12/18  11:46:38  narten  * more lint cleanups (Guy Harris)  *  * Revision 4.4  87/10/18  10:41:12  narten  * Updating version numbers  * Changes relative to 1.1 actually relative to 4.2  *  * Revision 1.3  87/09/24  14:01:10  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:45  jenkins  * Port to suns  *  * Revision 4.2  83/12/05  09:18:09  wft  * changed rewriteflag to external.  *  * Revision 4.1  83/05/11  16:16:55  wft  * Added -b, updated getnumericrev() accordingly.  * Replaced getpwuid() with getcaller().  *  * Revision 3.7  83/05/11  14:24:13  wft  * Added options -L and -R;  * Fixed selection bug with -l on multiple files.  * Fixed error on dates of the form -d'>date' (rewrote getdatepair()).  *  * Revision 3.6  82/12/24  15:57:53  wft  * shortened output format.  *  * Revision 3.5  82/12/08  21:45:26  wft  * removed call to checkaccesslist(); used DATEFORM to format all dates;  * removed unused variables.  *  * Revision 3.4  82/12/04  13:26:25  wft  * Replaced getdelta() with gettree(); removed updating of field lockedby.  *  * Revision 3.3  82/12/03  14:08:20  wft  * Replaced getlogin with getpwuid(), %02d with %.2d, fancydate with PRINTDATE.  * Fixed printing of nil, removed printing of Suffix,  * added shortcut if no revisions are printed, disambiguated struct members.  *  * Revision 3.2  82/10/18  21:09:06  wft  * call to curdir replaced with getfullRCSname(),  * fixed call to getlogin(), cosmetic changes on output,  * changed conflicting long identifiers.  *  * Revision 3.1  82/10/13  16:07:56  wft  * fixed type of variables receiving from getc() (char -> int).  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_struct
struct|struct
name|rcslockers
block|{
comment|/* lockers in locker option; stored   */
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
comment|/* lockerlist			    */
name|struct
name|rcslockers
modifier|*
name|lockerlink
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|stateattri
block|{
comment|/* states in state option; stored in  */
name|char
specifier|const
modifier|*
name|status
decl_stmt|;
comment|/* statelist			    */
name|struct
name|stateattri
modifier|*
name|nextstate
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|authors
block|{
comment|/* login names in author option;      */
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
comment|/* stored in authorlist		    */
name|struct
name|authors
modifier|*
name|nextauthor
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Revpairs
block|{
comment|/* revision or branch range in -r     */
name|int
name|numfld
decl_stmt|;
comment|/* option; stored in revlist	    */
name|char
specifier|const
modifier|*
name|strtrev
decl_stmt|;
name|char
specifier|const
modifier|*
name|endrev
decl_stmt|;
name|struct
name|Revpairs
modifier|*
name|rnext
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Datepairs
block|{
comment|/* date range in -d option; stored in */
name|struct
name|Datepairs
modifier|*
name|dnext
decl_stmt|;
name|char
name|strtdate
index|[
name|datesize
index|]
decl_stmt|;
comment|/* duelst and datelist      */
name|char
name|enddate
index|[
name|datesize
index|]
decl_stmt|;
name|char
name|ne_date
decl_stmt|;
comment|/* datelist only; distinguishes< from<= */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|extractdelta
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checkrevpair
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extdate
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getnumericrev
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
specifier|const
modifier|*
name|readdeltalog
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exttree
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getauthor
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getdatepair
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getlocker
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getrevpairs
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getscript
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getstate
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putabranch
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putadelta
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putforest
name|P
argument_list|(
operator|(
expr|struct
name|branchhead
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putree
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putrunk
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|recentdate
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
expr|struct
name|Datepairs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trunclocks
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|insDelFormat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|branchflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*set on -b */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Datepairs
modifier|*
name|datelist
decl_stmt|,
modifier|*
name|duelst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Revpairs
modifier|*
name|revlist
decl_stmt|,
modifier|*
name|Revlst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|authors
modifier|*
name|authorlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rcslockers
modifier|*
name|lockerlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stateattri
modifier|*
name|statelist
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rlogId
argument_list|,
literal|"rlog"
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nrlog usage: rlog -{bhLNRt} -v[string] -ddates -l[lockers] -r[revs] -sstates -Vn -w[logins] -xsuff -zzone file ..."
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|currdate
decl_stmt|;
name|char
specifier|const
modifier|*
name|accessListString
decl_stmt|,
modifier|*
name|accessFormat
decl_stmt|;
name|char
specifier|const
modifier|*
name|headFormat
decl_stmt|,
modifier|*
name|symbolFormat
decl_stmt|;
name|struct
name|access
specifier|const
modifier|*
name|curaccess
decl_stmt|;
name|struct
name|assoc
specifier|const
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|struct
name|rcslock
specifier|const
modifier|*
name|currlock
decl_stmt|;
name|int
name|descflag
decl_stmt|,
name|selectflag
decl_stmt|;
name|int
name|onlylockflag
decl_stmt|;
comment|/* print only files with locks */
name|int
name|onlyRCSflag
decl_stmt|;
comment|/* print only RCS pathname */
name|int
name|pre5
decl_stmt|;
name|int
name|shownames
decl_stmt|;
name|int
name|revno
decl_stmt|;
name|int
name|versionlist
decl_stmt|;
name|char
modifier|*
name|vstring
decl_stmt|;
name|descflag
operator|=
name|selectflag
operator|=
name|shownames
operator|=
name|true
expr_stmt|;
name|versionlist
operator|=
name|onlylockflag
operator|=
name|onlyRCSflag
operator|=
name|false
expr_stmt|;
name|vstring
operator|=
literal|0
expr_stmt|;
name|out
operator|=
name|stdout
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'L'
case|:
name|onlylockflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|shownames
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|onlyRCSflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lockflag
operator|=
name|true
expr_stmt|;
name|getlocker
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|branchflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|getrevpairs
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|getdatepair
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|getstate
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|getauthor
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|descflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|selectflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* This has no effect; it's here for consistency.  */
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|zone_set
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Ignore -T, so that RCSINIT can contain -T.  */
if|if
condition|(
operator|*
name|a
condition|)
goto|goto
name|unknown
goto|;
break|break;
case|case
literal|'V'
case|:
name|setRCSversion
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|versionlist
operator|=
name|true
expr_stmt|;
name|vstring
operator|=
name|a
expr_stmt|;
break|break;
default|default:
name|unknown
label|:
name|error
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end of option processing */
if|if
condition|(
operator|!
operator|(
name|descflag
operator||
name|selectflag
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"-t overrides -h."
argument_list|)
expr_stmt|;
name|descflag
operator|=
name|true
expr_stmt|;
block|}
name|pre5
operator|=
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre5
condition|)
block|{
name|accessListString
operator|=
literal|"\naccess list:   "
expr_stmt|;
name|accessFormat
operator|=
literal|"  %s"
expr_stmt|;
name|headFormat
operator|=
literal|"RCS file:        %s;   Working file:    %s\nhead:           %s%s\nbranch:         %s%s\nlocks:         "
expr_stmt|;
name|insDelFormat
operator|=
literal|"  lines added/del: %ld/%ld"
expr_stmt|;
name|symbolFormat
operator|=
literal|"  %s: %s;"
expr_stmt|;
block|}
else|else
block|{
name|accessListString
operator|=
literal|"\naccess list:"
expr_stmt|;
name|accessFormat
operator|=
literal|"\n\t%s"
expr_stmt|;
name|headFormat
operator|=
literal|"RCS file: %s\nWorking file: %s\nhead:%s%s\nbranch:%s%s\nlocks:%s"
expr_stmt|;
name|insDelFormat
operator|=
literal|"  lines: +%ld -%ld"
expr_stmt|;
name|symbolFormat
operator|=
literal|"\n\t%s: %s"
expr_stmt|;
block|}
comment|/* Now handle all pathnames.  */
if|if
condition|(
name|nerror
condition|)
name|cleanup
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
literal|0
operator|<
name|argc
condition|;
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
control|)
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
comment|/* 	     * RCSname contains the name of the RCS file, 	     * and finptr the file descriptor; 	     * workname contains the name of the working file.              */
comment|/* Keep only those locks given by -l.  */
if|if
condition|(
name|lockflag
condition|)
name|trunclocks
argument_list|()
expr_stmt|;
comment|/* do nothing if -L is given and there are no locks*/
if|if
condition|(
name|onlylockflag
operator|&&
operator|!
name|Locks
condition|)
continue|continue;
if|if
condition|(
name|versionlist
condition|)
block|{
name|gettree
argument_list|()
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%s%s %s\n"
argument_list|,
name|vstring
argument_list|,
name|workname
argument_list|,
name|tiprev
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|onlyRCSflag
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gettree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getnumericrev
argument_list|()
condition|)
continue|continue;
comment|/* 	    * Output the first character with putc, not printf. 	    * Otherwise, an SVR4 stdio bug buffers output inefficiently. 	    */
name|aputc_
argument_list|(
literal|'\n'
argument_list|,
argument|out
argument_list|)
comment|/*   print RCS pathname, working pathname and optional                  administrative information                         */
comment|/* could use getfullRCSname() here, but that is very slow */
name|aprintf
argument_list|(
name|out
argument_list|,
name|headFormat
argument_list|,
name|RCSname
argument_list|,
name|workname
argument_list|,
name|Head
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|Head
condition|?
name|Head
operator|->
name|num
else|:
literal|""
argument_list|,
name|Dbranch
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|Dbranch
condition|?
name|Dbranch
else|:
literal|""
argument_list|,
name|StrictLocks
condition|?
literal|" strict"
else|:
literal|""
argument_list|)
expr_stmt|;
name|currlock
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|currlock
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
name|symbolFormat
argument_list|,
name|currlock
operator|->
name|login
argument_list|,
name|currlock
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|currlock
operator|=
name|currlock
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|StrictLocks
operator|&&
name|pre5
condition|)
name|aputs
argument_list|(
literal|"  ;  strict"
operator|+
operator|(
name|Locks
condition|?
literal|3
else|:
literal|0
operator|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
name|accessListString
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/*  print access list  */
name|curaccess
operator|=
name|AccessList
expr_stmt|;
while|while
condition|(
name|curaccess
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
name|accessFormat
argument_list|,
name|curaccess
operator|->
name|login
argument_list|)
expr_stmt|;
name|curaccess
operator|=
name|curaccess
operator|->
name|nextaccess
expr_stmt|;
block|}
if|if
condition|(
name|shownames
condition|)
block|{
name|aputs
argument_list|(
literal|"\nsymbolic names:"
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/*  print symbolic names   */
for|for
control|(
name|curassoc
operator|=
name|Symbols
init|;
name|curassoc
condition|;
name|curassoc
operator|=
name|curassoc
operator|->
name|nextassoc
control|)
name|aprintf
argument_list|(
name|out
argument_list|,
name|symbolFormat
argument_list|,
name|curassoc
operator|->
name|symbol
argument_list|,
name|curassoc
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pre5
condition|)
block|{
name|aputs
argument_list|(
literal|"\ncomment leader:  \""
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|awrite
argument_list|(
name|Comment
operator|.
name|string
argument_list|,
name|Comment
operator|.
name|size
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
literal|'\"'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pre5
operator|||
name|Expand
operator|!=
name|KEYVAL_EXPAND
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"\nkeyword substitution: %s"
argument_list|,
name|expand_names
index|[
name|Expand
index|]
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"\ntotal revisions: %d"
argument_list|,
name|TotalDeltas
argument_list|)
expr_stmt|;
name|revno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Head
operator|&&
name|selectflag
operator|&
name|descflag
condition|)
block|{
name|exttree
argument_list|(
name|Head
argument_list|)
expr_stmt|;
comment|/*  get most recently date of the dates pointed by duelst  */
name|currdate
operator|=
name|duelst
expr_stmt|;
while|while
condition|(
name|currdate
condition|)
block|{
name|VOID
name|strcpy
argument_list|(
name|currdate
operator|->
name|strtdate
argument_list|,
literal|"0.0.0.0.0.0"
argument_list|)
decl_stmt|;
name|recentdate
argument_list|(
name|Head
argument_list|,
name|currdate
argument_list|)
expr_stmt|;
name|currdate
operator|=
name|currdate
operator|->
name|dnext
expr_stmt|;
block|}
name|revno
operator|=
name|extdate
argument_list|(
name|Head
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|";\tselected revisions: %d"
argument_list|,
name|revno
argument_list|)
expr_stmt|;
block|}
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|descflag
condition|)
block|{
name|aputs
argument_list|(
literal|"description:\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|getdesc
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|revno
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|delta
operator|=
name|readdeltalog
argument_list|()
operator|)
operator|->
name|selector
operator|||
operator|--
name|revno
condition|)
continue|continue;
if|if
condition|(
name|delta
operator|->
name|next
operator|&&
name|countnumflds
argument_list|(
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|2
condition|)
comment|/* Read through delta->next to get its insertlns.  */
while|while
condition|(
name|readdeltalog
argument_list|()
operator|!=
name|delta
operator|->
name|next
condition|)
continue|continue;
name|putrunk
argument_list|()
expr_stmt|;
name|putree
argument_list|(
name|Head
argument_list|)
expr_stmt|;
block|}
name|aputs
argument_list|(
literal|"----------------------------\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
literal|"=============================================================================\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|Ofclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|RCS_lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|rlogExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putrunk
parameter_list|()
comment|/*  function:  print revisions chosen, which are in trunk      */
block|{
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|Head
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|putadelta
argument_list|(
name|ptr
argument_list|,
name|ptr
operator|->
name|next
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putree
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|root
decl_stmt|;
comment|/*   function: print delta tree (not including trunk) in reverse                order on each branch                                        */
block|{
if|if
condition|(
operator|!
name|root
condition|)
return|return;
name|putree
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|putforest
argument_list|(
name|root
operator|->
name|branches
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putforest
parameter_list|(
name|branchroot
parameter_list|)
name|struct
name|branchhead
specifier|const
modifier|*
name|branchroot
decl_stmt|;
comment|/*   function:  print branches that has the same direct ancestor    */
block|{
if|if
condition|(
operator|!
name|branchroot
condition|)
return|return;
name|putforest
argument_list|(
name|branchroot
operator|->
name|nextbranch
argument_list|)
expr_stmt|;
name|putabranch
argument_list|(
name|branchroot
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|putree
argument_list|(
name|branchroot
operator|->
name|hsh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putabranch
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|root
decl_stmt|;
comment|/*   function  :  print one branch     */
block|{
if|if
condition|(
operator|!
name|root
condition|)
return|return;
name|putabranch
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|putadelta
argument_list|(
name|root
argument_list|,
name|root
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putadelta
parameter_list|(
name|node
parameter_list|,
name|editscript
parameter_list|,
name|trunk
parameter_list|)
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|node
decl_stmt|,
decl|*
name|editscript
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|trunk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  function: Print delta node if node->selector is set.        */
end_comment

begin_comment
comment|/*      editscript indicates where the editscript is stored     */
end_comment

begin_comment
comment|/*      trunk indicated whether this node is in trunk           */
end_comment

begin_block
block|{
specifier|static
name|char
name|emptych
index|[]
init|=
name|EMPTYLOG
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
name|struct
name|buf
name|branchnum
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|int
name|pre5
init|=
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|selector
condition|)
return|return;
name|out
operator|=
name|stdout
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"----------------------------\nrevision %s%s"
argument_list|,
name|node
operator|->
name|num
argument_list|,
name|pre5
condition|?
literal|"        "
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|lockedby
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
name|pre5
operator|+
literal|"\tlocked by: %s;"
argument_list|,
name|node
operator|->
name|lockedby
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"\ndate: %s;  author: %s;  state: %s;"
argument_list|,
name|date2str
argument_list|(
name|node
operator|->
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|,
name|node
operator|->
name|author
argument_list|,
name|node
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|editscript
condition|)
if|if
condition|(
name|trunk
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
name|insDelFormat
argument_list|,
name|editscript
operator|->
name|deletelns
argument_list|,
name|editscript
operator|->
name|insertlns
argument_list|)
expr_stmt|;
else|else
name|aprintf
argument_list|(
name|out
argument_list|,
name|insDelFormat
argument_list|,
name|editscript
operator|->
name|insertlns
argument_list|,
name|editscript
operator|->
name|deletelns
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|node
operator|->
name|branches
expr_stmt|;
if|if
condition|(
name|newbranch
condition|)
block|{
name|bufautobegin
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
literal|"\nbranches:"
argument_list|,
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|getbranchno
argument_list|(
name|newbranch
operator|->
name|hsh
operator|->
name|num
argument_list|,
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"  %s;"
argument_list|,
name|branchnum
operator|.
name|string
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
name|bufautoend
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
block|}
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|s
operator|=
name|node
operator|->
name|log
operator|.
name|string
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|=
name|node
operator|->
name|log
operator|.
name|size
operator|)
condition|)
block|{
name|s
operator|=
name|emptych
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|emptych
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|awrite
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|n
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|struct
name|hshentry
specifier|const
modifier|*
name|readdeltalog
parameter_list|()
comment|/*  Function : get the log message and skip the text of a deltatext node.  *	       Return the delta found.  *             Assumes the current lexeme is not yet in nexttok; does not  *             advance nexttok.  */
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
name|struct
name|buf
name|logbuf
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
if|if
condition|(
name|eoflex
argument_list|()
condition|)
name|fatserror
argument_list|(
literal|"missing delta log"
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Delta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
name|fatserror
argument_list|(
literal|"delta number corrupted"
argument_list|)
expr_stmt|;
name|getkeystring
argument_list|(
name|Klog
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delta
operator|->
name|log
operator|.
name|string
condition|)
name|fatserror
argument_list|(
literal|"duplicate delta log"
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|logbuf
argument_list|)
expr_stmt|;
name|cb
operator|=
name|savestring
argument_list|(
operator|&
name|logbuf
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|log
operator|=
name|bufremember
argument_list|(
operator|&
name|logbuf
argument_list|,
name|cb
operator|.
name|size
argument_list|)
expr_stmt|;
name|ignorephrases
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
name|getkeystring
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
name|Delta
operator|->
name|insertlns
operator|=
name|Delta
operator|->
name|deletelns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Delta
operator|!=
name|Head
condition|)
name|getscript
argument_list|(
name|Delta
argument_list|)
expr_stmt|;
else|else
name|readstring
argument_list|()
expr_stmt|;
return|return
name|Delta
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getscript
parameter_list|(
name|Delta
parameter_list|)
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
comment|/*   function:  read edit script of Delta and count how many lines added  */
comment|/*              and deleted in the script                                 */
block|{
name|int
name|ed
decl_stmt|;
comment|/*  editor command  */
name|declarecache
expr_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
name|struct
name|diffcmd
name|dc
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|initdiffcmd
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|(
name|ed
operator|=
name|getdiffcmd
argument_list|(
name|fin
argument_list|,
name|true
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|dc
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
name|ed
condition|)
name|Delta
operator|->
name|deletelns
operator|+=
name|dc
operator|.
name|nlines
expr_stmt|;
else|else
block|{
comment|/*  skip scripted lines  */
name|i
operator|=
name|dc
operator|.
name|nlines
expr_stmt|;
name|Delta
operator|->
name|insertlns
operator|+=
name|i
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
do|do
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|cacheget_
argument_list|(
argument|c
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
continue|continue;
case|case
name|SDELIM
case|:
name|cacheget_
argument_list|(
argument|c
argument_list|)
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
continue|continue;
if|if
condition|(
operator|--
name|i
condition|)
name|unexpected_EOF
argument_list|()
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\n'
case|:
break|break;
block|}
break|break;
block|}
operator|++
name|rcsline
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exttree
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
comment|/*  function: select revisions , starting with root             */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
return|return;
name|root
operator|->
name|selector
operator|=
name|extractdelta
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|root
operator|->
name|log
operator|.
name|string
operator|=
literal|0
expr_stmt|;
name|exttree
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|exttree
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getlocker
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*   function : get the login names of lockers from command line   */
comment|/*              and store in lockerlist.                           */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|rcslockers
modifier|*
name|newlocker
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|lockerlist
operator|=
literal|0
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newlocker
operator|=
name|talloc
argument_list|(
expr|struct
name|rcslockers
argument_list|)
expr_stmt|;
name|newlocker
operator|->
name|lockerlink
operator|=
name|lockerlist
expr_stmt|;
name|newlocker
operator|->
name|login
operator|=
name|argv
expr_stmt|;
name|lockerlist
operator|=
name|newlocker
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
continue|continue;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
continue|continue;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getauthor
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*   function:  get the author's name from command line   */
comment|/*              and store in authorlist                   */
block|{
specifier|register
name|c
expr_stmt|;
name|struct
name|authors
modifier|*
name|newauthor
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|authorlist
operator|=
name|talloc
argument_list|(
expr|struct
name|authors
argument_list|)
expr_stmt|;
name|authorlist
operator|->
name|login
operator|=
name|getusername
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|authorlist
operator|->
name|nextauthor
operator|=
literal|0
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newauthor
operator|=
name|talloc
argument_list|(
expr|struct
name|authors
argument_list|)
expr_stmt|;
name|newauthor
operator|->
name|nextauthor
operator|=
name|authorlist
expr_stmt|;
name|newauthor
operator|->
name|login
operator|=
name|argv
expr_stmt|;
name|authorlist
operator|=
name|newauthor
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
continue|continue;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
continue|continue;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getstate
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*   function :  get the states of revisions from command line  */
comment|/*               and store in statelist                         */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|stateattri
modifier|*
name|newstate
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"missing state attributes after -s options"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|newstate
operator|=
name|talloc
argument_list|(
expr|struct
name|stateattri
argument_list|)
expr_stmt|;
name|newstate
operator|->
name|nextstate
operator|=
name|statelist
expr_stmt|;
name|newstate
operator|->
name|status
operator|=
name|argv
expr_stmt|;
name|statelist
operator|=
name|newstate
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|';'
condition|)
continue|continue;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
continue|continue;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trunclocks
parameter_list|()
comment|/*  Function:  Truncate the list of locks to those that are held by the  */
comment|/*             id's on lockerlist. Do not truncate if lockerlist empty.  */
block|{
name|struct
name|rcslockers
specifier|const
modifier|*
name|plocker
decl_stmt|;
name|struct
name|rcslock
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|lockerlist
condition|)
return|return;
comment|/* shorten Locks to those contained in lockerlist */
for|for
control|(
name|pp
operator|=
operator|&
name|Locks
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
condition|;
control|)
for|for
control|(
name|plocker
operator|=
name|lockerlist
init|;
condition|;
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|plocker
operator|->
name|login
argument_list|,
name|p
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pp
operator|=
operator|&
name|p
operator|->
name|nextlock
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|plocker
operator|=
name|plocker
operator|->
name|lockerlink
operator|)
condition|)
block|{
operator|*
name|pp
operator|=
name|p
operator|->
name|nextlock
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|recentdate
parameter_list|(
name|root
parameter_list|,
name|pd
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|root
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|pd
decl_stmt|;
comment|/*  function:  Finds the delta that is closest to the cutoff date given by   */
comment|/*             pd among the revisions selected by exttree.                   */
comment|/*             Successively narrows down the interval given by pd,           */
comment|/*             and sets the strtdate of pd to the date of the selected delta */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
return|return;
if|if
condition|(
name|root
operator|->
name|selector
condition|)
block|{
if|if
condition|(
name|cmpdate
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pd
operator|->
name|strtdate
argument_list|)
operator|>=
literal|0
operator|&&
name|cmpdate
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pd
operator|->
name|enddate
argument_list|)
operator|<=
literal|0
condition|)
name|VOID
name|strcpy
argument_list|(
name|pd
operator|->
name|strtdate
argument_list|,
name|root
operator|->
name|date
argument_list|)
decl_stmt|;
block|}
name|recentdate
argument_list|(
name|root
operator|->
name|next
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|recentdate
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|,
name|pd
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|extdate
parameter_list|(
name|root
parameter_list|)
name|struct
name|hshentry
modifier|*
name|root
decl_stmt|;
comment|/*  function:  select revisions which are in the date range specified     */
comment|/*             in duelst  and datelist, start at root                     */
comment|/* Yield number of revisions selected, including those already selected.  */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|newbranch
decl_stmt|;
name|struct
name|Datepairs
specifier|const
modifier|*
name|pdate
decl_stmt|;
name|int
name|revno
decl_stmt|,
name|ne
decl_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|datelist
operator|||
name|duelst
condition|)
block|{
name|pdate
operator|=
name|datelist
expr_stmt|;
while|while
condition|(
name|pdate
condition|)
block|{
name|ne
operator|=
name|pdate
operator|->
name|ne_date
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|pdate
operator|->
name|strtdate
index|[
literal|0
index|]
operator|||
name|ne
operator|<=
name|cmpdate
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pdate
operator|->
name|strtdate
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|pdate
operator|->
name|enddate
index|[
literal|0
index|]
operator|||
name|ne
operator|<=
name|cmpdate
argument_list|(
name|pdate
operator|->
name|enddate
argument_list|,
name|root
operator|->
name|date
argument_list|)
operator|)
condition|)
break|break;
name|pdate
operator|=
name|pdate
operator|->
name|dnext
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pdate
condition|)
block|{
name|pdate
operator|=
name|duelst
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|pdate
condition|)
block|{
name|root
operator|->
name|selector
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmpdate
argument_list|(
name|root
operator|->
name|date
argument_list|,
name|pdate
operator|->
name|strtdate
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|pdate
operator|=
name|pdate
operator|->
name|dnext
expr_stmt|;
block|}
block|}
block|}
name|revno
operator|=
name|root
operator|->
name|selector
operator|+
name|extdate
argument_list|(
name|root
operator|->
name|next
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|newbranch
condition|)
block|{
name|revno
operator|+=
name|extdate
argument_list|(
name|newbranch
operator|->
name|hsh
argument_list|)
expr_stmt|;
name|newbranch
operator|=
name|newbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
return|return
name|revno
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|extractdelta
parameter_list|(
name|pdelta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|pdelta
decl_stmt|;
comment|/*  function:  compare information of pdelta to the authorlist, lockerlist,*/
comment|/*             statelist, revlist and yield true if pdelta is selected.    */
block|{
name|struct
name|rcslock
specifier|const
modifier|*
name|plock
decl_stmt|;
name|struct
name|stateattri
specifier|const
modifier|*
name|pstate
decl_stmt|;
name|struct
name|authors
specifier|const
modifier|*
name|pauthor
decl_stmt|;
name|struct
name|Revpairs
specifier|const
modifier|*
name|prevision
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|pauthor
operator|=
name|authorlist
operator|)
condition|)
comment|/* only certain authors wanted */
while|while
condition|(
name|strcmp
argument_list|(
name|pauthor
operator|->
name|login
argument_list|,
name|pdelta
operator|->
name|author
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
name|pauthor
operator|=
name|pauthor
operator|->
name|nextauthor
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|pstate
operator|=
name|statelist
operator|)
condition|)
comment|/* only certain states wanted */
while|while
condition|(
name|strcmp
argument_list|(
name|pstate
operator|->
name|status
argument_list|,
name|pdelta
operator|->
name|state
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
name|pstate
operator|=
name|pstate
operator|->
name|nextstate
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|lockflag
condition|)
comment|/* only locked revisions wanted */
for|for
control|(
name|plock
operator|=
name|Locks
init|;
condition|;
name|plock
operator|=
name|plock
operator|->
name|nextlock
control|)
if|if
condition|(
operator|!
name|plock
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|plock
operator|->
name|delta
operator|==
name|pdelta
condition|)
break|break;
if|if
condition|(
operator|(
name|prevision
operator|=
name|Revlst
operator|)
condition|)
comment|/* only certain revs or branches wanted */
for|for
control|(
init|;
condition|;
control|)
block|{
name|length
operator|=
name|prevision
operator|->
name|numfld
expr_stmt|;
if|if
condition|(
name|countnumflds
argument_list|(
name|pdelta
operator|->
name|num
argument_list|)
operator|==
name|length
operator|+
operator|(
name|length
operator|&
literal|1
operator|)
operator|&&
literal|0
operator|<=
name|compartial
argument_list|(
name|pdelta
operator|->
name|num
argument_list|,
name|prevision
operator|->
name|strtrev
argument_list|,
name|length
argument_list|)
operator|&&
literal|0
operator|<=
name|compartial
argument_list|(
name|prevision
operator|->
name|endrev
argument_list|,
name|pdelta
operator|->
name|num
argument_list|,
name|length
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|prevision
operator|=
name|prevision
operator|->
name|rnext
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getdatepair
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*  function:  get time range from command line and store in datelist if    */
comment|/*             a time range specified or in duelst if a time spot specified */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|Datepairs
modifier|*
name|nextdate
decl_stmt|;
name|char
specifier|const
modifier|*
name|rawdate
decl_stmt|;
name|int
name|switchflag
decl_stmt|;
name|argv
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|','
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"missing date/time after -d"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|switchflag
operator|=
name|false
expr_stmt|;
name|nextdate
operator|=
name|talloc
argument_list|(
expr|struct
name|Datepairs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
comment|/*   case: -d<date   */
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdate
operator|->
name|ne_date
operator|=
name|c
operator|!=
literal|'='
operator|)
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|(
name|nextdate
operator|->
name|strtdate
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
comment|/* case: -d'>date' */
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdate
operator|->
name|ne_date
operator|=
name|c
operator|!=
literal|'='
operator|)
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|(
name|nextdate
operator|->
name|enddate
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|switchflag
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|rawdate
operator|=
name|argv
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
name|switchflag
operator|=
name|true
expr_stmt|;
name|str2date
argument_list|(
name|rawdate
argument_list|,
name|switchflag
condition|?
name|nextdate
operator|->
name|enddate
else|:
name|nextdate
operator|->
name|strtdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*  case: -d date  */
name|VOID
name|strcpy
argument_list|(
name|nextdate
operator|->
name|enddate
argument_list|,
name|nextdate
operator|->
name|strtdate
argument_list|)
decl_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|duelst
expr_stmt|;
name|duelst
operator|=
name|nextdate
expr_stmt|;
goto|goto
name|end
goto|;
block|}
else|else
block|{
comment|/*   case:   -d date<  or -d  date>; see switchflag */
name|int
name|eq
init|=
name|argv
index|[
literal|1
index|]
operator|==
literal|'='
decl_stmt|;
name|nextdate
operator|->
name|ne_date
operator|=
operator|!
name|eq
expr_stmt|;
name|argv
operator|+=
name|eq
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|';'
operator|||
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* second date missing */
if|if
condition|(
name|switchflag
condition|)
operator|*
name|nextdate
operator|->
name|strtdate
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|nextdate
operator|->
name|enddate
operator|=
literal|'\0'
expr_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|datelist
expr_stmt|;
name|datelist
operator|=
name|nextdate
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
block|}
name|rawdate
operator|=
name|argv
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'>'
operator|&&
name|c
operator|!=
literal|'<'
operator|&&
name|c
operator|!=
literal|';'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
name|str2date
argument_list|(
name|rawdate
argument_list|,
name|switchflag
condition|?
name|nextdate
operator|->
name|strtdate
else|:
name|nextdate
operator|->
name|enddate
argument_list|)
expr_stmt|;
name|nextdate
operator|->
name|dnext
operator|=
name|datelist
expr_stmt|;
name|datelist
operator|=
name|nextdate
expr_stmt|;
name|end
label|:
if|if
condition|(
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|)
name|nextdate
operator|->
name|ne_date
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|';'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|getnumericrev
parameter_list|()
comment|/*  function:  get the numeric name of revisions which stored in revlist  */
comment|/*             and then stored the numeric names in Revlst                */
comment|/*             if branchflag, also add default branch                     */
block|{
name|struct
name|Revpairs
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|buf
name|s
decl_stmt|,
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|lrev
decl_stmt|;
name|struct
name|buf
specifier|const
modifier|*
name|rstart
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
name|Revlst
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|revlist
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|rstart
operator|=
operator|&
name|s
expr_stmt|;
name|rend
operator|=
operator|&
name|e
expr_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|numfld
condition|)
block|{
case|case
literal|1
case|:
comment|/* -rREV */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
operator|&
name|s
argument_list|)
condition|)
goto|goto
name|freebufs
goto|;
name|rend
operator|=
operator|&
name|s
expr_stmt|;
name|n
operator|=
name|countnumflds
argument_list|(
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|&&
operator|(
name|lrev
operator|=
name|tiprev
argument_list|()
operator|)
condition|)
block|{
name|bufscpy
argument_list|(
operator|&
name|s
argument_list|,
name|lrev
argument_list|)
expr_stmt|;
name|n
operator|=
name|countnumflds
argument_list|(
name|lrev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* -rREV: */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
operator|&
name|s
argument_list|)
condition|)
goto|goto
name|freebufs
goto|;
name|bufscpy
argument_list|(
operator|&
name|e
argument_list|,
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
name|n
operator|=
name|countnumflds
argument_list|(
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
operator|(
name|n
operator|<
literal|2
condition|?
name|e
operator|.
name|string
else|:
name|strrchr
argument_list|(
name|e
operator|.
name|string
argument_list|,
literal|'.'
argument_list|)
operator|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* -r:REV */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|ptr
operator|->
name|endrev
argument_list|,
operator|&
name|e
argument_list|)
condition|)
goto|goto
name|freebufs
goto|;
if|if
condition|(
operator|(
name|n
operator|=
name|countnumflds
argument_list|(
name|e
operator|.
name|string
argument_list|)
operator|)
operator|<
literal|2
condition|)
name|bufscpy
argument_list|(
operator|&
name|s
argument_list|,
literal|".0"
argument_list|)
expr_stmt|;
else|else
block|{
name|bufscpy
argument_list|(
operator|&
name|s
argument_list|,
name|e
operator|.
name|string
argument_list|)
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|strrchr
argument_list|(
name|s
operator|.
name|string
argument_list|,
literal|'.'
argument_list|)
argument_list|,
literal|".0"
argument_list|)
decl_stmt|;
block|}
break|break;
default|default:
comment|/* -rREV1:REV2 */
if|if
condition|(
operator|!
operator|(
name|expandsym
argument_list|(
name|ptr
operator|->
name|strtrev
argument_list|,
operator|&
name|s
argument_list|)
operator|&&
name|expandsym
argument_list|(
name|ptr
operator|->
name|endrev
argument_list|,
operator|&
name|e
argument_list|)
operator|&&
name|checkrevpair
argument_list|(
name|s
operator|.
name|string
argument_list|,
name|e
operator|.
name|string
argument_list|)
operator|)
condition|)
goto|goto
name|freebufs
goto|;
name|n
operator|=
name|countnumflds
argument_list|(
name|s
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* Swap if out of order.  */
if|if
condition|(
name|compartial
argument_list|(
name|s
operator|.
name|string
argument_list|,
name|e
operator|.
name|string
argument_list|,
name|n
argument_list|)
operator|>
literal|0
condition|)
block|{
name|rstart
operator|=
operator|&
name|e
expr_stmt|;
name|rend
operator|=
operator|&
name|s
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|pt
operator|=
name|ftalloc
argument_list|(
expr|struct
name|Revpairs
argument_list|)
expr_stmt|;
name|pt
operator|->
name|numfld
operator|=
name|n
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|fstr_save
argument_list|(
name|rstart
operator|->
name|string
argument_list|)
expr_stmt|;
name|pt
operator|->
name|endrev
operator|=
name|fstr_save
argument_list|(
name|rend
operator|->
name|string
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rnext
operator|=
name|Revlst
expr_stmt|;
name|Revlst
operator|=
name|pt
expr_stmt|;
block|}
name|ptr
operator|=
name|ptr
operator|->
name|rnext
expr_stmt|;
block|}
comment|/* Now take care of branchflag */
if|if
condition|(
name|branchflag
operator|&&
operator|(
name|Dbranch
operator|||
name|Head
operator|)
condition|)
block|{
name|pt
operator|=
name|ftalloc
argument_list|(
expr|struct
name|Revpairs
argument_list|)
expr_stmt|;
name|pt
operator|->
name|strtrev
operator|=
name|pt
operator|->
name|endrev
operator|=
name|Dbranch
condition|?
name|Dbranch
else|:
name|fstr_save
argument_list|(
name|partialno
argument_list|(
operator|&
name|s
argument_list|,
name|Head
operator|->
name|num
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pt
operator|->
name|rnext
operator|=
name|Revlst
expr_stmt|;
name|Revlst
operator|=
name|pt
expr_stmt|;
name|pt
operator|->
name|numfld
operator|=
name|countnumflds
argument_list|(
name|pt
operator|->
name|strtrev
argument_list|)
expr_stmt|;
block|}
name|freebufs
label|:
name|bufautoend
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
return|return
operator|!
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|checkrevpair
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|)
name|char
specifier|const
modifier|*
name|num1
decl_stmt|,
decl|*
name|num2
decl_stmt|;
end_function

begin_comment
comment|/*  function:  check whether num1, num2 are legal pair,i.e.     only the last field are different and have same number of     fields( if length<= 2, may be different if first field)   */
end_comment

begin_block
block|{
name|int
name|length
init|=
name|countnumflds
argument_list|(
name|num1
argument_list|)
decl_stmt|;
if|if
condition|(
name|countnumflds
argument_list|(
name|num2
argument_list|)
operator|!=
name|length
operator|||
operator|(
literal|2
operator|<
name|length
operator|&&
name|compartial
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|,
name|length
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"invalid branch or revision pair %s : %s"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|getrevpairs
parameter_list|(
name|argv
parameter_list|)
specifier|register
name|char
modifier|*
name|argv
decl_stmt|;
comment|/*  function:  get revision or branch range from command line, and   */
comment|/*             store in revlist                                      */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|struct
name|Revpairs
modifier|*
name|nextrevpair
decl_stmt|;
name|int
name|separator
decl_stmt|;
name|c
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* Support old ambiguous '-' syntax; this will go away.  */
if|if
condition|(
name|strchr
argument_list|(
name|argv
argument_list|,
literal|':'
argument_list|)
condition|)
name|separator
operator|=
literal|':'
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|argv
argument_list|,
literal|'-'
argument_list|)
operator|&&
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
condition|)
name|warn
argument_list|(
literal|"`-' is obsolete in `-r%s'; use `:' instead"
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|separator
operator|=
literal|'-'
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|nextrevpair
operator|=
name|talloc
argument_list|(
expr|struct
name|Revpairs
argument_list|)
expr_stmt|;
name|nextrevpair
operator|->
name|rnext
operator|=
name|revlist
expr_stmt|;
name|revlist
operator|=
name|nextrevpair
expr_stmt|;
name|nextrevpair
operator|->
name|numfld
operator|=
literal|1
expr_stmt|;
name|nextrevpair
operator|->
name|strtrev
operator|=
name|argv
expr_stmt|;
for|for
control|(
init|;
condition|;
name|c
operator|=
operator|*
operator|++
name|argv
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
continue|continue;
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
break|break;
case|case
literal|':'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|c
operator|==
name|separator
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|separator
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
name|nextrevpair
operator|->
name|endrev
operator|=
name|argv
expr_stmt|;
for|for
control|(
init|;
condition|;
name|c
operator|=
operator|*
operator|++
name|argv
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
continue|continue;
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
break|break;
case|case
literal|':'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|c
operator|==
name|separator
condition|)
break|break;
continue|continue;
block|}
break|break;
block|}
operator|*
name|argv
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|nextrevpair
operator|->
name|numfld
operator|=
operator|!
name|nextrevpair
operator|->
name|endrev
index|[
literal|0
index|]
condition|?
literal|2
comment|/* -rREV: */
else|:
operator|!
name|nextrevpair
operator|->
name|strtrev
index|[
literal|0
index|]
condition|?
literal|3
comment|/* -r:REV */
else|:
literal|4
comment|/* -rREV1:REV2 */
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|';'
condition|)
name|c
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
else|else
name|error
argument_list|(
literal|"missing `,' near `%c%s'"
argument_list|,
name|c
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

