begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2010 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Pawel Jakub Dawidek under sponsorship from  * the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* powerof2() */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pjdlog.h>
end_include

begin_include
include|#
directive|include
file|"activemap.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PJDLOG_ASSERT
end_ifndef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|PJDLOG_ASSERT
parameter_list|(
modifier|...
parameter_list|)
value|assert(__VA_ARGS__)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ACTIVEMAP_MAGIC
value|0xac71e4
end_define

begin_struct
struct|struct
name|activemap
block|{
name|int
name|am_magic
decl_stmt|;
comment|/* Magic value. */
name|off_t
name|am_mediasize
decl_stmt|;
comment|/* Media size in bytes. */
name|uint32_t
name|am_extentsize
decl_stmt|;
comment|/* Extent size in bytes, 					   must be power of 2. */
name|uint8_t
name|am_extentshift
decl_stmt|;
comment|/* 2 ^ extentbits == extentsize */
name|int
name|am_nextents
decl_stmt|;
comment|/* Number of extents. */
name|size_t
name|am_mapsize
decl_stmt|;
comment|/* Bitmap size in bytes. */
name|uint16_t
modifier|*
name|am_memtab
decl_stmt|;
comment|/* An array that holds number of pending 					   writes per extent. */
name|bitstr_t
modifier|*
name|am_diskmap
decl_stmt|;
comment|/* On-disk bitmap of dirty extents. */
name|bitstr_t
modifier|*
name|am_memmap
decl_stmt|;
comment|/* In-memory bitmap of dirty extents. */
name|size_t
name|am_diskmapsize
decl_stmt|;
comment|/* Map size rounded up to sector size. */
name|uint64_t
name|am_ndirty
decl_stmt|;
comment|/* Number of dirty regions. */
name|bitstr_t
modifier|*
name|am_syncmap
decl_stmt|;
comment|/* Bitmap of extents to sync. */
name|off_t
name|am_syncoff
decl_stmt|;
comment|/* Next synchronization offset. */
name|TAILQ_HEAD
argument_list|(
argument|skeepdirty
argument_list|,
argument|keepdirty
argument_list|)
name|am_keepdirty
expr_stmt|;
comment|/* List of extents that 					   we keep dirty to reduce bitmap 					   updates. */
name|int
name|am_nkeepdirty
decl_stmt|;
comment|/* Number of am_keepdirty elements. */
name|int
name|am_nkeepdirty_limit
decl_stmt|;
comment|/* Maximum number of am_keepdirty 					         elements. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|keepdirty
block|{
name|int
name|kd_extent
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|keepdirty
argument_list|)
name|kd_next
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Helper function taken from sys/systm.h to calculate extentshift.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bitcount32
parameter_list|(
name|uint32_t
name|x
parameter_list|)
block|{
name|x
operator|=
operator|(
name|x
operator|&
literal|0x55555555
operator|)
operator|+
operator|(
operator|(
name|x
operator|&
literal|0xaaaaaaaa
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0x33333333
operator|)
operator|+
operator|(
operator|(
name|x
operator|&
literal|0xcccccccc
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|4
operator|)
operator|)
operator|&
literal|0x0f0f0f0f
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|8
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|16
operator|)
operator|)
operator|&
literal|0x000000ff
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|off2ext
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|int
name|extent
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<
name|amp
operator|->
name|am_mediasize
argument_list|)
expr_stmt|;
name|extent
operator|=
operator|(
name|offset
operator|>>
name|amp
operator|->
name|am_extentshift
operator|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|extent
operator|>=
literal|0
operator|&&
name|extent
operator|<
name|amp
operator|->
name|am_nextents
argument_list|)
expr_stmt|;
return|return
operator|(
name|extent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|off_t
name|ext2off
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|off_t
name|offset
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|extent
operator|>=
literal|0
operator|&&
name|extent
operator|<
name|amp
operator|->
name|am_nextents
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|off_t
operator|)
name|extent
operator|<<
name|amp
operator|->
name|am_extentshift
operator|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<
name|amp
operator|->
name|am_mediasize
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function calculates number of requests needed to synchronize the given  * extent.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ext2reqs
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|int
name|ext
parameter_list|)
block|{
name|off_t
name|left
decl_stmt|;
if|if
condition|(
name|ext
operator|<
name|amp
operator|->
name|am_nextents
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
operator|(
name|amp
operator|->
name|am_extentsize
operator|-
literal|1
operator|)
operator|/
name|MAXPHYS
operator|)
operator|+
literal|1
operator|)
return|;
name|PJDLOG_ASSERT
argument_list|(
name|ext
operator|==
name|amp
operator|->
name|am_nextents
operator|-
literal|1
argument_list|)
expr_stmt|;
name|left
operator|=
name|amp
operator|->
name|am_mediasize
operator|%
name|amp
operator|->
name|am_extentsize
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
name|left
operator|=
name|amp
operator|->
name|am_extentsize
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|left
operator|-
literal|1
operator|)
operator|/
name|MAXPHYS
operator|)
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize activemap structure and allocate memory for internal needs.  * Function returns 0 on success and -1 if any of the allocations failed.  */
end_comment

begin_function
name|int
name|activemap_init
parameter_list|(
name|struct
name|activemap
modifier|*
modifier|*
name|ampp
parameter_list|,
name|uint64_t
name|mediasize
parameter_list|,
name|uint32_t
name|extentsize
parameter_list|,
name|uint32_t
name|sectorsize
parameter_list|,
name|uint32_t
name|keepdirty
parameter_list|)
block|{
name|struct
name|activemap
modifier|*
name|amp
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|ampp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|mediasize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|extentsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|powerof2
argument_list|(
name|extentsize
argument_list|)
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|sectorsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|powerof2
argument_list|(
name|sectorsize
argument_list|)
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|keepdirty
operator|>
literal|0
argument_list|)
expr_stmt|;
name|amp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|amp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|amp
operator|->
name|am_mediasize
operator|=
name|mediasize
expr_stmt|;
name|amp
operator|->
name|am_nkeepdirty_limit
operator|=
name|keepdirty
expr_stmt|;
name|amp
operator|->
name|am_extentsize
operator|=
name|extentsize
expr_stmt|;
name|amp
operator|->
name|am_extentshift
operator|=
name|bitcount32
argument_list|(
name|extentsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_nextents
operator|=
operator|(
operator|(
name|mediasize
operator|-
literal|1
operator|)
operator|/
name|extentsize
operator|)
operator|+
literal|1
expr_stmt|;
name|amp
operator|->
name|am_mapsize
operator|=
sizeof|sizeof
argument_list|(
name|bitstr_t
argument_list|)
operator|*
name|bitstr_size
argument_list|(
name|amp
operator|->
name|am_nextents
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_diskmapsize
operator|=
name|roundup2
argument_list|(
name|amp
operator|->
name|am_mapsize
argument_list|,
name|sectorsize
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_ndirty
operator|=
literal|0
expr_stmt|;
name|amp
operator|->
name|am_syncoff
operator|=
operator|-
literal|2
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_nkeepdirty
operator|=
literal|0
expr_stmt|;
name|amp
operator|->
name|am_memtab
operator|=
name|calloc
argument_list|(
name|amp
operator|->
name|am_nextents
argument_list|,
sizeof|sizeof
argument_list|(
name|amp
operator|->
name|am_memtab
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_diskmap
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|amp
operator|->
name|am_diskmapsize
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_memmap
operator|=
name|bit_alloc
argument_list|(
name|amp
operator|->
name|am_nextents
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_syncmap
operator|=
name|bit_alloc
argument_list|(
name|amp
operator|->
name|am_nextents
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if any of the allocations above failed. 	 */
if|if
condition|(
name|amp
operator|->
name|am_memtab
operator|==
name|NULL
operator|||
name|amp
operator|->
name|am_diskmap
operator|==
name|NULL
operator|||
name|amp
operator|->
name|am_memmap
operator|==
name|NULL
operator|||
name|amp
operator|->
name|am_syncmap
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|amp
operator|->
name|am_memtab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|amp
operator|->
name|am_memtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|amp
operator|->
name|am_diskmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|amp
operator|->
name|am_memmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|amp
operator|->
name|am_syncmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_magic
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|amp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|amp
operator|->
name|am_magic
operator|=
name|ACTIVEMAP_MAGIC
expr_stmt|;
operator|*
name|ampp
operator|=
name|amp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|keepdirty
modifier|*
name|keepdirty_find
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|struct
name|keepdirty
modifier|*
name|kd
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|kd
argument_list|,
argument|&amp->am_keepdirty
argument_list|,
argument|kd_next
argument_list|)
block|{
if|if
condition|(
name|kd
operator|->
name|kd_extent
operator|==
name|extent
condition|)
break|break;
block|}
return|return
operator|(
name|kd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|keepdirty_add
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|struct
name|keepdirty
modifier|*
name|kd
decl_stmt|;
name|kd
operator|=
name|keepdirty_find
argument_list|(
name|amp
argument_list|,
name|extent
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only move element at the beginning. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|,
name|kd
argument_list|,
name|kd_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|,
name|kd
argument_list|,
name|kd_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* 	 * Add new element, but first remove the most unused one if 	 * we have too many. 	 */
if|if
condition|(
name|amp
operator|->
name|am_nkeepdirty
operator|>=
name|amp
operator|->
name|am_nkeepdirty_limit
condition|)
block|{
name|kd
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|,
name|skeepdirty
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|kd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|,
name|kd
argument_list|,
name|kd_next
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_nkeepdirty
operator|--
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_nkeepdirty
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kd
operator|==
name|NULL
condition|)
name|kd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can ignore allocation failure. */
if|if
condition|(
name|kd
operator|!=
name|NULL
condition|)
block|{
name|kd
operator|->
name|kd_extent
operator|=
name|extent
expr_stmt|;
name|amp
operator|->
name|am_nkeepdirty
operator|++
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|,
name|kd
argument_list|,
name|kd_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|keepdirty_fill
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|struct
name|keepdirty
modifier|*
name|kd
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|kd
argument_list|,
argument|&amp->am_keepdirty
argument_list|,
argument|kd_next
argument_list|)
name|bit_set
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|,
name|kd
operator|->
name|kd_extent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|keepdirty_free
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|struct
name|keepdirty
modifier|*
name|kd
decl_stmt|;
while|while
condition|(
operator|(
name|kd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|amp
operator|->
name|am_keepdirty
argument_list|,
name|kd
argument_list|,
name|kd_next
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_nkeepdirty
operator|--
expr_stmt|;
name|free
argument_list|(
name|kd
argument_list|)
expr_stmt|;
block|}
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_nkeepdirty
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function frees resources allocated by activemap_init() function.  */
end_comment

begin_function
name|void
name|activemap_free
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_magic
operator|=
literal|0
expr_stmt|;
name|keepdirty_free
argument_list|(
name|amp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|amp
operator|->
name|am_memtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function should be called before we handle write requests. It updates  * internal structures and returns true if on-disk metadata should be updated.  */
end_comment

begin_function
name|bool
name|activemap_write_start
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|length
parameter_list|)
block|{
name|bool
name|modified
decl_stmt|;
name|off_t
name|end
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|modified
operator|=
name|false
expr_stmt|;
name|end
operator|=
name|offset
operator|+
name|length
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ext
operator|=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|offset
argument_list|)
init|;
name|ext
operator|<=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|end
argument_list|)
condition|;
name|ext
operator|++
control|)
block|{
comment|/* 		 * If the number of pending writes is increased from 0, 		 * we have to mark the extent as dirty also in on-disk bitmap. 		 * By returning true we inform the caller that on-disk bitmap 		 * was modified and has to be flushed to disk. 		 */
if|if
condition|(
name|amp
operator|->
name|am_memtab
index|[
name|ext
index|]
operator|++
operator|==
literal|0
condition|)
block|{
name|PJDLOG_ASSERT
argument_list|(
operator|!
name|bit_test
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_ndirty
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|keepdirty_add
argument_list|(
name|amp
argument_list|,
name|ext
argument_list|)
condition|)
name|modified
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|modified
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function should be called after receiving write confirmation. It updates  * internal structures and returns true if on-disk metadata should be updated.  */
end_comment

begin_function
name|bool
name|activemap_write_complete
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|length
parameter_list|)
block|{
name|bool
name|modified
decl_stmt|;
name|off_t
name|end
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|modified
operator|=
name|false
expr_stmt|;
name|end
operator|=
name|offset
operator|+
name|length
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ext
operator|=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|offset
argument_list|)
init|;
name|ext
operator|<=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|end
argument_list|)
condition|;
name|ext
operator|++
control|)
block|{
comment|/* 		 * If the number of pending writes goes down to 0, we have to 		 * mark the extent as clean also in on-disk bitmap. 		 * By returning true we inform the caller that on-disk bitmap 		 * was modified and has to be flushed to disk. 		 */
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_memtab
index|[
name|ext
index|]
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|bit_test
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|amp
operator|->
name|am_memtab
index|[
name|ext
index|]
operator|==
literal|0
condition|)
block|{
name|bit_clear
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_ndirty
operator|--
expr_stmt|;
if|if
condition|(
name|keepdirty_find
argument_list|(
name|amp
argument_list|,
name|ext
argument_list|)
operator|==
name|NULL
condition|)
name|modified
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
operator|(
name|modified
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function should be called after finishing synchronization of one extent.  * It returns true if on-disk metadata should be updated.  */
end_comment

begin_function
name|bool
name|activemap_extent_complete
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|bool
name|modified
decl_stmt|;
name|int
name|reqs
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|extent
operator|>=
literal|0
operator|&&
name|extent
operator|<
name|amp
operator|->
name|am_nextents
argument_list|)
expr_stmt|;
name|modified
operator|=
name|false
expr_stmt|;
name|reqs
operator|=
name|ext2reqs
argument_list|(
name|amp
argument_list|,
name|extent
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_memtab
index|[
name|extent
index|]
operator|>=
name|reqs
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_memtab
index|[
name|extent
index|]
operator|-=
name|reqs
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|bit_test
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|extent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amp
operator|->
name|am_memtab
index|[
name|extent
index|]
operator|==
literal|0
condition|)
block|{
name|bit_clear
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|extent
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_ndirty
operator|--
expr_stmt|;
name|modified
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|modified
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function returns number of dirty regions.  */
end_comment

begin_function
name|uint64_t
name|activemap_ndirty
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
return|return
operator|(
name|amp
operator|->
name|am_ndirty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function compare on-disk bitmap and in-memory bitmap and returns true if  * they differ and should be flushed to the disk.  */
end_comment

begin_function
name|bool
name|activemap_differ
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
return|return
operator|(
name|memcmp
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|,
name|amp
operator|->
name|am_memmap
argument_list|,
name|amp
operator|->
name|am_mapsize
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function returns number of bytes used by bitmap.  */
end_comment

begin_function
name|size_t
name|activemap_size
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
return|return
operator|(
name|amp
operator|->
name|am_mapsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function returns number of bytes needed for storing on-disk bitmap.  * This is the same as activemap_size(), but rounded up to sector size.  */
end_comment

begin_function
name|size_t
name|activemap_ondisk_size
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
return|return
operator|(
name|amp
operator|->
name|am_diskmapsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function copies the given buffer read from disk to the internal bitmap.  */
end_comment

begin_function
name|void
name|activemap_copyin
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ext
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|size
operator|>=
name|amp
operator|->
name|am_mapsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|,
name|buf
argument_list|,
name|amp
operator|->
name|am_mapsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|buf
argument_list|,
name|amp
operator|->
name|am_mapsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|buf
argument_list|,
name|amp
operator|->
name|am_mapsize
argument_list|)
expr_stmt|;
name|bit_ffs
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|amp
operator|->
name|am_nextents
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* There are no dirty extents, so we can leave now. */
return|return;
block|}
comment|/* 	 * Set synchronization offset to the first dirty extent. 	 */
name|activemap_sync_rewind
argument_list|(
name|amp
argument_list|)
expr_stmt|;
comment|/* 	 * We have dirty extents and we want them to stay that way until 	 * we synchronize, so we set number of pending writes to number 	 * of requests needed to synchronize one extent. 	 */
name|amp
operator|->
name|am_ndirty
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|ext
operator|<
name|amp
operator|->
name|am_nextents
condition|;
name|ext
operator|++
control|)
block|{
if|if
condition|(
name|bit_test
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
condition|)
block|{
name|amp
operator|->
name|am_memtab
index|[
name|ext
index|]
operator|=
name|ext2reqs
argument_list|(
name|amp
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_ndirty
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Function merges the given bitmap with existing one.  */
end_comment

begin_function
name|void
name|activemap_merge
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bitstr_t
modifier|*
name|remmap
init|=
name|__DECONST
argument_list|(
name|bitstr_t
operator|*
argument_list|,
name|buf
argument_list|)
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|size
operator|>=
name|amp
operator|->
name|am_mapsize
argument_list|)
expr_stmt|;
name|bit_ffs
argument_list|(
name|remmap
argument_list|,
name|amp
operator|->
name|am_nextents
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* There are no dirty extents, so we can leave now. */
return|return;
block|}
comment|/* 	 * We have dirty extents and we want them to stay that way until 	 * we synchronize, so we set number of pending writes to number 	 * of requests needed to synchronize one extent. 	 */
for|for
control|(
init|;
name|ext
operator|<
name|amp
operator|->
name|am_nextents
condition|;
name|ext
operator|++
control|)
block|{
comment|/* Local extent already dirty. */
if|if
condition|(
name|bit_test
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|ext
argument_list|)
condition|)
continue|continue;
comment|/* Remote extent isn't dirty. */
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|remmap
argument_list|,
name|ext
argument_list|)
condition|)
continue|continue;
name|bit_set
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|amp
operator|->
name|am_memtab
index|[
name|ext
index|]
operator|==
literal|0
condition|)
name|amp
operator|->
name|am_ndirty
operator|++
expr_stmt|;
name|amp
operator|->
name|am_memtab
index|[
name|ext
index|]
operator|=
name|ext2reqs
argument_list|(
name|amp
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set synchronization offset to the first dirty extent. 	 */
name|activemap_sync_rewind
argument_list|(
name|amp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function returns pointer to internal bitmap that should be written to disk.  */
end_comment

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|activemap_bitmap
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|=
name|amp
operator|->
name|am_diskmapsize
expr_stmt|;
name|memcpy
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|,
name|amp
operator|->
name|am_memmap
argument_list|,
name|amp
operator|->
name|am_mapsize
argument_list|)
expr_stmt|;
name|keepdirty_fill
argument_list|(
name|amp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|amp
operator|->
name|am_diskmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function calculates size needed to store bitmap on disk.  */
end_comment

begin_function
name|size_t
name|activemap_calc_ondisk_size
parameter_list|(
name|uint64_t
name|mediasize
parameter_list|,
name|uint32_t
name|extentsize
parameter_list|,
name|uint32_t
name|sectorsize
parameter_list|)
block|{
name|uint64_t
name|nextents
decl_stmt|,
name|mapsize
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|mediasize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|extentsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|powerof2
argument_list|(
name|extentsize
argument_list|)
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|sectorsize
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|powerof2
argument_list|(
name|sectorsize
argument_list|)
argument_list|)
expr_stmt|;
name|nextents
operator|=
operator|(
operator|(
name|mediasize
operator|-
literal|1
operator|)
operator|/
name|extentsize
operator|)
operator|+
literal|1
expr_stmt|;
name|mapsize
operator|=
sizeof|sizeof
argument_list|(
name|bitstr_t
argument_list|)
operator|*
name|bitstr_size
argument_list|(
name|nextents
argument_list|)
expr_stmt|;
return|return
operator|(
name|roundup2
argument_list|(
name|mapsize
argument_list|,
name|sectorsize
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set synchronization offset to the first dirty extent.  */
end_comment

begin_function
name|void
name|activemap_sync_rewind
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|int
name|ext
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|bit_ffs
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|amp
operator|->
name|am_nextents
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* There are no extents to synchronize. */
name|amp
operator|->
name|am_syncoff
operator|=
operator|-
literal|2
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mark that we want to start synchronization from the beginning. 	 */
name|amp
operator|->
name|am_syncoff
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return next offset of where we should synchronize.  */
end_comment

begin_function
name|off_t
name|activemap_sync_offset
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|off_t
modifier|*
name|lengthp
parameter_list|,
name|int
modifier|*
name|syncextp
parameter_list|)
block|{
name|off_t
name|syncoff
decl_stmt|,
name|left
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|lengthp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|syncextp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|syncextp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|amp
operator|->
name|am_syncoff
operator|==
operator|-
literal|2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|amp
operator|->
name|am_syncoff
operator|>=
literal|0
operator|&&
operator|(
name|amp
operator|->
name|am_syncoff
operator|+
name|MAXPHYS
operator|>=
name|amp
operator|->
name|am_mediasize
operator|||
name|off2ext
argument_list|(
name|amp
argument_list|,
name|amp
operator|->
name|am_syncoff
argument_list|)
operator|!=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|amp
operator|->
name|am_syncoff
operator|+
name|MAXPHYS
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * We are about to change extent, so mark previous one as clean. 		 */
name|ext
operator|=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|amp
operator|->
name|am_syncoff
argument_list|)
expr_stmt|;
name|bit_clear
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
operator|*
name|syncextp
operator|=
name|ext
expr_stmt|;
name|amp
operator|->
name|am_syncoff
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|amp
operator|->
name|am_syncoff
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Let's find first extent to synchronize. 		 */
name|bit_ffs
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|amp
operator|->
name|am_nextents
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
operator|-
literal|1
condition|)
block|{
name|amp
operator|->
name|am_syncoff
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|amp
operator|->
name|am_syncoff
operator|=
name|ext2off
argument_list|(
name|amp
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't change extent, so just increase offset. 		 */
name|amp
operator|->
name|am_syncoff
operator|+=
name|MAXPHYS
expr_stmt|;
if|if
condition|(
name|amp
operator|->
name|am_syncoff
operator|>=
name|amp
operator|->
name|am_mediasize
condition|)
block|{
name|amp
operator|->
name|am_syncoff
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|syncoff
operator|=
name|amp
operator|->
name|am_syncoff
expr_stmt|;
name|left
operator|=
name|ext2off
argument_list|(
name|amp
argument_list|,
name|off2ext
argument_list|(
name|amp
argument_list|,
name|syncoff
argument_list|)
argument_list|)
operator|+
name|amp
operator|->
name|am_extentsize
operator|-
name|syncoff
expr_stmt|;
if|if
condition|(
name|syncoff
operator|+
name|left
operator|>
name|amp
operator|->
name|am_mediasize
condition|)
name|left
operator|=
name|amp
operator|->
name|am_mediasize
operator|-
name|syncoff
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|MAXPHYS
condition|)
name|left
operator|=
name|MAXPHYS
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|left
operator|>=
literal|0
operator|&&
name|left
operator|<=
name|MAXPHYS
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|syncoff
operator|>=
literal|0
operator|&&
name|syncoff
operator|<
name|amp
operator|->
name|am_mediasize
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|syncoff
operator|+
name|left
operator|>=
literal|0
operator|&&
name|syncoff
operator|+
name|left
operator|<=
name|amp
operator|->
name|am_mediasize
argument_list|)
expr_stmt|;
operator|*
name|lengthp
operator|=
name|left
expr_stmt|;
return|return
operator|(
name|syncoff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark extent(s) containing the given region for synchronization.  * Most likely one of the components is unavailable.  */
end_comment

begin_function
name|bool
name|activemap_need_sync
parameter_list|(
name|struct
name|activemap
modifier|*
name|amp
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|length
parameter_list|)
block|{
name|bool
name|modified
decl_stmt|;
name|off_t
name|end
decl_stmt|;
name|int
name|ext
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|amp
operator|->
name|am_magic
operator|==
name|ACTIVEMAP_MAGIC
argument_list|)
expr_stmt|;
name|modified
operator|=
name|false
expr_stmt|;
name|end
operator|=
name|offset
operator|+
name|length
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ext
operator|=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|offset
argument_list|)
init|;
name|ext
operator|<=
name|off2ext
argument_list|(
name|amp
argument_list|,
name|end
argument_list|)
condition|;
name|ext
operator|++
control|)
block|{
if|if
condition|(
name|bit_test
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|ext
argument_list|)
condition|)
block|{
comment|/* Already marked for synchronization. */
name|PJDLOG_ASSERT
argument_list|(
name|bit_test
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bit_set
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
condition|)
block|{
name|bit_set
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|amp
operator|->
name|am_ndirty
operator|++
expr_stmt|;
block|}
name|amp
operator|->
name|am_memtab
index|[
name|ext
index|]
operator|+=
name|ext2reqs
argument_list|(
name|amp
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|modified
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|modified
operator|)
return|;
block|}
end_function

begin_function
name|void
name|activemap_dump
parameter_list|(
specifier|const
name|struct
name|activemap
modifier|*
name|amp
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
name|printf
argument_list|(
literal|"M: "
argument_list|)
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|amp
operator|->
name|am_nextents
condition|;
name|bit
operator|++
control|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|bit_test
argument_list|(
name|amp
operator|->
name|am_memmap
argument_list|,
name|bit
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"D: "
argument_list|)
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|amp
operator|->
name|am_nextents
condition|;
name|bit
operator|++
control|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|bit_test
argument_list|(
name|amp
operator|->
name|am_diskmap
argument_list|,
name|bit
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"S: "
argument_list|)
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|amp
operator|->
name|am_nextents
condition|;
name|bit
operator|++
control|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|bit_test
argument_list|(
name|amp
operator|->
name|am_syncmap
argument_list|,
name|bit
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

