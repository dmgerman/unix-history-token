begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *  *  ntpSnmpSubAgentObject.c  *  *  This file provides the callback functions for net-snmp and registers the   *  serviced MIB objects with the master agent.  *   *  Each object has its own callback function that is called by the   *  master agent process whenever someone queries the corresponding MIB  *  object.   *   *  At the moment this triggers a full send/receive procedure for each  *  queried MIB object, one of the things that are still on my todo list:  *  a caching mechanism that reduces the number of requests sent to the  *  ntpd process.  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<ntp_snmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<ntp.h>
end_include

begin_include
include|#
directive|include
file|<libntpq.h>
end_include

begin_comment
comment|/* general purpose buffer length definition */
end_comment

begin_define
define|#
directive|define
name|NTPQ_BUFLEN
value|2048
end_define

begin_decl_stmt
name|char
name|ntpvalue
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************  *  * ntpsnmpd_parse_string  *  *  This function will parse a given NULL terminated string and cut it  *  into a fieldname and a value part (using the '=' as the delimiter.   *  The fieldname will be converted to uppercase and all whitespace   *  characters are removed from it.  *  The value part is stripped, e.g. all whitespace characters are removed  *  from the beginning and end of the string.  *  If the value is started and ended with quotes ("), they will be removed  *  and everything between the quotes is left untouched (including   *  whitespace)  *  Example:  *     server host name =   hello world!  *  will result in a field string "SERVERHOSTNAME" and a value  *  of "hello world!".  *     My first Parameter		=		"  is this!    "   * results in a field string "MYFIRSTPARAMETER" and a value " is this!    "  ****************************************************************************  * Parameters:  *	string		const char *	The source string to parse.  *					NOTE: must be NULL terminated!  *	field		char *		The buffer for the field name.  *	fieldsize	size_t		The size of the field buffer.  *	value		char *		The buffer for the value.  *	valuesize	size_t		The size of the value buffer.  *  * Returns:  *	size_t			length of value string   ****************************************************************************/
end_comment

begin_function
name|size_t
name|ntpsnmpd_parse_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|field
parameter_list|,
name|size_t
name|fieldsize
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|size_t
name|valuesize
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|size_t
name|str_cnt
decl_stmt|;
name|size_t
name|val_cnt
decl_stmt|;
comment|/* we need at least one byte to work with to simplify */
if|if
condition|(
name|fieldsize
operator|<
literal|1
operator|||
name|valuesize
operator|<
literal|1
condition|)
return|return
literal|0
return|;
name|str_cnt
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* Parsing the field name */
name|j
operator|=
literal|0
expr_stmt|;
name|loop
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|loop
operator|&&
name|i
operator|<=
name|str_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|string
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\t'
case|:
comment|/* Tab */
case|case
literal|'\n'
case|:
comment|/* LF */
case|case
literal|'\r'
case|:
comment|/* CR */
case|case
literal|' '
case|:
comment|/* Space */
break|break;
case|case
literal|'='
case|:
name|loop
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|j
operator|<
name|fieldsize
condition|)
name|field
index|[
name|j
operator|++
index|]
operator|=
name|toupper
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|j
operator|=
name|min
argument_list|(
name|j
argument_list|,
name|fieldsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|field
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now parsing the value */
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|val_cnt
operator|=
literal|0
init|;
name|i
operator|<
name|str_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|>
literal|0x0D
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
name|val_cnt
operator|=
name|min
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|valuesize
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
operator|(
name|string
index|[
name|i
index|]
operator|>
literal|0x0D
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
if|if
condition|(
name|j
operator|<
name|valuesize
condition|)
name|value
index|[
name|j
operator|++
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|value
index|[
name|val_cnt
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
block|{
name|val_cnt
operator|--
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
operator|&
name|value
index|[
literal|1
index|]
argument_list|,
name|valuesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|val_cnt
operator|>
literal|0
operator|&&
name|value
index|[
name|val_cnt
operator|-
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
name|val_cnt
operator|--
expr_stmt|;
name|value
index|[
name|val_cnt
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
return|return
name|val_cnt
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  * ntpsnmpd_cut_string  *  *  This function will parse a given NULL terminated string and cut it  *  into fields using the specified delimiter character.   *  It will then copy the requested field into a destination buffer  *  Example:  *     ntpsnmpd_cut_string(read:my:lips:fool, RESULT, ':', 2, sizeof(RESULT))  *  will copy "lips" to RESULT.  ****************************************************************************  * Parameters:  *	src		const char *	The name of the source string variable  *					NOTE: must be NULL terminated!  *	dest		char *		The name of the string which takes the  *					requested field content  * 	delim		char		The delimiter character  *	fieldnumber	int		The number of the required field  *					(start counting with 0)  *	maxsize		size_t		The maximum size of dest  *  * Returns:  *	size_t		length of resulting dest string   ****************************************************************************/
end_comment

begin_function
name|size_t
name|ntpsnmpd_cut_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|char
name|delim
parameter_list|,
name|int
name|fieldnumber
parameter_list|,
name|size_t
name|maxsize
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|int
name|l
decl_stmt|;
name|size_t
name|str_cnt
decl_stmt|;
if|if
condition|(
name|maxsize
operator|<
literal|1
condition|)
return|return
literal|0
return|;
name|str_cnt
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
comment|/* Parsing the field name */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|l
operator|=
literal|0
init|;
name|i
operator|<
name|str_cnt
operator|&&
name|l
operator|<=
name|fieldnumber
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|delim
condition|)
name|l
operator|++
expr_stmt|;
comment|/* next field */
elseif|else
if|if
condition|(
name|l
operator|==
name|fieldnumber
operator|&&
name|j
operator|<
name|maxsize
condition|)
name|dest
index|[
name|j
operator|++
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
block|}
name|j
operator|=
name|min
argument_list|(
name|j
argument_list|,
name|maxsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dest
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  read_ntp_value  *  *  This function retrieves the value for a given variable, currently  *  this only supports sysvars. It starts a full mode 6 send/receive/parse  *  iteration and needs to be optimized, e.g. by using a caching mechanism  *    ****************************************************************************  * Parameters:  *	variable	char*	The name of the required variable  *	rbuffer		char*	The buffer where the value goes  *	maxlength	int	Max. number of bytes for resultbuf  *  * Returns:  *	u_int		number of chars that have been copied to   *			rbuffer   ****************************************************************************/
end_comment

begin_function
name|size_t
name|read_ntp_value
parameter_list|(
specifier|const
name|char
modifier|*
name|variable
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|size_t
name|valuesize
parameter_list|)
block|{
name|size_t
name|sv_len
decl_stmt|;
name|char
name|sv_data
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
name|memset
argument_list|(
name|sv_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sv_data
argument_list|)
argument_list|)
expr_stmt|;
name|sv_len
operator|=
name|ntpq_read_sysvars
argument_list|(
name|sv_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sv_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|sv_len
condition|)
return|return
literal|0
return|;
else|else
return|return
name|ntpq_getvar
argument_list|(
name|sv_data
argument_list|,
name|sv_len
argument_list|,
name|variable
argument_list|,
name|value
argument_list|,
name|valuesize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  *  *  The get_xxx functions  *  *  The following function calls are callback functions that will be   *  used by the master agent process to retrieve a value for a requested   *  MIB object.   *  ****************************************************************************/
end_comment

begin_function
name|int
name|get_ntpEntSoftwareName
parameter_list|(
name|netsnmp_mib_handler
modifier|*
name|handler
parameter_list|,
name|netsnmp_handler_registration
modifier|*
name|reginfo
parameter_list|,
name|netsnmp_agent_request_info
modifier|*
name|reqinfo
parameter_list|,
name|netsnmp_request_info
modifier|*
name|requests
parameter_list|)
block|{
name|char
name|ntp_softwarename
index|[
name|NTPQ_BUFLEN
index|]
decl_stmt|;
name|memset
argument_list|(
name|ntp_softwarename
argument_list|,
literal|0
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reqinfo
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_GET
case|:
block|{
if|if
condition|(
name|read_ntp_value
argument_list|(
literal|"product"
argument_list|,
name|ntpvalue
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
condition|)
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ntpvalue
argument_list|,
name|strlen
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|read_ntp_value
argument_list|(
literal|"version"
argument_list|,
name|ntpvalue
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
condition|)
block|{
name|ntpsnmpd_cut_string
argument_list|(
name|ntpvalue
argument_list|,
name|ntp_softwarename
argument_list|,
literal|' '
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ntp_softwarename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ntp_softwarename
argument_list|,
name|strlen
argument_list|(
name|ntp_softwarename
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"N/A"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|/* If we cannot get the information we need, we will return a generic error to the SNMP client */
return|return
name|SNMP_ERR_GENERR
return|;
block|}
return|return
name|SNMP_ERR_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|get_ntpEntSoftwareVersion
parameter_list|(
name|netsnmp_mib_handler
modifier|*
name|handler
parameter_list|,
name|netsnmp_handler_registration
modifier|*
name|reginfo
parameter_list|,
name|netsnmp_agent_request_info
modifier|*
name|reqinfo
parameter_list|,
name|netsnmp_request_info
modifier|*
name|requests
parameter_list|)
block|{
switch|switch
condition|(
name|reqinfo
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_GET
case|:
block|{
if|if
condition|(
name|read_ntp_value
argument_list|(
literal|"version"
argument_list|,
name|ntpvalue
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
condition|)
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ntpvalue
argument_list|,
name|strlen
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"N/A"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|/* If we cannot get the information we need, we will return a generic error to the SNMP client */
return|return
name|SNMP_ERR_GENERR
return|;
block|}
return|return
name|SNMP_ERR_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|get_ntpEntSoftwareVendor
parameter_list|(
name|netsnmp_mib_handler
modifier|*
name|handler
parameter_list|,
name|netsnmp_handler_registration
modifier|*
name|reginfo
parameter_list|,
name|netsnmp_agent_request_info
modifier|*
name|reqinfo
parameter_list|,
name|netsnmp_request_info
modifier|*
name|requests
parameter_list|)
block|{
switch|switch
condition|(
name|reqinfo
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_GET
case|:
block|{
if|if
condition|(
name|read_ntp_value
argument_list|(
literal|"vendor"
argument_list|,
name|ntpvalue
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
condition|)
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ntpvalue
argument_list|,
name|strlen
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"N/A"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* If we cannot get the information we need, we will return a generic error to the SNMP client */
return|return
name|SNMP_ERR_GENERR
return|;
block|}
block|}
return|return
name|SNMP_ERR_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|get_ntpEntSystemType
parameter_list|(
name|netsnmp_mib_handler
modifier|*
name|handler
parameter_list|,
name|netsnmp_handler_registration
modifier|*
name|reginfo
parameter_list|,
name|netsnmp_agent_request_info
modifier|*
name|reqinfo
parameter_list|,
name|netsnmp_request_info
modifier|*
name|requests
parameter_list|)
block|{
switch|switch
condition|(
name|reqinfo
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_GET
case|:
block|{
if|if
condition|(
name|read_ntp_value
argument_list|(
literal|"systemtype"
argument_list|,
name|ntpvalue
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
condition|)
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ntpvalue
argument_list|,
name|strlen
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read_ntp_value
argument_list|(
literal|"system"
argument_list|,
name|ntpvalue
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
condition|)
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ntpvalue
argument_list|,
name|strlen
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"N/A"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|/* If we cannot get the information we need, we will return a generic error to the SNMP client */
return|return
name|SNMP_ERR_GENERR
return|;
block|}
return|return
name|SNMP_ERR_NOERROR
return|;
block|}
end_function

begin_comment
comment|/*  * ntpEntTimeResolution  *	"The time resolution in integer format, where the resolution  *	 is represented as divisions of a second, e.g., a value of 1000  *	 translates to 1.0 ms."  *  * ntpEntTimeResolution is a challenge for ntpd, as the resolution is  * not known nor exposed by ntpd, only the measured precision (time to  * read the clock).  *  * Logically the resolution must be at least the precision, so report  * it as our best approximation of resolution until/unless ntpd provides  * better.  */
end_comment

begin_function
name|int
name|get_ntpEntTimeResolution
parameter_list|(
name|netsnmp_mib_handler
modifier|*
name|handler
parameter_list|,
name|netsnmp_handler_registration
modifier|*
name|reginfo
parameter_list|,
name|netsnmp_agent_request_info
modifier|*
name|reqinfo
parameter_list|,
name|netsnmp_request_info
modifier|*
name|requests
parameter_list|)
block|{
name|int
name|precision
decl_stmt|;
name|u_int32
name|resolution
decl_stmt|;
switch|switch
condition|(
name|reqinfo
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_GET
case|:
if|if
condition|(
operator|!
name|read_ntp_value
argument_list|(
literal|"precision"
argument_list|,
name|ntpvalue
argument_list|,
sizeof|sizeof
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
condition|)
return|return
name|SNMP_ERR_GENERR
return|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|ntpvalue
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|precision
argument_list|)
condition|)
return|return
name|SNMP_ERR_GENERR
return|;
if|if
condition|(
name|precision
operator|>=
literal|0
condition|)
return|return
name|SNMP_ERR_GENERR
return|;
name|precision
operator|=
name|max
argument_list|(
name|precision
argument_list|,
operator|-
literal|31
argument_list|)
expr_stmt|;
name|resolution
operator|=
literal|1
operator|<<
operator|-
name|precision
expr_stmt|;
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_UNSIGNED
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|resolution
argument_list|,
sizeof|sizeof
argument_list|(
name|resolution
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|SNMP_ERR_GENERR
return|;
block|}
return|return
name|SNMP_ERR_NOERROR
return|;
block|}
end_function

begin_comment
comment|/*  * ntpEntTimePrecision  *	"The entity's precision in integer format, shows the precision.  *	 A value of -5 would mean 2^-5 = 31.25 ms."  */
end_comment

begin_function
name|int
name|get_ntpEntTimePrecision
parameter_list|(
name|netsnmp_mib_handler
modifier|*
name|handler
parameter_list|,
name|netsnmp_handler_registration
modifier|*
name|reginfo
parameter_list|,
name|netsnmp_agent_request_info
modifier|*
name|reqinfo
parameter_list|,
name|netsnmp_request_info
modifier|*
name|requests
parameter_list|)
block|{
name|int
name|precision
decl_stmt|;
name|int32
name|precision32
decl_stmt|;
switch|switch
condition|(
name|reqinfo
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_GET
case|:
if|if
condition|(
operator|!
name|read_ntp_value
argument_list|(
literal|"precision"
argument_list|,
name|ntpvalue
argument_list|,
sizeof|sizeof
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
condition|)
return|return
name|SNMP_ERR_GENERR
return|;
if|if
condition|(
literal|1
operator|!=
name|sscanf
argument_list|(
name|ntpvalue
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|precision
argument_list|)
condition|)
return|return
name|SNMP_ERR_GENERR
return|;
name|precision32
operator|=
operator|(
name|int32
operator|)
name|precision
expr_stmt|;
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_INTEGER
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|precision32
argument_list|,
sizeof|sizeof
argument_list|(
name|precision32
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|SNMP_ERR_GENERR
return|;
block|}
return|return
name|SNMP_ERR_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|get_ntpEntTimeDistance
parameter_list|(
name|netsnmp_mib_handler
modifier|*
name|handler
parameter_list|,
name|netsnmp_handler_registration
modifier|*
name|reginfo
parameter_list|,
name|netsnmp_agent_request_info
modifier|*
name|reqinfo
parameter_list|,
name|netsnmp_request_info
modifier|*
name|requests
parameter_list|)
block|{
switch|switch
condition|(
name|reqinfo
operator|->
name|mode
condition|)
block|{
case|case
name|MODE_GET
case|:
block|{
if|if
condition|(
name|read_ntp_value
argument_list|(
literal|"rootdelay"
argument_list|,
name|ntpvalue
argument_list|,
name|NTPQ_BUFLEN
argument_list|)
condition|)
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ntpvalue
argument_list|,
name|strlen
argument_list|(
name|ntpvalue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snmp_set_var_typed_value
argument_list|(
name|requests
operator|->
name|requestvb
argument_list|,
name|ASN_OCTET_STR
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"N/A"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|/* If we cannot get the information we need, we will return a generic error to the SNMP client */
return|return
name|SNMP_ERR_GENERR
return|;
block|}
return|return
name|SNMP_ERR_NOERROR
return|;
block|}
end_function

begin_comment
comment|/*  *  * Initialize sub agent  */
end_comment

begin_function
name|void
name|init_ntpSnmpSubagentObject
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Register all MIB objects with the agentx master */
name|NTP_OID_RO
argument_list|(
name|ntpEntSoftwareName
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NTP_OID_RO
argument_list|(
name|ntpEntSoftwareVersion
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NTP_OID_RO
argument_list|(
name|ntpEntSoftwareVendor
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NTP_OID_RO
argument_list|(
name|ntpEntSystemType
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NTP_OID_RO
argument_list|(
name|ntpEntTimeResolution
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NTP_OID_RO
argument_list|(
name|ntpEntTimePrecision
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NTP_OID_RO
argument_list|(
name|ntpEntTimeDistance
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

