begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2001 NETLAB, Temple University  * Copyright (c) 2001 Protocol Engineering Lab, University of Delaware  *  * Jerry Heinz<gheinz@astro.temple.edu>  * John Fiore<jfiore@joda.cis.temple.edu>  * Armando L. Caro Jr.<acaro@cis.udel.edu>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|NETDISSECT_REWORKED
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_comment
comment|/* must come after interface.h */
end_comment

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|"ip6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Definitions from:  *  * SCTP reference Implementation Copyright (C) 1999 Cisco And Motorola  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of Cisco nor of Motorola may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This file is part of the SCTP reference Implementation  *  *  * Please send any bug reports or fixes you make to one of the following email  * addresses:  *  * rstewar1@email.mot.com  * kmorneau@cisco.com  * qxie1@email.mot.com  *  * Any bugs reported given to us we will try to fix... any fixes shared will  * be incorperated into the next SCTP release.  */
end_comment

begin_comment
comment|/* The valid defines for all message  * types know to SCTP. 0 is reserved  */
end_comment

begin_define
define|#
directive|define
name|SCTP_DATA
value|0x00
end_define

begin_define
define|#
directive|define
name|SCTP_INITIATION
value|0x01
end_define

begin_define
define|#
directive|define
name|SCTP_INITIATION_ACK
value|0x02
end_define

begin_define
define|#
directive|define
name|SCTP_SELECTIVE_ACK
value|0x03
end_define

begin_define
define|#
directive|define
name|SCTP_HEARTBEAT_REQUEST
value|0x04
end_define

begin_define
define|#
directive|define
name|SCTP_HEARTBEAT_ACK
value|0x05
end_define

begin_define
define|#
directive|define
name|SCTP_ABORT_ASSOCIATION
value|0x06
end_define

begin_define
define|#
directive|define
name|SCTP_SHUTDOWN
value|0x07
end_define

begin_define
define|#
directive|define
name|SCTP_SHUTDOWN_ACK
value|0x08
end_define

begin_define
define|#
directive|define
name|SCTP_OPERATION_ERR
value|0x09
end_define

begin_define
define|#
directive|define
name|SCTP_COOKIE_ECHO
value|0x0a
end_define

begin_define
define|#
directive|define
name|SCTP_COOKIE_ACK
value|0x0b
end_define

begin_define
define|#
directive|define
name|SCTP_ECN_ECHO
value|0x0c
end_define

begin_define
define|#
directive|define
name|SCTP_ECN_CWR
value|0x0d
end_define

begin_define
define|#
directive|define
name|SCTP_SHUTDOWN_COMPLETE
value|0x0e
end_define

begin_define
define|#
directive|define
name|SCTP_FORWARD_CUM_TSN
value|0xc0
end_define

begin_define
define|#
directive|define
name|SCTP_RELIABLE_CNTL
value|0xc1
end_define

begin_define
define|#
directive|define
name|SCTP_RELIABLE_CNTL_ACK
value|0xc2
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|sctp_chunkid_str
index|[]
init|=
block|{
block|{
name|SCTP_DATA
block|,
literal|"DATA"
block|}
block|,
block|{
name|SCTP_INITIATION
block|,
literal|"INIT"
block|}
block|,
block|{
name|SCTP_INITIATION_ACK
block|,
literal|"INIT ACK"
block|}
block|,
block|{
name|SCTP_SELECTIVE_ACK
block|,
literal|"SACK"
block|}
block|,
block|{
name|SCTP_HEARTBEAT_REQUEST
block|,
literal|"HB REQ"
block|}
block|,
block|{
name|SCTP_HEARTBEAT_ACK
block|,
literal|"HB ACK"
block|}
block|,
block|{
name|SCTP_ABORT_ASSOCIATION
block|,
literal|"ABORT"
block|}
block|,
block|{
name|SCTP_SHUTDOWN
block|,
literal|"SHUTDOWN"
block|}
block|,
block|{
name|SCTP_SHUTDOWN_ACK
block|,
literal|"SHUTDOWN ACK"
block|}
block|,
block|{
name|SCTP_OPERATION_ERR
block|,
literal|"OP ERR"
block|}
block|,
block|{
name|SCTP_COOKIE_ECHO
block|,
literal|"COOKIE ECHO"
block|}
block|,
block|{
name|SCTP_COOKIE_ACK
block|,
literal|"COOKIE ACK"
block|}
block|,
block|{
name|SCTP_ECN_ECHO
block|,
literal|"ECN ECHO"
block|}
block|,
block|{
name|SCTP_ECN_CWR
block|,
literal|"ECN CWR"
block|}
block|,
block|{
name|SCTP_SHUTDOWN_COMPLETE
block|,
literal|"SHUTDOWN COMPLETE"
block|}
block|,
block|{
name|SCTP_FORWARD_CUM_TSN
block|,
literal|"FOR CUM TSN"
block|}
block|,
block|{
name|SCTP_RELIABLE_CNTL
block|,
literal|"REL CTRL"
block|}
block|,
block|{
name|SCTP_RELIABLE_CNTL_ACK
block|,
literal|"REL CTRL ACK"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data Chuck Specific Flags */
end_comment

begin_define
define|#
directive|define
name|SCTP_DATA_FRAG_MASK
value|0x03
end_define

begin_define
define|#
directive|define
name|SCTP_DATA_MIDDLE_FRAG
value|0x00
end_define

begin_define
define|#
directive|define
name|SCTP_DATA_LAST_FRAG
value|0x01
end_define

begin_define
define|#
directive|define
name|SCTP_DATA_FIRST_FRAG
value|0x02
end_define

begin_define
define|#
directive|define
name|SCTP_DATA_NOT_FRAG
value|0x03
end_define

begin_define
define|#
directive|define
name|SCTP_DATA_UNORDERED
value|0x04
end_define

begin_define
define|#
directive|define
name|SCTP_ADDRMAX
value|60
end_define

begin_define
define|#
directive|define
name|CHAN_HP
value|6704
end_define

begin_define
define|#
directive|define
name|CHAN_MP
value|6705
end_define

begin_define
define|#
directive|define
name|CHAN_LP
value|6706
end_define

begin_comment
comment|/* the sctp common header */
end_comment

begin_struct
struct|struct
name|sctpHeader
block|{
name|uint16_t
name|source
decl_stmt|;
name|uint16_t
name|destination
decl_stmt|;
name|uint32_t
name|verificationTag
decl_stmt|;
name|uint32_t
name|adler32
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* various descriptor parsers */
end_comment

begin_struct
struct|struct
name|sctpChunkDesc
block|{
name|uint8_t
name|chunkID
decl_stmt|;
name|uint8_t
name|chunkFlg
decl_stmt|;
name|uint16_t
name|chunkLength
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpParamDesc
block|{
name|uint16_t
name|paramType
decl_stmt|;
name|uint16_t
name|paramLength
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpRelChunkDesc
block|{
name|struct
name|sctpChunkDesc
name|chk
decl_stmt|;
name|uint32_t
name|serialNumber
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpVendorSpecificParam
block|{
name|struct
name|sctpParamDesc
name|p
decl_stmt|;
comment|/* type must be 0xfffe */
name|uint32_t
name|vendorId
decl_stmt|;
comment|/* vendor ID from RFC 1700 */
name|uint16_t
name|vendorSpecificType
decl_stmt|;
name|uint16_t
name|vendorSpecificLen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structures for the control parts */
end_comment

begin_comment
comment|/* Sctp association init request/ack */
end_comment

begin_comment
comment|/* this is used for init ack, too */
end_comment

begin_struct
struct|struct
name|sctpInitiation
block|{
name|uint32_t
name|initTag
decl_stmt|;
comment|/* tag of mine */
name|uint32_t
name|rcvWindowCredit
decl_stmt|;
comment|/* rwnd */
name|uint16_t
name|NumPreopenStreams
decl_stmt|;
comment|/* OS */
name|uint16_t
name|MaxInboundStreams
decl_stmt|;
comment|/* MIS */
name|uint32_t
name|initialTSN
decl_stmt|;
comment|/* optional param's follow in sctpParamDesc form */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpV4IpAddress
block|{
name|struct
name|sctpParamDesc
name|p
decl_stmt|;
comment|/* type is set to SCTP_IPV4_PARAM_TYPE, len=10 */
name|uint32_t
name|ipAddress
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpV6IpAddress
block|{
name|struct
name|sctpParamDesc
name|p
decl_stmt|;
comment|/* type is set to SCTP_IPV6_PARAM_TYPE, len=22 */
name|uint8_t
name|ipAddress
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpDNSName
block|{
name|struct
name|sctpParamDesc
name|param
decl_stmt|;
name|uint8_t
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpCookiePreserve
block|{
name|struct
name|sctpParamDesc
name|p
decl_stmt|;
comment|/* type is set to SCTP_COOKIE_PRESERVE, len=8 */
name|uint32_t
name|extraTime
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpTimeStamp
block|{
name|uint32_t
name|ts_sec
decl_stmt|;
name|uint32_t
name|ts_usec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* wire structure of my cookie */
end_comment

begin_struct
struct|struct
name|cookieMessage
block|{
name|uint32_t
name|TieTag_curTag
decl_stmt|;
comment|/* copied from assoc if present */
name|uint32_t
name|TieTag_hisTag
decl_stmt|;
comment|/* copied from assoc if present */
name|int32_t
name|cookieLife
decl_stmt|;
comment|/* life I will award this cookie */
name|struct
name|sctpTimeStamp
name|timeEnteringState
decl_stmt|;
comment|/* the time I built cookie */
name|struct
name|sctpInitiation
name|initAckISent
decl_stmt|;
comment|/* the INIT-ACK that I sent to my peer */
name|uint32_t
name|addressWhereISent
index|[
literal|4
index|]
decl_stmt|;
comment|/* I make this 4 ints so I get 128bits for future */
name|int32_t
name|addrtype
decl_stmt|;
comment|/* address type */
name|uint16_t
name|locScope
decl_stmt|;
comment|/* V6 local scope flag */
name|uint16_t
name|siteScope
decl_stmt|;
comment|/* V6 site scope flag */
comment|/* at the end is tacked on the INIT chunk sent in    * its entirety and of course our    * signature.    */
block|}
struct|;
end_struct

begin_comment
comment|/* this guy is for use when  * I have a initiate message gloming the  * things together.   */
end_comment

begin_struct
struct|struct
name|sctpUnifiedInit
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|struct
name|sctpInitiation
name|initm
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpSendableInit
block|{
name|struct
name|sctpHeader
name|mh
decl_stmt|;
name|struct
name|sctpUnifiedInit
name|msg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Selective Acknowledgement  * has the following structure with  * a optional ammount of trailing int's  * on the last part (based on the numberOfDesc  * field).  */
end_comment

begin_struct
struct|struct
name|sctpSelectiveAck
block|{
name|uint32_t
name|highestConseqTSN
decl_stmt|;
name|uint32_t
name|updatedRwnd
decl_stmt|;
name|uint16_t
name|numberOfdesc
decl_stmt|;
name|uint16_t
name|numDupTsns
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpSelectiveFrag
block|{
name|uint16_t
name|fragmentStart
decl_stmt|;
name|uint16_t
name|fragmentEnd
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpUnifiedSack
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|struct
name|sctpSelectiveAck
name|sack
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for both RTT request/response the  * following is sent  */
end_comment

begin_struct
struct|struct
name|sctpHBrequest
block|{
name|uint32_t
name|time_value_1
decl_stmt|;
name|uint32_t
name|time_value_2
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* here is what I read and respond with to. */
end_comment

begin_struct
struct|struct
name|sctpHBunified
block|{
name|struct
name|sctpChunkDesc
name|hdr
decl_stmt|;
name|struct
name|sctpParamDesc
name|hb
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* here is what I send */
end_comment

begin_struct
struct|struct
name|sctpHBsender
block|{
name|struct
name|sctpChunkDesc
name|hdr
decl_stmt|;
name|struct
name|sctpParamDesc
name|hb
decl_stmt|;
name|struct
name|sctpHBrequest
name|rtt
decl_stmt|;
name|int8_t
name|addrFmt
index|[
name|SCTP_ADDRMAX
index|]
decl_stmt|;
name|uint16_t
name|userreq
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for the abort and shutdown ACK  * we must carry the init tag in the common header. Just the  * common header is all that is needed with a chunk descriptor.  */
end_comment

begin_struct
struct|struct
name|sctpUnifiedAbort
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpUnifiedAbortLight
block|{
name|struct
name|sctpHeader
name|mh
decl_stmt|;
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpUnifiedAbortHeavy
block|{
name|struct
name|sctpHeader
name|mh
decl_stmt|;
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|uint16_t
name|causeCode
decl_stmt|;
name|uint16_t
name|causeLen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* For the graceful shutdown we must carry  * the tag (in common header)  and the highest consequitive acking value  */
end_comment

begin_struct
struct|struct
name|sctpShutdown
block|{
name|uint32_t
name|TSN_Seen
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpUnifiedShutdown
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|struct
name|sctpShutdown
name|shut
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* in the unified message we add the trailing  * stream id since it is the only message  * that is defined as a operation error.  */
end_comment

begin_struct
struct|struct
name|sctpOpErrorCause
block|{
name|uint16_t
name|cause
decl_stmt|;
name|uint16_t
name|causeLen
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpUnifiedOpError
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|struct
name|sctpOpErrorCause
name|c
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpUnifiedStreamError
block|{
name|struct
name|sctpHeader
name|mh
decl_stmt|;
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|struct
name|sctpOpErrorCause
name|c
decl_stmt|;
name|uint16_t
name|strmNum
decl_stmt|;
name|uint16_t
name|reserved
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|staleCookieMsg
block|{
name|struct
name|sctpHeader
name|mh
decl_stmt|;
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|struct
name|sctpOpErrorCause
name|c
decl_stmt|;
name|uint32_t
name|moretime
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* the following is used in all sends  * where nothing is needed except the  * chunk/type i.e. shutdownAck Abort */
end_comment

begin_struct
struct|struct
name|sctpUnifiedSingleMsg
block|{
name|struct
name|sctpHeader
name|mh
decl_stmt|;
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpDataPart
block|{
name|uint32_t
name|TSN
decl_stmt|;
name|uint16_t
name|streamId
decl_stmt|;
name|uint16_t
name|sequence
decl_stmt|;
name|uint32_t
name|payloadtype
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpUnifiedDatagram
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|struct
name|sctpDataPart
name|dp
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpECN_echo
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|uint32_t
name|Lowest_TSN
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sctpCWR
block|{
name|struct
name|sctpChunkDesc
name|uh
decl_stmt|;
name|uint32_t
name|TSN_reduced_at
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_channels
index|[]
init|=
block|{
block|{
name|CHAN_HP
block|,
literal|"ForCES HP"
block|}
block|,
block|{
name|CHAN_MP
block|,
literal|"ForCES MP"
block|}
block|,
block|{
name|CHAN_LP
block|,
literal|"ForCES LP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data chunk's payload protocol identifiers */
end_comment

begin_define
define|#
directive|define
name|SCTP_PPID_IUA
value|1
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_M2UA
value|2
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_M3UA
value|3
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_SUA
value|4
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_M2PA
value|5
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_V5UA
value|6
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_H248
value|7
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_BICC
value|8
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_TALI
value|9
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_DUA
value|10
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_ASAP
value|11
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_ENRP
value|12
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_H323
value|13
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_QIPC
value|14
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_SIMCO
value|15
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_DDPSC
value|16
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_DDPSSC
value|17
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_S1AP
value|18
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_RUA
value|19
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_HNBAP
value|20
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_FORCES_HP
value|21
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_FORCES_MP
value|22
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_FORCES_LP
value|23
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_SBC_AP
value|24
end_define

begin_define
define|#
directive|define
name|SCTP_PPID_NBAP
value|25
end_define

begin_comment
comment|/* 26 */
end_comment

begin_define
define|#
directive|define
name|SCTP_PPID_X2AP
value|27
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|PayloadProto_idents
index|[]
init|=
block|{
block|{
name|SCTP_PPID_IUA
block|,
literal|"ISDN Q.921"
block|}
block|,
block|{
name|SCTP_PPID_M2UA
block|,
literal|"M2UA"
block|}
block|,
block|{
name|SCTP_PPID_M3UA
block|,
literal|"M3UA"
block|}
block|,
block|{
name|SCTP_PPID_SUA
block|,
literal|"SUA"
block|}
block|,
block|{
name|SCTP_PPID_M2PA
block|,
literal|"M2PA"
block|}
block|,
block|{
name|SCTP_PPID_V5UA
block|,
literal|"V5.2"
block|}
block|,
block|{
name|SCTP_PPID_H248
block|,
literal|"H.248"
block|}
block|,
block|{
name|SCTP_PPID_BICC
block|,
literal|"BICC"
block|}
block|,
block|{
name|SCTP_PPID_TALI
block|,
literal|"TALI"
block|}
block|,
block|{
name|SCTP_PPID_DUA
block|,
literal|"DUA"
block|}
block|,
block|{
name|SCTP_PPID_ASAP
block|,
literal|"ASAP"
block|}
block|,
block|{
name|SCTP_PPID_ENRP
block|,
literal|"ENRP"
block|}
block|,
block|{
name|SCTP_PPID_H323
block|,
literal|"H.323"
block|}
block|,
block|{
name|SCTP_PPID_QIPC
block|,
literal|"Q.IPC"
block|}
block|,
block|{
name|SCTP_PPID_SIMCO
block|,
literal|"SIMCO"
block|}
block|,
block|{
name|SCTP_PPID_DDPSC
block|,
literal|"DDPSC"
block|}
block|,
block|{
name|SCTP_PPID_DDPSSC
block|,
literal|"DDPSSC"
block|}
block|,
block|{
name|SCTP_PPID_S1AP
block|,
literal|"S1AP"
block|}
block|,
block|{
name|SCTP_PPID_RUA
block|,
literal|"RUA"
block|}
block|,
block|{
name|SCTP_PPID_HNBAP
block|,
literal|"HNBAP"
block|}
block|,
block|{
name|SCTP_PPID_FORCES_HP
block|,
literal|"ForCES HP"
block|}
block|,
block|{
name|SCTP_PPID_FORCES_MP
block|,
literal|"ForCES MP"
block|}
block|,
block|{
name|SCTP_PPID_FORCES_LP
block|,
literal|"ForCES LP"
block|}
block|,
block|{
name|SCTP_PPID_SBC_AP
block|,
literal|"SBc-AP"
block|}
block|,
block|{
name|SCTP_PPID_NBAP
block|,
literal|"NBAP"
block|}
block|,
comment|/* 26 */
block|{
name|SCTP_PPID_X2AP
block|,
literal|"X2AP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|isForCES_port
parameter_list|(
name|u_short
name|Port
parameter_list|)
block|{
if|if
condition|(
name|Port
operator|==
name|CHAN_HP
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|Port
operator|==
name|CHAN_MP
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|Port
operator|==
name|CHAN_LP
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sctp_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
comment|/* beginning of sctp packet */
specifier|const
name|u_char
modifier|*
name|bp2
parameter_list|,
comment|/* beginning of enclosing */
name|u_int
name|sctpPacketLength
parameter_list|)
comment|/* ip packet */
block|{
specifier|const
name|struct
name|sctpHeader
modifier|*
name|sctpPktHdr
decl_stmt|;
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
specifier|const
name|void
modifier|*
name|endPacketPtr
decl_stmt|;
name|u_short
name|sourcePort
decl_stmt|,
name|destPort
decl_stmt|;
name|int
name|chunkCount
decl_stmt|;
specifier|const
name|struct
name|sctpChunkDesc
modifier|*
name|chunkDescPtr
decl_stmt|;
specifier|const
name|void
modifier|*
name|nextChunk
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|int
name|isforces
init|=
literal|0
decl_stmt|;
name|sctpPktHdr
operator|=
operator|(
specifier|const
expr|struct
name|sctpHeader
operator|*
operator|)
name|bp
expr_stmt|;
name|endPacketPtr
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|sctpPktHdr
operator|+
name|sctpPacketLength
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|endPacketPtr
operator|>
operator|(
name|u_long
operator|)
name|ndo
operator|->
name|ndo_snapend
condition|)
name|endPacketPtr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|ndo
operator|->
name|ndo_snapend
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|bp2
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|IP_V
argument_list|(
name|ip
argument_list|)
operator|==
literal|6
condition|)
name|ip6
operator|=
operator|(
specifier|const
expr|struct
name|ip6_hdr
operator|*
operator|)
name|bp2
expr_stmt|;
else|else
name|ip6
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/*INET6*/
name|ND_TCHECK
argument_list|(
operator|*
name|sctpPktHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctpPacketLength
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctpHeader
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"truncated-sctp - %ld bytes missing!"
operator|,
operator|(
name|long
operator|)
name|sctpPacketLength
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctpHeader
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    sctpPacketLength -= sizeof(struct sctpHeader);  packet length  */
comment|/*  			      is now only as long as the payload  */
name|sourcePort
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|sctpPktHdr
operator|->
name|source
argument_list|)
expr_stmt|;
name|destPort
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|sctpPktHdr
operator|->
name|destination
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ip6
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s.%d> %s.%d: sctp"
operator|,
name|ip6addr_string
argument_list|(
name|ndo
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|,
name|sourcePort
operator|,
name|ip6addr_string
argument_list|(
name|ndo
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
operator|,
name|destPort
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/*INET6*/
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s.%d> %s.%d: sctp"
operator|,
name|ipaddr_string
argument_list|(
name|ndo
argument_list|,
operator|&
name|ip
operator|->
name|ip_src
argument_list|)
operator|,
name|sourcePort
operator|,
name|ipaddr_string
argument_list|(
name|ndo
argument_list|,
operator|&
name|ip
operator|->
name|ip_dst
argument_list|)
operator|,
name|destPort
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isForCES_port
argument_list|(
name|sourcePort
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%s]"
operator|,
name|tok2str
argument_list|(
name|ForCES_channels
argument_list|,
name|NULL
argument_list|,
name|sourcePort
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|isforces
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isForCES_port
argument_list|(
name|destPort
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%s]"
operator|,
name|tok2str
argument_list|(
name|ForCES_channels
argument_list|,
name|NULL
argument_list|,
name|destPort
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|isforces
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|2
condition|)
name|sep
operator|=
literal|"\n\t"
expr_stmt|;
else|else
name|sep
operator|=
literal|" ("
expr_stmt|;
comment|/* cycle through all chunks, printing information on each one */
for|for
control|(
name|chunkCount
operator|=
literal|0
operator|,
name|chunkDescPtr
operator|=
operator|(
specifier|const
expr|struct
name|sctpChunkDesc
operator|*
operator|)
operator|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|sctpPktHdr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctpHeader
argument_list|)
operator|)
init|;
name|chunkDescPtr
operator|!=
name|NULL
operator|&&
operator|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|chunkDescPtr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctpChunkDesc
argument_list|)
operator|)
operator|<=
name|endPacketPtr
operator|)
condition|;
name|chunkDescPtr
operator|=
operator|(
specifier|const
expr|struct
name|sctpChunkDesc
operator|*
operator|)
name|nextChunk
operator|,
name|chunkCount
operator|++
control|)
block|{
name|uint16_t
name|chunkLength
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|chunkEnd
decl_stmt|;
name|uint16_t
name|align
decl_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|chunkDescPtr
argument_list|)
expr_stmt|;
name|chunkLength
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|chunkDescPtr
operator|->
name|chunkLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunkLength
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|chunkDescPtr
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s%d) [Bad chunk length %u]"
operator|,
name|sep
operator|,
name|chunkCount
operator|+
literal|1
operator|,
name|chunkLength
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ND_TCHECK2
argument_list|(
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|chunkDescPtr
operator|)
argument_list|,
name|chunkLength
argument_list|)
expr_stmt|;
name|chunkEnd
operator|=
operator|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|chunkDescPtr
operator|+
name|chunkLength
operator|)
expr_stmt|;
name|align
operator|=
name|chunkLength
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
name|align
operator|=
literal|4
operator|-
name|align
expr_stmt|;
name|nextChunk
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|chunkEnd
operator|+
name|align
operator|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s%d) "
operator|,
name|sep
operator|,
name|chunkCount
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[%s] "
operator|,
name|tok2str
argument_list|(
name|sctp_chunkid_str
argument_list|,
literal|"Unknown chunk type: 0x%x"
argument_list|,
name|chunkDescPtr
operator|->
name|chunkID
argument_list|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|chunkDescPtr
operator|->
name|chunkID
condition|)
block|{
case|case
name|SCTP_DATA
case|:
block|{
specifier|const
name|struct
name|sctpDataPart
modifier|*
name|dataHdrPtr
decl_stmt|;
name|uint32_t
name|ppid
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|payloadPtr
decl_stmt|;
name|u_int
name|payload_size
decl_stmt|;
if|if
condition|(
operator|(
name|chunkDescPtr
operator|->
name|chunkFlg
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
name|SCTP_DATA_UNORDERED
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"(U)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chunkDescPtr
operator|->
name|chunkFlg
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"(B)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chunkDescPtr
operator|->
name|chunkFlg
operator|&
name|SCTP_DATA_LAST_FRAG
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"(E)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|chunkDescPtr
operator|->
name|chunkFlg
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
name|SCTP_DATA_UNORDERED
operator|)
operator|||
operator|(
operator|(
name|chunkDescPtr
operator|->
name|chunkFlg
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|||
operator|(
operator|(
name|chunkDescPtr
operator|->
name|chunkFlg
operator|&
name|SCTP_DATA_LAST_FRAG
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
operator|)
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" "
operator|)
argument_list|)
expr_stmt|;
name|dataHdrPtr
operator|=
operator|(
specifier|const
expr|struct
name|sctpDataPart
operator|*
operator|)
operator|(
name|chunkDescPtr
operator|+
literal|1
operator|)
expr_stmt|;
name|ppid
operator|=
name|EXTRACT_32BITS
argument_list|(
operator|&
name|dataHdrPtr
operator|->
name|payloadtype
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[TSN: %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|dataHdrPtr
operator|->
name|TSN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[SID: %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|dataHdrPtr
operator|->
name|streamId
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[SSEQ %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|dataHdrPtr
operator|->
name|sequence
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[PPID %s] "
operator|,
name|tok2str
argument_list|(
name|PayloadProto_idents
argument_list|,
literal|"0x%x"
argument_list|,
name|ppid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isforces
condition|)
block|{
name|isforces
operator|=
operator|(
name|ppid
operator|==
name|SCTP_PPID_FORCES_HP
operator|)
operator|||
operator|(
name|ppid
operator|==
name|SCTP_PPID_FORCES_MP
operator|)
operator|||
operator|(
name|ppid
operator|==
name|SCTP_PPID_FORCES_LP
operator|)
expr_stmt|;
block|}
name|payloadPtr
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
operator|(
name|dataHdrPtr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|chunkDescPtr
operator|->
name|chunkLength
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctpDataPart
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctpChunkDesc
argument_list|)
operator|+
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"bogus chunk length %u]"
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|chunkDescPtr
operator|->
name|chunkLength
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|payload_size
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|chunkDescPtr
operator|->
name|chunkLength
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctpDataPart
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctpChunkDesc
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|isforces
condition|)
block|{
name|forces_print
argument_list|(
name|ndo
argument_list|,
name|payloadPtr
argument_list|,
name|payload_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|2
condition|)
block|{
comment|/* if verbose output is specified */
comment|/* at the command line */
switch|switch
condition|(
name|ppid
condition|)
block|{
case|case
name|SCTP_PPID_M3UA
case|:
name|m3ua_print
argument_list|(
name|ndo
argument_list|,
name|payloadPtr
argument_list|,
name|payload_size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[Payload"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndo
operator|->
name|ndo_suppress_default_print
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|ND_DEFAULTPRINT
argument_list|(
name|payloadPtr
argument_list|,
name|payload_size
argument_list|)
expr_stmt|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"]"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_INITIATION
case|:
block|{
specifier|const
name|struct
name|sctpInitiation
modifier|*
name|init
decl_stmt|;
name|init
operator|=
operator|(
specifier|const
expr|struct
name|sctpInitiation
operator|*
operator|)
operator|(
name|chunkDescPtr
operator|+
literal|1
operator|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[init tag: %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|init
operator|->
name|initTag
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[rwnd: %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|init
operator|->
name|rcvWindowCredit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[OS: %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|init
operator|->
name|NumPreopenStreams
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[MIS: %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|init
operator|->
name|MaxInboundStreams
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[init TSN: %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|init
operator|->
name|initialTSN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
literal|0
operator|)
comment|/* ALC you can add code for optional params here */
if|if
condition|(
operator|(
name|init
operator|+
literal|1
operator|)
operator|<
name|chunkEnd
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" @@@@@ UNFINISHED @@@@@@%s\n"
operator|,
literal|"Optional params present, but not printed."
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|SCTP_INITIATION_ACK
case|:
block|{
specifier|const
name|struct
name|sctpInitiation
modifier|*
name|init
decl_stmt|;
name|init
operator|=
operator|(
specifier|const
expr|struct
name|sctpInitiation
operator|*
operator|)
operator|(
name|chunkDescPtr
operator|+
literal|1
operator|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[init tag: %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|init
operator|->
name|initTag
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[rwnd: %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|init
operator|->
name|rcvWindowCredit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[OS: %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|init
operator|->
name|NumPreopenStreams
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[MIS: %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|init
operator|->
name|MaxInboundStreams
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[init TSN: %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|init
operator|->
name|initialTSN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
literal|0
operator|)
comment|/* ALC you can add code for optional params here */
if|if
condition|(
operator|(
name|init
operator|+
literal|1
operator|)
operator|<
name|chunkEnd
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" @@@@@ UNFINISHED @@@@@@%s\n"
operator|,
literal|"Optional params present, but not printed."
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|SCTP_SELECTIVE_ACK
case|:
block|{
specifier|const
name|struct
name|sctpSelectiveAck
modifier|*
name|sack
decl_stmt|;
specifier|const
name|struct
name|sctpSelectiveFrag
modifier|*
name|frag
decl_stmt|;
name|int
name|fragNo
decl_stmt|,
name|tsnNo
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|dupTSN
decl_stmt|;
name|sack
operator|=
operator|(
specifier|const
expr|struct
name|sctpSelectiveAck
operator|*
operator|)
operator|(
name|chunkDescPtr
operator|+
literal|1
operator|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[cum ack %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|sack
operator|->
name|highestConseqTSN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[a_rwnd %u] "
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|sack
operator|->
name|updatedRwnd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[#gap acks %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|sack
operator|->
name|numberOfdesc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[#dup tsns %u] "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|sack
operator|->
name|numDupTsns
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* print gaps */
for|for
control|(
name|frag
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|sctpSelectiveFrag
operator|*
operator|)
operator|(
operator|(
specifier|const
expr|struct
name|sctpSelectiveAck
operator|*
operator|)
name|sack
operator|+
literal|1
operator|)
operator|)
operator|,
name|fragNo
operator|=
literal|0
init|;
operator|(
specifier|const
name|void
operator|*
operator|)
name|frag
operator|<
name|nextChunk
operator|&&
name|fragNo
operator|<
name|EXTRACT_16BITS
argument_list|(
operator|&
name|sack
operator|->
name|numberOfdesc
argument_list|)
condition|;
name|frag
operator|++
operator|,
name|fragNo
operator|++
control|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\t[gap ack block #%d: start = %u, end = %u] "
operator|,
name|fragNo
operator|+
literal|1
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|sack
operator|->
name|highestConseqTSN
argument_list|)
operator|+
name|EXTRACT_16BITS
argument_list|(
operator|&
name|frag
operator|->
name|fragmentStart
argument_list|)
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|sack
operator|->
name|highestConseqTSN
argument_list|)
operator|+
name|EXTRACT_16BITS
argument_list|(
operator|&
name|frag
operator|->
name|fragmentEnd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* print duplicate TSNs */
for|for
control|(
name|dupTSN
operator|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|frag
operator|,
name|tsnNo
operator|=
literal|0
init|;
operator|(
specifier|const
name|void
operator|*
operator|)
name|dupTSN
operator|<
name|nextChunk
operator|&&
name|tsnNo
operator|<
name|EXTRACT_16BITS
argument_list|(
operator|&
name|sack
operator|->
name|numDupTsns
argument_list|)
condition|;
name|dupTSN
operator|+=
literal|4
operator|,
name|tsnNo
operator|++
control|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\t[dup TSN #%u: %u] "
operator|,
name|tsnNo
operator|+
literal|1
operator|,
name|EXTRACT_32BITS
argument_list|(
name|dupTSN
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|<
literal|2
condition|)
name|sep
operator|=
literal|", ("
expr_stmt|;
block|}
return|return;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"[|sctp]"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

