begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- MCJITTestBase.h - Common base class for MCJIT Unit tests  ----------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class implements common functionality required by the MCJIT unit tests,
end_comment

begin_comment
comment|// as well as logic to skip tests on unsupported architectures and operating
end_comment

begin_comment
comment|// systems.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MCJIT_TEST_BASE_H
end_ifndef

begin_define
define|#
directive|define
name|MCJIT_TEST_BASE_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Config/config.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/ExecutionEngine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/SectionMemoryManager.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/TypeBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CodeGen.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Host.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/TargetSelect.h"
end_include

begin_comment
comment|// Used to skip tests on unsupported architectures and operating systems.
end_comment

begin_comment
comment|// To skip a test, add this macro at the top of a test-case in a suite that
end_comment

begin_comment
comment|// inherits from MCJITTestBase. See MCJITTest.cpp for examples.
end_comment

begin_define
define|#
directive|define
name|SKIP_UNSUPPORTED_PLATFORM
define|\
value|do \     if (!ArchSupportsMCJIT() || !OSSupportsMCJIT()) \       return; \   while(0);
end_define

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MCJITTestBase
block|{
name|protected
label|:
name|MCJITTestBase
argument_list|()
operator|:
name|OptLevel
argument_list|(
name|CodeGenOpt
operator|::
name|None
argument_list|)
operator|,
name|RelocModel
argument_list|(
name|Reloc
operator|::
name|Default
argument_list|)
operator|,
name|CodeModel
argument_list|(
name|CodeModel
operator|::
name|Default
argument_list|)
operator|,
name|MArch
argument_list|(
literal|""
argument_list|)
operator|,
name|Builder
argument_list|(
name|Context
argument_list|)
operator|,
name|MM
argument_list|(
argument|new SectionMemoryManager
argument_list|)
operator|,
name|HostTriple
argument_list|(
argument|sys::getProcessTriple()
argument_list|)
block|{
name|InitializeNativeTarget
argument_list|()
block|;
name|InitializeNativeTargetAsmPrinter
argument_list|()
block|;
ifdef|#
directive|ifdef
name|LLVM_ON_WIN32
comment|// On Windows, generate ELF objects by specifying "-elf" in triple
name|HostTriple
operator|+=
literal|"-elf"
block|;
endif|#
directive|endif
comment|// LLVM_ON_WIN32
name|HostTriple
operator|=
name|Triple
operator|::
name|normalize
argument_list|(
name|HostTriple
argument_list|)
block|;
comment|// The architectures below are known to be compatible with MCJIT as they
comment|// are copied from test/ExecutionEngine/MCJIT/lit.local.cfg and should be
comment|// kept in sync.
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|arm
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|mips
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|x86
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|x86_64
argument_list|)
block|;
comment|// The operating systems below are known to be incompatible with MCJIT as
comment|// they are copied from the test/ExecutionEngine/MCJIT/lit.local.cfg and
comment|// should be kept in sync.
name|UnsupportedOSs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|Cygwin
argument_list|)
block|;
name|UnsupportedOSs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|Darwin
argument_list|)
block|;   }
comment|/// Returns true if the host architecture is known to support MCJIT
name|bool
name|ArchSupportsMCJIT
argument_list|()
block|{
name|Triple
name|Host
argument_list|(
name|HostTriple
argument_list|)
block|;
if|if
condition|(
name|std
operator|::
name|find
argument_list|(
name|SupportedArchs
operator|.
name|begin
argument_list|()
argument_list|,
name|SupportedArchs
operator|.
name|end
argument_list|()
argument_list|,
name|Host
operator|.
name|getArch
argument_list|()
argument_list|)
operator|==
name|SupportedArchs
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
comment|/// Returns true if the host OS is known to support MCJIT
name|bool
name|OSSupportsMCJIT
parameter_list|()
block|{
name|Triple
name|Host
argument_list|(
name|HostTriple
argument_list|)
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|find
argument_list|(
name|UnsupportedOSs
operator|.
name|begin
argument_list|()
argument_list|,
name|UnsupportedOSs
operator|.
name|end
argument_list|()
argument_list|,
name|Host
operator|.
name|getOS
argument_list|()
argument_list|)
operator|==
name|UnsupportedOSs
operator|.
name|end
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|Module
modifier|*
name|createEmptyModule
parameter_list|(
name|StringRef
name|Name
parameter_list|)
block|{
name|Module
modifier|*
name|M
init|=
name|new
name|Module
argument_list|(
name|Name
argument_list|,
name|Context
argument_list|)
decl_stmt|;
name|M
operator|->
name|setTargetTriple
argument_list|(
name|Triple
operator|::
name|normalize
argument_list|(
name|HostTriple
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|M
return|;
block|}
name|template
operator|<
name|typename
name|FuncType
operator|>
name|Function
operator|*
name|startFunction
argument_list|(
argument|Module *M
argument_list|,
argument|StringRef Name
argument_list|)
block|{
name|Function
operator|*
name|Result
operator|=
name|Function
operator|::
name|Create
argument_list|(
name|TypeBuilder
operator|<
name|FuncType
argument_list|,
name|false
operator|>
operator|::
name|get
argument_list|(
name|Context
argument_list|)
argument_list|,
name|GlobalValue
operator|::
name|ExternalLinkage
argument_list|,
name|Name
argument_list|,
name|M
argument_list|)
block|;
name|BasicBlock
operator|*
name|BB
operator|=
name|BasicBlock
operator|::
name|Create
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|,
name|Result
argument_list|)
block|;
name|Builder
operator|.
name|SetInsertPoint
argument_list|(
name|BB
argument_list|)
block|;
return|return
name|Result
return|;
block|}
name|void
name|endFunctionWithRet
parameter_list|(
name|Function
modifier|*
name|Func
parameter_list|,
name|Value
modifier|*
name|RetValue
parameter_list|)
block|{
name|Builder
operator|.
name|CreateRet
argument_list|(
name|RetValue
argument_list|)
expr_stmt|;
block|}
comment|// Inserts a simple function that invokes Callee and takes the same arguments:
comment|//    int Caller(...) { return Callee(...); }
name|template
operator|<
name|typename
name|Signature
operator|>
name|Function
operator|*
name|insertSimpleCallFunction
argument_list|(
argument|Module *M
argument_list|,
argument|Function *Callee
argument_list|)
block|{
name|Function
operator|*
name|Result
operator|=
name|startFunction
operator|<
name|Signature
operator|>
operator|(
name|M
operator|,
literal|"caller"
operator|)
block|;
name|SmallVector
operator|<
name|Value
operator|*
block|,
literal|1
operator|>
name|CallArgs
block|;
name|Function
operator|::
name|arg_iterator
name|arg_iter
operator|=
name|Result
operator|->
name|arg_begin
argument_list|()
block|;
for|for
control|(
init|;
name|arg_iter
operator|!=
name|Result
operator|->
name|arg_end
argument_list|()
condition|;
operator|++
name|arg_iter
control|)
name|CallArgs
operator|.
name|push_back
argument_list|(
name|arg_iter
argument_list|)
expr_stmt|;
name|Value
operator|*
name|ReturnCode
operator|=
name|Builder
operator|.
name|CreateCall
argument_list|(
name|Callee
argument_list|,
name|CallArgs
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|CreateRet
argument_list|(
name|ReturnCode
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts a function named 'main' that returns a uint32_t:
comment|//    int32_t main() { return X; }
comment|// where X is given by returnCode
name|Function
modifier|*
name|insertMainFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|uint32_t
name|returnCode
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|startFunction
operator|<
name|int32_t
argument_list|(
name|void
argument_list|)
operator|>
operator|(
name|M
expr|,
literal|"main"
operator|)
decl_stmt|;
name|Value
modifier|*
name|ReturnVal
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|APInt
argument_list|(
literal|32
argument_list|,
name|returnCode
argument_list|)
argument_list|)
decl_stmt|;
name|endFunctionWithRet
argument_list|(
name|Result
argument_list|,
name|ReturnVal
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts a function
comment|//    int32_t add(int32_t a, int32_t b) { return a + b; }
comment|// in the current module and returns a pointer to it.
name|Function
modifier|*
name|insertAddFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|StringRef
name|Name
init|=
literal|"add"
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|startFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|,
name|int32_t
argument_list|)
operator|>
operator|(
name|M
expr|,
name|Name
operator|)
decl_stmt|;
name|Function
operator|::
name|arg_iterator
name|args
operator|=
name|Result
operator|->
name|arg_begin
argument_list|()
expr_stmt|;
name|Value
modifier|*
name|Arg1
init|=
name|args
decl_stmt|;
name|Value
modifier|*
name|Arg2
init|=
operator|++
name|args
decl_stmt|;
name|Value
modifier|*
name|AddResult
init|=
name|Builder
operator|.
name|CreateAdd
argument_list|(
name|Arg1
argument_list|,
name|Arg2
argument_list|)
decl_stmt|;
name|endFunctionWithRet
argument_list|(
name|Result
argument_list|,
name|AddResult
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts an declaration to a function defined elsewhere
name|Function
modifier|*
name|insertExternalReferenceToFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|StringRef
name|Name
parameter_list|,
name|FunctionType
modifier|*
name|FuncTy
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|Function
operator|::
name|Create
argument_list|(
name|FuncTy
argument_list|,
name|GlobalValue
operator|::
name|ExternalLinkage
argument_list|,
name|Name
argument_list|,
name|M
argument_list|)
decl_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts an declaration to a function defined elsewhere
name|Function
modifier|*
name|insertExternalReferenceToFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|Function
modifier|*
name|Func
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|Function
operator|::
name|Create
argument_list|(
name|Func
operator|->
name|getFunctionType
argument_list|()
argument_list|,
name|GlobalValue
operator|::
name|AvailableExternallyLinkage
argument_list|,
name|Func
operator|->
name|getName
argument_list|()
argument_list|,
name|M
argument_list|)
decl_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts a global variable of type int32
name|GlobalVariable
modifier|*
name|insertGlobalInt32
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|StringRef
name|name
parameter_list|,
name|int32_t
name|InitialValue
parameter_list|)
block|{
name|Type
modifier|*
name|GlobalTy
init|=
name|TypeBuilder
operator|<
name|types
operator|::
name|i
operator|<
literal|32
operator|>
decl_stmt|,
name|true
decl|>::
name|get
argument_list|(
name|Context
argument_list|)
decl_stmt|;
name|Constant
modifier|*
name|IV
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|APInt
argument_list|(
literal|32
argument_list|,
name|InitialValue
argument_list|)
argument_list|)
decl_stmt|;
name|GlobalVariable
modifier|*
name|Global
init|=
name|new
name|GlobalVariable
argument_list|(
operator|*
name|M
argument_list|,
name|GlobalTy
argument_list|,
name|false
argument_list|,
name|GlobalValue
operator|::
name|ExternalLinkage
argument_list|,
name|IV
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
name|Global
return|;
block|}
name|void
name|createJIT
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|)
block|{
comment|// Due to the EngineBuilder constructor, it is required to have a Module
comment|// in order to construct an ExecutionEngine (i.e. MCJIT)
name|assert
argument_list|(
name|M
operator|!=
literal|0
operator|&&
literal|"a non-null Module must be provided to create MCJIT"
argument_list|)
expr_stmt|;
name|EngineBuilder
name|EB
argument_list|(
name|M
argument_list|)
decl_stmt|;
name|std
operator|::
name|string
name|Error
expr_stmt|;
name|TheJIT
operator|.
name|reset
argument_list|(
name|EB
operator|.
name|setEngineKind
argument_list|(
name|EngineKind
operator|::
name|JIT
argument_list|)
operator|.
name|setUseMCJIT
argument_list|(
name|true
argument_list|)
comment|/* can this be folded into the EngineKind enum? */
operator|.
name|setJITMemoryManager
argument_list|(
name|MM
argument_list|)
operator|.
name|setErrorStr
argument_list|(
operator|&
name|Error
argument_list|)
operator|.
name|setOptLevel
argument_list|(
name|CodeGenOpt
operator|::
name|None
argument_list|)
operator|.
name|setAllocateGVsWithCode
argument_list|(
name|false
argument_list|)
comment|/*does this do anything?*/
operator|.
name|setCodeModel
argument_list|(
name|CodeModel
operator|::
name|JITDefault
argument_list|)
operator|.
name|setRelocationModel
argument_list|(
name|Reloc
operator|::
name|Default
argument_list|)
operator|.
name|setMArch
argument_list|(
name|MArch
argument_list|)
operator|.
name|setMCPU
argument_list|(
name|sys
operator|::
name|getHostCPUName
argument_list|()
argument_list|)
comment|//.setMAttrs(MAttrs)
operator|.
name|create
argument_list|()
argument_list|)
expr_stmt|;
comment|// At this point, we cannot modify the module any more.
name|assert
argument_list|(
name|TheJIT
operator|.
name|get
argument_list|()
operator|!=
name|NULL
operator|&&
literal|"error creating MCJIT with EngineBuilder"
argument_list|)
expr_stmt|;
block|}
name|LLVMContext
name|Context
decl_stmt|;
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
expr_stmt|;
name|Reloc
operator|::
name|Model
name|RelocModel
expr_stmt|;
name|CodeModel
operator|::
name|Model
name|CodeModel
expr_stmt|;
name|StringRef
name|MArch
decl_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|string
operator|,
literal|1
operator|>
name|MAttrs
expr_stmt|;
name|OwningPtr
operator|<
name|TargetMachine
operator|>
name|TM
expr_stmt|;
name|OwningPtr
operator|<
name|ExecutionEngine
operator|>
name|TheJIT
expr_stmt|;
name|IRBuilder
operator|<
operator|>
name|Builder
expr_stmt|;
name|JITMemoryManager
modifier|*
name|MM
decl_stmt|;
name|std
operator|::
name|string
name|HostTriple
expr_stmt|;
name|SmallVector
operator|<
name|Triple
operator|::
name|ArchType
operator|,
literal|4
operator|>
name|SupportedArchs
expr_stmt|;
name|SmallVector
operator|<
name|Triple
operator|::
name|OSType
operator|,
literal|4
operator|>
name|UnsupportedOSs
expr_stmt|;
name|OwningPtr
operator|<
name|Module
operator|>
name|M
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// MCJIT_TEST_H
end_comment

end_unit

