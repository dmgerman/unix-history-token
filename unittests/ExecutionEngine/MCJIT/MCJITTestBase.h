begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- MCJITTestBase.h - Common base class for MCJIT Unit tests  ----------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class implements common functionality required by the MCJIT unit tests,
end_comment

begin_comment
comment|// as well as logic to skip tests on unsupported architectures and operating
end_comment

begin_comment
comment|// systems.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MCJIT_TEST_BASE_H
end_ifndef

begin_define
define|#
directive|define
name|MCJIT_TEST_BASE_H
end_define

begin_include
include|#
directive|include
file|"MCJITTestAPICommon.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Config/config.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/ExecutionEngine.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ExecutionEngine/SectionMemoryManager.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Function.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/IRBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/TypeBuilder.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CodeGen.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// Helper class that can build very simple Modules
name|class
name|TrivialModuleBuilder
block|{
name|protected
label|:
name|LLVMContext
name|Context
decl_stmt|;
name|IRBuilder
operator|<
operator|>
name|Builder
expr_stmt|;
name|std
operator|::
name|string
name|BuilderTriple
expr_stmt|;
name|TrivialModuleBuilder
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Triple
argument_list|)
operator|:
name|Builder
argument_list|(
name|Context
argument_list|)
operator|,
name|BuilderTriple
argument_list|(
argument|Triple
argument_list|)
block|{}
name|Module
operator|*
name|createEmptyModule
argument_list|(
argument|StringRef Name = StringRef()
argument_list|)
block|{
name|Module
operator|*
name|M
operator|=
name|new
name|Module
argument_list|(
name|Name
argument_list|,
name|Context
argument_list|)
block|;
name|M
operator|->
name|setTargetTriple
argument_list|(
name|Triple
operator|::
name|normalize
argument_list|(
name|BuilderTriple
argument_list|)
argument_list|)
block|;
return|return
name|M
return|;
block|}
name|template
operator|<
name|typename
name|FuncType
operator|>
name|Function
operator|*
name|startFunction
argument_list|(
argument|Module *M
argument_list|,
argument|StringRef Name
argument_list|)
block|{
name|Function
operator|*
name|Result
operator|=
name|Function
operator|::
name|Create
argument_list|(
name|TypeBuilder
operator|<
name|FuncType
argument_list|,
name|false
operator|>
operator|::
name|get
argument_list|(
name|Context
argument_list|)
argument_list|,
name|GlobalValue
operator|::
name|ExternalLinkage
argument_list|,
name|Name
argument_list|,
name|M
argument_list|)
block|;
name|BasicBlock
operator|*
name|BB
operator|=
name|BasicBlock
operator|::
name|Create
argument_list|(
name|Context
argument_list|,
name|Name
argument_list|,
name|Result
argument_list|)
block|;
name|Builder
operator|.
name|SetInsertPoint
argument_list|(
name|BB
argument_list|)
block|;
return|return
name|Result
return|;
block|}
name|void
name|endFunctionWithRet
parameter_list|(
name|Function
modifier|*
name|Func
parameter_list|,
name|Value
modifier|*
name|RetValue
parameter_list|)
block|{
name|Builder
operator|.
name|CreateRet
argument_list|(
name|RetValue
argument_list|)
expr_stmt|;
block|}
comment|// Inserts a simple function that invokes Callee and takes the same arguments:
comment|//    int Caller(...) { return Callee(...); }
name|template
operator|<
name|typename
name|Signature
operator|>
name|Function
operator|*
name|insertSimpleCallFunction
argument_list|(
argument|Module *M
argument_list|,
argument|Function *Callee
argument_list|)
block|{
name|Function
operator|*
name|Result
operator|=
name|startFunction
operator|<
name|Signature
operator|>
operator|(
name|M
operator|,
literal|"caller"
operator|)
block|;
name|SmallVector
operator|<
name|Value
operator|*
block|,
literal|1
operator|>
name|CallArgs
block|;
name|Function
operator|::
name|arg_iterator
name|arg_iter
operator|=
name|Result
operator|->
name|arg_begin
argument_list|()
block|;
for|for
control|(
init|;
name|arg_iter
operator|!=
name|Result
operator|->
name|arg_end
argument_list|()
condition|;
operator|++
name|arg_iter
control|)
name|CallArgs
operator|.
name|push_back
argument_list|(
name|arg_iter
argument_list|)
expr_stmt|;
name|Value
operator|*
name|ReturnCode
operator|=
name|Builder
operator|.
name|CreateCall
argument_list|(
name|Callee
argument_list|,
name|CallArgs
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|CreateRet
argument_list|(
name|ReturnCode
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts a function named 'main' that returns a uint32_t:
comment|//    int32_t main() { return X; }
comment|// where X is given by returnCode
name|Function
modifier|*
name|insertMainFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|uint32_t
name|returnCode
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|startFunction
operator|<
name|int32_t
argument_list|(
name|void
argument_list|)
operator|>
operator|(
name|M
expr|,
literal|"main"
operator|)
decl_stmt|;
name|Value
modifier|*
name|ReturnVal
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|APInt
argument_list|(
literal|32
argument_list|,
name|returnCode
argument_list|)
argument_list|)
decl_stmt|;
name|endFunctionWithRet
argument_list|(
name|Result
argument_list|,
name|ReturnVal
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts a function
comment|//    int32_t add(int32_t a, int32_t b) { return a + b; }
comment|// in the current module and returns a pointer to it.
name|Function
modifier|*
name|insertAddFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|StringRef
name|Name
init|=
literal|"add"
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|startFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|,
name|int32_t
argument_list|)
operator|>
operator|(
name|M
expr|,
name|Name
operator|)
decl_stmt|;
name|Function
operator|::
name|arg_iterator
name|args
operator|=
name|Result
operator|->
name|arg_begin
argument_list|()
expr_stmt|;
name|Value
modifier|*
name|Arg1
init|=
name|args
decl_stmt|;
name|Value
modifier|*
name|Arg2
init|=
operator|++
name|args
decl_stmt|;
name|Value
modifier|*
name|AddResult
init|=
name|Builder
operator|.
name|CreateAdd
argument_list|(
name|Arg1
argument_list|,
name|Arg2
argument_list|)
decl_stmt|;
name|endFunctionWithRet
argument_list|(
name|Result
argument_list|,
name|AddResult
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts an declaration to a function defined elsewhere
name|Function
modifier|*
name|insertExternalReferenceToFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|StringRef
name|Name
parameter_list|,
name|FunctionType
modifier|*
name|FuncTy
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|Function
operator|::
name|Create
argument_list|(
name|FuncTy
argument_list|,
name|GlobalValue
operator|::
name|ExternalLinkage
argument_list|,
name|Name
argument_list|,
name|M
argument_list|)
decl_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts an declaration to a function defined elsewhere
name|Function
modifier|*
name|insertExternalReferenceToFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|Function
modifier|*
name|Func
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|Function
operator|::
name|Create
argument_list|(
name|Func
operator|->
name|getFunctionType
argument_list|()
argument_list|,
name|GlobalValue
operator|::
name|ExternalLinkage
argument_list|,
name|Func
operator|->
name|getName
argument_list|()
argument_list|,
name|M
argument_list|)
decl_stmt|;
return|return
name|Result
return|;
block|}
comment|// Inserts a global variable of type int32
comment|// FIXME: make this a template function to support any type
name|GlobalVariable
modifier|*
name|insertGlobalInt32
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|StringRef
name|name
parameter_list|,
name|int32_t
name|InitialValue
parameter_list|)
block|{
name|Type
modifier|*
name|GlobalTy
init|=
name|TypeBuilder
operator|<
name|types
operator|::
name|i
operator|<
literal|32
operator|>
decl_stmt|,
name|true
decl|>::
name|get
argument_list|(
name|Context
argument_list|)
decl_stmt|;
name|Constant
modifier|*
name|IV
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|APInt
argument_list|(
literal|32
argument_list|,
name|InitialValue
argument_list|)
argument_list|)
decl_stmt|;
name|GlobalVariable
modifier|*
name|Global
init|=
name|new
name|GlobalVariable
argument_list|(
operator|*
name|M
argument_list|,
name|GlobalTy
argument_list|,
name|false
argument_list|,
name|GlobalValue
operator|::
name|ExternalLinkage
argument_list|,
name|IV
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
name|Global
return|;
block|}
comment|// Inserts a function
comment|//   int32_t recursive_add(int32_t num) {
comment|//     if (num == 0) {
comment|//       return num;
comment|//     } else {
comment|//       int32_t recursive_param = num - 1;
comment|//       return num + Helper(recursive_param);
comment|//     }
comment|//   }
comment|// NOTE: if Helper is left as the default parameter, Helper == recursive_add.
name|Function
modifier|*
name|insertAccumulateFunction
parameter_list|(
name|Module
modifier|*
name|M
parameter_list|,
name|Function
modifier|*
name|Helper
init|=
literal|0
parameter_list|,
name|StringRef
name|Name
init|=
literal|"accumulate"
parameter_list|)
block|{
name|Function
modifier|*
name|Result
init|=
name|startFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|)
operator|>
operator|(
name|M
expr|,
name|Name
operator|)
decl_stmt|;
if|if
condition|(
name|Helper
operator|==
literal|0
condition|)
name|Helper
operator|=
name|Result
expr_stmt|;
name|BasicBlock
modifier|*
name|BaseCase
init|=
name|BasicBlock
operator|::
name|Create
argument_list|(
name|Context
argument_list|,
literal|""
argument_list|,
name|Result
argument_list|)
decl_stmt|;
name|BasicBlock
modifier|*
name|RecursiveCase
init|=
name|BasicBlock
operator|::
name|Create
argument_list|(
name|Context
argument_list|,
literal|""
argument_list|,
name|Result
argument_list|)
decl_stmt|;
comment|// if (num == 0)
name|Value
modifier|*
name|Param
init|=
name|Result
operator|->
name|arg_begin
argument_list|()
decl_stmt|;
name|Value
modifier|*
name|Zero
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|APInt
argument_list|(
literal|32
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Builder
operator|.
name|CreateCondBr
argument_list|(
name|Builder
operator|.
name|CreateICmpEQ
argument_list|(
name|Param
argument_list|,
name|Zero
argument_list|)
argument_list|,
name|BaseCase
argument_list|,
name|RecursiveCase
argument_list|)
expr_stmt|;
comment|//   return num;
name|Builder
operator|.
name|SetInsertPoint
argument_list|(
name|BaseCase
argument_list|)
expr_stmt|;
name|Builder
operator|.
name|CreateRet
argument_list|(
name|Param
argument_list|)
expr_stmt|;
comment|//   int32_t recursive_param = num - 1;
comment|//   return Helper(recursive_param);
name|Builder
operator|.
name|SetInsertPoint
argument_list|(
name|RecursiveCase
argument_list|)
expr_stmt|;
name|Value
modifier|*
name|One
init|=
name|ConstantInt
operator|::
name|get
argument_list|(
name|Context
argument_list|,
name|APInt
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|RecursiveParam
init|=
name|Builder
operator|.
name|CreateSub
argument_list|(
name|Param
argument_list|,
name|One
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|RecursiveReturn
init|=
name|Builder
operator|.
name|CreateCall
argument_list|(
name|Helper
argument_list|,
name|RecursiveParam
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|Accumulator
init|=
name|Builder
operator|.
name|CreateAdd
argument_list|(
name|Param
argument_list|,
name|RecursiveReturn
argument_list|)
decl_stmt|;
name|Builder
operator|.
name|CreateRet
argument_list|(
name|Accumulator
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
comment|// Populates Modules A and B:
comment|// Module A { Extern FB1, Function FA which calls FB1 },
comment|// Module B { Extern FA, Function FB1, Function FB2 which calls FA },
name|void
name|createCrossModuleRecursiveCase
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|A
argument_list|,
name|Function
operator|*
operator|&
name|FA
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|B
argument_list|,
name|Function
operator|*
operator|&
name|FB1
argument_list|,
name|Function
operator|*
operator|&
name|FB2
argument_list|)
block|{
comment|// Define FB1 in B.
name|B
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"B"
argument_list|)
argument_list|)
expr_stmt|;
name|FB1
operator|=
name|insertAccumulateFunction
argument_list|(
name|B
operator|.
name|get
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|"FB1"
argument_list|)
expr_stmt|;
comment|// Declare FB1 in A (as an external).
name|A
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"A"
argument_list|)
argument_list|)
expr_stmt|;
name|Function
modifier|*
name|FB1Extern
init|=
name|insertExternalReferenceToFunction
argument_list|(
name|A
operator|.
name|get
argument_list|()
argument_list|,
name|FB1
argument_list|)
decl_stmt|;
comment|// Define FA in A (with a call to FB1).
name|FA
operator|=
name|insertAccumulateFunction
argument_list|(
name|A
operator|.
name|get
argument_list|()
argument_list|,
name|FB1Extern
argument_list|,
literal|"FA"
argument_list|)
expr_stmt|;
comment|// Declare FA in B (as an external)
name|Function
modifier|*
name|FAExtern
init|=
name|insertExternalReferenceToFunction
argument_list|(
name|B
operator|.
name|get
argument_list|()
argument_list|,
name|FA
argument_list|)
decl_stmt|;
comment|// Define FB2 in B (with a call to FA)
name|FB2
operator|=
name|insertAccumulateFunction
argument_list|(
name|B
operator|.
name|get
argument_list|()
argument_list|,
name|FAExtern
argument_list|,
literal|"FB2"
argument_list|)
expr_stmt|;
block|}
comment|// Module A { Function FA },
comment|// Module B { Extern FA, Function FB which calls FA },
comment|// Module C { Extern FB, Function FC which calls FB },
name|void
name|createThreeModuleChainedCallsCase
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|A
argument_list|,
name|Function
operator|*
operator|&
name|FA
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|B
argument_list|,
name|Function
operator|*
operator|&
name|FB
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|C
argument_list|,
name|Function
operator|*
operator|&
name|FC
argument_list|)
block|{
name|A
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"A"
argument_list|)
argument_list|)
expr_stmt|;
name|FA
operator|=
name|insertAddFunction
argument_list|(
name|A
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|B
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"B"
argument_list|)
argument_list|)
expr_stmt|;
name|Function
modifier|*
name|FAExtern_in_B
init|=
name|insertExternalReferenceToFunction
argument_list|(
name|B
operator|.
name|get
argument_list|()
argument_list|,
name|FA
argument_list|)
decl_stmt|;
name|FB
operator|=
name|insertSimpleCallFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|,
name|int32_t
argument_list|)
operator|>
operator|(
name|B
operator|.
name|get
argument_list|()
operator|,
name|FAExtern_in_B
operator|)
expr_stmt|;
name|C
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"C"
argument_list|)
argument_list|)
expr_stmt|;
name|Function
modifier|*
name|FBExtern_in_C
init|=
name|insertExternalReferenceToFunction
argument_list|(
name|C
operator|.
name|get
argument_list|()
argument_list|,
name|FB
argument_list|)
decl_stmt|;
name|FC
operator|=
name|insertSimpleCallFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|,
name|int32_t
argument_list|)
operator|>
operator|(
name|C
operator|.
name|get
argument_list|()
operator|,
name|FBExtern_in_C
operator|)
expr_stmt|;
block|}
comment|// Module A { Function FA },
comment|// Populates Modules A and B:
comment|// Module B { Function FB }
name|void
name|createTwoModuleCase
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|A
argument_list|,
name|Function
operator|*
operator|&
name|FA
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|B
argument_list|,
name|Function
operator|*
operator|&
name|FB
argument_list|)
block|{
name|A
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"A"
argument_list|)
argument_list|)
expr_stmt|;
name|FA
operator|=
name|insertAddFunction
argument_list|(
name|A
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|B
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"B"
argument_list|)
argument_list|)
expr_stmt|;
name|FB
operator|=
name|insertAddFunction
argument_list|(
name|B
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Module A { Function FA },
comment|// Module B { Extern FA, Function FB which calls FA }
name|void
name|createTwoModuleExternCase
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|A
argument_list|,
name|Function
operator|*
operator|&
name|FA
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|B
argument_list|,
name|Function
operator|*
operator|&
name|FB
argument_list|)
block|{
name|A
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"A"
argument_list|)
argument_list|)
expr_stmt|;
name|FA
operator|=
name|insertAddFunction
argument_list|(
name|A
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|B
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"B"
argument_list|)
argument_list|)
expr_stmt|;
name|Function
modifier|*
name|FAExtern_in_B
init|=
name|insertExternalReferenceToFunction
argument_list|(
name|B
operator|.
name|get
argument_list|()
argument_list|,
name|FA
argument_list|)
decl_stmt|;
name|FB
operator|=
name|insertSimpleCallFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|,
name|int32_t
argument_list|)
operator|>
operator|(
name|B
operator|.
name|get
argument_list|()
operator|,
name|FAExtern_in_B
operator|)
expr_stmt|;
block|}
comment|// Module A { Function FA },
comment|// Module B { Extern FA, Function FB which calls FA },
comment|// Module C { Extern FB, Function FC which calls FA },
name|void
name|createThreeModuleCase
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|A
argument_list|,
name|Function
operator|*
operator|&
name|FA
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|B
argument_list|,
name|Function
operator|*
operator|&
name|FB
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
operator|&
name|C
argument_list|,
name|Function
operator|*
operator|&
name|FC
argument_list|)
block|{
name|A
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"A"
argument_list|)
argument_list|)
expr_stmt|;
name|FA
operator|=
name|insertAddFunction
argument_list|(
name|A
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|B
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"B"
argument_list|)
argument_list|)
expr_stmt|;
name|Function
modifier|*
name|FAExtern_in_B
init|=
name|insertExternalReferenceToFunction
argument_list|(
name|B
operator|.
name|get
argument_list|()
argument_list|,
name|FA
argument_list|)
decl_stmt|;
name|FB
operator|=
name|insertSimpleCallFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|,
name|int32_t
argument_list|)
operator|>
operator|(
name|B
operator|.
name|get
argument_list|()
operator|,
name|FAExtern_in_B
operator|)
expr_stmt|;
name|C
operator|.
name|reset
argument_list|(
name|createEmptyModule
argument_list|(
literal|"C"
argument_list|)
argument_list|)
expr_stmt|;
name|Function
modifier|*
name|FAExtern_in_C
init|=
name|insertExternalReferenceToFunction
argument_list|(
name|C
operator|.
name|get
argument_list|()
argument_list|,
name|FA
argument_list|)
decl_stmt|;
name|FC
operator|=
name|insertSimpleCallFunction
operator|<
name|int32_t
argument_list|(
name|int32_t
argument_list|,
name|int32_t
argument_list|)
operator|>
operator|(
name|C
operator|.
name|get
argument_list|()
operator|,
name|FAExtern_in_C
operator|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|MCJITTestBase
range|:
name|public
name|MCJITTestAPICommon
decl_stmt|,
name|public
name|TrivialModuleBuilder
block|{
name|protected
label|:
name|MCJITTestBase
argument_list|()
operator|:
name|TrivialModuleBuilder
argument_list|(
name|HostTriple
argument_list|)
operator|,
name|OptLevel
argument_list|(
name|CodeGenOpt
operator|::
name|None
argument_list|)
operator|,
name|RelocModel
argument_list|(
name|Reloc
operator|::
name|Default
argument_list|)
operator|,
name|CodeModel
argument_list|(
name|CodeModel
operator|::
name|Default
argument_list|)
operator|,
name|MArch
argument_list|(
literal|""
argument_list|)
operator|,
name|MM
argument_list|(
argument|new SectionMemoryManager
argument_list|)
block|{
comment|// The architectures below are known to be compatible with MCJIT as they
comment|// are copied from test/ExecutionEngine/MCJIT/lit.local.cfg and should be
comment|// kept in sync.
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|aarch64
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|arm
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|mips
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|mipsel
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|x86
argument_list|)
block|;
name|SupportedArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|x86_64
argument_list|)
block|;
comment|// Some architectures have sub-architectures in which tests will fail, like
comment|// ARM. These two vectors will define if they do have sub-archs (to avoid
comment|// extra work for those who don't), and if so, if they are listed to work
name|HasSubArchs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|arm
argument_list|)
block|;
name|SupportedSubArchs
operator|.
name|push_back
argument_list|(
literal|"armv6"
argument_list|)
block|;
name|SupportedSubArchs
operator|.
name|push_back
argument_list|(
literal|"armv7"
argument_list|)
block|;
comment|// The operating systems below are known to be incompatible with MCJIT as
comment|// they are copied from the test/ExecutionEngine/MCJIT/lit.local.cfg and
comment|// should be kept in sync.
name|UnsupportedOSs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|Cygwin
argument_list|)
block|;
name|UnsupportedOSs
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|Darwin
argument_list|)
block|;
name|UnsupportedEnvironments
operator|.
name|push_back
argument_list|(
name|Triple
operator|::
name|Cygnus
argument_list|)
block|;   }
name|void
name|createJIT
argument_list|(
argument|Module *M
argument_list|)
block|{
comment|// Due to the EngineBuilder constructor, it is required to have a Module
comment|// in order to construct an ExecutionEngine (i.e. MCJIT)
name|assert
argument_list|(
name|M
operator|!=
literal|0
operator|&&
literal|"a non-null Module must be provided to create MCJIT"
argument_list|)
block|;
name|EngineBuilder
name|EB
argument_list|(
name|M
argument_list|)
block|;
name|std
operator|::
name|string
name|Error
block|;
name|TheJIT
operator|.
name|reset
argument_list|(
name|EB
operator|.
name|setEngineKind
argument_list|(
name|EngineKind
operator|::
name|JIT
argument_list|)
operator|.
name|setUseMCJIT
argument_list|(
name|true
argument_list|)
comment|/* can this be folded into the EngineKind enum? */
operator|.
name|setMCJITMemoryManager
argument_list|(
name|MM
argument_list|)
operator|.
name|setErrorStr
argument_list|(
operator|&
name|Error
argument_list|)
operator|.
name|setOptLevel
argument_list|(
name|CodeGenOpt
operator|::
name|None
argument_list|)
operator|.
name|setAllocateGVsWithCode
argument_list|(
name|false
argument_list|)
comment|/*does this do anything?*/
operator|.
name|setCodeModel
argument_list|(
name|CodeModel
operator|::
name|JITDefault
argument_list|)
operator|.
name|setRelocationModel
argument_list|(
name|Reloc
operator|::
name|Default
argument_list|)
operator|.
name|setMArch
argument_list|(
name|MArch
argument_list|)
operator|.
name|setMCPU
argument_list|(
name|sys
operator|::
name|getHostCPUName
argument_list|()
argument_list|)
comment|//.setMAttrs(MAttrs)
operator|.
name|create
argument_list|()
argument_list|)
block|;
comment|// At this point, we cannot modify the module any more.
name|assert
argument_list|(
name|TheJIT
operator|.
name|get
argument_list|()
operator|!=
name|NULL
operator|&&
literal|"error creating MCJIT with EngineBuilder"
argument_list|)
block|;   }
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
expr_stmt|;
name|Reloc
operator|::
name|Model
name|RelocModel
expr_stmt|;
name|CodeModel
operator|::
name|Model
name|CodeModel
expr_stmt|;
name|StringRef
name|MArch
decl_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|string
operator|,
literal|1
operator|>
name|MAttrs
expr_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|ExecutionEngine
operator|>
name|TheJIT
expr_stmt|;
name|RTDyldMemoryManager
modifier|*
name|MM
decl_stmt|;
name|std
operator|::
name|unique_ptr
operator|<
name|Module
operator|>
name|M
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// MCJIT_TEST_H
end_comment

end_unit

