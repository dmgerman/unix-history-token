begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-ipd-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon ipd.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_IPD_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_IPD_TYPEDEFS_H__
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_1ST_MBUFF_SKIP
value|(CVMX_ADD_IO_SEG(0x00014F0000000000ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_1st_NEXT_PTR_BACK
value|(CVMX_ADD_IO_SEG(0x00014F0000000150ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_2nd_NEXT_PTR_BACK
value|(CVMX_ADD_IO_SEG(0x00014F0000000158ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_BIST_STATUS
value|(CVMX_ADD_IO_SEG(0x00014F00000007F8ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_BP_PRT_RED_END
value|(CVMX_ADD_IO_SEG(0x00014F0000000328ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_CLK_COUNT
value|(CVMX_ADD_IO_SEG(0x00014F0000000338ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_CTL_STATUS
value|(CVMX_ADD_IO_SEG(0x00014F0000000018ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_INT_ENB
value|(CVMX_ADD_IO_SEG(0x00014F0000000160ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_INT_SUM
value|(CVMX_ADD_IO_SEG(0x00014F0000000168ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_NOT_1ST_MBUFF_SKIP
value|(CVMX_ADD_IO_SEG(0x00014F0000000008ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_PACKET_MBUFF_SIZE
value|(CVMX_ADD_IO_SEG(0x00014F0000000010ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_PKT_PTR_VALID
value|(CVMX_ADD_IO_SEG(0x00014F0000000358ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORTX_BP_PAGE_CNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
name|offset
operator|==
literal|32
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORTX_BP_PAGE_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORTX_BP_PAGE_CNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F0000000028ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORTX_BP_PAGE_CNT2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORTX_BP_PAGE_CNT2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000368ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|36
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORTX_BP_PAGE_CNT2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F0000000368ull) + ((offset)& 63) * 8 - 8*36)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORTX_BP_PAGE_CNT3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORTX_BP_PAGE_CNT3(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F00000003D0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORTX_BP_PAGE_CNT3
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F00000003D0ull) + ((offset)& 63) * 8 - 8*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORT_BP_COUNTERS2_PAIRX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORT_BP_COUNTERS2_PAIRX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000388ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|36
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORT_BP_COUNTERS2_PAIRX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F0000000388ull) + ((offset)& 63) * 8 - 8*36)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORT_BP_COUNTERS3_PAIRX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORT_BP_COUNTERS3_PAIRX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F00000003B0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
operator|-
literal|8
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORT_BP_COUNTERS3_PAIRX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F00000003B0ull) + ((offset)& 63) * 8 - 8*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORT_BP_COUNTERS_PAIRX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
name|offset
operator|==
literal|32
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORT_BP_COUNTERS_PAIRX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F00000001B8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORT_BP_COUNTERS_PAIRX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F00000001B8ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORT_QOS_INTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|==
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|==
literal|2
operator|)
operator|||
operator|(
name|offset
operator|==
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|==
literal|4
operator|)
operator|||
operator|(
name|offset
operator|==
literal|5
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORT_QOS_INTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000808ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORT_QOS_INTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F0000000808ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORT_QOS_INT_ENBX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|==
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|==
literal|2
operator|)
operator|||
operator|(
name|offset
operator|==
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|==
literal|4
operator|)
operator|||
operator|(
name|offset
operator|==
literal|5
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORT_QOS_INT_ENBX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000848ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORT_QOS_INT_ENBX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F0000000848ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_PORT_QOS_X_CNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|256
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|319
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|128
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|159
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|256
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|319
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|256
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|351
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_PORT_QOS_X_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000888ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|511
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_PORT_QOS_X_CNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F0000000888ull) + ((offset)& 511) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_IPD_PRC_HOLD_PTR_FIFO_CTL
value|(CVMX_ADD_IO_SEG(0x00014F0000000348ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_PRC_PORT_PTR_FIFO_CTL
value|(CVMX_ADD_IO_SEG(0x00014F0000000350ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_PTR_COUNT
value|(CVMX_ADD_IO_SEG(0x00014F0000000320ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_PWP_PTR_FIFO_CTL
value|(CVMX_ADD_IO_SEG(0x00014F0000000340ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS0_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(0)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS1_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(1)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS2_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(2)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS3_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(3)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS4_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(4)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS5_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(5)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS6_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(6)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_QOS7_RED_MARKS
value|CVMX_IPD_QOSX_RED_MARKS(7)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_QOSX_RED_MARKS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_QOSX_RED_MARKS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000178ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_QOSX_RED_MARKS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F0000000178ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_IPD_QUE0_FREE_PAGE_CNT
value|(CVMX_ADD_IO_SEG(0x00014F0000000330ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_PORT_ENABLE
value|(CVMX_ADD_IO_SEG(0x00014F00000002D8ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_IPD_RED_PORT_ENABLE2
value|CVMX_IPD_RED_PORT_ENABLE2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_RED_PORT_ENABLE2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_RED_PORT_ENABLE2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F00000003A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_RED_PORT_ENABLE2
value|(CVMX_ADD_IO_SEG(0x00014F00000003A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE0_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(0)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE1_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(1)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE2_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(2)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE3_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(3)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE4_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(4)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE5_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(5)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE6_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(6)
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUE7_PARAM
value|CVMX_IPD_RED_QUEX_PARAM(7)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_RED_QUEX_PARAM
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_RED_QUEX_PARAM(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F00000002E0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_RED_QUEX_PARAM
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00014F00000002E0ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_IPD_SUB_PORT_BP_PAGE_CNT
value|(CVMX_ADD_IO_SEG(0x00014F0000000148ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_SUB_PORT_FCS
value|(CVMX_ADD_IO_SEG(0x00014F0000000170ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_IPD_SUB_PORT_QOS_CNT
value|CVMX_IPD_SUB_PORT_QOS_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_IPD_SUB_PORT_QOS_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_IPD_SUB_PORT_QOS_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00014F0000000800ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_IPD_SUB_PORT_QOS_CNT
value|(CVMX_ADD_IO_SEG(0x00014F0000000800ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_IPD_WQE_FPA_QUEUE
value|(CVMX_ADD_IO_SEG(0x00014F0000000020ull))
end_define

begin_define
define|#
directive|define
name|CVMX_IPD_WQE_PTR_VALID
value|(CVMX_ADD_IO_SEG(0x00014F0000000360ull))
end_define

begin_comment
comment|/**  * cvmx_ipd_1st_mbuff_skip  *  * IPD_1ST_MBUFF_SKIP = IPD First MBUFF Word Skip Size  *  * The number of words that the IPD will skip when writing the first MBUFF.  */
end_comment

begin_union
union|union
name|cvmx_ipd_1st_mbuff_skip
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_1st_mbuff_skip_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|skip_sz
range|:
literal|6
decl_stmt|;
comment|/**< The number of 8-byte words from the top of the                                                          1st MBUFF that the IPD will store the next-pointer.                                                          Legal values are 0 to 32, where the MAX value                                                          is also limited to:                                                          IPD_PACKET_MBUFF_SIZE[MB_SIZE] - 18.                                                          Must be at least 16 when IPD_CTL_STATUS[NO_WPTR]                                                          is set. */
else|#
directive|else
name|uint64_t
name|skip_sz
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_mbuff_skip_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_1st_mbuff_skip
name|cvmx_ipd_1st_mbuff_skip_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_1st_next_ptr_back  *  * IPD_1st_NEXT_PTR_BACK = IPD First Next Pointer Back Values  *  * Contains the Back Field for use in creating the Next Pointer Header for the First MBUF  */
end_comment

begin_union
union|union
name|cvmx_ipd_1st_next_ptr_back
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_1st_next_ptr_back_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Used to find head of buffer from the nxt-hdr-ptr. */
else|#
directive|else
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_1st_next_ptr_back_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_1st_next_ptr_back
name|cvmx_ipd_1st_next_ptr_back_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_2nd_next_ptr_back  *  * IPD_2nd_NEXT_PTR_BACK = IPD Second Next Pointer Back Value  *  * Contains the Back Field for use in creating the Next Pointer Header for the First MBUF  */
end_comment

begin_union
union|union
name|cvmx_ipd_2nd_next_ptr_back
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_2nd_next_ptr_back_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
comment|/**< Used to find head of buffer from the nxt-hdr-ptr. */
else|#
directive|else
name|uint64_t
name|back
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_2nd_next_ptr_back_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_2nd_next_ptr_back
name|cvmx_ipd_2nd_next_ptr_back_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_bist_status  *  * IPD_BIST_STATUS = IPD BIST STATUS  *  * BIST Status for IPD's Memories.  */
end_comment

begin_union
union|union
name|cvmx_ipd_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_bist_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|csr_mem
range|:
literal|1
decl_stmt|;
comment|/**< CSR Register Memory Bist Status. */
name|uint64_t
name|csr_ncmd
range|:
literal|1
decl_stmt|;
comment|/**< CSR NCB Commands Memory Bist Status. */
name|uint64_t
name|pwq_wqed
range|:
literal|1
decl_stmt|;
comment|/**< PWQ PIP WQE DONE Memory Bist Status. */
name|uint64_t
name|pwq_wp1
range|:
literal|1
decl_stmt|;
comment|/**< PWQ WQE PAGE1 PTR Memory Bist Status. */
name|uint64_t
name|pwq_pow
range|:
literal|1
decl_stmt|;
comment|/**< PWQ POW MEM Memory Bist Status. */
name|uint64_t
name|ipq_pbe1
range|:
literal|1
decl_stmt|;
comment|/**< IPQ PBE1 Memory Bist Status. */
name|uint64_t
name|ipq_pbe0
range|:
literal|1
decl_stmt|;
comment|/**< IPQ PBE0 Memory Bist Status. */
name|uint64_t
name|pbm3
range|:
literal|1
decl_stmt|;
comment|/**< PBM3 Memory Bist Status. */
name|uint64_t
name|pbm2
range|:
literal|1
decl_stmt|;
comment|/**< PBM2 Memory Bist Status. */
name|uint64_t
name|pbm1
range|:
literal|1
decl_stmt|;
comment|/**< PBM1 Memory Bist Status. */
name|uint64_t
name|pbm0
range|:
literal|1
decl_stmt|;
comment|/**< PBM0 Memory Bist Status. */
name|uint64_t
name|pbm_word
range|:
literal|1
decl_stmt|;
comment|/**< PBM_WORD Memory Bist Status. */
name|uint64_t
name|pwq1
range|:
literal|1
decl_stmt|;
comment|/**< PWQ1 Memory Bist Status. */
name|uint64_t
name|pwq0
range|:
literal|1
decl_stmt|;
comment|/**< PWQ0 Memory Bist Status. */
name|uint64_t
name|prc_off
range|:
literal|1
decl_stmt|;
comment|/**< PRC_OFF Memory Bist Status. */
name|uint64_t
name|ipd_old
range|:
literal|1
decl_stmt|;
comment|/**< IPD_OLD Memory Bist Status. */
name|uint64_t
name|ipd_new
range|:
literal|1
decl_stmt|;
comment|/**< IPD_NEW Memory Bist Status. */
name|uint64_t
name|pwp
range|:
literal|1
decl_stmt|;
comment|/**< PWP Memory Bist Status. */
else|#
directive|else
name|uint64_t
name|pwp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_new
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_old
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipq_pbe0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipq_pbe1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq_pow
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq_wp1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq_wqed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr_ncmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|csr_mem
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ipd_bist_status_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|pwq_wqed
range|:
literal|1
decl_stmt|;
comment|/**< PWQ PIP WQE DONE Memory Bist Status. */
name|uint64_t
name|pwq_wp1
range|:
literal|1
decl_stmt|;
comment|/**< PWQ WQE PAGE1 PTR Memory Bist Status. */
name|uint64_t
name|pwq_pow
range|:
literal|1
decl_stmt|;
comment|/**< PWQ POW MEM Memory Bist Status. */
name|uint64_t
name|ipq_pbe1
range|:
literal|1
decl_stmt|;
comment|/**< IPQ PBE1 Memory Bist Status. */
name|uint64_t
name|ipq_pbe0
range|:
literal|1
decl_stmt|;
comment|/**< IPQ PBE0 Memory Bist Status. */
name|uint64_t
name|pbm3
range|:
literal|1
decl_stmt|;
comment|/**< PBM3 Memory Bist Status. */
name|uint64_t
name|pbm2
range|:
literal|1
decl_stmt|;
comment|/**< PBM2 Memory Bist Status. */
name|uint64_t
name|pbm1
range|:
literal|1
decl_stmt|;
comment|/**< PBM1 Memory Bist Status. */
name|uint64_t
name|pbm0
range|:
literal|1
decl_stmt|;
comment|/**< PBM0 Memory Bist Status. */
name|uint64_t
name|pbm_word
range|:
literal|1
decl_stmt|;
comment|/**< PBM_WORD Memory Bist Status. */
name|uint64_t
name|pwq1
range|:
literal|1
decl_stmt|;
comment|/**< PWQ1 Memory Bist Status. */
name|uint64_t
name|pwq0
range|:
literal|1
decl_stmt|;
comment|/**< PWQ0 Memory Bist Status. */
name|uint64_t
name|prc_off
range|:
literal|1
decl_stmt|;
comment|/**< PRC_OFF Memory Bist Status. */
name|uint64_t
name|ipd_old
range|:
literal|1
decl_stmt|;
comment|/**< IPD_OLD Memory Bist Status. */
name|uint64_t
name|ipd_new
range|:
literal|1
decl_stmt|;
comment|/**< IPD_NEW Memory Bist Status. */
name|uint64_t
name|pwp
range|:
literal|1
decl_stmt|;
comment|/**< PWP Memory Bist Status. */
else|#
directive|else
name|uint64_t
name|pwp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_new
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_old
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbm3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipq_pbe0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipq_pbe1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq_pow
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq_wp1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pwq_wqed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_ipd_bist_status_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_bist_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_bist_status
name|cvmx_ipd_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_bp_prt_red_end  *  * IPD_BP_PRT_RED_END = IPD Backpressure Port RED Enable  *  * When IPD applies backpressure to a PORT and the corresponding bit in this register is set,  * the RED Unit will drop packets for that port.  */
end_comment

begin_union
union|union
name|cvmx_ipd_bp_prt_red_end
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_bp_prt_red_end_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|prt_enb
range|:
literal|44
decl_stmt|;
comment|/**< The port corresponding to the bit position in this                                                          field will drop all NON-RAW packets to that port                                                          when port level backpressure is applied to that                                                          port.  The applying of port-level backpressure for                                                          this dropping does not take into consideration the                                                          value of IPD_PORTX_BP_PAGE_CNT[BP_ENB], nor                                                          IPD_RED_PORT_ENABLE[PRT_ENB]. */
else|#
directive|else
name|uint64_t
name|prt_enb
range|:
literal|44
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ipd_bp_prt_red_end_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|prt_enb
range|:
literal|36
decl_stmt|;
comment|/**< The port corresponding to the bit position in this                                                          field, will allow RED to drop back when port level                                                          backpressure is applied to the port. The applying                                                          of port-level backpressure for this RED dropping                                                          does not take into consideration the value of                                                          IPD_PORTX_BP_PAGE_CNT[BP_ENB]. */
else|#
directive|else
name|uint64_t
name|prt_enb
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_ipd_bp_prt_red_end_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|prt_enb
range|:
literal|40
decl_stmt|;
comment|/**< The port corresponding to the bit position in this                                                          field, will allow RED to drop back when port level                                                          backpressure is applied to the port. The applying                                                          of port-level backpressure for this RED dropping                                                          does not take into consideration the value of                                                          IPD_PORTX_BP_PAGE_CNT[BP_ENB]. */
else|#
directive|else
name|uint64_t
name|prt_enb
range|:
literal|40
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_bp_prt_red_end_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_bp_prt_red_end
name|cvmx_ipd_bp_prt_red_end_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_clk_count  *  * IPD_CLK_COUNT = IPD Clock Count  *  * Counts the number of core clocks periods since the de-asserition of reset.  */
end_comment

begin_union
union|union
name|cvmx_ipd_clk_count
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_clk_count_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|clk_cnt
range|:
literal|64
decl_stmt|;
comment|/**< This counter will be zeroed when reset is applied                                                          and will increment every rising edge of the                                                          core-clock. */
else|#
directive|else
name|uint64_t
name|clk_cnt
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_clk_count_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_clk_count
name|cvmx_ipd_clk_count_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_ctl_status  *  * IPD_CTL_STATUS = IPD's Control Status Register  *  * The number of words in a MBUFF used for packet data store.  */
end_comment

begin_union
union|union
name|cvmx_ipd_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_ctl_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|use_sop
range|:
literal|1
decl_stmt|;
comment|/**< When '1' the SOP sent by the MAC will be used in                                                          place of the SOP generated by the IPD. */
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
comment|/**< When '0' IPD has finished reset. No access                                                          except the reading of this bit should occur to the                                                          IPD until this is asserted. Or a 1000 core clock                                                          cycles has passed after the de-assertion of reset. */
name|uint64_t
name|clken
range|:
literal|1
decl_stmt|;
comment|/**< Controls the conditional clocking within IPD                                                          0=Allow HW to control the clocks                                                          1=Force the clocks to be always on */
name|uint64_t
name|no_wptr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the WQE pointers will not be used and                                                          the WQE will be located at the front of the packet.                                                          When set:                                                            - IPD_WQE_FPA_QUEUE[WQE_QUE] is not used                                                            - IPD_1ST_MBUFF_SKIP[SKIP_SZ] must be at least 16                                                            - If 16<= IPD_1ST_MBUFF_SKIP[SKIP_SZ]<= 31 then                                                              the WQE will be written into the first 128B                                                              cache block in the first buffer that contains                                                              the packet.                                                            - If IPD_1ST_MBUFF_SKIP[SKIP_SZ] == 32 then                                                              the WQE will be written into the second 128B                                                              cache block in the first buffer that contains                                                              the packet. */
name|uint64_t
name|pq_apkt
range|:
literal|1
decl_stmt|;
comment|/**< When set IPD_PORT_QOS_X_CNT WILL be incremented                                                          by one for every work queue entry that is sent to                                                          POW. */
name|uint64_t
name|pq_nabuf
range|:
literal|1
decl_stmt|;
comment|/**< When set IPD_PORT_QOS_X_CNT WILL NOT be                                                          incremented when IPD allocates a buffer for a                                                          packet. */
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD acts normaly.                                                          When set '1' the IPD drive the IPD_BUFF_FULL line to                                                          the IOB-arbiter, telling it to not give grants to                                                          NCB devices sending packet data. */
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD working normaly,                                                          buffering the received packet data. When set '1'                                                          the IPD will not buffer the received packet data. */
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
comment|/**< Setting of this bit will subtract 8 from the                                                          data-length field in the header written to the                                                          POW and the top of a MBUFF.                                                          OCTEAN generates a length that includes the                                                          length of the data + 8 for the header-field. By                                                          setting this bit the 8 for the instr-field will                                                          not be included in the length field of the header.                                                          NOTE: IPD is compliant with the spec when this                                                          field is '1'. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' causes a reset of the IPD, except                                                          RSL. */
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[ADDPKT] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL],                                                          IPD_PORT_BP_COUNTERS2_PAIR(port)[CNT_VAL] and                                                          IPD_PORT_BP_COUNTERS3_PAIR(port)[CNT_VAL]                                                          WILL be incremented by one for every work                                                          queue entry that is sent to POW. */
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[NADDBUF] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL],                                                          IPD_PORT_BP_COUNTERS2_PAIR(port)[CNT_VAL] and                                                          IPD_PORT_BP_COUNTERS3_PAIR(port)[CNT_VAL]                                                          WILL NOT be incremented when IPD allocates a                                                          buffer for a packet on the port. */
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes PKT to little endian writes to L2C */
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes WQE to little endian writes to L2C */
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
comment|/**< Port back pressure enable. When set '1' enables                                                          the sending of port level backpressure to the                                                          Octane input-ports. The application should NOT                                                          de-assert this bit after asserting it. The                                                          receivers of this bit may have been put into                                                          backpressure mode and can only be released by                                                          IPD informing them that the backpressure has                                                          been released.                                                          GMXX_INF_MODE[EN] must be set to '1' for each                                                          packet interface which requires port back pressure                                                          prior to setting PBP_EN to '1'. */
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
comment|/**< 0 ==> All packet data (and next buffer pointers)                                                          is written through to memory.                                                          1 ==> All packet data (and next buffer pointers) is                                                          written into the cache.                                                          2 ==> The first aligned cache block holding the                                                          packet data (and initial next buffer pointer) is                                                          written to the L2 cache, all remaining cache blocks                                                          are not written to the L2 cache.                                                          3 ==> The first two aligned cache blocks holding                                                          the packet data (and initial next buffer pointer)                                                          are written to the L2 cache, all remaining cache                                                          blocks are not written to the L2 cache. */
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' enable the operation of the IPD.                                                          When clear '0', the IPD will appear to the                                                          IOB-arbiter to be applying backpressure, this                                                          causes the IOB-Arbiter to not send grants to NCB                                                          devices requesting to send packet data to the IPD. */
else|#
directive|else
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_nabuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_apkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|no_wptr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clken
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ipd_ctl_status_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
comment|/**< Setting of this bit will subtract 8 from the                                                          data-length field in the header written wo the                                                          POW and the top of a MBUFF.                                                          OCTEAN generates a length that includes the                                                          length of the data + 8 for the header-field. By                                                          setting this bit the 8 for the instr-field will                                                          not be included in the length field of the header.                                                          NOTE: IPD is compliant with the spec when this                                                          field is '1'. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' causes a reset of the IPD, except                                                          RSL. */
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[ADDPKT] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL be incremented by one for every work                                                          queue entry that is sent to POW. */
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[NADDBUF] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL NOT be incremented when IPD allocates a                                                          buffer for a packet on the port. */
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes PKT to little endian writes to L2C */
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes WQE to little endian writes to L2C */
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
comment|/**< Port back pressure enable. When set '1' enables                                                          the sending of port level backpressure to the                                                          Octane input-ports. Once enabled the sending of                                                          port-level-backpressure can not be disabled by                                                          changing the value of this bit.                                                          GMXX_INF_MODE[EN] must be set to '1' for each                                                          packet interface which requires port back pressure                                                          prior to setting PBP_EN to '1'. */
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
comment|/**< 0 ==> All packet data (and next buffer pointers)                                                          is written through to memory.                                                          1 ==> All packet data (and next buffer pointers) is                                                          written into the cache.                                                          2 ==> The first aligned cache block holding the                                                          packet data (and initial next buffer pointer) is                                                          written to the L2 cache, all remaining cache blocks                                                          are not written to the L2 cache.                                                          3 ==> The first two aligned cache blocks holding                                                          the packet data (and initial next buffer pointer)                                                          are written to the L2 cache, all remaining cache                                                          blocks are not written to the L2 cache. */
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' enable the operation of the IPD. */
else|#
directive|else
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_ipd_ctl_status_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_ctl_status_cn30xx
name|cn38xx
decl_stmt|;
struct|struct
name|cvmx_ipd_ctl_status_cn38xxp2
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' causes a reset of the IPD, except                                                          RSL. */
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[ADDPKT] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL be incremented by one for every work                                                          queue entry that is sent to POW.                                                          PASS-2 Field. */
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[NADDBUF] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL NOT be incremented when IPD allocates a                                                          buffer for a packet on the port.                                                          PASS-2 Field. */
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes PKT to little endian writes to L2C */
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes WQE to little endian writes to L2C */
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
comment|/**< Port back pressure enable. When set '1' enables                                                          the sending of port level backpressure to the                                                          Octane input-ports. Once enabled the sending of                                                          port-level-backpressure can not be disabled by                                                          changing the value of this bit. */
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
comment|/**< 0 ==> All packet data (and next buffer pointers)                                                          is written through to memory.                                                          1 ==> All packet data (and next buffer pointers) is                                                          written into the cache.                                                          2 ==> The first aligned cache block holding the                                                          packet data (and initial next buffer pointer) is                                                          written to the L2 cache, all remaining cache blocks                                                          are not written to the L2 cache.                                                          3 ==> The first two aligned cache blocks holding                                                          the packet data (and initial next buffer pointer)                                                          are written to the L2 cache, all remaining cache                                                          blocks are not written to the L2 cache. */
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' enable the operation of the IPD. */
else|#
directive|else
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
struct|struct
name|cvmx_ipd_ctl_status_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|no_wptr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the WQE pointers will not be used and                                                          the WQE will be located at the front of the packet. */
name|uint64_t
name|pq_apkt
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|pq_nabuf
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD acts normaly.                                                          When set '1' the IPD drive the IPD_BUFF_FULL line to                                                          the IOB-arbiter, telling it to not give grants to                                                          NCB devices sending packet data. */
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD working normaly,                                                          buffering the received packet data. When set '1'                                                          the IPD will not buffer the received packet data. */
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
comment|/**< Setting of this bit will subtract 8 from the                                                          data-length field in the header written wo the                                                          POW and the top of a MBUFF.                                                          OCTEAN generates a length that includes the                                                          length of the data + 8 for the header-field. By                                                          setting this bit the 8 for the instr-field will                                                          not be included in the length field of the header.                                                          NOTE: IPD is compliant with the spec when this                                                          field is '1'. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' causes a reset of the IPD, except                                                          RSL. */
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[ADDPKT] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL be incremented by one for every work                                                          queue entry that is sent to POW. */
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[NADDBUF] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL NOT be incremented when IPD allocates a                                                          buffer for a packet on the port. */
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes PKT to little endian writes to L2C */
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes WQE to little endian writes to L2C */
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
comment|/**< Port back pressure enable. When set '1' enables                                                          the sending of port level backpressure to the                                                          Octane input-ports. Once enabled the sending of                                                          port-level-backpressure can not be disabled by                                                          changing the value of this bit.                                                          GMXX_INF_MODE[EN] must be set to '1' for each                                                          packet interface which requires port back pressure                                                          prior to setting PBP_EN to '1'. */
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
comment|/**< 0 ==> All packet data (and next buffer pointers)                                                          is written through to memory.                                                          1 ==> All packet data (and next buffer pointers) is                                                          written into the cache.                                                          2 ==> The first aligned cache block holding the                                                          packet data (and initial next buffer pointer) is                                                          written to the L2 cache, all remaining cache blocks                                                          are not written to the L2 cache.                                                          3 ==> The first two aligned cache blocks holding                                                          the packet data (and initial next buffer pointer)                                                          are written to the L2 cache, all remaining cache                                                          blocks are not written to the L2 cache. */
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' enable the operation of the IPD.                                                          When clear '0', the IPD will appear to the                                                          IOB-arbiter to be applying backpressure, this                                                          causes the IOB-Arbiter to not send grants to NCB                                                          devices requesting to send packet data to the IPD. */
else|#
directive|else
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_nabuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_apkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|no_wptr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_ipd_ctl_status_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_ctl_status_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_ctl_status_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_ctl_status_cn50xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_ipd_ctl_status_cn58xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD acts normaly.                                                          When set '1' the IPD drive the IPD_BUFF_FULL line to                                                          the IOB-arbiter, telling it to not give grants to                                                          NCB devices sending packet data. */
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD working normaly,                                                          buffering the received packet data. When set '1'                                                          the IPD will not buffer the received packet data. */
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
comment|/**< Setting of this bit will subtract 8 from the                                                          data-length field in the header written wo the                                                          POW and the top of a MBUFF.                                                          OCTEAN PASS2 generates a length that includes the                                                          length of the data + 8 for the header-field. By                                                          setting this bit the 8 for the instr-field will                                                          not be included in the length field of the header.                                                          NOTE: IPD is compliant with the spec when this                                                          field is '1'. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' causes a reset of the IPD, except                                                          RSL. */
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[ADDPKT] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL be incremented by one for every work                                                          queue entry that is sent to POW.                                                          PASS-2 Field. */
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[NADDBUF] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL]                                                          WILL NOT be incremented when IPD allocates a                                                          buffer for a packet on the port.                                                          PASS-2 Field. */
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes PKT to little endian writes to L2C */
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes WQE to little endian writes to L2C */
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
comment|/**< Port back pressure enable. When set '1' enables                                                          the sending of port level backpressure to the                                                          Octane input-ports. Once enabled the sending of                                                          port-level-backpressure can not be disabled by                                                          changing the value of this bit. */
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
comment|/**< 0 ==> All packet data (and next buffer pointers)                                                          is written through to memory.                                                          1 ==> All packet data (and next buffer pointers) is                                                          written into the cache.                                                          2 ==> The first aligned cache block holding the                                                          packet data (and initial next buffer pointer) is                                                          written to the L2 cache, all remaining cache blocks                                                          are not written to the L2 cache.                                                          3 ==> The first two aligned cache blocks holding                                                          the packet data (and initial next buffer pointer)                                                          are written to the L2 cache, all remaining cache                                                          blocks are not written to the L2 cache. */
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' enable the operation of the IPD.                                                          When clear '0', the IPD will appear to the                                                          IOB-arbiter to be applying backpressure, this                                                          causes the IOB-Arbiter to not send grants to NCB                                                          devices requesting to send packet data to the IPD. */
else|#
directive|else
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_ipd_ctl_status_cn58xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_ctl_status_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_ipd_ctl_status_cn63xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|clken
range|:
literal|1
decl_stmt|;
comment|/**< Controls the conditional clocking within IPD                                                          0=Allow HW to control the clocks                                                          1=Force the clocks to be always on */
name|uint64_t
name|no_wptr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the WQE pointers will not be used and                                                          the WQE will be located at the front of the packet.                                                          When set:                                                            - IPD_WQE_FPA_QUEUE[WQE_QUE] is not used                                                            - IPD_1ST_MBUFF_SKIP[SKIP_SZ] must be at least 16                                                            - If 16<= IPD_1ST_MBUFF_SKIP[SKIP_SZ]<= 31 then                                                              the WQE will be written into the first 128B                                                              cache block in the first buffer that contains                                                              the packet.                                                            - If IPD_1ST_MBUFF_SKIP[SKIP_SZ] == 32 then                                                              the WQE will be written into the second 128B                                                              cache block in the first buffer that contains                                                              the packet. */
name|uint64_t
name|pq_apkt
range|:
literal|1
decl_stmt|;
comment|/**< When set IPD_PORT_QOS_X_CNT WILL be incremented                                                          by one for every work queue entry that is sent to                                                          POW. */
name|uint64_t
name|pq_nabuf
range|:
literal|1
decl_stmt|;
comment|/**< When set IPD_PORT_QOS_X_CNT WILL NOT be                                                          incremented when IPD allocates a buffer for a                                                          packet. */
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD acts normaly.                                                          When set '1' the IPD drive the IPD_BUFF_FULL line to                                                          the IOB-arbiter, telling it to not give grants to                                                          NCB devices sending packet data. */
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
comment|/**< When clear '0' the IPD working normaly,                                                          buffering the received packet data. When set '1'                                                          the IPD will not buffer the received packet data. */
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
comment|/**< Setting of this bit will subtract 8 from the                                                          data-length field in the header written to the                                                          POW and the top of a MBUFF.                                                          OCTEAN generates a length that includes the                                                          length of the data + 8 for the header-field. By                                                          setting this bit the 8 for the instr-field will                                                          not be included in the length field of the header.                                                          NOTE: IPD is compliant with the spec when this                                                          field is '1'. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' causes a reset of the IPD, except                                                          RSL. */
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[ADDPKT] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL],                                                          IPD_PORT_BP_COUNTERS2_PAIR(port)[CNT_VAL] and                                                          IPD_PORT_BP_COUNTERS3_PAIR(port)[CNT_VAL]                                                          WILL be incremented by one for every work                                                          queue entry that is sent to POW. */
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
comment|/**< When IPD_CTL_STATUS[NADDBUF] is set,                                                          IPD_PORT_BP_COUNTERS_PAIR(port)[CNT_VAL],                                                          IPD_PORT_BP_COUNTERS2_PAIR(port)[CNT_VAL] and                                                          IPD_PORT_BP_COUNTERS3_PAIR(port)[CNT_VAL]                                                          WILL NOT be incremented when IPD allocates a                                                          buffer for a packet on the port. */
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes PKT to little endian writes to L2C */
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
comment|/**< Changes WQE to little endian writes to L2C */
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
comment|/**< Port back pressure enable. When set '1' enables                                                          the sending of port level backpressure to the                                                          Octane input-ports. The application should NOT                                                          de-assert this bit after asserting it. The                                                          receivers of this bit may have been put into                                                          backpressure mode and can only be released by                                                          IPD informing them that the backpressure has                                                          been released.                                                          GMXX_INF_MODE[EN] must be set to '1' for each                                                          packet interface which requires port back pressure                                                          prior to setting PBP_EN to '1'. */
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
comment|/**< 0 ==> All packet data (and next buffer pointers)                                                          is written through to memory.                                                          1 ==> All packet data (and next buffer pointers) is                                                          written into the cache.                                                          2 ==> The first aligned cache block holding the                                                          packet data (and initial next buffer pointer) is                                                          written to the L2 cache, all remaining cache blocks                                                          are not written to the L2 cache.                                                          3 ==> The first two aligned cache blocks holding                                                          the packet data (and initial next buffer pointer)                                                          are written to the L2 cache, all remaining cache                                                          blocks are not written to the L2 cache. */
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' enable the operation of the IPD.                                                          When clear '0', the IPD will appear to the                                                          IOB-arbiter to be applying backpressure, this                                                          causes the IOB-Arbiter to not send grants to NCB                                                          devices requesting to send packet data to the IPD. */
else|#
directive|else
name|uint64_t
name|ipd_en
range|:
literal|1
decl_stmt|;
name|cvmx_ipd_mode_t
name|opc_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wqe_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_lend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|naddbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addpkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len_m8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_off
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipd_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_nabuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_apkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|no_wptr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clken
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_ctl_status
name|cvmx_ipd_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_int_enb  *  * IPD_INTERRUPT_ENB = IPD Interrupt Enable Register  *  * Used to enable the various interrupting conditions of IPD  */
end_comment

begin_union
union|union
name|cvmx_ipd_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_int_enb_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|pq_sub
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set. */
name|uint64_t
name|pq_add
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set. */
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set. */
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set. */
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set. */
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set. */
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set. */
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
comment|/**< Enables interrupts when a backpressure subtract                                                          has an illegal value. */
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [127:96] of the PBM memory. */
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [95:64] of the PBM memory. */
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [63:32] of the PBM memory. */
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [31:0] of the PBM memory. */
else|#
directive|else
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_add
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ipd_int_enb_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
comment|/**< Enables interrupts when a backpressure subtract                                                          has an illegal value. */
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [127:96] of the PBM memory. */
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [95:64] of the PBM memory. */
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [63:32] of the PBM memory. */
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [31:0] of the PBM memory. */
else|#
directive|else
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_ipd_int_enb_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_ipd_int_enb_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set.                                                          This is a PASS-3 Field. */
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set.                                                          This is a PASS-3 Field. */
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set.                                                          This is a PASS-3 Field. */
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set.                                                          This is a PASS-3 Field. */
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Allows an interrupt to be sent when the                                                          corresponding bit in the IPD_INT_SUM is set.                                                          This is a PASS-3 Field. */
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
comment|/**< Enables interrupts when a backpressure subtract                                                          has an illegal value. */
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [127:96] of the PBM memory. */
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [95:64] of the PBM memory. */
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [63:32] of the PBM memory. */
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
comment|/**< Enable parity error interrupts for bits                                                          [31:0] of the PBM memory. */
else|#
directive|else
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_ipd_int_enb_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_cn38xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_cn38xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_enb_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_int_enb
name|cvmx_ipd_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_int_sum  *  * IPD_INTERRUPT_SUM = IPD Interrupt Summary Register  *  * Set when an interrupt condition occurs, write '1' to clear.  */
end_comment

begin_union
union|union
name|cvmx_ipd_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_int_sum_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|pq_sub
range|:
literal|1
decl_stmt|;
comment|/**< Set when a port-qos does an sub to the count                                                          that causes the counter to wrap. */
name|uint64_t
name|pq_add
range|:
literal|1
decl_stmt|;
comment|/**< Set when a port-qos does an add to the count                                                          that causes the counter to wrap. */
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Set when the byte-count to send to IOB overflows. */
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
comment|/**< Set when the packet/WQE data to be sent to IOB                                                          collides. */
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
comment|/**< Set when the packet/WQE commands to be sent to IOB                                                          collides. */
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Set when the command credits to the IOB overflow. */
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Set when the data credits to the IOB overflow. */
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
comment|/**< Set when a backpressure subtract is done with a                                                          supplied illegal value. */
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [127:96] of the PBM memory. */
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [95:64] of the PBM memory. */
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [63:32] of the PBM memory. */
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [31:0] of the PBM memory. */
else|#
directive|else
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_add
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pq_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ipd_int_sum_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
comment|/**< Set when a backpressure subtract is done with a                                                          supplied illegal value. */
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [127:96] of the PBM memory. */
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [95:64] of the PBM memory. */
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [63:32] of the PBM memory. */
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [31:0] of the PBM memory. */
else|#
directive|else
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_ipd_int_sum_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_ipd_int_sum_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Set when the byte-count to send to IOB overflows.                                                          This is a PASS-3 Field. */
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
comment|/**< Set when the packet/WQE data to be sent to IOB                                                          collides.                                                          This is a PASS-3 Field. */
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
comment|/**< Set when the packet/WQE commands to be sent to IOB                                                          collides.                                                          This is a PASS-3 Field. */
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Set when the command credits to the IOB overflow.                                                          This is a PASS-3 Field. */
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Set when the data credits to the IOB overflow.                                                          This is a PASS-3 Field. */
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
comment|/**< Set when a backpressure subtract is done with a                                                          supplied illegal value. */
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [127:96] of the PBM memory. */
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [95:64] of the PBM memory. */
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [63:32] of the PBM memory. */
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
comment|/**< Set when a parity error is dected for bits                                                          [31:0] of the PBM memory. */
else|#
directive|else
name|uint64_t
name|prc_par0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prc_par3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bp_sub
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_coll
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bc_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_ipd_int_sum_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_cn38xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_cn38xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_int_sum_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_int_sum
name|cvmx_ipd_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_not_1st_mbuff_skip  *  * IPD_NOT_1ST_MBUFF_SKIP = IPD Not First MBUFF Word Skip Size  *  * The number of words that the IPD will skip when writing any MBUFF that is not the first.  */
end_comment

begin_union
union|union
name|cvmx_ipd_not_1st_mbuff_skip
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|skip_sz
range|:
literal|6
decl_stmt|;
comment|/**< The number of 8-byte words from the top of any                                                          MBUFF, that is not the 1st MBUFF, that the IPD                                                          will write the next-pointer.                                                          Legal values are 0 to 32, where the MAX value                                                          is also limited to:                                                          IPD_PACKET_MBUFF_SIZE[MB_SIZE] - 16. */
else|#
directive|else
name|uint64_t
name|skip_sz
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_not_1st_mbuff_skip_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_not_1st_mbuff_skip
name|cvmx_ipd_not_1st_mbuff_skip_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_packet_mbuff_size  *  * IPD_PACKET_MBUFF_SIZE = IPD's PACKET MUBUF Size In Words  *  * The number of words in a MBUFF used for packet data store.  */
end_comment

begin_union
union|union
name|cvmx_ipd_packet_mbuff_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_packet_mbuff_size_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|mb_size
range|:
literal|12
decl_stmt|;
comment|/**< The number of 8-byte words in a MBUF.                                                          This must be a number in the range of 32 to                                                          2048.                                                          This is also the size of the FPA's                                                          Queue-0 Free-Page. */
else|#
directive|else
name|uint64_t
name|mb_size
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_packet_mbuff_size_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_packet_mbuff_size
name|cvmx_ipd_packet_mbuff_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_pkt_ptr_valid  *  * IPD_PKT_PTR_VALID = IPD's Packet Pointer Valid  *  * The value of the packet-pointer fetched and in the valid register.  */
end_comment

begin_union
union|union
name|cvmx_ipd_pkt_ptr_valid
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_pkt_ptr_valid_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
comment|/**< Pointer value. */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_pkt_ptr_valid_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_pkt_ptr_valid
name|cvmx_ipd_pkt_ptr_valid_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port#_bp_page_cnt  *  * IPD_PORTX_BP_PAGE_CNT = IPD Port Backpressure Page Count  *  * The number of pages in use by the port that when exceeded, backpressure will be applied to the port.  * See also IPD_PORTX_BP_PAGE_CNT2  * See also IPD_PORTX_BP_PAGE_CNT3  */
end_comment

begin_union
union|union
name|cvmx_ipd_portx_bp_page_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_portx_bp_page_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|bp_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BP will be applied, if '0' BP will                                                          not be applied to port. */
name|uint64_t
name|page_cnt
range|:
literal|17
decl_stmt|;
comment|/**< The number of page pointers assigned to                                                          the port, that when exceeded will cause                                                          back-pressure to be applied to the port.                                                          This value is in 256 page-pointer increments,                                                          (i.e. 0 = 0-page-ptrs, 1 = 256-page-ptrs,..) */
else|#
directive|else
name|uint64_t
name|page_cnt
range|:
literal|17
decl_stmt|;
name|uint64_t
name|bp_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_portx_bp_page_cnt
name|cvmx_ipd_portx_bp_page_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port#_bp_page_cnt2  *  * IPD_PORTX_BP_PAGE_CNT2 = IPD Port Backpressure Page Count  *  * The number of pages in use by the port that when exceeded, backpressure will be applied to the port.  * See also IPD_PORTX_BP_PAGE_CNT  * See also IPD_PORTX_BP_PAGE_CNT3  */
end_comment

begin_union
union|union
name|cvmx_ipd_portx_bp_page_cnt2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_portx_bp_page_cnt2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|bp_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BP will be applied, if '0' BP will                                                          not be applied to port. */
name|uint64_t
name|page_cnt
range|:
literal|17
decl_stmt|;
comment|/**< The number of page pointers assigned to                                                          the port, that when exceeded will cause                                                          back-pressure to be applied to the port.                                                          This value is in 256 page-pointer increments,                                                          (i.e. 0 = 0-page-ptrs, 1 = 256-page-ptrs,..) */
else|#
directive|else
name|uint64_t
name|page_cnt
range|:
literal|17
decl_stmt|;
name|uint64_t
name|bp_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_portx_bp_page_cnt2
name|cvmx_ipd_portx_bp_page_cnt2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port#_bp_page_cnt3  *  * IPD_PORTX_BP_PAGE_CNT3 = IPD Port Backpressure Page Count  *  * The number of pages in use by the port that when exceeded, backpressure will be applied to the port.  * See also IPD_PORTX_BP_PAGE_CNT  * See also IPD_PORTX_BP_PAGE_CNT2  */
end_comment

begin_union
union|union
name|cvmx_ipd_portx_bp_page_cnt3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_portx_bp_page_cnt3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|bp_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' BP will be applied, if '0' BP will                                                          not be applied to port. */
name|uint64_t
name|page_cnt
range|:
literal|17
decl_stmt|;
comment|/**< The number of page pointers assigned to                                                          the port, that when exceeded will cause                                                          back-pressure to be applied to the port.                                                          This value is in 256 page-pointer increments,                                                          (i.e. 0 = 0-page-ptrs, 1 = 256-page-ptrs,..) */
else|#
directive|else
name|uint64_t
name|page_cnt
range|:
literal|17
decl_stmt|;
name|uint64_t
name|bp_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_portx_bp_page_cnt3_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_portx_bp_page_cnt3
name|cvmx_ipd_portx_bp_page_cnt3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port_bp_counters2_pair#  *  * IPD_PORT_BP_COUNTERS2_PAIRX = MBUF Counters port Ports used to generate Back Pressure Per Port.  * See also IPD_PORT_BP_COUNTERS_PAIRX  * See also IPD_PORT_BP_COUNTERS3_PAIRX  */
end_comment

begin_union
union|union
name|cvmx_ipd_port_bp_counters2_pairx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_port_bp_counters2_pairx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|cnt_val
range|:
literal|25
decl_stmt|;
comment|/**< Number of MBUFs being used by data on this port. */
else|#
directive|else
name|uint64_t
name|cnt_val
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_port_bp_counters2_pairx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters2_pairx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters2_pairx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters2_pairx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters2_pairx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters2_pairx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_port_bp_counters2_pairx
name|cvmx_ipd_port_bp_counters2_pairx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port_bp_counters3_pair#  *  * IPD_PORT_BP_COUNTERS3_PAIRX = MBUF Counters port Ports used to generate Back Pressure Per Port.  * See also IPD_PORT_BP_COUNTERS_PAIRX  * See also IPD_PORT_BP_COUNTERS2_PAIRX  */
end_comment

begin_union
union|union
name|cvmx_ipd_port_bp_counters3_pairx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_port_bp_counters3_pairx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|cnt_val
range|:
literal|25
decl_stmt|;
comment|/**< Number of MBUFs being used by data on this port. */
else|#
directive|else
name|uint64_t
name|cnt_val
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_port_bp_counters3_pairx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters3_pairx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_port_bp_counters3_pairx
name|cvmx_ipd_port_bp_counters3_pairx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port_bp_counters_pair#  *  * IPD_PORT_BP_COUNTERS_PAIRX = MBUF Counters port Ports used to generate Back Pressure Per Port.  * See also IPD_PORT_BP_COUNTERS2_PAIRX  * See also IPD_PORT_BP_COUNTERS3_PAIRX  */
end_comment

begin_union
union|union
name|cvmx_ipd_port_bp_counters_pairx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_port_bp_counters_pairx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|cnt_val
range|:
literal|25
decl_stmt|;
comment|/**< Number of MBUFs being used by data on this port. */
else|#
directive|else
name|uint64_t
name|cnt_val
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_bp_counters_pairx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_port_bp_counters_pairx
name|cvmx_ipd_port_bp_counters_pairx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port_qos_#_cnt  *  * IPD_PORT_QOS_X_CNT = IPD PortX QOS-0 Count  *  * A counter per port/qos. Counter are originzed in sequence where the first 8 counter (0-7) belong to Port-0  * QOS 0-7 respectively followed by port 1 at (8-15), etc  * Ports 0-3, 32-43  */
end_comment

begin_union
union|union
name|cvmx_ipd_port_qos_x_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_port_qos_x_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
comment|/**< When the field CNT after being modified is equal to                                                          or crosses this value (i.e. value was greater than                                                          then becomes less then, or value was less than and                                                          becomes greater than) the corresponding bit in                                                          IPD_PORT_QOS_INTX is set. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< The packet related count that is incremented as                                                          specified by IPD_SUB_PORT_QOS_CNT. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_port_qos_x_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_x_cnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_x_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_x_cnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_x_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_x_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_port_qos_x_cnt
name|cvmx_ipd_port_qos_x_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port_qos_int#  *  * IPD_PORT_QOS_INTX = IPD PORT-QOS Interrupt  *  * See the description for IPD_PORT_QOS_X_CNT  *  * 0=P0-7; 1=P8-15; 2=P16-23; 3=P24-31; 4=P32-39; 5=P40-47; 6=P48-55; 7=P56-63  *  * Only ports used are: P0-3, P32-39, and P40-43. Therefore only IPD_PORT_QOS_INT0, IPD_PORT_QOS_INT4,  * and IPD_PORT_QOS_INT5 exist and, furthermore:<63:32> of IPD_PORT_QOS_INT0 and IPD_PORT_QOS_INT5,  * are reserved.  */
end_comment

begin_union
union|union
name|cvmx_ipd_port_qos_intx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_port_qos_intx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Interrupt bits. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_port_qos_intx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_intx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_intx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_intx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_intx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_intx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_port_qos_intx
name|cvmx_ipd_port_qos_intx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_port_qos_int_enb#  *  * IPD_PORT_QOS_INT_ENBX = IPD PORT-QOS Interrupt Enable  *  * When the IPD_PORT_QOS_INTX[\#] is '1' and IPD_PORT_QOS_INT_ENBX[\#] is '1' a interrupt will be generated.  */
end_comment

begin_union
union|union
name|cvmx_ipd_port_qos_int_enbx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_port_qos_int_enbx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enable bits. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_port_qos_int_enbx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_int_enbx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_int_enbx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_int_enbx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_int_enbx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_port_qos_int_enbx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_port_qos_int_enbx
name|cvmx_ipd_port_qos_int_enbx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_prc_hold_ptr_fifo_ctl  *  * IPD_PRC_HOLD_PTR_FIFO_CTL = IPD's PRC Holding Pointer FIFO Control  *  * Allows reading of the Page-Pointers stored in the IPD's PRC Holding Fifo.  */
end_comment

begin_union
union|union
name|cvmx_ipd_prc_hold_ptr_fifo_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|max_pkt
range|:
literal|3
decl_stmt|;
comment|/**< Maximum number of Packet-Pointers that COULD be                                                          in the FIFO. */
name|uint64_t
name|praddr
range|:
literal|3
decl_stmt|;
comment|/**< Present Packet-Pointer read address. */
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
comment|/**< The output of the prc-holding-fifo. */
name|uint64_t
name|cena
range|:
literal|1
decl_stmt|;
comment|/**< Active low Chip Enable that controls the                                                          MUX-select that steers [RADDR] to the fifo.                                                          *WARNING - Setting this field to '0' will allow                                                          reading of the memories thorugh the PTR field,                                                          but will cause unpredictable operation of the IPD                                                          under normal operation. */
name|uint64_t
name|raddr
range|:
literal|3
decl_stmt|;
comment|/**< Sets the address to read from in the holding.                                                          fifo in the PRC. This FIFO holds Packet-Pointers                                                          to be used for packet data storage. */
else|#
directive|else
name|uint64_t
name|raddr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|praddr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|max_pkt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_prc_hold_ptr_fifo_ctl
name|cvmx_ipd_prc_hold_ptr_fifo_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_prc_port_ptr_fifo_ctl  *  * IPD_PRC_PORT_PTR_FIFO_CTL = IPD's PRC PORT Pointer FIFO Control  *  * Allows reading of the Page-Pointers stored in the IPD's PRC PORT Fifo.  */
end_comment

begin_union
union|union
name|cvmx_ipd_prc_port_ptr_fifo_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|max_pkt
range|:
literal|7
decl_stmt|;
comment|/**< Maximum number of Packet-Pointers that are in                                                          in the FIFO. */
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
comment|/**< The output of the prc-port-ptr-fifo. */
name|uint64_t
name|cena
range|:
literal|1
decl_stmt|;
comment|/**< Active low Chip Enable to the read port of the                                                          pwp_fifo. This bit also controls the MUX-select                                                          that steers [RADDR] to the pwp_fifo.                                                          *WARNING - Setting this field to '0' will allow                                                          reading of the memories thorugh the PTR field,                                                          but will cause unpredictable operation of the IPD                                                          under normal operation. */
name|uint64_t
name|raddr
range|:
literal|7
decl_stmt|;
comment|/**< Sets the address to read from in the port                                                          fifo in the PRC. This FIFO holds Packet-Pointers                                                          to be used for packet data storage. */
else|#
directive|else
name|uint64_t
name|raddr
range|:
literal|7
decl_stmt|;
name|uint64_t
name|cena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|max_pkt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_prc_port_ptr_fifo_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_prc_port_ptr_fifo_ctl
name|cvmx_ipd_prc_port_ptr_fifo_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_ptr_count  *  * IPD_PTR_COUNT = IPD Page Pointer Count  *  * Shows the number of WQE and Packet Page Pointers stored in the IPD.  */
end_comment

begin_union
union|union
name|cvmx_ipd_ptr_count
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_ptr_count_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|pktv_cnt
range|:
literal|1
decl_stmt|;
comment|/**< PKT Ptr Valid. */
name|uint64_t
name|wqev_cnt
range|:
literal|1
decl_stmt|;
comment|/**< WQE Ptr Valid. This value is '1' when a WQE                                                          is being for use by the IPD. The value of this                                                          field should be added to tha value of the                                                          WQE_PCNT field, of this register, for a total                                                          count of the WQE Page Pointers being held by IPD.                                                          When IPD_CTL_STATUS[NO_WPTR] is set '1' this field                                                          represents a Packet-Pointer NOT a WQE pointer. */
name|uint64_t
name|pfif_cnt
range|:
literal|3
decl_stmt|;
comment|/**< See PKT_PCNT. */
name|uint64_t
name|pkt_pcnt
range|:
literal|7
decl_stmt|;
comment|/**< This value plus PFIF_CNT plus                                                          IPD_PRC_PORT_PTR_FIFO_CTL[MAX_PKT] is the number                                                          of PKT Page Pointers in IPD. */
name|uint64_t
name|wqe_pcnt
range|:
literal|7
decl_stmt|;
comment|/**< Number of page pointers for WQE storage that are                                                          buffered in the IPD. The total count is the value                                                          of this buffer plus the field [WQEV_CNT]. For                                                          PASS-1 (which does not have the WQEV_CNT field)                                                          when the value of this register is '0' there still                                                          may be 1 pointer being held by IPD. */
else|#
directive|else
name|uint64_t
name|wqe_pcnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pkt_pcnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pfif_cnt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wqev_cnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pktv_cnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_ptr_count_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_ptr_count
name|cvmx_ipd_ptr_count_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_pwp_ptr_fifo_ctl  *  * IPD_PWP_PTR_FIFO_CTL = IPD's PWP Pointer FIFO Control  *  * Allows reading of the Page-Pointers stored in the IPD's PWP Fifo.  */
end_comment

begin_union
union|union
name|cvmx_ipd_pwp_ptr_fifo_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|max_cnts
range|:
literal|7
decl_stmt|;
comment|/**< Maximum number of Packet-Pointers or WQE-Pointers                                                          that COULD be in the FIFO.                                                          When IPD_CTL_STATUS[NO_WPTR] is set '1' this field                                                          only represents the Max number of Packet-Pointers,                                                          WQE-Pointers are not used in this mode. */
name|uint64_t
name|wraddr
range|:
literal|8
decl_stmt|;
comment|/**< Present FIFO WQE Read address. */
name|uint64_t
name|praddr
range|:
literal|8
decl_stmt|;
comment|/**< Present FIFO Packet Read address. */
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
comment|/**< The output of the pwp_fifo. */
name|uint64_t
name|cena
range|:
literal|1
decl_stmt|;
comment|/**< Active low Chip Enable to the read port of the                                                          pwp_fifo. This bit also controls the MUX-select                                                          that steers [RADDR] to the pwp_fifo.                                                          *WARNING - Setting this field to '0' will allow                                                          reading of the memories thorugh the PTR field,                                                          but will cause unpredictable operation of the IPD                                                          under normal operation. */
name|uint64_t
name|raddr
range|:
literal|8
decl_stmt|;
comment|/**< Sets the address to read from in the pwp_fifo.                                                          Addresses 0 through 63 contain Packet-Pointers and                                                          addresses 64 through 127 contain WQE-Pointers.                                                          When IPD_CTL_STATUS[NO_WPTR] is set '1' addresses                                                          64 through 127 are not valid. */
else|#
directive|else
name|uint64_t
name|raddr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|praddr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wraddr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|max_cnts
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_pwp_ptr_fifo_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_pwp_ptr_fifo_ctl
name|cvmx_ipd_pwp_ptr_fifo_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_qos#_red_marks  *  * IPD_QOS0_RED_MARKS = IPD QOS 0 Marks Red High Low  *  * Set the pass-drop marks for qos level.  */
end_comment

begin_union
union|union
name|cvmx_ipd_qosx_red_marks
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_qosx_red_marks_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|drop
range|:
literal|32
decl_stmt|;
comment|/**< Packets will be dropped when the average value of                                                          IPD_QUE0_FREE_PAGE_CNT is equal to or less than                                                          this value. */
name|uint64_t
name|pass
range|:
literal|32
decl_stmt|;
comment|/**< Packets will be passed when the average value of                                                          IPD_QUE0_FREE_PAGE_CNT is larger than this value. */
else|#
directive|else
name|uint64_t
name|pass
range|:
literal|32
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_qosx_red_marks_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_qosx_red_marks
name|cvmx_ipd_qosx_red_marks_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_que0_free_page_cnt  *  * IPD_QUE0_FREE_PAGE_CNT = IPD Queue0 Free Page Count  *  * Number of Free-Page Pointer that are available for use in the FPA for Queue-0.  */
end_comment

begin_union
union|union
name|cvmx_ipd_que0_free_page_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_que0_free_page_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|q0_pcnt
range|:
literal|32
decl_stmt|;
comment|/**< Number of Queue-0 Page Pointers Available. */
else|#
directive|else
name|uint64_t
name|q0_pcnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_que0_free_page_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_que0_free_page_cnt
name|cvmx_ipd_que0_free_page_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_red_port_enable  *  * IPD_RED_PORT_ENABLE = IPD RED Port Enable  *  * Set the pass-drop marks for qos level.  */
end_comment

begin_union
union|union
name|cvmx_ipd_red_port_enable
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_red_port_enable_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|prb_dly
range|:
literal|14
decl_stmt|;
comment|/**< Number (core clocks periods + 68) * 8 to wait                                                          before calculating the new packet drop                                                          probability for each QOS level. */
name|uint64_t
name|avg_dly
range|:
literal|14
decl_stmt|;
comment|/**< Number (core clocks periods + 10) * 8 to wait                                                          before calculating the moving average for each                                                          QOS level.                                                          Larger AVG_DLY values cause the moving averages                                                          of ALL QOS levels to track changes in the actual                                                          free space more slowly. Smaller NEW_CON (and                                                          larger AVG_CON) values can have a similar effect,                                                          but only affect an individual QOS level, rather                                                          than all. */
name|uint64_t
name|prt_enb
range|:
literal|36
decl_stmt|;
comment|/**< The bit position will enable the corresponding                                                          Ports ability to have packets dropped by RED                                                          probability. */
else|#
directive|else
name|uint64_t
name|prt_enb
range|:
literal|36
decl_stmt|;
name|uint64_t
name|avg_dly
range|:
literal|14
decl_stmt|;
name|uint64_t
name|prb_dly
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_red_port_enable
name|cvmx_ipd_red_port_enable_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_red_port_enable2  *  * IPD_RED_PORT_ENABLE2 = IPD RED Port Enable2  *  * Set the pass-drop marks for qos level.  */
end_comment

begin_union
union|union
name|cvmx_ipd_red_port_enable2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_red_port_enable2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|prt_enb
range|:
literal|8
decl_stmt|;
comment|/**< Bits 7-0 corresponds to ports 43-36. These bits                                                          have the same meaning as the PRT_ENB field of                                                          IPD_RED_PORT_ENABLE. */
else|#
directive|else
name|uint64_t
name|prt_enb
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ipd_red_port_enable2_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|prt_enb
range|:
literal|4
decl_stmt|;
comment|/**< Bits 3-0 cooresponds to ports 39-36. These bits                                                          have the same meaning as the PRT_ENB field of                                                          IPD_RED_PORT_ENABLE. */
else|#
directive|else
name|uint64_t
name|prt_enb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_ipd_red_port_enable2_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable2_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable2_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_port_enable2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_red_port_enable2
name|cvmx_ipd_red_port_enable2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_red_que#_param  *  * IPD_RED_QUE0_PARAM = IPD RED Queue-0 Parameters  *  * Value control the Passing and Dropping of packets by the red engine for QOS Level-0.  */
end_comment

begin_union
union|union
name|cvmx_ipd_red_quex_param
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_red_quex_param_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|use_pcnt
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' red will use the actual Packet-Page                                                          Count in place of the Average for RED calculations. */
name|uint64_t
name|new_con
range|:
literal|8
decl_stmt|;
comment|/**< This value is used control how much of the present                                                          Actual Queue Size is used to calculate the new                                                          Average Queue Size. The value is a number from 0                                                          256, which represents NEW_CON/256 of the Actual                                                          Queue Size that will be used in the calculation.                                                          The number in this field plus the value of                                                          AVG_CON must be equal to 256.                                                          Larger AVG_DLY values cause the moving averages                                                          of ALL QOS levels to track changes in the actual                                                          free space more slowly. Smaller NEW_CON (and                                                          larger AVG_CON) values can have a similar effect,                                                          but only affect an individual QOS level, rather                                                          than all. */
name|uint64_t
name|avg_con
range|:
literal|8
decl_stmt|;
comment|/**< This value is used control how much of the present                                                          Average Queue Size is used to calculate the new                                                          Average Queue Size. The value is a number from 0                                                          256, which represents AVG_CON/256 of the Average                                                          Queue Size that will be used in the calculation.                                                          The number in this field plus the value of                                                          NEW_CON must be equal to 256.                                                          Larger AVG_DLY values cause the moving averages                                                          of ALL QOS levels to track changes in the actual                                                          free space more slowly. Smaller NEW_CON (and                                                          larger AVG_CON) values can have a similar effect,                                                          but only affect an individual QOS level, rather                                                          than all. */
name|uint64_t
name|prb_con
range|:
literal|32
decl_stmt|;
comment|/**< Used in computing the probability of a packet being                                                          passed or drop by the WRED engine. The field is                                                          calculated to be (255 * 2^24)/(PASS-DROP). Where                                                          PASS and DROP are the field from the                                                          IPD_QOS0_RED_MARKS CSR. */
else|#
directive|else
name|uint64_t
name|prb_con
range|:
literal|32
decl_stmt|;
name|uint64_t
name|avg_con
range|:
literal|8
decl_stmt|;
name|uint64_t
name|new_con
range|:
literal|8
decl_stmt|;
name|uint64_t
name|use_pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_red_quex_param_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_red_quex_param
name|cvmx_ipd_red_quex_param_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_sub_port_bp_page_cnt  *  * IPD_SUB_PORT_BP_PAGE_CNT = IPD Subtract Port Backpressure Page Count  *  * Will add the value to the indicated port count register, the number of pages supplied. The value added should  * be the 2's complement of the value that needs to be subtracted. Users add 2's complement values to the  * port-mbuf-count register to return (lower the count) mbufs to the counter in order to avoid port-level  * backpressure being applied to the port. Backpressure is applied when the MBUF used count of a port exceeds the  * value in the IPD_PORTX_BP_PAGE_CNT, IPD_PORTX_BP_PAGE_CNT2, and IPD_PORTX_BP_PAGE_CNT3.  *  * This register can't be written from the PCI via a window write.  */
end_comment

begin_union
union|union
name|cvmx_ipd_sub_port_bp_page_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|port
range|:
literal|6
decl_stmt|;
comment|/**< The port to add the PAGE_CNT field to. */
name|uint64_t
name|page_cnt
range|:
literal|25
decl_stmt|;
comment|/**< The number of page pointers to add to                                                          the port counter pointed to by the                                                          PORT Field. */
else|#
directive|else
name|uint64_t
name|page_cnt
range|:
literal|25
decl_stmt|;
name|uint64_t
name|port
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_bp_page_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_sub_port_bp_page_cnt
name|cvmx_ipd_sub_port_bp_page_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_sub_port_fcs  *  * IPD_SUB_PORT_FCS = IPD Subtract Ports FCS Register  *  * When set '1' the port corresponding to the bit set will subtract 4 bytes from the end of  * the packet.  */
end_comment

begin_union
union|union
name|cvmx_ipd_sub_port_fcs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_sub_port_fcs_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|port_bit2
range|:
literal|4
decl_stmt|;
comment|/**< When set '1', the port corresponding to the bit                                                          position set, will subtract the FCS for packets                                                          on that port. */
name|uint64_t
name|reserved_32_35
range|:
literal|4
decl_stmt|;
name|uint64_t
name|port_bit
range|:
literal|32
decl_stmt|;
comment|/**< When set '1', the port corresponding to the bit                                                          position set, will subtract the FCS for packets                                                          on that port. */
else|#
directive|else
name|uint64_t
name|port_bit
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_35
range|:
literal|4
decl_stmt|;
name|uint64_t
name|port_bit2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ipd_sub_port_fcs_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|port_bit
range|:
literal|3
decl_stmt|;
comment|/**< When set '1', the port corresponding to the bit                                                          position set, will subtract the FCS for packets                                                          on that port. */
else|#
directive|else
name|uint64_t
name|port_bit
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_ipd_sub_port_fcs_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_ipd_sub_port_fcs_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port_bit
range|:
literal|32
decl_stmt|;
comment|/**< When set '1', the port corresponding to the bit                                                          position set, will subtract the FCS for packets                                                          on that port. */
else|#
directive|else
name|uint64_t
name|port_bit
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_ipd_sub_port_fcs_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_cn38xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_fcs_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_sub_port_fcs
name|cvmx_ipd_sub_port_fcs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_sub_port_qos_cnt  *  * IPD_SUB_PORT_QOS_CNT = IPD Subtract Port QOS Count  *  * Will add the value (CNT) to the indicated Port-QOS register (PORT_QOS). The value added must be  * be the 2's complement of the value that needs to be subtracted.  */
end_comment

begin_union
union|union
name|cvmx_ipd_sub_port_qos_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_sub_port_qos_cnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_41_63
range|:
literal|23
decl_stmt|;
name|uint64_t
name|port_qos
range|:
literal|9
decl_stmt|;
comment|/**< The port to add the CNT field to. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< The value to be added to the register selected                                                          in the PORT_QOS field. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port_qos
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_41_63
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_sub_port_qos_cnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_qos_cnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_qos_cnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_qos_cnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_qos_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_sub_port_qos_cnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_sub_port_qos_cnt
name|cvmx_ipd_sub_port_qos_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_wqe_fpa_queue  *  * IPD_WQE_FPA_QUEUE = IPD Work-Queue-Entry FPA Page Size  *  * Which FPA Queue (0-7) to fetch page-pointers from for WQE's  */
end_comment

begin_union
union|union
name|cvmx_ipd_wqe_fpa_queue
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_wqe_fpa_queue_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|wqe_pool
range|:
literal|3
decl_stmt|;
comment|/**< Which FPA Queue to fetch page-pointers                                                          from for WQE's.                                                          Not used when IPD_CTL_STATUS[NO_WPTR] is set. */
else|#
directive|else
name|uint64_t
name|wqe_pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_fpa_queue_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_wqe_fpa_queue
name|cvmx_ipd_wqe_fpa_queue_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ipd_wqe_ptr_valid  *  * IPD_WQE_PTR_VALID = IPD's WQE Pointer Valid  *  * The value of the WQE-pointer fetched and in the valid register.  */
end_comment

begin_union
union|union
name|cvmx_ipd_wqe_ptr_valid
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ipd_wqe_ptr_valid_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
comment|/**< Pointer value.                                                          When IPD_CTL_STATUS[NO_WPTR] is set '1' this field                                                          represents a Packet-Pointer NOT a WQE pointer. */
else|#
directive|else
name|uint64_t
name|ptr
range|:
literal|29
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_ipd_wqe_ptr_valid_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ipd_wqe_ptr_valid
name|cvmx_ipd_wqe_ptr_valid_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

