begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	sys_file.c	5.8	82/12/17	*/
end_comment

begin_include
include|#
directive|include
file|"../machine/reg.h"
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/systm.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/user.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/proc.h"
end_include

begin_include
include|#
directive|include
file|"../h/timeb.h"
end_include

begin_include
include|#
directive|include
file|"../h/times.h"
end_include

begin_include
include|#
directive|include
file|"../h/reboot.h"
end_include

begin_include
include|#
directive|include
file|"../h/fs.h"
end_include

begin_include
include|#
directive|include
file|"../h/conf.h"
end_include

begin_include
include|#
directive|include
file|"../h/buf.h"
end_include

begin_include
include|#
directive|include
file|"../h/mount.h"
end_include

begin_include
include|#
directive|include
file|"../h/file.h"
end_include

begin_macro
name|portal
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_macro
name|utimes
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_comment
comment|/*  * Lock a file:  * Ip is the inode associated with the file to be locked,  * flags is the current "locking state" of the file relative  * to the process' file descriptor (i.e. u_pofile), and cmd  * is the new action to be applied.  We need flags in case  * we're changing a shared lock to a exclusive lock, or vice versa.  *  * NB: the inode should't be ilocked before the call as the  *     only fields we modify are private to the flocki and  *     funlocki; and later accesses to the inode would block  *     in ilock where they're not interruptible.  */
end_comment

begin_expr_stmt
name|flocki
argument_list|(
name|ip
argument_list|,
name|flags
argument_list|,
name|cmd
argument_list|)
specifier|register
expr|struct
name|inode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|,
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|priority
init|=
name|PLOCK
decl_stmt|;
if|if
condition|(
name|cmd
operator|&
name|FEXLOCK
condition|)
name|priority
operator|++
expr_stmt|;
comment|/* 	 * If there's a exclusive lock currently applied 	 * to the file, or someone waiting to get a 	 * exclusive lock, then we've gotta wait for the 	 * lock with everyone else. 	 */
name|again
label|:
while|while
condition|(
name|ip
operator|->
name|i_flag
operator|&
operator|(
name|IEXLOCK
operator||
name|ILWAIT
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|FNBLOCK
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EWOULDBLOCK
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
comment|/* 		 * If we're holding a write 		 * lock, then release it. 		 */
if|if
condition|(
name|flags
operator|&
name|UF_EXLOCK
condition|)
block|{
name|funlocki
argument_list|(
name|ip
argument_list|,
name|UF_EXLOCK
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|UF_EXLOCK
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|ip
operator|->
name|i_flag
operator||=
name|ILWAIT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|i_exlockc
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
name|FEXLOCK
condition|)
block|{
name|cmd
operator|&=
operator|~
name|FSHLOCK
expr_stmt|;
comment|/* 		 * Must wait for any shared locks to finish 		 * before we try to apply a exclusive lock. 		 */
while|while
condition|(
name|ip
operator|->
name|i_flag
operator|&
name|ISHLOCK
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|FNBLOCK
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EWOULDBLOCK
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
comment|/* 			 * If we're holding a shared 			 * lock, then release it. 			 */
if|if
condition|(
name|flags
operator|&
name|UF_SHLOCK
condition|)
block|{
name|funlocki
argument_list|(
name|ip
argument_list|,
name|UF_SHLOCK
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|UF_SHLOCK
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|ip
operator|->
name|i_flag
operator||=
name|ILWAIT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|i_shlockc
argument_list|,
name|PLOCK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|UF_SHLOCK
operator||
name|UF_EXLOCK
operator|)
condition|)
name|panic
argument_list|(
literal|"flocki"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
name|FSHLOCK
condition|)
block|{
name|ip
operator|->
name|i_shlockc
operator|++
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|ISHLOCK
expr_stmt|;
name|flags
operator||=
name|UF_SHLOCK
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
name|FEXLOCK
condition|)
block|{
name|ip
operator|->
name|i_exlockc
operator|++
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IEXLOCK
expr_stmt|;
name|flags
operator||=
name|UF_EXLOCK
expr_stmt|;
block|}
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Unlock a file.  */
end_comment

begin_expr_stmt
name|funlocki
argument_list|(
name|ip
argument_list|,
name|locktype
argument_list|)
specifier|register
expr|struct
name|inode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|locktype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"funlocki"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ip
operator|->
name|i_flag
expr_stmt|;
if|if
condition|(
name|locktype
operator|&
name|UF_SHLOCK
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|ISHLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no shared lock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ip
operator|->
name|i_shlockc
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|i_flag
operator|&=
operator|~
name|ISHLOCK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ILWAIT
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|i_shlockc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|locktype
operator|&
name|UF_EXLOCK
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|IEXLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"no exclusive lock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ip
operator|->
name|i_exlockc
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|i_flag
operator|&=
operator|~
operator|(
name|IEXLOCK
operator||
name|ILWAIT
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ILWAIT
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|i_exlockc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

