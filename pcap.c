begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995, 1996, 1997, 1998  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Computer Systems  *	Engineering Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/libpcap/pcap.c,v 1.128 2008-12-23 20:13:29 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<pcap-stdinc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* WIN32 */
end_comment

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_STDINT_H
end_elif

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BITYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bitypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WIN32 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|"pcap-dos.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DAG_API
end_ifdef

begin_include
include|#
directive|include
file|<dagnew.h>
end_include

begin_include
include|#
directive|include
file|<dagapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcap_not_initialized
parameter_list|(
name|pcap_t
modifier|*
name|pcap
parameter_list|)
block|{
comment|/* this means 'not initialized' */
return|return
operator|(
name|PCAP_ERROR_NOT_ACTIVATED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 1 if rfmon mode can be set on the pcap_t, 0 if it can't,  * a PCAP_ERROR value on an error.  */
end_comment

begin_function
name|int
name|pcap_can_set_rfmon
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|can_set_rfmon_op
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For systems where rfmon mode is never supported.  */
end_comment

begin_function
specifier|static
name|int
name|pcap_cant_set_rfmon
parameter_list|(
name|pcap_t
modifier|*
name|p
name|_U_
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sets *tstamp_typesp to point to an array 1 or more supported time stamp  * types; the return value is the number of supported time stamp types.  * The list should be freed by a call to pcap_free_tstamp_types() when  * you're done with it.  *  * A return value of 0 means "you don't get a choice of time stamp type",  * in which case *tstamp_typesp is set to null.  *  * PCAP_ERROR is returned on error.  */
end_comment

begin_function
name|int
name|pcap_list_tstamp_types
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
modifier|*
name|tstamp_typesp
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|tstamp_type_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We don't support multiple time stamp types. 		 */
operator|*
name|tstamp_typesp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tstamp_typesp
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tstamp_typesp
argument_list|)
argument_list|,
name|p
operator|->
name|tstamp_type_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tstamp_typesp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|*
name|tstamp_typesp
argument_list|,
name|p
operator|->
name|tstamp_type_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tstamp_typesp
argument_list|)
operator|*
name|p
operator|->
name|tstamp_type_count
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|->
name|tstamp_type_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In Windows, you might have a library built with one version of the  * C runtime library and an application built with another version of  * the C runtime library, which means that the library might use one  * version of malloc() and free() and the application might use another  * version of malloc() and free().  If so, that means something  * allocated by the library cannot be freed by the application, so we  * need to have a pcap_free_tstamp_types() routine to free up the list  * allocated by pcap_list_tstamp_types(), even though it's just a wrapper  * around free().  */
end_comment

begin_function
name|void
name|pcap_free_tstamp_types
parameter_list|(
name|int
modifier|*
name|tstamp_type_list
parameter_list|)
block|{
name|free
argument_list|(
name|tstamp_type_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Default one-shot callback; overridden for capture types where the  * packet data cannot be guaranteed to be available after the callback  * returns, so that a copy must be made.  */
end_comment

begin_function
specifier|static
name|void
name|pcap_oneshot
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|oneshot_userdata
modifier|*
name|sp
init|=
operator|(
expr|struct
name|oneshot_userdata
operator|*
operator|)
name|user
decl_stmt|;
operator|*
name|sp
operator|->
name|hdr
operator|=
operator|*
name|h
expr_stmt|;
operator|*
name|sp
operator|->
name|pkt
operator|=
name|pkt
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|u_char
modifier|*
name|pcap_next
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|oneshot_userdata
name|s
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|pkt
decl_stmt|;
name|s
operator|.
name|hdr
operator|=
name|h
expr_stmt|;
name|s
operator|.
name|pkt
operator|=
operator|&
name|pkt
expr_stmt|;
name|s
operator|.
name|pd
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|pcap_dispatch
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|oneshot_callback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pkt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_next_ex
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
modifier|*
name|pkt_header
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
name|pkt_data
parameter_list|)
block|{
name|struct
name|oneshot_userdata
name|s
decl_stmt|;
name|s
operator|.
name|hdr
operator|=
operator|&
name|p
operator|->
name|pcap_header
expr_stmt|;
name|s
operator|.
name|pkt
operator|=
name|pkt_data
expr_stmt|;
name|s
operator|.
name|pd
operator|=
name|p
expr_stmt|;
comment|/* Saves a pointer to the packet headers */
operator|*
name|pkt_header
operator|=
operator|&
name|p
operator|->
name|pcap_header
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|rfile
operator|!=
name|NULL
condition|)
block|{
name|int
name|status
decl_stmt|;
comment|/* We are on an offline capture */
name|status
operator|=
name|pcap_offline_read
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|oneshot_callback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * Return codes for pcap_offline_read() are: 		 *   -  0: EOF 		 *   - -1: error 		 *   ->1: OK 		 * The first one ('0') conflicts with the return code of 		 * 0 from pcap_read() meaning "no packets arrived before 		 * the timeout expired", so we map it to -2 so you can 		 * distinguish between an EOF from a savefile and a 		 * "no packets arrived before the timeout expired, try 		 * again" from a live capture. 		 */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	 * Return codes for pcap_read() are: 	 *   -  0: timeout 	 *   - -1: error 	 *   - -2: loop was broken out of with pcap_breakloop() 	 *   ->1: OK 	 * The first one ('0') conflicts with the return code of 0 from 	 * pcap_offline_read() meaning "end of file". 	*/
return|return
operator|(
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|oneshot_callback
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_ops
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * Set operation pointers for operations that only work on 	 * an activated pcap_t to point to a routine that returns 	 * a "this isn't activated" error. 	 */
name|p
operator|->
name|read_op
operator|=
operator|(
name|read_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|inject_op
operator|=
operator|(
name|inject_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setfilter_op
operator|=
operator|(
name|setfilter_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setdirection_op
operator|=
operator|(
name|setdirection_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|set_datalink_op
operator|=
operator|(
name|set_datalink_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|getnonblock_op
operator|=
operator|(
name|getnonblock_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setnonblock_op
operator|=
operator|(
name|setnonblock_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
operator|(
name|stats_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|p
operator|->
name|setbuff_op
operator|=
operator|(
name|setbuff_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setmode_op
operator|=
operator|(
name|setmode_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
name|p
operator|->
name|setmintocopy_op
operator|=
operator|(
name|setmintocopy_op_t
operator|)
name|pcap_not_initialized
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Default cleanup operation - implementations can override 	 * this, but should call pcap_cleanup_live_common() after 	 * doing their own additional cleanup. 	 */
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_live_common
expr_stmt|;
comment|/* 	 * In most cases, the standard one-short callback can 	 * be used for pcap_next()/pcap_next_ex(). 	 */
name|p
operator|->
name|oneshot_callback
operator|=
name|pcap_oneshot
expr_stmt|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_create_common
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
name|p
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not opened yet */
name|p
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|send_fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|opt
operator|.
name|source
operator|=
name|strdup
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|source
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|ebuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Default to "can't set rfmon mode"; if it's supported by 	 * a platform, the create routine that called us can set 	 * the op to its routine to check whether a particular 	 * device supports it. 	 */
name|p
operator|->
name|can_set_rfmon_op
operator|=
name|pcap_cant_set_rfmon
expr_stmt|;
name|initialize_ops
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* put in some defaults*/
name|pcap_set_timeout
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcap_set_snaplen
argument_list|(
name|p
argument_list|,
literal|65535
argument_list|)
expr_stmt|;
comment|/* max packet size */
name|p
operator|->
name|opt
operator|.
name|promisc
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|opt
operator|.
name|tstamp_type
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* default to not setting time stamp type */
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_check_activated
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|activated
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"can't perform "
literal|" operation on activated capture"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_snaplen
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|snaplen
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_promisc
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|promisc
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|promisc
operator|=
name|promisc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_rfmon
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|rfmon
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|rfmon
operator|=
name|rfmon
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_timeout
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|timeout_ms
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|md
operator|.
name|timeout
operator|=
name|timeout_ms
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_tstamp_type
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|tstamp_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
comment|/* 	 * If p->tstamp_type_count is 0, we don't support setting 	 * the time stamp type at all. 	 */
if|if
condition|(
name|p
operator|->
name|tstamp_type_count
operator|==
literal|0
condition|)
return|return
operator|(
name|PCAP_ERROR_CANTSET_TSTAMP_TYPE
operator|)
return|;
comment|/* 	 * Check whether we claim to support this type of time stamp. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|tstamp_type_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|tstamp_type_list
index|[
name|i
index|]
operator|==
name|tstamp_type
condition|)
block|{
comment|/* 			 * Yes. 			 */
name|p
operator|->
name|opt
operator|.
name|tstamp_type
operator|=
name|tstamp_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * No.  We support setting the time stamp type, but not to this 	 * particular value. 	 */
return|return
operator|(
name|PCAP_WARNING_TSTAMP_TYPE_NOTSUP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_set_buffer_size
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|buffer_size
parameter_list|)
block|{
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|p
operator|->
name|opt
operator|.
name|buffer_size
operator|=
name|buffer_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_activate
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
comment|/* 	 * Catch attempts to re-activate an already-activated 	 * pcap_t; this should, for example, catch code that 	 * calls pcap_open_live() followed by pcap_activate(), 	 * as some code that showed up in a Stack Exchange 	 * question did. 	 */
if|if
condition|(
name|pcap_check_activated
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|PCAP_ERROR_ACTIVATED
operator|)
return|;
name|status
operator|=
name|p
operator|->
name|activate_op
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|p
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|errbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 			 * No error message supplied by the activate routine; 			 * for the benefit of programs that don't specially 			 * handle errors other than PCAP_ERROR, return the 			 * error message corresponding to the status. 			 */
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s"
argument_list|,
name|pcap_statustostr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Undo any operation pointer setting, etc. done by 		 * the activate operation. 		 */
name|initialize_ops
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_live
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
name|p
operator|=
name|pcap_create
argument_list|(
name|source
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|status
operator|=
name|pcap_set_snaplen
argument_list|(
name|p
argument_list|,
name|snaplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|pcap_set_promisc
argument_list|(
name|p
argument_list|,
name|promisc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|status
operator|=
name|pcap_set_timeout
argument_list|(
name|p
argument_list|,
name|to_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Mark this as opened with pcap_open_live(), so that, for 	 * example, we show the full list of DLT_ values, rather 	 * than just the ones that are compatible with capturing 	 * when not in monitor mode.  That allows existing applications 	 * to work the way they used to work, but allows new applications 	 * that know about the new open API to, for example, find out the 	 * DLT_ values that they can select without changing whether 	 * the adapter is in monitor mode or not. 	 */
name|p
operator|->
name|oldstyle
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|pcap_activate
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
name|p
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|status
operator|==
name|PCAP_ERROR
condition|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|source
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
name|PCAP_ERROR_NO_SUCH_DEVICE
operator|||
name|status
operator|==
name|PCAP_ERROR_PERM_DENIED
operator|||
name|status
operator|==
name|PCAP_ERROR_PROMISC_PERM_DENIED
condition|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s (%s)"
argument_list|,
name|source
argument_list|,
name|pcap_statustostr
argument_list|(
name|status
argument_list|)
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"%s: %s"
argument_list|,
name|source
argument_list|,
name|pcap_statustostr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|pcap_close
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_dispatch
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX - is this necessary?  */
end_comment

begin_function
name|int
name|pcap_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_loop
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|->
name|sf
operator|.
name|rfile
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * 0 means EOF, so don't loop if we get 0. 			 */
name|n
operator|=
name|pcap_offline_read
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX keep reading until we get something 			 * (or an error occurs) 			 */
do|do
block|{
name|n
operator|=
name|p
operator|->
name|read_op
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|,
name|callback
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|cnt
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Force the loop in "pcap_read()" or "pcap_read_offline()" to terminate.  */
end_comment

begin_function
name|void
name|pcap_breakloop
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|break_loop
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|linktype
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_datalink_ext
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|linktype_ext
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_list_datalinks
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
modifier|*
modifier|*
name|dlt_buffer
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We couldn't fetch the list of DLTs, which means 		 * this platform doesn't support changing the 		 * DLT for an interface.  Return a list of DLTs 		 * containing only the DLT this device supports. 		 */
operator|*
name|dlt_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dlt_buffer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
operator|*
name|dlt_buffer
operator|=
name|p
operator|->
name|linktype
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
operator|*
name|dlt_buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
argument_list|,
name|p
operator|->
name|dlt_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dlt_buffer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"malloc: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|*
name|dlt_buffer
argument_list|,
name|p
operator|->
name|dlt_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|dlt_buffer
argument_list|)
operator|*
name|p
operator|->
name|dlt_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|dlt_count
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * In Windows, you might have a library built with one version of the  * C runtime library and an application built with another version of  * the C runtime library, which means that the library might use one  * version of malloc() and free() and the application might use another  * version of malloc() and free().  If so, that means something  * allocated by the library cannot be freed by the application, so we  * need to have a pcap_free_datalinks() routine to free up the list  * allocated by pcap_list_datalinks(), even though it's just a wrapper  * around free().  */
end_comment

begin_function
name|void
name|pcap_free_datalinks
parameter_list|(
name|int
modifier|*
name|dlt_list
parameter_list|)
block|{
name|free
argument_list|(
name|dlt_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_set_datalink
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|dlt_name
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|0
operator|||
name|p
operator|->
name|set_datalink_op
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We couldn't fetch the list of DLTs, or we don't 		 * have a "set datalink" operation, which means 		 * this platform doesn't support changing the 		 * DLT for an interface.  Check whether the new 		 * DLT is the one this interface supports. 		 */
if|if
condition|(
name|p
operator|->
name|linktype
operator|!=
name|dlt
condition|)
goto|goto
name|unsupported
goto|;
comment|/* 		 * It is, so there's nothing we need to do here. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|dlt_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dlt_list
index|[
name|i
index|]
operator|==
name|dlt
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|p
operator|->
name|dlt_count
condition|)
goto|goto
name|unsupported
goto|;
if|if
condition|(
name|p
operator|->
name|dlt_count
operator|==
literal|2
operator|&&
name|p
operator|->
name|dlt_list
index|[
literal|0
index|]
operator|==
name|DLT_EN10MB
operator|&&
name|dlt
operator|==
name|DLT_DOCSIS
condition|)
block|{
comment|/* 		 * This is presumably an Ethernet device, as the first 		 * link-layer type it offers is DLT_EN10MB, and the only 		 * other type it offers is DLT_DOCSIS.  That means that 		 * we can't tell the driver to supply DOCSIS link-layer 		 * headers - we're just pretending that's what we're 		 * getting, as, presumably, we're capturing on a dedicated 		 * link to a Cisco Cable Modem Termination System, and 		 * it's putting raw DOCSIS frames on the wire inside low-level 		 * Ethernet framing. 		 */
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|set_datalink_op
argument_list|(
name|p
argument_list|,
name|dlt
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|p
operator|->
name|linktype
operator|=
name|dlt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|unsupported
label|:
name|dlt_name
operator|=
name|pcap_datalink_val_to_name
argument_list|(
name|dlt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlt_name
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"%s is not one of the DLTs supported by this device"
argument_list|,
name|dlt_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|errbuf
argument_list|)
argument_list|,
literal|"DLT %d is not one of the DLTs supported by this device"
argument_list|,
name|dlt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This array is designed for mapping upper and lower case letter  * together for a case independent comparison.  The mappings are  * based upon ascii character sequences.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|charmap
index|[]
init|=
block|{
operator|(
name|u_char
operator|)
literal|'\000'
block|,
operator|(
name|u_char
operator|)
literal|'\001'
block|,
operator|(
name|u_char
operator|)
literal|'\002'
block|,
operator|(
name|u_char
operator|)
literal|'\003'
block|,
operator|(
name|u_char
operator|)
literal|'\004'
block|,
operator|(
name|u_char
operator|)
literal|'\005'
block|,
operator|(
name|u_char
operator|)
literal|'\006'
block|,
operator|(
name|u_char
operator|)
literal|'\007'
block|,
operator|(
name|u_char
operator|)
literal|'\010'
block|,
operator|(
name|u_char
operator|)
literal|'\011'
block|,
operator|(
name|u_char
operator|)
literal|'\012'
block|,
operator|(
name|u_char
operator|)
literal|'\013'
block|,
operator|(
name|u_char
operator|)
literal|'\014'
block|,
operator|(
name|u_char
operator|)
literal|'\015'
block|,
operator|(
name|u_char
operator|)
literal|'\016'
block|,
operator|(
name|u_char
operator|)
literal|'\017'
block|,
operator|(
name|u_char
operator|)
literal|'\020'
block|,
operator|(
name|u_char
operator|)
literal|'\021'
block|,
operator|(
name|u_char
operator|)
literal|'\022'
block|,
operator|(
name|u_char
operator|)
literal|'\023'
block|,
operator|(
name|u_char
operator|)
literal|'\024'
block|,
operator|(
name|u_char
operator|)
literal|'\025'
block|,
operator|(
name|u_char
operator|)
literal|'\026'
block|,
operator|(
name|u_char
operator|)
literal|'\027'
block|,
operator|(
name|u_char
operator|)
literal|'\030'
block|,
operator|(
name|u_char
operator|)
literal|'\031'
block|,
operator|(
name|u_char
operator|)
literal|'\032'
block|,
operator|(
name|u_char
operator|)
literal|'\033'
block|,
operator|(
name|u_char
operator|)
literal|'\034'
block|,
operator|(
name|u_char
operator|)
literal|'\035'
block|,
operator|(
name|u_char
operator|)
literal|'\036'
block|,
operator|(
name|u_char
operator|)
literal|'\037'
block|,
operator|(
name|u_char
operator|)
literal|'\040'
block|,
operator|(
name|u_char
operator|)
literal|'\041'
block|,
operator|(
name|u_char
operator|)
literal|'\042'
block|,
operator|(
name|u_char
operator|)
literal|'\043'
block|,
operator|(
name|u_char
operator|)
literal|'\044'
block|,
operator|(
name|u_char
operator|)
literal|'\045'
block|,
operator|(
name|u_char
operator|)
literal|'\046'
block|,
operator|(
name|u_char
operator|)
literal|'\047'
block|,
operator|(
name|u_char
operator|)
literal|'\050'
block|,
operator|(
name|u_char
operator|)
literal|'\051'
block|,
operator|(
name|u_char
operator|)
literal|'\052'
block|,
operator|(
name|u_char
operator|)
literal|'\053'
block|,
operator|(
name|u_char
operator|)
literal|'\054'
block|,
operator|(
name|u_char
operator|)
literal|'\055'
block|,
operator|(
name|u_char
operator|)
literal|'\056'
block|,
operator|(
name|u_char
operator|)
literal|'\057'
block|,
operator|(
name|u_char
operator|)
literal|'\060'
block|,
operator|(
name|u_char
operator|)
literal|'\061'
block|,
operator|(
name|u_char
operator|)
literal|'\062'
block|,
operator|(
name|u_char
operator|)
literal|'\063'
block|,
operator|(
name|u_char
operator|)
literal|'\064'
block|,
operator|(
name|u_char
operator|)
literal|'\065'
block|,
operator|(
name|u_char
operator|)
literal|'\066'
block|,
operator|(
name|u_char
operator|)
literal|'\067'
block|,
operator|(
name|u_char
operator|)
literal|'\070'
block|,
operator|(
name|u_char
operator|)
literal|'\071'
block|,
operator|(
name|u_char
operator|)
literal|'\072'
block|,
operator|(
name|u_char
operator|)
literal|'\073'
block|,
operator|(
name|u_char
operator|)
literal|'\074'
block|,
operator|(
name|u_char
operator|)
literal|'\075'
block|,
operator|(
name|u_char
operator|)
literal|'\076'
block|,
operator|(
name|u_char
operator|)
literal|'\077'
block|,
operator|(
name|u_char
operator|)
literal|'\100'
block|,
operator|(
name|u_char
operator|)
literal|'\141'
block|,
operator|(
name|u_char
operator|)
literal|'\142'
block|,
operator|(
name|u_char
operator|)
literal|'\143'
block|,
operator|(
name|u_char
operator|)
literal|'\144'
block|,
operator|(
name|u_char
operator|)
literal|'\145'
block|,
operator|(
name|u_char
operator|)
literal|'\146'
block|,
operator|(
name|u_char
operator|)
literal|'\147'
block|,
operator|(
name|u_char
operator|)
literal|'\150'
block|,
operator|(
name|u_char
operator|)
literal|'\151'
block|,
operator|(
name|u_char
operator|)
literal|'\152'
block|,
operator|(
name|u_char
operator|)
literal|'\153'
block|,
operator|(
name|u_char
operator|)
literal|'\154'
block|,
operator|(
name|u_char
operator|)
literal|'\155'
block|,
operator|(
name|u_char
operator|)
literal|'\156'
block|,
operator|(
name|u_char
operator|)
literal|'\157'
block|,
operator|(
name|u_char
operator|)
literal|'\160'
block|,
operator|(
name|u_char
operator|)
literal|'\161'
block|,
operator|(
name|u_char
operator|)
literal|'\162'
block|,
operator|(
name|u_char
operator|)
literal|'\163'
block|,
operator|(
name|u_char
operator|)
literal|'\164'
block|,
operator|(
name|u_char
operator|)
literal|'\165'
block|,
operator|(
name|u_char
operator|)
literal|'\166'
block|,
operator|(
name|u_char
operator|)
literal|'\167'
block|,
operator|(
name|u_char
operator|)
literal|'\170'
block|,
operator|(
name|u_char
operator|)
literal|'\171'
block|,
operator|(
name|u_char
operator|)
literal|'\172'
block|,
operator|(
name|u_char
operator|)
literal|'\133'
block|,
operator|(
name|u_char
operator|)
literal|'\134'
block|,
operator|(
name|u_char
operator|)
literal|'\135'
block|,
operator|(
name|u_char
operator|)
literal|'\136'
block|,
operator|(
name|u_char
operator|)
literal|'\137'
block|,
operator|(
name|u_char
operator|)
literal|'\140'
block|,
operator|(
name|u_char
operator|)
literal|'\141'
block|,
operator|(
name|u_char
operator|)
literal|'\142'
block|,
operator|(
name|u_char
operator|)
literal|'\143'
block|,
operator|(
name|u_char
operator|)
literal|'\144'
block|,
operator|(
name|u_char
operator|)
literal|'\145'
block|,
operator|(
name|u_char
operator|)
literal|'\146'
block|,
operator|(
name|u_char
operator|)
literal|'\147'
block|,
operator|(
name|u_char
operator|)
literal|'\150'
block|,
operator|(
name|u_char
operator|)
literal|'\151'
block|,
operator|(
name|u_char
operator|)
literal|'\152'
block|,
operator|(
name|u_char
operator|)
literal|'\153'
block|,
operator|(
name|u_char
operator|)
literal|'\154'
block|,
operator|(
name|u_char
operator|)
literal|'\155'
block|,
operator|(
name|u_char
operator|)
literal|'\156'
block|,
operator|(
name|u_char
operator|)
literal|'\157'
block|,
operator|(
name|u_char
operator|)
literal|'\160'
block|,
operator|(
name|u_char
operator|)
literal|'\161'
block|,
operator|(
name|u_char
operator|)
literal|'\162'
block|,
operator|(
name|u_char
operator|)
literal|'\163'
block|,
operator|(
name|u_char
operator|)
literal|'\164'
block|,
operator|(
name|u_char
operator|)
literal|'\165'
block|,
operator|(
name|u_char
operator|)
literal|'\166'
block|,
operator|(
name|u_char
operator|)
literal|'\167'
block|,
operator|(
name|u_char
operator|)
literal|'\170'
block|,
operator|(
name|u_char
operator|)
literal|'\171'
block|,
operator|(
name|u_char
operator|)
literal|'\172'
block|,
operator|(
name|u_char
operator|)
literal|'\173'
block|,
operator|(
name|u_char
operator|)
literal|'\174'
block|,
operator|(
name|u_char
operator|)
literal|'\175'
block|,
operator|(
name|u_char
operator|)
literal|'\176'
block|,
operator|(
name|u_char
operator|)
literal|'\177'
block|,
operator|(
name|u_char
operator|)
literal|'\200'
block|,
operator|(
name|u_char
operator|)
literal|'\201'
block|,
operator|(
name|u_char
operator|)
literal|'\202'
block|,
operator|(
name|u_char
operator|)
literal|'\203'
block|,
operator|(
name|u_char
operator|)
literal|'\204'
block|,
operator|(
name|u_char
operator|)
literal|'\205'
block|,
operator|(
name|u_char
operator|)
literal|'\206'
block|,
operator|(
name|u_char
operator|)
literal|'\207'
block|,
operator|(
name|u_char
operator|)
literal|'\210'
block|,
operator|(
name|u_char
operator|)
literal|'\211'
block|,
operator|(
name|u_char
operator|)
literal|'\212'
block|,
operator|(
name|u_char
operator|)
literal|'\213'
block|,
operator|(
name|u_char
operator|)
literal|'\214'
block|,
operator|(
name|u_char
operator|)
literal|'\215'
block|,
operator|(
name|u_char
operator|)
literal|'\216'
block|,
operator|(
name|u_char
operator|)
literal|'\217'
block|,
operator|(
name|u_char
operator|)
literal|'\220'
block|,
operator|(
name|u_char
operator|)
literal|'\221'
block|,
operator|(
name|u_char
operator|)
literal|'\222'
block|,
operator|(
name|u_char
operator|)
literal|'\223'
block|,
operator|(
name|u_char
operator|)
literal|'\224'
block|,
operator|(
name|u_char
operator|)
literal|'\225'
block|,
operator|(
name|u_char
operator|)
literal|'\226'
block|,
operator|(
name|u_char
operator|)
literal|'\227'
block|,
operator|(
name|u_char
operator|)
literal|'\230'
block|,
operator|(
name|u_char
operator|)
literal|'\231'
block|,
operator|(
name|u_char
operator|)
literal|'\232'
block|,
operator|(
name|u_char
operator|)
literal|'\233'
block|,
operator|(
name|u_char
operator|)
literal|'\234'
block|,
operator|(
name|u_char
operator|)
literal|'\235'
block|,
operator|(
name|u_char
operator|)
literal|'\236'
block|,
operator|(
name|u_char
operator|)
literal|'\237'
block|,
operator|(
name|u_char
operator|)
literal|'\240'
block|,
operator|(
name|u_char
operator|)
literal|'\241'
block|,
operator|(
name|u_char
operator|)
literal|'\242'
block|,
operator|(
name|u_char
operator|)
literal|'\243'
block|,
operator|(
name|u_char
operator|)
literal|'\244'
block|,
operator|(
name|u_char
operator|)
literal|'\245'
block|,
operator|(
name|u_char
operator|)
literal|'\246'
block|,
operator|(
name|u_char
operator|)
literal|'\247'
block|,
operator|(
name|u_char
operator|)
literal|'\250'
block|,
operator|(
name|u_char
operator|)
literal|'\251'
block|,
operator|(
name|u_char
operator|)
literal|'\252'
block|,
operator|(
name|u_char
operator|)
literal|'\253'
block|,
operator|(
name|u_char
operator|)
literal|'\254'
block|,
operator|(
name|u_char
operator|)
literal|'\255'
block|,
operator|(
name|u_char
operator|)
literal|'\256'
block|,
operator|(
name|u_char
operator|)
literal|'\257'
block|,
operator|(
name|u_char
operator|)
literal|'\260'
block|,
operator|(
name|u_char
operator|)
literal|'\261'
block|,
operator|(
name|u_char
operator|)
literal|'\262'
block|,
operator|(
name|u_char
operator|)
literal|'\263'
block|,
operator|(
name|u_char
operator|)
literal|'\264'
block|,
operator|(
name|u_char
operator|)
literal|'\265'
block|,
operator|(
name|u_char
operator|)
literal|'\266'
block|,
operator|(
name|u_char
operator|)
literal|'\267'
block|,
operator|(
name|u_char
operator|)
literal|'\270'
block|,
operator|(
name|u_char
operator|)
literal|'\271'
block|,
operator|(
name|u_char
operator|)
literal|'\272'
block|,
operator|(
name|u_char
operator|)
literal|'\273'
block|,
operator|(
name|u_char
operator|)
literal|'\274'
block|,
operator|(
name|u_char
operator|)
literal|'\275'
block|,
operator|(
name|u_char
operator|)
literal|'\276'
block|,
operator|(
name|u_char
operator|)
literal|'\277'
block|,
operator|(
name|u_char
operator|)
literal|'\300'
block|,
operator|(
name|u_char
operator|)
literal|'\341'
block|,
operator|(
name|u_char
operator|)
literal|'\342'
block|,
operator|(
name|u_char
operator|)
literal|'\343'
block|,
operator|(
name|u_char
operator|)
literal|'\344'
block|,
operator|(
name|u_char
operator|)
literal|'\345'
block|,
operator|(
name|u_char
operator|)
literal|'\346'
block|,
operator|(
name|u_char
operator|)
literal|'\347'
block|,
operator|(
name|u_char
operator|)
literal|'\350'
block|,
operator|(
name|u_char
operator|)
literal|'\351'
block|,
operator|(
name|u_char
operator|)
literal|'\352'
block|,
operator|(
name|u_char
operator|)
literal|'\353'
block|,
operator|(
name|u_char
operator|)
literal|'\354'
block|,
operator|(
name|u_char
operator|)
literal|'\355'
block|,
operator|(
name|u_char
operator|)
literal|'\356'
block|,
operator|(
name|u_char
operator|)
literal|'\357'
block|,
operator|(
name|u_char
operator|)
literal|'\360'
block|,
operator|(
name|u_char
operator|)
literal|'\361'
block|,
operator|(
name|u_char
operator|)
literal|'\362'
block|,
operator|(
name|u_char
operator|)
literal|'\363'
block|,
operator|(
name|u_char
operator|)
literal|'\364'
block|,
operator|(
name|u_char
operator|)
literal|'\365'
block|,
operator|(
name|u_char
operator|)
literal|'\366'
block|,
operator|(
name|u_char
operator|)
literal|'\367'
block|,
operator|(
name|u_char
operator|)
literal|'\370'
block|,
operator|(
name|u_char
operator|)
literal|'\371'
block|,
operator|(
name|u_char
operator|)
literal|'\372'
block|,
operator|(
name|u_char
operator|)
literal|'\333'
block|,
operator|(
name|u_char
operator|)
literal|'\334'
block|,
operator|(
name|u_char
operator|)
literal|'\335'
block|,
operator|(
name|u_char
operator|)
literal|'\336'
block|,
operator|(
name|u_char
operator|)
literal|'\337'
block|,
operator|(
name|u_char
operator|)
literal|'\340'
block|,
operator|(
name|u_char
operator|)
literal|'\341'
block|,
operator|(
name|u_char
operator|)
literal|'\342'
block|,
operator|(
name|u_char
operator|)
literal|'\343'
block|,
operator|(
name|u_char
operator|)
literal|'\344'
block|,
operator|(
name|u_char
operator|)
literal|'\345'
block|,
operator|(
name|u_char
operator|)
literal|'\346'
block|,
operator|(
name|u_char
operator|)
literal|'\347'
block|,
operator|(
name|u_char
operator|)
literal|'\350'
block|,
operator|(
name|u_char
operator|)
literal|'\351'
block|,
operator|(
name|u_char
operator|)
literal|'\352'
block|,
operator|(
name|u_char
operator|)
literal|'\353'
block|,
operator|(
name|u_char
operator|)
literal|'\354'
block|,
operator|(
name|u_char
operator|)
literal|'\355'
block|,
operator|(
name|u_char
operator|)
literal|'\356'
block|,
operator|(
name|u_char
operator|)
literal|'\357'
block|,
operator|(
name|u_char
operator|)
literal|'\360'
block|,
operator|(
name|u_char
operator|)
literal|'\361'
block|,
operator|(
name|u_char
operator|)
literal|'\362'
block|,
operator|(
name|u_char
operator|)
literal|'\363'
block|,
operator|(
name|u_char
operator|)
literal|'\364'
block|,
operator|(
name|u_char
operator|)
literal|'\365'
block|,
operator|(
name|u_char
operator|)
literal|'\366'
block|,
operator|(
name|u_char
operator|)
literal|'\367'
block|,
operator|(
name|u_char
operator|)
literal|'\370'
block|,
operator|(
name|u_char
operator|)
literal|'\371'
block|,
operator|(
name|u_char
operator|)
literal|'\372'
block|,
operator|(
name|u_char
operator|)
literal|'\373'
block|,
operator|(
name|u_char
operator|)
literal|'\374'
block|,
operator|(
name|u_char
operator|)
literal|'\375'
block|,
operator|(
name|u_char
operator|)
literal|'\376'
block|,
operator|(
name|u_char
operator|)
literal|'\377'
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_strcasecmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
specifier|register
specifier|const
name|u_char
modifier|*
name|cm
init|=
name|charmap
decl_stmt|,
modifier|*
name|us1
init|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|s1
decl_stmt|,
modifier|*
name|us2
init|=
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|cm
index|[
operator|*
name|us1
index|]
operator|==
name|cm
index|[
operator|*
name|us2
operator|++
index|]
condition|)
if|if
condition|(
operator|*
name|us1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cm
index|[
operator|*
name|us1
index|]
operator|-
name|cm
index|[
operator|*
operator|--
name|us2
index|]
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|dlt_choice
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
name|int
name|dlt
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DLT_CHOICE
parameter_list|(
name|code
parameter_list|,
name|description
parameter_list|)
value|{ #code, description, code }
end_define

begin_define
define|#
directive|define
name|DLT_CHOICE_SENTINEL
value|{ NULL, NULL, 0 }
end_define

begin_decl_stmt
specifier|static
name|struct
name|dlt_choice
name|dlt_choices
index|[]
init|=
block|{
name|DLT_CHOICE
argument_list|(
name|DLT_NULL
argument_list|,
literal|"BSD loopback"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_EN10MB
argument_list|,
literal|"Ethernet"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802
argument_list|,
literal|"Token ring"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ARCNET
argument_list|,
literal|"BSD ARCNET"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SLIP
argument_list|,
literal|"SLIP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP
argument_list|,
literal|"PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_FDDI
argument_list|,
literal|"FDDI"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ATM_RFC1483
argument_list|,
literal|"RFC 1483 LLC-encapsulated ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_RAW
argument_list|,
literal|"Raw IP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SLIP_BSDOS
argument_list|,
literal|"BSD/OS SLIP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_BSDOS
argument_list|,
literal|"BSD/OS PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ATM_CLIP
argument_list|,
literal|"Linux Classical IP-over-ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_SERIAL
argument_list|,
literal|"PPP over serial"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_ETHER
argument_list|,
literal|"PPPoE"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SYMANTEC_FIREWALL
argument_list|,
literal|"Symantec Firewall"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_C_HDLC
argument_list|,
literal|"Cisco HDLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_11
argument_list|,
literal|"802.11"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_FRELAY
argument_list|,
literal|"Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LOOP
argument_list|,
literal|"OpenBSD loopback"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ENC
argument_list|,
literal|"OpenBSD encapsulated IP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LINUX_SLL
argument_list|,
literal|"Linux cooked"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LTALK
argument_list|,
literal|"Localtalk"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PFLOG
argument_list|,
literal|"OpenBSD pflog file"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PFSYNC
argument_list|,
literal|"Packet filter state syncing"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PRISM_HEADER
argument_list|,
literal|"802.11 plus Prism header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IP_OVER_FC
argument_list|,
literal|"RFC 2625 IP-over-Fibre Channel"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SUNATM
argument_list|,
literal|"Sun raw ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_11_RADIO
argument_list|,
literal|"802.11 plus radiotap header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ARCNET_LINUX
argument_list|,
literal|"Linux ARCNET"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_MLPPP
argument_list|,
literal|"Juniper Multi-Link PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_MLFR
argument_list|,
literal|"Juniper Multi-Link Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ES
argument_list|,
literal|"Juniper Encryption Services PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_GGSN
argument_list|,
literal|"Juniper GGSN PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_MFR
argument_list|,
literal|"Juniper FRF.16 Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ATM2
argument_list|,
literal|"Juniper ATM2 PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_SERVICES
argument_list|,
literal|"Juniper Advanced Services PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ATM1
argument_list|,
literal|"Juniper ATM1 PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_APPLE_IP_OVER_IEEE1394
argument_list|,
literal|"Apple IP-over-IEEE 1394"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_MTP2_WITH_PHDR
argument_list|,
literal|"SS7 MTP2 with Pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_MTP2
argument_list|,
literal|"SS7 MTP2"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_MTP3
argument_list|,
literal|"SS7 MTP3"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SCCP
argument_list|,
literal|"SS7 SCCP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_DOCSIS
argument_list|,
literal|"DOCSIS"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LINUX_IRDA
argument_list|,
literal|"Linux IrDA"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_11_RADIO_AVS
argument_list|,
literal|"802.11 plus AVS radio information header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_MONITOR
argument_list|,
literal|"Juniper Passive Monitor PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPP_PPPD
argument_list|,
literal|"PPP for pppd, with direction flag"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_PPPOE
argument_list|,
literal|"Juniper PPPoE"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_PPPOE_ATM
argument_list|,
literal|"Juniper PPPoE/ATM"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_GPRS_LLC
argument_list|,
literal|"GPRS LLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_GPF_T
argument_list|,
literal|"GPF-T"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_GPF_F
argument_list|,
literal|"GPF-F"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_PIC_PEER
argument_list|,
literal|"Juniper PIC Peer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ERF_ETH
argument_list|,
literal|"Ethernet with Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ERF_POS
argument_list|,
literal|"Packet-over-SONET with Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_LINUX_LAPD
argument_list|,
literal|"Linux vISDN LAPD"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ETHER
argument_list|,
literal|"Juniper Ethernet"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_PPP
argument_list|,
literal|"Juniper PPP"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_FRELAY
argument_list|,
literal|"Juniper Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_CHDLC
argument_list|,
literal|"Juniper C-HDLC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_MFR
argument_list|,
literal|"FRF.16 Frame Relay"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_VP
argument_list|,
literal|"Juniper Voice PIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_A429
argument_list|,
literal|"Arinc 429"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_A653_ICM
argument_list|,
literal|"Arinc 653 Interpartition Communication"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_USB
argument_list|,
literal|"USB"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_BLUETOOTH_HCI_H4
argument_list|,
literal|"Bluetooth HCI UART transport layer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_16_MAC_CPS
argument_list|,
literal|"IEEE 802.16 MAC Common Part Sublayer"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_USB_LINUX
argument_list|,
literal|"USB with Linux header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_CAN20B
argument_list|,
literal|"Controller Area Network (CAN) v. 2.0B"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_15_4_LINUX
argument_list|,
literal|"IEEE 802.15.4 with Linux padding"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_PPI
argument_list|,
literal|"Per-Packet Information"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_16_MAC_CPS_RADIO
argument_list|,
literal|"IEEE 802.16 MAC Common Part Sublayer plus radiotap header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ISM
argument_list|,
literal|"Juniper Integrated Service Module"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_15_4
argument_list|,
literal|"IEEE 802.15.4 with FCS"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_SITA
argument_list|,
literal|"SITA pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_ERF
argument_list|,
literal|"Endace ERF header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_RAIF1
argument_list|,
literal|"Ethernet with u10 Networks pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IPMB
argument_list|,
literal|"IPMB"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ST
argument_list|,
literal|"Juniper Secure Tunnel"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_BLUETOOTH_HCI_H4_WITH_PHDR
argument_list|,
literal|"Bluetooth HCI UART transport layer plus pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_AX25_KISS
argument_list|,
literal|"AX.25 with KISS header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_15_4_NONASK_PHY
argument_list|,
literal|"IEEE 802.15.4 with non-ASK PHY data"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_MPLS
argument_list|,
literal|"MPLS with label as link-layer header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_USB_LINUX_MMAPPED
argument_list|,
literal|"USB with padded Linux header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_DECT
argument_list|,
literal|"DECT"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_AOS
argument_list|,
literal|"AOS Space Data Link protocol"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_WIHART
argument_list|,
literal|"Wireless HART"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_FC_2
argument_list|,
literal|"Fibre Channel FC-2"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_FC_2_WITH_FRAME_DELIMS
argument_list|,
literal|"Fibre Channel FC-2 with frame delimiters"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IPNET
argument_list|,
literal|"Solaris ipnet"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_CAN_SOCKETCAN
argument_list|,
literal|"CAN-bus with SocketCAN headers"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IPV4
argument_list|,
literal|"Raw IPv4"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IPV6
argument_list|,
literal|"Raw IPv6"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IEEE802_15_4_NOFCS
argument_list|,
literal|"IEEE 802.15.4 without FCS"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_VS
argument_list|,
literal|"Juniper Virtual Server"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_SRX_E2E
argument_list|,
literal|"Juniper SRX E2E"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_FIBRECHANNEL
argument_list|,
literal|"Juniper Fibre Channel"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_DVB_CI
argument_list|,
literal|"DVB-CI"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_JUNIPER_ATM_CEMIC
argument_list|,
literal|"Juniper ATM CEMIC"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_NFLOG
argument_list|,
literal|"Linux netfilter log messages"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_NETANALYZER
argument_list|,
literal|"Ethernet with Hilscher netANALYZER pseudo-header"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_NETANALYZER_TRANSPARENT
argument_list|,
literal|"Ethernet with Hilscher netANALYZER pseudo-header and with preamble and SFD"
argument_list|)
block|,
name|DLT_CHOICE
argument_list|(
name|DLT_IPOIB
argument_list|,
literal|"RFC 4391 IP-over-Infiniband"
argument_list|)
block|,
name|DLT_CHOICE_SENTINEL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_datalink_name_to_val
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcap_strcasecmp
argument_list|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|+
sizeof|sizeof
argument_list|(
literal|"DLT_"
argument_list|)
operator|-
literal|1
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_datalink_val_to_name
parameter_list|(
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|==
name|dlt
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|+
sizeof|sizeof
argument_list|(
literal|"DLT_"
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_datalink_val_to_description
parameter_list|(
name|int
name|dlt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dlt_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|dlt
operator|==
name|dlt
condition|)
return|return
operator|(
name|dlt_choices
index|[
name|i
index|]
operator|.
name|description
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|tstamp_type_choice
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tstamp_type_choice
name|tstamp_type_choices
index|[]
init|=
block|{
block|{
literal|"host"
block|,
literal|"Host"
block|,
name|PCAP_TSTAMP_HOST
block|}
block|,
block|{
literal|"host_lowprec"
block|,
literal|"Host, low precision"
block|,
name|PCAP_TSTAMP_HOST_LOWPREC
block|}
block|,
block|{
literal|"host_hiprec"
block|,
literal|"Host, high precision"
block|,
name|PCAP_TSTAMP_HOST_HIPREC
block|}
block|,
block|{
literal|"adapter"
block|,
literal|"Adapter"
block|,
name|PCAP_TSTAMP_ADAPTER
block|}
block|,
block|{
literal|"adapter_unsynced"
block|,
literal|"Adapter, not synced with system time"
block|,
name|PCAP_TSTAMP_ADAPTER_UNSYNCED
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcap_tstamp_type_name_to_val
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcap_strcasecmp
argument_list|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|type
operator|)
return|;
block|}
return|return
operator|(
name|PCAP_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_tstamp_type_val_to_name
parameter_list|(
name|int
name|tstamp_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|type
operator|==
name|tstamp_type
condition|)
return|return
operator|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|pcap_tstamp_type_val_to_description
parameter_list|(
name|int
name|tstamp_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|type
operator|==
name|tstamp_type
condition|)
return|return
operator|(
name|tstamp_type_choices
index|[
name|i
index|]
operator|.
name|description
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_snapshot
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|snapshot
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_is_swapped
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|swapped
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_major_version
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|version_major
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_minor_version
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|version_minor
operator|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|pcap_file
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|sf
operator|.
name|rfile
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_fileno
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|WIN32
return|return
operator|(
name|p
operator|->
name|fd
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|p
operator|->
name|adapter
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|int
operator|)
operator|(
name|DWORD
operator|)
name|p
operator|->
name|adapter
operator|->
name|hFile
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|int
name|pcap_get_selectable_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|selectable_fd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pcap_perror
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|prefix
argument_list|,
name|p
operator|->
name|errbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|pcap_geterr
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|errbuf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_getnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|getnonblock_op
argument_list|(
name|p
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current non-blocking mode setting, under the assumption that  * it's just the standard POSIX non-blocking flag.  *  * We don't look at "p->nonblock", in case somebody tweaked the FD  * directly.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|int
name|pcap_getnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fdflags
decl_stmt|;
name|fdflags
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_GETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fdflags
operator|&
name|O_NONBLOCK
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcap_setnonblock
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setnonblock_op
argument_list|(
name|p
argument_list|,
name|nonblock
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_comment
comment|/*  * Set non-blocking mode, under the assumption that it's just the  * standard POSIX non-blocking flag.  (This can be called by the  * per-platform non-blocking-mode routine if that routine also  * needs to do some additional work.)  */
end_comment

begin_function
name|int
name|pcap_setnonblock_fd
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|nonblock
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|int
name|fdflags
decl_stmt|;
name|fdflags
operator|=
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdflags
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_GETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nonblock
condition|)
name|fdflags
operator||=
name|O_NONBLOCK
expr_stmt|;
else|else
name|fdflags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fdflags
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"F_SETFL: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/*  * Generate a string for the last Win32-specific error (i.e. an error generated when   * calling a Win32 API).  * For errors occurred during standard C calls, we still use pcap_strerror()  */
end_comment

begin_function
name|char
modifier|*
name|pcap_win32strerror
parameter_list|(
name|void
parameter_list|)
block|{
name|DWORD
name|error
decl_stmt|;
specifier|static
name|char
name|errbuf
index|[
name|PCAP_ERRBUF_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|errlen
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|error
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|FormatMessage
argument_list|(
name|FORMAT_MESSAGE_FROM_SYSTEM
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|,
literal|0
argument_list|,
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * "FormatMessage()" "helpfully" sticks CR/LF at the end of the 	 * message.  Get rid of it. 	 */
name|errlen
operator|=
name|strlen
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errlen
operator|>=
literal|2
condition|)
block|{
name|errbuf
index|[
name|errlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|errbuf
index|[
name|errlen
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|errbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
operator|-
operator|(
name|p
operator|-
name|errbuf
operator|)
argument_list|,
literal|" (%lu)"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Generate error strings for PCAP_ERROR_ and PCAP_WARNING_ values.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcap_statustostr
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
specifier|static
name|char
name|ebuf
index|[
literal|15
operator|+
literal|10
operator|+
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|errnum
condition|)
block|{
case|case
name|PCAP_WARNING
case|:
return|return
operator|(
literal|"Generic warning"
operator|)
return|;
case|case
name|PCAP_WARNING_TSTAMP_TYPE_NOTSUP
case|:
return|return
operator|(
literal|"That type of time stamp is not supported by that device"
operator|)
return|;
case|case
name|PCAP_WARNING_PROMISC_NOTSUP
case|:
return|return
operator|(
literal|"That device doesn't support promiscuous mode"
operator|)
return|;
case|case
name|PCAP_ERROR
case|:
return|return
operator|(
literal|"Generic error"
operator|)
return|;
case|case
name|PCAP_ERROR_BREAK
case|:
return|return
operator|(
literal|"Loop terminated by pcap_breakloop"
operator|)
return|;
case|case
name|PCAP_ERROR_NOT_ACTIVATED
case|:
return|return
operator|(
literal|"The pcap_t has not been activated"
operator|)
return|;
case|case
name|PCAP_ERROR_ACTIVATED
case|:
return|return
operator|(
literal|"The setting can't be changed after the pcap_t is activated"
operator|)
return|;
case|case
name|PCAP_ERROR_NO_SUCH_DEVICE
case|:
return|return
operator|(
literal|"No such device exists"
operator|)
return|;
case|case
name|PCAP_ERROR_RFMON_NOTSUP
case|:
return|return
operator|(
literal|"That device doesn't support monitor mode"
operator|)
return|;
case|case
name|PCAP_ERROR_NOT_RFMON
case|:
return|return
operator|(
literal|"That operation is supported only in monitor mode"
operator|)
return|;
case|case
name|PCAP_ERROR_PERM_DENIED
case|:
return|return
operator|(
literal|"You don't have permission to capture on that device"
operator|)
return|;
case|case
name|PCAP_ERROR_IFACE_NOT_UP
case|:
return|return
operator|(
literal|"That device is not up"
operator|)
return|;
case|case
name|PCAP_ERROR_CANTSET_TSTAMP_TYPE
case|:
return|return
operator|(
literal|"That device doesn't support setting the time stamp type"
operator|)
return|;
case|case
name|PCAP_ERROR_PROMISC_PERM_DENIED
case|:
return|return
operator|(
literal|"You don't have permission to capture in promiscuous mode on that device"
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
name|ebuf
argument_list|,
literal|"Unknown error: %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|ebuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Not all systems have strerror().  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcap_strerror
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_STRERROR
return|return
operator|(
name|strerror
argument_list|(
name|errnum
argument_list|)
operator|)
return|;
else|#
directive|else
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|char
name|ebuf
index|[
literal|15
operator|+
literal|10
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|errnum
operator|<
name|sys_nerr
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|sys_errlist
index|[
name|errnum
index|]
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ebuf
argument_list|,
sizeof|sizeof
name|ebuf
argument_list|,
literal|"Unknown error: %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|ebuf
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|pcap_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setfilter_op
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set direction flag, which controls whether we accept only incoming  * packets, only outgoing packets, or both.  * Note that, depending on the platform, some or all direction arguments  * might not be supported.  */
end_comment

begin_function
name|int
name|pcap_setdirection
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|pcap_direction_t
name|d
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|setdirection_op
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Setting direction is not implemented on this platform"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|p
operator|->
name|setdirection_op
argument_list|(
name|p
argument_list|,
name|d
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|stats_op
argument_list|(
name|p
argument_list|,
name|ps
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_stats_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
name|_U_
parameter_list|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"Statistics aren't available from a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_function
name|int
name|pcap_setbuff
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dim
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setbuff_op
argument_list|(
name|p
argument_list|,
name|dim
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setbuff_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|dim
parameter_list|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The kernel buffer size cannot be set on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setmode
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setmode_op
argument_list|(
name|p
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setmode_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"impossible to set mode on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setmintocopy
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|setmintocopy_op
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcap_setmintocopy_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|snprintf
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|,
literal|"The mintocopy parameter cannot be set on a pcap_open_dead pcap_t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * On some platforms, we need to clean up promiscuous or monitor mode  * when we close a device - and we want that to happen even if the  * application just exits without explicitl closing devices.  * On those platforms, we need to register a "close all the pcaps"  * routine to be called when we exit, and need to maintain a list of  * pcaps that need to be closed to clean up modes.  *  * XXX - not thread-safe.  */
end_comment

begin_comment
comment|/*  * List of pcaps on which we've done something that needs to be  * cleaned up.  * If there are any such pcaps, we arrange to call "pcap_close_all()"  * when we exit, and have it close all of them.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcap
modifier|*
name|pcaps_to_close
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TRUE if we've already called "atexit()" to cause "pcap_close_all()" to  * be called on exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|did_atexit
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pcap_close_all
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pcap
modifier|*
name|handle
decl_stmt|;
while|while
condition|(
operator|(
name|handle
operator|=
name|pcaps_to_close
operator|)
operator|!=
name|NULL
condition|)
name|pcap_close
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcap_do_addexit
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * If we haven't already done so, arrange to have 	 * "pcap_close_all()" called when we exit. 	 */
if|if
condition|(
operator|!
name|did_atexit
condition|)
block|{
if|if
condition|(
name|atexit
argument_list|(
name|pcap_close_all
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * "atexit()" failed; let our caller know. 			 */
name|strncpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
literal|"atexit failed"
argument_list|,
name|PCAP_ERRBUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|did_atexit
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_add_to_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|p
operator|->
name|md
operator|.
name|next
operator|=
name|pcaps_to_close
expr_stmt|;
name|pcaps_to_close
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcap_remove_from_pcaps_to_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
name|pcap_t
modifier|*
name|pc
decl_stmt|,
modifier|*
name|prevpc
decl_stmt|;
for|for
control|(
name|pc
operator|=
name|pcaps_to_close
operator|,
name|prevpc
operator|=
name|NULL
init|;
name|pc
operator|!=
name|NULL
condition|;
name|prevpc
operator|=
name|pc
operator|,
name|pc
operator|=
name|pc
operator|->
name|md
operator|.
name|next
control|)
block|{
if|if
condition|(
name|pc
operator|==
name|p
condition|)
block|{
comment|/* 			 * Found it.  Remove it from the list. 			 */
if|if
condition|(
name|prevpc
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * It was at the head of the list. 				 */
name|pcaps_to_close
operator|=
name|pc
operator|->
name|md
operator|.
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * It was in the middle of the list. 				 */
name|prevpc
operator|->
name|md
operator|.
name|next
operator|=
name|pc
operator|->
name|md
operator|.
name|next
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pcap_cleanup_live_common
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|dlt_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|dlt_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|dlt_list
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|dlt_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|tstamp_type_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|tstamp_type_list
argument_list|)
expr_stmt|;
name|p
operator|->
name|tstamp_type_list
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|tstamp_type_count
operator|=
literal|0
expr_stmt|;
block|}
name|pcap_freecode
argument_list|(
operator|&
name|p
operator|->
name|fcode
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
if|if
condition|(
name|p
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|selectable_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|send_fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|pcap_cleanup_dead
parameter_list|(
name|pcap_t
modifier|*
name|p
name|_U_
parameter_list|)
block|{
comment|/* Nothing to do. */
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_dead
parameter_list|(
name|int
name|linktype
parameter_list|,
name|int
name|snaplen
parameter_list|)
block|{
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
name|p
operator|->
name|linktype
operator|=
name|linktype
expr_stmt|;
name|p
operator|->
name|stats_op
operator|=
name|pcap_stats_dead
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|p
operator|->
name|setbuff_op
operator|=
name|pcap_setbuff_dead
expr_stmt|;
name|p
operator|->
name|setmode_op
operator|=
name|pcap_setmode_dead
expr_stmt|;
name|p
operator|->
name|setmintocopy_op
operator|=
name|pcap_setmintocopy_dead
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|cleanup_op
operator|=
name|pcap_cleanup_dead
expr_stmt|;
name|p
operator|->
name|activated
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * API compatible with WinPcap's "send a packet" routine - returns -1  * on error, 0 otherwise.  *  * XXX - what if we get a short write?  */
end_comment

begin_function
name|int
name|pcap_sendpacket
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|inject_op
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * API compatible with OpenBSD's "send a packet" routine - returns -1 on  * error, number of bytes written otherwise.  */
end_comment

begin_function
name|int
name|pcap_inject
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|p
operator|->
name|inject_op
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcap_close
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|opt
operator|.
name|source
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|opt
operator|.
name|source
argument_list|)
expr_stmt|;
name|p
operator|->
name|cleanup_op
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a BPF program, a pcap_pkthdr structure for a packet, and the raw  * data for the packet, check whether the packet passes the filter.  * Returns the return value of the filter program, which will be zero if  * the packet doesn't pass and non-zero if the packet does pass.  */
end_comment

begin_function
name|int
name|pcap_offline_filter
parameter_list|(
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pkt
parameter_list|)
block|{
name|struct
name|bpf_insn
modifier|*
name|fcode
init|=
name|fp
operator|->
name|bf_insns
decl_stmt|;
if|if
condition|(
name|fcode
operator|!=
name|NULL
condition|)
return|return
operator|(
name|bpf_filter
argument_list|(
name|fcode
argument_list|,
name|pkt
argument_list|,
name|h
operator|->
name|len
argument_list|,
name|h
operator|->
name|caplen
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We make the version string static, and return a pointer to it, rather  * than exporting the version string directly.  On at least some UNIXes,  * if you import data from a shared library into an program, the data is  * bound into the program binary, so if the string in the version of the  * library with which the program was linked isn't the same as the  * string in the version of the library with which the program is being  * run, various undesirable things may happen (warnings, the string  * being the one from the version of the library with which the program  * was linked, or even weirder things, such as the string being the one  * from the library but being truncated).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VERSION_H
end_ifdef

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string
index|[]
init|=
literal|"libpcap version 1.x.y"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_comment
comment|/*  * XXX - it'd be nice if we could somehow generate the WinPcap and libpcap  * version numbers when building WinPcap.  (It'd be nice to do so for  * the packet.dll version number as well.)  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|wpcap_version_string
index|[]
init|=
literal|"4.0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string_fmt
index|[]
init|=
literal|"WinPcap version %s, based on %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|pcap_version_string_packet_dll_fmt
index|[]
init|=
literal|"WinPcap version %s (packet.dll version %s), based on %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|full_pcap_version_string
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|packet_version_string
decl_stmt|;
name|size_t
name|full_pcap_version_string_len
decl_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Generate the version string. 		 */
name|packet_version_string
operator|=
name|PacketGetVersion
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|wpcap_version_string
argument_list|,
name|packet_version_string
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * WinPcap version string and packet.dll version 			 * string are the same; just report the WinPcap 			 * version. 			 */
name|full_pcap_version_string_len
operator|=
operator|(
sizeof|sizeof
name|pcap_version_string_fmt
operator|-
literal|4
operator|)
operator|+
name|strlen
argument_list|(
name|wpcap_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|full_pcap_version_string
argument_list|,
name|pcap_version_string_fmt
argument_list|,
name|wpcap_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * WinPcap version string and packet.dll version 			 * string are different; that shouldn't be the 			 * case (the two libraries should come from the 			 * same version of WinPcap), so we report both 			 * versions. 			 */
name|full_pcap_version_string_len
operator|=
operator|(
sizeof|sizeof
name|pcap_version_string_packet_dll_fmt
operator|-
literal|6
operator|)
operator|+
name|strlen
argument_list|(
name|wpcap_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|packet_version_string
argument_list|)
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|full_pcap_version_string
argument_list|,
name|pcap_version_string_packet_dll_fmt
argument_list|,
name|wpcap_version_string
argument_list|,
name|packet_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|full_pcap_version_string
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|full_pcap_version_string
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|packet_version_string
decl_stmt|;
name|size_t
name|full_pcap_version_string_len
decl_stmt|;
specifier|static
name|char
name|dospfx
index|[]
init|=
literal|"DOS-"
decl_stmt|;
if|if
condition|(
name|full_pcap_version_string
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Generate the version string. 		 */
name|full_pcap_version_string_len
operator|=
sizeof|sizeof
name|dospfx
operator|+
name|strlen
argument_list|(
name|pcap_version_string
argument_list|)
expr_stmt|;
name|full_pcap_version_string
operator|=
name|malloc
argument_list|(
name|full_pcap_version_string_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_pcap_version_string
argument_list|,
name|dospfx
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_pcap_version_string
argument_list|,
name|pcap_version_string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|full_pcap_version_string
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UN*X */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcap_lib_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|pcap_version_string
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

