begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- FuzzerDictionary.h - Internal header for the Fuzzer ------*- C++ -* ===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// fuzzer::Dictionary
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_FUZZER_DICTIONARY_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_FUZZER_DICTIONARY_H
end_define

begin_include
include|#
directive|include
file|"FuzzerDefs.h"
end_include

begin_include
include|#
directive|include
file|"FuzzerIO.h"
end_include

begin_include
include|#
directive|include
file|"FuzzerUtil.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_decl_stmt
name|namespace
name|fuzzer
block|{
comment|// A simple POD sized array of bytes.
name|template
operator|<
name|size_t
name|kMaxSizeT
operator|>
name|class
name|FixedWord
block|{
name|public
operator|:
specifier|static
specifier|const
name|size_t
name|kMaxSize
operator|=
name|kMaxSizeT
block|;
name|FixedWord
argument_list|()
block|{}
name|FixedWord
argument_list|(
argument|const uint8_t *B
argument_list|,
argument|uint8_t S
argument_list|)
block|{
name|Set
argument_list|(
name|B
argument_list|,
name|S
argument_list|)
block|; }
name|void
name|Set
argument_list|(
argument|const uint8_t *B
argument_list|,
argument|uint8_t S
argument_list|)
block|{
name|assert
argument_list|(
name|S
operator|<=
name|kMaxSize
argument_list|)
block|;
name|memcpy
argument_list|(
name|Data
argument_list|,
name|B
argument_list|,
name|S
argument_list|)
block|;
name|Size
operator|=
name|S
block|;   }
name|bool
name|operator
operator|==
operator|(
specifier|const
name|FixedWord
operator|<
name|kMaxSize
operator|>
operator|&
name|w
operator|)
specifier|const
block|{
name|ScopedDoingMyOwnMemOrStr
name|scoped_doing_my_own_mem_os_str
block|;
return|return
name|Size
operator|==
name|w
operator|.
name|Size
operator|&&
literal|0
operator|==
name|memcmp
argument_list|(
name|Data
argument_list|,
name|w
operator|.
name|Data
argument_list|,
name|Size
argument_list|)
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|FixedWord
operator|<
name|kMaxSize
operator|>
operator|&
name|w
operator|)
specifier|const
block|{
name|ScopedDoingMyOwnMemOrStr
name|scoped_doing_my_own_mem_os_str
block|;
if|if
condition|(
name|Size
operator|!=
name|w
operator|.
name|Size
condition|)
return|return
name|Size
operator|<
name|w
operator|.
name|Size
return|;
return|return
name|memcmp
argument_list|(
name|Data
argument_list|,
name|w
operator|.
name|Data
argument_list|,
name|Size
argument_list|)
operator|<
literal|0
return|;
block|}
specifier|static
name|size_t
name|GetMaxSize
parameter_list|()
block|{
return|return
name|kMaxSize
return|;
block|}
specifier|const
name|uint8_t
operator|*
name|data
argument_list|()
specifier|const
block|{
return|return
name|Data
return|;
block|}
name|uint8_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
name|private
label|:
name|uint8_t
name|Size
init|=
literal|0
decl_stmt|;
name|uint8_t
name|Data
index|[
name|kMaxSize
index|]
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|FixedWord
operator|<
literal|64
operator|>
name|Word
expr_stmt|;
end_typedef

begin_decl_stmt
name|class
name|DictionaryEntry
block|{
name|public
label|:
name|DictionaryEntry
argument_list|()
block|{}
name|DictionaryEntry
argument_list|(
argument|Word W
argument_list|)
block|:
name|W
argument_list|(
argument|W
argument_list|)
block|{}
name|DictionaryEntry
argument_list|(
argument|Word W
argument_list|,
argument|size_t PositionHint
argument_list|)
block|:
name|W
argument_list|(
name|W
argument_list|)
operator|,
name|PositionHint
argument_list|(
argument|PositionHint
argument_list|)
block|{}
specifier|const
name|Word
operator|&
name|GetW
argument_list|()
specifier|const
block|{
return|return
name|W
return|;
block|}
name|bool
name|HasPositionHint
argument_list|()
specifier|const
block|{
return|return
name|PositionHint
operator|!=
name|std
operator|::
name|numeric_limits
operator|<
name|size_t
operator|>
operator|::
name|max
argument_list|()
return|;
block|}
name|size_t
name|GetPositionHint
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|HasPositionHint
argument_list|()
argument_list|)
block|;
return|return
name|PositionHint
return|;
block|}
name|void
name|IncUseCount
parameter_list|()
block|{
name|UseCount
operator|++
expr_stmt|;
block|}
name|void
name|IncSuccessCount
parameter_list|()
block|{
name|SuccessCount
operator|++
expr_stmt|;
block|}
name|size_t
name|GetUseCount
argument_list|()
specifier|const
block|{
return|return
name|UseCount
return|;
block|}
name|size_t
name|GetSuccessCount
argument_list|()
specifier|const
block|{
return|return
name|SuccessCount
return|;
block|}
name|void
name|Print
parameter_list|(
specifier|const
name|char
modifier|*
name|PrintAfter
init|=
literal|"\n"
parameter_list|)
block|{
name|PrintASCII
argument_list|(
name|W
operator|.
name|data
argument_list|()
argument_list|,
name|W
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|HasPositionHint
argument_list|()
condition|)
name|Printf
argument_list|(
literal|"@%zd"
argument_list|,
name|GetPositionHint
argument_list|()
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%s"
argument_list|,
name|PrintAfter
argument_list|)
expr_stmt|;
block|}
name|private
label|:
name|Word
name|W
decl_stmt|;
name|size_t
name|PositionHint
init|=
name|std
operator|::
name|numeric_limits
operator|<
name|size_t
operator|>
operator|::
name|max
argument_list|()
decl_stmt|;
name|size_t
name|UseCount
init|=
literal|0
decl_stmt|;
name|size_t
name|SuccessCount
init|=
literal|0
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|Dictionary
block|{
name|public
label|:
specifier|static
specifier|const
name|size_t
name|kMaxDictSize
init|=
literal|1
operator|<<
literal|14
decl_stmt|;
name|bool
name|ContainsWord
argument_list|(
specifier|const
name|Word
operator|&
name|W
argument_list|)
decl|const
block|{
return|return
name|std
operator|::
name|any_of
argument_list|(
name|begin
argument_list|()
argument_list|,
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
specifier|const
name|DictionaryEntry
operator|&
name|DE
operator|)
block|{
return|return
name|DE
operator|.
name|GetW
argument_list|()
operator|==
name|W
return|;
block|}
block|)
decl_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
specifier|const
name|DictionaryEntry
operator|*
name|begin
argument_list|()
specifier|const
block|{
return|return
operator|&
name|DE
index|[
literal|0
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|DictionaryEntry
operator|*
name|end
argument_list|()
specifier|const
block|{
return|return
name|begin
argument_list|()
operator|+
name|Size
return|;
block|}
end_expr_stmt

begin_function
name|DictionaryEntry
modifier|&
name|operator
function|[]
parameter_list|(
name|size_t
name|Idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|Size
argument_list|)
expr_stmt|;
return|return
name|DE
index|[
name|Idx
index|]
return|;
block|}
end_function

begin_function
name|void
name|push_back
parameter_list|(
name|DictionaryEntry
name|DE
parameter_list|)
block|{
if|if
condition|(
name|Size
operator|<
name|kMaxDictSize
condition|)
name|this
operator|->
name|DE
index|[
name|Size
operator|++
index|]
operator|=
name|DE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear
parameter_list|()
block|{
name|Size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|Size
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|Size
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|DictionaryEntry
name|DE
index|[
name|kMaxDictSize
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|Size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// Parses one dictionary entry.
end_comment

begin_comment
comment|// If successfull, write the enty to Unit and returns true,
end_comment

begin_comment
comment|// otherwise returns false.
end_comment

begin_decl_stmt
name|bool
name|ParseOneDictionaryEntry
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Str
argument_list|,
name|Unit
operator|*
name|U
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Parses the dictionary file, fills Units, returns true iff all lines
end_comment

begin_comment
comment|// were parsed succesfully.
end_comment

begin_decl_stmt
name|bool
name|ParseDictionaryFile
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Text
argument_list|,
name|std
operator|::
name|vector
operator|<
name|Unit
operator|>
operator|*
name|Units
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// namespace fuzzer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_FUZZER_DICTIONARY_H
end_comment

end_unit

