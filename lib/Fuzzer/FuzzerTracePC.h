begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- FuzzerTracePC.h - Internal header for the Fuzzer ---------*- C++ -* ===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// fuzzer::TracePC
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_FUZZER_TRACE_PC
end_ifndef

begin_define
define|#
directive|define
name|LLVM_FUZZER_TRACE_PC
end_define

begin_include
include|#
directive|include
file|"FuzzerDefs.h"
end_include

begin_include
include|#
directive|include
file|"FuzzerValueBitMap.h"
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|fuzzer
block|{
comment|// TableOfRecentCompares (TORC) remembers the most recently performed
comment|// comparisons of type T.
comment|// We record the arguments of CMP instructions in this table unconditionally
comment|// because it seems cheaper this way than to compute some expensive
comment|// conditions inside __sanitizer_cov_trace_cmp*.
comment|// After the unit has been executed we may decide to use the contents of
comment|// this table to populate a Dictionary.
name|template
operator|<
name|class
name|T
operator|,
name|size_t
name|kSizeT
operator|>
expr|struct
name|TableOfRecentCompares
block|{
specifier|static
specifier|const
name|size_t
name|kSize
operator|=
name|kSizeT
block|;   struct
name|Pair
block|{
name|T
name|A
block|,
name|B
block|;   }
block|;
name|void
name|Insert
argument_list|(
argument|size_t Idx
argument_list|,
argument|T Arg1
argument_list|,
argument|T Arg2
argument_list|)
block|{
name|Idx
operator|=
name|Idx
operator|%
name|kSize
block|;
name|Table
index|[
name|Idx
index|]
operator|.
name|A
operator|=
name|Arg1
block|;
name|Table
index|[
name|Idx
index|]
operator|.
name|B
operator|=
name|Arg2
block|;   }
name|Pair
name|Get
argument_list|(
argument|size_t I
argument_list|)
block|{
return|return
name|Table
index|[
name|I
operator|%
name|kSize
index|]
return|;
block|}
name|Pair
name|Table
index|[
name|kSize
index|]
block|; }
expr_stmt|;
name|class
name|TracePC
block|{
name|public
label|:
specifier|static
specifier|const
name|size_t
name|kFeatureSetSize
init|=
name|ValueBitMap
operator|::
name|kNumberOfItems
decl_stmt|;
name|void
name|HandleTrace
parameter_list|(
name|uint32_t
modifier|*
name|guard
parameter_list|,
name|uintptr_t
name|PC
parameter_list|)
function_decl|;
name|void
name|HandleInit
parameter_list|(
name|uint32_t
modifier|*
name|start
parameter_list|,
name|uint32_t
modifier|*
name|stop
parameter_list|)
function_decl|;
name|void
name|HandleCallerCallee
parameter_list|(
name|uintptr_t
name|Caller
parameter_list|,
name|uintptr_t
name|Callee
parameter_list|)
function_decl|;
name|void
name|HandleValueProfile
parameter_list|(
name|size_t
name|Value
parameter_list|)
block|{
name|ValueProfileMap
operator|.
name|AddValue
argument_list|(
name|Value
argument_list|)
expr_stmt|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|void
name|HandleCmp
argument_list|(
argument|void *PC
argument_list|,
argument|T Arg1
argument_list|,
argument|T Arg2
argument_list|)
expr_stmt|;
name|size_t
name|GetTotalPCCoverage
parameter_list|()
function_decl|;
name|void
name|SetUseCounters
parameter_list|(
name|bool
name|UC
parameter_list|)
block|{
name|UseCounters
operator|=
name|UC
expr_stmt|;
block|}
name|void
name|SetUseValueProfile
parameter_list|(
name|bool
name|VP
parameter_list|)
block|{
name|UseValueProfile
operator|=
name|VP
expr_stmt|;
block|}
name|void
name|SetPrintNewPCs
parameter_list|(
name|bool
name|P
parameter_list|)
block|{
name|DoPrintNewPCs
operator|=
name|P
expr_stmt|;
block|}
name|template
operator|<
name|class
name|Callback
operator|>
name|size_t
name|CollectFeatures
argument_list|(
argument|Callback CB
argument_list|)
expr_stmt|;
name|bool
name|UpdateValueProfileMap
parameter_list|(
name|ValueBitMap
modifier|*
name|MaxValueProfileMap
parameter_list|)
block|{
return|return
name|UseValueProfile
operator|&&
name|MaxValueProfileMap
operator|->
name|MergeFrom
argument_list|(
name|ValueProfileMap
argument_list|)
return|;
block|}
name|void
name|ResetMaps
parameter_list|()
block|{
name|ValueProfileMap
operator|.
name|Reset
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|Counters
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Counters
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|UpdateFeatureSet
parameter_list|(
name|size_t
name|CurrentElementIdx
parameter_list|,
name|size_t
name|CurrentElementSize
parameter_list|)
function_decl|;
name|void
name|PrintFeatureSet
parameter_list|()
function_decl|;
name|void
name|PrintModuleInfo
parameter_list|()
function_decl|;
name|void
name|PrintCoverage
parameter_list|()
function_decl|;
name|void
name|DumpCoverage
parameter_list|()
function_decl|;
name|void
name|AddValueForMemcmp
parameter_list|(
name|void
modifier|*
name|caller_pc
parameter_list|,
specifier|const
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
name|void
name|AddValueForStrcmp
parameter_list|(
name|void
modifier|*
name|caller_pc
parameter_list|,
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
name|bool
name|UsingTracePcGuard
argument_list|()
specifier|const
block|{
return|return
name|NumModules
return|;
block|}
specifier|static
specifier|const
name|size_t
name|kTORCSize
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
name|TableOfRecentCompares
operator|<
name|uint32_t
operator|,
name|kTORCSize
operator|>
name|TORC4
expr_stmt|;
name|TableOfRecentCompares
operator|<
name|uint64_t
operator|,
name|kTORCSize
operator|>
name|TORC8
expr_stmt|;
name|void
name|PrintNewPCs
parameter_list|()
function_decl|;
name|void
name|InitializePrintNewPCs
parameter_list|()
function_decl|;
name|size_t
name|GetNumPCs
argument_list|()
specifier|const
block|{
return|return
name|Min
argument_list|(
name|kNumPCs
argument_list|,
name|NumGuards
operator|+
literal|1
argument_list|)
return|;
block|}
name|uintptr_t
name|GetPC
parameter_list|(
name|size_t
name|Idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|GetNumPCs
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|PCs
index|[
name|Idx
index|]
return|;
block|}
name|private
label|:
name|bool
name|UseCounters
init|=
name|false
decl_stmt|;
name|bool
name|UseValueProfile
init|=
name|false
decl_stmt|;
name|bool
name|DoPrintNewPCs
init|=
name|false
decl_stmt|;
struct|struct
name|Module
block|{
name|uint32_t
modifier|*
name|Start
decl_stmt|,
modifier|*
name|Stop
decl_stmt|;
block|}
struct|;
name|Module
name|Modules
index|[
literal|4096
index|]
decl_stmt|;
name|size_t
name|NumModules
decl_stmt|;
comment|// linker-initialized.
name|size_t
name|NumGuards
decl_stmt|;
comment|// linker-initialized.
specifier|static
specifier|const
name|size_t
name|kNumCounters
init|=
literal|1
operator|<<
literal|14
decl_stmt|;
name|alignas
argument_list|(
literal|8
argument_list|)
name|uint8_t
name|Counters
index|[
name|kNumCounters
index|]
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|kNumPCs
init|=
literal|1
operator|<<
literal|24
decl_stmt|;
name|uintptr_t
name|PCs
index|[
name|kNumPCs
index|]
decl_stmt|;
name|std
operator|::
name|set
operator|<
name|uintptr_t
operator|>
operator|*
name|PrintedPCs
expr_stmt|;
name|ValueBitMap
name|ValueProfileMap
decl_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Callback
operator|>
name|size_t
name|TracePC
operator|::
name|CollectFeatures
argument_list|(
argument|Callback CB
argument_list|)
block|{
if|if
condition|(
operator|!
name|UsingTracePcGuard
argument_list|()
condition|)
return|return
literal|0
return|;
name|size_t
name|Res
operator|=
literal|0
expr_stmt|;
specifier|const
name|size_t
name|Step
init|=
literal|8
decl_stmt|;
name|assert
argument_list|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Counters
operator|)
operator|%
name|Step
operator|==
literal|0
argument_list|)
expr_stmt|;
name|size_t
name|N
init|=
name|Min
argument_list|(
name|kNumCounters
argument_list|,
name|NumGuards
operator|+
literal|1
argument_list|)
decl_stmt|;
name|N
operator|=
operator|(
name|N
operator|+
name|Step
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|Step
operator|-
literal|1
operator|)
expr_stmt|;
comment|// Round up.
for|for
control|(
name|size_t
name|Idx
init|=
literal|0
init|;
name|Idx
operator|<
name|N
condition|;
name|Idx
operator|+=
name|Step
control|)
block|{
name|uint64_t
name|Bundle
init|=
operator|*
name|reinterpret_cast
operator|<
name|uint64_t
operator|*
operator|>
operator|(
operator|&
name|Counters
index|[
name|Idx
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|Bundle
condition|)
continue|continue;
for|for
control|(
name|size_t
name|i
init|=
name|Idx
init|;
name|i
operator|<
name|Idx
operator|+
name|Step
condition|;
name|i
operator|++
control|)
block|{
name|uint8_t
name|Counter
init|=
operator|(
name|Bundle
operator|>>
operator|(
operator|(
name|i
operator|-
name|Idx
operator|)
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
operator|!
name|Counter
condition|)
continue|continue;
name|Counters
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|unsigned
name|Bit
init|=
literal|0
decl_stmt|;
comment|/**/
if|if
condition|(
name|Counter
operator|>=
literal|128
condition|)
name|Bit
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|32
condition|)
name|Bit
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|16
condition|)
name|Bit
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|8
condition|)
name|Bit
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|4
condition|)
name|Bit
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|3
condition|)
name|Bit
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|2
condition|)
name|Bit
operator|=
literal|1
expr_stmt|;
name|size_t
name|Feature
init|=
operator|(
name|i
operator|*
literal|8
operator|+
name|Bit
operator|)
decl_stmt|;
if|if
condition|(
name|CB
argument_list|(
name|Feature
argument_list|)
condition|)
name|Res
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|UseValueProfile
condition|)
name|ValueProfileMap
operator|.
name|ForEach
argument_list|(
index|[
operator|&
index|]
operator|(
name|size_t
name|Idx
operator|)
block|{
if|if
condition|(
name|CB
argument_list|(
name|NumGuards
operator|*
literal|8
operator|+
name|Idx
argument_list|)
condition|)
name|Res
operator|++
expr_stmt|;
block|}
block|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|Res
return|;
end_return

begin_decl_stmt
unit|}  extern
name|TracePC
name|TPC
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// namespace fuzzer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_FUZZER_TRACE_PC
end_comment

end_unit

