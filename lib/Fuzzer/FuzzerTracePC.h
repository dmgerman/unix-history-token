begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- FuzzerTracePC.h - Internal header for the Fuzzer ---------*- C++ -* ===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// fuzzer::TracePC
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_FUZZER_TRACE_PC
end_ifndef

begin_define
define|#
directive|define
name|LLVM_FUZZER_TRACE_PC
end_define

begin_include
include|#
directive|include
file|"FuzzerDefs.h"
end_include

begin_include
include|#
directive|include
file|"FuzzerDictionary.h"
end_include

begin_include
include|#
directive|include
file|"FuzzerValueBitMap.h"
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|fuzzer
block|{
comment|// TableOfRecentCompares (TORC) remembers the most recently performed
comment|// comparisons of type T.
comment|// We record the arguments of CMP instructions in this table unconditionally
comment|// because it seems cheaper this way than to compute some expensive
comment|// conditions inside __sanitizer_cov_trace_cmp*.
comment|// After the unit has been executed we may decide to use the contents of
comment|// this table to populate a Dictionary.
name|template
operator|<
name|class
name|T
operator|,
name|size_t
name|kSizeT
operator|>
expr|struct
name|TableOfRecentCompares
block|{
specifier|static
specifier|const
name|size_t
name|kSize
operator|=
name|kSizeT
block|;   struct
name|Pair
block|{
name|T
name|A
block|,
name|B
block|;   }
block|;
name|ATTRIBUTE_NO_SANITIZE_ALL
name|void
name|Insert
argument_list|(
argument|size_t Idx
argument_list|,
argument|const T&Arg1
argument_list|,
argument|const T&Arg2
argument_list|)
block|{
name|Idx
operator|=
name|Idx
operator|%
name|kSize
block|;
name|Table
index|[
name|Idx
index|]
operator|.
name|A
operator|=
name|Arg1
block|;
name|Table
index|[
name|Idx
index|]
operator|.
name|B
operator|=
name|Arg2
block|;   }
name|Pair
name|Get
argument_list|(
argument|size_t I
argument_list|)
block|{
return|return
name|Table
index|[
name|I
operator|%
name|kSize
index|]
return|;
block|}
name|Pair
name|Table
index|[
name|kSize
index|]
block|; }
expr_stmt|;
name|class
name|TracePC
block|{
name|public
label|:
specifier|static
specifier|const
name|size_t
name|kNumPCs
init|=
literal|1
operator|<<
literal|21
decl_stmt|;
comment|// How many bits of PC are used from __sanitizer_cov_trace_pc.
specifier|static
specifier|const
name|size_t
name|kTracePcBits
init|=
literal|18
decl_stmt|;
name|void
name|HandleInit
parameter_list|(
name|uint32_t
modifier|*
name|start
parameter_list|,
name|uint32_t
modifier|*
name|stop
parameter_list|)
function_decl|;
name|void
name|HandleCallerCallee
parameter_list|(
name|uintptr_t
name|Caller
parameter_list|,
name|uintptr_t
name|Callee
parameter_list|)
function_decl|;
name|template
operator|<
name|class
name|T
operator|>
name|void
name|HandleCmp
argument_list|(
argument|uintptr_t PC
argument_list|,
argument|T Arg1
argument_list|,
argument|T Arg2
argument_list|)
expr_stmt|;
name|size_t
name|GetTotalPCCoverage
parameter_list|()
function_decl|;
name|void
name|SetUseCounters
parameter_list|(
name|bool
name|UC
parameter_list|)
block|{
name|UseCounters
operator|=
name|UC
expr_stmt|;
block|}
name|void
name|SetUseValueProfile
parameter_list|(
name|bool
name|VP
parameter_list|)
block|{
name|UseValueProfile
operator|=
name|VP
expr_stmt|;
block|}
name|void
name|SetPrintNewPCs
parameter_list|(
name|bool
name|P
parameter_list|)
block|{
name|DoPrintNewPCs
operator|=
name|P
expr_stmt|;
block|}
name|template
operator|<
name|class
name|Callback
operator|>
name|void
name|CollectFeatures
argument_list|(
argument|Callback CB
argument_list|)
specifier|const
expr_stmt|;
name|void
name|ResetMaps
parameter_list|()
block|{
name|ValueProfileMap
operator|.
name|Reset
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|Counters
argument_list|()
argument_list|,
literal|0
argument_list|,
name|GetNumPCs
argument_list|()
argument_list|)
expr_stmt|;
name|ClearExtraCounters
argument_list|()
expr_stmt|;
block|}
name|void
name|UpdateFeatureSet
parameter_list|(
name|size_t
name|CurrentElementIdx
parameter_list|,
name|size_t
name|CurrentElementSize
parameter_list|)
function_decl|;
name|void
name|PrintFeatureSet
parameter_list|()
function_decl|;
name|void
name|PrintModuleInfo
parameter_list|()
function_decl|;
name|void
name|PrintCoverage
parameter_list|()
function_decl|;
name|void
name|DumpCoverage
parameter_list|()
function_decl|;
name|void
name|AddValueForMemcmp
parameter_list|(
name|void
modifier|*
name|caller_pc
parameter_list|,
specifier|const
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|,
name|bool
name|StopAtZero
parameter_list|)
function_decl|;
name|TableOfRecentCompares
operator|<
name|uint32_t
operator|,
literal|32
operator|>
name|TORC4
expr_stmt|;
name|TableOfRecentCompares
operator|<
name|uint64_t
operator|,
literal|32
operator|>
name|TORC8
expr_stmt|;
name|TableOfRecentCompares
operator|<
name|Word
operator|,
literal|32
operator|>
name|TORCW
expr_stmt|;
name|void
name|PrintNewPCs
parameter_list|()
function_decl|;
name|void
name|InitializePrintNewPCs
parameter_list|()
function_decl|;
name|size_t
name|GetNumPCs
argument_list|()
specifier|const
block|{
return|return
name|NumGuards
operator|==
literal|0
operator|?
operator|(
literal|1
operator|<<
name|kTracePcBits
operator|)
operator|:
name|Min
argument_list|(
name|kNumPCs
argument_list|,
name|NumGuards
operator|+
literal|1
argument_list|)
return|;
block|}
name|uintptr_t
name|GetPC
parameter_list|(
name|size_t
name|Idx
parameter_list|)
block|{
name|assert
argument_list|(
name|Idx
operator|<
name|GetNumPCs
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|PCs
argument_list|()
index|[
name|Idx
index|]
return|;
block|}
name|private
label|:
name|bool
name|UseCounters
init|=
name|false
decl_stmt|;
name|bool
name|UseValueProfile
init|=
name|false
decl_stmt|;
name|bool
name|DoPrintNewPCs
init|=
name|false
decl_stmt|;
struct|struct
name|Module
block|{
name|uint32_t
modifier|*
name|Start
decl_stmt|,
modifier|*
name|Stop
decl_stmt|;
block|}
struct|;
name|Module
name|Modules
index|[
literal|4096
index|]
decl_stmt|;
name|size_t
name|NumModules
decl_stmt|;
comment|// linker-initialized.
name|size_t
name|NumGuards
decl_stmt|;
comment|// linker-initialized.
name|uint8_t
operator|*
name|Counters
argument_list|()
specifier|const
expr_stmt|;
name|uintptr_t
operator|*
name|PCs
argument_list|()
specifier|const
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|uintptr_t
operator|>
operator|*
name|PrintedPCs
expr_stmt|;
name|ValueBitMap
name|ValueProfileMap
decl_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|Callback
operator|>
comment|// void Callback(size_t Idx, uint8_t Value);
name|ATTRIBUTE_NO_SANITIZE_ALL
name|void
name|ForEachNonZeroByte
argument_list|(
argument|const uint8_t *Begin
argument_list|,
argument|const uint8_t *End
argument_list|,
argument|size_t FirstFeature
argument_list|,
argument|Callback Handle8bitCounter
argument_list|)
block|{
typedef|typedef
name|uintptr_t
name|LargeType
typedef|;
specifier|const
name|size_t
name|Step
operator|=
sizeof|sizeof
argument_list|(
name|LargeType
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|Begin
operator|)
operator|%
literal|64
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|P
init|=
name|Begin
init|;
name|P
operator|<
name|End
condition|;
name|P
operator|+=
name|Step
control|)
if|if
condition|(
name|LargeType
name|Bundle
init|=
operator|*
name|reinterpret_cast
operator|<
specifier|const
name|LargeType
operator|*
operator|>
operator|(
name|P
operator|)
condition|)
for|for
control|(
name|size_t
name|I
init|=
literal|0
init|;
name|I
operator|<
name|Step
condition|;
name|I
operator|++
operator|,
name|Bundle
operator|>>=
literal|8
control|)
if|if
condition|(
name|uint8_t
name|V
init|=
name|Bundle
operator|&
literal|0xff
condition|)
name|Handle8bitCounter
argument_list|(
name|FirstFeature
operator|+
name|P
operator|-
name|Begin
operator|+
name|I
argument_list|,
name|V
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|Callback
operator|>
comment|// bool Callback(size_t Feature)
name|ATTRIBUTE_NO_SANITIZE_ALL
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
name|void
name|TracePC
operator|::
name|CollectFeatures
argument_list|(
argument|Callback HandleFeature
argument_list|)
specifier|const
block|{
name|uint8_t
operator|*
name|Counters
operator|=
name|this
operator|->
name|Counters
argument_list|()
block|;
name|size_t
name|N
operator|=
name|GetNumPCs
argument_list|()
block|;
name|auto
name|Handle8bitCounter
operator|=
index|[
operator|&
index|]
operator|(
name|size_t
name|Idx
operator|,
name|uint8_t
name|Counter
operator|)
block|{
name|assert
argument_list|(
name|Counter
argument_list|)
block|;
name|unsigned
name|Bit
operator|=
literal|0
block|;
comment|/**/
if|if
condition|(
name|Counter
operator|>=
literal|128
condition|)
name|Bit
operator|=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|32
condition|)
name|Bit
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|16
condition|)
name|Bit
operator|=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|8
condition|)
name|Bit
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|4
condition|)
name|Bit
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|3
condition|)
name|Bit
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|Counter
operator|>=
literal|2
condition|)
name|Bit
operator|=
literal|1
expr_stmt|;
name|HandleFeature
argument_list|(
name|Idx
operator|*
literal|8
operator|+
name|Bit
argument_list|)
block|;   }
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ForEachNonZeroByte
argument_list|(
name|Counters
argument_list|,
name|Counters
operator|+
name|N
argument_list|,
literal|0
argument_list|,
name|Handle8bitCounter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ForEachNonZeroByte
argument_list|(
name|ExtraCountersBegin
argument_list|()
argument_list|,
name|ExtraCountersEnd
argument_list|()
argument_list|,
name|N
operator|*
literal|8
argument_list|,
name|Handle8bitCounter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|UseValueProfile
condition|)
name|ValueProfileMap
operator|.
name|ForEach
argument_list|(
index|[
operator|&
index|]
operator|(
name|size_t
name|Idx
operator|)
block|{
name|HandleFeature
argument_list|(
name|N
operator|*
literal|8
operator|+
name|Idx
argument_list|)
block|;     }
end_if

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
unit|}  extern
name|TracePC
name|TPC
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// namespace fuzzer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_FUZZER_TRACE_PC
end_comment

end_unit

