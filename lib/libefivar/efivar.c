begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Netflix, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<efivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/efiio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"efichar.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|efi_fd
init|=
operator|-
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Z
value|{ 0, 0, 0, 0, 0, { 0 } }
end_define

begin_decl_stmt
specifier|const
name|efi_guid_t
name|efi_guid_empty
init|=
name|Z
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid_table
name|guid_tbl
index|[]
init|=
block|{
block|{
literal|"00000000-0000-0000-0000-000000000000"
block|,
literal|"zero"
block|,
name|Z
block|}
block|,
block|{
literal|"093e0fae-a6c4-4f50-9f1b-d41e2b89c19a"
block|,
literal|"sha512"
block|,
name|Z
block|}
block|,
block|{
literal|"0abba7dc-e516-4167-bbf5-4d9d1c739416"
block|,
literal|"redhat"
block|,
name|Z
block|}
block|,
block|{
literal|"0b6e5233-a65c-44c9-9407-d9ab83bfc8bd"
block|,
literal|"sha224"
block|,
name|Z
block|}
block|,
block|{
literal|"126a762d-5758-4fca-8531-201a7f57f850"
block|,
literal|"lenovo_boot_menu"
block|,
name|Z
block|}
block|,
block|{
literal|"3bd2a492-96c0-4079-b420-fcf98ef103ed"
block|,
literal|"x509_sha256"
block|,
name|Z
block|}
block|,
block|{
literal|"3c5766e8-269c-4e34-aa14-ed776e85b3b6"
block|,
literal|"rsa2048"
block|,
name|Z
block|}
block|,
block|{
literal|"3CC24E96-22C7-41D8-8863-8E39DCDCC2CF"
block|,
literal|"lenovo"
block|,
name|Z
block|}
block|,
block|{
literal|"3f7e615b-0d45-4f80-88dc-26b234958560"
block|,
literal|"lenovo_diag"
block|,
name|Z
block|}
block|,
block|{
literal|"446dbf63-2502-4cda-bcfa-2465d2b0fe9d"
block|,
literal|"x509_sha512"
block|,
name|Z
block|}
block|,
block|{
literal|"4aafd29d-68df-49ee-8aa9-347d375665a7"
block|,
literal|"pkcs7_cert"
block|,
name|Z
block|}
block|,
block|{
literal|"605dab50-e046-4300-abb6-3dd810dd8b23"
block|,
literal|"shim"
block|,
name|Z
block|}
block|,
block|{
literal|"665d3f60-ad3e-4cad-8e26-db46eee9f1b5"
block|,
literal|"lenovo_rescue"
block|,
name|Z
block|}
block|,
block|{
literal|"67f8444f-8743-48f1-a328-1eaab8736080"
block|,
literal|"rsa2048_sha1"
block|,
name|Z
block|}
block|,
block|{
literal|"7076876e-80c2-4ee6-aad2-28b349a6865b"
block|,
literal|"x509_sha384"
block|,
name|Z
block|}
block|,
block|{
literal|"721c8b66-426c-4e86-8e99-3457c46ab0b9"
block|,
literal|"lenovo_setup"
block|,
name|Z
block|}
block|,
block|{
literal|"77fa9abd-0359-4d32-bd60-28f4e78f784b"
block|,
literal|"microsoft"
block|,
name|Z
block|}
block|,
block|{
literal|"7FACC7B6-127F-4E9C-9C5D-080F98994345"
block|,
literal|"lenovo_2"
block|,
name|Z
block|}
block|,
block|{
literal|"826ca512-cf10-4ac9-b187-be01496631bd"
block|,
literal|"sha1"
block|,
name|Z
block|}
block|,
block|{
literal|"82988420-7467-4490-9059-feb448dd1963"
block|,
literal|"lenovo_me_config"
block|,
name|Z
block|}
block|,
block|{
literal|"8be4df61-93ca-11d2-aa0d-00e098032b8c"
block|,
literal|"global"
block|,
name|Z
block|}
block|,
block|{
literal|"a5c059a1-94e4-4aa7-87b5-ab155c2bf072"
block|,
literal|"x509_cert"
block|,
name|Z
block|}
block|,
block|{
literal|"a7717414-c616-4977-9420-844712a735bf"
block|,
literal|"rsa2048_sha256_cert"
block|,
name|Z
block|}
block|,
block|{
literal|"a7d8d9a6-6ab0-4aeb-ad9d-163e59a7a380"
block|,
literal|"lenovo_diag_splash"
block|,
name|Z
block|}
block|,
block|{
literal|"ade9e48f-9cb8-98e6-31af-b4e6009e2fe3"
block|,
literal|"redhat_2"
block|,
name|Z
block|}
block|,
block|{
literal|"bc7838d2-0f82-4d60-8316-c068ee79d25b"
block|,
literal|"lenovo_msg"
block|,
name|Z
block|}
block|,
block|{
literal|"c1c41626-504c-4092-aca9-41f936934328"
block|,
literal|"sha256"
block|,
name|Z
block|}
block|,
block|{
literal|"c57ad6b7-0515-40a8-9d21-551652854e37"
block|,
literal|"shell"
block|,
name|Z
block|}
block|,
block|{
literal|"d719b2cb-3d3a-4596-a3bc-dad00e67656f"
block|,
literal|"security"
block|,
name|Z
block|}
block|,
block|{
literal|"e2b36190-879b-4a3d-ad8d-f2e7bba32784"
block|,
literal|"rsa2048_sha256"
block|,
name|Z
block|}
block|,
block|{
literal|"ff3e5307-9fd0-48c9-85f1-8ad56c701e01"
block|,
literal|"sha384"
block|,
name|Z
block|}
block|,
block|{
literal|"f46ee6f4-4785-43a3-923d-7f786c3c8479"
block|,
literal|"lenovo_startup_interrupt"
block|,
name|Z
block|}
block|,
block|{
literal|"ffffffff-ffff-ffff-ffff-ffffffffffff"
block|,
literal|"zzignore-this-guid"
block|,
name|Z
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|Z
end_undef

begin_function
specifier|static
name|void
name|efi_guid_tbl_compile
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|done
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|guid_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uuid_from_string
argument_list|(
name|guid_tbl
index|[
name|i
index|]
operator|.
name|uuid_str
argument_list|,
operator|&
name|guid_tbl
index|[
name|i
index|]
operator|.
name|guid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* all f's is a bad version, so ignore that error */
if|if
condition|(
name|status
operator|!=
name|uuid_s_ok
operator|&&
name|status
operator|!=
name|uuid_s_bad_version
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't convert %s to a uuid for %s: %d\n"
argument_list|,
name|guid_tbl
index|[
name|i
index|]
operator|.
name|uuid_str
argument_list|,
name|guid_tbl
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
block|}
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|efi_known_guid
parameter_list|(
name|struct
name|uuid_table
modifier|*
modifier|*
name|tbl
parameter_list|)
block|{
operator|*
name|tbl
operator|=
name|guid_tbl
expr_stmt|;
return|return
operator|(
name|nitems
argument_list|(
name|guid_tbl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|efi_open_dev
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|efi_fd
operator|==
operator|-
literal|2
condition|)
name|efi_fd
operator|=
name|open
argument_list|(
literal|"/dev/efi"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|efi_fd
operator|<
literal|0
condition|)
name|efi_fd
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|efi_guid_tbl_compile
argument_list|()
expr_stmt|;
return|return
operator|(
name|efi_fd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|efi_var_reset
parameter_list|(
name|struct
name|efi_var_ioc
modifier|*
name|var
parameter_list|)
block|{
name|var
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|namesize
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|var
operator|->
name|vendor
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|var
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|attrib
operator|=
literal|0
expr_stmt|;
name|var
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|var
operator|->
name|datasize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rv_to_linux_rv
parameter_list|(
name|int
name|rv
parameter_list|)
block|{
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|rv
operator|=
literal|1
expr_stmt|;
else|else
name|rv
operator|=
operator|-
name|errno
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|efi_append_variable
parameter_list|(
name|efi_guid_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|data_size
parameter_list|,
name|uint32_t
name|attributes
parameter_list|)
block|{
return|return
name|efi_set_variable
argument_list|(
name|guid
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|,
name|attributes
operator||
name|EFI_VARIABLE_APPEND_WRITE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|efi_del_variable
parameter_list|(
name|efi_guid_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* data_size of 0 deletes the variable */
return|return
name|efi_set_variable
argument_list|(
name|guid
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|efi_get_variable
parameter_list|(
name|efi_guid_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|data
parameter_list|,
name|size_t
modifier|*
name|data_size
parameter_list|,
name|uint32_t
modifier|*
name|attributes
parameter_list|)
block|{
name|struct
name|efi_var_ioc
name|var
decl_stmt|;
name|int
name|rv
decl_stmt|;
specifier|static
name|uint8_t
name|buf
index|[
literal|1024
operator|*
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|efi_open_dev
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|efi_var_reset
argument_list|(
operator|&
name|var
argument_list|)
expr_stmt|;
name|rv
operator|=
name|utf8_to_ucs2
argument_list|(
name|name
argument_list|,
operator|&
name|var
operator|.
name|name
argument_list|,
operator|&
name|var
operator|.
name|namesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
name|var
operator|.
name|vendor
operator|=
name|guid
expr_stmt|;
name|var
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|var
operator|.
name|datasize
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|efi_fd
argument_list|,
name|EFIIOC_VAR_GET
argument_list|,
operator|&
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_size
operator|!=
name|NULL
condition|)
operator|*
name|data_size
operator|=
name|var
operator|.
name|datasize
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
operator|*
name|data
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|attributes
operator|!=
name|NULL
condition|)
operator|*
name|attributes
operator|=
name|var
operator|.
name|attrib
expr_stmt|;
name|errout
label|:
name|free
argument_list|(
name|var
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|rv_to_linux_rv
argument_list|(
name|rv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|efi_get_variable_attributes
parameter_list|(
name|efi_guid_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
modifier|*
name|attributes
parameter_list|)
block|{
comment|/* Make sure this construct works -- I think it will fail */
return|return
name|efi_get_variable
argument_list|(
name|guid
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|attributes
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|efi_get_variable_size
parameter_list|(
name|efi_guid_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
comment|/* XXX check to make sure this matches the linux value */
operator|*
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|efi_get_variable
argument_list|(
name|guid
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|efi_get_next_variable_name
parameter_list|(
name|efi_guid_t
modifier|*
modifier|*
name|guid
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|efi_var_ioc
name|var
decl_stmt|;
name|int
name|rv
decl_stmt|;
specifier|static
name|efi_char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|size_t
name|buflen
init|=
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|efi_char
argument_list|)
decl_stmt|;
specifier|static
name|efi_guid_t
name|retguid
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|efi_open_dev
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
name|again
label|:
name|efi_var_reset
argument_list|(
operator|&
name|var
argument_list|)
expr_stmt|;
name|var
operator|.
name|name
operator|=
name|buf
expr_stmt|;
name|var
operator|.
name|namesize
operator|=
name|buflen
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
name|NULL
condition|)
block|{
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
comment|/* GUID zeroed in var_reset */
block|}
else|else
block|{
name|rv
operator|=
name|utf8_to_ucs2
argument_list|(
operator|*
name|name
argument_list|,
operator|&
name|var
operator|.
name|name
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
name|var
operator|.
name|vendor
operator|=
operator|*
operator|*
name|guid
expr_stmt|;
block|}
name|rv
operator|=
name|ioctl
argument_list|(
name|efi_fd
argument_list|,
name|EFIIOC_VAR_NEXT
argument_list|,
operator|&
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|var
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * oops, too little space. Try again. 		 */
name|void
modifier|*
name|new
init|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
decl_stmt|;
name|buflen
operator|=
name|var
operator|.
name|namesize
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|buf
operator|=
name|new
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
operator|*
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* XXX */
name|var
operator|.
name|name
index|[
name|var
operator|.
name|namesize
operator|/
sizeof|sizeof
argument_list|(
name|efi_char
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
comment|/* EFI doesn't NUL terminate */
name|rv
operator|=
name|ucs2_to_utf8
argument_list|(
name|var
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
name|retguid
operator|=
name|var
operator|.
name|vendor
expr_stmt|;
operator|*
name|guid
operator|=
operator|&
name|retguid
expr_stmt|;
block|}
name|errout
label|:
comment|/* XXX The linux interface expects name to be a static buffer -- fix or leak memory? */
name|done
label|:
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|rv_to_linux_rv
argument_list|(
name|rv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|efi_guid_cmp
parameter_list|(
specifier|const
name|efi_guid_t
modifier|*
name|guid1
parameter_list|,
specifier|const
name|efi_guid_t
modifier|*
name|guid2
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
return|return
name|uuid_compare
argument_list|(
name|guid1
argument_list|,
name|guid2
argument_list|,
operator|&
name|status
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|efi_guid_is_zero
parameter_list|(
specifier|const
name|efi_guid_t
modifier|*
name|guid
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
return|return
name|uuid_is_nil
argument_list|(
name|guid
argument_list|,
operator|&
name|status
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|efi_guid_to_name
parameter_list|(
name|efi_guid_t
modifier|*
name|guid
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|efi_guid_tbl_compile
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|guid_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uuid_equal
argument_list|(
name|guid
argument_list|,
operator|&
name|guid_tbl
index|[
name|i
index|]
operator|.
name|guid
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
operator|*
name|name
operator|=
name|strdup
argument_list|(
name|guid_tbl
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|efi_guid_to_str
argument_list|(
name|guid
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|efi_guid_to_symbol
parameter_list|(
name|efi_guid_t
modifier|*
name|guid
name|__unused
parameter_list|,
name|char
modifier|*
modifier|*
name|symbol
name|__unused
parameter_list|)
block|{
comment|/* 	 * Unsure what this is used for, efibootmgr doesn't use it. 	 * Leave unimplemented for now. 	 */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|efi_guid_to_str
parameter_list|(
specifier|const
name|efi_guid_t
modifier|*
name|guid
parameter_list|,
name|char
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
comment|/* knows efi_guid_t is a typedef of uuid_t */
name|uuid_to_string
argument_list|(
name|guid
argument_list|,
name|sp
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|uuid_s_ok
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|efi_name_to_guid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|efi_guid_t
modifier|*
name|guid
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|efi_guid_tbl_compile
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|guid_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|guid_tbl
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|guid
operator|=
name|guid_tbl
index|[
name|i
index|]
operator|.
name|guid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|efi_str_to_guid
argument_list|(
name|name
argument_list|,
name|guid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|efi_set_variable
parameter_list|(
name|efi_guid_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|data_size
parameter_list|,
name|uint32_t
name|attributes
parameter_list|,
name|mode_t
name|mode
name|__unused
parameter_list|)
block|{
name|struct
name|efi_var_ioc
name|var
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|efi_open_dev
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|efi_var_reset
argument_list|(
operator|&
name|var
argument_list|)
expr_stmt|;
name|rv
operator|=
name|utf8_to_ucs2
argument_list|(
name|name
argument_list|,
operator|&
name|var
operator|.
name|name
argument_list|,
operator|&
name|var
operator|.
name|namesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
name|var
operator|.
name|vendor
operator|=
name|guid
expr_stmt|;
name|var
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|var
operator|.
name|datasize
operator|=
name|data_size
expr_stmt|;
name|var
operator|.
name|attrib
operator|=
name|attributes
expr_stmt|;
name|rv
operator|=
name|ioctl
argument_list|(
name|efi_fd
argument_list|,
name|EFIIOC_VAR_SET
argument_list|,
operator|&
name|var
argument_list|)
expr_stmt|;
name|errout
label|:
name|free
argument_list|(
name|var
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
name|int
name|efi_str_to_guid
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|efi_guid_t
modifier|*
name|guid
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
comment|/* knows efi_guid_t is a typedef of uuid_t */
name|uuid_from_string
argument_list|(
name|s
argument_list|,
name|guid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
name|uuid_s_ok
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|efi_variables_supported
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|efi_open_dev
argument_list|()
operator|!=
operator|-
literal|1
return|;
block|}
end_function

end_unit

