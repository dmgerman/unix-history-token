begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  -*- mode: c; tab-width: 8; c-basic-indent: 4; -*-     Alias_db.c encapsulates all data structures used for storing     packet aliasing data.  Other parts of the aliasing software     access data through functions provided in this file.      Data storage is based on the notion of a "link", which is     established for ICMP echo/reply packets, UDP datagrams and     TCP stream connections.  A link stores the original source     and destination addresses.  For UDP and TCP, it also stores     source and destination port numbers, as well as an alias     port number.  Links are also used to store information about     fragments.      There is a facility for sweeping through and deleting old     links as new packets are sent through.  A simple timeout is     used for ICMP and UDP links.  TCP links are left alone unless     there is an incomplete connection, in which case the link     can be deleted after a certain amount of time.       This software is placed into the public domain with no restrictions     on its distribution.      Initial version: August, 1996  (cjm)      Version 1.4: September 16, 1996 (cjm)         Facility for handling incoming links added.      Version 1.6: September 18, 1996 (cjm)         ICMP data handling simplified.      Version 1.7: January 9, 1997 (cjm)         Fragment handling simplified.         Saves pointers for unresolved fragments.         Permits links for unspecied remote ports           or unspecified remote addresses.         Fixed bug which did not properly zero port           table entries after a link was deleted.         Cleaned up some obsolete comments.      Version 1.8: January 14, 1997 (cjm)         Fixed data type error in StartPoint().         (This error did not exist prior to v1.7         and was discovered and fixed by Ari Suutari)      Version 1.9: February 1, 1997         Optionally, connections initiated from packet aliasing host         machine will will not have their port number aliased unless it         conflicts with an aliasing port already being used. (cjm)          All options earlier being #ifdef'ed now are available through         a new interface, SetPacketAliasMode().  This allow run time         control (which is now available in PPP+pktAlias through the         'alias' keyword). (ee)          Added ability to create an alias port without         either destination address or port specified.         port type = ALIAS_PORT_UNKNOWN_DEST_ALL (ee)           Removed K&R style function headers         and general cleanup. (ee)          Added packetAliasMode to replace compiler #defines's (ee)           Allocates sockets for partially specified         ports if ALIAS_USE_SOCKETS defined. (cjm)      Version 2.0: March, 1997         SetAliasAddress() will now clean up alias links         if the aliasing address is changed. (cjm)          PacketAliasPermanentLink() function added to support permanent         links.  (J. Fortes suggested the need for this.)         Examples:          (192.168.0.1, port 23)<-> alias port 6002, unknown dest addr/port           (192.168.0.2, port 21)<-> alias port 3604, known dest addr                                                      unknown dest port           These permament links allow for incoming connections to         machines on the local network.  They can be given with a         user-chosen amount of specificity, with increasing specificity         meaning more security. (cjm)          Quite a bit of rework to the basic engine.  The portTable[]         array, which kept track of which ports were in use was replaced         by a table/linked list structure. (cjm)          SetExpire() function added. (cjm)          DeleteLink() no longer frees memory association with a pointer         to a fragment (this bug was first recognized by E. Eiklund in         v1.9).      Version 2.1: May, 1997 (cjm)         Packet aliasing engine reworked so that it can handle         multiple external addresses rather than just a single         host address.          PacketAliasRedirectPort() and PacketAliasRedirectAddr()         added to the API.  The first function is a more generalized         version of PacketAliasPermanentLink().  The second function         implements static network address translation. */
end_comment

begin_comment
comment|/* System include files */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* BSD network include files */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_include
include|#
directive|include
file|"alias_local.h"
end_include

begin_comment
comment|/*    Constants (note: constants are also defined               near relevant functions or structs) */
end_comment

begin_comment
comment|/* Sizes of input and output link tables */
end_comment

begin_define
define|#
directive|define
name|LINK_TABLE_OUT_SIZE
value|101
end_define

begin_define
define|#
directive|define
name|LINK_TABLE_IN_SIZE
value|4001
end_define

begin_comment
comment|/* Parameters used for cleanup of expired links */
end_comment

begin_define
define|#
directive|define
name|ALIAS_CLEANUP_INTERVAL_SECS
value|60
end_define

begin_define
define|#
directive|define
name|ALIAS_CLEANUP_MAX_SPOKES
value|30
end_define

begin_comment
comment|/* Timouts (in seconds) for different link types) */
end_comment

begin_define
define|#
directive|define
name|ICMP_EXPIRE_TIME
value|60
end_define

begin_define
define|#
directive|define
name|UDP_EXPIRE_TIME
value|60
end_define

begin_define
define|#
directive|define
name|TCP_EXPIRE_TIME
value|90
end_define

begin_define
define|#
directive|define
name|FRAGMENT_ID_EXPIRE_TIME
value|10
end_define

begin_define
define|#
directive|define
name|FRAGMENT_PTR_EXPIRE_TIME
value|30
end_define

begin_comment
comment|/* Dummy port number codes used for FindLinkIn/Out() and AddLink().    These constants can be anything except zero, which indicates an    unknown port numbea. */
end_comment

begin_define
define|#
directive|define
name|NO_DEST_PORT
value|1
end_define

begin_define
define|#
directive|define
name|NO_SRC_PORT
value|1
end_define

begin_comment
comment|/* Data Structures       The fundamental data structure used in this program is     "struct alias_link".  Whenever a TCP connection is made,     a UDP datagram is sent out, or an ICMP echo request is made,     a link record is made (if it has not already been created).     The link record is identified by the source address/port     and the destination address/port. In the case of an ICMP     echo request, the source port is treated as being equivalent     with the 16-bit id number of the ICMP packet.      The link record also can store some auxiliary data.  For     TCP connections that have had sequence and acknowledgment     modifications, data space is available to track these changes.     A state field is used to keep track in changes to the tcp     connection state.  Id numbers of fragments can also be     stored in the auxiliary space.  Pointers to unresolved     framgents can also be stored.      The link records support two independent chainings.  Lookup     tables for input and out tables hold the initial pointers     the link chains.  On input, the lookup table indexes on alias     port and link type.  On output, the lookup table indexes on     source addreess, destination address, source port, destination     port and link type. */
end_comment

begin_struct
struct|struct
name|ack_data_record
comment|/* used to save changes to ack/seq numbers */
block|{
name|u_long
name|ack_old
decl_stmt|;
name|u_long
name|ack_new
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|int
name|active
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tcp_state
comment|/* Information about tcp connection        */
block|{
name|int
name|in
decl_stmt|;
comment|/* State for outside -> inside             */
name|int
name|out
decl_stmt|;
comment|/* State for inside  -> outside            */
name|int
name|index
decl_stmt|;
comment|/* Index to ack data array                 */
name|int
name|ack_modified
decl_stmt|;
comment|/* Indicates whether ack and seq numbers   */
comment|/* been modified                           */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|N_LINK_TCP_DATA
value|3
end_define

begin_comment
comment|/* Number of distinct ack number changes                                saved for a modified TCP stream */
end_comment

begin_struct
struct|struct
name|tcp_dat
block|{
name|struct
name|tcp_state
name|state
decl_stmt|;
name|struct
name|ack_data_record
name|ack
index|[
name|N_LINK_TCP_DATA
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|alias_link
comment|/* Main data structure */
block|{
name|struct
name|in_addr
name|src_addr
decl_stmt|;
comment|/* Address and port information        */
name|struct
name|in_addr
name|dst_addr
decl_stmt|;
comment|/*  .                                  */
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
comment|/*  .                                  */
name|u_short
name|src_port
decl_stmt|;
comment|/*  .                                  */
name|u_short
name|dst_port
decl_stmt|;
comment|/*  .                                  */
name|u_short
name|alias_port
decl_stmt|;
comment|/*  .                                  */
name|int
name|link_type
decl_stmt|;
comment|/* Type of link: tcp, udp, icmp, frag  */
comment|/* values for link_type */
define|#
directive|define
name|LINK_ICMP
value|1
define|#
directive|define
name|LINK_UDP
value|2
define|#
directive|define
name|LINK_TCP
value|3
define|#
directive|define
name|LINK_FRAGMENT_ID
value|4
define|#
directive|define
name|LINK_FRAGMENT_PTR
value|5
define|#
directive|define
name|LINK_ADDR
value|6
name|int
name|flags
decl_stmt|;
comment|/* indicates special characteristics   */
comment|/* flag bits */
define|#
directive|define
name|LINK_UNKNOWN_DEST_PORT
value|0x01
define|#
directive|define
name|LINK_UNKNOWN_DEST_ADDR
value|0x02
define|#
directive|define
name|LINK_PERMANENT
value|0x04
define|#
directive|define
name|LINK_PARTIALLY_SPECIFIED
value|0x03
comment|/* logical-or of first two bits */
name|int
name|timestamp
decl_stmt|;
comment|/* Time link was last accessed         */
name|int
name|expire_time
decl_stmt|;
comment|/* Expire time for link                */
name|int
name|sockfd
decl_stmt|;
comment|/* socket descriptor                   */
name|u_int
name|start_point_out
decl_stmt|;
comment|/* Index number in output lookup table */
name|u_int
name|start_point_in
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|next_out
decl_stmt|;
comment|/* Linked list pointers for input and  */
name|struct
name|alias_link
modifier|*
name|last_out
decl_stmt|;
comment|/* output tables                       */
name|struct
name|alias_link
modifier|*
name|next_in
decl_stmt|;
comment|/*  .                                  */
name|struct
name|alias_link
modifier|*
name|last_in
decl_stmt|;
comment|/*  .                                  */
union|union
comment|/* Auxiliary data                      */
block|{
name|char
modifier|*
name|frag_ptr
decl_stmt|;
name|struct
name|in_addr
name|frag_addr
decl_stmt|;
name|struct
name|tcp_dat
modifier|*
name|tcp
decl_stmt|;
block|}
name|data
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Global Variables       The global variables listed here are only accessed from     within alias_db.c and so are prefixed with the static      designation. */
end_comment

begin_decl_stmt
name|int
name|packetAliasMode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode flags                      */
end_comment

begin_comment
comment|/*        - documented in alias.h  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|aliasAddress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address written onto source     */
end_comment

begin_comment
comment|/*   field of IP packet.           */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|targetAddress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IP address incoming packets     */
end_comment

begin_comment
comment|/*   are sent to if no aliasing    */
end_comment

begin_comment
comment|/*   link already exists           */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|nullAddress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used as a dummy parameter for   */
end_comment

begin_comment
comment|/*   some function calls           */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|alias_link
modifier|*
name|linkTableOut
index|[
name|LINK_TABLE_OUT_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookup table of pointers to     */
end_comment

begin_comment
comment|/*   chains of link records. Each  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|alias_link
modifier|*
comment|/*   link record is doubly indexed */
name|linkTableIn
index|[
name|LINK_TABLE_IN_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   into input and output lookup  */
end_comment

begin_comment
comment|/*   tables.                       */
end_comment

begin_decl_stmt
specifier|static
name|int
name|icmpLinkCount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Link statistics                 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|udpLinkCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcpLinkCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fragmentIdLinkCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fragmentPtrLinkCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sockCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cleanupIndex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index to chain of link table    */
end_comment

begin_comment
comment|/* being inspected for old links   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeStamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System time in seconds for      */
end_comment

begin_comment
comment|/* current packet                  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastCleanupTime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last time IncrementalCleanup()  */
end_comment

begin_comment
comment|/* was called                      */
end_comment

begin_decl_stmt
specifier|static
name|int
name|houseKeepingResidual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by HouseKeeping()          */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deleteAllLinks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If equal to zero, DeleteLink()  */
end_comment

begin_comment
comment|/* will not remove permanent links */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|monitorFile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor for link        */
end_comment

begin_comment
comment|/* statistics monitoring file      */
end_comment

begin_decl_stmt
specifier|static
name|int
name|firstCall
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Needed by InitAlias()           */
end_comment

begin_decl_stmt
specifier|static
name|int
name|newDefaultLink
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates if a new aliasing     */
end_comment

begin_comment
comment|/* link has been created after a   */
end_comment

begin_comment
comment|/* call to PacketAliasIn/Out().    */
end_comment

begin_comment
comment|/* Internal utility routines (used only in alias_db.c)  Lookup table starting points:     StartPointIn()           -- link table initial search point for                                 outgoing packets     StartPointOut()          -- port table initial search point for                                 incoming packets      Miscellaneous:     SeqDiff()                -- difference between two TCP sequences     ShowAliasStats()         -- send alias statistics to a monitor file */
end_comment

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|u_int
name|StartPointIn
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|StartPointOut
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SeqDiff
parameter_list|(
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ShowAliasStats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|u_int
name|StartPointIn
parameter_list|(
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|int
name|link_type
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|n
operator|=
name|alias_addr
operator|.
name|s_addr
expr_stmt|;
name|n
operator|+=
name|alias_port
expr_stmt|;
name|n
operator|+=
name|link_type
expr_stmt|;
return|return
operator|(
name|n
operator|%
name|LINK_TABLE_IN_SIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|StartPointOut
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|link_type
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|n
operator|=
name|src_addr
operator|.
name|s_addr
expr_stmt|;
name|n
operator|+=
name|dst_addr
operator|.
name|s_addr
expr_stmt|;
name|n
operator|+=
name|src_port
expr_stmt|;
name|n
operator|+=
name|dst_port
expr_stmt|;
name|n
operator|+=
name|link_type
expr_stmt|;
return|return
operator|(
name|n
operator|%
name|LINK_TABLE_OUT_SIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SeqDiff
parameter_list|(
name|u_long
name|x
parameter_list|,
name|u_long
name|y
parameter_list|)
block|{
comment|/* Return the difference between two TCP sequence numbers */
comment|/*     This function is encapsulated in case there are any unusual     arithmetic conditions that need to be considered. */
return|return
operator|(
name|ntohl
argument_list|(
name|y
argument_list|)
operator|-
name|ntohl
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ShowAliasStats
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Used for debugging */
if|if
condition|(
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|fprintf
argument_list|(
name|monitorFile
argument_list|,
literal|"icmp=%d, udp=%d, tcp=%d, frag_id=%d frag_ptr=%d"
argument_list|,
name|icmpLinkCount
argument_list|,
name|udpLinkCount
argument_list|,
name|tcpLinkCount
argument_list|,
name|fragmentIdLinkCount
argument_list|,
name|fragmentPtrLinkCount
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|monitorFile
argument_list|,
literal|" / tot=%d  (sock=%d)\n"
argument_list|,
name|icmpLinkCount
operator|+
name|udpLinkCount
operator|+
name|tcpLinkCount
operator|+
name|fragmentIdLinkCount
operator|+
name|fragmentPtrLinkCount
argument_list|,
name|sockCount
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|monitorFile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Internal routines for finding, deleting and adding links  Port Allocation:     GetNewPort()             -- find and reserve new alias port number     GetSocket()              -- try to allocate a socket for a given port  Link creation and deletion:     CleanupAliasData()      - remove all link chains from lookup table     IncrementalCleanup()    - look for stale links in a single chain     DeleteLink()            - remove link     AddLink()               - add link   Link search:     FindLinkOut()           - find link for outgoing packets     FindLinkIn()            - find link for incoming packets */
end_comment

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|GetNewPort
parameter_list|(
name|struct
name|alias_link
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|GetSocket
parameter_list|(
name|u_short
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|CleanupAliasData
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IncrementalCleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DeleteLink
parameter_list|(
name|struct
name|alias_link
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_link
modifier|*
name|AddLink
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_link
modifier|*
name|FindLinkOut
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|alias_link
modifier|*
name|FindLinkIn
parameter_list|(
name|struct
name|in_addr
parameter_list|,
name|struct
name|in_addr
parameter_list|,
name|u_short
parameter_list|,
name|u_short
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ALIAS_PORT_BASE
value|0x08000
end_define

begin_define
define|#
directive|define
name|ALIAS_PORT_MASK
value|0x07fff
end_define

begin_define
define|#
directive|define
name|GET_NEW_PORT_MAX_ATTEMPTS
value|20
end_define

begin_define
define|#
directive|define
name|GET_ALIAS_PORT
value|-1
end_define

begin_define
define|#
directive|define
name|GET_ALIAS_ID
value|GET_ALIAS_PORT
end_define

begin_comment
comment|/* GetNewPort() allocates port numbers.  Note that if a port number    is already in use, that does not mean that it cannot be used by    another link concurrently.  This is because GetNewPort() looks for    unused triplets: (dest addr, dest port, alias port). */
end_comment

begin_function
specifier|static
name|int
name|GetNewPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|int
name|alias_port_param
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|max_trials
decl_stmt|;
name|u_short
name|port_sys
decl_stmt|;
name|u_short
name|port_net
decl_stmt|;
comment|/*    Description of alias_port_param for GetNewPort().  When    this parameter is zero or positive, it precisely specifies    the port number.  GetNewPort() will return this number    without check that it is in use.     Whis this parameter is -1, it indicates to get a randomly    selected port number. */
if|if
condition|(
name|alias_port_param
operator|==
name|GET_ALIAS_PORT
condition|)
block|{
comment|/*          * The aliasing port is automatically selected          * by one of two methods below:          */
name|max_trials
operator|=
name|GET_NEW_PORT_MAX_ATTEMPTS
expr_stmt|;
if|if
condition|(
name|packetAliasMode
operator|&
name|PKT_ALIAS_SAME_PORTS
condition|)
block|{
comment|/*              * When the ALIAS_SAME_PORTS option is              * chosen, the first try will be the              * actual source port. If this is already              * in use, the remainder of the trials              * will be random.              */
name|port_net
operator|=
name|link
operator|->
name|src_port
expr_stmt|;
name|port_sys
operator|=
name|ntohs
argument_list|(
name|port_net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* First trial and all subsequent are random. */
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK
expr_stmt|;
name|port_sys
operator|+=
name|ALIAS_PORT_BASE
expr_stmt|;
name|port_net
operator|=
name|htons
argument_list|(
name|port_sys
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|alias_port_param
operator|>=
literal|0
operator|&&
name|alias_port_param
operator|<
literal|0x10000
condition|)
block|{
name|link
operator|->
name|alias_port
operator|=
operator|(
name|u_short
operator|)
name|alias_port_param
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetNewPort(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"input parameter error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Port number search */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_trials
condition|;
name|i
operator|++
control|)
block|{
name|int
name|go_ahead
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|search_result
decl_stmt|;
name|search_result
operator|=
name|FindLinkIn
argument_list|(
name|link
operator|->
name|dst_addr
argument_list|,
name|link
operator|->
name|alias_addr
argument_list|,
name|link
operator|->
name|dst_port
argument_list|,
name|port_net
argument_list|,
name|link
operator|->
name|link_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_result
operator|==
name|NULL
condition|)
name|go_ahead
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|link
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
operator|&&
operator|(
name|search_result
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
condition|)
name|go_ahead
operator|=
literal|1
expr_stmt|;
else|else
name|go_ahead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|go_ahead
condition|)
block|{
if|if
condition|(
operator|(
name|packetAliasMode
operator|&&
name|PKT_ALIAS_USE_SOCKETS
operator|)
operator|&&
operator|(
name|link
operator|->
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
condition|)
block|{
if|if
condition|(
name|GetSocket
argument_list|(
name|port_net
argument_list|,
operator|&
name|link
operator|->
name|sockfd
argument_list|,
name|link
operator|->
name|link_type
argument_list|)
condition|)
block|{
name|link
operator|->
name|alias_port
operator|=
name|port_net
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|link
operator|->
name|alias_port
operator|=
name|port_net
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|port_sys
operator|=
name|random
argument_list|()
operator|&
name|ALIAS_PORT_MASK
expr_stmt|;
name|port_sys
operator|+=
name|ALIAS_PORT_BASE
expr_stmt|;
name|port_net
operator|=
name|htons
argument_list|(
name|port_sys
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetnewPort(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not find free port\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_short
name|GetSocket
parameter_list|(
name|u_short
name|port_net
parameter_list|,
name|int
modifier|*
name|sockfd
parameter_list|,
name|int
name|link_type
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|struct
name|sockaddr_in
name|sock_addr
decl_stmt|;
if|if
condition|(
name|link_type
operator|==
name|LINK_TCP
condition|)
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|link_type
operator|==
name|LINK_UDP
condition|)
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetSocket(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"incorrect link type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/GetSocket(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"socket() error %d\n"
argument_list|,
operator|*
name|sockfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sock_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sock_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|sock_addr
operator|.
name|sin_port
operator|=
name|port_net
expr_stmt|;
name|err
operator|=
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sock_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sock_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|sockCount
operator|++
expr_stmt|;
operator|*
name|sockfd
operator|=
name|sock
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|CleanupAliasData
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|int
name|i
decl_stmt|,
name|icount
decl_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINK_TABLE_OUT_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|=
name|linkTableOut
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
name|struct
name|alias_link
modifier|*
name|link_next
decl_stmt|;
name|link_next
operator|=
name|link
operator|->
name|next_out
expr_stmt|;
name|icount
operator|++
expr_stmt|;
name|DeleteLink
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|link
operator|=
name|link_next
expr_stmt|;
block|}
block|}
name|cleanupIndex
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|IncrementalCleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|icount
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
name|link
operator|=
name|linkTableOut
index|[
name|cleanupIndex
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
name|int
name|idelta
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link_next
decl_stmt|;
name|link_next
operator|=
name|link
operator|->
name|next_out
expr_stmt|;
name|idelta
operator|=
name|timeStamp
operator|-
name|link
operator|->
name|timestamp
expr_stmt|;
switch|switch
condition|(
name|link
operator|->
name|link_type
condition|)
block|{
case|case
name|LINK_ICMP
case|:
case|case
name|LINK_UDP
case|:
case|case
name|LINK_FRAGMENT_ID
case|:
case|case
name|LINK_FRAGMENT_PTR
case|:
if|if
condition|(
name|idelta
operator|>
name|link
operator|->
name|expire_time
condition|)
block|{
name|DeleteLink
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|icount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|LINK_TCP
case|:
if|if
condition|(
name|idelta
operator|>
name|link
operator|->
name|expire_time
condition|)
block|{
name|struct
name|tcp_dat
modifier|*
name|tcp_aux
decl_stmt|;
name|tcp_aux
operator|=
name|link
operator|->
name|data
operator|.
name|tcp
expr_stmt|;
if|if
condition|(
name|tcp_aux
operator|->
name|state
operator|.
name|in
operator|!=
literal|1
operator|||
name|tcp_aux
operator|->
name|state
operator|.
name|out
operator|!=
literal|1
condition|)
block|{
name|DeleteLink
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|icount
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
name|link
operator|=
name|link_next
expr_stmt|;
block|}
if|if
condition|(
name|cleanupIndex
operator|==
name|LINK_TABLE_OUT_SIZE
condition|)
name|cleanupIndex
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DeleteLink
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|link_last
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link_next
decl_stmt|;
comment|/* Don't do anything if the link is marked permanent */
if|if
condition|(
name|deleteAllLinks
operator|==
literal|0
operator|&&
name|link
operator|->
name|flags
operator|&
name|LINK_PERMANENT
condition|)
return|return;
comment|/* Adjust output table pointers */
name|link_last
operator|=
name|link
operator|->
name|last_out
expr_stmt|;
name|link_next
operator|=
name|link
operator|->
name|next_out
expr_stmt|;
if|if
condition|(
name|link_last
operator|!=
name|NULL
condition|)
name|link_last
operator|->
name|next_out
operator|=
name|link_next
expr_stmt|;
else|else
name|linkTableOut
index|[
name|link
operator|->
name|start_point_out
index|]
operator|=
name|link_next
expr_stmt|;
if|if
condition|(
name|link_next
operator|!=
name|NULL
condition|)
name|link_next
operator|->
name|last_out
operator|=
name|link_last
expr_stmt|;
comment|/* Adjust input table pointers */
name|link_last
operator|=
name|link
operator|->
name|last_in
expr_stmt|;
name|link_next
operator|=
name|link
operator|->
name|next_in
expr_stmt|;
if|if
condition|(
name|link_last
operator|!=
name|NULL
condition|)
name|link_last
operator|->
name|next_in
operator|=
name|link_next
expr_stmt|;
else|else
name|linkTableIn
index|[
name|link
operator|->
name|start_point_in
index|]
operator|=
name|link_next
expr_stmt|;
if|if
condition|(
name|link_next
operator|!=
name|NULL
condition|)
name|link_next
operator|->
name|last_in
operator|=
name|link_last
expr_stmt|;
comment|/* Close socket, if one has been allocated */
if|if
condition|(
name|link
operator|->
name|sockfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|sockCount
operator|--
expr_stmt|;
name|close
argument_list|(
name|link
operator|->
name|sockfd
argument_list|)
expr_stmt|;
block|}
comment|/* Link-type dependent cleanup */
switch|switch
condition|(
name|link
operator|->
name|link_type
condition|)
block|{
case|case
name|LINK_ICMP
case|:
name|icmpLinkCount
operator|--
expr_stmt|;
break|break;
case|case
name|LINK_UDP
case|:
name|udpLinkCount
operator|--
expr_stmt|;
break|break;
case|case
name|LINK_TCP
case|:
name|tcpLinkCount
operator|--
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|link
operator|->
name|data
operator|.
name|tcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_ID
case|:
name|fragmentIdLinkCount
operator|--
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_PTR
case|:
name|fragmentPtrLinkCount
operator|--
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|data
operator|.
name|frag_ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|link
operator|->
name|data
operator|.
name|frag_ptr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Free memory */
name|free
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* Write statistics, if logging enabled */
if|if
condition|(
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|ShowAliasStats
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|AddLink
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|alias_port_param
parameter_list|,
comment|/* if less than zero, alias   */
name|int
name|link_type
parameter_list|)
comment|/* port will be automatically */
block|{
comment|/* chosen. If greater than    */
name|u_int
name|start_point
decl_stmt|;
comment|/* zero, equal to alias port  */
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|first_link
decl_stmt|;
name|link
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|alias_link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
comment|/* If either the aliasing address or source address are        equal to the default device address (equal to the        global variable aliasAddress), then set the alias        address field of the link record to zero */
if|if
condition|(
name|src_addr
operator|.
name|s_addr
operator|==
name|aliasAddress
operator|.
name|s_addr
condition|)
name|src_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alias_addr
operator|.
name|s_addr
operator|==
name|aliasAddress
operator|.
name|s_addr
condition|)
name|alias_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
comment|/* Basic initialization */
name|link
operator|->
name|src_addr
operator|=
name|src_addr
expr_stmt|;
name|link
operator|->
name|dst_addr
operator|=
name|dst_addr
expr_stmt|;
name|link
operator|->
name|src_port
operator|=
name|src_port
expr_stmt|;
name|link
operator|->
name|alias_addr
operator|=
name|alias_addr
expr_stmt|;
name|link
operator|->
name|dst_port
operator|=
name|dst_port
expr_stmt|;
name|link
operator|->
name|link_type
operator|=
name|link_type
expr_stmt|;
name|link
operator|->
name|sockfd
operator|=
operator|-
literal|1
expr_stmt|;
name|link
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|timestamp
operator|=
name|timeStamp
expr_stmt|;
comment|/* Expiration time */
switch|switch
condition|(
name|link_type
condition|)
block|{
case|case
name|LINK_ICMP
case|:
name|link
operator|->
name|expire_time
operator|=
name|ICMP_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_UDP
case|:
name|link
operator|->
name|expire_time
operator|=
name|UDP_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_TCP
case|:
name|link
operator|->
name|expire_time
operator|=
name|TCP_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_ID
case|:
name|link
operator|->
name|expire_time
operator|=
name|FRAGMENT_ID_EXPIRE_TIME
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_PTR
case|:
name|link
operator|->
name|expire_time
operator|=
name|FRAGMENT_PTR_EXPIRE_TIME
expr_stmt|;
break|break;
block|}
comment|/* Determine alias flags */
if|if
condition|(
name|dst_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
name|link
operator|->
name|flags
operator||=
name|LINK_UNKNOWN_DEST_ADDR
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
literal|0
condition|)
name|link
operator|->
name|flags
operator||=
name|LINK_UNKNOWN_DEST_PORT
expr_stmt|;
comment|/* Determine alias port */
if|if
condition|(
name|GetNewPort
argument_list|(
name|link
argument_list|,
name|alias_port_param
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Set up pointers for output lookup table */
name|start_point
operator|=
name|StartPointOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|first_link
operator|=
name|linkTableOut
index|[
name|start_point
index|]
expr_stmt|;
name|link
operator|->
name|last_out
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|next_out
operator|=
name|first_link
expr_stmt|;
name|link
operator|->
name|start_point_out
operator|=
name|start_point
expr_stmt|;
if|if
condition|(
name|first_link
operator|!=
name|NULL
condition|)
name|first_link
operator|->
name|last_out
operator|=
name|link
expr_stmt|;
name|linkTableOut
index|[
name|start_point
index|]
operator|=
name|link
expr_stmt|;
comment|/* Set up pointers for input lookup table */
name|start_point
operator|=
name|StartPointIn
argument_list|(
name|alias_addr
argument_list|,
name|link
operator|->
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|first_link
operator|=
name|linkTableIn
index|[
name|start_point
index|]
expr_stmt|;
name|link
operator|->
name|last_in
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|next_in
operator|=
name|first_link
expr_stmt|;
name|link
operator|->
name|start_point_in
operator|=
name|start_point
expr_stmt|;
if|if
condition|(
name|first_link
operator|!=
name|NULL
condition|)
name|first_link
operator|->
name|last_in
operator|=
name|link
expr_stmt|;
name|linkTableIn
index|[
name|start_point
index|]
operator|=
name|link
expr_stmt|;
comment|/* Link-type dependent initialization */
switch|switch
condition|(
name|link_type
condition|)
block|{
name|struct
name|tcp_dat
modifier|*
name|aux_tcp
decl_stmt|;
case|case
name|LINK_ICMP
case|:
name|icmpLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_UDP
case|:
name|udpLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_TCP
case|:
name|aux_tcp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tcp_dat
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|data
operator|.
name|tcp
operator|=
name|aux_tcp
expr_stmt|;
if|if
condition|(
name|aux_tcp
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tcpLinkCount
operator|++
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|aux_tcp
operator|->
name|state
operator|.
name|ack_modified
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_LINK_TCP_DATA
condition|;
name|i
operator|++
control|)
name|aux_tcp
operator|->
name|ack
index|[
name|i
index|]
operator|.
name|active
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/AddLink: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" cannot allocate auxiliary TCP data\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LINK_FRAGMENT_ID
case|:
name|fragmentIdLinkCount
operator|++
expr_stmt|;
break|break;
case|case
name|LINK_FRAGMENT_PTR
case|:
name|fragmentPtrLinkCount
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/AddLink(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc() call failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|ShowAliasStats
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alias_link
modifier|*
name|FindLinkOut
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|int
name|link_type
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
name|src_addr
operator|.
name|s_addr
operator|==
name|aliasAddress
operator|.
name|s_addr
condition|)
name|src_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|StartPointOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|link
operator|=
name|linkTableOut
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
name|src_addr
operator|.
name|s_addr
operator|&&
name|link
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
operator|&&
name|link
operator|->
name|dst_port
operator|==
name|dst_port
operator|&&
name|link
operator|->
name|src_port
operator|==
name|src_port
operator|&&
name|link
operator|->
name|link_type
operator|==
name|link_type
condition|)
block|{
name|link
operator|->
name|timestamp
operator|=
name|timeStamp
expr_stmt|;
break|break;
block|}
name|link
operator|=
name|link
operator|->
name|next_out
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindLinkIn
parameter_list|(
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|int
name|link_type
parameter_list|,
name|int
name|replace_partial_links
parameter_list|)
block|{
name|int
name|flags_in
decl_stmt|;
name|u_int
name|start_point
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link_fully_specified
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link_unknown_all
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link_unknown_dst_addr
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link_unknown_dst_port
decl_stmt|;
comment|/* Initialize pointers */
name|link_fully_specified
operator|=
name|NULL
expr_stmt|;
name|link_unknown_all
operator|=
name|NULL
expr_stmt|;
name|link_unknown_dst_addr
operator|=
name|NULL
expr_stmt|;
name|link_unknown_dst_port
operator|=
name|NULL
expr_stmt|;
comment|/* If either the dest addr or port is unknown, the search    loop will have to know about this. */
name|flags_in
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dst_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
name|flags_in
operator||=
name|LINK_UNKNOWN_DEST_ADDR
expr_stmt|;
if|if
condition|(
name|dst_port
operator|==
literal|0
condition|)
name|flags_in
operator||=
name|LINK_UNKNOWN_DEST_PORT
expr_stmt|;
comment|/* The following allows permanent links to be    be specified as using the default aliasing address    (i.e. device interface address) without knowing    in advance what that address is. */
if|if
condition|(
name|alias_addr
operator|.
name|s_addr
operator|==
name|aliasAddress
operator|.
name|s_addr
condition|)
name|alias_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
comment|/* Search loop */
name|start_point
operator|=
name|StartPointIn
argument_list|(
name|alias_addr
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|link
operator|=
name|linkTableIn
index|[
name|start_point
index|]
expr_stmt|;
while|while
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|flags_in
operator||
name|link
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LINK_PARTIALLY_SPECIFIED
operator|)
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|link
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|link
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
operator|&&
name|link
operator|->
name|dst_port
operator|==
name|dst_port
operator|&&
name|link
operator|->
name|link_type
operator|==
name|link_type
condition|)
block|{
name|link_fully_specified
operator|=
name|link
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_ADDR
operator|)
operator|&&
operator|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_PORT
operator|)
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|link
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|link
operator|->
name|link_type
operator|==
name|link_type
condition|)
block|{
if|if
condition|(
name|link_unknown_all
operator|==
name|NULL
condition|)
name|link_unknown_all
operator|=
name|link
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_ADDR
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|link
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|link
operator|->
name|link_type
operator|==
name|link_type
operator|&&
name|link
operator|->
name|dst_port
operator|==
name|dst_port
condition|)
block|{
if|if
condition|(
name|link_unknown_dst_addr
operator|==
name|NULL
condition|)
name|link_unknown_dst_addr
operator|=
name|link
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|LINK_UNKNOWN_DEST_PORT
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
name|alias_addr
operator|.
name|s_addr
operator|&&
name|link
operator|->
name|alias_port
operator|==
name|alias_port
operator|&&
name|link
operator|->
name|link_type
operator|==
name|link_type
operator|&&
name|link
operator|->
name|dst_addr
operator|.
name|s_addr
operator|==
name|dst_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|link_unknown_dst_port
operator|==
name|NULL
condition|)
name|link_unknown_dst_port
operator|=
name|link
expr_stmt|;
block|}
block|}
name|link
operator|=
name|link
operator|->
name|next_in
expr_stmt|;
block|}
if|if
condition|(
name|link_fully_specified
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|link_fully_specified
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|link_unknown_dst_port
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|replace_partial_links
condition|)
block|{
name|link
operator|=
name|AddLink
argument_list|(
name|link_unknown_dst_port
operator|->
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|link_unknown_dst_port
operator|->
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|DeleteLink
argument_list|(
name|link_unknown_dst_port
argument_list|)
expr_stmt|;
return|return
operator|(
name|link
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|link_unknown_dst_port
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|link_unknown_dst_addr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|replace_partial_links
condition|)
block|{
name|link
operator|=
name|AddLink
argument_list|(
name|link_unknown_dst_addr
operator|->
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|link_unknown_dst_addr
operator|->
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|DeleteLink
argument_list|(
name|link_unknown_dst_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|link
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|link_unknown_dst_addr
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|link_unknown_all
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|replace_partial_links
condition|)
block|{
name|link
operator|=
name|AddLink
argument_list|(
name|link_unknown_all
operator|->
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|link_unknown_all
operator|->
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
name|DeleteLink
argument_list|(
name|link_unknown_all
argument_list|)
expr_stmt|;
return|return
operator|(
name|link
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|link_unknown_all
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* External routines for finding/adding links  -- "external" means outside alias_db.c, but within alias*.c --      FindIcmpIn(), FindIcmpOut()     FindFragmentIn1(), FindFragmentIn2()     AddFragmentPtrLink(), FindFragmentPtr()     FindUdpTcpIn(), FindUdpTcpOut()     FindOriginalAddress(), FindAliasAddress()  (prototypes in alias_local.h) */
end_comment

begin_function
name|struct
name|alias_link
modifier|*
name|FindIcmpIn
parameter_list|(
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|id_alias
parameter_list|)
block|{
return|return
name|FindLinkIn
argument_list|(
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|id_alias
argument_list|,
name|LINK_ICMP
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindIcmpOut
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|id
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|link
operator|=
name|FindLinkOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|id
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|LINK_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|alias_addr
operator|=
name|FindAliasAddress
argument_list|(
name|src_addr
argument_list|)
expr_stmt|;
name|link
operator|=
name|AddLink
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|id
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|GET_ALIAS_ID
argument_list|,
name|LINK_ICMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindFragmentIn1
parameter_list|(
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|ip_id
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|link
operator|=
name|FindLinkIn
argument_list|(
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_ID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|link
operator|=
name|AddLink
argument_list|(
name|nullAddress
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_ID
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindFragmentIn2
parameter_list|(
name|struct
name|in_addr
name|dst_addr
parameter_list|,
comment|/* Doesn't add a link if one */
name|struct
name|in_addr
name|alias_addr
parameter_list|,
comment|/*   is not found.           */
name|u_short
name|ip_id
parameter_list|)
block|{
return|return
name|FindLinkIn
argument_list|(
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_ID
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|AddFragmentPtrLink
parameter_list|(
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|ip_id
parameter_list|)
block|{
return|return
name|AddLink
argument_list|(
name|nullAddress
argument_list|,
name|dst_addr
argument_list|,
name|nullAddress
argument_list|,
name|NO_SRC_PORT
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_PTR
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindFragmentPtr
parameter_list|(
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|ip_id
parameter_list|)
block|{
return|return
name|FindLinkIn
argument_list|(
name|dst_addr
argument_list|,
name|nullAddress
argument_list|,
name|NO_DEST_PORT
argument_list|,
name|ip_id
argument_list|,
name|LINK_FRAGMENT_PTR
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindUdpTcpIn
parameter_list|(
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|int
name|link_type
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
break|break;
block|}
name|link
operator|=
name|FindLinkIn
argument_list|(
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|packetAliasMode
operator|&
name|PKT_ALIAS_DENY_INCOMING
operator|)
operator|&&
name|link
operator|==
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|target_addr
decl_stmt|;
name|target_addr
operator|=
name|FindOriginalAddress
argument_list|(
name|alias_addr
argument_list|)
expr_stmt|;
name|link
operator|=
name|AddLink
argument_list|(
name|target_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|alias_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|alias_link
modifier|*
name|FindUdpTcpOut
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|int
name|link_type
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
break|break;
block|}
name|link
operator|=
name|FindLinkOut
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|alias_addr
decl_stmt|;
name|alias_addr
operator|=
name|FindAliasAddress
argument_list|(
name|src_addr
argument_list|)
expr_stmt|;
name|link
operator|=
name|AddLink
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|GET_ALIAS_PORT
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|link
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|FindOriginalAddress
parameter_list|(
name|struct
name|in_addr
name|alias_addr
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|link
operator|=
name|FindLinkIn
argument_list|(
name|nullAddress
argument_list|,
name|alias_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|newDefaultLink
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|targetAddress
operator|.
name|s_addr
operator|!=
literal|0
condition|)
return|return
name|targetAddress
return|;
else|else
return|return
name|alias_addr
return|;
block|}
else|else
block|{
if|if
condition|(
name|link
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
name|aliasAddress
return|;
else|else
return|return
name|link
operator|->
name|src_addr
return|;
block|}
block|}
end_function

begin_function
name|struct
name|in_addr
name|FindAliasAddress
parameter_list|(
name|struct
name|in_addr
name|original_addr
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|link
operator|=
name|FindLinkOut
argument_list|(
name|original_addr
argument_list|,
name|nullAddress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
return|return
name|aliasAddress
return|;
block|}
else|else
block|{
if|if
condition|(
name|link
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
name|aliasAddress
return|;
else|else
return|return
name|link
operator|->
name|alias_addr
return|;
block|}
block|}
end_function

begin_comment
comment|/* External routines for getting or changing link data    (external to alias_db.c, but internal to alias*.c)      SetFragmentData(), GetFragmentData()     SetFragmentPtr(), GetFragmentPtr()     SetStateIn(), SetStateOut(), GetStateIn(), GetStateOut()     GetOriginalAddress(), GetDestAddress(), GetAliasAddress()     GetOriginalPort(), GetAliasPort()     SetAckModified(), GetAckModified()     GetDeltaAckIn(), GetDeltaSeqOut(), AddSeq() */
end_comment

begin_function
name|void
name|SetFragmentAddr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|struct
name|in_addr
name|src_addr
parameter_list|)
block|{
name|link
operator|->
name|data
operator|.
name|frag_addr
operator|=
name|src_addr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GetFragmentAddr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|struct
name|in_addr
modifier|*
name|src_addr
parameter_list|)
block|{
operator|*
name|src_addr
operator|=
name|link
operator|->
name|data
operator|.
name|frag_addr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetFragmentPtr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|char
modifier|*
name|fptr
parameter_list|)
block|{
name|link
operator|->
name|data
operator|.
name|frag_ptr
operator|=
name|fptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GetFragmentPtr
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|char
modifier|*
modifier|*
name|fptr
parameter_list|)
block|{
operator|*
name|fptr
operator|=
name|link
operator|->
name|data
operator|.
name|frag_ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetStateIn
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|int
name|state
parameter_list|)
block|{
comment|/* TCP input state */
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|in
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetStateOut
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|int
name|state
parameter_list|)
block|{
comment|/* TCP output state */
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|out
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|int
name|GetStateIn
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
comment|/* TCP input state */
return|return
operator|(
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|in
operator|)
return|;
block|}
end_function

begin_function
name|int
name|GetStateOut
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
comment|/* TCP output state */
return|return
operator|(
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|out
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetOriginalAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
if|if
condition|(
name|link
operator|->
name|src_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
name|aliasAddress
return|;
else|else
return|return
operator|(
name|link
operator|->
name|src_addr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetDestAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
return|return
operator|(
name|link
operator|->
name|dst_addr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetAliasAddress
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
if|if
condition|(
name|link
operator|->
name|alias_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
name|aliasAddress
return|;
else|else
return|return
name|link
operator|->
name|alias_addr
return|;
block|}
end_function

begin_function
name|struct
name|in_addr
name|GetDefaultAliasAddress
parameter_list|()
block|{
return|return
name|aliasAddress
return|;
block|}
end_function

begin_function
name|void
name|SetDefaultAliasAddress
parameter_list|(
name|struct
name|in_addr
name|alias_addr
parameter_list|)
block|{
name|aliasAddress
operator|=
name|alias_addr
expr_stmt|;
block|}
end_function

begin_function
name|u_short
name|GetOriginalPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
return|return
operator|(
name|link
operator|->
name|src_port
operator|)
return|;
block|}
end_function

begin_function
name|u_short
name|GetAliasPort
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
return|return
operator|(
name|link
operator|->
name|alias_port
operator|)
return|;
block|}
end_function

begin_function
name|void
name|SetAckModified
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
comment|/* Indicate that ack numbers have been modified in a TCP connection */
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|ack_modified
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|GetAckModified
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
comment|/* See if ack numbers have been modified */
return|return
operator|(
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|ack_modified
operator|)
return|;
block|}
end_function

begin_function
name|int
name|GetDeltaAckIn
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
comment|/* Find out how much the ack number has been altered for an incoming TCP packet.  To do this, a circular list is ack numbers where the TCP packet size was altered is searched.  */
name|int
name|i
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|ack_diff_min
decl_stmt|;
name|u_long
name|ack
decl_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pip
operator|+
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|ack
operator|=
name|tc
operator|->
name|th_ack
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
name|ack_diff_min
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_LINK_TCP_DATA
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ack_data_record
name|x
decl_stmt|;
name|x
operator|=
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|ack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|active
operator|==
literal|1
condition|)
block|{
name|int
name|ack_diff
decl_stmt|;
name|ack_diff
operator|=
name|SeqDiff
argument_list|(
name|x
operator|.
name|ack_new
argument_list|,
name|ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_diff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ack_diff_min
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ack_diff
operator|<
name|ack_diff_min
condition|)
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|ack_diff_min
operator|=
name|ack_diff
expr_stmt|;
block|}
block|}
else|else
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|ack_diff_min
operator|=
name|ack_diff
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_function
name|int
name|GetDeltaSeqOut
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
comment|/* Find out how much the seq number has been altered for an outgoing TCP packet.  To do this, a circular list is ack numbers where the TCP packet size was altered is searched.  */
name|int
name|i
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|seq_diff_min
decl_stmt|;
name|u_long
name|seq
decl_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pip
operator|+
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|seq
operator|=
name|tc
operator|->
name|th_seq
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
name|seq_diff_min
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_LINK_TCP_DATA
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ack_data_record
name|x
decl_stmt|;
name|x
operator|=
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|ack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|active
operator|==
literal|1
condition|)
block|{
name|int
name|seq_diff
decl_stmt|;
name|seq_diff
operator|=
name|SeqDiff
argument_list|(
name|x
operator|.
name|ack_old
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_diff
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|seq_diff_min
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|seq_diff
operator|<
name|seq_diff_min
condition|)
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|seq_diff_min
operator|=
name|seq_diff
expr_stmt|;
block|}
block|}
else|else
block|{
name|delta
operator|=
name|x
operator|.
name|delta
expr_stmt|;
name|seq_diff_min
operator|=
name|seq_diff
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_function
name|void
name|AddSeq
parameter_list|(
name|struct
name|ip
modifier|*
name|pip
parameter_list|,
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|int
name|delta
parameter_list|)
block|{
comment|/* When a TCP packet has been altered in length, save this information in a circular list.  If enough packets have been altered, then this list will begin to overwrite itself. */
name|struct
name|tcphdr
modifier|*
name|tc
decl_stmt|;
name|struct
name|ack_data_record
name|x
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|tlen
decl_stmt|,
name|dlen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tc
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pip
operator|+
operator|(
name|pip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|hlen
operator|=
operator|(
name|pip
operator|->
name|ip_hl
operator|+
name|tc
operator|->
name|th_off
operator|)
operator|<<
literal|2
expr_stmt|;
name|tlen
operator|=
name|ntohs
argument_list|(
name|pip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|dlen
operator|=
name|tlen
operator|-
name|hlen
expr_stmt|;
name|x
operator|.
name|ack_old
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|tc
operator|->
name|th_seq
argument_list|)
operator|+
name|dlen
argument_list|)
expr_stmt|;
name|x
operator|.
name|ack_new
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|tc
operator|->
name|th_seq
argument_list|)
operator|+
name|dlen
operator|+
name|delta
argument_list|)
expr_stmt|;
name|x
operator|.
name|delta
operator|=
name|delta
expr_stmt|;
name|x
operator|.
name|active
operator|=
literal|1
expr_stmt|;
name|i
operator|=
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|index
expr_stmt|;
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|ack
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|N_LINK_TCP_DATA
condition|)
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|index
operator|=
literal|0
expr_stmt|;
else|else
operator|(
name|link
operator|->
name|data
operator|.
name|tcp
operator|)
operator|->
name|state
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetExpire
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|,
name|int
name|expire
parameter_list|)
block|{
if|if
condition|(
name|expire
operator|==
literal|0
condition|)
block|{
name|link
operator|->
name|flags
operator|&=
operator|~
name|LINK_PERMANENT
expr_stmt|;
name|DeleteLink
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expire
operator|==
operator|-
literal|1
condition|)
block|{
name|link
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expire
operator|>
literal|0
condition|)
block|{
name|link
operator|->
name|expire_time
operator|=
name|expire
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/SetExpire(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error in expire parameter\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ClearCheckNewLink
parameter_list|(
name|void
parameter_list|)
block|{
name|newDefaultLink
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Miscellaneous Functions      HouseKeeping()     InitPacketAliasLog()     UninitPacketAliasLog() */
end_comment

begin_comment
comment|/*     Whenever an outgoing or incoming packet is handled, HouseKeeping()     is called to find and remove timed-out aliasing links.  Logic exists     to sweep through the entire table and linked list structure     every 60 seconds.      (prototype in alias_local.h) */
end_comment

begin_function
name|void
name|HouseKeeping
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|n100
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
comment|/*      * Save system time (seconds) in global variable timeStamp for      * use by other functions. This is done so as not to unnecessarily      * waste timeline by making system calls.      */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|timeStamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
comment|/* Compute number of spokes (output table link chains) to cover */
name|n100
operator|=
name|LINK_TABLE_OUT_SIZE
operator|*
literal|100
operator|+
name|houseKeepingResidual
expr_stmt|;
name|n100
operator|*=
name|timeStamp
operator|-
name|lastCleanupTime
expr_stmt|;
name|n100
operator|/=
name|ALIAS_CLEANUP_INTERVAL_SECS
expr_stmt|;
name|n
operator|=
name|n100
operator|/
literal|100
expr_stmt|;
comment|/* Handle different cases */
if|if
condition|(
name|n
operator|>
name|ALIAS_CLEANUP_MAX_SPOKES
condition|)
block|{
name|n
operator|=
name|ALIAS_CLEANUP_MAX_SPOKES
expr_stmt|;
name|lastCleanupTime
operator|=
name|timeStamp
expr_stmt|;
name|houseKeepingResidual
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|IncrementalCleanup
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|lastCleanupTime
operator|=
name|timeStamp
expr_stmt|;
name|houseKeepingResidual
operator|=
name|n100
operator|-
literal|100
operator|*
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|IncrementalCleanup
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAlias/HouseKeeping(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"something unexpected in time values\n"
argument_list|)
expr_stmt|;
name|lastCleanupTime
operator|=
name|timeStamp
expr_stmt|;
name|houseKeepingResidual
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Init the log file and enable logging */
end_comment

begin_function
name|void
name|InitPacketAliasLog
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|~
name|packetAliasMode
operator|&
name|PKT_ALIAS_LOG
operator|)
operator|&&
operator|(
name|monitorFile
operator|=
name|fopen
argument_list|(
literal|"/var/log/alias.log"
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|packetAliasMode
operator||=
name|PKT_ALIAS_LOG
expr_stmt|;
name|fprintf
argument_list|(
name|monitorFile
argument_list|,
literal|"PacketAlias/InitPacketAliasLog: Packet alias logging enabled.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Close the log-file and disable logging. */
end_comment

begin_function
name|void
name|UninitPacketAliasLog
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|monitorFile
condition|)
name|fclose
argument_list|(
name|monitorFile
argument_list|)
expr_stmt|;
name|packetAliasMode
operator|&=
operator|~
name|PKT_ALIAS_LOG
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Outside world interfaces  -- "outside world" means other than alias*.c routines --      PacketAliasRedirectPort()     PacketAliasRedirectAddr()     PacketAliasRedirectDelete()     PacketAliasSetAddress()     PacketAliasInit()     PacketAliasSetMode()  (prototypes in alias.h) */
end_comment

begin_comment
comment|/* Redirection from a specific public addr:port to a    a private addr:port */
end_comment

begin_function
name|struct
name|alias_link
modifier|*
name|PacketAliasRedirectPort
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|u_short
name|src_port
parameter_list|,
name|struct
name|in_addr
name|dst_addr
parameter_list|,
name|u_short
name|dst_port
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|,
name|u_short
name|alias_port
parameter_list|,
name|u_char
name|proto
parameter_list|)
block|{
name|int
name|link_type
decl_stmt|;
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|link_type
operator|=
name|LINK_UDP
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|link_type
operator|=
name|LINK_TCP
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAliasRedirectPort(): "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"only TCP and UDP protocols allowed\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|link
operator|=
name|AddLink
argument_list|(
name|src_addr
argument_list|,
name|dst_addr
argument_list|,
name|alias_addr
argument_list|,
name|src_port
argument_list|,
name|dst_port
argument_list|,
name|alias_port
argument_list|,
name|link_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
name|link
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAliasRedirectPort(): "
literal|"call to AddLink() failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|link
return|;
block|}
end_function

begin_comment
comment|/* Static address translation */
end_comment

begin_function
name|struct
name|alias_link
modifier|*
name|PacketAliasRedirectAddr
parameter_list|(
name|struct
name|in_addr
name|src_addr
parameter_list|,
name|struct
name|in_addr
name|alias_addr
parameter_list|)
block|{
name|struct
name|alias_link
modifier|*
name|link
decl_stmt|;
name|link
operator|=
name|AddLink
argument_list|(
name|src_addr
argument_list|,
name|nullAddress
argument_list|,
name|alias_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|LINK_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
name|link
operator|->
name|flags
operator||=
name|LINK_PERMANENT
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PacketAliasRedirectAddr(): "
literal|"call to AddLink() failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|link
return|;
block|}
end_function

begin_function
name|void
name|PacketAliasRedirectDelete
parameter_list|(
name|struct
name|alias_link
modifier|*
name|link
parameter_list|)
block|{
comment|/* This is a dangerous function to put in the API,    because an invalid pointer can crash the program. */
name|deleteAllLinks
operator|=
literal|1
expr_stmt|;
name|DeleteLink
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|deleteAllLinks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PacketAliasSetAddress
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
if|if
condition|(
name|packetAliasMode
operator|&
name|PKT_ALIAS_RESET_ON_ADDR_CHANGE
operator|&&
name|aliasAddress
operator|.
name|s_addr
operator|!=
name|addr
operator|.
name|s_addr
condition|)
name|CleanupAliasData
argument_list|()
expr_stmt|;
name|aliasAddress
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PacketAliasSetTarget
parameter_list|(
name|struct
name|in_addr
name|target_addr
parameter_list|)
block|{
name|targetAddress
operator|=
name|target_addr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PacketAliasInit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
if|if
condition|(
name|firstCall
operator|==
literal|1
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|timeStamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|lastCleanupTime
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|houseKeepingResidual
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINK_TABLE_OUT_SIZE
condition|;
name|i
operator|++
control|)
name|linkTableOut
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINK_TABLE_IN_SIZE
condition|;
name|i
operator|++
control|)
name|linkTableIn
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|firstCall
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|deleteAllLinks
operator|=
literal|1
expr_stmt|;
name|CleanupAliasData
argument_list|()
expr_stmt|;
name|deleteAllLinks
operator|=
literal|0
expr_stmt|;
block|}
name|aliasAddress
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|targetAddress
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|icmpLinkCount
operator|=
literal|0
expr_stmt|;
name|udpLinkCount
operator|=
literal|0
expr_stmt|;
name|tcpLinkCount
operator|=
literal|0
expr_stmt|;
name|fragmentIdLinkCount
operator|=
literal|0
expr_stmt|;
name|fragmentPtrLinkCount
operator|=
literal|0
expr_stmt|;
name|sockCount
operator|=
literal|0
expr_stmt|;
name|cleanupIndex
operator|=
literal|0
expr_stmt|;
name|packetAliasMode
operator|=
name|PKT_ALIAS_SAME_PORTS
operator||
name|PKT_ALIAS_USE_SOCKETS
operator||
name|PKT_ALIAS_RESET_ON_ADDR_CHANGE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change mode for some operations */
end_comment

begin_function
name|unsigned
name|int
name|PacketAliasSetMode
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|,
comment|/* Which state to bring flags to */
name|unsigned
name|int
name|mask
comment|/* Mask of which flags to affect (use 0 to do a                            probe for flag values) */
parameter_list|)
block|{
comment|/* Enable logging? */
if|if
condition|(
name|flags
operator|&
name|mask
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|InitPacketAliasLog
argument_list|()
expr_stmt|;
comment|/* Do the enable */
block|}
comment|/* _Disable_ logging? */
if|if
condition|(
operator|~
name|flags
operator|&
name|mask
operator|&
name|PKT_ALIAS_LOG
condition|)
block|{
name|UninitPacketAliasLog
argument_list|()
expr_stmt|;
block|}
comment|/* Other flags can be set/cleared without special action */
name|packetAliasMode
operator|=
operator|(
name|flags
operator|&
name|mask
operator|)
operator||
operator|(
name|packetAliasMode
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
return|return
name|packetAliasMode
return|;
block|}
end_function

begin_function
name|int
name|PacketAliasCheckNewLink
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|newDefaultLink
return|;
block|}
end_function

end_unit

