begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2014 Devin Teske<dteske@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"figpar.h"
end_include

begin_include
include|#
directive|include
file|"string_m.h"
end_include

begin_decl_stmt
name|struct
name|fp_config
name|fp_dummy_config
init|=
block|{
literal|0
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Search for config option (struct fp_config) in the array of config options,  * returning the struct whose directive matches the given parameter. If no  * match is found, a pointer to the static dummy array (above) is returned.  *  * This is to eliminate dependency on the index position of an item in the  * array, since the index position is more apt to be changed as code grows.  */
end_comment

begin_function
name|struct
name|fp_config
modifier|*
name|get_config_option
parameter_list|(
name|struct
name|fp_config
name|options
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|directive
parameter_list|)
block|{
name|uint32_t
name|n
decl_stmt|;
comment|/* Check arguments */
if|if
condition|(
name|options
operator|==
name|NULL
operator|||
name|directive
operator|==
name|NULL
condition|)
return|return
operator|(
operator|&
name|fp_dummy_config
operator|)
return|;
comment|/* Loop through the array, return the index of the first match */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|options
index|[
name|n
index|]
operator|.
name|directive
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|options
index|[
name|n
index|]
operator|.
name|directive
argument_list|,
name|directive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
operator|(
name|options
index|[
name|n
index|]
operator|)
operator|)
return|;
comment|/* Re-initialize the dummy variable in case it was written to */
name|fp_dummy_config
operator|.
name|directive
operator|=
name|NULL
expr_stmt|;
name|fp_dummy_config
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|fp_dummy_config
operator|.
name|action
operator|=
name|NULL
expr_stmt|;
name|fp_dummy_config
operator|.
name|value
operator|.
name|u_num
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|fp_dummy_config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the configuration file at `path' and execute the `action' call-back  * functions for any directives defined by the array of config options (first  * argument).  *  * For unknown directives that are encountered, you can optionally pass a  * call-back function for the third argument to be called for unknowns.  *  * Returns zero on success; otherwise returns -1 and errno should be consulted. */
end_comment

begin_function
name|int
name|parse_config
parameter_list|(
name|struct
name|fp_config
name|options
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
function_decl|(
modifier|*
name|unknown
function_decl|)
parameter_list|(
name|struct
name|fp_config
modifier|*
name|option
parameter_list|,
name|uint32_t
name|line
parameter_list|,
name|char
modifier|*
name|directive
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
parameter_list|,
name|uint16_t
name|processing_options
parameter_list|)
block|{
name|uint8_t
name|bequals
decl_stmt|;
name|uint8_t
name|bsemicolon
decl_stmt|;
name|uint8_t
name|case_sensitive
decl_stmt|;
name|uint8_t
name|comment
init|=
literal|0
decl_stmt|;
name|uint8_t
name|end
decl_stmt|;
name|uint8_t
name|found
decl_stmt|;
name|uint8_t
name|have_equals
init|=
literal|0
decl_stmt|;
name|uint8_t
name|quote
decl_stmt|;
name|uint8_t
name|require_equals
decl_stmt|;
name|uint8_t
name|strict_equals
decl_stmt|;
name|char
name|p
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|directive
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|ssize_t
name|r
init|=
literal|1
decl_stmt|;
name|uint32_t
name|dsize
decl_stmt|;
name|uint32_t
name|line
init|=
literal|1
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|uint32_t
name|vsize
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|off_t
name|charpos
decl_stmt|;
name|off_t
name|curpos
decl_stmt|;
name|char
name|rpath
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* Sanity check: if no options and no unknown function, return */
if|if
condition|(
name|options
operator|==
name|NULL
operator|&&
name|unknown
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Processing options */
name|bequals
operator|=
operator|(
name|processing_options
operator|&
name|FP_BREAK_ON_EQUALS
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|bsemicolon
operator|=
operator|(
name|processing_options
operator|&
name|FP_BREAK_ON_SEMICOLON
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|case_sensitive
operator|=
operator|(
name|processing_options
operator|&
name|FP_CASE_SENSITIVE
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|require_equals
operator|=
operator|(
name|processing_options
operator|&
name|FP_REQUIRE_EQUALS
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|strict_equals
operator|=
operator|(
name|processing_options
operator|&
name|FP_STRICT_EQUALS
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* Initialize strings */
name|directive
operator|=
name|value
operator|=
literal|0
expr_stmt|;
name|vsize
operator|=
name|dsize
operator|=
literal|0
expr_stmt|;
comment|/* Resolve the file path */
if|if
condition|(
name|realpath
argument_list|(
name|path
argument_list|,
name|rpath
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Open the file */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|rpath
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Read the file until EOF */
while|while
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* skip to the beginning of a directive */
while|while
condition|(
name|r
operator|!=
literal|0
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'#'
operator|||
name|comment
operator|||
operator|(
name|bsemicolon
operator|&&
operator|*
name|p
operator|==
literal|';'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
name|comment
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|comment
operator|=
literal|0
expr_stmt|;
name|line
operator|++
expr_stmt|;
block|}
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Test for EOF; if EOF then no directive was found */
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Get the current offset */
name|curpos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|curpos
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Find the length of the directive */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|r
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|bequals
operator|&&
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|have_equals
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bsemicolon
operator|&&
operator|*
name|p
operator|==
literal|';'
condition|)
break|break;
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Test for EOF, if EOF then no directive was found */
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|r
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Go back to the beginning of the directive */
name|error
operator|=
operator|(
name|int
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|curpos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|(
name|curpos
operator|-
literal|1
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Allocate and read the directive into memory */
if|if
condition|(
name|n
operator|>
name|dsize
condition|)
block|{
if|if
condition|(
operator|(
name|directive
operator|=
name|realloc
argument_list|(
name|directive
argument_list|,
name|n
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dsize
operator|=
name|n
expr_stmt|;
block|}
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|directive
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Advance beyond the equals sign if appropriate/desired */
if|if
condition|(
name|bequals
operator|&&
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_equals
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/* Terminate the string */
name|directive
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Convert directive to lower case before comparison */
if|if
condition|(
operator|!
name|case_sensitive
condition|)
name|strtolower
argument_list|(
name|directive
argument_list|)
expr_stmt|;
comment|/* Move to what may be the start of the value */
if|if
condition|(
operator|!
operator|(
name|bsemicolon
operator|&&
operator|*
name|p
operator|==
literal|';'
operator|)
operator|&&
operator|!
operator|(
name|strict_equals
operator|&&
operator|*
name|p
operator|==
literal|'='
operator|)
condition|)
block|{
while|while
condition|(
name|r
operator|!=
literal|0
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* An equals sign may have stopped us, should we eat it? */
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|bequals
operator|&&
operator|*
name|p
operator|==
literal|'='
operator|&&
operator|!
name|strict_equals
condition|)
block|{
name|have_equals
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If no value, allocate a dummy value and jump to action */
if|if
condition|(
name|r
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'#'
operator|||
operator|(
name|bsemicolon
operator|&&
operator|*
name|p
operator|==
literal|';'
operator|)
condition|)
block|{
comment|/* Initialize the value if not already done */
if|if
condition|(
name|value
operator|==
name|NULL
operator|&&
operator|(
name|value
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|call_function
goto|;
block|}
comment|/* Get the current offset */
name|curpos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|curpos
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Find the end of the value */
name|quote
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|r
operator|!=
literal|0
operator|&&
name|end
operator|==
literal|0
condition|)
block|{
comment|/* Advance to the next character if we know we can */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\"'
operator|&&
operator|*
name|p
operator|!=
literal|'#'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|(
operator|!
name|bsemicolon
operator|||
operator|*
name|p
operator|!=
literal|';'
operator|)
condition|)
block|{
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we get this far, we've hit an end-key 			 */
comment|/* Get the current offset */
name|charpos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|charpos
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * Go back so we can read the character before the key 			 * to check if the character is escaped (which means we 			 * should continue). 			 */
name|error
operator|=
operator|(
name|int
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
literal|2
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|3
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Count how many backslashes there are (an odd number 			 * means the key is escaped, even means otherwise). 			 */
for|for
control|(
name|n
operator|=
literal|1
init|;
operator|*
name|p
operator|==
literal|'\\'
condition|;
name|n
operator|++
control|)
block|{
comment|/* Move back another offset to read */
name|error
operator|=
operator|(
name|int
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|-
literal|2
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|3
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Move offset back to the key and read it */
name|error
operator|=
operator|(
name|int
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|charpos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|(
name|charpos
operator|-
literal|1
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * If an even number of backslashes was counted meaning 			 * key is not escaped, we should evaluate what to do. 			 */
if|if
condition|(
operator|(
name|n
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\"'
case|:
comment|/* 				 	 * Flag current sequence of characters 					 * to follow as being quoted (hashes 					 * are not considered comments). 					 */
name|quote
operator|=
operator|!
name|quote
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* 					 * If we aren't in a quoted series, we 					 * just hit an inline comment and have 					 * found the end of the value. 					 */
if|if
condition|(
operator|!
name|quote
condition|)
name|end
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* 					 * Newline characters must always be 					 * escaped, whether inside a quoted 					 * series or not, otherwise they 					 * terminate the value. 					 */
name|end
operator|=
literal|1
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
operator|!
name|quote
operator|&&
name|bsemicolon
condition|)
name|end
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
comment|/* Escaped newline character. increment */
name|line
operator|++
expr_stmt|;
comment|/* Advance to the next character */
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the current offset */
name|charpos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|charpos
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Get the length of the value */
name|n
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|charpos
operator|-
name|curpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
comment|/* more to read, but don't read ending key */
name|n
operator|--
expr_stmt|;
comment|/* Move offset back to the beginning of the value */
name|error
operator|=
operator|(
name|int
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|curpos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|(
name|curpos
operator|-
literal|1
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Allocate and read the value into memory */
if|if
condition|(
name|n
operator|>
name|vsize
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|=
name|realloc
argument_list|(
name|value
argument_list|,
name|n
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|vsize
operator|=
name|n
expr_stmt|;
block|}
name|r
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|value
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Terminate the string */
name|value
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Cut trailing whitespace off by termination */
name|t
operator|=
name|value
operator|+
name|n
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|--
name|t
argument_list|)
condition|)
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
comment|/* Escape the escaped quotes (replaceall is in string_m.c) */
name|x
operator|=
name|strcount
argument_list|(
name|value
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
comment|/* in string_m.c */
if|if
condition|(
name|x
operator|!=
literal|0
operator|&&
operator|(
name|n
operator|+
name|x
operator|)
operator|>
name|vsize
condition|)
block|{
if|if
condition|(
operator|(
name|value
operator|=
name|realloc
argument_list|(
name|value
argument_list|,
name|n
operator|+
name|x
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|vsize
operator|=
name|n
operator|+
name|x
expr_stmt|;
block|}
if|if
condition|(
name|replaceall
argument_list|(
name|value
argument_list|,
literal|"\\\""
argument_list|,
literal|"\\\\\""
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Replace operation failed for some unknown reason */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Remove all new line characters */
if|if
condition|(
name|replaceall
argument_list|(
name|value
argument_list|,
literal|"\\\n"
argument_list|,
literal|""
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Replace operation failed for some unknown reason */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Resolve escape sequences */
name|strexpand
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* in string_m.c */
name|call_function
label|:
comment|/* Abort if we're seeking only assignments */
if|if
condition|(
name|require_equals
operator|&&
operator|!
name|have_equals
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|found
operator|=
name|have_equals
operator|=
literal|0
expr_stmt|;
comment|/* reset */
comment|/* If there are no options defined, call unknown and loop */
if|if
condition|(
name|options
operator|==
name|NULL
operator|&&
name|unknown
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|unknown
argument_list|(
name|NULL
argument_list|,
name|line
argument_list|,
name|directive
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
continue|continue;
block|}
comment|/* Loop through the array looking for a match for the value */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|options
index|[
name|n
index|]
operator|.
name|directive
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
block|{
name|error
operator|=
name|fnmatch
argument_list|(
name|options
index|[
name|n
index|]
operator|.
name|directive
argument_list|,
name|directive
argument_list|,
name|FNM_NOESCAPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
comment|/* Call function for array index item */
if|if
condition|(
name|options
index|[
name|n
index|]
operator|.
name|action
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|options
index|[
name|n
index|]
operator|.
name|action
argument_list|(
operator|&
name|options
index|[
name|n
index|]
argument_list|,
name|line
argument_list|,
name|directive
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
name|FNM_NOMATCH
condition|)
block|{
comment|/* An error has occurred */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|found
operator|&&
name|unknown
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * No match was found for the value we read from the 			 * file; call function designated for unknown values. 			 */
name|error
operator|=
name|unknown
argument_list|(
name|NULL
argument_list|,
name|line
argument_list|,
name|directive
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

