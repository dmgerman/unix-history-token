begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2014 Devin Teske<dteske@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"string_m.h"
end_include

begin_comment
comment|/*  * Counts the number of occurrences of one string that appear in the source  * string. Return value is the total count.  *  * An example use would be if you need to know how large a block of memory  * needs to be for a replaceall() series.  */
end_comment

begin_function
name|unsigned
name|int
name|strcount
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|find
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|source
decl_stmt|;
name|size_t
name|flen
decl_stmt|;
name|unsigned
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Both parameters are required */
if|if
condition|(
name|source
operator|==
name|NULL
operator|||
name|find
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Cache the length of find element */
name|flen
operator|=
name|strlen
argument_list|(
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|source
argument_list|)
operator|==
literal|0
operator|||
name|flen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Loop until the end of the string */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|find
argument_list|,
name|flen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found an instance */
name|p
operator|+=
name|flen
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replaces all occurrences of `find' in `source' with `replace'.  *  * You should not pass a string constant as the first parameter, it needs to be  * a pointer to an allocated block of memory. The block of memory that source  * points to should be large enough to hold the result. If the length of the  * replacement string is greater than the length of the find string, the result  * will be larger than the original source string. To allocate enough space for  * the result, use the function strcount() declared above to determine the  * number of occurrences and how much larger the block size needs to be.  *  * If source is not large enough, the application will crash. The return value  * is the length (in bytes) of the result.  *  * When an error occurs, -1 is returned and the global variable errno is set  * accordingly. Returns zero on success.  */
end_comment

begin_function
name|int
name|replaceall
parameter_list|(
name|char
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|find
parameter_list|,
specifier|const
name|char
modifier|*
name|replace
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|size_t
name|flen
decl_stmt|;
name|size_t
name|rlen
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
name|uint32_t
name|n
init|=
literal|0
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* reset global error number */
comment|/* Check that we have non-null parameters */
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|find
operator|==
name|NULL
condition|)
return|return
operator|(
name|strlen
argument_list|(
name|source
argument_list|)
operator|)
return|;
comment|/* Cache the length of the strings */
name|slen
operator|=
name|strlen
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|flen
operator|=
name|strlen
argument_list|(
name|find
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|replace
condition|?
name|strlen
argument_list|(
name|replace
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* Cases where no replacements need to be made */
if|if
condition|(
name|slen
operator|==
literal|0
operator|||
name|flen
operator|==
literal|0
operator|||
name|slen
operator|<
name|flen
condition|)
return|return
operator|(
name|slen
operator|)
return|;
comment|/* If replace is longer than find, we'll need to create a temp copy */
if|if
condition|(
name|rlen
operator|>
name|flen
condition|)
block|{
name|temp
operator|=
name|malloc
argument_list|(
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
comment|/* could not allocate memory */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|source
expr_stmt|;
comment|/* Reconstruct the string with the replacements */
name|p
operator|=
name|source
expr_stmt|;
name|t
operator|=
name|temp
expr_stmt|;
comment|/* position elements */
while|while
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|t
argument_list|,
name|find
argument_list|,
name|flen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found an occurrence */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|replace
operator|&&
name|replace
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|replace
index|[
name|n
index|]
expr_stmt|;
name|t
operator|+=
name|flen
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
comment|/* copy character and increment */
block|}
comment|/* Terminate the string */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Free the temporary allocated memory */
if|if
condition|(
name|temp
operator|!=
name|source
condition|)
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Return the length of the completed string */
return|return
operator|(
name|strlen
argument_list|(
name|source
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expands escape sequences in a buffer pointed to by `source'. This function  * steps through each character, and converts escape sequences such as "\n",  * "\r", "\t" and others into their respective meanings.  *  * You should not pass a string constant or literal to this function or the  * program will likely segmentation fault when it tries to modify the data.  *  * The string length will either shorten or stay the same depending on whether  * any escape sequences were converted but the amount of memory allocated does  * not change.  *  * Interpreted sequences are:  *  * 	\0NNN	character with octal value NNN (0 to 3 digits)  * 	\N	character with octal value N (0 thru 7)  * 	\a	alert (BEL)  * 	\b	backslash  * 	\f	form feed  * 	\n	new line  * 	\r	carriage return  * 	\t	horizontal tab  * 	\v	vertical tab  * 	\xNN	byte with hexadecimal value NN (1 to 2 digits)  *  * All other sequences are unescaped (ie. '\"' and '\#').  */
end_comment

begin_function
name|void
name|strexpand
parameter_list|(
name|char
modifier|*
name|source
parameter_list|)
block|{
name|uint8_t
name|c
decl_stmt|;
name|char
modifier|*
name|chr
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|char
name|d
index|[
literal|4
index|]
decl_stmt|;
comment|/* Initialize position elements */
name|pos
operator|=
name|chr
operator|=
name|source
expr_stmt|;
comment|/* Loop until we hit the end of the string */
while|while
condition|(
operator|*
name|pos
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|chr
operator|!=
literal|'\\'
condition|)
block|{
operator|*
name|pos
operator|=
operator|*
name|chr
expr_stmt|;
comment|/* copy character to current offset */
name|pos
operator|++
expr_stmt|;
name|chr
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Replace the backslash with the correct character */
switch|switch
condition|(
operator|*
operator|++
name|chr
condition|)
block|{
case|case
literal|'a'
case|:
operator|*
name|pos
operator|=
literal|'\a'
expr_stmt|;
break|break;
comment|/* bell/alert (BEL) */
case|case
literal|'b'
case|:
operator|*
name|pos
operator|=
literal|'\b'
expr_stmt|;
break|break;
comment|/* backspace */
case|case
literal|'f'
case|:
operator|*
name|pos
operator|=
literal|'\f'
expr_stmt|;
break|break;
comment|/* form feed */
case|case
literal|'n'
case|:
operator|*
name|pos
operator|=
literal|'\n'
expr_stmt|;
break|break;
comment|/* new line */
case|case
literal|'r'
case|:
operator|*
name|pos
operator|=
literal|'\r'
expr_stmt|;
break|break;
comment|/* carriage return */
case|case
literal|'t'
case|:
operator|*
name|pos
operator|=
literal|'\t'
expr_stmt|;
break|break;
comment|/* horizontal tab */
case|case
literal|'v'
case|:
operator|*
name|pos
operator|=
literal|'\v'
expr_stmt|;
break|break;
comment|/* vertical tab */
case|case
literal|'x'
case|:
comment|/* hex value (1 to 2 digits)(\xNN) */
name|d
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* pre-terminate the string */
comment|/* verify next two characters are hex */
name|d
index|[
literal|0
index|]
operator|=
name|isxdigit
argument_list|(
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
argument_list|)
condition|?
operator|*
operator|++
name|chr
else|:
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|d
index|[
literal|1
index|]
operator|=
name|isxdigit
argument_list|(
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
argument_list|)
condition|?
operator|*
operator|++
name|chr
else|:
literal|'\0'
expr_stmt|;
comment|/* convert the characters to decimal */
name|c
operator|=
operator|(
name|uint8_t
operator|)
name|strtoul
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* assign the converted value */
operator|*
name|pos
operator|=
operator|(
name|c
operator|!=
literal|0
operator|||
name|d
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
condition|?
name|c
else|:
operator|*
operator|++
name|chr
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* octal value (0 to 3 digits)(\0NNN) */
name|d
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* pre-terminate the string */
comment|/* verify next three characters are octal */
name|d
index|[
literal|0
index|]
operator|=
operator|(
name|isdigit
argument_list|(
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
argument_list|)
operator|&&
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
operator|<
literal|'8'
operator|)
condition|?
operator|*
operator|++
name|chr
else|:
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|d
index|[
literal|1
index|]
operator|=
operator|(
name|isdigit
argument_list|(
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
argument_list|)
operator|&&
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
operator|<
literal|'8'
operator|)
condition|?
operator|*
operator|++
name|chr
else|:
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|d
index|[
literal|2
index|]
operator|=
operator|(
name|isdigit
argument_list|(
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
argument_list|)
operator|&&
operator|*
operator|(
name|chr
operator|+
literal|1
operator|)
operator|<
literal|'8'
operator|)
condition|?
operator|*
operator|++
name|chr
else|:
literal|'\0'
expr_stmt|;
comment|/* convert the characters to decimal */
name|c
operator|=
operator|(
name|uint8_t
operator|)
name|strtoul
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* assign the converted value */
operator|*
name|pos
operator|=
name|c
expr_stmt|;
break|break;
default|default:
comment|/* single octal (\0..7) or unknown sequence */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|chr
argument_list|)
operator|&&
operator|*
name|chr
operator|<
literal|'8'
condition|)
block|{
name|d
index|[
literal|0
index|]
operator|=
operator|*
name|chr
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pos
operator|=
operator|(
name|uint8_t
operator|)
name|strtoul
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|pos
operator|=
operator|*
name|chr
expr_stmt|;
block|}
comment|/* Increment to next offset, possible next escape sequence */
name|pos
operator|++
expr_stmt|;
name|chr
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Expand only the escaped newlines in a buffer pointed to by `source'. This  * function steps through each character, and converts the "\n" sequence into  * a literal newline and the "\\n" sequence into "\n".  *  * You should not pass a string constant or literal to this function or the  * program will likely segmentation fault when it tries to modify the data.  *  * The string length will either shorten or stay the same depending on whether  * any escaped newlines were converted but the amount of memory allocated does  * not change.  */
end_comment

begin_function
name|void
name|strexpandnl
parameter_list|(
name|char
modifier|*
name|source
parameter_list|)
block|{
name|uint8_t
name|backslash
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp1
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* Replace '\n' with literal in dprompt */
name|cp1
operator|=
name|cp2
operator|=
name|source
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|cp1
operator|=
operator|*
name|cp2
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'\\'
condition|)
name|backslash
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp2
operator|!=
literal|'n'
condition|)
name|backslash
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|backslash
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
operator|--
name|cp1
operator|)
operator|=
operator|(
name|backslash
operator|&
literal|1
operator|)
operator|==
literal|1
condition|?
literal|'\n'
else|:
literal|'n'
expr_stmt|;
name|backslash
operator|=
literal|0
expr_stmt|;
block|}
name|cp1
operator|++
expr_stmt|;
name|cp2
operator|++
expr_stmt|;
block|}
operator|*
name|cp1
operator|=
operator|*
name|cp2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a string to lower case. You should not pass a string constant to  * this function. Only pass pointers to allocated memory with null terminated  * string data.  */
end_comment

begin_function
name|void
name|strtolower
parameter_list|(
name|char
modifier|*
name|source
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|source
decl_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* would have just used `*p++' but gcc 3.x warns */
block|}
block|}
end_function

end_unit

