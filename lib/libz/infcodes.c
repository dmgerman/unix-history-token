begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infcodes.c -- process literals and length/distance pairs  * Copyright (C) 1995-2002 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_include
include|#
directive|include
file|"infblock.h"
end_include

begin_include
include|#
directive|include
file|"infcodes.h"
end_include

begin_include
include|#
directive|include
file|"infutil.h"
end_include

begin_include
include|#
directive|include
file|"inffast.h"
end_include

begin_comment
comment|/* simplify the use of the inflate_huft type with some defines */
end_comment

begin_define
define|#
directive|define
name|exop
value|word.what.Exop
end_define

begin_define
define|#
directive|define
name|bits
value|word.what.Bits
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
name|START
block|,
comment|/* x: set up for LEN */
name|LEN
block|,
comment|/* i: get length/literal/eob next */
name|LENEXT
block|,
comment|/* i: getting length extra (have base) */
name|DIST
block|,
comment|/* i: get distance next */
name|DISTEXT
block|,
comment|/* i: getting distance extra */
name|COPY
block|,
comment|/* o: copying bytes in window, waiting for space */
name|LIT
block|,
comment|/* o: got literal, waiting for output space */
name|WASH
block|,
comment|/* o: got eob, possibly still output waiting */
name|END
block|,
comment|/* x: got eob and all data flushed */
name|BADCODE
block|}
comment|/* x: got error */
name|inflate_codes_mode
typedef|;
end_typedef

begin_comment
comment|/* inflate codes private state */
end_comment

begin_struct
struct|struct
name|inflate_codes_state
block|{
comment|/* mode */
name|inflate_codes_mode
name|mode
decl_stmt|;
comment|/* current inflate_codes mode */
comment|/* mode dependent information */
name|uInt
name|len
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|inflate_huft
modifier|*
name|tree
decl_stmt|;
comment|/* pointer into tree */
name|uInt
name|need
decl_stmt|;
comment|/* bits needed */
block|}
name|code
struct|;
comment|/* if LEN or DIST, where in tree */
name|uInt
name|lit
decl_stmt|;
comment|/* if LIT, literal */
struct|struct
block|{
name|uInt
name|get
decl_stmt|;
comment|/* bits to get for extra */
name|uInt
name|dist
decl_stmt|;
comment|/* distance back to copy from */
block|}
name|copy
struct|;
comment|/* if EXT or COPY, where and how much */
block|}
name|sub
union|;
comment|/* submode */
comment|/* mode independent information */
name|Byte
name|lbits
decl_stmt|;
comment|/* ltree bits decoded per branch */
name|Byte
name|dbits
decl_stmt|;
comment|/* dtree bits decoder per branch */
name|inflate_huft
modifier|*
name|ltree
decl_stmt|;
comment|/* literal/length/eob tree */
name|inflate_huft
modifier|*
name|dtree
decl_stmt|;
comment|/* distance tree */
block|}
struct|;
end_struct

begin_function
name|inflate_codes_statef
modifier|*
name|inflate_codes_new
parameter_list|(
name|bl
parameter_list|,
name|bd
parameter_list|,
name|tl
parameter_list|,
name|td
parameter_list|,
name|z
parameter_list|)
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|;
name|inflate_huft
modifier|*
name|td
decl_stmt|;
comment|/* need separate declaration for Borland C++ */
name|z_streamp
name|z
decl_stmt|;
block|{
name|inflate_codes_statef
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|(
name|inflate_codes_statef
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_codes_state
argument_list|)
argument_list|)
operator|)
operator|!=
name|Z_NULL
condition|)
block|{
name|c
operator|->
name|mode
operator|=
name|START
expr_stmt|;
name|c
operator|->
name|lbits
operator|=
operator|(
name|Byte
operator|)
name|bl
expr_stmt|;
name|c
operator|->
name|dbits
operator|=
operator|(
name|Byte
operator|)
name|bd
expr_stmt|;
name|c
operator|->
name|ltree
operator|=
name|tl
expr_stmt|;
name|c
operator|->
name|dtree
operator|=
name|td
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes new\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
name|int
name|inflate_codes
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|r
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_streamp
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
name|uInt
name|j
decl_stmt|;
comment|/* temporary storage */
name|inflate_huft
modifier|*
name|t
decl_stmt|;
comment|/* temporary pointer */
name|uInt
name|e
decl_stmt|;
comment|/* extra bits or operation */
name|uLong
name|b
decl_stmt|;
comment|/* bit buffer */
name|uInt
name|k
decl_stmt|;
comment|/* bits in bit buffer */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* input data pointer */
name|uInt
name|n
decl_stmt|;
comment|/* bytes available there */
name|Bytef
modifier|*
name|q
decl_stmt|;
comment|/* output window write pointer */
name|uInt
name|m
decl_stmt|;
comment|/* bytes to end of window or read pointer */
name|Bytef
modifier|*
name|f
decl_stmt|;
comment|/* pointer to copy strings from */
name|inflate_codes_statef
modifier|*
name|c
init|=
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
decl_stmt|;
comment|/* codes state */
comment|/* copy input/output information to locals (UPDATE macro restores) */
name|LOAD
comment|/* process input and output based on current state */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
operator|->
name|mode
condition|)
block|{
comment|/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
case|case
name|START
case|:
comment|/* x: set up for LEN */
ifndef|#
directive|ifndef
name|SLOW
if|if
condition|(
name|m
operator|>=
literal|258
operator|&&
name|n
operator|>=
literal|10
condition|)
block|{
name|UPDATE
name|r
init|=
name|inflate_fast
argument_list|(
name|c
operator|->
name|lbits
argument_list|,
name|c
operator|->
name|dbits
argument_list|,
name|c
operator|->
name|ltree
argument_list|,
name|c
operator|->
name|dtree
argument_list|,
name|s
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|LOAD
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|c
operator|->
name|mode
operator|=
name|r
operator|==
name|Z_STREAM_END
condition|?
name|WASH
else|:
name|BADCODE
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* !SLOW */
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|c
operator|->
name|lbits
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|c
operator|->
name|ltree
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
case|case
name|LEN
case|:
comment|/* i: get length/literal/eob next */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|t
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|e
operator|=
call|(
name|uInt
call|)
argument_list|(
name|t
operator|->
name|exop
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
comment|/* literal */
block|{
name|c
operator|->
name|sub
operator|.
name|lit
operator|=
name|t
operator|->
name|base
expr_stmt|;
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|t
operator|->
name|base
operator|>=
literal|0x20
operator|&&
name|t
operator|->
name|base
operator|<
literal|0x7f
condition|?
literal|"inflate:         literal '%c'\n"
else|:
literal|"inflate:         literal 0x%02x\n"
operator|,
name|t
operator|->
name|base
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|LIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|&
literal|16
condition|)
comment|/* length */
block|{
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
operator|=
name|e
operator|&
literal|15
expr_stmt|;
name|c
operator|->
name|len
operator|=
name|t
operator|->
name|base
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|LENEXT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
comment|/* next table */
block|{
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|e
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|t
operator|+
name|t
operator|->
name|base
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|&
literal|32
condition|)
comment|/* end of block */
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|WASH
expr_stmt|;
break|break;
block|}
name|c
operator|->
name|mode
operator|=
name|BADCODE
expr_stmt|;
comment|/* invalid code */
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/length code"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
case|case
name|LENEXT
case|:
comment|/* i: getting length extra (have base) */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|c
operator|->
name|len
operator|+=
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|j
argument_list|)
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|c
operator|->
name|dbits
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|c
operator|->
name|dtree
expr_stmt|;
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         length %u\n"
operator|,
name|c
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|DIST
expr_stmt|;
case|case
name|DIST
case|:
comment|/* i: get distance next */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|t
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|e
operator|=
call|(
name|uInt
call|)
argument_list|(
name|t
operator|->
name|exop
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|&
literal|16
condition|)
comment|/* distance */
block|{
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
operator|=
name|e
operator|&
literal|15
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|=
name|t
operator|->
name|base
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|DISTEXT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
comment|/* next table */
block|{
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|e
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|t
operator|+
name|t
operator|->
name|base
expr_stmt|;
break|break;
block|}
name|c
operator|->
name|mode
operator|=
name|BADCODE
expr_stmt|;
comment|/* invalid code */
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance code"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
case|case
name|DISTEXT
case|:
comment|/* i: getting distance extra */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|+=
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|j
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         distance %u\n"
operator|,
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|COPY
expr_stmt|;
case|case
name|COPY
case|:
comment|/* o: copying bytes in window, waiting for space */
name|f
operator|=
name|q
operator|-
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
expr_stmt|;
while|while
condition|(
name|f
operator|<
name|s
operator|->
name|window
condition|)
comment|/* modulo window size-"while" instead */
name|f
operator|+=
name|s
operator|->
name|end
operator|-
name|s
operator|->
name|window
expr_stmt|;
comment|/* of "if" handles invalid distances */
while|while
condition|(
name|c
operator|->
name|len
condition|)
block|{
name|NEEDOUT
name|OUTBYTE
argument_list|(
operator|*
name|f
operator|++
argument_list|)
decl|if
argument_list|(
name|f
operator|==
name|s
operator|->
name|end
argument_list|)
name|f
init|=
name|s
operator|->
name|window
decl_stmt|;
name|c
operator|->
name|len
operator|--
expr_stmt|;
block|}
name|c
operator|->
name|mode
operator|=
name|START
expr_stmt|;
break|break;
case|case
name|LIT
case|:
comment|/* o: got literal, waiting for output space */
name|NEEDOUT
name|OUTBYTE
argument_list|(
name|c
operator|->
name|sub
operator|.
name|lit
argument_list|)
name|c
operator|->
name|mode
init|=
name|START
decl_stmt|;
break|break;
case|case
name|WASH
case|:
comment|/* o: got eob, possibly more output */
if|if
condition|(
name|k
operator|>
literal|7
condition|)
comment|/* return unused byte, if any */
block|{
name|Assert
argument_list|(
argument|k<
literal|16
argument_list|,
literal|"inflate_codes grabbed too many bytes"
argument_list|)
name|k
operator|-=
literal|8
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|p
operator|--
expr_stmt|;
comment|/* can always return one */
block|}
name|FLUSH
if|if
condition|(
name|s
operator|->
name|read
operator|!=
name|s
operator|->
name|write
condition|)
name|LEAVE
name|c
operator|->
name|mode
init|=
name|END
decl_stmt|;
case|case
name|END
case|:
name|r
operator|=
name|Z_STREAM_END
expr_stmt|;
name|LEAVE
case|case
name|BADCODE
case|:
comment|/* x: got error */
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
default|default:
name|r
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
name|LEAVE
block|}
ifdef|#
directive|ifdef
name|NEED_DUMMY_RETURN
return|return
name|Z_STREAM_ERROR
return|;
comment|/* Some dumb compilers complain without this */
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|inflate_codes_free
parameter_list|(
name|c
parameter_list|,
name|z
parameter_list|)
name|inflate_codes_statef
modifier|*
name|c
decl_stmt|;
name|z_streamp
name|z
decl_stmt|;
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes free\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

