begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inffast.c -- process literals and length/distance pairs fast  * Copyright (C) 1995-1996 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_include
include|#
directive|include
file|"infblock.h"
end_include

begin_include
include|#
directive|include
file|"infcodes.h"
end_include

begin_include
include|#
directive|include
file|"infutil.h"
end_include

begin_include
include|#
directive|include
file|"inffast.h"
end_include

begin_struct
struct|struct
name|inflate_codes_state
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for buggy compilers */
end_comment

begin_comment
comment|/* simplify the use of the inflate_huft type with some defines */
end_comment

begin_define
define|#
directive|define
name|base
value|more.Base
end_define

begin_define
define|#
directive|define
name|next
value|more.Next
end_define

begin_define
define|#
directive|define
name|exop
value|word.what.Exop
end_define

begin_define
define|#
directive|define
name|bits
value|word.what.Bits
end_define

begin_comment
comment|/* macros for bit input with no checking and for returning unused bytes */
end_comment

begin_define
define|#
directive|define
name|GRABBITS
parameter_list|(
name|j
parameter_list|)
value|{while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
end_define

begin_define
define|#
directive|define
name|UNGRAB
value|{n+=(c=k>>3);p-=c;k&=7;}
end_define

begin_comment
comment|/* Called with number of bytes left to write in window at least 258    (the maximum string length) and number of input bytes available    at least ten.  The ten bytes are six bytes for the longest length/    distance pair plus four bytes for overloading the bit buffer. */
end_comment

begin_function
name|int
name|inflate_fast
parameter_list|(
name|bl
parameter_list|,
name|bd
parameter_list|,
name|tl
parameter_list|,
name|td
parameter_list|,
name|s
parameter_list|,
name|z
parameter_list|)
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|;
name|inflate_huft
modifier|*
name|td
decl_stmt|;
comment|/* need separate declaration for Borland C++ */
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_streamp
name|z
decl_stmt|;
block|{
name|inflate_huft
modifier|*
name|t
decl_stmt|;
comment|/* temporary pointer */
name|uInt
name|e
decl_stmt|;
comment|/* extra bits or operation */
name|uLong
name|b
decl_stmt|;
comment|/* bit buffer */
name|uInt
name|k
decl_stmt|;
comment|/* bits in bit buffer */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* input data pointer */
name|uInt
name|n
decl_stmt|;
comment|/* bytes available there */
name|Bytef
modifier|*
name|q
decl_stmt|;
comment|/* output window write pointer */
name|uInt
name|m
decl_stmt|;
comment|/* bytes to end of window or read pointer */
name|uInt
name|ml
decl_stmt|;
comment|/* mask for literal/length tree */
name|uInt
name|md
decl_stmt|;
comment|/* mask for distance tree */
name|uInt
name|c
decl_stmt|;
comment|/* bytes to copy */
name|uInt
name|d
decl_stmt|;
comment|/* distance back to copy from */
name|Bytef
modifier|*
name|r
decl_stmt|;
comment|/* copy source pointer */
comment|/* load input, output, bit values */
name|LOAD
comment|/* initialize masks */
name|ml
init|=
name|inflate_mask
index|[
name|bl
index|]
decl_stmt|;
name|md
operator|=
name|inflate_mask
index|[
name|bd
index|]
expr_stmt|;
comment|/* do until not enough input or output space for fast loop */
do|do
block|{
comment|/* assume called with m>= 258&& n>= 10 */
comment|/* get literal/length code */
name|GRABBITS
argument_list|(
literal|20
argument_list|)
comment|/* max bits for literal/length code */
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|tl
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|ml
operator|)
operator|)
operator|->
name|exop
operator|)
operator|==
literal|0
condition|)
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|t
operator|->
name|base
operator|>=
literal|0x20
operator|&&
name|t
operator|->
name|base
operator|<
literal|0x7f
condition|?
literal|"inflate:         * literal '%c'\n"
else|:
literal|"inflate:         * literal 0x%02x\n"
operator|,
name|t
operator|->
name|base
operator|)
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|Byte
operator|)
name|t
operator|->
name|base
expr_stmt|;
name|m
operator|--
expr_stmt|;
continue|continue;
block|}
do|do
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
if|if
condition|(
name|e
operator|&
literal|16
condition|)
block|{
comment|/* get extra bits for length */
name|e
operator|&=
literal|15
expr_stmt|;
name|c
operator|=
name|t
operator|->
name|base
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|e
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         * length %u\n"
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
comment|/* decode distance base of block to copy */
name|GRABBITS
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* max bits for distance code */
name|e
operator|=
operator|(
name|t
operator|=
name|td
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|md
operator|)
operator|)
operator|->
name|exop
expr_stmt|;
do|do
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
if|if
condition|(
name|e
operator|&
literal|16
condition|)
block|{
comment|/* get extra bits to add to distance base */
name|e
operator|&=
literal|15
expr_stmt|;
name|GRABBITS
argument_list|(
argument|e
argument_list|)
comment|/* get extra bits (up to 13) */
name|d
operator|=
name|t
operator|->
name|base
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|e
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         * distance %u\n"
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
comment|/* do the copy */
name|m
operator|-=
name|c
expr_stmt|;
if|if
condition|(
call|(
name|uInt
call|)
argument_list|(
name|q
operator|-
name|s
operator|->
name|window
argument_list|)
operator|>=
name|d
condition|)
comment|/* offset before dest */
block|{
comment|/*  just copy */
name|r
operator|=
name|q
operator|-
name|d
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
comment|/* minimum count is three, */
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
comment|/*  so unroll loop a little */
block|}
else|else
comment|/* else offset after destination */
block|{
name|e
operator|=
name|d
operator|-
call|(
name|uInt
call|)
argument_list|(
name|q
operator|-
name|s
operator|->
name|window
argument_list|)
expr_stmt|;
comment|/* bytes from offset to end */
name|r
operator|=
name|s
operator|->
name|end
operator|-
name|e
expr_stmt|;
comment|/* pointer to offset */
if|if
condition|(
name|c
operator|>
name|e
condition|)
comment|/* if source crosses, */
block|{
name|c
operator|-=
name|e
expr_stmt|;
comment|/* copy to end of window */
do|do
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|e
condition|)
do|;
name|r
operator|=
name|s
operator|->
name|window
expr_stmt|;
comment|/* copy rest from start of window */
block|}
block|}
do|do
block|{
comment|/* copy all or what's left */
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
condition|)
do|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|next
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|exop
expr_stmt|;
else|else
block|{
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance code"
expr_stmt|;
name|UNGRAB
name|UPDATE
return|return
name|Z_DATA_ERROR
return|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|next
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|exop
operator|)
operator|==
literal|0
condition|)
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|t
operator|->
name|base
operator|>=
literal|0x20
operator|&&
name|t
operator|->
name|base
operator|<
literal|0x7f
condition|?
literal|"inflate:         * literal '%c'\n"
else|:
literal|"inflate:         * literal 0x%02x\n"
operator|,
name|t
operator|->
name|base
operator|)
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|Byte
operator|)
name|t
operator|->
name|base
expr_stmt|;
name|m
operator|--
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|&
literal|32
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         * end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|UNGRAB
name|UPDATE
return|return
name|Z_STREAM_END
return|;
block|}
else|else
block|{
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/length code"
expr_stmt|;
name|UNGRAB
name|UPDATE
return|return
name|Z_DATA_ERROR
return|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
do|while
condition|(
name|m
operator|>=
literal|258
operator|&&
name|n
operator|>=
literal|10
condition|)
do|;
comment|/* not enough input or output--restore pointers and return */
name|UNGRAB
name|UPDATE
return|return
name|Z_OK
return|;
block|}
end_function

end_unit

