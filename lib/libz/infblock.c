begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infblock.c -- interpret and process block types to last block  * Copyright (C) 1995-1998 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"infblock.h"
end_include

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_include
include|#
directive|include
file|"infcodes.h"
end_include

begin_include
include|#
directive|include
file|"infutil.h"
end_include

begin_struct
struct|struct
name|inflate_codes_state
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for buggy compilers */
end_comment

begin_comment
comment|/* simplify the use of the inflate_huft type with some defines */
end_comment

begin_define
define|#
directive|define
name|exop
value|word.what.Exop
end_define

begin_define
define|#
directive|define
name|bits
value|word.what.Bits
end_define

begin_comment
comment|/* Table for deflate from PKZIP's appnote.txt. */
end_comment

begin_decl_stmt
name|local
specifier|const
name|uInt
name|border
index|[]
init|=
block|{
comment|/* Order of the bit length code lengths */
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Notes beyond the 1.93a appnote.txt:     1. Distance pointers never point before the beginning of the output       stream.    2. Distance pointers can point back across blocks, up to 32k away.    3. There is an implied maximum of 7 bits for the bit length table and       15 bits for the actual data.    4. If only one code exists, then it is encoded using one bit.  (Zero       would be more efficient, but perhaps a little confusing.)  If two       codes exist, they are coded using one bit each (0 and 1).    5. There is no way of sending zero distance codes--a dummy must be       sent if there are none.  (History: a pre 2.0 version of PKZIP would       store blocks with no distance codes, but this was discovered to be       too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow       zero distance codes, which is sent as one code of zero bits in       length.    6. There are up to 286 literal/length codes.  Code 256 represents the       end-of-block.  Note however that the static length tree defines       288 codes just to fill out the Huffman codes.  Codes 286 and 287       cannot be used though, since there is no length base or extra bits       defined for them.  Similarily, there are up to 30 distance codes.       However, static trees define 32 codes (all 5 bits) to fill out the       Huffman codes, but the last two had better not show up in the data.    7. Unzip can check dynamic Huffman blocks for complete code sets.       The exception is that a single code would not be complete (see #4).    8. The five bits following the block type is really the number of       literal codes sent minus 257.    9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits       (1+6+6).  Therefore, to output three times the length, you output       three codes (1+1+1), whereas to output four times the same length,       you only need two codes (1+3).  Hmm.   10. In the tree reconstruction algorithm, Code = Code + Increment       only if BitLength(i) is not zero.  (Pretty obvious.)   11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)   12. Note: length code 284 can represent 227-258, but length code 285       really is 258.  The last length deserves its own, short code       since it gets used a lot in very redundant files.  The length       258 is special since 258 - 3 (the min match length) is 255.   13. The literal/length and distance code bit lengths are read as a       single stream of lengths.  It is possible (and advantageous) for       a repeat code (16, 17, or 18) to go across the boundary between       the two sets of lengths.  */
end_comment

begin_function
name|void
name|inflate_blocks_reset
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|c
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_streamp
name|z
decl_stmt|;
name|uLongf
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|!=
name|Z_NULL
condition|)
operator|*
name|c
operator|=
name|s
operator|->
name|check
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
name|BTREE
operator|||
name|s
operator|->
name|mode
operator|==
name|DTREE
condition|)
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
name|CODES
condition|)
name|inflate_codes_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
name|s
operator|->
name|bitk
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bitb
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|read
operator|=
name|s
operator|->
name|write
operator|=
name|s
operator|->
name|window
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|checkfn
operator|!=
name|Z_NULL
condition|)
name|z
operator|->
name|adler
operator|=
name|s
operator|->
name|check
operator|=
call|(
modifier|*
name|s
operator|->
name|checkfn
call|)
argument_list|(
literal|0L
argument_list|,
operator|(
specifier|const
name|Bytef
operator|*
operator|)
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   blocks reset\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|inflate_blocks_statef
modifier|*
name|inflate_blocks_new
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|,
name|w
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
name|check_func
name|c
decl_stmt|;
name|uInt
name|w
decl_stmt|;
block|{
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
operator|(
name|inflate_blocks_statef
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_blocks_state
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|(
name|s
operator|->
name|hufts
operator|=
operator|(
name|inflate_huft
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
name|inflate_huft
argument_list|)
argument_list|,
name|MANY
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|Z_NULL
return|;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|window
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
name|w
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|hufts
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|Z_NULL
return|;
block|}
name|s
operator|->
name|end
operator|=
name|s
operator|->
name|window
operator|+
name|w
expr_stmt|;
name|s
operator|->
name|checkfn
operator|=
name|c
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   blocks allocated\n"
operator|)
argument_list|)
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|inflate_blocks
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|r
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_streamp
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
name|uInt
name|t
decl_stmt|;
comment|/* temporary storage */
name|uLong
name|b
decl_stmt|;
comment|/* bit buffer */
name|uInt
name|k
decl_stmt|;
comment|/* bits in bit buffer */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* input data pointer */
name|uInt
name|n
decl_stmt|;
comment|/* bytes available there */
name|Bytef
modifier|*
name|q
decl_stmt|;
comment|/* output window write pointer */
name|uInt
name|m
decl_stmt|;
comment|/* bytes to end of window or read pointer */
comment|/* copy input/output information to locals (UPDATE macro restores) */
name|LOAD
comment|/* process input based on current state */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|s
operator|->
name|mode
condition|)
block|{
case|case
name|TYPE
case|:
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
name|t
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|7
expr_stmt|;
name|s
operator|->
name|last
operator|=
name|t
operator|&
literal|1
expr_stmt|;
switch|switch
condition|(
name|t
operator|>>
literal|1
condition|)
block|{
case|case
literal|0
case|:
comment|/* stored */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     stored block%s\n"
operator|,
name|s
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|t
operator|=
name|k
operator|&
literal|7
expr_stmt|;
comment|/* go to byte boundary */
name|DUMPBITS
argument_list|(
argument|t
argument_list|)
name|s
operator|->
name|mode
operator|=
name|LENS
expr_stmt|;
comment|/* get length of stored block */
break|break;
case|case
literal|1
case|:
comment|/* fixed */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     fixed codes block%s\n"
operator|,
name|s
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|{
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|,
modifier|*
name|td
decl_stmt|;
name|inflate_trees_fixed
argument_list|(
operator|&
name|bl
argument_list|,
operator|&
name|bd
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
operator|=
name|inflate_codes_new
argument_list|(
name|bl
argument_list|,
name|bd
argument_list|,
name|tl
argument_list|,
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
operator|==
name|Z_NULL
condition|)
block|{
name|r
operator|=
name|Z_MEM_ERROR
expr_stmt|;
name|LEAVE
block|}
block|}
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|mode
operator|=
name|CODES
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* dynamic */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     dynamic codes block%s\n"
operator|,
name|s
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|mode
operator|=
name|TABLE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* illegal */
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid block type"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
break|break;
case|case
name|LENS
case|:
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
if|if
condition|(
operator|(
operator|(
operator|(
operator|~
name|b
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|!=
operator|(
name|b
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|s
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid stored block lengths"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
name|s
operator|->
name|sub
operator|.
name|left
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|0xffff
expr_stmt|;
name|b
operator|=
name|k
operator|=
literal|0
expr_stmt|;
comment|/* dump bits */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored length %u\n"
operator|,
name|s
operator|->
name|sub
operator|.
name|left
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|s
operator|->
name|sub
operator|.
name|left
condition|?
name|STORED
else|:
operator|(
name|s
operator|->
name|last
condition|?
name|DRY
else|:
name|TYPE
operator|)
expr_stmt|;
break|break;
case|case
name|STORED
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|LEAVE
name|NEEDOUT
name|t
init|=
name|s
operator|->
name|sub
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|t
operator|>
name|n
condition|)
name|t
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|t
operator|>
name|m
condition|)
name|t
operator|=
name|m
expr_stmt|;
name|zmemcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|p
operator|+=
name|t
expr_stmt|;
name|n
operator|-=
name|t
expr_stmt|;
name|q
operator|+=
name|t
expr_stmt|;
name|m
operator|-=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|sub
operator|.
name|left
operator|-=
name|t
operator|)
operator|!=
literal|0
condition|)
break|break;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored end, %lu total out\n"
operator|,
name|z
operator|->
name|total_out
operator|+
operator|(
name|q
operator|>=
name|s
operator|->
name|read
condition|?
name|q
operator|-
name|s
operator|->
name|read
else|:
operator|(
name|s
operator|->
name|end
operator|-
name|s
operator|->
name|read
operator|)
operator|+
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|s
operator|->
name|last
condition|?
name|DRY
else|:
name|TYPE
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
name|NEEDBITS
argument_list|(
literal|14
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
operator|=
name|t
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|0x3fff
expr_stmt|;
ifndef|#
directive|ifndef
name|PKZIP_BUG_WORKAROUND
if|if
condition|(
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|>
literal|29
operator|||
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
operator|>
literal|29
condition|)
block|{
name|s
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"too many length or distance symbols"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
endif|#
directive|endif
name|t
operator|=
literal|258
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
operator|=
operator|(
name|uIntf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|uInt
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|r
operator|=
name|Z_MEM_ERROR
expr_stmt|;
name|LEAVE
block|}
name|DUMPBITS
argument_list|(
literal|14
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       table sizes ok\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|BTREE
expr_stmt|;
case|case
name|BTREE
case|:
while|while
condition|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|<
literal|4
operator|+
operator|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
operator|>>
literal|10
operator|)
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|border
index|[
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|++
index|]
index|]
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|7
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
block|}
while|while
condition|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|<
literal|19
condition|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|border
index|[
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|++
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|bb
operator|=
literal|7
expr_stmt|;
name|t
operator|=
name|inflate_trees_bits
argument_list|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|,
operator|&
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|bb
argument_list|,
operator|&
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|tb
argument_list|,
name|s
operator|->
name|hufts
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|Z_OK
condition|)
block|{
name|r
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
block|}
name|LEAVE
block|}
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       bits tree ok\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|DTREE
expr_stmt|;
case|case
name|DTREE
case|:
while|while
condition|(
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
operator|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|<
literal|258
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
condition|)
block|{
name|inflate_huft
modifier|*
name|h
decl_stmt|;
name|uInt
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|bb
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|t
argument_list|)
name|h
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|tb
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|t
index|]
operator|)
expr_stmt|;
name|t
operator|=
name|h
operator|->
name|bits
expr_stmt|;
name|c
operator|=
name|h
operator|->
name|base
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|16
condition|)
block|{
name|DUMPBITS
argument_list|(
argument|t
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
comment|/* c == 16..18 */
block|{
name|i
operator|=
name|c
operator|==
literal|18
condition|?
literal|7
else|:
name|c
operator|-
literal|14
expr_stmt|;
name|j
operator|=
name|c
operator|==
literal|18
condition|?
literal|11
else|:
literal|3
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|t + i
argument_list|)
name|DUMPBITS
argument_list|(
argument|t
argument_list|)
name|j
operator|+=
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|i
index|]
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|i
argument_list|)
name|i
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
expr_stmt|;
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|>
literal|258
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
operator|||
operator|(
name|c
operator|==
literal|16
operator|&&
name|i
operator|<
literal|1
operator|)
condition|)
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid bit length repeat"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
name|c
operator|=
name|c
operator|==
literal|16
condition|?
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|i
operator|-
literal|1
index|]
else|:
literal|0
expr_stmt|;
do|do
block|{
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|j
condition|)
do|;
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|tb
operator|=
name|Z_NULL
expr_stmt|;
block|{
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|,
modifier|*
name|td
decl_stmt|;
name|inflate_codes_statef
modifier|*
name|c
decl_stmt|;
name|bl
operator|=
literal|9
expr_stmt|;
comment|/* must be<= 9 for lookahead assumptions */
name|bd
operator|=
literal|6
expr_stmt|;
comment|/* must be<= 9 for lookahead assumptions */
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
expr_stmt|;
name|t
operator|=
name|inflate_trees_dynamic
argument_list|(
literal|257
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
argument_list|,
literal|1
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|,
operator|&
name|bl
argument_list|,
operator|&
name|bd
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|td
argument_list|,
name|s
operator|->
name|hufts
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|Z_OK
condition|)
block|{
if|if
condition|(
name|t
operator|==
operator|(
name|uInt
operator|)
name|Z_DATA_ERROR
condition|)
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
block|}
name|r
operator|=
name|t
expr_stmt|;
name|LEAVE
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       trees ok\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|inflate_codes_new
argument_list|(
name|bl
argument_list|,
name|bd
argument_list|,
name|tl
argument_list|,
name|td
argument_list|,
name|z
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|r
operator|=
name|Z_MEM_ERROR
expr_stmt|;
name|LEAVE
block|}
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
operator|=
name|c
expr_stmt|;
block|}
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|CODES
expr_stmt|;
case|case
name|CODES
case|:
name|UPDATE
if|if
condition|(
operator|(
name|r
operator|=
name|inflate_codes
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
name|r
argument_list|)
operator|)
operator|!=
name|Z_STREAM_END
condition|)
return|return
name|inflate_flush
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
name|r
argument_list|)
return|;
name|r
operator|=
name|Z_OK
expr_stmt|;
name|inflate_codes_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|LOAD
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes end, %lu total out\n"
operator|,
name|z
operator|->
name|total_out
operator|+
operator|(
name|q
operator|>=
name|s
operator|->
name|read
condition|?
name|q
operator|-
name|s
operator|->
name|read
else|:
operator|(
name|s
operator|->
name|end
operator|-
name|s
operator|->
name|read
operator|)
operator|+
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
operator|)
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|last
condition|)
block|{
name|s
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|mode
operator|=
name|DRY
expr_stmt|;
case|case
name|DRY
case|:
name|FLUSH
if|if
condition|(
name|s
operator|->
name|read
operator|!=
name|s
operator|->
name|write
condition|)
name|LEAVE
name|s
operator|->
name|mode
init|=
name|DONE
decl_stmt|;
case|case
name|DONE
case|:
name|r
operator|=
name|Z_STREAM_END
expr_stmt|;
name|LEAVE
case|case
name|BAD
case|:
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
default|default:
name|r
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
name|LEAVE
block|}
block|}
end_function

begin_function
name|int
name|inflate_blocks_free
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_streamp
name|z
decl_stmt|;
block|{
name|inflate_blocks_reset
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|window
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|hufts
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   blocks freed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|void
name|inflate_set_dictionary
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|d
decl_stmt|;
name|uInt
name|n
decl_stmt|;
block|{
name|zmemcpy
argument_list|(
name|s
operator|->
name|window
argument_list|,
name|d
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|read
operator|=
name|s
operator|->
name|write
operator|=
name|s
operator|->
name|window
operator|+
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if inflate is currently at the end of a block generated  * by Z_SYNC_FLUSH or Z_FULL_FLUSH.   * IN assertion: s != Z_NULL  */
end_comment

begin_function
name|int
name|inflate_blocks_sync_point
parameter_list|(
name|s
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|s
operator|->
name|mode
operator|==
name|LENS
return|;
block|}
end_function

end_unit

