begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inftrees.c -- generate Huffman trees for efficient decoding  * Copyright (C) 1995-2004 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_define
define|#
directive|define
name|MAXBITS
value|15
end_define

begin_decl_stmt
specifier|const
name|char
name|inflate_copyright
index|[]
init|=
literal|" inflate 1.2.2 Copyright 1995-2004 Mark Adler "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   If you use the zlib library in a product, an acknowledgment is welcome   in the documentation of your product. If for some reason you cannot   include such an acknowledgment, I would appreciate that you keep this   copyright string in the executable of your product.  */
end_comment

begin_comment
comment|/*    Build a set of tables to decode the provided canonical Huffman code.    The code lengths are lens[0..codes-1].  The result starts at *table,    whose indices are 0..2^bits-1.  work is a writable array of at least    lens shorts, which is used as a work area.  type is the type of code    to be generated, CODES, LENS, or DISTS.  On return, zero is success,    -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table    on return points to the next available entry's address.  bits is the    requested root table index bits, and on return it is the actual root    table index bits.  It will differ if the request is greater than the    longest code or if it is less than the shortest code.  */
end_comment

begin_function
name|int
name|inflate_table
parameter_list|(
name|type
parameter_list|,
name|lens
parameter_list|,
name|codes
parameter_list|,
name|table
parameter_list|,
name|bits
parameter_list|,
name|work
parameter_list|)
name|codetype
name|type
decl_stmt|;
name|unsigned
name|short
name|FAR
modifier|*
name|lens
decl_stmt|;
name|unsigned
name|codes
decl_stmt|;
name|code
name|FAR
modifier|*
name|FAR
modifier|*
name|table
decl_stmt|;
name|unsigned
name|FAR
modifier|*
name|bits
decl_stmt|;
name|unsigned
name|short
name|FAR
modifier|*
name|work
decl_stmt|;
block|{
name|unsigned
name|len
decl_stmt|;
comment|/* a code's length in bits */
name|unsigned
name|sym
decl_stmt|;
comment|/* index of code symbols */
name|unsigned
name|min
decl_stmt|,
name|max
decl_stmt|;
comment|/* minimum and maximum code lengths */
name|unsigned
name|root
decl_stmt|;
comment|/* number of index bits for root table */
name|unsigned
name|curr
decl_stmt|;
comment|/* number of index bits for current table */
name|unsigned
name|drop
decl_stmt|;
comment|/* code bits to drop for sub-table */
name|int
name|left
decl_stmt|;
comment|/* number of prefix codes available */
name|unsigned
name|used
decl_stmt|;
comment|/* code entries in table used */
name|unsigned
name|huff
decl_stmt|;
comment|/* Huffman code */
name|unsigned
name|incr
decl_stmt|;
comment|/* for incrementing code, index */
name|unsigned
name|fill
decl_stmt|;
comment|/* index for replicating entries */
name|unsigned
name|low
decl_stmt|;
comment|/* low bits for current root entry */
name|unsigned
name|mask
decl_stmt|;
comment|/* mask for low root bits */
name|code
name|this
decl_stmt|;
comment|/* table entry for duplication */
name|code
name|FAR
modifier|*
name|next
decl_stmt|;
comment|/* next available space in table */
specifier|const
name|unsigned
name|short
name|FAR
modifier|*
name|base
decl_stmt|;
comment|/* base value table to use */
specifier|const
name|unsigned
name|short
name|FAR
modifier|*
name|extra
decl_stmt|;
comment|/* extra bits table to use */
name|int
name|end
decl_stmt|;
comment|/* use base and extra for symbol> end */
name|unsigned
name|short
name|count
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* number of codes of each length */
name|unsigned
name|short
name|offs
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* offsets in table for each length */
specifier|static
specifier|const
name|unsigned
name|short
name|lbase
index|[
literal|31
index|]
init|=
block|{
comment|/* Length codes 257..285 base */
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|13
block|,
literal|15
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|27
block|,
literal|31
block|,
literal|35
block|,
literal|43
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|115
block|,
literal|131
block|,
literal|163
block|,
literal|195
block|,
literal|227
block|,
literal|258
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|short
name|lext
index|[
literal|31
index|]
init|=
block|{
comment|/* Length codes 257..285 extra */
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|16
block|,
literal|199
block|,
literal|198
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|short
name|dbase
index|[
literal|32
index|]
init|=
block|{
comment|/* Distance codes 0..29 base */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|13
block|,
literal|17
block|,
literal|25
block|,
literal|33
block|,
literal|49
block|,
literal|65
block|,
literal|97
block|,
literal|129
block|,
literal|193
block|,
literal|257
block|,
literal|385
block|,
literal|513
block|,
literal|769
block|,
literal|1025
block|,
literal|1537
block|,
literal|2049
block|,
literal|3073
block|,
literal|4097
block|,
literal|6145
block|,
literal|8193
block|,
literal|12289
block|,
literal|16385
block|,
literal|24577
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|static
specifier|const
name|unsigned
name|short
name|dext
index|[
literal|32
index|]
init|=
block|{
comment|/* Distance codes 0..29 extra */
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|17
block|,
literal|18
block|,
literal|18
block|,
literal|19
block|,
literal|19
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|21
block|,
literal|22
block|,
literal|22
block|,
literal|23
block|,
literal|23
block|,
literal|24
block|,
literal|24
block|,
literal|25
block|,
literal|25
block|,
literal|26
block|,
literal|26
block|,
literal|27
block|,
literal|27
block|,
literal|28
block|,
literal|28
block|,
literal|29
block|,
literal|29
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
comment|/*        Process a set of code lengths to create a canonical Huffman code.  The        code lengths are lens[0..codes-1].  Each length corresponds to the        symbols 0..codes-1.  The Huffman code is generated by first sorting the        symbols by length from short to long, and retaining the symbol order        for codes with equal lengths.  Then the code starts with all zero bits        for the first code of the shortest length, and the codes are integer        increments for the same length, and zeros are appended as the length        increases.  For the deflate format, these bits are stored backwards        from their more natural integer increment ordering, and so when the        decoding tables are built in the large loop below, the integer codes        are incremented backwards.         This routine assumes, but does not check, that all of the entries in        lens[] are in the range 0..MAXBITS.  The caller must assure this.        1..MAXBITS is interpreted as that code length.  zero means that that        symbol does not occur in this code.         The codes are sorted by computing a count of codes for each length,        creating from that a table of starting indices for each length in the        sorted table, and then entering the symbols in order in the sorted        table.  The sorted table is work[], with that space being provided by        the caller.         The length counts are used for other purposes as well, i.e. finding        the minimum and maximum length codes, determining if there are any        codes at all, checking for a valid set of lengths, and looking ahead        at length counts to determine sub-table sizes when building the        decoding tables.      */
comment|/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<=
name|MAXBITS
condition|;
name|len
operator|++
control|)
name|count
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
literal|0
init|;
name|sym
operator|<
name|codes
condition|;
name|sym
operator|++
control|)
name|count
index|[
name|lens
index|[
name|sym
index|]
index|]
operator|++
expr_stmt|;
comment|/* bound code lengths, force root to be within code lengths */
name|root
operator|=
operator|*
name|bits
expr_stmt|;
for|for
control|(
name|max
operator|=
name|MAXBITS
init|;
name|max
operator|>=
literal|1
condition|;
name|max
operator|--
control|)
if|if
condition|(
name|count
index|[
name|max
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|root
operator|>
name|max
condition|)
name|root
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
block|{
comment|/* no symbols to code at all */
name|this
operator|.
name|op
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|64
expr_stmt|;
comment|/* invalid code marker */
name|this
operator|.
name|bits
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|1
expr_stmt|;
name|this
operator|.
name|val
operator|=
operator|(
name|unsigned
name|short
operator|)
literal|0
expr_stmt|;
operator|*
operator|(
operator|*
name|table
operator|)
operator|++
operator|=
name|this
expr_stmt|;
comment|/* make a table to force an error */
operator|*
operator|(
operator|*
name|table
operator|)
operator|++
operator|=
name|this
expr_stmt|;
operator|*
name|bits
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* no symbols, but wait for decoding to report error */
block|}
for|for
control|(
name|min
operator|=
literal|1
init|;
name|min
operator|<=
name|MAXBITS
condition|;
name|min
operator|++
control|)
if|if
condition|(
name|count
index|[
name|min
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|root
operator|<
name|min
condition|)
name|root
operator|=
name|min
expr_stmt|;
comment|/* check for an over-subscribed or incomplete set of lengths */
name|left
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<=
name|MAXBITS
condition|;
name|len
operator|++
control|)
block|{
name|left
operator|<<=
literal|1
expr_stmt|;
name|left
operator|-=
name|count
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|left
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* over-subscribed */
block|}
if|if
condition|(
name|left
operator|>
literal|0
operator|&&
operator|(
name|type
operator|==
name|CODES
operator|||
name|max
operator|!=
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* incomplete set */
comment|/* generate offsets into symbol table for each length for sorting */
name|offs
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|1
init|;
name|len
operator|<
name|MAXBITS
condition|;
name|len
operator|++
control|)
name|offs
index|[
name|len
operator|+
literal|1
index|]
operator|=
name|offs
index|[
name|len
index|]
operator|+
name|count
index|[
name|len
index|]
expr_stmt|;
comment|/* sort symbols by length, by symbol order within each length */
for|for
control|(
name|sym
operator|=
literal|0
init|;
name|sym
operator|<
name|codes
condition|;
name|sym
operator|++
control|)
if|if
condition|(
name|lens
index|[
name|sym
index|]
operator|!=
literal|0
condition|)
name|work
index|[
name|offs
index|[
name|lens
index|[
name|sym
index|]
index|]
operator|++
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|sym
expr_stmt|;
comment|/*        Create and fill in decoding tables.  In this loop, the table being        filled is at next and has curr index bits.  The code being used is huff        with length len.  That code is converted to an index by dropping drop        bits off of the bottom.  For codes where len is less than drop + curr,        those top drop + curr - len bits are incremented through all values to        fill the table with replicated entries.         root is the number of index bits for the root table.  When len exceeds        root, sub-tables are created pointed to by the root entry with an index        of the low root bits of huff.  This is saved in low to check for when a        new sub-table should be started.  drop is zero when the root table is        being filled, and drop is root when sub-tables are being filled.         When a new sub-table is needed, it is necessary to look ahead in the        code lengths to determine what size sub-table is needed.  The length        counts are used for this, and so count[] is decremented as codes are        entered in the tables.         used keeps track of how many table entries have been allocated from the        provided *table space.  It is checked when a LENS table is being made        against the space in *table, ENOUGH, minus the maximum space needed by        the worst case distance code, MAXD.  This should never happen, but the        sufficiency of ENOUGH has not been proven exhaustively, hence the check.        This assumes that when type == LENS, bits == 9.         sym increments through all symbols, and the loop terminates when        all codes of length max, i.e. all codes, have been processed.  This        routine permits incomplete codes, so another loop after this one fills        in the rest of the decoding tables with invalid code markers.      */
comment|/* set up for code type */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CODES
case|:
name|base
operator|=
name|extra
operator|=
name|work
expr_stmt|;
comment|/* dummy value--not used */
name|end
operator|=
literal|19
expr_stmt|;
break|break;
case|case
name|LENS
case|:
name|base
operator|=
name|lbase
expr_stmt|;
name|base
operator|-=
literal|257
expr_stmt|;
name|extra
operator|=
name|lext
expr_stmt|;
name|extra
operator|-=
literal|257
expr_stmt|;
name|end
operator|=
literal|256
expr_stmt|;
break|break;
default|default:
comment|/* DISTS */
name|base
operator|=
name|dbase
expr_stmt|;
name|extra
operator|=
name|dext
expr_stmt|;
name|end
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* initialize state for loop */
name|huff
operator|=
literal|0
expr_stmt|;
comment|/* starting code */
name|sym
operator|=
literal|0
expr_stmt|;
comment|/* starting code symbol */
name|len
operator|=
name|min
expr_stmt|;
comment|/* starting code length */
name|next
operator|=
operator|*
name|table
expr_stmt|;
comment|/* current table to fill in */
name|curr
operator|=
name|root
expr_stmt|;
comment|/* current table index bits */
name|drop
operator|=
literal|0
expr_stmt|;
comment|/* current bits to drop from code for index */
name|low
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* trigger new sub-table when len> root */
name|used
operator|=
literal|1U
operator|<<
name|root
expr_stmt|;
comment|/* use root table entries */
name|mask
operator|=
name|used
operator|-
literal|1
expr_stmt|;
comment|/* mask for comparing low */
comment|/* check available table space */
if|if
condition|(
name|type
operator|==
name|LENS
operator|&&
name|used
operator|>=
name|ENOUGH
operator|-
name|MAXD
condition|)
return|return
literal|1
return|;
comment|/* process all codes and make table entries */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* create table entry */
name|this
operator|.
name|bits
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|len
operator|-
name|drop
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|work
index|[
name|sym
index|]
argument_list|)
operator|<
name|end
condition|)
block|{
name|this
operator|.
name|op
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|0
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|work
index|[
name|sym
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|work
index|[
name|sym
index|]
argument_list|)
operator|>
name|end
condition|)
block|{
name|this
operator|.
name|op
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|extra
index|[
name|work
index|[
name|sym
index|]
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|base
index|[
name|work
index|[
name|sym
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|op
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/* end of block */
name|this
operator|.
name|val
operator|=
literal|0
expr_stmt|;
block|}
comment|/* replicate for those indices with low len bits equal to huff */
name|incr
operator|=
literal|1U
operator|<<
operator|(
name|len
operator|-
name|drop
operator|)
expr_stmt|;
name|fill
operator|=
literal|1U
operator|<<
name|curr
expr_stmt|;
do|do
block|{
name|fill
operator|-=
name|incr
expr_stmt|;
name|next
index|[
operator|(
name|huff
operator|>>
name|drop
operator|)
operator|+
name|fill
index|]
operator|=
name|this
expr_stmt|;
block|}
do|while
condition|(
name|fill
operator|!=
literal|0
condition|)
do|;
comment|/* backwards increment the len-bit code huff */
name|incr
operator|=
literal|1U
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|huff
operator|&
name|incr
condition|)
name|incr
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|incr
operator|!=
literal|0
condition|)
block|{
name|huff
operator|&=
name|incr
operator|-
literal|1
expr_stmt|;
name|huff
operator|+=
name|incr
expr_stmt|;
block|}
else|else
name|huff
operator|=
literal|0
expr_stmt|;
comment|/* go to next symbol, update count, len */
name|sym
operator|++
expr_stmt|;
if|if
condition|(
operator|--
operator|(
name|count
index|[
name|len
index|]
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|==
name|max
condition|)
break|break;
name|len
operator|=
name|lens
index|[
name|work
index|[
name|sym
index|]
index|]
expr_stmt|;
block|}
comment|/* create new sub-table if needed */
if|if
condition|(
name|len
operator|>
name|root
operator|&&
operator|(
name|huff
operator|&
name|mask
operator|)
operator|!=
name|low
condition|)
block|{
comment|/* if first time, transition to sub-tables */
if|if
condition|(
name|drop
operator|==
literal|0
condition|)
name|drop
operator|=
name|root
expr_stmt|;
comment|/* increment past last table */
name|next
operator|+=
literal|1U
operator|<<
name|curr
expr_stmt|;
comment|/* determine length of next table */
name|curr
operator|=
name|len
operator|-
name|drop
expr_stmt|;
name|left
operator|=
call|(
name|int
call|)
argument_list|(
literal|1
operator|<<
name|curr
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
operator|+
name|drop
operator|<
name|max
condition|)
block|{
name|left
operator|-=
name|count
index|[
name|curr
operator|+
name|drop
index|]
expr_stmt|;
if|if
condition|(
name|left
operator|<=
literal|0
condition|)
break|break;
name|curr
operator|++
expr_stmt|;
name|left
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* check for enough space */
name|used
operator|+=
literal|1U
operator|<<
name|curr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LENS
operator|&&
name|used
operator|>=
name|ENOUGH
operator|-
name|MAXD
condition|)
return|return
literal|1
return|;
comment|/* point entry in root table to sub-table */
name|low
operator|=
name|huff
operator|&
name|mask
expr_stmt|;
operator|(
operator|*
name|table
operator|)
index|[
name|low
index|]
operator|.
name|op
operator|=
operator|(
name|unsigned
name|char
operator|)
name|curr
expr_stmt|;
operator|(
operator|*
name|table
operator|)
index|[
name|low
index|]
operator|.
name|bits
operator|=
operator|(
name|unsigned
name|char
operator|)
name|root
expr_stmt|;
operator|(
operator|*
name|table
operator|)
index|[
name|low
index|]
operator|.
name|val
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|next
operator|-
operator|*
name|table
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*        Fill in rest of table for incomplete codes.  This loop is similar to the        loop above in incrementing huff for table indices.  It is assumed that        len is equal to curr + drop, so there is no loop needed to increment        through high index bits.  When the current sub-table is filled, the loop        drops back to the root table to fill in any remaining entries there.      */
name|this
operator|.
name|op
operator|=
operator|(
name|unsigned
name|char
operator|)
literal|64
expr_stmt|;
comment|/* invalid code marker */
name|this
operator|.
name|bits
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|len
operator|-
name|drop
argument_list|)
expr_stmt|;
name|this
operator|.
name|val
operator|=
operator|(
name|unsigned
name|short
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|huff
operator|!=
literal|0
condition|)
block|{
comment|/* when done with sub-table, drop back to root table */
if|if
condition|(
name|drop
operator|!=
literal|0
operator|&&
operator|(
name|huff
operator|&
name|mask
operator|)
operator|!=
name|low
condition|)
block|{
name|drop
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|root
expr_stmt|;
name|next
operator|=
operator|*
name|table
expr_stmt|;
name|this
operator|.
name|bits
operator|=
operator|(
name|unsigned
name|char
operator|)
name|len
expr_stmt|;
block|}
comment|/* put invalid code marker in table */
name|next
index|[
name|huff
operator|>>
name|drop
index|]
operator|=
name|this
expr_stmt|;
comment|/* backwards increment the len-bit code huff */
name|incr
operator|=
literal|1U
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|huff
operator|&
name|incr
condition|)
name|incr
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|incr
operator|!=
literal|0
condition|)
block|{
name|huff
operator|&=
name|incr
operator|-
literal|1
expr_stmt|;
name|huff
operator|+=
name|incr
expr_stmt|;
block|}
else|else
name|huff
operator|=
literal|0
expr_stmt|;
block|}
comment|/* set return parameters */
operator|*
name|table
operator|+=
name|used
expr_stmt|;
operator|*
name|bits
operator|=
name|root
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

