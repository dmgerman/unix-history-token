begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* crc32.c -- compute the CRC-32 of a data stream  * Copyright (C) 1995-2003 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  *  * Thanks to Rodney Brown<rbrown64@csc.com.au> for his contribution of faster  * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing  * tables for updating the shift register in one step with three exclusive-ors  * instead of four steps with four exclusive-ors.  This results about a factor  * of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAKECRCH
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DYNAMIC_CRC_TABLE
end_ifndef

begin_define
define|#
directive|define
name|DYNAMIC_CRC_TABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DYNAMIC_CRC_TABLE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKECRCH */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_comment
comment|/* for STDC and FAR definitions */
end_comment

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* Find a four-byte integer type for crc32_little() and crc32_big(). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOBYFOUR
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STDC
end_ifdef

begin_comment
comment|/* need ANSI C limits.h to determine sizes */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|BYFOUR
end_define

begin_if
if|#
directive|if
operator|(
name|UINT_MAX
operator|==
literal|0xffffffffUL
operator|)
end_if

begin_typedef
typedef|typedef
name|unsigned
name|int
name|u4
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|ULONG_MAX
operator|==
literal|0xffffffffUL
operator|)
end_if

begin_typedef
typedef|typedef
name|unsigned
name|long
name|u4
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|USHRT_MAX
operator|==
literal|0xffffffffUL
operator|)
end_if

begin_typedef
typedef|typedef
name|unsigned
name|short
name|u4
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|BYFOUR
end_undef

begin_comment
comment|/* can't find a four-byte integer type! */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NOBYFOUR */
end_comment

begin_comment
comment|/* Definitions for doing the crc four data bytes at a time. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BYFOUR
end_ifdef

begin_define
define|#
directive|define
name|REV
parameter_list|(
name|w
parameter_list|)
value|(((w)>>24)+(((w)>>8)&0xff00)+ \                 (((w)&0xff00)<<8)+(((w)&0xff)<<24))
end_define

begin_decl_stmt
name|local
name|unsigned
name|long
name|crc32_little
name|OF
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|long
name|crc32_big
name|OF
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TBLS
value|8
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TBLS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BYFOUR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC_CRC_TABLE
end_ifdef

begin_decl_stmt
name|local
name|int
name|crc_table_empty
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|long
name|FAR
name|crc_table
index|[
name|TBLS
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|make_crc_table
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAKECRCH
end_ifdef

begin_decl_stmt
name|local
name|void
name|write_table
name|OF
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|unsigned
name|long
name|FAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKECRCH */
end_comment

begin_comment
comment|/*   Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.    Polynomials over GF(2) are represented in binary, one bit per coefficient,   with the lowest powers in the most significant bit.  Then adding polynomials   is just exclusive-or, and multiplying a polynomial by x is a right shift by   one.  If we call the above polynomial p, and represent a byte as the   polynomial q, also with the lowest power in the most significant bit (so the   byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,   where a mod b means the remainder after dividing a by b.    This calculation is done using the shift-register method of multiplying and   taking the remainder.  The register is initialized to zero, and for each   incoming bit, x^32 is added mod p to the register if the bit is a one (where   x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by   x (which is shifting right by one and adding x^32 mod p if the bit shifted   out is a one).  We start with the highest power (least significant bit) of   q and repeat for all eight bits of q.    The first table is simply the CRC of all possible eight bit values.  This is   all the information needed to generate CRCs on data a byte at a time for all   combinations of CRC register values and incoming bytes.  The remaining tables   allow for word-at-a-time CRC calculation for both big-endian and little-   endian machines, where a word is four bytes. */
end_comment

begin_function
name|local
name|void
name|make_crc_table
parameter_list|()
block|{
name|unsigned
name|long
name|c
decl_stmt|;
name|int
name|n
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|long
name|poly
decl_stmt|;
comment|/* polynomial exclusive-or pattern */
comment|/* terms of polynomial defining this crc (except x^32): */
specifier|static
specifier|const
name|unsigned
name|char
name|p
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|16
block|,
literal|22
block|,
literal|23
block|,
literal|26
block|}
decl_stmt|;
comment|/* make exclusive-or pattern from polynomial (0xedb88320UL) */
name|poly
operator|=
literal|0UL
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|p
argument_list|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
condition|;
name|n
operator|++
control|)
name|poly
operator||=
literal|1UL
operator|<<
operator|(
literal|31
operator|-
name|p
index|[
name|n
index|]
operator|)
expr_stmt|;
comment|/* generate a crc for every 8-bit value */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|long
operator|)
name|n
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
name|c
operator|=
name|c
operator|&
literal|1
condition|?
name|poly
operator|^
operator|(
name|c
operator|>>
literal|1
operator|)
else|:
name|c
operator|>>
literal|1
expr_stmt|;
name|crc_table
index|[
literal|0
index|]
index|[
name|n
index|]
operator|=
name|c
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BYFOUR
comment|/* generate crc for each value followed by one, two, and three zeros, and        then the byte reversal of those as well as the first table */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
name|n
index|]
expr_stmt|;
name|crc_table
index|[
literal|4
index|]
index|[
name|n
index|]
operator|=
name|REV
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
name|c
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>
literal|8
operator|)
expr_stmt|;
name|crc_table
index|[
name|k
index|]
index|[
name|n
index|]
operator|=
name|c
expr_stmt|;
name|crc_table
index|[
name|k
operator|+
literal|4
index|]
index|[
name|n
index|]
operator|=
name|REV
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* BYFOUR */
name|crc_table_empty
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MAKECRCH
comment|/* write out CRC tables to crc32.h */
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
name|out
operator|=
name|fopen
argument_list|(
literal|"crc32.h"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"/* crc32.h -- tables for rapid CRC calculation\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" * Generated automatically by crc32.c\n */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"local const unsigned long FAR "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"crc_table[TBLS][256] =\n{\n  {\n"
argument_list|)
expr_stmt|;
name|write_table
argument_list|(
name|out
argument_list|,
name|crc_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYFOUR
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#ifdef BYFOUR\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  },\n  {\n"
argument_list|)
expr_stmt|;
name|write_table
argument_list|(
name|out
argument_list|,
name|crc_table
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BYFOUR */
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  }\n};\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MAKECRCH */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAKECRCH
end_ifdef

begin_function
name|local
name|void
name|write_table
parameter_list|(
name|out
parameter_list|,
name|table
parameter_list|)
name|FILE
modifier|*
name|out
decl_stmt|;
specifier|const
name|unsigned
name|long
name|FAR
modifier|*
name|table
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s0x%08lxUL%s"
argument_list|,
name|n
operator|%
literal|5
condition|?
literal|""
else|:
literal|"    "
argument_list|,
name|table
index|[
name|n
index|]
argument_list|,
name|n
operator|==
literal|255
condition|?
literal|"\n"
else|:
operator|(
name|n
operator|%
literal|5
operator|==
literal|4
condition|?
literal|",\n"
else|:
literal|", "
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKECRCH */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DYNAMIC_CRC_TABLE */
end_comment

begin_comment
comment|/* ========================================================================  * Tables of CRC-32s of all single-byte values, made by make_crc_table().  */
end_comment

begin_include
include|#
directive|include
file|"crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC_CRC_TABLE */
end_comment

begin_comment
comment|/* =========================================================================  * This function can be used by asm versions of crc32()  */
end_comment

begin_function
specifier|const
name|unsigned
name|long
name|FAR
modifier|*
name|ZEXPORT
name|get_crc_table
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DYNAMIC_CRC_TABLE
if|if
condition|(
name|crc_table_empty
condition|)
name|make_crc_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC_CRC_TABLE */
return|return
operator|(
specifier|const
name|unsigned
name|long
name|FAR
operator|*
operator|)
name|crc_table
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_define
define|#
directive|define
name|DO1
value|crc = crc_table[0][((int)crc ^ (*buf++))& 0xff] ^ (crc>> 8)
end_define

begin_define
define|#
directive|define
name|DO8
value|DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|unsigned
name|long
name|ZEXPORT
name|crc32
parameter_list|(
name|crc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|long
name|crc
decl_stmt|;
specifier|const
name|unsigned
name|char
name|FAR
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|==
name|Z_NULL
condition|)
return|return
literal|0UL
return|;
ifdef|#
directive|ifdef
name|DYNAMIC_CRC_TABLE
if|if
condition|(
name|crc_table_empty
condition|)
name|make_crc_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC_CRC_TABLE */
ifdef|#
directive|ifdef
name|BYFOUR
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ptrdiff_t
argument_list|)
condition|)
block|{
name|u4
name|endian
decl_stmt|;
name|endian
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|&
name|endian
operator|)
operator|)
condition|)
return|return
name|crc32_little
argument_list|(
name|crc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|crc32_big
argument_list|(
name|crc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* BYFOUR */
name|crc
operator|=
name|crc
operator|^
literal|0xffffffffUL
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|DO8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
do|do
block|{
name|DO1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
return|return
name|crc
operator|^
literal|0xffffffffUL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BYFOUR
end_ifdef

begin_comment
comment|/* ========================================================================= */
end_comment

begin_define
define|#
directive|define
name|DOLIT4
value|c ^= *buf4++; \         c = crc_table[3][c& 0xff] ^ crc_table[2][(c>> 8)& 0xff] ^ \             crc_table[1][(c>> 16)& 0xff] ^ crc_table[0][c>> 24]
end_define

begin_define
define|#
directive|define
name|DOLIT32
value|DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|local
name|unsigned
name|long
name|crc32_little
parameter_list|(
name|crc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|long
name|crc
decl_stmt|;
specifier|const
name|unsigned
name|char
name|FAR
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
specifier|register
name|u4
name|c
decl_stmt|;
specifier|register
specifier|const
name|u4
name|FAR
modifier|*
name|buf4
decl_stmt|;
name|c
operator|=
operator|(
name|u4
operator|)
name|crc
expr_stmt|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
while|while
condition|(
name|len
operator|&&
operator|(
operator|(
name|ptrdiff_t
operator|)
name|buf
operator|&
literal|3
operator|)
condition|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
operator|(
name|c
operator|^
operator|*
name|buf
operator|++
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>
literal|8
operator|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|buf4
operator|=
operator|(
specifier|const
name|u4
name|FAR
operator|*
operator|)
name|buf
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|32
condition|)
block|{
name|DOLIT32
expr_stmt|;
name|len
operator|-=
literal|32
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|DOLIT4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
name|buf
operator|=
operator|(
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|)
name|buf4
expr_stmt|;
if|if
condition|(
name|len
condition|)
do|do
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
operator|(
name|c
operator|^
operator|*
name|buf
operator|++
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
return|return
operator|(
name|unsigned
name|long
operator|)
name|c
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_define
define|#
directive|define
name|DOBIG4
value|c ^= *++buf4; \         c = crc_table[4][c& 0xff] ^ crc_table[5][(c>> 8)& 0xff] ^ \             crc_table[6][(c>> 16)& 0xff] ^ crc_table[7][c>> 24]
end_define

begin_define
define|#
directive|define
name|DOBIG32
value|DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|local
name|unsigned
name|long
name|crc32_big
parameter_list|(
name|crc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|long
name|crc
decl_stmt|;
specifier|const
name|unsigned
name|char
name|FAR
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
specifier|register
name|u4
name|c
decl_stmt|;
specifier|register
specifier|const
name|u4
name|FAR
modifier|*
name|buf4
decl_stmt|;
name|c
operator|=
name|REV
argument_list|(
operator|(
name|u4
operator|)
name|crc
argument_list|)
expr_stmt|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
while|while
condition|(
name|len
operator|&&
operator|(
operator|(
name|ptrdiff_t
operator|)
name|buf
operator|&
literal|3
operator|)
condition|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|4
index|]
index|[
operator|(
name|c
operator|>>
literal|24
operator|)
operator|^
operator|*
name|buf
operator|++
index|]
operator|^
operator|(
name|c
operator|<<
literal|8
operator|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|buf4
operator|=
operator|(
specifier|const
name|u4
name|FAR
operator|*
operator|)
name|buf
expr_stmt|;
name|buf4
operator|--
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|32
condition|)
block|{
name|DOBIG32
expr_stmt|;
name|len
operator|-=
literal|32
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|DOBIG4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
name|buf4
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|)
name|buf4
expr_stmt|;
if|if
condition|(
name|len
condition|)
do|do
block|{
name|c
operator|=
name|crc_table
index|[
literal|4
index|]
index|[
operator|(
name|c
operator|>>
literal|24
operator|)
operator|^
operator|*
name|buf
operator|++
index|]
operator|^
operator|(
name|c
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
name|REV
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BYFOUR */
end_comment

end_unit

