begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzio.c -- IO on .gz files  * Copyright (C) 1995-1996 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/* $Id: gzio.c,v 1.14 1996/07/24 13:41:01 me Exp $ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_struct
struct|struct
name|internal_state
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for buggy compilers */
end_comment

begin_define
define|#
directive|define
name|Z_BUFSIZE
value|4096
end_define

begin_define
define|#
directive|define
name|ALLOC
parameter_list|(
name|size
parameter_list|)
value|malloc(size)
end_define

begin_define
define|#
directive|define
name|TRYFREE
parameter_list|(
name|p
parameter_list|)
value|{if (p) free(p);}
end_define

begin_decl_stmt
specifier|static
name|int
name|gz_magic
index|[
literal|2
index|]
init|=
block|{
literal|0x1f
block|,
literal|0x8b
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gzip magic header */
end_comment

begin_comment
comment|/* gzip flag byte */
end_comment

begin_define
define|#
directive|define
name|ASCII_FLAG
value|0x01
end_define

begin_comment
comment|/* bit 0 set: file probably ascii text */
end_comment

begin_define
define|#
directive|define
name|HEAD_CRC
value|0x02
end_define

begin_comment
comment|/* bit 1 set: header CRC present */
end_comment

begin_define
define|#
directive|define
name|EXTRA_FIELD
value|0x04
end_define

begin_comment
comment|/* bit 2 set: extra field present */
end_comment

begin_define
define|#
directive|define
name|ORIG_NAME
value|0x08
end_define

begin_comment
comment|/* bit 3 set: original file name present */
end_comment

begin_define
define|#
directive|define
name|COMMENT
value|0x10
end_define

begin_comment
comment|/* bit 4 set: file comment present */
end_comment

begin_define
define|#
directive|define
name|RESERVED
value|0xE0
end_define

begin_comment
comment|/* bits 5..7: reserved */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gz_stream
block|{
name|z_stream
name|stream
decl_stmt|;
name|int
name|z_err
decl_stmt|;
comment|/* error code for last stream operation */
name|int
name|z_eof
decl_stmt|;
comment|/* set if end of input file */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* .gz file */
name|Byte
modifier|*
name|inbuf
decl_stmt|;
comment|/* input buffer */
name|Byte
modifier|*
name|outbuf
decl_stmt|;
comment|/* output buffer */
name|uLong
name|crc
decl_stmt|;
comment|/* crc32 of uncompressed data */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* error message */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path name for debugging only */
name|int
name|transparent
decl_stmt|;
comment|/* 1 if input file is not a .gz file */
name|char
name|mode
decl_stmt|;
comment|/* 'w' or 'r' */
block|}
name|gz_stream
typedef|;
end_typedef

begin_decl_stmt
name|local
name|gzFile
name|gz_open
name|OF
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|path
operator|,
specifier|const
name|char
operator|*
name|mode
operator|,
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|get_byte
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|check_header
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|destroy
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|putLong
name|OF
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
name|uLong
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|uLong
name|getLong
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ===========================================================================      Opens a gzip (.gz) file for reading or writing. The mode parameter    is as in fopen ("rb" or "wb"). The file is given either by file descriptor    or path name (if fd == -1).      gz_open return NULL if the file could not be opened or if there was    insufficient memory to allocate the (de)compression state; errno    can be checked to distinguish the two cases (if errno is zero, the    zlib error is Z_MEM_ERROR). */
end_comment

begin_function
name|local
name|gzFile
name|gz_open
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|,
name|fd
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|int
name|level
init|=
name|Z_DEFAULT_COMPRESSION
decl_stmt|;
comment|/* compression level */
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|mode
decl_stmt|;
name|gz_stream
modifier|*
name|s
decl_stmt|;
name|char
name|fmode
index|[
literal|80
index|]
decl_stmt|;
comment|/* copy of mode, without the compression level */
name|char
modifier|*
name|m
init|=
name|fmode
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|!
name|mode
condition|)
return|return
name|Z_NULL
return|;
name|s
operator|=
operator|(
name|gz_stream
operator|*
operator|)
name|ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|gz_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|Z_NULL
return|;
name|s
operator|->
name|stream
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|z_err
operator|=
name|Z_OK
expr_stmt|;
name|s
operator|->
name|z_eof
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|transparent
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ALLOC
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
name|strcpy
argument_list|(
name|s
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* do this early for debugging */
name|s
operator|->
name|mode
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
name|s
operator|->
name|mode
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'w'
operator|||
operator|*
name|p
operator|==
literal|'a'
condition|)
name|s
operator|->
name|mode
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|level
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|m
operator|++
operator|=
operator|*
name|p
expr_stmt|;
comment|/* copy the mode */
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|&&
name|m
operator|!=
name|fmode
operator|+
sizeof|sizeof
argument_list|(
name|fmode
argument_list|)
condition|)
do|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'\0'
condition|)
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
name|err
operator|=
name|deflateInit2
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
name|MAX_WBITS
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* windowBits is passed< 0 to suppress zlib header */
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ALLOC
argument_list|(
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
operator|||
name|s
operator|->
name|outbuf
operator|==
name|Z_NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|inflateInit2
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
operator|-
name|MAX_WBITS
argument_list|)
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ALLOC
argument_list|(
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
operator|||
name|s
operator|->
name|inbuf
operator|==
name|Z_NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
block|}
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|fd
operator|<
literal|0
condition|?
name|FOPEN
argument_list|(
name|path
argument_list|,
name|fmode
argument_list|)
else|:
operator|(
name|FILE
operator|*
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|fmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
comment|/* Write a very simple .gz header:          */
name|fprintf
argument_list|(
name|s
operator|->
name|file
argument_list|,
literal|"%c%c%c%c%c%c%c%c%c%c"
argument_list|,
name|gz_magic
index|[
literal|0
index|]
argument_list|,
name|gz_magic
index|[
literal|1
index|]
argument_list|,
name|Z_DEFLATED
argument_list|,
literal|0
comment|/*flags*/
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
comment|/*time*/
argument_list|,
literal|0
comment|/*xflags*/
argument_list|,
name|OS_CODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check_header
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* skip the .gz header */
block|}
return|return
operator|(
name|gzFile
operator|)
name|s
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Opens a gzip (.gz) file for reading or writing. */
end_comment

begin_function
name|gzFile
name|gzopen
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
return|return
name|gz_open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Associate a gzFile with the file descriptor fd. fd is not dup'ed here    to mimic the behavio(u)r of fdopen. */
end_comment

begin_function
name|gzFile
name|gzdopen
parameter_list|(
name|fd
parameter_list|,
name|mode
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"<fd:%d>"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* for debugging */
return|return
name|gz_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|,
name|fd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Read a byte from a gz_stream; update next_in and avail_in. Return EOF    for end of file.    IN assertion: the stream s has been sucessfully opened for reading. */
end_comment

begin_function
name|local
name|int
name|get_byte
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|z_eof
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|s
operator|->
name|inbuf
argument_list|,
literal|1
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|z_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|)
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
expr_stmt|;
block|}
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|--
expr_stmt|;
return|return
operator|*
operator|(
name|s
operator|->
name|stream
operator|.
name|next_in
operator|)
operator|++
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================       Check the gzip header of a gz_stream opened for reading. Set the stream     mode to transparent if the gzip magic header is not present; set s->err     to Z_DATA_ERROR if the magic header is present but the rest of the header     is incorrect.     IN assertion: the stream s has already been created sucessfully;        s->stream.avail_in is zero for the first time, but may be non-zero        for concatenated .gz files. */
end_comment

begin_function
name|local
name|void
name|check_header
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|method
decl_stmt|;
comment|/* method byte */
name|int
name|flags
decl_stmt|;
comment|/* flags byte */
name|uInt
name|len
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Check the gzip magic header */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|2
condition|;
name|len
operator|++
control|)
block|{
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|gz_magic
index|[
name|len
index|]
condition|)
block|{
name|s
operator|->
name|transparent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|++
operator|,
name|s
operator|->
name|stream
operator|.
name|next_in
operator|--
expr_stmt|;
name|s
operator|->
name|z_err
operator|=
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|!=
literal|0
condition|?
name|Z_OK
else|:
name|Z_STREAM_END
expr_stmt|;
return|return;
block|}
block|}
name|method
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|flags
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|!=
name|Z_DEFLATED
operator|||
operator|(
name|flags
operator|&
name|RESERVED
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_DATA_ERROR
expr_stmt|;
return|return;
block|}
comment|/* Discard time, xflags and OS code: */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|6
condition|;
name|len
operator|++
control|)
operator|(
name|void
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|EXTRA_FIELD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the extra field */
name|len
operator|=
operator|(
name|uInt
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|uInt
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* len is garbage if EOF but the loop below will quit anyway */
while|while
condition|(
name|len
operator|--
operator|!=
literal|0
operator|&&
name|get_byte
argument_list|(
name|s
argument_list|)
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ORIG_NAME
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the original file name */
while|while
condition|(
operator|(
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|COMMENT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the .gz file comment */
while|while
condition|(
operator|(
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|HEAD_CRC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the header crc */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|2
condition|;
name|len
operator|++
control|)
operator|(
name|void
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|s
operator|->
name|z_eof
condition|?
name|Z_DATA_ERROR
else|:
name|Z_OK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Cleanup then free the given gz_stream. Return a zlib error code.    Try freeing in the reverse order of allocations.  */
end_comment

begin_function
name|local
name|int
name|destroy
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|state
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
name|err
operator|=
name|deflateEnd
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'r'
condition|)
block|{
name|err
operator|=
name|inflateEnd
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|file
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|)
block|{
name|err
operator|=
name|Z_ERRNO
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|z_err
operator|<
literal|0
condition|)
name|err
operator|=
name|s
operator|->
name|z_err
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|inbuf
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|outbuf
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|path
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Reads the given number of uncompressed bytes from the compressed file.    gzread returns the number of bytes actually read (0 for end of file). */
end_comment

begin_function
name|int
name|gzread
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
name|Bytef
modifier|*
name|start
init|=
name|buf
decl_stmt|;
comment|/* starting point for crc computation */
name|Byte
modifier|*
name|next_out
decl_stmt|;
comment|/* == stream.next_out but not forced far (for MSDOS) */
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'r'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_DATA_ERROR
operator|||
name|s
operator|->
name|z_err
operator|==
name|Z_ERRNO
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|)
return|return
literal|0
return|;
comment|/* EOF */
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|next_out
operator|=
name|buf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|transparent
condition|)
block|{
comment|/* Copy first the lookahead bytes: */
name|uInt
name|n
init|=
name|s
operator|->
name|stream
operator|.
name|avail_in
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|s
operator|->
name|stream
operator|.
name|avail_out
condition|)
name|n
operator|=
name|s
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|zmemcpy
argument_list|(
name|s
operator|->
name|stream
operator|.
name|next_out
argument_list|,
name|s
operator|->
name|stream
operator|.
name|next_in
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|next_out
operator|+=
name|n
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|next_out
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|+=
name|n
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|-=
name|n
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|-=
name|fread
argument_list|(
name|next_out
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|stream
operator|.
name|avail_out
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_out
argument_list|)
return|;
block|}
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
operator|&&
operator|!
name|s
operator|->
name|z_eof
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|s
operator|->
name|inbuf
argument_list|,
literal|1
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|z_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|inflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|)
block|{
comment|/* Check CRC and original size */
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|s
operator|->
name|crc
argument_list|,
name|start
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|s
operator|->
name|stream
operator|.
name|next_out
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|s
operator|->
name|stream
operator|.
name|next_out
expr_stmt|;
if|if
condition|(
name|getLong
argument_list|(
name|s
argument_list|)
operator|!=
name|s
operator|->
name|crc
operator|||
name|getLong
argument_list|(
name|s
argument_list|)
operator|!=
name|s
operator|->
name|stream
operator|.
name|total_out
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_DATA_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|/* Check for concatenated .gz files: */
name|check_header
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_OK
condition|)
block|{
name|inflateReset
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
operator|||
name|s
operator|->
name|z_eof
condition|)
break|break;
block|}
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|s
operator|->
name|crc
argument_list|,
name|start
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|s
operator|->
name|stream
operator|.
name|next_out
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_out
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Writes the given number of uncompressed bytes into the compressed file.    gzwrite returns the number of bytes actually written (0 in case of error). */
end_comment

begin_function
name|int
name|gzwrite
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
specifier|const
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|buf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|s
operator|->
name|outbuf
argument_list|,
literal|1
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|s
operator|->
name|file
argument_list|)
operator|!=
name|Z_BUFSIZE
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|deflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
condition|)
break|break;
block|}
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|s
operator|->
name|crc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_in
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Flushes all pending output into the compressed file. The parameter    flush is as in the deflate() function.      gzflush should be called only when strictly necessary because it can    degrade compression. */
end_comment

begin_function
name|int
name|gzflush
parameter_list|(
name|file
parameter_list|,
name|flush
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|uInt
name|len
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* should be zero already anyway */
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|Z_BUFSIZE
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|uInt
operator|)
name|fwrite
argument_list|(
name|s
operator|->
name|outbuf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|s
operator|->
name|file
argument_list|)
operator|!=
name|len
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
return|return
name|Z_ERRNO
return|;
block|}
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
break|break;
name|s
operator|->
name|z_err
operator|=
name|deflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|flush
argument_list|)
expr_stmt|;
comment|/* deflate has finished flushing only when it hasn't used up          * all the available space in the output buffer:           */
name|done
operator|=
operator|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|!=
literal|0
operator|||
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
operator|&&
name|s
operator|->
name|z_err
operator|!=
name|Z_STREAM_END
condition|)
break|break;
block|}
name|fflush
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|?
name|Z_OK
else|:
name|s
operator|->
name|z_err
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================    Outputs a long in LSB order to the given file */
end_comment

begin_function
name|local
name|void
name|putLong
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|uLong
name|x
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|fputc
argument_list|(
call|(
name|int
call|)
argument_list|(
name|x
operator|&
literal|0xff
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|x
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================    Reads a long in LSB order from the given gz_stream. Sets  */
end_comment

begin_function
name|local
name|uLong
name|getLong
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
name|uLong
name|x
init|=
operator|(
name|uLong
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
name|x
operator|+=
operator|(
operator|(
name|uLong
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
name|x
operator|+=
operator|(
operator|(
name|uLong
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|<<
literal|16
expr_stmt|;
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|s
operator|->
name|z_err
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|x
operator|+=
operator|(
operator|(
name|uLong
operator|)
name|c
operator|)
operator|<<
literal|24
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Flushes all pending output if necessary, closes the compressed file    and deallocates all the (de)compression state. */
end_comment

begin_function
name|int
name|gzclose
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
name|err
operator|=
name|gzflush
argument_list|(
name|file
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|destroy
argument_list|(
name|file
argument_list|)
return|;
name|putLong
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|crc
argument_list|)
expr_stmt|;
name|putLong
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|stream
operator|.
name|total_in
argument_list|)
expr_stmt|;
block|}
return|return
name|destroy
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Returns the error message for the last error which occured on the    given compressed file. errnum is set to zlib error number. If an    error occured in the file system and not in the compression library,    errnum is set to Z_ERRNO and the application may consult errno    to get the exact error code. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gzerror
parameter_list|(
name|file
parameter_list|,
name|errnum
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
modifier|*
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|m
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
operator|*
name|errnum
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|ERR_MSG
argument_list|(
name|Z_STREAM_ERROR
argument_list|)
return|;
block|}
operator|*
name|errnum
operator|=
name|s
operator|->
name|z_err
expr_stmt|;
if|if
condition|(
operator|*
name|errnum
operator|==
name|Z_OK
condition|)
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
literal|""
return|;
name|m
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|errnum
operator|==
name|Z_ERRNO
condition|?
name|zstrerror
argument_list|(
name|errno
argument_list|)
else|:
name|s
operator|->
name|stream
operator|.
name|msg
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|*
name|m
operator|==
literal|'\0'
condition|)
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|ERR_MSG
argument_list|(
name|s
operator|->
name|z_err
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|msg
argument_list|)
expr_stmt|;
name|s
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|ALLOC
argument_list|(
name|strlen
argument_list|(
name|s
operator|->
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|m
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|->
name|msg
argument_list|,
name|s
operator|->
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
operator|->
name|msg
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
operator|->
name|msg
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|->
name|msg
return|;
block|}
end_function

end_unit

