begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzio.c -- IO on .gz files  * Copyright (C) 1995-1998 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h  *  * Compile this file with -DNO_DEFLATE to avoid the compression code.  */
end_comment

begin_comment
comment|/* @(#) $Id$ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_struct
struct|struct
name|internal_state
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for buggy compilers */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|Z_BUFSIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAXSEG_64K
end_ifdef

begin_define
define|#
directive|define
name|Z_BUFSIZE
value|4096
end_define

begin_comment
comment|/* minimize memory usage for 16-bit DOS */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Z_BUFSIZE
value|16384
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Z_PRINTF_BUFSIZE
end_ifndef

begin_define
define|#
directive|define
name|Z_PRINTF_BUFSIZE
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ALLOC
parameter_list|(
name|size
parameter_list|)
value|malloc(size)
end_define

begin_define
define|#
directive|define
name|TRYFREE
parameter_list|(
name|p
parameter_list|)
value|{if (p) free(p);}
end_define

begin_decl_stmt
specifier|static
name|int
name|gz_magic
index|[
literal|2
index|]
init|=
block|{
literal|0x1f
block|,
literal|0x8b
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gzip magic header */
end_comment

begin_comment
comment|/* gzip flag byte */
end_comment

begin_define
define|#
directive|define
name|ASCII_FLAG
value|0x01
end_define

begin_comment
comment|/* bit 0 set: file probably ascii text */
end_comment

begin_define
define|#
directive|define
name|HEAD_CRC
value|0x02
end_define

begin_comment
comment|/* bit 1 set: header CRC present */
end_comment

begin_define
define|#
directive|define
name|EXTRA_FIELD
value|0x04
end_define

begin_comment
comment|/* bit 2 set: extra field present */
end_comment

begin_define
define|#
directive|define
name|ORIG_NAME
value|0x08
end_define

begin_comment
comment|/* bit 3 set: original file name present */
end_comment

begin_define
define|#
directive|define
name|COMMENT
value|0x10
end_define

begin_comment
comment|/* bit 4 set: file comment present */
end_comment

begin_define
define|#
directive|define
name|RESERVED
value|0xE0
end_define

begin_comment
comment|/* bits 5..7: reserved */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gz_stream
block|{
name|z_stream
name|stream
decl_stmt|;
name|int
name|z_err
decl_stmt|;
comment|/* error code for last stream operation */
name|int
name|z_eof
decl_stmt|;
comment|/* set if end of input file */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* .gz file */
name|Byte
modifier|*
name|inbuf
decl_stmt|;
comment|/* input buffer */
name|Byte
modifier|*
name|outbuf
decl_stmt|;
comment|/* output buffer */
name|uLong
name|crc
decl_stmt|;
comment|/* crc32 of uncompressed data */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* error message */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path name for debugging only */
name|int
name|transparent
decl_stmt|;
comment|/* 1 if input file is not a .gz file */
name|char
name|mode
decl_stmt|;
comment|/* 'w' or 'r' */
name|long
name|startpos
decl_stmt|;
comment|/* start of compressed data in file (header skipped) */
block|}
name|gz_stream
typedef|;
end_typedef

begin_decl_stmt
name|local
name|gzFile
name|gz_open
name|OF
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|path
operator|,
specifier|const
name|char
operator|*
name|mode
operator|,
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|do_flush
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|get_byte
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|check_header
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|destroy
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|putLong
name|OF
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
name|uLong
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|uLong
name|getLong
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ===========================================================================      Opens a gzip (.gz) file for reading or writing. The mode parameter    is as in fopen ("rb" or "wb"). The file is given either by file descriptor    or path name (if fd == -1).      gz_open return NULL if the file could not be opened or if there was    insufficient memory to allocate the (de)compression state; errno    can be checked to distinguish the two cases (if errno is zero, the    zlib error is Z_MEM_ERROR). */
end_comment

begin_function
name|local
name|gzFile
name|gz_open
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|,
name|fd
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|int
name|level
init|=
name|Z_DEFAULT_COMPRESSION
decl_stmt|;
comment|/* compression level */
name|int
name|strategy
init|=
name|Z_DEFAULT_STRATEGY
decl_stmt|;
comment|/* compression strategy */
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|mode
decl_stmt|;
name|gz_stream
modifier|*
name|s
decl_stmt|;
name|char
name|fmode
index|[
literal|80
index|]
decl_stmt|;
comment|/* copy of mode, without the compression level */
name|char
modifier|*
name|m
init|=
name|fmode
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|!
name|mode
condition|)
return|return
name|Z_NULL
return|;
name|s
operator|=
operator|(
name|gz_stream
operator|*
operator|)
name|ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|gz_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|Z_NULL
return|;
name|s
operator|->
name|stream
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|z_err
operator|=
name|Z_OK
expr_stmt|;
name|s
operator|->
name|z_eof
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|transparent
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ALLOC
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
name|strcpy
argument_list|(
name|s
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* do this early for debugging */
name|s
operator|->
name|mode
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
name|s
operator|->
name|mode
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'w'
operator|||
operator|*
name|p
operator|==
literal|'a'
condition|)
name|s
operator|->
name|mode
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|level
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'f'
condition|)
block|{
name|strategy
operator|=
name|Z_FILTERED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'h'
condition|)
block|{
name|strategy
operator|=
name|Z_HUFFMAN_ONLY
expr_stmt|;
block|}
else|else
block|{
operator|*
name|m
operator|++
operator|=
operator|*
name|p
expr_stmt|;
comment|/* copy the mode */
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|&&
name|m
operator|!=
name|fmode
operator|+
sizeof|sizeof
argument_list|(
name|fmode
argument_list|)
condition|)
do|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'\0'
condition|)
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_DEFLATE
name|err
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|deflateInit2
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
name|MAX_WBITS
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
comment|/* windowBits is passed< 0 to suppress zlib header */
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ALLOC
argument_list|(
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
operator|!=
name|Z_OK
operator|||
name|s
operator|->
name|outbuf
operator|==
name|Z_NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
block|}
else|else
block|{
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ALLOC
argument_list|(
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
name|err
operator|=
name|inflateInit2
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
operator|-
name|MAX_WBITS
argument_list|)
expr_stmt|;
comment|/* windowBits is passed< 0 to tell that there is no zlib header.          * Note that in this case inflate *requires* an extra "dummy" byte          * after the compressed stream in order to complete decompression and          * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are          * present after the compressed stream.          */
if|if
condition|(
name|err
operator|!=
name|Z_OK
operator|||
name|s
operator|->
name|inbuf
operator|==
name|Z_NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
block|}
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|fd
operator|<
literal|0
condition|?
name|F_OPEN
argument_list|(
name|path
argument_list|,
name|fmode
argument_list|)
else|:
operator|(
name|FILE
operator|*
operator|)
name|fdopen
argument_list|(
name|fd
argument_list|,
name|fmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
comment|/* Write a very simple .gz header:          */
name|fprintf
argument_list|(
name|s
operator|->
name|file
argument_list|,
literal|"%c%c%c%c%c%c%c%c%c%c"
argument_list|,
name|gz_magic
index|[
literal|0
index|]
argument_list|,
name|gz_magic
index|[
literal|1
index|]
argument_list|,
name|Z_DEFLATED
argument_list|,
literal|0
comment|/*flags*/
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
comment|/*time*/
argument_list|,
literal|0
comment|/*xflags*/
argument_list|,
name|OS_CODE
argument_list|)
expr_stmt|;
name|s
operator|->
name|startpos
operator|=
literal|10L
expr_stmt|;
comment|/* We use 10L instead of ftell(s->file) to because ftell causes an          * fflush on some systems. This version of the library doesn't use          * startpos anyway in write mode, so this initialization is not          * necessary.          */
block|}
else|else
block|{
name|check_header
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* skip the .gz header */
name|s
operator|->
name|startpos
operator|=
operator|(
name|ftell
argument_list|(
name|s
operator|->
name|file
argument_list|)
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|gzFile
operator|)
name|s
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Opens a gzip (.gz) file for reading or writing. */
end_comment

begin_function
name|gzFile
name|ZEXPORT
name|gzopen
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
return|return
name|gz_open
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Associate a gzFile with the file descriptor fd. fd is not dup'ed here    to mimic the behavio(u)r of fdopen. */
end_comment

begin_function
name|gzFile
name|ZEXPORT
name|gzdopen
parameter_list|(
name|fd
parameter_list|,
name|mode
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"<fd:%d>"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* for debugging */
return|return
name|gz_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|,
name|fd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Update the compression level and strategy  */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzsetparams
parameter_list|(
name|file
parameter_list|,
name|level
parameter_list|,
name|strategy
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|strategy
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* Make room to allow flushing */
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|s
operator|->
name|outbuf
argument_list|,
literal|1
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|s
operator|->
name|file
argument_list|)
operator|!=
name|Z_BUFSIZE
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
block|}
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
block|}
return|return
name|deflateParams
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|level
argument_list|,
name|strategy
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Read a byte from a gz_stream; update next_in and avail_in. Return EOF    for end of file.    IN assertion: the stream s has been sucessfully opened for reading. */
end_comment

begin_function
name|local
name|int
name|get_byte
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|z_eof
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|s
operator|->
name|inbuf
argument_list|,
literal|1
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|z_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|)
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
expr_stmt|;
block|}
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|--
expr_stmt|;
return|return
operator|*
operator|(
name|s
operator|->
name|stream
operator|.
name|next_in
operator|)
operator|++
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================       Check the gzip header of a gz_stream opened for reading. Set the stream     mode to transparent if the gzip magic header is not present; set s->err     to Z_DATA_ERROR if the magic header is present but the rest of the header     is incorrect.     IN assertion: the stream s has already been created sucessfully;        s->stream.avail_in is zero for the first time, but may be non-zero        for concatenated .gz files. */
end_comment

begin_function
name|local
name|void
name|check_header
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|method
decl_stmt|;
comment|/* method byte */
name|int
name|flags
decl_stmt|;
comment|/* flags byte */
name|uInt
name|len
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Check the gzip magic header */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|2
condition|;
name|len
operator|++
control|)
block|{
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|gz_magic
index|[
name|len
index|]
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|++
operator|,
name|s
operator|->
name|stream
operator|.
name|next_in
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|++
operator|,
name|s
operator|->
name|stream
operator|.
name|next_in
operator|--
expr_stmt|;
name|s
operator|->
name|transparent
operator|=
literal|1
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|!=
literal|0
condition|?
name|Z_OK
else|:
name|Z_STREAM_END
expr_stmt|;
return|return;
block|}
block|}
name|method
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|flags
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|!=
name|Z_DEFLATED
operator|||
operator|(
name|flags
operator|&
name|RESERVED
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_DATA_ERROR
expr_stmt|;
return|return;
block|}
comment|/* Discard time, xflags and OS code: */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|6
condition|;
name|len
operator|++
control|)
operator|(
name|void
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|EXTRA_FIELD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the extra field */
name|len
operator|=
operator|(
name|uInt
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|uInt
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* len is garbage if EOF but the loop below will quit anyway */
while|while
condition|(
name|len
operator|--
operator|!=
literal|0
operator|&&
name|get_byte
argument_list|(
name|s
argument_list|)
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ORIG_NAME
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the original file name */
while|while
condition|(
operator|(
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|COMMENT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the .gz file comment */
while|while
condition|(
operator|(
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|HEAD_CRC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* skip the header crc */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|2
condition|;
name|len
operator|++
control|)
operator|(
name|void
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|s
operator|->
name|z_eof
condition|?
name|Z_DATA_ERROR
else|:
name|Z_OK
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Cleanup then free the given gz_stream. Return a zlib error code.    Try freeing in the reverse order of allocations.  */
end_comment

begin_function
name|local
name|int
name|destroy
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|state
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_DEFLATE
name|err
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|deflateEnd
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'r'
condition|)
block|{
name|err
operator|=
name|inflateEnd
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|file
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ESPIPE
if|if
condition|(
name|errno
operator|!=
name|ESPIPE
condition|)
comment|/* fclose is broken for pipes in HP/UX */
endif|#
directive|endif
name|err
operator|=
name|Z_ERRNO
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|z_err
operator|<
literal|0
condition|)
name|err
operator|=
name|s
operator|->
name|z_err
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|inbuf
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|outbuf
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|path
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Reads the given number of uncompressed bytes from the compressed file.    gzread returns the number of bytes actually read (0 for end of file). */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzread
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
name|Bytef
modifier|*
name|start
init|=
operator|(
name|Bytef
operator|*
operator|)
name|buf
decl_stmt|;
comment|/* starting point for crc computation */
name|Byte
modifier|*
name|next_out
decl_stmt|;
comment|/* == stream.next_out but not forced far (for MSDOS) */
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'r'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_DATA_ERROR
operator|||
name|s
operator|->
name|z_err
operator|==
name|Z_ERRNO
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|)
return|return
literal|0
return|;
comment|/* EOF */
name|next_out
operator|=
operator|(
name|Byte
operator|*
operator|)
name|buf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|buf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|transparent
condition|)
block|{
comment|/* Copy first the lookahead bytes: */
name|uInt
name|n
init|=
name|s
operator|->
name|stream
operator|.
name|avail_in
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|s
operator|->
name|stream
operator|.
name|avail_out
condition|)
name|n
operator|=
name|s
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|zmemcpy
argument_list|(
name|s
operator|->
name|stream
operator|.
name|next_out
argument_list|,
name|s
operator|->
name|stream
operator|.
name|next_in
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|next_out
operator|+=
name|n
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|next_out
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|+=
name|n
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|-=
name|n
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|-=
name|fread
argument_list|(
name|next_out
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|stream
operator|.
name|avail_out
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|s
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|total_in
operator|+=
operator|(
name|uLong
operator|)
name|len
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|total_out
operator|+=
operator|(
name|uLong
operator|)
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|s
operator|->
name|z_eof
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
operator|&&
operator|!
name|s
operator|->
name|z_eof
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|fread
argument_list|(
name|s
operator|->
name|inbuf
argument_list|,
literal|1
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|z_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|s
operator|->
name|file
argument_list|)
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|inflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|)
block|{
comment|/* Check CRC and original size */
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|s
operator|->
name|crc
argument_list|,
name|start
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|s
operator|->
name|stream
operator|.
name|next_out
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|s
operator|->
name|stream
operator|.
name|next_out
expr_stmt|;
if|if
condition|(
name|getLong
argument_list|(
name|s
argument_list|)
operator|!=
name|s
operator|->
name|crc
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_DATA_ERROR
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|getLong
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* The uncompressed length returned by above getlong() may                  * be different from s->stream.total_out) in case of 		 * concatenated .gz files. Check for such files: 		 */
name|check_header
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|==
name|Z_OK
condition|)
block|{
name|uLong
name|total_in
init|=
name|s
operator|->
name|stream
operator|.
name|total_in
decl_stmt|;
name|uLong
name|total_out
init|=
name|s
operator|->
name|stream
operator|.
name|total_out
decl_stmt|;
name|inflateReset
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|total_in
operator|=
name|total_in
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|total_out
operator|=
name|total_out
expr_stmt|;
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
operator|||
name|s
operator|->
name|z_eof
condition|)
break|break;
block|}
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|s
operator|->
name|crc
argument_list|,
name|start
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|s
operator|->
name|stream
operator|.
name|next_out
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_out
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================       Reads one byte from the compressed file. gzgetc returns this byte    or -1 in case of end of file or error. */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzgetc
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|unsigned
name|char
name|c
decl_stmt|;
return|return
name|gzread
argument_list|(
name|file
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|?
name|c
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================       Reads bytes from the compressed file until len-1 characters are    read, or a newline character is read and transferred to buf, or an    end-of-file condition is encountered.  The string is then terminated    with a null character.       gzgets returns buf, or Z_NULL in case of error.        The current implementation is not optimized at all. */
end_comment

begin_function
name|char
modifier|*
name|ZEXPORT
name|gzgets
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|Z_NULL
operator|||
name|len
operator|<=
literal|0
condition|)
return|return
name|Z_NULL
return|;
while|while
condition|(
operator|--
name|len
operator|>
literal|0
operator|&&
name|gzread
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|buf
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|b
operator|==
name|buf
operator|&&
name|len
operator|>
literal|0
condition|?
name|Z_NULL
else|:
name|b
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DEFLATE
end_ifndef

begin_comment
comment|/* ===========================================================================      Writes the given number of uncompressed bytes into the compressed file.    gzwrite returns the number of bytes actually written (0 in case of error). */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzwrite
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
specifier|const
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|buf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|s
operator|->
name|outbuf
argument_list|,
literal|1
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|s
operator|->
name|file
argument_list|)
operator|!=
name|Z_BUFSIZE
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|deflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
condition|)
break|break;
block|}
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
name|s
operator|->
name|crc
argument_list|,
operator|(
specifier|const
name|Bytef
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_in
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Converts, formats, and writes the args to the compressed file under    control of the format string, as in fprintf. gzprintf returns the number of    uncompressed bytes actually written (0 in case of error). */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDC
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_function
name|int
name|ZEXPORTVA
name|gzprintf
parameter_list|(
name|gzFile
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
comment|/* args */
modifier|...
parameter_list|)
block|{
name|char
name|buf
index|[
name|Z_PRINTF_BUFSIZE
index|]
decl_stmt|;
name|va_list
name|va
decl_stmt|;
name|int
name|len
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_vsnprintf
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|va
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|format
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* some *sprintf don't return the nb of bytes written */
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|gzwrite
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not ANSI C */
end_comment

begin_function
name|int
name|ZEXPORTVA
name|gzprintf
parameter_list|(
name|file
parameter_list|,
name|format
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|,
name|a5
parameter_list|,
name|a6
parameter_list|,
name|a7
parameter_list|,
name|a8
parameter_list|,
name|a9
parameter_list|,
name|a10
parameter_list|,
name|a11
parameter_list|,
name|a12
parameter_list|,
name|a13
parameter_list|,
name|a14
parameter_list|,
name|a15
parameter_list|,
name|a16
parameter_list|,
name|a17
parameter_list|,
name|a18
parameter_list|,
name|a19
parameter_list|,
name|a20
parameter_list|)
name|gzFile
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|,
name|a6
decl_stmt|,
name|a7
decl_stmt|,
name|a8
decl_stmt|,
name|a9
decl_stmt|,
name|a10
decl_stmt|,
name|a11
decl_stmt|,
name|a12
decl_stmt|,
name|a13
decl_stmt|,
name|a14
decl_stmt|,
name|a15
decl_stmt|,
name|a16
decl_stmt|,
name|a17
decl_stmt|,
name|a18
decl_stmt|,
name|a19
decl_stmt|,
name|a20
decl_stmt|;
block|{
name|char
name|buf
index|[
name|Z_PRINTF_BUFSIZE
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_snprintf
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|a10
argument_list|,
name|a11
argument_list|,
name|a12
argument_list|,
name|a13
argument_list|,
name|a14
argument_list|,
name|a15
argument_list|,
name|a16
argument_list|,
name|a17
argument_list|,
name|a18
argument_list|,
name|a19
argument_list|,
name|a20
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|a10
argument_list|,
name|a11
argument_list|,
name|a12
argument_list|,
name|a13
argument_list|,
name|a14
argument_list|,
name|a15
argument_list|,
name|a16
argument_list|,
name|a17
argument_list|,
name|a18
argument_list|,
name|a19
argument_list|,
name|a20
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* old sprintf doesn't return the nb of bytes written */
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|gzwrite
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================       Writes c, converted to an unsigned char, into the compressed file.    gzputc returns the value that was written, or -1 in case of error. */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzputc
parameter_list|(
name|file
parameter_list|,
name|c
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|unsigned
name|char
name|cc
init|=
operator|(
name|unsigned
name|char
operator|)
name|c
decl_stmt|;
comment|/* required for big endian systems */
return|return
name|gzwrite
argument_list|(
name|file
argument_list|,
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|?
operator|(
name|int
operator|)
name|cc
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================       Writes the given null-terminated string to the compressed file, excluding    the terminating null character.       gzputs returns the number of characters written, or -1 in case of error. */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzputs
parameter_list|(
name|file
parameter_list|,
name|s
parameter_list|)
name|gzFile
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
name|gzwrite
argument_list|(
name|file
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Flushes all pending output into the compressed file. The parameter    flush is as in the deflate() function. */
end_comment

begin_function
name|local
name|int
name|do_flush
parameter_list|(
name|file
parameter_list|,
name|flush
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|uInt
name|len
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* should be zero already anyway */
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|Z_BUFSIZE
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|uInt
operator|)
name|fwrite
argument_list|(
name|s
operator|->
name|outbuf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|s
operator|->
name|file
argument_list|)
operator|!=
name|len
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
return|return
name|Z_ERRNO
return|;
block|}
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
break|break;
name|s
operator|->
name|z_err
operator|=
name|deflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|flush
argument_list|)
expr_stmt|;
comment|/* Ignore the second of two consecutive flushes: */
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|s
operator|->
name|z_err
operator|==
name|Z_BUF_ERROR
condition|)
name|s
operator|->
name|z_err
operator|=
name|Z_OK
expr_stmt|;
comment|/* deflate has finished flushing only when it hasn't used up          * all the available space in the output buffer:           */
name|done
operator|=
operator|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|!=
literal|0
operator|||
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
operator|&&
name|s
operator|->
name|z_err
operator|!=
name|Z_STREAM_END
condition|)
break|break;
block|}
return|return
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|?
name|Z_OK
else|:
name|s
operator|->
name|z_err
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|gzflush
parameter_list|(
name|file
parameter_list|,
name|flush
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
name|int
name|err
init|=
name|do_flush
argument_list|(
name|file
argument_list|,
name|flush
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|fflush
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|?
name|Z_OK
else|:
name|s
operator|->
name|z_err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_DEFLATE */
end_comment

begin_comment
comment|/* ===========================================================================       Sets the starting position for the next gzread or gzwrite on the given    compressed file. The offset represents a number of bytes in the       gzseek returns the resulting offset location as measured in bytes from    the beginning of the uncompressed stream, or -1 in case of error.       SEEK_END is not implemented, returns error.       In this version of the library, gzseek can be extremely slow. */
end_comment

begin_function
name|z_off_t
name|ZEXPORT
name|gzseek
parameter_list|(
name|file
parameter_list|,
name|offset
parameter_list|,
name|whence
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|z_off_t
name|offset
decl_stmt|;
name|int
name|whence
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|whence
operator|==
name|SEEK_END
operator|||
name|s
operator|->
name|z_err
operator|==
name|Z_ERRNO
operator|||
name|s
operator|->
name|z_err
operator|==
name|Z_DATA_ERROR
condition|)
block|{
return|return
operator|-
literal|1L
return|;
block|}
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_DEFLATE
return|return
operator|-
literal|1L
return|;
else|#
directive|else
if|if
condition|(
name|whence
operator|==
name|SEEK_SET
condition|)
block|{
name|offset
operator|-=
name|s
operator|->
name|stream
operator|.
name|total_in
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|-
literal|1L
return|;
comment|/* At this point, offset is the number of zero bytes to write. */
if|if
condition|(
name|s
operator|->
name|inbuf
operator|==
name|Z_NULL
condition|)
block|{
name|s
operator|->
name|inbuf
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ALLOC
argument_list|(
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
comment|/* for seeking */
name|zmemzero
argument_list|(
name|s
operator|->
name|inbuf
argument_list|,
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|uInt
name|size
init|=
name|Z_BUFSIZE
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|Z_BUFSIZE
condition|)
name|size
operator|=
operator|(
name|uInt
operator|)
name|offset
expr_stmt|;
name|size
operator|=
name|gzwrite
argument_list|(
name|file
argument_list|,
name|s
operator|->
name|inbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|-
literal|1L
return|;
name|offset
operator|-=
name|size
expr_stmt|;
block|}
return|return
operator|(
name|z_off_t
operator|)
name|s
operator|->
name|stream
operator|.
name|total_in
return|;
endif|#
directive|endif
block|}
comment|/* Rest of function is for reading only */
comment|/* compute absolute position */
if|if
condition|(
name|whence
operator|==
name|SEEK_CUR
condition|)
block|{
name|offset
operator|+=
name|s
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|-
literal|1L
return|;
if|if
condition|(
name|s
operator|->
name|transparent
condition|)
block|{
comment|/* map to fseek */
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1L
return|;
name|s
operator|->
name|stream
operator|.
name|total_in
operator|=
name|s
operator|->
name|stream
operator|.
name|total_out
operator|=
operator|(
name|uLong
operator|)
name|offset
expr_stmt|;
return|return
name|offset
return|;
block|}
comment|/* For a negative seek, rewind and use positive seek */
if|if
condition|(
operator|(
name|uLong
operator|)
name|offset
operator|>=
name|s
operator|->
name|stream
operator|.
name|total_out
condition|)
block|{
name|offset
operator|-=
name|s
operator|->
name|stream
operator|.
name|total_out
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gzrewind
argument_list|(
name|file
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1L
return|;
block|}
comment|/* offset is now the number of bytes to skip. */
if|if
condition|(
name|offset
operator|!=
literal|0
operator|&&
name|s
operator|->
name|outbuf
operator|==
name|Z_NULL
condition|)
block|{
name|s
operator|->
name|outbuf
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ALLOC
argument_list|(
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|int
name|size
init|=
name|Z_BUFSIZE
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|Z_BUFSIZE
condition|)
name|size
operator|=
operator|(
name|int
operator|)
name|offset
expr_stmt|;
name|size
operator|=
name|gzread
argument_list|(
name|file
argument_list|,
name|s
operator|->
name|outbuf
argument_list|,
operator|(
name|uInt
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1L
return|;
name|offset
operator|-=
name|size
expr_stmt|;
block|}
return|return
operator|(
name|z_off_t
operator|)
name|s
operator|->
name|stream
operator|.
name|total_out
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Rewinds input file.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzrewind
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'r'
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|->
name|z_err
operator|=
name|Z_OK
expr_stmt|;
name|s
operator|->
name|z_eof
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
expr_stmt|;
name|s
operator|->
name|crc
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|startpos
operator|==
literal|0
condition|)
block|{
comment|/* not a compressed file */
name|rewind
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|inflateReset
argument_list|(
operator|&
name|s
operator|->
name|stream
argument_list|)
expr_stmt|;
return|return
name|fseek
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|startpos
argument_list|,
name|SEEK_SET
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Returns the starting position for the next gzread or gzwrite on the    given compressed file. This position represents a number of bytes in the    uncompressed data stream. */
end_comment

begin_function
name|z_off_t
name|ZEXPORT
name|gztell
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
return|return
name|gzseek
argument_list|(
name|file
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Returns 1 when EOF has previously been detected reading the given    input stream, otherwise zero. */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzeof
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
return|return
operator|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'r'
operator|)
condition|?
literal|0
else|:
name|s
operator|->
name|z_eof
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================    Outputs a long in LSB order to the given file */
end_comment

begin_function
name|local
name|void
name|putLong
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|uLong
name|x
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|fputc
argument_list|(
call|(
name|int
call|)
argument_list|(
name|x
operator|&
literal|0xff
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|x
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================    Reads a long in LSB order from the given gz_stream. Sets z_err in case    of error. */
end_comment

begin_function
name|local
name|uLong
name|getLong
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
name|uLong
name|x
init|=
operator|(
name|uLong
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
name|x
operator|+=
operator|(
operator|(
name|uLong
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
name|x
operator|+=
operator|(
operator|(
name|uLong
operator|)
name|get_byte
argument_list|(
name|s
argument_list|)
operator|)
operator|<<
literal|16
expr_stmt|;
name|c
operator|=
name|get_byte
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|s
operator|->
name|z_err
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|x
operator|+=
operator|(
operator|(
name|uLong
operator|)
name|c
operator|)
operator|<<
literal|24
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Flushes all pending output if necessary, closes the compressed file    and deallocates all the (de)compression state. */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzclose
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_DEFLATE
return|return
name|Z_STREAM_ERROR
return|;
else|#
directive|else
name|err
operator|=
name|do_flush
argument_list|(
name|file
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|destroy
argument_list|(
operator|(
name|gz_stream
operator|*
operator|)
name|file
argument_list|)
return|;
name|putLong
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|crc
argument_list|)
expr_stmt|;
name|putLong
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|stream
operator|.
name|total_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|destroy
argument_list|(
operator|(
name|gz_stream
operator|*
operator|)
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Returns the error message for the last error which occured on the    given compressed file. errnum is set to zlib error number. If an    error occured in the file system and not in the compression library,    errnum is set to Z_ERRNO and the application may consult errno    to get the exact error code. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ZEXPORT
name|gzerror
parameter_list|(
name|file
parameter_list|,
name|errnum
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
modifier|*
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|m
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
operator|*
name|errnum
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|ERR_MSG
argument_list|(
name|Z_STREAM_ERROR
argument_list|)
return|;
block|}
operator|*
name|errnum
operator|=
name|s
operator|->
name|z_err
expr_stmt|;
if|if
condition|(
operator|*
name|errnum
operator|==
name|Z_OK
condition|)
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
literal|""
return|;
name|m
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|errnum
operator|==
name|Z_ERRNO
condition|?
name|zstrerror
argument_list|(
name|errno
argument_list|)
else|:
name|s
operator|->
name|stream
operator|.
name|msg
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|*
name|m
operator|==
literal|'\0'
condition|)
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|ERR_MSG
argument_list|(
name|s
operator|->
name|z_err
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|msg
argument_list|)
expr_stmt|;
name|s
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|ALLOC
argument_list|(
name|strlen
argument_list|(
name|s
operator|->
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|m
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|->
name|msg
argument_list|,
name|s
operator|->
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
operator|->
name|msg
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
operator|->
name|msg
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|s
operator|->
name|msg
return|;
block|}
end_function

end_unit

