begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infback.c -- inflate using a call-back interface  * Copyright (C) 1995-2005 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/*    This code is largely copied from inflate.c.  Normally either infback.o or    inflate.o would be linked into an application--not both.  The interface    with inffast.c is retained so that optimized assembler-coded versions of    inflate_fast() can be used with either inflate.c or infback.c.  */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_include
include|#
directive|include
file|"inflate.h"
end_include

begin_include
include|#
directive|include
file|"inffast.h"
end_include

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
name|local
name|void
name|fixedtables
name|OF
argument_list|(
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
name|state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    strm provides memory allocation functions in zalloc and zfree, or    Z_NULL to use the library memory allocation functions.     windowBits is in the range 8..15, and window is a user-supplied    window and output buffer that is 2**windowBits bytes.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|inflateBackInit_
parameter_list|(
name|strm
parameter_list|,
name|windowBits
parameter_list|,
name|window
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|windowBits
decl_stmt|;
name|unsigned
name|char
name|FAR
modifier|*
name|window
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|version
operator|==
name|Z_NULL
operator|||
name|version
index|[
literal|0
index|]
operator|!=
name|ZLIB_VERSION
index|[
literal|0
index|]
operator|||
name|stream_size
operator|!=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
condition|)
return|return
name|Z_VERSION_ERROR
return|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|window
operator|==
name|Z_NULL
operator|||
name|windowBits
operator|<
literal|8
operator|||
name|windowBits
operator|>
literal|15
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
comment|/* in case we return an error */
if|if
condition|(
name|strm
operator|->
name|zalloc
operator|==
operator|(
name|alloc_func
operator|)
literal|0
condition|)
block|{
name|strm
operator|->
name|zalloc
operator|=
name|zcalloc
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
name|strm
operator|->
name|zfree
operator|=
name|zcfree
expr_stmt|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: allocated\n"
operator|)
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
operator|(
expr|struct
name|internal_state
name|FAR
operator|*
operator|)
name|state
expr_stmt|;
name|state
operator|->
name|dmax
operator|=
literal|32768U
expr_stmt|;
name|state
operator|->
name|wbits
operator|=
name|windowBits
expr_stmt|;
name|state
operator|->
name|wsize
operator|=
literal|1U
operator|<<
name|windowBits
expr_stmt|;
name|state
operator|->
name|window
operator|=
name|window
expr_stmt|;
name|state
operator|->
name|write
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|whave
operator|=
literal|0
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*    Return state with length and distance decoding tables and index sizes set to    fixed code decoding.  Normally this returns fixed tables from inffixed.h.    If BUILDFIXED is defined, then instead this routine builds the tables the    first time it's called, and returns those tables the first time and    thereafter.  This reduces the size of the code by about 2K bytes, in    exchange for a little execution time.  However, BUILDFIXED should not be    used for threaded applications, since the rewriting of the tables and virgin    may not be thread-safe.  */
end_comment

begin_function
name|local
name|void
name|fixedtables
parameter_list|(
name|state
parameter_list|)
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BUILDFIXED
specifier|static
name|int
name|virgin
init|=
literal|1
decl_stmt|;
specifier|static
name|code
modifier|*
name|lenfix
decl_stmt|,
modifier|*
name|distfix
decl_stmt|;
specifier|static
name|code
name|fixed
index|[
literal|544
index|]
decl_stmt|;
comment|/* build fixed huffman tables if first call (may not be thread safe) */
if|if
condition|(
name|virgin
condition|)
block|{
name|unsigned
name|sym
decl_stmt|,
name|bits
decl_stmt|;
specifier|static
name|code
modifier|*
name|next
decl_stmt|;
comment|/* literal/length table */
name|sym
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|144
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|256
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|9
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|280
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|7
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|288
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|8
expr_stmt|;
name|next
operator|=
name|fixed
expr_stmt|;
name|lenfix
operator|=
name|next
expr_stmt|;
name|bits
operator|=
literal|9
expr_stmt|;
name|inflate_table
argument_list|(
name|LENS
argument_list|,
name|state
operator|->
name|lens
argument_list|,
literal|288
argument_list|,
operator|&
operator|(
name|next
operator|)
argument_list|,
operator|&
operator|(
name|bits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
comment|/* distance table */
name|sym
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|32
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|5
expr_stmt|;
name|distfix
operator|=
name|next
expr_stmt|;
name|bits
operator|=
literal|5
expr_stmt|;
name|inflate_table
argument_list|(
name|DISTS
argument_list|,
name|state
operator|->
name|lens
argument_list|,
literal|32
argument_list|,
operator|&
operator|(
name|next
operator|)
argument_list|,
operator|&
operator|(
name|bits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
comment|/* do this just once */
name|virgin
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* !BUILDFIXED */
include|#
directive|include
file|"inffixed.h"
endif|#
directive|endif
comment|/* BUILDFIXED */
name|state
operator|->
name|lencode
operator|=
name|lenfix
expr_stmt|;
name|state
operator|->
name|lenbits
operator|=
literal|9
expr_stmt|;
name|state
operator|->
name|distcode
operator|=
name|distfix
expr_stmt|;
name|state
operator|->
name|distbits
operator|=
literal|5
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Macros for inflateBack(): */
end_comment

begin_comment
comment|/* Load returned state from inflate_fast() */
end_comment

begin_define
define|#
directive|define
name|LOAD
parameter_list|()
define|\
value|do { \         put = strm->next_out; \         left = strm->avail_out; \         next = strm->next_in; \         have = strm->avail_in; \         hold = state->hold; \         bits = state->bits; \     } while (0)
end_define

begin_comment
comment|/* Set state from registers for inflate_fast() */
end_comment

begin_define
define|#
directive|define
name|RESTORE
parameter_list|()
define|\
value|do { \         strm->next_out = put; \         strm->avail_out = left; \         strm->next_in = next; \         strm->avail_in = have; \         state->hold = hold; \         state->bits = bits; \     } while (0)
end_define

begin_comment
comment|/* Clear the input bit accumulator */
end_comment

begin_define
define|#
directive|define
name|INITBITS
parameter_list|()
define|\
value|do { \         hold = 0; \         bits = 0; \     } while (0)
end_define

begin_comment
comment|/* Assure that some input is available.  If input is requested, but denied,    then return a Z_BUF_ERROR from inflateBack(). */
end_comment

begin_define
define|#
directive|define
name|PULL
parameter_list|()
define|\
value|do { \         if (have == 0) { \             have = in(in_desc,&next); \             if (have == 0) { \                 next = Z_NULL; \                 ret = Z_BUF_ERROR; \                 goto inf_leave; \             } \         } \     } while (0)
end_define

begin_comment
comment|/* Get a byte of input into the bit accumulator, or return from inflateBack()    with an error if there is no input available. */
end_comment

begin_define
define|#
directive|define
name|PULLBYTE
parameter_list|()
define|\
value|do { \         PULL(); \         have--; \         hold += (unsigned long)(*next++)<< bits; \         bits += 8; \     } while (0)
end_define

begin_comment
comment|/* Assure that there are at least n bits in the bit accumulator.  If there is    not enough available input to do that, then return from inflateBack() with    an error. */
end_comment

begin_define
define|#
directive|define
name|NEEDBITS
parameter_list|(
name|n
parameter_list|)
define|\
value|do { \         while (bits< (unsigned)(n)) \             PULLBYTE(); \     } while (0)
end_define

begin_comment
comment|/* Return the low n bits of the bit accumulator (n< 16) */
end_comment

begin_define
define|#
directive|define
name|BITS
parameter_list|(
name|n
parameter_list|)
define|\
value|((unsigned)hold& ((1U<< (n)) - 1))
end_define

begin_comment
comment|/* Remove n bits from the bit accumulator */
end_comment

begin_define
define|#
directive|define
name|DROPBITS
parameter_list|(
name|n
parameter_list|)
define|\
value|do { \         hold>>= (n); \         bits -= (unsigned)(n); \     } while (0)
end_define

begin_comment
comment|/* Remove zero to seven bits as needed to go to a byte boundary */
end_comment

begin_define
define|#
directive|define
name|BYTEBITS
parameter_list|()
define|\
value|do { \         hold>>= bits& 7; \         bits -= bits& 7; \     } while (0)
end_define

begin_comment
comment|/* Assure that some output space is available, by writing out the window    if it's full.  If the write fails, return from inflateBack() with a    Z_BUF_ERROR. */
end_comment

begin_define
define|#
directive|define
name|ROOM
parameter_list|()
define|\
value|do { \         if (left == 0) { \             put = state->window; \             left = state->wsize; \             state->whave = left; \             if (out(out_desc, put, left)) { \                 ret = Z_BUF_ERROR; \                 goto inf_leave; \             } \         } \     } while (0)
end_define

begin_comment
comment|/*    strm provides the memory allocation functions and window buffer on input,    and provides information on the unused input on return.  For Z_DATA_ERROR    returns, strm will also provide an error message.     in() and out() are the call-back input and output functions.  When    inflateBack() needs more input, it calls in().  When inflateBack() has    filled the window with output, or when it completes with data in the    window, it calls out() to write out the data.  The application must not    change the provided input until in() is called again or inflateBack()    returns.  The application must not change the window/output buffer until    inflateBack() returns.     in() and out() are called with a descriptor parameter provided in the    inflateBack() call.  This parameter can be a structure that provides the    information required to do the read or write, as well as accumulated    information on the input and output such as totals and check values.     in() should return zero on failure.  out() should return non-zero on    failure.  If either in() or out() fails, than inflateBack() returns a    Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it    was in() or out() that caused in the error.  Otherwise,  inflateBack()    returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format    error, or Z_MEM_ERROR if it could not allocate memory for the state.    inflateBack() can also return Z_STREAM_ERROR if the input parameters    are not correct, i.e. strm is Z_NULL or the state was not initialized.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|inflateBack
parameter_list|(
name|strm
parameter_list|,
name|in
parameter_list|,
name|in_desc
parameter_list|,
name|out
parameter_list|,
name|out_desc
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|in_func
name|in
decl_stmt|;
name|void
name|FAR
modifier|*
name|in_desc
decl_stmt|;
name|out_func
name|out
decl_stmt|;
name|void
name|FAR
modifier|*
name|out_desc
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
name|unsigned
name|char
name|FAR
modifier|*
name|next
decl_stmt|;
comment|/* next input */
name|unsigned
name|char
name|FAR
modifier|*
name|put
decl_stmt|;
comment|/* next output */
name|unsigned
name|have
decl_stmt|,
name|left
decl_stmt|;
comment|/* available input and output */
name|unsigned
name|long
name|hold
decl_stmt|;
comment|/* bit buffer */
name|unsigned
name|bits
decl_stmt|;
comment|/* bits in bit buffer */
name|unsigned
name|copy
decl_stmt|;
comment|/* number of stored or match bytes to copy */
name|unsigned
name|char
name|FAR
modifier|*
name|from
decl_stmt|;
comment|/* where to copy match bytes from */
name|code
name|this
decl_stmt|;
comment|/* current decoding table entry */
name|code
name|last
decl_stmt|;
comment|/* parent table entry */
name|unsigned
name|len
decl_stmt|;
comment|/* length to copy for repeats, bits to drop */
name|int
name|ret
decl_stmt|;
comment|/* return code */
specifier|static
specifier|const
name|unsigned
name|short
name|order
index|[
literal|19
index|]
init|=
comment|/* permutation of code lengths */
block|{
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
comment|/* Check that the strm exists and that the state was initialized */
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
comment|/* Reset the state */
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
name|state
operator|->
name|last
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|whave
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|strm
operator|->
name|next_in
expr_stmt|;
name|have
operator|=
name|next
operator|!=
name|Z_NULL
condition|?
name|strm
operator|->
name|avail_in
else|:
literal|0
expr_stmt|;
name|hold
operator|=
literal|0
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
name|put
operator|=
name|state
operator|->
name|window
expr_stmt|;
name|left
operator|=
name|state
operator|->
name|wsize
expr_stmt|;
comment|/* Inflate until end of block marked as last */
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|state
operator|->
name|mode
condition|)
block|{
case|case
name|TYPE
case|:
comment|/* determine and dispatch block type */
if|if
condition|(
name|state
operator|->
name|last
condition|)
block|{
name|BYTEBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
break|break;
block|}
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|state
operator|->
name|last
operator|=
name|BITS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|BITS
argument_list|(
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* stored block */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     stored block%s\n"
operator|,
name|state
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|STORED
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* fixed block */
name|fixedtables
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     fixed codes block%s\n"
operator|,
name|state
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
comment|/* decode codes */
break|break;
case|case
literal|2
case|:
comment|/* dynamic block */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     dynamic codes block%s\n"
operator|,
name|state
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TABLE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid block type"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STORED
case|:
comment|/* get and verify stored block length */
name|BYTEBITS
argument_list|()
expr_stmt|;
comment|/* go to byte boundary */
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hold
operator|&
literal|0xffff
operator|)
operator|!=
operator|(
operator|(
name|hold
operator|>>
literal|16
operator|)
operator|^
literal|0xffff
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid stored block lengths"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|length
operator|=
operator|(
name|unsigned
operator|)
name|hold
operator|&
literal|0xffff
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored length %u\n"
operator|,
name|state
operator|->
name|length
operator|)
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
comment|/* copy stored block from input to output */
while|while
condition|(
name|state
operator|->
name|length
operator|!=
literal|0
condition|)
block|{
name|copy
operator|=
name|state
operator|->
name|length
expr_stmt|;
name|PULL
argument_list|()
expr_stmt|;
name|ROOM
argument_list|()
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|have
condition|)
name|copy
operator|=
name|have
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|left
condition|)
name|copy
operator|=
name|left
expr_stmt|;
name|zmemcpy
argument_list|(
name|put
argument_list|,
name|next
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|have
operator|-=
name|copy
expr_stmt|;
name|next
operator|+=
name|copy
expr_stmt|;
name|left
operator|-=
name|copy
expr_stmt|;
name|put
operator|+=
name|copy
expr_stmt|;
name|state
operator|->
name|length
operator|-=
name|copy
expr_stmt|;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored end\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
comment|/* get dynamic table entries descriptor */
name|NEEDBITS
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|state
operator|->
name|nlen
operator|=
name|BITS
argument_list|(
literal|5
argument_list|)
operator|+
literal|257
expr_stmt|;
name|DROPBITS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|state
operator|->
name|ndist
operator|=
name|BITS
argument_list|(
literal|5
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DROPBITS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|state
operator|->
name|ncode
operator|=
name|BITS
argument_list|(
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
name|DROPBITS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PKZIP_BUG_WORKAROUND
if|if
condition|(
name|state
operator|->
name|nlen
operator|>
literal|286
operator|||
name|state
operator|->
name|ndist
operator|>
literal|30
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"too many length or distance symbols"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       table sizes ok\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* get code length code lengths (not a typo) */
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|have
operator|<
name|state
operator|->
name|ncode
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|state
operator|->
name|lens
index|[
name|order
index|[
name|state
operator|->
name|have
operator|++
index|]
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|BITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|state
operator|->
name|have
operator|<
literal|19
condition|)
name|state
operator|->
name|lens
index|[
name|order
index|[
name|state
operator|->
name|have
operator|++
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|codes
expr_stmt|;
name|state
operator|->
name|lencode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|state
operator|->
name|lenbits
operator|=
literal|7
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|CODES
argument_list|,
name|state
operator|->
name|lens
argument_list|,
literal|19
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|state
operator|->
name|lenbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid code lengths set"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       code lengths ok\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* get length and distance code code lengths */
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|have
operator|<
name|state
operator|->
name|nlen
operator|+
name|state
operator|->
name|ndist
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|lencode
index|[
name|BITS
argument_list|(
name|state
operator|->
name|lenbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|val
operator|<
literal|16
condition|)
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|++
index|]
operator|=
name|this
operator|.
name|val
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this
operator|.
name|val
operator|==
literal|16
condition|)
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
operator|+
literal|2
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|have
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid bit length repeat"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|len
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|copy
operator|=
literal|3
operator|+
name|BITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|val
operator|==
literal|17
condition|)
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
operator|+
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
literal|3
operator|+
name|BITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
operator|+
literal|7
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
literal|11
operator|+
name|BITS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|have
operator|+
name|copy
operator|>
name|state
operator|->
name|nlen
operator|+
name|state
operator|->
name|ndist
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid bit length repeat"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|copy
operator|--
condition|)
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|++
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|len
expr_stmt|;
block|}
block|}
comment|/* handle error breaks in while */
if|if
condition|(
name|state
operator|->
name|mode
operator|==
name|BAD
condition|)
break|break;
comment|/* build code tables */
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|codes
expr_stmt|;
name|state
operator|->
name|lencode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|state
operator|->
name|lenbits
operator|=
literal|9
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|LENS
argument_list|,
name|state
operator|->
name|lens
argument_list|,
name|state
operator|->
name|nlen
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|state
operator|->
name|lenbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/lengths set"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|distcode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|state
operator|->
name|distbits
operator|=
literal|6
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|DISTS
argument_list|,
name|state
operator|->
name|lens
operator|+
name|state
operator|->
name|nlen
argument_list|,
name|state
operator|->
name|ndist
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|state
operator|->
name|distbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distances set"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes ok\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
case|case
name|LEN
case|:
comment|/* use inflate_fast() if we have enough input and output */
if|if
condition|(
name|have
operator|>=
literal|6
operator|&&
name|left
operator|>=
literal|258
condition|)
block|{
name|RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|whave
operator|<
name|state
operator|->
name|wsize
condition|)
name|state
operator|->
name|whave
operator|=
name|state
operator|->
name|wsize
operator|-
name|left
expr_stmt|;
name|inflate_fast
argument_list|(
name|strm
argument_list|,
name|state
operator|->
name|wsize
argument_list|)
expr_stmt|;
name|LOAD
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* get a literal, length, or end-of-block code */
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|lencode
index|[
name|BITS
argument_list|(
name|state
operator|->
name|lenbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|op
operator|&&
operator|(
name|this
operator|.
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|this
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|lencode
index|[
name|last
operator|.
name|val
operator|+
operator|(
name|BITS
argument_list|(
name|last
operator|.
name|bits
operator|+
name|last
operator|.
name|op
argument_list|)
operator|>>
name|last
operator|.
name|bits
operator|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|last
operator|.
name|bits
operator|+
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|last
operator|.
name|bits
argument_list|)
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|state
operator|->
name|length
operator|=
operator|(
name|unsigned
operator|)
name|this
operator|.
name|val
expr_stmt|;
comment|/* process literal */
if|if
condition|(
name|this
operator|.
name|op
operator|==
literal|0
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|this
operator|.
name|val
operator|>=
literal|0x20
operator|&&
name|this
operator|.
name|val
operator|<
literal|0x7f
condition|?
literal|"inflate:         literal '%c'\n"
else|:
literal|"inflate:         literal 0x%02x\n"
operator|,
name|this
operator|.
name|val
operator|)
argument_list|)
expr_stmt|;
name|ROOM
argument_list|()
expr_stmt|;
operator|*
name|put
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|state
operator|->
name|length
argument_list|)
expr_stmt|;
name|left
operator|--
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
break|break;
block|}
comment|/* process end of block */
if|if
condition|(
name|this
operator|.
name|op
operator|&
literal|32
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
block|}
comment|/* invalid code */
if|if
condition|(
name|this
operator|.
name|op
operator|&
literal|64
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/length code"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
comment|/* length code -- get extra bits, if any */
name|state
operator|->
name|extra
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|op
argument_list|)
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|extra
operator|!=
literal|0
condition|)
block|{
name|NEEDBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|state
operator|->
name|length
operator|+=
name|BITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
block|}
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         length %u\n"
operator|,
name|state
operator|->
name|length
operator|)
argument_list|)
expr_stmt|;
comment|/* get distance code */
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|distcode
index|[
name|BITS
argument_list|(
name|state
operator|->
name|distbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|this
operator|.
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|this
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|distcode
index|[
name|last
operator|.
name|val
operator|+
operator|(
name|BITS
argument_list|(
name|last
operator|.
name|bits
operator|+
name|last
operator|.
name|op
argument_list|)
operator|>>
name|last
operator|.
name|bits
operator|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|last
operator|.
name|bits
operator|+
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|last
operator|.
name|bits
argument_list|)
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|op
operator|&
literal|64
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance code"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|offset
operator|=
operator|(
name|unsigned
operator|)
name|this
operator|.
name|val
expr_stmt|;
comment|/* get distance extra bits, if any */
name|state
operator|->
name|extra
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|op
argument_list|)
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|extra
operator|!=
literal|0
condition|)
block|{
name|NEEDBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|state
operator|->
name|offset
operator|+=
name|BITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|offset
operator|>
name|state
operator|->
name|wsize
operator|-
operator|(
name|state
operator|->
name|whave
operator|<
name|state
operator|->
name|wsize
condition|?
name|left
else|:
literal|0
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance too far back"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         distance %u\n"
operator|,
name|state
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
comment|/* copy match from window to output */
do|do
block|{
name|ROOM
argument_list|()
expr_stmt|;
name|copy
operator|=
name|state
operator|->
name|wsize
operator|-
name|state
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|copy
operator|<
name|left
condition|)
block|{
name|from
operator|=
name|put
operator|+
name|copy
expr_stmt|;
name|copy
operator|=
name|left
operator|-
name|copy
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|put
operator|-
name|state
operator|->
name|offset
expr_stmt|;
name|copy
operator|=
name|left
expr_stmt|;
block|}
if|if
condition|(
name|copy
operator|>
name|state
operator|->
name|length
condition|)
name|copy
operator|=
name|state
operator|->
name|length
expr_stmt|;
name|state
operator|->
name|length
operator|-=
name|copy
expr_stmt|;
name|left
operator|-=
name|copy
expr_stmt|;
do|do
block|{
operator|*
name|put
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|copy
condition|)
do|;
block|}
do|while
condition|(
name|state
operator|->
name|length
operator|!=
literal|0
condition|)
do|;
break|break;
case|case
name|DONE
case|:
comment|/* inflate stream terminated properly -- write leftover output */
name|ret
operator|=
name|Z_STREAM_END
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|state
operator|->
name|wsize
condition|)
block|{
if|if
condition|(
name|out
argument_list|(
name|out_desc
argument_list|,
name|state
operator|->
name|window
argument_list|,
name|state
operator|->
name|wsize
operator|-
name|left
argument_list|)
condition|)
name|ret
operator|=
name|Z_BUF_ERROR
expr_stmt|;
block|}
goto|goto
name|inf_leave
goto|;
case|case
name|BAD
case|:
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
goto|goto
name|inf_leave
goto|;
default|default:
comment|/* can't happen, but makes compilers happy */
name|ret
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
goto|goto
name|inf_leave
goto|;
block|}
comment|/* Return unused input */
name|inf_leave
label|:
name|strm
operator|->
name|next_in
operator|=
name|next
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
name|have
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateBackEnd
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|ZFREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

end_unit

