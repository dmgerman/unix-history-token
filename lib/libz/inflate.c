begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inflate.c -- zlib interface to inflate modules  * Copyright (C) 1995-1998 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"infblock.h"
end_include

begin_struct
struct|struct
name|inflate_blocks_state
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for buggy compilers */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|METHOD
block|,
comment|/* waiting for method byte */
name|FLAG
block|,
comment|/* waiting for flag byte */
name|DICT4
block|,
comment|/* four dictionary check bytes to go */
name|DICT3
block|,
comment|/* three dictionary check bytes to go */
name|DICT2
block|,
comment|/* two dictionary check bytes to go */
name|DICT1
block|,
comment|/* one dictionary check byte to go */
name|DICT0
block|,
comment|/* waiting for inflateSetDictionary */
name|BLOCKS
block|,
comment|/* decompressing blocks */
name|CHECK4
block|,
comment|/* four check bytes to go */
name|CHECK3
block|,
comment|/* three check bytes to go */
name|CHECK2
block|,
comment|/* two check bytes to go */
name|CHECK1
block|,
comment|/* one check byte to go */
name|DONE
block|,
comment|/* finished check, done */
name|BAD
block|}
comment|/* got an error--stay here */
name|inflate_mode
typedef|;
end_typedef

begin_comment
comment|/* inflate private state */
end_comment

begin_struct
struct|struct
name|internal_state
block|{
comment|/* mode */
name|inflate_mode
name|mode
decl_stmt|;
comment|/* current inflate mode */
comment|/* mode dependent information */
union|union
block|{
name|uInt
name|method
decl_stmt|;
comment|/* if FLAGS, method byte */
struct|struct
block|{
name|uLong
name|was
decl_stmt|;
comment|/* computed check value */
name|uLong
name|need
decl_stmt|;
comment|/* stream check value */
block|}
name|check
struct|;
comment|/* if CHECK, check values to compare */
name|uInt
name|marker
decl_stmt|;
comment|/* if BAD, inflateSync's marker bytes count */
block|}
name|sub
union|;
comment|/* submode */
comment|/* mode independent information */
name|int
name|nowrap
decl_stmt|;
comment|/* flag for no wrapper */
name|uInt
name|wbits
decl_stmt|;
comment|/* log2(window size)  (8..15, defaults to 15) */
name|inflate_blocks_statef
modifier|*
name|blocks
decl_stmt|;
comment|/* current inflate_blocks state */
block|}
struct|;
end_struct

begin_function
name|int
name|ZEXPORT
name|inflateReset
parameter_list|(
name|z
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
block|{
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|z
operator|->
name|total_in
operator|=
name|z
operator|->
name|total_out
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|z
operator|->
name|state
operator|->
name|nowrap
condition|?
name|BLOCKS
else|:
name|METHOD
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
name|Z_NULL
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: reset\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateEnd
parameter_list|(
name|z
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
block|{
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|zfree
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|blocks
operator|!=
name|Z_NULL
condition|)
name|inflate_blocks_free
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|z
operator|->
name|state
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateInit2_
parameter_list|(
name|z
parameter_list|,
name|w
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
name|int
name|w
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
if|if
condition|(
name|version
operator|==
name|Z_NULL
operator|||
name|version
index|[
literal|0
index|]
operator|!=
name|ZLIB_VERSION
index|[
literal|0
index|]
operator|||
name|stream_size
operator|!=
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
condition|)
return|return
name|Z_VERSION_ERROR
return|;
comment|/* initialize state */
if|if
condition|(
name|z
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|z
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|zalloc
operator|==
name|Z_NULL
condition|)
block|{
name|z
operator|->
name|zalloc
operator|=
name|zcalloc
expr_stmt|;
name|z
operator|->
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|->
name|zfree
operator|==
name|Z_NULL
condition|)
name|z
operator|->
name|zfree
operator|=
name|zcfree
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|=
operator|(
expr|struct
name|internal_state
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_state
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|z
operator|->
name|state
operator|->
name|blocks
operator|=
name|Z_NULL
expr_stmt|;
comment|/* handle undocumented nowrap option (no zlib header or check) */
name|z
operator|->
name|state
operator|->
name|nowrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|nowrap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* set window size */
if|if
condition|(
name|w
operator|<
literal|8
operator|||
name|w
operator|>
literal|15
condition|)
block|{
name|inflateEnd
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|z
operator|->
name|state
operator|->
name|wbits
operator|=
operator|(
name|uInt
operator|)
name|w
expr_stmt|;
comment|/* create inflate_blocks state */
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|->
name|blocks
operator|=
name|inflate_blocks_new
argument_list|(
name|z
argument_list|,
name|z
operator|->
name|state
operator|->
name|nowrap
condition|?
name|Z_NULL
else|:
name|adler32
argument_list|,
operator|(
name|uInt
operator|)
literal|1
operator|<<
name|w
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|inflateEnd
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: allocated\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* reset state */
name|inflateReset
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateInit_
parameter_list|(
name|z
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
return|return
name|inflateInit2_
argument_list|(
name|z
argument_list|,
name|DEF_WBITS
argument_list|,
name|version
argument_list|,
name|stream_size
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NEEDBYTE
value|{if(z->avail_in==0)return r;r=f;}
end_define

begin_define
define|#
directive|define
name|NEXTBYTE
value|(z->avail_in--,z->total_in++,*z->next_in++)
end_define

begin_function
name|int
name|ZEXPORT
name|inflate
parameter_list|(
name|z
parameter_list|,
name|f
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
name|int
name|f
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|uInt
name|b
decl_stmt|;
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|next_in
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|f
operator|=
name|f
operator|==
name|Z_FINISH
condition|?
name|Z_BUF_ERROR
else|:
name|Z_OK
expr_stmt|;
name|r
operator|=
name|Z_BUF_ERROR
expr_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|z
operator|->
name|state
operator|->
name|mode
condition|)
block|{
case|case
name|METHOD
case|:
name|NEEDBYTE
if|if
condition|(
operator|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|=
name|NEXTBYTE
operator|)
operator|&
literal|0xf
operator|)
operator|!=
name|Z_DEFLATED
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown compression method"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|>>
literal|4
operator|)
operator|+
literal|8
operator|>
name|z
operator|->
name|state
operator|->
name|wbits
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid window size"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|FLAG
expr_stmt|;
case|case
name|FLAG
case|:
name|NEEDBYTE
name|b
init|=
name|NEXTBYTE
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|<<
literal|8
operator|)
operator|+
name|b
operator|)
operator|%
literal|31
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect header check"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: zlib header ok\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|&
name|PRESET_DICT
operator|)
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BLOCKS
expr_stmt|;
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT4
expr_stmt|;
case|case
name|DICT4
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
init|=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|24
decl_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT3
expr_stmt|;
case|case
name|DICT3
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|16
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT2
expr_stmt|;
case|case
name|DICT2
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|8
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT1
expr_stmt|;
case|case
name|DICT1
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
expr_stmt|;
name|z
operator|->
name|adler
operator|=
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DICT0
expr_stmt|;
return|return
name|Z_NEED_DICT
return|;
case|case
name|DICT0
case|:
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"need dictionary"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
comment|/* can try inflateSync */
return|return
name|Z_STREAM_ERROR
return|;
case|case
name|BLOCKS
case|:
name|r
operator|=
name|inflate_blocks
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
comment|/* can try inflateSync */
break|break;
block|}
if|if
condition|(
name|r
operator|==
name|Z_OK
condition|)
name|r
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|Z_STREAM_END
condition|)
return|return
name|r
return|;
name|r
operator|=
name|f
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
operator|&
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|was
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|nowrap
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK4
expr_stmt|;
case|case
name|CHECK4
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
init|=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|24
decl_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK3
expr_stmt|;
case|case
name|CHECK3
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|16
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK2
expr_stmt|;
case|case
name|CHECK2
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|8
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK1
expr_stmt|;
case|case
name|CHECK1
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|was
operator|!=
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect data check"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: zlib check ok\n"
operator|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
case|case
name|DONE
case|:
return|return
name|Z_STREAM_END
return|;
case|case
name|BAD
case|:
return|return
name|Z_DATA_ERROR
return|;
default|default:
return|return
name|Z_STREAM_ERROR
return|;
block|}
ifdef|#
directive|ifdef
name|NEED_DUMMY_RETURN
return|return
name|Z_STREAM_ERROR
return|;
comment|/* Some dumb compilers complain without this */
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateSetDictionary
parameter_list|(
name|z
parameter_list|,
name|dictionary
parameter_list|,
name|dictLength
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|dictionary
decl_stmt|;
name|uInt
name|dictLength
decl_stmt|;
block|{
name|uInt
name|length
init|=
name|dictLength
decl_stmt|;
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|->
name|mode
operator|!=
name|DICT0
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|adler32
argument_list|(
literal|1L
argument_list|,
name|dictionary
argument_list|,
name|dictLength
argument_list|)
operator|!=
name|z
operator|->
name|adler
condition|)
return|return
name|Z_DATA_ERROR
return|;
name|z
operator|->
name|adler
operator|=
literal|1L
expr_stmt|;
if|if
condition|(
name|length
operator|>=
operator|(
operator|(
name|uInt
operator|)
literal|1
operator|<<
name|z
operator|->
name|state
operator|->
name|wbits
operator|)
condition|)
block|{
name|length
operator|=
operator|(
literal|1
operator|<<
name|z
operator|->
name|state
operator|->
name|wbits
operator|)
operator|-
literal|1
expr_stmt|;
name|dictionary
operator|+=
name|dictLength
operator|-
name|length
expr_stmt|;
block|}
name|inflate_set_dictionary
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|dictionary
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BLOCKS
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateSync
parameter_list|(
name|z
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
block|{
name|uInt
name|n
decl_stmt|;
comment|/* number of bytes to look at */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* pointer to bytes */
name|uInt
name|m
decl_stmt|;
comment|/* number of marker bytes found in a row */
name|uLong
name|r
decl_stmt|,
name|w
decl_stmt|;
comment|/* temporaries to save total_in and total_out */
comment|/* set up */
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|mode
operator|!=
name|BAD
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|z
operator|->
name|avail_in
operator|)
operator|==
literal|0
condition|)
return|return
name|Z_BUF_ERROR
return|;
name|p
operator|=
name|z
operator|->
name|next_in
expr_stmt|;
name|m
operator|=
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
expr_stmt|;
comment|/* search */
while|while
condition|(
name|n
operator|&&
name|m
operator|<
literal|4
condition|)
block|{
specifier|static
specifier|const
name|Byte
name|mark
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|mark
index|[
name|m
index|]
condition|)
name|m
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
condition|)
name|m
operator|=
literal|0
expr_stmt|;
else|else
name|m
operator|=
literal|4
operator|-
name|m
expr_stmt|;
name|p
operator|++
operator|,
name|n
operator|--
expr_stmt|;
block|}
comment|/* restore */
name|z
operator|->
name|total_in
operator|+=
name|p
operator|-
name|z
operator|->
name|next_in
expr_stmt|;
name|z
operator|->
name|next_in
operator|=
name|p
expr_stmt|;
name|z
operator|->
name|avail_in
operator|=
name|n
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
name|m
expr_stmt|;
comment|/* return no joy or set up to restart on a new block */
if|if
condition|(
name|m
operator|!=
literal|4
condition|)
return|return
name|Z_DATA_ERROR
return|;
name|r
operator|=
name|z
operator|->
name|total_in
expr_stmt|;
name|w
operator|=
name|z
operator|->
name|total_out
expr_stmt|;
name|inflateReset
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|z
operator|->
name|total_in
operator|=
name|r
expr_stmt|;
name|z
operator|->
name|total_out
operator|=
name|w
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BLOCKS
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* Returns true if inflate is currently at the end of a block generated  * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP  * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH  * but removes the length bytes of the resulting empty stored block. When  * decompressing, PPP checks that at the end of input packet, inflate is  * waiting for these length bytes.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|inflateSyncPoint
parameter_list|(
name|z
parameter_list|)
name|z_streamp
name|z
decl_stmt|;
block|{
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|->
name|blocks
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
return|return
name|inflate_blocks_sync_point
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|)
return|;
block|}
end_function

end_unit

