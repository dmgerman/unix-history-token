begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inflate.c -- zlib decompression  * Copyright (C) 1995-2003 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/*  * Change history:  *  * 1.2.beta0    24 Nov 2002  * - First version -- complete rewrite of inflate to simplify code, avoid  *   creation of window when not needed, minimize use of window when it is  *   needed, make inffast.c even faster, implement gzip decoding, and to  *   improve code readability and style over the previous zlib inflate code  *  * 1.2.beta1    25 Nov 2002  * - Use pointers for available input and output checking in inffast.c  * - Remove input and output counters in inffast.c  * - Change inffast.c entry and loop from avail_in>= 7 to>= 6  * - Remove unnecessary second byte pull from length extra in inffast.c  * - Unroll direct copy to three copies per loop in inffast.c  *  * 1.2.beta2    4 Dec 2002  * - Change external routine names to reduce potential conflicts  * - Correct filename to inffixed.h for fixed tables in inflate.c  * - Make hbuf[] unsigned char to match parameter type in inflate.c  * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)  *   to avoid negation problem on Alphas (64 bit) in inflate.c  *  * 1.2.beta3    22 Dec 2002  * - Add comments on state->bits assertion in inffast.c  * - Add comments on op field in inftrees.h  * - Fix bug in reuse of allocated window after inflateReset()  * - Remove bit fields--back to byte structure for speed  * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths  * - Change post-increments to pre-increments in inflate_fast(), PPC biased?  * - Add compile time option, POSTINC, to use post-increments instead (Intel?)  * - Make MATCH copy in inflate() much faster for when inflate_fast() not used  * - Use local copies of stream next and avail values, as well as local bit  *   buffer and bit count in inflate()--for speed when inflate_fast() not used  *  * 1.2.beta4    1 Jan 2003  * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings  * - Move a comment on output buffer sizes from inffast.c to inflate.c  * - Add comments in inffast.c to introduce the inflate_fast() routine  * - Rearrange window copies in inflate_fast() for speed and simplification  * - Unroll last copy for window match in inflate_fast()  * - Use local copies of window variables in inflate_fast() for speed  * - Pull out common write == 0 case for speed in inflate_fast()  * - Make op and len in inflate_fast() unsigned for consistency  * - Add FAR to lcode and dcode declarations in inflate_fast()  * - Simplified bad distance check in inflate_fast()  * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new  *   source file infback.c to provide a call-back interface to inflate for  *   programs like gzip and unzip -- uses window as output buffer to avoid  *   window copying  *  * 1.2.beta5    1 Jan 2003  * - Improved inflateBack() interface to allow the caller to provide initial  *   input in strm.  * - Fixed stored blocks bug in inflateBack()  *  * 1.2.beta6    4 Jan 2003  * - Added comments in inffast.c on effectiveness of POSTINC  * - Typecasting all around to reduce compiler warnings  * - Changed loops from while (1) or do {} while (1) to for (;;), again to  *   make compilers happy  * - Changed type of window in inflateBackInit() to unsigned char *  *  * 1.2.beta7    27 Jan 2003  * - Changed many types to unsigned or unsigned short to avoid warnings  * - Added inflateCopy() function  *  * 1.2.0        9 Mar 2003  * - Changed inflateBack() interface to provide separate opaque descriptors  *   for the in() and out() functions  * - Changed inflateBack() argument and in_func typedef to swap the length  *   and buffer address return values for the input function  * - Check next_in and next_out for Z_NULL on entry to inflate()  *  * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.  */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_include
include|#
directive|include
file|"inflate.h"
end_include

begin_include
include|#
directive|include
file|"inffast.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAKEFIXED
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|BUILDFIXED
end_ifndef

begin_define
define|#
directive|define
name|BUILDFIXED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
name|local
name|void
name|fixedtables
name|OF
argument_list|(
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
name|state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|updatewindow
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|unsigned
name|out
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BUILDFIXED
end_ifdef

begin_decl_stmt
name|void
name|makefixed
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|local
name|unsigned
name|syncsearch
name|OF
argument_list|(
operator|(
name|unsigned
name|FAR
operator|*
name|have
operator|,
name|unsigned
name|char
name|FAR
operator|*
name|buf
operator|,
name|unsigned
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ZEXPORT
name|inflateReset
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
name|strm
operator|->
name|total_in
operator|=
name|strm
operator|->
name|total_out
operator|=
name|state
operator|->
name|total
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
literal|1
expr_stmt|;
comment|/* to support ill-conceived Java test suite */
name|state
operator|->
name|mode
operator|=
name|HEAD
expr_stmt|;
name|state
operator|->
name|last
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|havedict
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|wsize
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|whave
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|hold
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|bits
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|lencode
operator|=
name|state
operator|->
name|distcode
operator|=
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|codes
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: reset\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateInit2_
parameter_list|(
name|strm
parameter_list|,
name|windowBits
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|windowBits
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|version
operator|==
name|Z_NULL
operator|||
name|version
index|[
literal|0
index|]
operator|!=
name|ZLIB_VERSION
index|[
literal|0
index|]
operator|||
name|stream_size
operator|!=
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|z_stream
argument_list|)
argument_list|)
condition|)
return|return
name|Z_VERSION_ERROR
return|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
comment|/* in case we return an error */
if|if
condition|(
name|strm
operator|->
name|zalloc
operator|==
operator|(
name|alloc_func
operator|)
literal|0
condition|)
block|{
name|strm
operator|->
name|zalloc
operator|=
name|zcalloc
expr_stmt|;
name|strm
operator|->
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
name|strm
operator|->
name|zfree
operator|=
name|zcfree
expr_stmt|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: allocated\n"
operator|)
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
operator|(
name|voidpf
operator|)
name|state
expr_stmt|;
if|if
condition|(
name|windowBits
operator|<
literal|0
condition|)
block|{
name|state
operator|->
name|wrap
operator|=
literal|0
expr_stmt|;
name|windowBits
operator|=
operator|-
name|windowBits
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|wrap
operator|=
operator|(
name|windowBits
operator|>>
literal|4
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GUNZIP
if|if
condition|(
name|windowBits
operator|<
literal|48
condition|)
name|windowBits
operator|&=
literal|15
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|windowBits
operator|<
literal|8
operator|||
name|windowBits
operator|>
literal|15
condition|)
block|{
name|ZFREE
argument_list|(
name|strm
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|state
operator|->
name|wbits
operator|=
operator|(
name|unsigned
operator|)
name|windowBits
expr_stmt|;
name|state
operator|->
name|window
operator|=
name|Z_NULL
expr_stmt|;
return|return
name|inflateReset
argument_list|(
name|strm
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateInit_
parameter_list|(
name|strm
parameter_list|,
name|version
parameter_list|,
name|stream_size
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|stream_size
decl_stmt|;
block|{
return|return
name|inflateInit2_
argument_list|(
name|strm
argument_list|,
name|DEF_WBITS
argument_list|,
name|version
argument_list|,
name|stream_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    Return state with length and distance decoding tables and index sizes set to    fixed code decoding.  Normally this returns fixed tables from inffixed.h.    If BUILDFIXED is defined, then instead this routine builds the tables the    first time it's called, and returns those tables the first time and    thereafter.  This reduces the size of the code by about 2K bytes, in    exchange for a little execution time.  However, BUILDFIXED should not be    used for threaded applications, since the rewriting of the tables and virgin    may not be thread-safe.  */
end_comment

begin_function
name|local
name|void
name|fixedtables
parameter_list|(
name|state
parameter_list|)
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BUILDFIXED
specifier|static
name|int
name|virgin
init|=
literal|1
decl_stmt|;
specifier|static
name|code
modifier|*
name|lenfix
decl_stmt|,
modifier|*
name|distfix
decl_stmt|;
specifier|static
name|code
name|fixed
index|[
literal|544
index|]
decl_stmt|;
comment|/* build fixed huffman tables if first call (may not be thread safe) */
if|if
condition|(
name|virgin
condition|)
block|{
name|unsigned
name|sym
decl_stmt|,
name|bits
decl_stmt|;
specifier|static
name|code
modifier|*
name|next
decl_stmt|;
comment|/* literal/length table */
name|sym
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|144
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|256
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|9
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|280
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|7
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|288
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|8
expr_stmt|;
name|next
operator|=
name|fixed
expr_stmt|;
name|lenfix
operator|=
name|next
expr_stmt|;
name|bits
operator|=
literal|9
expr_stmt|;
name|inflate_table
argument_list|(
name|LENS
argument_list|,
name|state
operator|->
name|lens
argument_list|,
literal|288
argument_list|,
operator|&
operator|(
name|next
operator|)
argument_list|,
operator|&
operator|(
name|bits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
comment|/* distance table */
name|sym
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym
operator|<
literal|32
condition|)
name|state
operator|->
name|lens
index|[
name|sym
operator|++
index|]
operator|=
literal|5
expr_stmt|;
name|distfix
operator|=
name|next
expr_stmt|;
name|bits
operator|=
literal|5
expr_stmt|;
name|inflate_table
argument_list|(
name|DISTS
argument_list|,
name|state
operator|->
name|lens
argument_list|,
literal|32
argument_list|,
operator|&
operator|(
name|next
operator|)
argument_list|,
operator|&
operator|(
name|bits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
comment|/* do this just once */
name|virgin
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* !BUILDFIXED */
include|#
directive|include
file|"inffixed.h"
endif|#
directive|endif
comment|/* BUILDFIXED */
name|state
operator|->
name|lencode
operator|=
name|lenfix
expr_stmt|;
name|state
operator|->
name|lenbits
operator|=
literal|9
expr_stmt|;
name|state
operator|->
name|distcode
operator|=
name|distfix
expr_stmt|;
name|state
operator|->
name|distbits
operator|=
literal|5
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAKEFIXED
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*    Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also    defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes    those tables to stdout, which would be piped to inffixed.h.  A small program    can simply call makefixed to do this:      void makefixed(void);      int main(void)     {         makefixed();         return 0;     }     Then that can be linked with zlib built with MAKEFIXED defined and run:      a.out> inffixed.h  */
end_comment

begin_function
name|void
name|makefixed
parameter_list|()
block|{
name|unsigned
name|low
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|inflate_state
name|state
decl_stmt|;
name|fixedtables
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    /* inffixed.h -- table for decoding fixed codes"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     * Generated automatically by makefixed()."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     */"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"    /* WARNING: this file should *not* be used by applications."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"       It is part of the implementation of this library and is"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"       subject to change. Applications should only use zlib.h."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     */"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1U
operator|<<
literal|9
expr_stmt|;
name|printf
argument_list|(
literal|"    static const code lenfix[%u] = {"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|low
operator|%
literal|7
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n        "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{%u,%u,%d}"
argument_list|,
name|state
operator|.
name|lencode
index|[
name|low
index|]
operator|.
name|op
argument_list|,
name|state
operator|.
name|lencode
index|[
name|low
index|]
operator|.
name|bits
argument_list|,
name|state
operator|.
name|lencode
index|[
name|low
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|low
operator|==
name|size
condition|)
break|break;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"\n    };"
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1U
operator|<<
literal|5
expr_stmt|;
name|printf
argument_list|(
literal|"\n    static const code distfix[%u] = {"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|low
operator|%
literal|6
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n        "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{%u,%u,%d}"
argument_list|,
name|state
operator|.
name|distcode
index|[
name|low
index|]
operator|.
name|op
argument_list|,
name|state
operator|.
name|distcode
index|[
name|low
index|]
operator|.
name|bits
argument_list|,
name|state
operator|.
name|distcode
index|[
name|low
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|low
operator|==
name|size
condition|)
break|break;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"\n    };"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKEFIXED */
end_comment

begin_comment
comment|/*    Update the window with the last wsize (normally 32K) bytes written before    returning.  If window does not exist yet, create it.  This is only called    when a window is already in use, or when output has been written during this    inflate call, but the end of the deflate stream has not been reached yet.    It is also called to create a window for dictionary data when a dictionary    is loaded.     Providing output buffers larger than 32K to inflate() should provide a speed    advantage, since only the last 32K of output is copied to the sliding window    upon return from inflate(), and since all distances after the first 32K of    output will fall in the output data, making match copies simpler and faster.    The advantage may be dependent on the size of the processor's data caches.  */
end_comment

begin_function
name|local
name|int
name|updatewindow
parameter_list|(
name|strm
parameter_list|,
name|out
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|unsigned
name|out
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
name|unsigned
name|copy
decl_stmt|,
name|dist
decl_stmt|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
comment|/* if it hasn't been done already, allocate space for the window */
if|if
condition|(
name|state
operator|->
name|window
operator|==
name|Z_NULL
condition|)
block|{
name|state
operator|->
name|window
operator|=
operator|(
name|unsigned
name|char
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|strm
argument_list|,
literal|1U
operator|<<
name|state
operator|->
name|wbits
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|window
operator|==
name|Z_NULL
condition|)
return|return
literal|1
return|;
block|}
comment|/* if window not in use yet, initialize */
if|if
condition|(
name|state
operator|->
name|wsize
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|wsize
operator|=
literal|1U
operator|<<
name|state
operator|->
name|wbits
expr_stmt|;
name|state
operator|->
name|write
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|whave
operator|=
literal|0
expr_stmt|;
block|}
comment|/* copy state->wsize or less output bytes into the circular window */
name|copy
operator|=
name|out
operator|-
name|strm
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|copy
operator|>=
name|state
operator|->
name|wsize
condition|)
block|{
name|zmemcpy
argument_list|(
name|state
operator|->
name|window
argument_list|,
name|strm
operator|->
name|next_out
operator|-
name|state
operator|->
name|wsize
argument_list|,
name|state
operator|->
name|wsize
argument_list|)
expr_stmt|;
name|state
operator|->
name|write
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|whave
operator|=
name|state
operator|->
name|wsize
expr_stmt|;
block|}
else|else
block|{
name|dist
operator|=
name|state
operator|->
name|wsize
operator|-
name|state
operator|->
name|write
expr_stmt|;
if|if
condition|(
name|dist
operator|>
name|copy
condition|)
name|dist
operator|=
name|copy
expr_stmt|;
name|zmemcpy
argument_list|(
name|state
operator|->
name|window
operator|+
name|state
operator|->
name|write
argument_list|,
name|strm
operator|->
name|next_out
operator|-
name|copy
argument_list|,
name|dist
argument_list|)
expr_stmt|;
name|copy
operator|-=
name|dist
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
name|zmemcpy
argument_list|(
name|state
operator|->
name|window
argument_list|,
name|strm
operator|->
name|next_out
operator|-
name|copy
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|state
operator|->
name|write
operator|=
name|copy
expr_stmt|;
name|state
operator|->
name|whave
operator|=
name|state
operator|->
name|wsize
expr_stmt|;
block|}
else|else
block|{
name|state
operator|->
name|write
operator|+=
name|dist
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|write
operator|==
name|state
operator|->
name|wsize
condition|)
name|state
operator|->
name|write
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|whave
operator|<
name|state
operator|->
name|wsize
condition|)
name|state
operator|->
name|whave
operator|+=
name|dist
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Macros for inflate(): */
end_comment

begin_comment
comment|/* check function to use adler32() for zlib or crc32() for gzip */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GUNZIP
end_ifdef

begin_define
define|#
directive|define
name|UPDATE
parameter_list|(
name|check
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
define|\
value|(state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UPDATE
parameter_list|(
name|check
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
value|adler32(check, buf, len)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* check macros for header crc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GUNZIP
end_ifdef

begin_define
define|#
directive|define
name|CRC2
parameter_list|(
name|check
parameter_list|,
name|word
parameter_list|)
define|\
value|do { \         hbuf[0] = (unsigned char)(word); \         hbuf[1] = (unsigned char)((word)>> 8); \         check = crc32(check, hbuf, 2); \     } while (0)
end_define

begin_define
define|#
directive|define
name|CRC4
parameter_list|(
name|check
parameter_list|,
name|word
parameter_list|)
define|\
value|do { \         hbuf[0] = (unsigned char)(word); \         hbuf[1] = (unsigned char)((word)>> 8); \         hbuf[2] = (unsigned char)((word)>> 16); \         hbuf[3] = (unsigned char)((word)>> 24); \         check = crc32(check, hbuf, 4); \     } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Load registers with state in inflate() for speed */
end_comment

begin_define
define|#
directive|define
name|LOAD
parameter_list|()
define|\
value|do { \         put = strm->next_out; \         left = strm->avail_out; \         next = strm->next_in; \         have = strm->avail_in; \         hold = state->hold; \         bits = state->bits; \     } while (0)
end_define

begin_comment
comment|/* Restore state from registers in inflate() */
end_comment

begin_define
define|#
directive|define
name|RESTORE
parameter_list|()
define|\
value|do { \         strm->next_out = put; \         strm->avail_out = left; \         strm->next_in = next; \         strm->avail_in = have; \         state->hold = hold; \         state->bits = bits; \     } while (0)
end_define

begin_comment
comment|/* Clear the input bit accumulator */
end_comment

begin_define
define|#
directive|define
name|INITBITS
parameter_list|()
define|\
value|do { \         hold = 0; \         bits = 0; \     } while (0)
end_define

begin_comment
comment|/* Get a byte of input into the bit accumulator, or return from inflate()    if there is no input available. */
end_comment

begin_define
define|#
directive|define
name|PULLBYTE
parameter_list|()
define|\
value|do { \         if (have == 0) goto inf_leave; \         have--; \         hold += (unsigned long)(*next++)<< bits; \         bits += 8; \     } while (0)
end_define

begin_comment
comment|/* Assure that there are at least n bits in the bit accumulator.  If there is    not enough available input to do that, then return from inflate(). */
end_comment

begin_define
define|#
directive|define
name|NEEDBITS
parameter_list|(
name|n
parameter_list|)
define|\
value|do { \         while (bits< (unsigned)(n)) \             PULLBYTE(); \     } while (0)
end_define

begin_comment
comment|/* Return the low n bits of the bit accumulator (n< 16) */
end_comment

begin_define
define|#
directive|define
name|BITS
parameter_list|(
name|n
parameter_list|)
define|\
value|((unsigned)hold& ((1U<< (n)) - 1))
end_define

begin_comment
comment|/* Remove n bits from the bit accumulator */
end_comment

begin_define
define|#
directive|define
name|DROPBITS
parameter_list|(
name|n
parameter_list|)
define|\
value|do { \         hold>>= (n); \         bits -= (unsigned)(n); \     } while (0)
end_define

begin_comment
comment|/* Remove zero to seven bits as needed to go to a byte boundary */
end_comment

begin_define
define|#
directive|define
name|BYTEBITS
parameter_list|()
define|\
value|do { \         hold>>= bits& 7; \         bits -= bits& 7; \     } while (0)
end_define

begin_comment
comment|/* Reverse the bytes in a 32-bit value */
end_comment

begin_define
define|#
directive|define
name|REVERSE
parameter_list|(
name|q
parameter_list|)
define|\
value|((((q)>> 24)& 0xff) + (((q)>> 8)& 0xff00) + \      (((q)& 0xff00)<< 8) + (((q)& 0xff)<< 24))
end_define

begin_comment
comment|/*    inflate() uses a state machine to process as much input data and generate as    much output data as possible before returning.  The state machine is    structured roughly as follows:      for (;;) switch (state) {     ...     case STATEn:         if (not enough input data or output space to make progress)             return;         ... make progress ...         state = STATEm;         break;     ...     }     so when inflate() is called again, the same case is attempted again, and    if the appropriate resources are provided, the machine proceeds to the    next state.  The NEEDBITS() macro is usually the way the state evaluates    whether it can proceed or should return.  NEEDBITS() does the return if    the requested bits are not available.  The typical use of the BITS macros    is:          NEEDBITS(n);         ... do something with BITS(n) ...         DROPBITS(n);     where NEEDBITS(n) either returns from inflate() if there isn't enough    input left to load n bits into the accumulator, or it continues.  BITS(n)    gives the low n bits in the accumulator.  When done, DROPBITS(n) drops    the low n bits off the accumulator.  INITBITS() clears the accumulator    and sets the number of available bits to zero.  BYTEBITS() discards just    enough bits to put the accumulator on a byte boundary.  After BYTEBITS()    and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.     NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return    if there is no input available.  The decoding of variable length codes uses    PULLBYTE() directly in order to pull just enough bytes to decode the next    code, and no more.     Some states loop until they get enough input, making sure that enough    state information is maintained to continue the loop where it left off    if NEEDBITS() returns in the loop.  For example, want, need, and keep    would all have to actually be part of the saved state in case NEEDBITS()    returns:      case STATEw:         while (want< need) {             NEEDBITS(n);             keep[want++] = BITS(n);             DROPBITS(n);         }         state = STATEx;     case STATEx:     As shown above, if the next state is also the next case, then the break    is omitted.     A state may also return if there is not enough output space available to    complete that state.  Those states are copying stored data, writing a    literal byte, and copying a matching string.     When returning, a "goto inf_leave" is used to update the total counters,    update the check value, and determine whether any progress has been made    during that inflate() call in order to return the proper return code.    Progress is defined as a change in either strm->avail_in or strm->avail_out.    When there is a window, goto inf_leave will update the window with the last    output written.  If a goto inf_leave occurs in the middle of decompression    and there is no window currently, goto inf_leave will create one and copy    output to the window for the next call of inflate().     In this implementation, the flush parameter of inflate() only affects the    return code (per zlib.h).  inflate() always writes as much as possible to    strm->next_out, given the space available and the provided input--the effect    documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers    the allocation of and copying into a sliding window until necessary, which    provides the effect documented in zlib.h for Z_FINISH when the entire input    stream available.  So the only thing the flush parameter actually does is:    when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it    will return Z_BUF_ERROR if it has not reached the end of the stream.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|inflate
parameter_list|(
name|strm
parameter_list|,
name|flush
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
name|unsigned
name|char
name|FAR
modifier|*
name|next
decl_stmt|;
comment|/* next input */
name|unsigned
name|char
name|FAR
modifier|*
name|put
decl_stmt|;
comment|/* next output */
name|unsigned
name|have
decl_stmt|,
name|left
decl_stmt|;
comment|/* available input and output */
name|unsigned
name|long
name|hold
decl_stmt|;
comment|/* bit buffer */
name|unsigned
name|bits
decl_stmt|;
comment|/* bits in bit buffer */
name|unsigned
name|in
decl_stmt|,
name|out
decl_stmt|;
comment|/* save starting available input and output */
name|unsigned
name|copy
decl_stmt|;
comment|/* number of stored or match bytes to copy */
name|unsigned
name|char
name|FAR
modifier|*
name|from
decl_stmt|;
comment|/* where to copy match bytes from */
name|code
name|this
decl_stmt|;
comment|/* current decoding table entry */
name|code
name|last
decl_stmt|;
comment|/* parent table entry */
name|unsigned
name|len
decl_stmt|;
comment|/* length to copy for repeats, bits to drop */
name|int
name|ret
decl_stmt|;
comment|/* return code */
ifdef|#
directive|ifdef
name|GUNZIP
name|unsigned
name|char
name|hbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* buffer for gzip header crc calculation */
endif|#
directive|endif
specifier|static
specifier|const
name|unsigned
name|short
name|order
index|[
literal|19
index|]
init|=
comment|/* permutation of code lengths */
block|{
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|next_out
operator|==
name|Z_NULL
operator|||
operator|(
name|strm
operator|->
name|next_in
operator|==
name|Z_NULL
operator|&&
name|strm
operator|->
name|avail_in
operator|!=
literal|0
operator|)
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|mode
operator|==
name|TYPE
condition|)
name|state
operator|->
name|mode
operator|=
name|TYPEDO
expr_stmt|;
comment|/* skip check */
name|LOAD
argument_list|()
expr_stmt|;
name|in
operator|=
name|have
expr_stmt|;
name|out
operator|=
name|left
expr_stmt|;
name|ret
operator|=
name|Z_OK
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|state
operator|->
name|mode
condition|)
block|{
case|case
name|HEAD
case|:
if|if
condition|(
name|state
operator|->
name|wrap
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|mode
operator|=
name|TYPEDO
expr_stmt|;
break|break;
block|}
name|NEEDBITS
argument_list|(
literal|16
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GUNZIP
if|if
condition|(
operator|(
name|state
operator|->
name|wrap
operator|&
literal|2
operator|)
operator|&&
name|hold
operator|==
literal|0x8b1f
condition|)
block|{
comment|/* gzip header */
name|state
operator|->
name|check
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CRC2
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|hold
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|FLAGS
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* expect zlib header */
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|wrap
operator|&
literal|1
operator|)
operator|||
comment|/* check if zlib header allowed */
else|#
directive|else
if|if
condition|(
endif|#
directive|endif
operator|(
operator|(
name|BITS
argument_list|(
literal|8
argument_list|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|hold
operator|>>
literal|8
operator|)
operator|)
operator|%
literal|31
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect header check"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|BITS
argument_list|(
literal|4
argument_list|)
operator|!=
name|Z_DEFLATED
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown compression method"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|DROPBITS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|BITS
argument_list|(
literal|4
argument_list|)
operator|+
literal|8
operator|>
name|state
operator|->
name|wbits
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid window size"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   zlib header ok\n"
operator|)
argument_list|)
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
name|state
operator|->
name|check
operator|=
name|adler32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|hold
operator|&
literal|0x200
condition|?
name|DICTID
else|:
name|TYPE
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|GUNZIP
case|case
name|FLAGS
case|:
name|NEEDBITS
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|state
operator|->
name|flags
operator|=
call|(
name|int
call|)
argument_list|(
name|hold
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|->
name|flags
operator|&
literal|0xff
operator|)
operator|!=
name|Z_DEFLATED
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown compression method"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0xe000
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"unknown header flags set"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0200
condition|)
name|CRC2
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|hold
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TIME
expr_stmt|;
case|case
name|TIME
case|:
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0200
condition|)
name|CRC4
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|hold
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|OS
expr_stmt|;
case|case
name|OS
case|:
name|NEEDBITS
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0200
condition|)
name|CRC2
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|hold
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|EXLEN
expr_stmt|;
case|case
name|EXLEN
case|:
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0400
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|state
operator|->
name|length
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|hold
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0200
condition|)
name|CRC2
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|hold
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
block|}
name|state
operator|->
name|mode
operator|=
name|EXTRA
expr_stmt|;
case|case
name|EXTRA
case|:
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0400
condition|)
block|{
name|copy
operator|=
name|state
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|have
condition|)
name|copy
operator|=
name|have
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0200
condition|)
name|state
operator|->
name|check
operator|=
name|crc32
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|next
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|have
operator|-=
name|copy
expr_stmt|;
name|next
operator|+=
name|copy
expr_stmt|;
name|state
operator|->
name|length
operator|-=
name|copy
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|length
condition|)
goto|goto
name|inf_leave
goto|;
block|}
name|state
operator|->
name|mode
operator|=
name|NAME
expr_stmt|;
case|case
name|NAME
case|:
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0800
condition|)
block|{
if|if
condition|(
name|have
operator|==
literal|0
condition|)
goto|goto
name|inf_leave
goto|;
name|copy
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|len
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|next
index|[
name|copy
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|&&
name|copy
operator|<
name|have
condition|)
do|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x02000
condition|)
name|state
operator|->
name|check
operator|=
name|crc32
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|next
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|have
operator|-=
name|copy
expr_stmt|;
name|next
operator|+=
name|copy
expr_stmt|;
if|if
condition|(
name|len
condition|)
goto|goto
name|inf_leave
goto|;
block|}
name|state
operator|->
name|mode
operator|=
name|COMMENT
expr_stmt|;
case|case
name|COMMENT
case|:
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x1000
condition|)
block|{
if|if
condition|(
name|have
operator|==
literal|0
condition|)
goto|goto
name|inf_leave
goto|;
name|copy
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|len
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|next
index|[
name|copy
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|&&
name|copy
operator|<
name|have
condition|)
do|;
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x02000
condition|)
name|state
operator|->
name|check
operator|=
name|crc32
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|next
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|have
operator|-=
name|copy
expr_stmt|;
name|next
operator|+=
name|copy
expr_stmt|;
if|if
condition|(
name|len
condition|)
goto|goto
name|inf_leave
goto|;
block|}
name|state
operator|->
name|mode
operator|=
name|HCRC
expr_stmt|;
case|case
name|HCRC
case|:
if|if
condition|(
name|state
operator|->
name|flags
operator|&
literal|0x0200
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|hold
operator|!=
operator|(
name|state
operator|->
name|check
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"header crc mismatch"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|INITBITS
argument_list|()
expr_stmt|;
block|}
name|strm
operator|->
name|adler
operator|=
name|state
operator|->
name|check
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|DICTID
case|:
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
name|state
operator|->
name|check
operator|=
name|REVERSE
argument_list|(
name|hold
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|DICT
expr_stmt|;
case|case
name|DICT
case|:
if|if
condition|(
name|state
operator|->
name|havedict
operator|==
literal|0
condition|)
block|{
name|RESTORE
argument_list|()
expr_stmt|;
return|return
name|Z_NEED_DICT
return|;
block|}
name|strm
operator|->
name|adler
operator|=
name|state
operator|->
name|check
operator|=
name|adler32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
case|case
name|TYPE
case|:
if|if
condition|(
name|flush
operator|==
name|Z_BLOCK
condition|)
goto|goto
name|inf_leave
goto|;
case|case
name|TYPEDO
case|:
if|if
condition|(
name|state
operator|->
name|last
condition|)
block|{
name|BYTEBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|CHECK
expr_stmt|;
break|break;
block|}
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|state
operator|->
name|last
operator|=
name|BITS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|BITS
argument_list|(
literal|2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* stored block */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     stored block%s\n"
operator|,
name|state
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|STORED
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* fixed block */
name|fixedtables
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     fixed codes block%s\n"
operator|,
name|state
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
comment|/* decode codes */
break|break;
case|case
literal|2
case|:
comment|/* dynamic block */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     dynamic codes block%s\n"
operator|,
name|state
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TABLE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid block type"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STORED
case|:
name|BYTEBITS
argument_list|()
expr_stmt|;
comment|/* go to byte boundary */
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hold
operator|&
literal|0xffff
operator|)
operator|!=
operator|(
operator|(
name|hold
operator|>>
literal|16
operator|)
operator|^
literal|0xffff
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid stored block lengths"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|length
operator|=
operator|(
name|unsigned
operator|)
name|hold
operator|&
literal|0xffff
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored length %u\n"
operator|,
name|state
operator|->
name|length
operator|)
argument_list|)
expr_stmt|;
name|INITBITS
argument_list|()
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|COPY
expr_stmt|;
case|case
name|COPY
case|:
name|copy
operator|=
name|state
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|copy
condition|)
block|{
if|if
condition|(
name|copy
operator|>
name|have
condition|)
name|copy
operator|=
name|have
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|left
condition|)
name|copy
operator|=
name|left
expr_stmt|;
if|if
condition|(
name|copy
operator|==
literal|0
condition|)
goto|goto
name|inf_leave
goto|;
name|zmemcpy
argument_list|(
name|put
argument_list|,
name|next
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|have
operator|-=
name|copy
expr_stmt|;
name|next
operator|+=
name|copy
expr_stmt|;
name|left
operator|-=
name|copy
expr_stmt|;
name|put
operator|+=
name|copy
expr_stmt|;
name|state
operator|->
name|length
operator|-=
name|copy
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored end\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
name|NEEDBITS
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|state
operator|->
name|nlen
operator|=
name|BITS
argument_list|(
literal|5
argument_list|)
operator|+
literal|257
expr_stmt|;
name|DROPBITS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|state
operator|->
name|ndist
operator|=
name|BITS
argument_list|(
literal|5
argument_list|)
operator|+
literal|1
expr_stmt|;
name|DROPBITS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|state
operator|->
name|ncode
operator|=
name|BITS
argument_list|(
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
name|DROPBITS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PKZIP_BUG_WORKAROUND
if|if
condition|(
name|state
operator|->
name|nlen
operator|>
literal|286
operator|||
name|state
operator|->
name|ndist
operator|>
literal|30
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"too many length or distance symbols"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       table sizes ok\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LENLENS
expr_stmt|;
case|case
name|LENLENS
case|:
while|while
condition|(
name|state
operator|->
name|have
operator|<
name|state
operator|->
name|ncode
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|state
operator|->
name|lens
index|[
name|order
index|[
name|state
operator|->
name|have
operator|++
index|]
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|BITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|state
operator|->
name|have
operator|<
literal|19
condition|)
name|state
operator|->
name|lens
index|[
name|order
index|[
name|state
operator|->
name|have
operator|++
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|codes
expr_stmt|;
name|state
operator|->
name|lencode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|state
operator|->
name|lenbits
operator|=
literal|7
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|CODES
argument_list|,
name|state
operator|->
name|lens
argument_list|,
literal|19
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|state
operator|->
name|lenbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid code lengths set"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       code lengths ok\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|CODELENS
expr_stmt|;
case|case
name|CODELENS
case|:
while|while
condition|(
name|state
operator|->
name|have
operator|<
name|state
operator|->
name|nlen
operator|+
name|state
operator|->
name|ndist
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|lencode
index|[
name|BITS
argument_list|(
name|state
operator|->
name|lenbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|val
operator|<
literal|16
condition|)
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|++
index|]
operator|=
name|this
operator|.
name|val
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|this
operator|.
name|val
operator|==
literal|16
condition|)
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
operator|+
literal|2
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|have
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid bit length repeat"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|-
literal|1
index|]
expr_stmt|;
name|copy
operator|=
literal|3
operator|+
name|BITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|val
operator|==
literal|17
condition|)
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
operator|+
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
literal|3
operator|+
name|BITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NEEDBITS
argument_list|(
name|this
operator|.
name|bits
operator|+
literal|7
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
literal|11
operator|+
name|BITS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|have
operator|+
name|copy
operator|>
name|state
operator|->
name|nlen
operator|+
name|state
operator|->
name|ndist
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid bit length repeat"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|copy
operator|--
condition|)
name|state
operator|->
name|lens
index|[
name|state
operator|->
name|have
operator|++
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|len
expr_stmt|;
block|}
block|}
comment|/* handle error breaks in while */
if|if
condition|(
name|state
operator|->
name|mode
operator|==
name|BAD
condition|)
break|break;
comment|/* build code tables */
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|codes
expr_stmt|;
name|state
operator|->
name|lencode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|state
operator|->
name|lenbits
operator|=
literal|9
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|LENS
argument_list|,
name|state
operator|->
name|lens
argument_list|,
name|state
operator|->
name|nlen
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|state
operator|->
name|lenbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/lengths set"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|distcode
operator|=
operator|(
name|code
specifier|const
name|FAR
operator|*
operator|)
operator|(
name|state
operator|->
name|next
operator|)
expr_stmt|;
name|state
operator|->
name|distbits
operator|=
literal|6
expr_stmt|;
name|ret
operator|=
name|inflate_table
argument_list|(
name|DISTS
argument_list|,
name|state
operator|->
name|lens
operator|+
name|state
operator|->
name|nlen
argument_list|,
name|state
operator|->
name|ndist
argument_list|,
operator|&
operator|(
name|state
operator|->
name|next
operator|)
argument_list|,
operator|&
operator|(
name|state
operator|->
name|distbits
operator|)
argument_list|,
name|state
operator|->
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distances set"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes ok\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
case|case
name|LEN
case|:
if|if
condition|(
name|have
operator|>=
literal|6
operator|&&
name|left
operator|>=
literal|258
condition|)
block|{
name|RESTORE
argument_list|()
expr_stmt|;
name|inflate_fast
argument_list|(
name|strm
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|LOAD
argument_list|()
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|lencode
index|[
name|BITS
argument_list|(
name|state
operator|->
name|lenbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|op
operator|&&
operator|(
name|this
operator|.
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|this
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|lencode
index|[
name|last
operator|.
name|val
operator|+
operator|(
name|BITS
argument_list|(
name|last
operator|.
name|bits
operator|+
name|last
operator|.
name|op
argument_list|)
operator|>>
name|last
operator|.
name|bits
operator|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|last
operator|.
name|bits
operator|+
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|last
operator|.
name|bits
argument_list|)
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|state
operator|->
name|length
operator|=
operator|(
name|unsigned
operator|)
name|this
operator|.
name|val
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|this
operator|.
name|op
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|this
operator|.
name|val
operator|>=
literal|0x20
operator|&&
name|this
operator|.
name|val
operator|<
literal|0x7f
condition|?
literal|"inflate:         literal '%c'\n"
else|:
literal|"inflate:         literal 0x%02x\n"
operator|,
name|this
operator|.
name|val
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|this
operator|.
name|op
operator|&
literal|32
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|this
operator|.
name|op
operator|&
literal|64
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/length code"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|extra
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|op
argument_list|)
operator|&
literal|15
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LENEXT
expr_stmt|;
case|case
name|LENEXT
case|:
if|if
condition|(
name|state
operator|->
name|extra
condition|)
block|{
name|NEEDBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|state
operator|->
name|length
operator|+=
name|BITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
block|}
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         length %u\n"
operator|,
name|state
operator|->
name|length
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|DIST
expr_stmt|;
case|case
name|DIST
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|distcode
index|[
name|BITS
argument_list|(
name|state
operator|->
name|distbits
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|this
operator|.
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0
condition|)
block|{
name|last
operator|=
name|this
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|this
operator|=
name|state
operator|->
name|distcode
index|[
name|last
operator|.
name|val
operator|+
operator|(
name|BITS
argument_list|(
name|last
operator|.
name|bits
operator|+
name|last
operator|.
name|op
argument_list|)
operator|>>
name|last
operator|.
name|bits
operator|)
index|]
expr_stmt|;
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|last
operator|.
name|bits
operator|+
name|this
operator|.
name|bits
argument_list|)
operator|<=
name|bits
condition|)
break|break;
name|PULLBYTE
argument_list|()
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|last
operator|.
name|bits
argument_list|)
expr_stmt|;
block|}
name|DROPBITS
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|op
operator|&
literal|64
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance code"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|state
operator|->
name|offset
operator|=
operator|(
name|unsigned
operator|)
name|this
operator|.
name|val
expr_stmt|;
name|state
operator|->
name|extra
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|op
argument_list|)
operator|&
literal|15
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|DISTEXT
expr_stmt|;
case|case
name|DISTEXT
case|:
if|if
condition|(
name|state
operator|->
name|extra
condition|)
block|{
name|NEEDBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|state
operator|->
name|offset
operator|+=
name|BITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
name|DROPBITS
argument_list|(
name|state
operator|->
name|extra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|offset
operator|>
name|state
operator|->
name|whave
operator|+
name|out
operator|-
name|left
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance too far back"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         distance %u\n"
operator|,
name|state
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|MATCH
expr_stmt|;
case|case
name|MATCH
case|:
if|if
condition|(
name|left
operator|==
literal|0
condition|)
goto|goto
name|inf_leave
goto|;
name|copy
operator|=
name|out
operator|-
name|left
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|offset
operator|>
name|copy
condition|)
block|{
comment|/* copy from window */
name|copy
operator|=
name|state
operator|->
name|offset
operator|-
name|copy
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|state
operator|->
name|write
condition|)
block|{
name|copy
operator|-=
name|state
operator|->
name|write
expr_stmt|;
name|from
operator|=
name|state
operator|->
name|window
operator|+
operator|(
name|state
operator|->
name|wsize
operator|-
name|copy
operator|)
expr_stmt|;
block|}
else|else
name|from
operator|=
name|state
operator|->
name|window
operator|+
operator|(
name|state
operator|->
name|write
operator|-
name|copy
operator|)
expr_stmt|;
if|if
condition|(
name|copy
operator|>
name|state
operator|->
name|length
condition|)
name|copy
operator|=
name|state
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
comment|/* copy from output */
name|from
operator|=
name|put
operator|-
name|state
operator|->
name|offset
expr_stmt|;
name|copy
operator|=
name|state
operator|->
name|length
expr_stmt|;
block|}
if|if
condition|(
name|copy
operator|>
name|left
condition|)
name|copy
operator|=
name|left
expr_stmt|;
name|left
operator|-=
name|copy
expr_stmt|;
name|state
operator|->
name|length
operator|-=
name|copy
expr_stmt|;
do|do
block|{
operator|*
name|put
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|copy
condition|)
do|;
if|if
condition|(
name|state
operator|->
name|length
operator|==
literal|0
condition|)
name|state
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
break|break;
case|case
name|LIT
case|:
if|if
condition|(
name|left
operator|==
literal|0
condition|)
goto|goto
name|inf_leave
goto|;
operator|*
name|put
operator|++
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|state
operator|->
name|length
argument_list|)
expr_stmt|;
name|left
operator|--
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
break|break;
case|case
name|CHECK
case|:
if|if
condition|(
name|state
operator|->
name|wrap
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|out
operator|-=
name|left
expr_stmt|;
name|strm
operator|->
name|total_out
operator|+=
name|out
expr_stmt|;
name|state
operator|->
name|total
operator|+=
name|out
expr_stmt|;
if|if
condition|(
name|out
condition|)
name|strm
operator|->
name|adler
operator|=
name|state
operator|->
name|check
operator|=
name|UPDATE
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|put
operator|-
name|out
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|out
operator|=
name|left
expr_stmt|;
if|if
condition|(
operator|(
ifdef|#
directive|ifdef
name|GUNZIP
name|state
operator|->
name|flags
condition|?
name|hold
else|:
endif|#
directive|endif
name|REVERSE
argument_list|(
name|hold
argument_list|)
operator|)
operator|!=
name|state
operator|->
name|check
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect data check"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|INITBITS
argument_list|()
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   check matches trailer\n"
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GUNZIP
name|state
operator|->
name|mode
operator|=
name|LENGTH
expr_stmt|;
case|case
name|LENGTH
case|:
if|if
condition|(
name|state
operator|->
name|wrap
operator|&&
name|state
operator|->
name|flags
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|hold
operator|!=
operator|(
name|state
operator|->
name|total
operator|&
literal|0xffffffffUL
operator|)
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"incorrect length check"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|INITBITS
argument_list|()
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   length matches trailer\n"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
case|case
name|DONE
case|:
name|ret
operator|=
name|Z_STREAM_END
expr_stmt|;
goto|goto
name|inf_leave
goto|;
case|case
name|BAD
case|:
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
goto|goto
name|inf_leave
goto|;
case|case
name|MEM
case|:
return|return
name|Z_MEM_ERROR
return|;
case|case
name|SYNC
case|:
default|default:
return|return
name|Z_STREAM_ERROR
return|;
block|}
comment|/*        Return from inflate(), updating the total counts and the check value.        If there was no progress during the inflate() call, return a buffer        error.  Call updatewindow() to create and/or update the window state.        Note: a memory error from inflate() is non-recoverable.      */
name|inf_leave
label|:
name|RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|wsize
operator|||
operator|(
name|state
operator|->
name|mode
operator|<
name|CHECK
operator|&&
name|out
operator|!=
name|strm
operator|->
name|avail_out
operator|)
condition|)
if|if
condition|(
name|updatewindow
argument_list|(
name|strm
argument_list|,
name|out
argument_list|)
condition|)
block|{
name|state
operator|->
name|mode
operator|=
name|MEM
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
name|in
operator|-=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|out
operator|-=
name|strm
operator|->
name|avail_out
expr_stmt|;
name|strm
operator|->
name|total_in
operator|+=
name|in
expr_stmt|;
name|strm
operator|->
name|total_out
operator|+=
name|out
expr_stmt|;
name|state
operator|->
name|total
operator|+=
name|out
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|wrap
operator|&&
name|out
condition|)
name|strm
operator|->
name|adler
operator|=
name|state
operator|->
name|check
operator|=
name|UPDATE
argument_list|(
name|state
operator|->
name|check
argument_list|,
name|strm
operator|->
name|next_out
operator|-
name|out
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|strm
operator|->
name|data_type
operator|=
name|state
operator|->
name|bits
operator|+
operator|(
name|state
operator|->
name|last
condition|?
literal|64
else|:
literal|0
operator|)
operator|+
operator|(
name|state
operator|->
name|mode
operator|==
name|TYPE
condition|?
literal|128
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|in
operator|==
literal|0
operator|&&
name|out
operator|==
literal|0
operator|)
operator|||
name|flush
operator|==
name|Z_FINISH
operator|)
operator|&&
name|ret
operator|==
name|Z_OK
condition|)
name|ret
operator|=
name|Z_BUF_ERROR
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateEnd
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|window
operator|!=
name|Z_NULL
condition|)
name|ZFREE
argument_list|(
name|strm
argument_list|,
name|state
operator|->
name|window
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|state
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateSetDictionary
parameter_list|(
name|strm
parameter_list|,
name|dictionary
parameter_list|,
name|dictLength
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|dictionary
decl_stmt|;
name|uInt
name|dictLength
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
name|unsigned
name|long
name|id
decl_stmt|;
comment|/* check state */
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|DICT
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* check for correct dictionary id */
name|id
operator|=
name|adler32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|id
operator|=
name|adler32
argument_list|(
name|id
argument_list|,
name|dictionary
argument_list|,
name|dictLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|state
operator|->
name|check
condition|)
return|return
name|Z_DATA_ERROR
return|;
comment|/* copy dictionary to window */
if|if
condition|(
name|updatewindow
argument_list|(
name|strm
argument_list|,
name|strm
operator|->
name|avail_out
argument_list|)
condition|)
block|{
name|state
operator|->
name|mode
operator|=
name|MEM
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
if|if
condition|(
name|dictLength
operator|>
name|state
operator|->
name|wsize
condition|)
block|{
name|zmemcpy
argument_list|(
name|state
operator|->
name|window
argument_list|,
name|dictionary
operator|+
name|dictLength
operator|-
name|state
operator|->
name|wsize
argument_list|,
name|state
operator|->
name|wsize
argument_list|)
expr_stmt|;
name|state
operator|->
name|whave
operator|=
name|state
operator|->
name|wsize
expr_stmt|;
block|}
else|else
block|{
name|zmemcpy
argument_list|(
name|state
operator|->
name|window
operator|+
name|state
operator|->
name|wsize
operator|-
name|dictLength
argument_list|,
name|dictionary
argument_list|,
name|dictLength
argument_list|)
expr_stmt|;
name|state
operator|->
name|whave
operator|=
name|dictLength
expr_stmt|;
block|}
name|state
operator|->
name|havedict
operator|=
literal|1
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   dictionary set\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*    Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found    or when out of input.  When called, *have is the number of pattern bytes    found in order so far, in 0..3.  On return *have is updated to the new    state.  If on return *have equals four, then the pattern was found and the    return value is how many bytes were read including the last byte of the    pattern.  If *have is less than four, then the pattern has not been found    yet and the return value is len.  In the latter case, syncsearch() can be    called again with more data and the *have state.  *have is initialized to    zero for the first call.  */
end_comment

begin_function
name|local
name|unsigned
name|syncsearch
parameter_list|(
name|have
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|FAR
modifier|*
name|have
decl_stmt|;
name|unsigned
name|char
name|FAR
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|unsigned
name|got
decl_stmt|;
name|unsigned
name|next
decl_stmt|;
name|got
operator|=
operator|*
name|have
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|len
operator|&&
name|got
operator|<
literal|4
condition|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|buf
index|[
name|next
index|]
argument_list|)
operator|==
operator|(
name|got
operator|<
literal|2
condition|?
literal|0
else|:
literal|0xff
operator|)
condition|)
name|got
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
name|next
index|]
condition|)
name|got
operator|=
literal|0
expr_stmt|;
else|else
name|got
operator|=
literal|4
operator|-
name|got
expr_stmt|;
name|next
operator|++
expr_stmt|;
block|}
operator|*
name|have
operator|=
name|got
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateSync
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
name|unsigned
name|len
decl_stmt|;
comment|/* number of bytes to look at or looked at */
name|unsigned
name|long
name|in
decl_stmt|,
name|out
decl_stmt|;
comment|/* temporary to save total_in and total_out */
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* to restore bit buffer to byte string */
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
comment|/* check parameters */
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
operator|&&
name|state
operator|->
name|bits
operator|<
literal|8
condition|)
return|return
name|Z_BUF_ERROR
return|;
comment|/* if first time, start search in bit buffer */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|SYNC
condition|)
block|{
name|state
operator|->
name|mode
operator|=
name|SYNC
expr_stmt|;
name|state
operator|->
name|hold
operator|<<=
name|state
operator|->
name|bits
operator|&
literal|7
expr_stmt|;
name|state
operator|->
name|bits
operator|-=
name|state
operator|->
name|bits
operator|&
literal|7
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|bits
operator|>=
literal|8
condition|)
block|{
name|buf
index|[
name|len
operator|++
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|state
operator|->
name|hold
argument_list|)
expr_stmt|;
name|state
operator|->
name|hold
operator|>>=
literal|8
expr_stmt|;
name|state
operator|->
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
name|syncsearch
argument_list|(
operator|&
operator|(
name|state
operator|->
name|have
operator|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* search available input */
name|len
operator|=
name|syncsearch
argument_list|(
operator|&
operator|(
name|state
operator|->
name|have
operator|)
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|strm
operator|->
name|avail_in
argument_list|)
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|-=
name|len
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|total_in
operator|+=
name|len
expr_stmt|;
comment|/* return no joy or set up to restart inflate() on a new block */
if|if
condition|(
name|state
operator|->
name|have
operator|!=
literal|4
condition|)
return|return
name|Z_DATA_ERROR
return|;
name|in
operator|=
name|strm
operator|->
name|total_in
expr_stmt|;
name|out
operator|=
name|strm
operator|->
name|total_out
expr_stmt|;
name|inflateReset
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|strm
operator|->
name|total_in
operator|=
name|in
expr_stmt|;
name|strm
operator|->
name|total_out
operator|=
name|out
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*    Returns true if inflate is currently at the end of a block generated by    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP    implementation to provide an additional safety check. PPP uses    Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored    block. When decompressing, PPP checks that at the end of input packet,    inflate is waiting for these length bytes.  */
end_comment

begin_function
name|int
name|ZEXPORT
name|inflateSyncPoint
parameter_list|(
name|strm
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
return|return
name|state
operator|->
name|mode
operator|==
name|STORED
operator|&&
name|state
operator|->
name|bits
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|inflateCopy
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|z_streamp
name|dest
decl_stmt|;
name|z_streamp
name|source
decl_stmt|;
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
name|struct
name|inflate_state
name|FAR
modifier|*
name|copy
decl_stmt|;
name|unsigned
name|char
name|FAR
modifier|*
name|window
decl_stmt|;
comment|/* check input */
if|if
condition|(
name|dest
operator|==
name|Z_NULL
operator|||
name|source
operator|==
name|Z_NULL
operator|||
name|source
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|source
operator|->
name|zalloc
operator|==
operator|(
name|alloc_func
operator|)
literal|0
operator|||
name|source
operator|->
name|zfree
operator|==
operator|(
name|free_func
operator|)
literal|0
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|source
operator|->
name|state
expr_stmt|;
comment|/* allocate space */
name|copy
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|source
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|window
operator|=
name|Z_NULL
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|window
operator|!=
name|Z_NULL
condition|)
block|{
name|window
operator|=
operator|(
name|unsigned
name|char
name|FAR
operator|*
operator|)
name|ZALLOC
argument_list|(
name|source
argument_list|,
literal|1U
operator|<<
name|state
operator|->
name|wbits
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|==
name|Z_NULL
condition|)
block|{
name|ZFREE
argument_list|(
name|source
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
block|}
comment|/* copy state */
operator|*
name|dest
operator|=
operator|*
name|source
expr_stmt|;
operator|*
name|copy
operator|=
operator|*
name|state
expr_stmt|;
name|copy
operator|->
name|lencode
operator|=
name|copy
operator|->
name|codes
operator|+
operator|(
name|state
operator|->
name|lencode
operator|-
name|state
operator|->
name|codes
operator|)
expr_stmt|;
name|copy
operator|->
name|distcode
operator|=
name|copy
operator|->
name|codes
operator|+
operator|(
name|state
operator|->
name|distcode
operator|-
name|state
operator|->
name|codes
operator|)
expr_stmt|;
name|copy
operator|->
name|next
operator|=
name|copy
operator|->
name|codes
operator|+
operator|(
name|state
operator|->
name|next
operator|-
name|state
operator|->
name|codes
operator|)
expr_stmt|;
if|if
condition|(
name|window
operator|!=
name|Z_NULL
condition|)
name|zmemcpy
argument_list|(
name|window
argument_list|,
name|state
operator|->
name|window
argument_list|,
literal|1U
operator|<<
name|state
operator|->
name|wbits
argument_list|)
expr_stmt|;
name|copy
operator|->
name|window
operator|=
name|window
expr_stmt|;
name|dest
operator|->
name|state
operator|=
operator|(
name|voidpf
operator|)
name|copy
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

end_unit

