begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* zutil.c -- target dependent utility functions for the compression library  * Copyright (C) 1995-2003 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/* @(#) $Id$ */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DUMMY_DECL
end_ifndef

begin_struct
struct|struct
name|internal_state
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* for buggy compilers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDC
end_ifndef

begin_decl_stmt
specifier|extern
name|void
name|exit
name|OF
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|z_errmsg
index|[
literal|10
index|]
init|=
block|{
literal|"need dictionary"
block|,
comment|/* Z_NEED_DICT       2  */
literal|"stream end"
block|,
comment|/* Z_STREAM_END      1  */
literal|""
block|,
comment|/* Z_OK              0  */
literal|"file error"
block|,
comment|/* Z_ERRNO         (-1) */
literal|"stream error"
block|,
comment|/* Z_STREAM_ERROR  (-2) */
literal|"data error"
block|,
comment|/* Z_DATA_ERROR    (-3) */
literal|"insufficient memory"
block|,
comment|/* Z_MEM_ERROR     (-4) */
literal|"buffer error"
block|,
comment|/* Z_BUF_ERROR     (-5) */
literal|"incompatible version"
block|,
comment|/* Z_VERSION_ERROR (-6) */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|ZEXPORT
name|zlibVersion
parameter_list|()
block|{
return|return
name|ZLIB_VERSION
return|;
block|}
end_function

begin_function
name|uLong
name|ZEXPORT
name|zlibCompileFlags
parameter_list|()
block|{
name|uLong
name|flags
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|uInt
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
break|break;
case|case
literal|4
case|:
name|flags
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|flags
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|flags
operator|+=
literal|3
expr_stmt|;
block|}
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|uLong
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
break|break;
case|case
literal|4
case|:
name|flags
operator|+=
literal|1
operator|<<
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|flags
operator|+=
literal|2
operator|<<
literal|2
expr_stmt|;
break|break;
default|default:
name|flags
operator|+=
literal|3
operator|<<
literal|2
expr_stmt|;
block|}
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|voidpf
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
break|break;
case|case
literal|4
case|:
name|flags
operator|+=
literal|1
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|flags
operator|+=
literal|2
operator|<<
literal|4
expr_stmt|;
break|break;
default|default:
name|flags
operator|+=
literal|3
operator|<<
literal|4
expr_stmt|;
block|}
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|z_off_t
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
break|break;
case|case
literal|4
case|:
name|flags
operator|+=
literal|1
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|flags
operator|+=
literal|2
operator|<<
literal|6
expr_stmt|;
break|break;
default|default:
name|flags
operator|+=
literal|3
operator|<<
literal|6
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|flags
operator|+=
literal|1
operator|<<
literal|8
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ASMV
argument_list|)
operator|||
name|defined
argument_list|(
name|ASMINF
argument_list|)
name|flags
operator|+=
literal|1
operator|<<
literal|9
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZLIB_WINAPI
name|flags
operator|+=
literal|1
operator|<<
literal|10
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BUILDFIXED
name|flags
operator|+=
literal|1
operator|<<
literal|12
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_CRC_TABLE
name|flags
operator|+=
literal|1
operator|<<
literal|13
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_GZCOMPRESS
name|flags
operator|+=
literal|1
operator|<<
literal|16
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_GZIP
name|flags
operator|+=
literal|1
operator|<<
literal|17
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
name|flags
operator|+=
literal|1
operator|<<
literal|20
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FASTEST
name|flags
operator|+=
literal|1
operator|<<
literal|21
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STDC
ifdef|#
directive|ifdef
name|NO_vsnprintf
name|flags
operator|+=
literal|1
operator|<<
literal|25
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_vsprintf_void
name|flags
operator|+=
literal|1
operator|<<
literal|26
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_vsnprintf_void
name|flags
operator|+=
literal|1
operator|<<
literal|26
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
name|flags
operator|+=
literal|1
operator|<<
literal|24
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_snprintf
name|flags
operator|+=
literal|1
operator|<<
literal|25
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_sprintf_void
name|flags
operator|+=
literal|1
operator|<<
literal|26
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_snprintf_void
name|flags
operator|+=
literal|1
operator|<<
literal|26
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
return|return
name|flags
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|verbose
end_ifndef

begin_define
define|#
directive|define
name|verbose
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|z_verbose
init|=
name|verbose
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|z_error
parameter_list|(
name|m
parameter_list|)
name|char
modifier|*
name|m
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* exported to allow conversion of error code to string for compress() and  * uncompress()  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ZEXPORT
name|zError
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
return|return
name|ERR_MSG
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32_WCE
argument_list|)
end_if

begin_comment
comment|/* does not exist on WCE */
end_comment

begin_decl_stmt
name|int
name|errno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMCPY
end_ifndef

begin_function
name|void
name|zmemcpy
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|len
parameter_list|)
name|Bytef
modifier|*
name|dest
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|source
decl_stmt|;
name|uInt
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
do|do
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|source
operator|++
expr_stmt|;
comment|/* ??? to be unrolled */
block|}
do|while
condition|(
operator|--
name|len
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_function
name|int
name|zmemcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
specifier|const
name|Bytef
modifier|*
name|s1
decl_stmt|;
specifier|const
name|Bytef
modifier|*
name|s2
decl_stmt|;
name|uInt
name|len
decl_stmt|;
block|{
name|uInt
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|s1
index|[
name|j
index|]
operator|!=
name|s2
index|[
name|j
index|]
condition|)
return|return
literal|2
operator|*
operator|(
name|s1
index|[
name|j
index|]
operator|>
name|s2
index|[
name|j
index|]
operator|)
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|zmemzero
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
name|Bytef
modifier|*
name|dest
decl_stmt|;
name|uInt
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
do|do
block|{
operator|*
name|dest
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* ??? to be unrolled */
block|}
do|while
condition|(
operator|--
name|len
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS16BIT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__TURBOC__
end_ifdef

begin_comment
comment|/* Turbo C in 16-bit mode */
end_comment

begin_define
define|#
directive|define
name|MY_ZCALLOC
end_define

begin_comment
comment|/* Turbo C malloc() does not allow dynamic allocation of 64K bytes  * and farmalloc(64K) returns a pointer with an offset of 8, so we  * must fix the pointer. Warning: the pointer must be put back to its  * original form in order to free it, use zcfree().  */
end_comment

begin_define
define|#
directive|define
name|MAX_PTR
value|10
end_define

begin_comment
comment|/* 10*64K = 640K */
end_comment

begin_decl_stmt
name|local
name|int
name|next_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ptr_table_s
block|{
name|voidpf
name|org_ptr
decl_stmt|;
name|voidpf
name|new_ptr
decl_stmt|;
block|}
name|ptr_table
typedef|;
end_typedef

begin_decl_stmt
name|local
name|ptr_table
name|table
index|[
name|MAX_PTR
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is used to remember the original form of pointers  * to large buffers (64K). Such pointers are normalized with a zero offset.  * Since MSDOS is not a preemptive multitasking OS, this table is not  * protected from concurrent access. This hack doesn't work anyway on  * a protected system like OS/2. Use Microsoft C instead.  */
end_comment

begin_function
name|voidpf
name|zcalloc
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|unsigned
name|items
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
name|voidpf
name|buf
init|=
name|opaque
decl_stmt|;
comment|/* just to make some compilers happy */
name|ulg
name|bsize
init|=
operator|(
name|ulg
operator|)
name|items
operator|*
name|size
decl_stmt|;
comment|/* If we allocate less than 65520 bytes, we assume that farmalloc      * will return a usable pointer which doesn't have to be normalized.      */
if|if
condition|(
name|bsize
operator|<
literal|65520L
condition|)
block|{
name|buf
operator|=
name|farmalloc
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|ush
operator|*
operator|)
operator|&
name|buf
operator|!=
literal|0
condition|)
return|return
name|buf
return|;
block|}
else|else
block|{
name|buf
operator|=
name|farmalloc
argument_list|(
name|bsize
operator|+
literal|16L
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
name|next_ptr
operator|>=
name|MAX_PTR
condition|)
return|return
name|NULL
return|;
name|table
index|[
name|next_ptr
index|]
operator|.
name|org_ptr
operator|=
name|buf
expr_stmt|;
comment|/* Normalize the pointer to seg:0 */
operator|*
operator|(
operator|(
name|ush
operator|*
operator|)
operator|&
name|buf
operator|+
literal|1
operator|)
operator|+=
operator|(
call|(
name|ush
call|)
argument_list|(
operator|(
name|uch
operator|*
operator|)
name|buf
operator|-
literal|0
argument_list|)
operator|+
literal|15
operator|)
operator|>>
literal|4
expr_stmt|;
operator|*
operator|(
name|ush
operator|*
operator|)
operator|&
name|buf
operator|=
literal|0
expr_stmt|;
name|table
index|[
name|next_ptr
operator|++
index|]
operator|.
name|new_ptr
operator|=
name|buf
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|void
name|zcfree
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|voidpf
name|ptr
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|ush
operator|*
operator|)
operator|&
name|ptr
operator|!=
literal|0
condition|)
block|{
comment|/* object< 64K */
name|farfree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the original pointer */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|next_ptr
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|table
index|[
name|n
index|]
operator|.
name|new_ptr
condition|)
continue|continue;
name|farfree
argument_list|(
name|table
index|[
name|n
index|]
operator|.
name|org_ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|n
operator|<
name|next_ptr
condition|)
block|{
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|table
index|[
name|n
index|]
expr_stmt|;
block|}
name|next_ptr
operator|--
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
name|opaque
expr_stmt|;
comment|/* just to make some compilers happy */
name|Assert
argument_list|(
literal|0
argument_list|,
literal|"zcfree: ptr not found"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __TURBOC__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|M_I86
end_ifdef

begin_comment
comment|/* Microsoft C in 16-bit mode */
end_comment

begin_define
define|#
directive|define
name|MY_ZCALLOC
end_define

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|_MSC_VER
operator|<=
literal|600
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|_halloc
value|halloc
end_define

begin_define
define|#
directive|define
name|_hfree
value|hfree
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|voidpf
name|zcalloc
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|unsigned
name|items
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
if|if
condition|(
name|opaque
condition|)
name|opaque
operator|=
literal|0
expr_stmt|;
comment|/* to make compiler happy */
return|return
name|_halloc
argument_list|(
operator|(
name|long
operator|)
name|items
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|zcfree
parameter_list|(
name|voidpf
name|opaque
parameter_list|,
name|voidpf
name|ptr
parameter_list|)
block|{
if|if
condition|(
name|opaque
condition|)
name|opaque
operator|=
literal|0
expr_stmt|;
comment|/* to make compiler happy */
name|_hfree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* M_I86 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS16BIT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_ZCALLOC
end_ifndef

begin_comment
comment|/* Any system without a special alloc function */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STDC
end_ifndef

begin_decl_stmt
specifier|extern
name|voidp
name|malloc
name|OF
argument_list|(
operator|(
name|uInt
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|voidp
name|calloc
name|OF
argument_list|(
operator|(
name|uInt
name|items
operator|,
name|uInt
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free
name|OF
argument_list|(
operator|(
name|voidpf
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|voidpf
name|zcalloc
parameter_list|(
name|opaque
parameter_list|,
name|items
parameter_list|,
name|size
parameter_list|)
name|voidpf
name|opaque
decl_stmt|;
name|unsigned
name|items
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
if|if
condition|(
name|opaque
condition|)
name|items
operator|+=
name|size
operator|-
name|size
expr_stmt|;
comment|/* make compiler happy */
return|return
sizeof|sizeof
argument_list|(
name|uInt
argument_list|)
operator|>
literal|2
condition|?
operator|(
name|voidpf
operator|)
name|malloc
argument_list|(
name|items
operator|*
name|size
argument_list|)
else|:
operator|(
name|voidpf
operator|)
name|calloc
argument_list|(
name|items
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|zcfree
parameter_list|(
name|opaque
parameter_list|,
name|ptr
parameter_list|)
name|voidpf
name|opaque
decl_stmt|;
name|voidpf
name|ptr
decl_stmt|;
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|opaque
condition|)
return|return;
comment|/* make compiler happy */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MY_ZCALLOC */
end_comment

end_unit

