begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* scsi: SCSI user library  */
end_comment

begin_comment
comment|/* Copyright (c) 1994 HD Associates  * (contact: dufault@hda.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * This product includes software developed by HD Associates  * 4. Neither the name of the HD Associaates nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY HD ASSOCIATES``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL HD ASSOCIATES OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/scsiio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"scsi.h"
end_include

begin_struct
specifier|static
struct|struct
block|{
name|FILE
modifier|*
name|db_f
decl_stmt|;
name|int
name|db_level
decl_stmt|;
name|int
name|db_trunc
decl_stmt|;
block|}
name|behave
struct|;
end_struct

begin_comment
comment|/* scsireq_reset: Reset a scsireq structure.  */
end_comment

begin_function
name|scsireq_t
modifier|*
name|scsireq_reset
parameter_list|(
name|scsireq_t
modifier|*
name|scsireq
parameter_list|)
block|{
if|if
condition|(
name|scsireq
operator|==
literal|0
condition|)
return|return
name|scsireq
return|;
name|scsireq
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* info about the request status and type */
name|scsireq
operator|->
name|timeout
operator|=
literal|2000
expr_stmt|;
comment|/* 2 seconds */
name|bzero
argument_list|(
name|scsireq
operator|->
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsireq
operator|->
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsireq
operator|->
name|cmdlen
operator|=
literal|0
expr_stmt|;
comment|/* Leave scsireq->databuf alone */
comment|/* Leave scsireq->datalen alone */
name|scsireq
operator|->
name|datalen_used
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|scsireq
operator|->
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
name|scsireq
operator|->
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|scsireq
operator|->
name|senselen
operator|=
sizeof|sizeof
argument_list|(
name|scsireq
operator|->
name|sense
argument_list|)
expr_stmt|;
name|scsireq
operator|->
name|senselen_used
operator|=
literal|0
expr_stmt|;
name|scsireq
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scsireq
operator|->
name|retsts
operator|=
literal|0
expr_stmt|;
name|scsireq
operator|->
name|error
operator|=
literal|0
expr_stmt|;
return|return
name|scsireq
return|;
block|}
end_function

begin_comment
comment|/* scsireq_new: Allocate and initialize a new scsireq.  */
end_comment

begin_function
name|scsireq_t
modifier|*
name|scsireq_new
parameter_list|(
name|void
parameter_list|)
block|{
name|scsireq_t
modifier|*
name|p
init|=
operator|(
name|scsireq_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scsireq_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|scsireq_reset
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Decode: Decode the data section of a scsireq.  This decodes  * trivial grammar:  *  * fields : field fields  *        ;  *  * field : field_specifier  *       | control  *       ;  *  * control : 's' seek_value  *       | 's' '+' seek_value  *       ;  *  * seek_value : DECIMAL_NUMBER  *       | 'v'				// For indirect seek, i.e., value from the arg list  *       ;  *  * field_specifier : type_specifier field_width  *       | '{' NAME '}' type_specifier field_width  *       ;  *  * field_width : DECIMAL_NUMBER  *       ;  *  * type_specifier : 'i'	// Integral types (i1, i2, i3, i4)  *       | 'b'				// Bits  *       | 't'				// Bits  *       | 'c'				// Character arrays  *       | 'z'				// Character arrays with zeroed trailing spaces  *       ;  *  * Notes:  * 1. Integral types are swapped into host order.  * 2. Bit fields are allocated MSB to LSB to match the SCSI spec documentation.  * 3. 's' permits "seeking" in the string.  "s+DECIMAL" seeks relative to  *    DECIMAL; "sDECIMAL" seeks absolute to decimal.  * 4. 's' permits an indirect reference.  "sv" or "s+v" will get the  *    next integer value from the arg array.  * 5. Field names can be anything between the braces  *  * BUGS:  * i and b types are promoted to ints.  *  */
end_comment

begin_function
specifier|static
name|int
name|do_buff_decode
parameter_list|(
name|u_char
modifier|*
name|databuf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
function_decl|(
modifier|*
name|arg_put
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|puthook
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|assigned
init|=
literal|0
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|suppress
decl_stmt|;
name|int
name|plus
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|mask
index|[]
init|=
block|{
literal|0
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|}
decl_stmt|;
name|int
name|value
decl_stmt|;
name|u_char
modifier|*
name|base
init|=
name|databuf
decl_stmt|;
name|char
name|letter
decl_stmt|;
name|char
name|field_name
index|[
literal|80
index|]
decl_stmt|;
define|#
directive|define
name|ARG_PUT
parameter_list|(
name|ARG
parameter_list|)
define|\
value|do \ 	{ \ 		if (!suppress) \ 		{ \ 			if (arg_put) \ 				(*arg_put)(puthook, (letter == 't' ? 'b' : letter), \ 				(void *)((long)(ARG)), 1, field_name); \ 			else \ 				*(va_arg(ap, int *)) = (ARG); \ 			assigned++; \ 		} \ 		field_name[0] = 0; \ 		suppress = 0; \ 	} while (0)
name|u_char
name|bits
init|=
literal|0
decl_stmt|;
comment|/* For bit fields */
name|int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* Bits already shifted out */
name|suppress
operator|=
literal|0
expr_stmt|;
name|field_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
name|letter
operator|=
operator|*
name|fmt
condition|)
block|{
case|case
literal|' '
case|:
comment|/* White space */
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\f'
case|:
name|fmt
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Comment */
while|while
condition|(
operator|*
name|fmt
operator|&&
operator|(
operator|*
name|fmt
operator|!=
literal|'\n'
operator|)
condition|)
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
name|fmt
operator|++
expr_stmt|;
comment|/* Skip '\n' */
break|break;
case|case
literal|'*'
case|:
comment|/* Suppress assignment */
name|fmt
operator|++
expr_stmt|;
name|suppress
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* Field Name */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|fmt
operator|++
expr_stmt|;
comment|/* Skip '{' */
while|while
condition|(
operator|*
name|fmt
operator|&&
operator|(
operator|*
name|fmt
operator|!=
literal|'}'
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|field_name
argument_list|)
condition|)
name|field_name
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|fmt
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fmt
condition|)
name|fmt
operator|++
expr_stmt|;
comment|/* Skip '}' */
name|field_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* Bit (field) */
case|case
literal|'b'
case|:
comment|/* Bits */
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|8
condition|)
name|done
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|shift
operator|<=
literal|0
condition|)
block|{
name|bits
operator|=
operator|*
name|databuf
operator|++
expr_stmt|;
name|shift
operator|=
literal|8
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|bits
operator|>>
operator|(
name|shift
operator|-
name|width
operator|)
operator|)
operator|&
name|mask
index|[
name|width
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|printf("shift %2d bits %02x value %02x width %2d mask %02x\n", 				shift, bits, value, width, mask[width]);
endif|#
directive|endif
name|ARG_PUT
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|width
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
comment|/* Integral values */
name|shift
operator|=
literal|0
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|ARG_PUT
argument_list|(
operator|*
name|databuf
argument_list|)
expr_stmt|;
name|databuf
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ARG_PUT
argument_list|(
operator|(
operator|*
name|databuf
operator|)
operator|<<
literal|8
operator||
operator|*
operator|(
name|databuf
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|databuf
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ARG_PUT
argument_list|(
operator|(
operator|*
name|databuf
operator|)
operator|<<
literal|16
operator||
operator|(
operator|*
operator|(
name|databuf
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|8
operator||
operator|*
operator|(
name|databuf
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|databuf
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ARG_PUT
argument_list|(
operator|(
operator|*
name|databuf
operator|)
operator|<<
literal|24
operator||
operator|(
operator|*
operator|(
name|databuf
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|16
operator||
operator|(
operator|*
operator|(
name|databuf
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator||
operator|*
operator|(
name|databuf
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|databuf
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* Characters (i.e., not swapped) */
case|case
literal|'z'
case|:
comment|/* Characters with zeroed trailing spaces  */
name|shift
operator|=
literal|0
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|suppress
condition|)
block|{
if|if
condition|(
name|arg_put
condition|)
call|(
modifier|*
name|arg_put
call|)
argument_list|(
name|puthook
argument_list|,
operator|(
name|letter
operator|==
literal|'t'
condition|?
literal|'b'
else|:
name|letter
operator|)
argument_list|,
name|databuf
argument_list|,
name|width
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|dest
decl_stmt|;
name|dest
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|databuf
argument_list|,
name|dest
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
operator|==
literal|'z'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|dest
operator|+
name|width
operator|-
literal|1
init|;
operator|(
name|p
operator|>=
operator|(
name|char
operator|*
operator|)
name|dest
operator|)
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
condition|;
name|p
operator|--
control|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|assigned
operator|++
expr_stmt|;
block|}
name|databuf
operator|+=
name|width
expr_stmt|;
name|field_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|suppress
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Seek */
name|shift
operator|=
literal|0
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'+'
condition|)
block|{
name|plus
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
name|plus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|fmt
argument_list|)
operator|==
literal|'v'
condition|)
block|{
comment|/* You can't suppress a seek value.  You also 				 * can't have a variable seek when you are using 				 * "arg_put". 				 */
name|width
operator|=
operator|(
name|arg_put
operator|)
condition|?
literal|0
else|:
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|plus
condition|)
name|databuf
operator|+=
name|width
expr_stmt|;
comment|/* Relative seek */
else|else
name|databuf
operator|=
name|base
operator|+
name|width
expr_stmt|;
comment|/* Absolute seek */
break|break;
case|case
literal|0
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown letter in format: %c\n"
argument_list|,
name|letter
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
block|}
return|return
name|assigned
return|;
block|}
end_function

begin_function
name|int
name|scsireq_decode
parameter_list|(
name|scsireq_t
modifier|*
name|scsireq
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
name|do_buff_decode
argument_list|(
name|scsireq
operator|->
name|databuf
argument_list|,
operator|(
name|size_t
operator|)
name|scsireq
operator|->
name|datalen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scsireq_decode_visit
parameter_list|(
name|scsireq_t
modifier|*
name|scsireq
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|void
function_decl|(
modifier|*
name|arg_put
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|puthook
parameter_list|)
block|{
name|va_list
name|ap
init|=
operator|(
name|va_list
operator|)
literal|0
decl_stmt|;
return|return
name|do_buff_decode
argument_list|(
name|scsireq
operator|->
name|databuf
argument_list|,
operator|(
name|size_t
operator|)
name|scsireq
operator|->
name|datalen
argument_list|,
name|arg_put
argument_list|,
name|puthook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scsireq_buff_decode
parameter_list|(
name|u_char
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
name|do_buff_decode
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scsireq_buff_decode_visit
parameter_list|(
name|u_char
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|void
function_decl|(
modifier|*
name|arg_put
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|puthook
parameter_list|)
block|{
name|va_list
name|ap
init|=
operator|(
name|va_list
operator|)
literal|0
decl_stmt|;
return|return
name|do_buff_decode
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
name|arg_put
argument_list|,
name|puthook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* next_field: Return the next field in a command specifier.  This  * builds up a SCSI command using this trivial grammar:  *  * fields : field fields  *        ;  *  * field : value  *       | value ':' field_width  *       ;  *  * field_width : digit  *       | 'i' digit		// i2 = 2 byte integer, i3 = 3 byte integer etc.  *       ;  *  * value : HEX_NUMBER  *       | 'v'				// For indirection.  *       ;  *  * Notes:  *  Bit fields are specified MSB first to match the SCSI spec.  *  * Examples:  *  TUR: "0 0 0 0 0 0"  *  WRITE BUFFER: "38 v:3 0:2 0:3 v v:i3 v:i3 0", mode, buffer_id, list_length  *  * The function returns the value:  *  0: For reached end, with error_p set if an error was found  *  1: For valid stuff setup  *  2: For "v" was entered as the value (implies use varargs)  *  */
end_comment

begin_function
specifier|static
name|int
name|next_field
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|int
modifier|*
name|width_p
parameter_list|,
name|int
modifier|*
name|value_p
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|n_name
parameter_list|,
name|int
modifier|*
name|error_p
parameter_list|,
name|int
modifier|*
name|suppress_p
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|something
init|=
literal|0
decl_stmt|;
enum|enum
block|{
name|BETWEEN_FIELDS
block|,
name|START_FIELD
block|,
name|GET_FIELD
block|,
name|DONE
block|, 	}
name|state
enum|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|field_size
decl_stmt|;
comment|/* Default to byte field type... */
name|int
name|field_width
decl_stmt|;
comment|/* 1 byte wide */
name|int
name|is_error
init|=
literal|0
decl_stmt|;
name|int
name|suppress
init|=
literal|0
decl_stmt|;
name|field_size
operator|=
literal|8
expr_stmt|;
comment|/* Default to byte field type... */
operator|*
name|fmt
operator|=
literal|'i'
expr_stmt|;
name|field_width
operator|=
literal|1
expr_stmt|;
comment|/* 1 byte wide */
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|BETWEEN_FIELDS
expr_stmt|;
while|while
condition|(
name|state
operator|!=
name|DONE
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|BETWEEN_FIELDS
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|state
operator|=
name|DONE
expr_stmt|;
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|i
operator|<
name|n_name
condition|)
block|{
name|name
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
name|i
operator|<
name|n_name
condition|)
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|suppress
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|something
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|state
operator|=
name|START_FIELD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'v'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
name|state
operator|=
name|START_FIELD
expr_stmt|;
block|}
comment|/* Try to work without the "v".  */
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'i'
expr_stmt|;
name|field_size
operator|=
literal|8
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
comment|/* XXX: B can't work: Sees the 'b' as a hex digit in "isxdigit".  *      try "t" for bit field.  */
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'b'
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'s'
condition|)
comment|/* Seek */
block|{
operator|*
name|fmt
operator|=
literal|'s'
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'v'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
block|}
else|else
block|{
name|something
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|DONE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid starting character: %c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|is_error
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
break|break;
case|case
name|START_FIELD
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
comment|/* Default to bits when specified */
name|state
operator|=
name|GET_FIELD
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DONE
expr_stmt|;
break|break;
case|case
name|GET_FIELD
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|fmt
operator|=
literal|'b'
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'i'
condition|)
comment|/* Integral (bytes) */
block|{
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'i'
expr_stmt|;
name|field_size
operator|=
literal|8
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
condition|)
comment|/* Bits */
block|{
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'b'
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid startfield %c (%02x)\n"
argument_list|,
operator|*
name|p
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|is_error
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
break|break;
case|case
name|DONE
case|:
break|break;
block|}
block|}
if|if
condition|(
name|is_error
condition|)
block|{
operator|*
name|error_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|error_p
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
operator|*
name|width_p
operator|=
name|field_width
operator|*
name|field_size
expr_stmt|;
operator|*
name|value_p
operator|=
name|value
expr_stmt|;
operator|*
name|suppress_p
operator|=
name|suppress
expr_stmt|;
return|return
name|something
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_encode
parameter_list|(
name|u_char
modifier|*
name|buff
parameter_list|,
name|size_t
name|vec_max
parameter_list|,
name|size_t
modifier|*
name|used
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|ind
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|width
decl_stmt|,
name|value
decl_stmt|,
name|error
decl_stmt|,
name|suppress
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|encoded
init|=
literal|0
decl_stmt|;
name|char
name|field_name
index|[
literal|80
index|]
decl_stmt|;
name|ind
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|next_field
argument_list|(
operator|&
name|fmt
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|value
argument_list|,
name|field_name
argument_list|,
sizeof|sizeof
argument_list|(
name|field_name
argument_list|)
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|suppress
argument_list|)
operator|)
condition|)
block|{
name|encoded
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|suppress
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|=
name|arg_get
condition|?
call|(
modifier|*
name|arg_get
call|)
argument_list|(
name|gethook
argument_list|,
name|field_name
argument_list|)
else|:
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf( "do_encode: ret %d fmt %c width %d value %d name \"%s\" error %d suppress %d\n", 		ret, c, width, value, field_name, error, suppress);
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
comment|/* Absolute seek */
block|{
name|ind
operator|=
name|value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|width
operator|<
literal|8
condition|)
comment|/* A width of< 8 is a bit field. */
block|{
comment|/* This is a bit field.  We start with the high bits 			 * so it reads the same as the SCSI spec. 			 */
name|shift
operator|+=
name|width
expr_stmt|;
name|val
operator||=
operator|(
name|value
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|ind
operator|<
name|vec_max
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|shift
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|shift
condition|)
block|{
if|if
condition|(
name|ind
operator|<
name|vec_max
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|shift
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|8
case|:
comment|/* 1 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
condition|)
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* 2 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
operator|-
literal|2
operator|+
literal|1
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
comment|/* 3 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
operator|-
literal|3
operator|+
literal|1
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
comment|/* 4 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
operator|-
literal|4
operator|+
literal|1
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|24
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"do_encode: Illegal width\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Flush out any remaining bits 	 */
if|if
condition|(
name|shift
operator|&&
name|ind
operator|<
name|vec_max
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|ind
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|encoded
return|;
block|}
end_function

begin_comment
comment|/* XXX: Should be a constant in scsiio.h  */
end_comment

begin_define
define|#
directive|define
name|CMD_BUFLEN
value|16
end_define

begin_function
name|scsireq_t
modifier|*
name|scsireq_build
parameter_list|(
name|scsireq_t
modifier|*
name|scsireq
parameter_list|,
name|u_long
name|datalen
parameter_list|,
name|caddr_t
name|databuf
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|char
modifier|*
name|cmd_spec
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|cmdlen
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|scsireq
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|scsireq_reset
argument_list|(
name|scsireq
argument_list|)
expr_stmt|;
if|if
condition|(
name|databuf
condition|)
block|{
name|scsireq
operator|->
name|databuf
operator|=
name|databuf
expr_stmt|;
name|scsireq
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|scsireq
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* XXX: Good way to get a memory leak.  Perhaps this should be 		 * removed. 		 */
if|if
condition|(
operator|(
name|scsireq
operator|->
name|databuf
operator|=
name|malloc
argument_list|(
name|datalen
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|scsireq
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|scsireq
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmd_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_encode
argument_list|(
name|scsireq
operator|->
name|cmd
argument_list|,
name|CMD_BUFLEN
argument_list|,
operator|&
name|cmdlen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cmd_spec
argument_list|,
name|ap
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|scsireq
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
return|return
name|scsireq
return|;
block|}
end_function

begin_function
name|scsireq_t
modifier|*
name|scsireq_build_visit
parameter_list|(
name|scsireq_t
modifier|*
name|scsireq
parameter_list|,
name|u_long
name|datalen
parameter_list|,
name|caddr_t
name|databuf
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|char
modifier|*
name|cmd_spec
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|field_name
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|)
block|{
name|int
name|cmdlen
decl_stmt|;
name|va_list
name|ap
init|=
operator|(
name|va_list
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|scsireq
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|scsireq_reset
argument_list|(
name|scsireq
argument_list|)
expr_stmt|;
if|if
condition|(
name|databuf
condition|)
block|{
name|scsireq
operator|->
name|databuf
operator|=
name|databuf
expr_stmt|;
name|scsireq
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|scsireq
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* XXX: Good way to get a memory leak.  Perhaps this should be 		 * removed. 		 */
if|if
condition|(
operator|(
name|scsireq
operator|->
name|databuf
operator|=
name|malloc
argument_list|(
name|datalen
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|scsireq
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|scsireq
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
if|if
condition|(
name|do_encode
argument_list|(
name|scsireq
operator|->
name|cmd
argument_list|,
name|CMD_BUFLEN
argument_list|,
operator|&
name|cmdlen
argument_list|,
name|arg_get
argument_list|,
name|gethook
argument_list|,
name|cmd_spec
argument_list|,
name|ap
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|scsireq
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
return|return
name|scsireq
return|;
block|}
end_function

begin_function
name|int
name|scsireq_encode
parameter_list|(
name|scsireq_t
modifier|*
name|scsireq
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|scsireq
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
name|do_encode
argument_list|(
name|scsireq
operator|->
name|databuf
argument_list|,
name|scsireq
operator|->
name|datalen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scsireq_buff_encode_visit
parameter_list|(
name|u_char
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|field_name
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|)
block|{
name|va_list
name|ap
init|=
operator|(
name|va_list
operator|)
literal|0
decl_stmt|;
return|return
name|do_encode
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|arg_get
argument_list|,
name|gethook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scsireq_encode_visit
parameter_list|(
name|scsireq_t
modifier|*
name|scsireq
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|field_name
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|)
block|{
name|va_list
name|ap
init|=
operator|(
name|va_list
operator|)
literal|0
decl_stmt|;
return|return
name|do_encode
argument_list|(
name|scsireq
operator|->
name|databuf
argument_list|,
name|scsireq
operator|->
name|datalen
argument_list|,
literal|0
argument_list|,
name|arg_get
argument_list|,
name|gethook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|scsi_debug_output
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|0
condition|)
name|behave
operator|.
name|db_f
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|behave
operator|.
name|db_f
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|behave
operator|.
name|db_f
operator|==
literal|0
condition|)
name|behave
operator|.
name|db_f
operator|=
name|stderr
expr_stmt|;
block|}
return|return
name|behave
operator|.
name|db_f
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SCSI_TRUNCATE
value|-1
end_define

begin_typedef
typedef|typedef
struct|struct
name|scsi_assoc
block|{
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|}
name|scsi_assoc_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|scsi_assoc_t
name|retsts
index|[]
init|=
block|{
block|{
name|SCCMD_OK
block|,
literal|"No error"
block|}
block|,
block|{
name|SCCMD_TIMEOUT
block|,
literal|"Command Timeout"
block|}
block|,
block|{
name|SCCMD_BUSY
block|,
literal|"Busy"
block|}
block|,
block|{
name|SCCMD_SENSE
block|,
literal|"Sense Returned"
block|}
block|,
block|{
name|SCCMD_UNKNOWN
block|,
literal|"Unknown return status"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|scsi_assoc_text
parameter_list|(
name|int
name|code
parameter_list|,
name|scsi_assoc_t
modifier|*
name|tab
parameter_list|)
block|{
while|while
condition|(
name|tab
operator|->
name|text
condition|)
block|{
if|if
condition|(
name|tab
operator|->
name|code
operator|==
name|code
condition|)
return|return
name|tab
operator|->
name|text
return|;
name|tab
operator|++
expr_stmt|;
block|}
return|return
literal|"Unknown code"
return|;
block|}
end_function

begin_function
name|void
name|scsi_dump
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|req
parameter_list|,
name|int
name|got
parameter_list|,
name|int
name|dump_print
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|trunc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
operator|||
name|req
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s (%d of %d):\n"
argument_list|,
name|text
argument_list|,
name|got
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|behave
operator|.
name|db_trunc
operator|!=
operator|-
literal|1
operator|&&
name|got
operator|>
name|behave
operator|.
name|db_trunc
condition|)
block|{
name|trunc
operator|=
literal|1
expr_stmt|;
name|got
operator|=
name|behave
operator|.
name|db_trunc
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|got
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%02x"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|==
literal|15
operator|||
name|i
operator|==
name|got
operator|-
literal|1
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|dump_print
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" # "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|15
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
name|putc
argument_list|(
operator|(
name|isprint
argument_list|(
name|p
index|[
name|j
index|]
argument_list|)
condition|?
name|p
index|[
name|j
index|]
else|:
literal|'.'
operator|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|trunc
operator|)
condition|?
literal|"(truncated)...\n"
else|:
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX: sense_7x_dump and scsi_sense dump was just sort of  * grabbed out of the old ds  * library and not really merged in carefully.  It should use the  * new buffer decoding stuff.  */
end_comment

begin_comment
comment|/* Get unsigned long.  */
end_comment

begin_function
specifier|static
name|u_long
name|g_u_long
parameter_list|(
name|u_char
modifier|*
name|s
parameter_list|)
block|{
return|return
operator|(
name|s
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|s
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|s
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|s
index|[
literal|3
index|]
return|;
block|}
end_function

begin_comment
comment|/* In the old software you could patch in a special error table:  */
end_comment

begin_decl_stmt
name|scsi_assoc_t
modifier|*
name|error_table
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sense_7x_dump
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|scsireq_t
modifier|*
name|scsireq
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|u_char
modifier|*
name|s
init|=
operator|(
name|u_char
operator|*
operator|)
name|scsireq
operator|->
name|sense
decl_stmt|;
name|int
name|valid
init|=
operator|(
operator|*
name|s
operator|)
operator|&
literal|0x80
decl_stmt|;
name|u_long
name|val
decl_stmt|;
specifier|static
name|scsi_assoc_t
name|sense
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|"No sense"
block|}
block|,
block|{
literal|1
block|,
literal|"Recovered error"
block|}
block|,
block|{
literal|2
block|,
literal|"Not Ready"
block|}
block|,
block|{
literal|3
block|,
literal|"Medium error"
block|}
block|,
block|{
literal|4
block|,
literal|"Hardware error"
block|}
block|,
block|{
literal|5
block|,
literal|"Illegal request"
block|}
block|,
block|{
literal|6
block|,
literal|"Unit attention"
block|}
block|,
block|{
literal|7
block|,
literal|"Data protect"
block|}
block|,
block|{
literal|8
block|,
literal|"Blank check"
block|}
block|,
block|{
literal|9
block|,
literal|"Vendor specific"
block|}
block|,
block|{
literal|0xa
block|,
literal|"Copy aborted"
block|}
block|,
block|{
literal|0xb
block|,
literal|"Aborted Command"
block|}
block|,
block|{
literal|0xc
block|,
literal|"Equal"
block|}
block|,
block|{
literal|0xd
block|,
literal|"Volume overflow"
block|}
block|,
block|{
literal|0xe
block|,
literal|"Miscompare"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, 	}
decl_stmt|;
specifier|static
name|scsi_assoc_t
name|code_tab
index|[]
init|=
block|{
block|{
literal|0x70
block|,
literal|"current errors"
block|}
block|,
block|{
literal|0x71
block|,
literal|"deferred errors"
block|}
block|, 	}
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Error code is \"%s\"\n"
argument_list|,
name|scsi_assoc_text
argument_list|(
name|s
index|[
literal|0
index|]
operator|&
literal|0x7F
argument_list|,
name|code_tab
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Segment number is %02x\n"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x20
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Incorrect Length Indicator is set.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Sense key is \"%s\"\n"
argument_list|,
name|scsi_assoc_text
argument_list|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x7
argument_list|,
name|sense
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|g_u_long
argument_list|(
name|s
operator|+
literal|3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The Information field is%s %08lx (%ld).\n"
argument_list|,
name|valid
condition|?
literal|""
else|:
literal|" not valid but contains"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|g_u_long
argument_list|(
name|s
operator|+
literal|8
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The Command Specific Information field is %08lx (%ld).\n"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Additional sense code: %02x\n"
argument_list|,
name|s
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Additional sense code qualifier: %02x\n"
argument_list|,
name|s
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|s
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
operator||
name|s
index|[
literal|13
index|]
expr_stmt|;
if|if
condition|(
name|error_table
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|scsi_assoc_text
argument_list|(
name|code
argument_list|,
name|error_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|15
index|]
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|0x7
operator|)
operator|==
literal|0x05
condition|)
comment|/* Illegal request */
block|{
name|int
name|byte
decl_stmt|;
name|u_char
name|value
decl_stmt|,
name|bit
decl_stmt|;
name|int
name|bad_par
init|=
operator|(
operator|(
name|s
index|[
literal|15
index|]
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Illegal value in the %s.\n"
argument_list|,
operator|(
name|bad_par
condition|?
literal|"parameter list"
else|:
literal|"command descriptor block"
operator|)
argument_list|)
expr_stmt|;
name|byte
operator|=
operator|(
operator|(
name|s
index|[
literal|16
index|]
operator|<<
literal|8
operator|)
operator||
name|s
index|[
literal|17
index|]
operator|)
expr_stmt|;
name|value
operator|=
name|bad_par
condition|?
operator|(
name|u_char
operator|)
name|scsireq
operator|->
name|databuf
index|[
name|byte
index|]
else|:
operator|(
name|u_char
operator|)
name|scsireq
operator|->
name|cmd
index|[
name|byte
index|]
expr_stmt|;
name|bit
operator|=
name|s
index|[
literal|15
index|]
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|15
index|]
operator|&
literal|0x08
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Bit %d of byte %d (value %02x) is illegal.\n"
argument_list|,
name|bit
argument_list|,
name|byte
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Byte %d (value %02x) is illegal.\n"
argument_list|,
name|byte
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Sense Key Specific (valid but not illegal request):\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%02x %02x %02x\n"
argument_list|,
name|s
index|[
literal|15
index|]
operator|&
literal|0x7f
argument_list|,
name|s
index|[
literal|16
index|]
argument_list|,
name|s
index|[
literal|17
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* scsi_sense_dump: Dump the sense portion of the scsireq structure.  */
end_comment

begin_function
name|void
name|scsi_sense_dump
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|scsireq_t
modifier|*
name|scsireq
parameter_list|)
block|{
name|u_char
modifier|*
name|s
init|=
operator|(
name|u_char
operator|*
operator|)
name|scsireq
operator|->
name|sense
decl_stmt|;
name|int
name|code
init|=
operator|(
operator|*
name|s
operator|)
operator|&
literal|0x7f
decl_stmt|;
if|if
condition|(
name|scsireq
operator|->
name|senselen_used
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"No sense sent.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|if (!valid) 		fprintf(f, "The sense data is not valid.\n");
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0x70
case|:
case|case
literal|0x71
case|:
name|sense_7x_dump
argument_list|(
name|f
argument_list|,
name|scsireq
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"No sense dump for error code %02x.\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|scsi_dump
argument_list|(
name|f
argument_list|,
literal|"sense"
argument_list|,
name|s
argument_list|,
name|scsireq
operator|->
name|senselen
argument_list|,
name|scsireq
operator|->
name|senselen_used
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scsi_retsts_dump
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|scsireq_t
modifier|*
name|scsireq
parameter_list|)
block|{
if|if
condition|(
name|scsireq
operator|->
name|retsts
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"return status %d (%s)"
argument_list|,
name|scsireq
operator|->
name|retsts
argument_list|,
name|scsi_assoc_text
argument_list|(
name|scsireq
operator|->
name|retsts
argument_list|,
name|retsts
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scsireq
operator|->
name|retsts
condition|)
block|{
case|case
name|SCCMD_TIMEOUT
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" after %ld ms"
argument_list|,
name|scsireq
operator|->
name|timeout
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|scsi_debug
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|ret
parameter_list|,
name|scsireq_t
modifier|*
name|scsireq
parameter_list|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"SCIOCCOMMAND ioctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|": Command accepted."
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", return value %d?"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|": %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|(
name|scsireq
operator|->
name|status
operator|||
name|scsireq
operator|->
name|retsts
operator|||
name|behave
operator|.
name|db_level
operator|)
condition|)
block|{
name|scsi_retsts_dump
argument_list|(
name|f
argument_list|,
name|scsireq
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsireq
operator|->
name|status
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" host adapter status %d\n"
argument_list|,
name|scsireq
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsireq
operator|->
name|flags
operator|&
name|SCCMD_READ
condition|)
name|d
operator|=
literal|"Data in"
expr_stmt|;
elseif|else
if|if
condition|(
name|scsireq
operator|->
name|flags
operator|&
name|SCCMD_WRITE
condition|)
name|d
operator|=
literal|"Data out"
expr_stmt|;
else|else
name|d
operator|=
literal|"No data transfer?"
expr_stmt|;
if|if
condition|(
name|scsireq
operator|->
name|cmdlen
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Zero length command????\n"
argument_list|)
expr_stmt|;
name|scsi_dump
argument_list|(
name|f
argument_list|,
literal|"Command out"
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|scsireq
operator|->
name|cmd
argument_list|,
name|scsireq
operator|->
name|cmdlen
argument_list|,
name|scsireq
operator|->
name|cmdlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scsi_dump
argument_list|(
name|f
argument_list|,
name|d
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|scsireq
operator|->
name|databuf
argument_list|,
name|scsireq
operator|->
name|datalen
argument_list|,
name|scsireq
operator|->
name|datalen_used
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_sense_dump
argument_list|(
name|f
argument_list|,
name|scsireq
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debug_output
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|scsi_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|debug_output
operator|=
name|getenv
argument_list|(
literal|"SU_DEBUG_OUTPUT"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|scsi_debug_output
argument_list|(
name|debug_output
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"SU_DEBUG_LEVEL"
argument_list|)
operator|)
condition|)
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|behave
operator|.
name|db_level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"SU_DEBUG_TRUNCATE"
argument_list|)
operator|)
condition|)
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|behave
operator|.
name|db_trunc
argument_list|)
expr_stmt|;
else|else
name|behave
operator|.
name|db_trunc
operator|=
name|SCSI_TRUNCATE
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_function
name|int
name|scsireq_enter
parameter_list|(
name|int
name|fid
parameter_list|,
name|scsireq_t
modifier|*
name|scsireq
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|scsireq
operator|==
literal|0
condition|)
return|return
name|EFAULT
return|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fid
argument_list|,
name|SCIOCCOMMAND
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scsireq
argument_list|)
expr_stmt|;
if|if
condition|(
name|behave
operator|.
name|db_f
condition|)
name|scsi_debug
argument_list|(
name|behave
operator|.
name|db_f
argument_list|,
name|ret
argument_list|,
name|scsireq
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

