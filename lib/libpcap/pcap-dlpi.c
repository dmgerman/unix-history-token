begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * This code contributed by Atanu Ghosh (atanu@cs.ucl.ac.uk),  * University College London.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$FreeBSD$ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Packet capture routine for dlpi under SunOS 5  *  * Notes:  *  *    - Apparently the DLIOCRAW ioctl() is specific to SunOS.  *  *    - There is a bug in bufmod(7) such that setting the snapshot  *      length results in data being left of the front of the packet.  *  *    - It might be desirable to use pfmod(7) to filter packets in the  *      kernel.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bufmod.h>
end_include

begin_include
include|#
directive|include
file|<sys/dlpi.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pcap-int.h"
end_include

begin_define
define|#
directive|define
name|MAXDLBUF
value|8192
end_define

begin_comment
comment|/* Forwards */
end_comment

begin_function_decl
specifier|static
name|int
name|send_request
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlattachreq
parameter_list|(
name|int
parameter_list|,
name|u_long
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlinfoack
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlinforeq
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlpromisconreq
parameter_list|(
name|int
parameter_list|,
name|u_long
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dlokack
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strioctl
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|getrelease
parameter_list|(
name|long
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|pcap_stats
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|pcap_stat
modifier|*
name|ps
parameter_list|)
block|{
operator|*
name|ps
operator|=
name|p
operator|->
name|md
operator|.
name|stat
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_read
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|,
name|pcap_handler
name|callback
parameter_list|,
name|u_char
modifier|*
name|user
parameter_list|)
block|{
specifier|register
name|int
name|cc
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|pk
decl_stmt|;
specifier|register
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|;
specifier|register
name|struct
name|sb_hdr
modifier|*
name|sbp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|strbuf
name|data
decl_stmt|;
name|struct
name|pcap_pkthdr
name|pkthdr
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|cc
operator|=
name|p
operator|->
name|cc
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|data
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|buffer
expr_stmt|;
name|data
operator|.
name|maxlen
operator|=
name|MAXDLBUF
expr_stmt|;
name|data
operator|.
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|getmsg
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|NULL
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Don't choke when we get ptraced */
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|cc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|p
operator|->
name|errbuf
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cc
operator|=
name|data
operator|.
name|len
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|==
literal|0
condition|)
do|;
name|bp
operator|=
name|p
operator|->
name|buffer
expr_stmt|;
block|}
else|else
name|bp
operator|=
name|p
operator|->
name|bp
expr_stmt|;
comment|/* Loop through packets */
name|fcode
operator|=
name|p
operator|->
name|fcode
operator|.
name|bf_insns
expr_stmt|;
name|ep
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
name|sbp
operator|=
operator|(
expr|struct
name|sb_hdr
operator|*
operator|)
name|bp
expr_stmt|;
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_drop
operator|+=
name|sbp
operator|->
name|sbh_drops
expr_stmt|;
operator|++
name|p
operator|->
name|md
operator|.
name|stat
operator|.
name|ps_recv
expr_stmt|;
name|pk
operator|=
name|bp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sbp
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sbp
operator|->
name|sbh_totlen
expr_stmt|;
if|if
condition|(
name|bpf_filter
argument_list|(
name|fcode
argument_list|,
name|pk
argument_list|,
name|sbp
operator|->
name|sbh_origlen
argument_list|,
name|sbp
operator|->
name|sbh_msglen
argument_list|)
condition|)
block|{
name|pkthdr
operator|.
name|ts
operator|=
name|sbp
operator|->
name|sbh_timestamp
expr_stmt|;
name|pkthdr
operator|.
name|len
operator|=
name|sbp
operator|->
name|sbh_origlen
expr_stmt|;
name|pkthdr
operator|.
name|caplen
operator|=
name|sbp
operator|->
name|sbh_msglen
expr_stmt|;
call|(
modifier|*
name|callback
call|)
argument_list|(
name|user
argument_list|,
operator|&
name|pkthdr
argument_list|,
name|pk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|>=
name|cnt
operator|&&
name|cnt
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|cc
operator|=
name|ep
operator|-
name|bp
expr_stmt|;
name|p
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
block|}
name|p
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|pcap_t
modifier|*
name|pcap_open_live
parameter_list|(
name|char
modifier|*
name|device
parameter_list|,
name|int
name|snaplen
parameter_list|,
name|int
name|promisc
parameter_list|,
name|int
name|to_ms
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
specifier|register
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|long
name|buf
index|[
name|MAXDLBUF
index|]
decl_stmt|;
name|int
name|ppa
decl_stmt|;
name|int
name|cppa
decl_stmt|;
specifier|register
name|dl_info_ack_t
modifier|*
name|infop
decl_stmt|;
name|u_long
name|ss
decl_stmt|,
name|flag
decl_stmt|;
ifdef|#
directive|ifdef
name|SOLARIS
name|char
modifier|*
name|release
decl_stmt|;
name|long
name|osmajor
decl_stmt|,
name|osminor
decl_stmt|,
name|osmicro
decl_stmt|;
endif|#
directive|endif
name|char
name|dname
index|[
literal|100
index|]
decl_stmt|;
name|p
operator|=
operator|(
name|pcap_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|ebuf
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	** 1) In order to get the ppa take the last character of the device 	** name if it is a number then fail the open. 	** 	** 2) If the name starts with a '/' then this is an absolute pathname, 	** otherwise prepend '/dev/'. 	** 	** 3) Remove the trailing digit and try and open the device 	** not staggeringly intuitive but it should work. 	** 	** If there are more than 9 devices this code will fail. 	*/
name|cppa
operator|=
name|device
index|[
name|strlen
argument_list|(
name|device
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|cppa
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"%c is not a digit, therefore not a valid ppa"
argument_list|,
name|cppa
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|device
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|strcpy
argument_list|(
name|dname
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dname
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|dname
index|[
name|strlen
argument_list|(
name|dname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|fd
operator|=
name|open
argument_list|(
name|dname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"%s: %s"
argument_list|,
name|dname
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|p
operator|->
name|snapshot
operator|=
name|snaplen
expr_stmt|;
name|ppa
operator|=
name|cppa
operator|-
literal|'0'
expr_stmt|;
comment|/* 	** Attach. 	*/
if|if
condition|(
name|dlattachreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|ppa
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|promisc
condition|)
block|{
comment|/* 		** enable promiscuous. 		*/
if|if
condition|(
name|dlpromisconreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DL_PROMISC_PHYS
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|dlpromisconreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DL_PROMISC_SAP
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 		** enable multicast, you would have thought promiscuous 		** would be sufficient. 		*/
if|if
condition|(
name|dlpromisconreq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DL_PROMISC_MULTI
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlokack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* 	** Determine link type 	*/
if|if
condition|(
name|dlinforeq
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
operator|||
name|dlinfoack
argument_list|(
name|p
operator|->
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|ebuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|infop
operator|=
operator|&
operator|(
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|buf
operator|)
operator|->
name|info_ack
expr_stmt|;
switch|switch
condition|(
name|infop
operator|->
name|dl_mac_type
condition|)
block|{
case|case
name|DL_ETHER
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_EN10MB
expr_stmt|;
break|break;
case|case
name|DL_FDDI
case|:
name|p
operator|->
name|linktype
operator|=
name|DLT_FDDI
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"unknown mac type 0x%lu"
argument_list|,
name|infop
operator|->
name|dl_mac_type
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|DLIOCRAW
comment|/* 	** This is a non standard SunOS hack to get the ethernet header. 	*/
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|DLIOCRAW
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"DLIOCRAW: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* 	** Another non standard call to get the data nicely buffered 	*/
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|I_PUSH
argument_list|,
literal|"bufmod"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"I_PUSH bufmod: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	** Now that the bufmod is pushed lets configure it. 	** 	** There is a bug in bufmod(7). When dealing with messages of 	** less than snaplen size it strips data from the beginning not 	** the end. 	** 	** This bug is supposed to be fixed in 5.3.2. Also, there is a 	** patch available. Ask for bugid 1149065. 	*/
name|ss
operator|=
name|snaplen
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLARIS
name|release
operator|=
name|getrelease
argument_list|(
operator|&
name|osmajor
argument_list|,
operator|&
name|osminor
argument_list|,
operator|&
name|osmicro
argument_list|)
expr_stmt|;
if|if
condition|(
name|osmajor
operator|==
literal|5
operator|&&
operator|(
name|osminor
operator|<=
literal|2
operator|||
operator|(
name|osminor
operator|==
literal|3
operator|&&
name|osmicro
operator|<
literal|2
operator|)
operator|)
operator|&&
name|getenv
argument_list|(
literal|"BUFMOD_FIXED"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: bufmod is broken in SunOS %s; ignoring snaplen.\n"
argument_list|,
name|release
argument_list|)
expr_stmt|;
name|ss
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ss
operator|>
literal|0
operator|&&
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCSSNAP
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ss
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"SBIOCSSNAP: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	** Set up the bufmod flags 	*/
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCGFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"SBIOCGFLAGS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|flag
operator||=
name|SB_NO_DROPS
expr_stmt|;
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCSFLAGS
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|flag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"SBIOCSFLAGS: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	** Set up the bufmod timeout 	*/
if|if
condition|(
name|to_ms
operator|!=
literal|0
condition|)
block|{
name|struct
name|timeval
name|to
decl_stmt|;
name|to
operator|.
name|tv_sec
operator|=
name|to_ms
operator|/
literal|1000
expr_stmt|;
name|to
operator|.
name|tv_usec
operator|=
operator|(
name|to_ms
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
if|if
condition|(
name|strioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|SBIOCSTIME
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"SBIOCSTIME: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	** As the last operation flush the read side. 	*/
if|if
condition|(
name|ioctl
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|I_FLUSH
argument_list|,
name|FLUSHR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"FLUSHR: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Allocate data buffer */
name|p
operator|->
name|bufsize
operator|=
name|MAXDLBUF
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|p
operator|->
name|buffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|p
operator|->
name|bufsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcap_setfilter
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|)
block|{
name|p
operator|->
name|fcode
operator|=
operator|*
name|fp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_request
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|ptr
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|putmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"putmsg \"%s\"failed: %s"
argument_list|,
name|what
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlattachreq
parameter_list|(
name|int
name|fd
parameter_list|,
name|u_long
name|ppa
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_attach_req_t
name|req
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_ATTACH_REQ
expr_stmt|;
name|req
operator|.
name|dl_ppa
operator|=
name|ppa
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"attach"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlpromisconreq
parameter_list|(
name|int
name|fd
parameter_list|,
name|u_long
name|level
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_promiscon_req_t
name|req
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_PROMISCON_REQ
expr_stmt|;
name|req
operator|.
name|dl_level
operator|=
name|level
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"promiscon"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlokack
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"getmsg: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|!=
name|DL_OK_ACK
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"dlokack unexpected primitive %d"
argument_list|,
name|dlp
operator|->
name|dl_primitive
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ctl
operator|.
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|dl_ok_ack_t
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"dlokack incorrect size returned"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlinforeq
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|dl_info_req_t
name|req
decl_stmt|;
name|req
operator|.
name|dl_primitive
operator|=
name|DL_INFO_REQ
expr_stmt|;
return|return
operator|(
name|send_request
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
literal|"info"
argument_list|,
name|ebuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dlinfoack
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|char
modifier|*
name|ebuf
parameter_list|)
block|{
name|union
name|DL_primitives
modifier|*
name|dlp
decl_stmt|;
name|struct
name|strbuf
name|ctl
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ctl
operator|.
name|maxlen
operator|=
name|MAXDLBUF
expr_stmt|;
name|ctl
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|ctl
operator|.
name|buf
operator|=
name|bufp
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getmsg
argument_list|(
name|fd
argument_list|,
operator|&
name|ctl
argument_list|,
operator|(
expr|struct
name|strbuf
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"dlinfoack: getmsg: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dlp
operator|=
operator|(
expr|union
name|DL_primitives
operator|*
operator|)
name|ctl
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|dlp
operator|->
name|dl_primitive
operator|!=
name|DL_INFO_ACK
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"dlinfoack: unexpected primitive %ld"
argument_list|,
name|dlp
operator|->
name|dl_primitive
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Extra stuff like the broadcast address can be returned */
if|if
condition|(
name|ctl
operator|.
name|len
operator|<
name|DL_INFO_ACK_SIZE
condition|)
block|{
name|sprintf
argument_list|(
name|ebuf
argument_list|,
literal|"dlinfoack: incorrect size returned"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strioctl
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|strioctl
name|str
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|str
operator|.
name|ic_cmd
operator|=
name|cmd
expr_stmt|;
name|str
operator|.
name|ic_timout
operator|=
operator|-
literal|1
expr_stmt|;
name|str
operator|.
name|ic_len
operator|=
name|len
expr_stmt|;
name|str
operator|.
name|ic_dp
operator|=
name|dp
expr_stmt|;
name|rc
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|I_STR
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
else|else
return|return
operator|(
name|str
operator|.
name|ic_len
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|getrelease
parameter_list|(
name|long
modifier|*
name|majorp
parameter_list|,
name|long
modifier|*
name|minorp
parameter_list|,
name|long
modifier|*
name|microp
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
operator|*
name|majorp
operator|=
literal|0
expr_stmt|;
operator|*
name|minorp
operator|=
literal|0
expr_stmt|;
operator|*
name|microp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysinfo
argument_list|(
name|SI_RELEASE
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|"?"
operator|)
return|;
name|cp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|majorp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|minorp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|buf
operator|)
return|;
operator|*
name|microp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

