begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*   SPDX-License-Identifier: BSD-3-Clause    auth_gss.c    RPCSEC_GSS client routines.      Copyright (c) 2000 The Regents of the University of Michigan.   All rights reserved.    Copyright (c) 2000 Dug Song<dugsong@UMICH.EDU>.   All rights reserved, all wrongs reversed.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright      notice, this list of conditions and the following disclaimer in the      documentation and/or other materials provided with the distribution.   3. Neither the name of the University nor the names of its      contributors may be used to endorse or promote products derived      from this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    $Id: auth_gss.c,v 1.32 2002/01/15 15:43:00 andros Exp $ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcsec_gss.h>
end_include

begin_include
include|#
directive|include
file|"rpcsec_gss_int.h"
end_include

begin_function_decl
specifier|static
name|void
name|rpc_gss_nextverf
parameter_list|(
name|AUTH
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_marshal
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|XDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_init
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
name|options_ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_refresh
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_validate
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|struct
name|opaque_auth
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpc_gss_destroy
parameter_list|(
name|AUTH
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpc_gss_destroy_context
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|bool_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|auth_ops
name|rpc_gss_ops
init|=
block|{
name|rpc_gss_nextverf
block|,
name|rpc_gss_marshal
block|,
name|rpc_gss_validate
block|,
name|rpc_gss_refresh
block|,
name|rpc_gss_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|rpcsec_gss_state
block|{
name|RPCSEC_GSS_START
block|,
name|RPCSEC_GSS_CONTEXT
block|,
name|RPCSEC_GSS_ESTABLISHED
block|}
enum|;
end_enum

begin_struct
struct|struct
name|rpc_gss_data
block|{
name|rpc_gss_options_req_t
name|gd_options
decl_stmt|;
comment|/* GSS context options */
name|enum
name|rpcsec_gss_state
name|gd_state
decl_stmt|;
comment|/* connection state */
name|gss_buffer_desc
name|gd_verf
decl_stmt|;
comment|/* save GSS_S_COMPLETE 						 * NULL RPC verfier to 						 * process at end of 						 * context negotiation */
name|CLIENT
modifier|*
name|gd_clnt
decl_stmt|;
comment|/* client handle */
name|gss_name_t
name|gd_name
decl_stmt|;
comment|/* service name */
name|gss_OID
name|gd_mech
decl_stmt|;
comment|/* mechanism to use */
name|gss_qop_t
name|gd_qop
decl_stmt|;
comment|/* quality of protection */
name|gss_ctx_id_t
name|gd_ctx
decl_stmt|;
comment|/* context id */
name|struct
name|rpc_gss_cred
name|gd_cred
decl_stmt|;
comment|/* client credentials */
name|u_int
name|gd_win
decl_stmt|;
comment|/* sequence window */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AUTH_PRIVATE
parameter_list|(
name|auth
parameter_list|)
value|((struct rpc_gss_data *)auth->ah_private)
end_define

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|AUTH_TIMEOUT
init|=
block|{
literal|25
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|AUTH
modifier|*
name|rpc_gss_seccreate
parameter_list|(
name|CLIENT
modifier|*
name|clnt
parameter_list|,
specifier|const
name|char
modifier|*
name|principal
parameter_list|,
specifier|const
name|char
modifier|*
name|mechanism
parameter_list|,
name|rpc_gss_service_t
name|service
parameter_list|,
specifier|const
name|char
modifier|*
name|qop
parameter_list|,
name|rpc_gss_options_req_t
modifier|*
name|options_req
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
name|options_ret
parameter_list|)
block|{
name|AUTH
modifier|*
name|auth
decl_stmt|,
modifier|*
name|save_auth
decl_stmt|;
name|rpc_gss_options_ret_t
name|options
decl_stmt|;
name|gss_OID
name|oid
decl_stmt|;
name|u_int
name|qop_num
decl_stmt|;
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|OM_uint32
name|maj_stat
init|=
literal|0
decl_stmt|,
name|min_stat
init|=
literal|0
decl_stmt|;
name|gss_buffer_desc
name|principal_desc
decl_stmt|;
comment|/* 	 * Bail out now if we don't know this mechanism. 	 */
if|if
condition|(
operator|!
name|rpc_gss_mech_to_oid
argument_list|(
name|mechanism
argument_list|,
operator|&
name|oid
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|qop
condition|)
block|{
if|if
condition|(
operator|!
name|rpc_gss_qop_to_num
argument_list|(
name|qop
argument_list|,
name|mechanism
argument_list|,
operator|&
name|qop_num
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|qop_num
operator|=
name|GSS_C_QOP_DEFAULT
expr_stmt|;
block|}
comment|/* 	 * If the caller doesn't want the options, point at local 	 * storage to simplify the code below. 	 */
if|if
condition|(
operator|!
name|options_ret
condition|)
name|options_ret
operator|=
operator|&
name|options
expr_stmt|;
comment|/* 	 * Default service is integrity. 	 */
if|if
condition|(
name|service
operator|==
name|rpc_gss_svc_default
condition|)
name|service
operator|=
name|rpc_gss_svc_integrity
expr_stmt|;
name|memset
argument_list|(
name|options_ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|options_ret
argument_list|)
argument_list|)
expr_stmt|;
name|log_debug
argument_list|(
literal|"in rpc_gss_seccreate()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rpc_createerr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rpc_createerr
argument_list|)
argument_list|)
expr_stmt|;
name|auth
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_error
operator|.
name|re_errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gd
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|==
name|NULL
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_error
operator|.
name|re_errno
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|auth
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|auth
operator|->
name|ah_ops
operator|=
operator|&
name|rpc_gss_ops
expr_stmt|;
name|auth
operator|->
name|ah_private
operator|=
operator|(
name|caddr_t
operator|)
name|gd
expr_stmt|;
name|auth
operator|->
name|ah_cred
operator|.
name|oa_flavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
name|principal_desc
operator|.
name|value
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|principal
expr_stmt|;
name|principal_desc
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|principal
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_import_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|principal_desc
argument_list|,
name|GSS_C_NT_HOSTBASED_SERVICE
argument_list|,
operator|&
name|gd
operator|->
name|gd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|options_req
condition|)
block|{
name|gd
operator|->
name|gd_options
operator|=
operator|*
name|options_req
expr_stmt|;
block|}
else|else
block|{
name|gd
operator|->
name|gd_options
operator|.
name|req_flags
operator|=
name|GSS_C_MUTUAL_FLAG
expr_stmt|;
name|gd
operator|->
name|gd_options
operator|.
name|time_req
operator|=
literal|0
expr_stmt|;
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
operator|=
name|GSS_C_NO_CREDENTIAL
expr_stmt|;
name|gd
operator|->
name|gd_options
operator|.
name|input_channel_bindings
operator|=
name|NULL
expr_stmt|;
block|}
name|gd
operator|->
name|gd_clnt
operator|=
name|clnt
expr_stmt|;
name|gd
operator|->
name|gd_ctx
operator|=
name|GSS_C_NO_CONTEXT
expr_stmt|;
name|gd
operator|->
name|gd_mech
operator|=
name|oid
expr_stmt|;
name|gd
operator|->
name|gd_qop
operator|=
name|qop_num
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_version
operator|=
name|RPCSEC_GSS_VERSION
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_INIT
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
operator|=
literal|0
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|=
name|service
expr_stmt|;
name|save_auth
operator|=
name|clnt
operator|->
name|cl_auth
expr_stmt|;
name|clnt
operator|->
name|cl_auth
operator|=
name|auth
expr_stmt|;
if|if
condition|(
operator|!
name|rpc_gss_init
argument_list|(
name|auth
argument_list|,
name|options_ret
argument_list|)
condition|)
block|{
name|clnt
operator|->
name|cl_auth
operator|=
name|save_auth
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|clnt
operator|->
name|cl_auth
operator|=
name|save_auth
expr_stmt|;
return|return
operator|(
name|auth
operator|)
return|;
name|bad
label|:
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|rpc_gss_set_defaults
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|rpc_gss_service_t
name|service
parameter_list|,
specifier|const
name|char
modifier|*
name|qop
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|u_int
name|qop_num
decl_stmt|;
specifier|const
name|char
modifier|*
name|mechanism
decl_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rpc_gss_oid_to_mech
argument_list|(
name|gd
operator|->
name|gd_mech
argument_list|,
operator|&
name|mechanism
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|qop
condition|)
block|{
if|if
condition|(
operator|!
name|rpc_gss_qop_to_num
argument_list|(
name|qop
argument_list|,
name|mechanism
argument_list|,
operator|&
name|qop_num
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
name|qop_num
operator|=
name|GSS_C_QOP_DEFAULT
expr_stmt|;
block|}
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|=
name|service
expr_stmt|;
name|gd
operator|->
name|gd_qop
operator|=
name|qop_num
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpc_gss_nextverf
parameter_list|(
name|__unused
name|AUTH
modifier|*
name|auth
parameter_list|)
block|{
comment|/* not used */
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_marshal
parameter_list|(
name|__unused
name|AUTH
modifier|*
name|auth
parameter_list|,
name|__unused
name|XDR
modifier|*
name|xdrs
parameter_list|)
block|{
comment|/* not used */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_validate
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|struct
name|opaque_auth
modifier|*
name|verf
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|gss_qop_t
name|qop_state
decl_stmt|;
name|uint32_t
name|num
decl_stmt|;
name|gss_buffer_desc
name|signbuf
decl_stmt|,
name|checksum
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|log_debug
argument_list|(
literal|"in rpc_gss_validate()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|==
name|RPCSEC_GSS_CONTEXT
condition|)
block|{
comment|/* 		 * Save the on the wire verifier to validate last INIT 		 * phase packet after decode if the major status is 		 * GSS_S_COMPLETE. 		 */
if|if
condition|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
condition|)
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_verf
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_verf
operator|.
name|value
operator|=
name|mem_alloc
argument_list|(
name|verf
operator|->
name|oa_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gss_validate: out of memory\n"
argument_list|)
expr_stmt|;
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
argument_list|,
name|verf
operator|->
name|oa_base
argument_list|,
name|verf
operator|->
name|oa_length
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_verf
operator|.
name|length
operator|=
name|verf
operator|->
name|oa_length
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|num
operator|=
name|htonl
argument_list|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
argument_list|)
expr_stmt|;
name|signbuf
operator|.
name|value
operator|=
operator|&
name|num
expr_stmt|;
name|signbuf
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|checksum
operator|.
name|value
operator|=
name|verf
operator|->
name|oa_base
expr_stmt|;
name|checksum
operator|.
name|length
operator|=
name|verf
operator|->
name|oa_length
expr_stmt|;
name|maj_stat
operator|=
name|gss_verify_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
operator|&
name|signbuf
argument_list|,
operator|&
name|checksum
argument_list|,
operator|&
name|qop_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
operator|||
name|qop_state
operator|!=
name|gd
operator|->
name|gd_qop
condition|)
block|{
name|log_status
argument_list|(
literal|"gss_verify_mic"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_CONTEXT_EXPIRED
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_init
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
name|options_ret
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|struct
name|rpc_gss_init_res
name|gr
decl_stmt|;
name|gss_buffer_desc
modifier|*
name|recv_tokenp
decl_stmt|,
name|recv_token
decl_stmt|,
name|send_token
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|,
name|call_stat
decl_stmt|;
specifier|const
name|char
modifier|*
name|mech
decl_stmt|;
name|log_debug
argument_list|(
literal|"in rpc_gss_refresh()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_START
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* GSS context establishment loop. */
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_CONTEXT
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_INIT
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|recv_token
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|recv_token
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gr
argument_list|)
argument_list|)
expr_stmt|;
name|recv_tokenp
operator|=
name|GSS_C_NO_BUFFER
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|maj_stat
operator|=
name|gss_init_sec_context
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
argument_list|,
operator|&
name|gd
operator|->
name|gd_ctx
argument_list|,
name|gd
operator|->
name|gd_name
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|req_flags
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|time_req
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|input_channel_bindings
argument_list|,
name|recv_tokenp
argument_list|,
operator|&
name|gd
operator|->
name|gd_mech
argument_list|,
comment|/* used mech */
operator|&
name|send_token
argument_list|,
operator|&
name|options_ret
operator|->
name|ret_flags
argument_list|,
operator|&
name|options_ret
operator|->
name|time_req
argument_list|)
expr_stmt|;
comment|/* 		 * Free the token which we got from the server (if 		 * any).  Remember that this was allocated by XDR, not 		 * GSS-API. 		 */
if|if
condition|(
name|recv_tokenp
operator|!=
name|GSS_C_NO_BUFFER
condition|)
block|{
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|recv_token
argument_list|)
expr_stmt|;
name|recv_tokenp
operator|=
name|GSS_C_NO_BUFFER
expr_stmt|;
block|}
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
operator|&&
name|maj_stat
operator|!=
name|GSS_S_CONTINUE_NEEDED
condition|)
block|{
name|log_status
argument_list|(
literal|"gss_init_sec_context"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|send_token
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|gr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gr
argument_list|)
argument_list|)
expr_stmt|;
name|call_stat
operator|=
name|clnt_call
argument_list|(
name|gd
operator|->
name|gd_clnt
argument_list|,
name|NULLPROC
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|&
name|send_token
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_rpc_gss_init_res
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gr
argument_list|,
name|AUTH_TIMEOUT
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|send_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_stat
operator|!=
name|RPC_SUCCESS
condition|)
break|break;
if|if
condition|(
name|gr
operator|.
name|gr_major
operator|!=
name|GSS_S_COMPLETE
operator|&&
name|gr
operator|.
name|gr_major
operator|!=
name|GSS_S_CONTINUE_NEEDED
condition|)
block|{
name|log_status
argument_list|(
literal|"server reply"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|gr
operator|.
name|gr_major
argument_list|,
name|gr
operator|.
name|gr_minor
argument_list|)
expr_stmt|;
name|options_ret
operator|->
name|major_status
operator|=
name|gr
operator|.
name|gr_major
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|gr
operator|.
name|gr_minor
expr_stmt|;
break|break;
block|}
comment|/* 			 * Save the server's gr_handle value, freeing 			 * what we have already (remember that this 			 * was allocated by XDR, not GSS-API). 			 */
if|if
condition|(
name|gr
operator|.
name|gr_handle
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
operator|=
name|gr
operator|.
name|gr_handle
expr_stmt|;
block|}
comment|/* 			 * Save the server's token as well. 			 */
if|if
condition|(
name|gr
operator|.
name|gr_token
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|recv_token
operator|=
name|gr
operator|.
name|gr_token
expr_stmt|;
name|recv_tokenp
operator|=
operator|&
name|recv_token
expr_stmt|;
block|}
comment|/* 			 * Since we have copied out all the bits of gr 			 * which XDR allocated for us, we don't need 			 * to free it. 			 */
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_CONTINUE_INIT
expr_stmt|;
block|}
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_buffer_desc
name|bufin
decl_stmt|;
name|u_int
name|seq
decl_stmt|,
name|qop_state
init|=
literal|0
decl_stmt|;
comment|/*  			 * gss header verifier, 			 * usually checked in gss_validate 			 */
name|seq
operator|=
name|htonl
argument_list|(
name|gr
operator|.
name|gr_win
argument_list|)
expr_stmt|;
name|bufin
operator|.
name|value
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|seq
expr_stmt|;
name|bufin
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_verify_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
operator|&
name|bufin
argument_list|,
operator|&
name|gd
operator|->
name|gd_verf
argument_list|,
operator|&
name|qop_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
operator|||
name|qop_state
operator|!=
name|gd
operator|->
name|gd_qop
condition|)
block|{
name|log_status
argument_list|(
literal|"gss_verify_mic"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_CONTEXT_EXPIRED
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|options_ret
operator|->
name|major_status
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
literal|0
expr_stmt|;
name|options_ret
operator|->
name|rpcsec_version
operator|=
name|gd
operator|->
name|gd_cred
operator|.
name|gc_version
expr_stmt|;
name|options_ret
operator|->
name|gss_context
operator|=
name|gd
operator|->
name|gd_ctx
expr_stmt|;
if|if
condition|(
name|rpc_gss_oid_to_mech
argument_list|(
name|gd
operator|->
name|gd_mech
argument_list|,
operator|&
name|mech
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|options_ret
operator|->
name|actual_mechanism
argument_list|,
name|mech
argument_list|,
sizeof|sizeof
argument_list|(
name|options_ret
operator|->
name|actual_mechanism
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_ESTABLISHED
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_DATA
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
operator|=
literal|0
expr_stmt|;
name|gd
operator|->
name|gd_win
operator|=
name|gr
operator|.
name|gr_win
expr_stmt|;
break|break;
block|}
block|}
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_verf
argument_list|)
expr_stmt|;
comment|/* End context negotiation loop. */
if|if
condition|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|!=
name|RPCSEC_GSS_DATA
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_AUTHERROR
expr_stmt|;
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_refresh
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|rpc_msg
modifier|*
name|reply
init|=
operator|(
expr|struct
name|rpc_msg
operator|*
operator|)
name|msg
decl_stmt|;
name|rpc_gss_options_ret_t
name|options
decl_stmt|;
comment|/* 	 * If the error was RPCSEC_GSS_CREDPROBLEM of 	 * RPCSEC_GSS_CTXPROBLEM we start again from scratch. All 	 * other errors are fatal. 	 */
if|if
condition|(
name|reply
operator|->
name|rm_reply
operator|.
name|rp_stat
operator|==
name|MSG_DENIED
operator|&&
name|reply
operator|->
name|rm_reply
operator|.
name|rp_rjct
operator|.
name|rj_stat
operator|==
name|AUTH_ERROR
operator|&&
operator|(
name|reply
operator|->
name|rm_reply
operator|.
name|rp_rjct
operator|.
name|rj_why
operator|==
name|RPCSEC_GSS_CREDPROBLEM
operator|||
name|reply
operator|->
name|rm_reply
operator|.
name|rp_rjct
operator|.
name|rj_why
operator|==
name|RPCSEC_GSS_CTXPROBLEM
operator|)
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rpc_gss_init
argument_list|(
name|auth
argument_list|,
operator|&
name|options
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpc_gss_destroy_context
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|bool_t
name|send_destroy
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|OM_uint32
name|min_stat
decl_stmt|;
name|log_debug
argument_list|(
literal|"in rpc_gss_destroy_context()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|==
name|RPCSEC_GSS_ESTABLISHED
operator|&&
name|send_destroy
condition|)
block|{
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_DESTROY
expr_stmt|;
name|clnt_call
argument_list|(
name|gd
operator|->
name|gd_clnt
argument_list|,
name|NULLPROC
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
name|NULL
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
name|NULL
argument_list|,
name|AUTH_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the context token. Remember that this was 	 * allocated by XDR, not GSS-API. 	 */
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
operator|.
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_ctx
operator|!=
name|GSS_C_NO_CONTEXT
condition|)
name|gss_delete_sec_context
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gd
operator|->
name|gd_ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_START
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpc_gss_destroy
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|OM_uint32
name|min_stat
decl_stmt|;
name|log_debug
argument_list|(
literal|"in rpc_gss_destroy()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_name
operator|!=
name|GSS_C_NO_NAME
condition|)
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gd
operator|->
name|gd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
condition|)
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_verf
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|gd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gd
argument_list|)
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|auth
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool_t
name|__rpc_gss_wrap
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|void
modifier|*
name|header
parameter_list|,
name|size_t
name|headerlen
parameter_list|,
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|xdrproc_t
name|xdr_args
parameter_list|,
name|void
modifier|*
name|args_ptr
parameter_list|)
block|{
name|XDR
name|tmpxdrs
decl_stmt|;
name|char
name|credbuf
index|[
name|MAX_AUTH_BYTES
index|]
decl_stmt|;
name|char
name|tmpheader
index|[
name|MAX_AUTH_BYTES
index|]
decl_stmt|;
name|struct
name|opaque_auth
name|creds
decl_stmt|,
name|verf
decl_stmt|;
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|gss_buffer_desc
name|rpcbuf
decl_stmt|,
name|checksum
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|bool_t
name|xdr_stat
decl_stmt|;
name|log_debug
argument_list|(
literal|"in rpc_gss_wrap()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|==
name|RPCSEC_GSS_ESTABLISHED
condition|)
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
operator|++
expr_stmt|;
comment|/* 	 * We need to encode our creds and then put the header and 	 * creds together in a buffer so that we can create a checksum 	 * for the verf. 	 */
name|xdrmem_create
argument_list|(
operator|&
name|tmpxdrs
argument_list|,
name|credbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|credbuf
argument_list|)
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_rpc_gss_cred
argument_list|(
operator|&
name|tmpxdrs
argument_list|,
operator|&
name|gd
operator|->
name|gd_cred
argument_list|)
condition|)
block|{
name|XDR_DESTROY
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|creds
operator|.
name|oa_flavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
name|creds
operator|.
name|oa_base
operator|=
name|credbuf
expr_stmt|;
name|creds
operator|.
name|oa_length
operator|=
name|XDR_GETPOS
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|XDR_DESTROY
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|xdrmem_create
argument_list|(
operator|&
name|tmpxdrs
argument_list|,
name|tmpheader
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpheader
argument_list|)
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XDR_PUTBYTES
argument_list|(
operator|&
name|tmpxdrs
argument_list|,
name|header
argument_list|,
name|headerlen
argument_list|)
operator|||
operator|!
name|xdr_opaque_auth
argument_list|(
operator|&
name|tmpxdrs
argument_list|,
operator|&
name|creds
argument_list|)
condition|)
block|{
name|XDR_DESTROY
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|headerlen
operator|=
name|XDR_GETPOS
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|XDR_DESTROY
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XDR_PUTBYTES
argument_list|(
name|xdrs
argument_list|,
name|tmpheader
argument_list|,
name|headerlen
argument_list|)
condition|)
block|{
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|==
name|RPCSEC_GSS_INIT
operator|||
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|==
name|RPCSEC_GSS_CONTINUE_INIT
condition|)
block|{
if|if
condition|(
operator|!
name|xdr_opaque_auth
argument_list|(
name|xdrs
argument_list|,
operator|&
name|_null_auth
argument_list|)
condition|)
block|{
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Checksum serialized RPC header, up to and including 		 * credential. 		 */
name|rpcbuf
operator|.
name|length
operator|=
name|headerlen
expr_stmt|;
name|rpcbuf
operator|.
name|value
operator|=
name|tmpheader
expr_stmt|;
name|maj_stat
operator|=
name|gss_get_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
operator|&
name|rpcbuf
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|log_status
argument_list|(
literal|"gss_get_mic"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_CONTEXT_EXPIRED
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|verf
operator|.
name|oa_flavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
name|verf
operator|.
name|oa_base
operator|=
name|checksum
operator|.
name|value
expr_stmt|;
name|verf
operator|.
name|oa_length
operator|=
name|checksum
operator|.
name|length
expr_stmt|;
name|xdr_stat
operator|=
name|xdr_opaque_auth
argument_list|(
name|xdrs
argument_list|,
operator|&
name|verf
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_stat
condition|)
block|{
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
operator|||
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|==
name|rpc_gss_svc_none
condition|)
block|{
return|return
operator|(
name|xdr_args
argument_list|(
name|xdrs
argument_list|,
name|args_ptr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|xdr_rpc_gss_wrap_data
argument_list|(
name|xdrs
argument_list|,
name|xdr_args
argument_list|,
name|args_ptr
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
argument_list|,
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|__rpc_gss_unwrap
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|xdrproc_t
name|xdr_func
parameter_list|,
name|void
modifier|*
name|xdr_ptr
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|log_debug
argument_list|(
literal|"in rpc_gss_unwrap()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
operator|||
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|==
name|rpc_gss_svc_none
condition|)
block|{
return|return
operator|(
name|xdr_func
argument_list|(
name|xdrs
argument_list|,
name|xdr_ptr
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|xdr_rpc_gss_unwrap_data
argument_list|(
name|xdrs
argument_list|,
name|xdr_func
argument_list|,
name|xdr_ptr
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
argument_list|,
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rpc_gss_max_data_length
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|int
name|max_tp_unit_len
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|int
name|want_conf
decl_stmt|;
name|OM_uint32
name|max
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|int
name|result
decl_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
condition|)
block|{
case|case
name|rpc_gss_svc_none
case|:
return|return
operator|(
name|max_tp_unit_len
operator|)
return|;
break|break;
case|case
name|rpc_gss_svc_default
case|:
case|case
name|rpc_gss_svc_integrity
case|:
name|want_conf
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|rpc_gss_svc_privacy
case|:
name|want_conf
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|maj_stat
operator|=
name|gss_wrap_size_limit
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|want_conf
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
name|max_tp_unit_len
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|max
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
block|{
name|log_status
argument_list|(
literal|"gss_wrap_size_limit"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

end_unit

