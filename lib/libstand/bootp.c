begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: bootp.c,v 1.14 1998/02/16 11:10:54 drochner Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * @(#) Header: bootp.c,v 1.4 93/09/11 03:13:51 leres Exp  (LBL)  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|BOOTP_DEBUGxx
end_define

begin_define
define|#
directive|define
name|SUPPORT_DHCP
end_define

begin_define
define|#
directive|define
name|DHCP_ENV_NOVENDOR
value|1
end_define

begin_comment
comment|/* do not parse vendor options */
end_comment

begin_define
define|#
directive|define
name|DHCP_ENV_PXE
value|10
end_define

begin_comment
comment|/* assume pxe vendor options */
end_comment

begin_define
define|#
directive|define
name|DHCP_ENV_FREEBSD
value|11
end_define

begin_comment
comment|/* assume freebsd vendor options */
end_comment

begin_comment
comment|/* set DHCP_ENV to one of the values above to export dhcp options to kenv */
end_comment

begin_define
define|#
directive|define
name|DHCP_ENV
value|DHCP_ENV_NO_VENDOR
end_define

begin_include
include|#
directive|include
file|"stand.h"
end_include

begin_include
include|#
directive|include
file|"net.h"
end_include

begin_include
include|#
directive|include
file|"netif.h"
end_include

begin_include
include|#
directive|include
file|"bootp.h"
end_include

begin_decl_stmt
name|struct
name|in_addr
name|servip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|bot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vm_rfc1048
index|[
literal|4
index|]
init|=
name|VM_RFC1048
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BOOTP_VEND_CMU
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|vm_cmu
index|[
literal|4
index|]
init|=
name|VM_CMU
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local forwards */
end_comment

begin_function_decl
specifier|static
name|ssize_t
name|bootpsend
parameter_list|(
name|struct
name|iodesc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|bootprecv
parameter_list|(
name|struct
name|iodesc
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vend_rfc1048
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BOOTP_VEND_CMU
end_ifdef

begin_function_decl
specifier|static
name|void
name|vend_cmu
parameter_list|(
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DHCP_ENV
end_ifdef

begin_comment
comment|/* export the dhcp response to kenv */
end_comment

begin_struct_decl
struct_decl|struct
name|dhcp_opt
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|setenv_
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|ep
parameter_list|,
name|struct
name|dhcp_opt
modifier|*
name|opts
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|setenv_
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DHCP
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|expected_dhcpmsgtype
init|=
operator|-
literal|1
decl_stmt|,
name|dhcp_ok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|dhcp_serverip
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|bootp
modifier|*
name|bootp_response
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|bootp_response_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fetch required bootp infomation */
end_comment

begin_function
name|void
name|bootp
parameter_list|(
name|int
name|sock
parameter_list|)
block|{
name|void
modifier|*
name|pkt
decl_stmt|;
name|struct
name|iodesc
modifier|*
name|d
decl_stmt|;
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
struct|struct
block|{
name|u_char
name|header
index|[
name|HEADER_SIZE
index|]
decl_stmt|;
name|struct
name|bootp
name|wbootp
decl_stmt|;
block|}
name|wbuf
struct|;
name|struct
name|bootp
modifier|*
name|rbootp
decl_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bootp: socket=%d\n"
argument_list|,
name|sock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bot
condition|)
name|bot
operator|=
name|getsecs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|socktodesc
argument_list|(
name|sock
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bootp: bad socket. %d\n"
argument_list|,
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bootp: d=%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
operator|&
name|wbuf
operator|.
name|wbootp
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_op
operator|=
name|BOOTREQUEST
expr_stmt|;
name|bp
operator|->
name|bp_htype
operator|=
literal|1
expr_stmt|;
comment|/* 10Mb Ethernet (48 bits) */
name|bp
operator|->
name|bp_hlen
operator|=
literal|6
expr_stmt|;
name|bp
operator|->
name|bp_xid
operator|=
name|htonl
argument_list|(
name|d
operator|->
name|xid
argument_list|)
expr_stmt|;
name|MACPY
argument_list|(
name|d
operator|->
name|myea
argument_list|,
name|bp
operator|->
name|bp_chaddr
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|,
name|bootfile
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
operator|->
name|bp_file
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|vm_rfc1048
argument_list|,
name|bp
operator|->
name|bp_vend
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_rfc1048
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_DHCP
name|bp
operator|->
name|bp_vend
index|[
literal|4
index|]
operator|=
name|TAG_DHCP_MSGTYPE
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|6
index|]
operator|=
name|DHCPDISCOVER
expr_stmt|;
comment|/* 	 * We are booting from PXE, we want to send the string 	 * 'PXEClient' to the DHCP server so you have the option of 	 * only responding to PXE aware dhcp requests. 	 */
name|bp
operator|->
name|bp_vend
index|[
literal|7
index|]
operator|=
name|TAG_CLASSID
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|8
index|]
operator|=
literal|9
expr_stmt|;
name|bcopy
argument_list|(
literal|"PXEClient"
argument_list|,
operator|&
name|bp
operator|->
name|bp_vend
index|[
literal|9
index|]
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|18
index|]
operator|=
name|TAG_USER_CLASS
expr_stmt|;
comment|/* len of each user class + number of user class */
name|bp
operator|->
name|bp_vend
index|[
literal|19
index|]
operator|=
literal|8
expr_stmt|;
comment|/* len of the first user class */
name|bp
operator|->
name|bp_vend
index|[
literal|20
index|]
operator|=
literal|7
expr_stmt|;
name|bcopy
argument_list|(
literal|"FreeBSD"
argument_list|,
operator|&
name|bp
operator|->
name|bp_vend
index|[
literal|21
index|]
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|28
index|]
operator|=
name|TAG_PARAM_REQ
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|29
index|]
operator|=
literal|7
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|30
index|]
operator|=
name|TAG_ROOTPATH
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|31
index|]
operator|=
name|TAG_HOSTNAME
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|32
index|]
operator|=
name|TAG_SWAPSERVER
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|33
index|]
operator|=
name|TAG_GATEWAY
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|34
index|]
operator|=
name|TAG_SUBNET_MASK
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|35
index|]
operator|=
name|TAG_INTF_MTU
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|36
index|]
operator|=
name|TAG_SERVERID
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|37
index|]
operator|=
name|TAG_END
expr_stmt|;
else|#
directive|else
name|bp
operator|->
name|bp_vend
index|[
literal|4
index|]
operator|=
name|TAG_END
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|myip
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|d
operator|->
name|myport
operator|=
name|htons
argument_list|(
name|IPPORT_BOOTPC
argument_list|)
expr_stmt|;
name|d
operator|->
name|destip
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
name|d
operator|->
name|destport
operator|=
name|htons
argument_list|(
name|IPPORT_BOOTPS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_DHCP
name|expected_dhcpmsgtype
operator|=
name|DHCPOFFER
expr_stmt|;
name|dhcp_ok
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendrecv
argument_list|(
name|d
argument_list|,
name|bootpsend
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|,
name|bootprecv
argument_list|,
operator|&
name|pkt
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rbootp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"bootp: no reply\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_DHCP
if|if
condition|(
name|dhcp_ok
condition|)
block|{
name|u_int32_t
name|leasetime
decl_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|6
index|]
operator|=
name|DHCPREQUEST
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|7
index|]
operator|=
name|TAG_REQ_ADDR
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|8
index|]
operator|=
literal|4
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rbootp
operator|->
name|bp_yiaddr
argument_list|,
operator|&
name|bp
operator|->
name|bp_vend
index|[
literal|9
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|13
index|]
operator|=
name|TAG_SERVERID
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|14
index|]
operator|=
literal|4
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dhcp_serverip
operator|.
name|s_addr
argument_list|,
operator|&
name|bp
operator|->
name|bp_vend
index|[
literal|15
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|19
index|]
operator|=
name|TAG_LEASETIME
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|20
index|]
operator|=
literal|4
expr_stmt|;
name|leasetime
operator|=
name|htonl
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|leasetime
argument_list|,
operator|&
name|bp
operator|->
name|bp_vend
index|[
literal|21
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|25
index|]
operator|=
name|TAG_CLASSID
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|26
index|]
operator|=
literal|9
expr_stmt|;
name|bcopy
argument_list|(
literal|"PXEClient"
argument_list|,
operator|&
name|bp
operator|->
name|bp_vend
index|[
literal|27
index|]
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_vend
index|[
literal|36
index|]
operator|=
name|TAG_END
expr_stmt|;
name|expected_dhcpmsgtype
operator|=
name|DHCPACK
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendrecv
argument_list|(
name|d
argument_list|,
name|bootpsend
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|,
name|bootprecv
argument_list|,
operator|&
name|pkt
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rbootp
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"DHCPREQUEST failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|myip
operator|=
name|d
operator|->
name|myip
operator|=
name|rbootp
operator|->
name|bp_yiaddr
expr_stmt|;
name|servip
operator|=
name|rbootp
operator|->
name|bp_siaddr
expr_stmt|;
if|if
condition|(
name|rootip
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|rootip
operator|=
name|servip
expr_stmt|;
name|bcopy
argument_list|(
name|rbootp
operator|->
name|bp_file
argument_list|,
name|bootfile
argument_list|,
sizeof|sizeof
argument_list|(
name|bootfile
argument_list|)
argument_list|)
expr_stmt|;
name|bootfile
index|[
sizeof|sizeof
argument_list|(
name|bootfile
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|netmask
condition|)
block|{
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|ntohl
argument_list|(
name|myip
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|netmask
operator|=
name|htonl
argument_list|(
name|IN_CLASSA_NET
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|ntohl
argument_list|(
name|myip
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
name|netmask
operator|=
name|htonl
argument_list|(
name|IN_CLASSB_NET
argument_list|)
expr_stmt|;
else|else
name|netmask
operator|=
name|htonl
argument_list|(
name|IN_CLASSC_NET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"'native netmask' is %s\n"
argument_list|,
name|intoa
argument_list|(
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"mask: %s\n"
argument_list|,
name|intoa
argument_list|(
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We need a gateway if root is on a different net */
if|if
condition|(
operator|!
name|SAMENET
argument_list|(
name|myip
argument_list|,
name|rootip
argument_list|,
name|netmask
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"need gateway for root ip\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Toss gateway if on a different net */
if|if
condition|(
operator|!
name|SAMENET
argument_list|(
name|myip
argument_list|,
name|gateip
argument_list|,
name|netmask
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"gateway ip (%s) bad\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|gateip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gateip
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Bump xid so next request will be unique. */
operator|++
name|d
operator|->
name|xid
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Transmit a bootp request */
end_comment

begin_function
specifier|static
name|ssize_t
name|bootpsend
parameter_list|(
name|struct
name|iodesc
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|pkt
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bootpsend: d=%lx called.\n"
argument_list|,
operator|(
name|long
operator|)
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
name|pkt
expr_stmt|;
name|bp
operator|->
name|bp_secs
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
name|getsecs
argument_list|()
operator|-
name|bot
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bootpsend: calling sendudp\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|sendudp
argument_list|(
name|d
argument_list|,
name|pkt
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|bootprecv
parameter_list|(
name|struct
name|iodesc
modifier|*
name|d
parameter_list|,
name|void
modifier|*
modifier|*
name|pkt
parameter_list|,
name|void
modifier|*
modifier|*
name|payload
parameter_list|,
name|time_t
name|tleft
parameter_list|)
block|{
name|ssize_t
name|n
decl_stmt|;
name|struct
name|bootp
modifier|*
name|bp
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bootp_recvoffer: called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|readudp
argument_list|(
name|d
argument_list|,
operator|&
name|ptr
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|bp
argument_list|,
name|tleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|||
name|n
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|bootp
argument_list|)
operator|-
name|BOOTP_VENDSIZE
condition|)
goto|goto
name|bad
goto|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bootprecv: checked.  bp = %p, n = %zd\n"
argument_list|,
name|bp
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|bp_xid
operator|!=
name|htonl
argument_list|(
name|d
operator|->
name|xid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"bootprecv: expected xid 0x%lx, got 0x%x\n"
argument_list|,
name|d
operator|->
name|xid
argument_list|,
name|ntohl
argument_list|(
name|bp
operator|->
name|bp_xid
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"bootprecv: got one!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Suck out vendor info */
if|if
condition|(
name|bcmp
argument_list|(
name|vm_rfc1048
argument_list|,
name|bp
operator|->
name|bp_vend
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_rfc1048
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|vsize
init|=
name|n
operator|-
name|offsetof
argument_list|(
expr|struct
name|bootp
argument_list|,
name|bp_vend
argument_list|)
decl_stmt|;
if|if
condition|(
name|vend_rfc1048
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|,
name|vsize
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* Save copy of bootp reply or DHCP ACK message */
if|if
condition|(
name|bp
operator|->
name|bp_op
operator|==
name|BOOTREPLY
operator|&&
operator|(
operator|(
name|dhcp_ok
operator|==
literal|1
operator|&&
name|expected_dhcpmsgtype
operator|==
name|DHCPACK
operator|)
operator|||
name|dhcp_ok
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|bootp_response
argument_list|)
expr_stmt|;
name|bootp_response
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootp_response
operator|!=
name|NULL
condition|)
block|{
name|bootp_response_size
operator|=
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|bp
argument_list|,
name|bootp_response
argument_list|,
name|bootp_response_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|BOOTP_VEND_CMU
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|vm_cmu
argument_list|,
name|bp
operator|->
name|bp_vend
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_cmu
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|vend_cmu
argument_list|(
name|bp
operator|->
name|bp_vend
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
literal|"bootprecv: unknown vendor 0x%lx\n"
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|bp_vend
argument_list|)
expr_stmt|;
operator|*
name|pkt
operator|=
name|ptr
expr_stmt|;
operator|*
name|payload
operator|=
name|bp
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dhcp_try_rfc1048
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|expected_dhcpmsgtype
operator|=
name|DHCPACK
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|vm_rfc1048
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_rfc1048
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|vend_rfc1048
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vend_rfc1048
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|ep
decl_stmt|;
name|int
name|size
decl_stmt|;
name|u_char
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"vend_rfc1048 bootp info. len=%d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ep
operator|=
name|cp
operator|+
name|len
expr_stmt|;
comment|/* Step over magic cookie */
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|setenv_
argument_list|(
name|cp
argument_list|,
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
name|tag
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|size
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|TAG_END
condition|)
break|break;
if|if
condition|(
name|tag
operator|==
name|TAG_SUBNET_MASK
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|netmask
argument_list|,
sizeof|sizeof
argument_list|(
name|netmask
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_GATEWAY
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|gateip
operator|.
name|s_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|gateip
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_SWAPSERVER
condition|)
block|{
comment|/* let it override bp_siaddr */
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|rootip
operator|.
name|s_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|rootip
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_ROOTPATH
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"dhcp.root-path"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|val
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|strlcpy
argument_list|(
name|rootpath
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|rootpath
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_HOSTNAME
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"dhcp.host-name"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|val
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
expr_stmt|;
name|strlcpy
argument_list|(
name|hostname
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_INTF_MTU
condition|)
block|{
name|intf_mtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"dhcp.interface-mtu"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|tmp
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Do not allow MTU to exceed max IPv4 packet 				 * size, max value of 16-bit word. 				 */
name|tmp
operator|=
name|strtoul
argument_list|(
name|val
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|val
operator|==
literal|'\0'
operator|||
operator|*
name|end
operator|!=
literal|'\0'
operator|||
name|tmp
operator|>
name|USHRT_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad value: \"%s\", "
literal|"ignoring\n"
argument_list|,
literal|"dhcp.interface-mtu"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|intf_mtu
operator|=
operator|(
name|u_int
operator|)
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intf_mtu
operator|<=
literal|0
condition|)
name|intf_mtu
operator|=
name|be16dec
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUPPORT_DHCP
if|if
condition|(
name|tag
operator|==
name|TAG_DHCP_MSGTYPE
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
name|expected_dhcpmsgtype
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dhcp_ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_SERVERID
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|dhcp_serverip
operator|.
name|s_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|dhcp_serverip
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cp
operator|+=
name|size
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BOOTP_VEND_CMU
end_ifdef

begin_function
specifier|static
name|void
name|vend_cmu
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|cmu_vend
modifier|*
name|vp
decl_stmt|;
ifdef|#
directive|ifdef
name|BOOTP_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"vend_cmu bootp info.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vp
operator|=
operator|(
expr|struct
name|cmu_vend
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_smask
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|netmask
operator|=
name|vp
operator|->
name|v_smask
operator|.
name|s_addr
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_dgate
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|gateip
operator|=
name|vp
operator|->
name|v_dgate
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DHCP_ENV
end_ifdef

begin_comment
comment|/*  * Parse DHCP options and store them into kenv variables.  * Original code from Danny Braniss, modifications by Luigi Rizzo.  *  * The parser is driven by tables which specify the type and name of  * each dhcp option and how it appears in kenv.  * The first entry in the list contains the prefix used to set the kenv  * name (including the . if needed), the last entry must have a 0 tag.  * Entries do not need to be sorted though it helps for readability.  *  * Certain vendor-specific tables can be enabled according to DHCP_ENV.  * Set it to 0 if you don't want any.  */
end_comment

begin_enum
enum|enum
name|opt_fmt
block|{
name|__NONE
init|=
literal|0
block|,
name|__8
init|=
literal|1
block|,
name|__16
init|=
literal|2
block|,
name|__32
init|=
literal|4
block|,
comment|/* Unsigned fields, value=size	*/
name|__IP
block|,
comment|/* IPv4 address			*/
name|__TXT
block|,
comment|/* C string			*/
name|__BYTES
block|,
comment|/* byte sequence, printed %02x	*/
name|__INDIR
block|,
comment|/* name=value			*/
name|__ILIST
block|,
comment|/* name=value;name=value ... */
name|__VE
block|,
comment|/* vendor specific, recurse	*/
block|}
enum|;
end_enum

begin_struct
struct|struct
name|dhcp_opt
block|{
name|uint8_t
name|tag
decl_stmt|;
name|uint8_t
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dhcp_opt
name|vndr_opt
index|[]
init|=
block|{
comment|/* Vendor Specific Options */
if|#
directive|if
name|DHCP_ENV
operator|==
name|DHCP_ENV_FREEBSD
comment|/* FreeBSD table in the original code */
block|{
literal|0
block|,
literal|0
block|,
literal|"FreeBSD"
block|}
block|,
comment|/* prefix */
block|{
literal|1
block|,
name|__TXT
block|,
literal|"kernel"
block|}
block|,
block|{
literal|2
block|,
name|__TXT
block|,
literal|"kernelname"
block|}
block|,
block|{
literal|3
block|,
name|__TXT
block|,
literal|"kernel_options"
block|}
block|,
block|{
literal|4
block|,
name|__IP
block|,
literal|"usr-ip"
block|}
block|,
block|{
literal|5
block|,
name|__TXT
block|,
literal|"conf-path"
block|}
block|,
block|{
literal|6
block|,
name|__TXT
block|,
literal|"rc.conf0"
block|}
block|,
block|{
literal|7
block|,
name|__TXT
block|,
literal|"rc.conf1"
block|}
block|,
block|{
literal|8
block|,
name|__TXT
block|,
literal|"rc.conf2"
block|}
block|,
block|{
literal|9
block|,
name|__TXT
block|,
literal|"rc.conf3"
block|}
block|,
block|{
literal|10
block|,
name|__TXT
block|,
literal|"rc.conf4"
block|}
block|,
block|{
literal|11
block|,
name|__TXT
block|,
literal|"rc.conf5"
block|}
block|,
block|{
literal|12
block|,
name|__TXT
block|,
literal|"rc.conf6"
block|}
block|,
block|{
literal|13
block|,
name|__TXT
block|,
literal|"rc.conf7"
block|}
block|,
block|{
literal|14
block|,
name|__TXT
block|,
literal|"rc.conf8"
block|}
block|,
block|{
literal|15
block|,
name|__TXT
block|,
literal|"rc.conf9"
block|}
block|,
block|{
literal|20
block|,
name|__TXT
block|,
literal|"boot.nfsroot.options"
block|}
block|,
block|{
literal|245
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|246
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|247
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|248
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|249
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|250
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|251
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|252
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|253
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|254
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
elif|#
directive|elif
name|DHCP_ENV
operator|==
name|DHCP_ENV_PXE
comment|/* some pxe options, RFC4578 */
block|{
literal|0
block|,
literal|0
block|,
literal|"pxe"
block|}
block|,
comment|/* prefix */
block|{
literal|93
block|,
name|__16
block|,
literal|"system-architecture"
block|}
block|,
block|{
literal|94
block|,
name|__BYTES
block|,
literal|"network-interface"
block|}
block|,
block|{
literal|97
block|,
name|__BYTES
block|,
literal|"machine-identifier"
block|}
block|,
else|#
directive|else
comment|/* default (empty) table */
block|{
literal|0
block|,
literal|0
block|,
literal|"dhcp.vendor."
block|}
block|,
comment|/* prefix */
endif|#
directive|endif
block|{
literal|0
block|,
name|__TXT
block|,
literal|"%soption-%d"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dhcp_opt
name|dhcp_opt
index|[]
init|=
block|{
comment|/* DHCP Option names, formats and codes, from RFC2132. */
block|{
literal|0
block|,
literal|0
block|,
literal|"dhcp."
block|}
block|,
comment|// prefix
block|{
literal|1
block|,
name|__IP
block|,
literal|"subnet-mask"
block|}
block|,
block|{
literal|2
block|,
name|__32
block|,
literal|"time-offset"
block|}
block|,
comment|/* this is signed */
block|{
literal|3
block|,
name|__IP
block|,
literal|"routers"
block|}
block|,
block|{
literal|4
block|,
name|__IP
block|,
literal|"time-servers"
block|}
block|,
block|{
literal|5
block|,
name|__IP
block|,
literal|"ien116-name-servers"
block|}
block|,
block|{
literal|6
block|,
name|__IP
block|,
literal|"domain-name-servers"
block|}
block|,
block|{
literal|7
block|,
name|__IP
block|,
literal|"log-servers"
block|}
block|,
block|{
literal|8
block|,
name|__IP
block|,
literal|"cookie-servers"
block|}
block|,
block|{
literal|9
block|,
name|__IP
block|,
literal|"lpr-servers"
block|}
block|,
block|{
literal|10
block|,
name|__IP
block|,
literal|"impress-servers"
block|}
block|,
block|{
literal|11
block|,
name|__IP
block|,
literal|"resource-location-servers"
block|}
block|,
block|{
literal|12
block|,
name|__TXT
block|,
literal|"host-name"
block|}
block|,
block|{
literal|13
block|,
name|__16
block|,
literal|"boot-size"
block|}
block|,
block|{
literal|14
block|,
name|__TXT
block|,
literal|"merit-dump"
block|}
block|,
block|{
literal|15
block|,
name|__TXT
block|,
literal|"domain-name"
block|}
block|,
block|{
literal|16
block|,
name|__IP
block|,
literal|"swap-server"
block|}
block|,
block|{
literal|17
block|,
name|__TXT
block|,
literal|"root-path"
block|}
block|,
block|{
literal|18
block|,
name|__TXT
block|,
literal|"extensions-path"
block|}
block|,
block|{
literal|19
block|,
name|__8
block|,
literal|"ip-forwarding"
block|}
block|,
block|{
literal|20
block|,
name|__8
block|,
literal|"non-local-source-routing"
block|}
block|,
block|{
literal|21
block|,
name|__IP
block|,
literal|"policy-filter"
block|}
block|,
block|{
literal|22
block|,
name|__16
block|,
literal|"max-dgram-reassembly"
block|}
block|,
block|{
literal|23
block|,
name|__8
block|,
literal|"default-ip-ttl"
block|}
block|,
block|{
literal|24
block|,
name|__32
block|,
literal|"path-mtu-aging-timeout"
block|}
block|,
block|{
literal|25
block|,
name|__16
block|,
literal|"path-mtu-plateau-table"
block|}
block|,
block|{
literal|26
block|,
name|__16
block|,
literal|"interface-mtu"
block|}
block|,
block|{
literal|27
block|,
name|__8
block|,
literal|"all-subnets-local"
block|}
block|,
block|{
literal|28
block|,
name|__IP
block|,
literal|"broadcast-address"
block|}
block|,
block|{
literal|29
block|,
name|__8
block|,
literal|"perform-mask-discovery"
block|}
block|,
block|{
literal|30
block|,
name|__8
block|,
literal|"mask-supplier"
block|}
block|,
block|{
literal|31
block|,
name|__8
block|,
literal|"perform-router-discovery"
block|}
block|,
block|{
literal|32
block|,
name|__IP
block|,
literal|"router-solicitation-address"
block|}
block|,
block|{
literal|33
block|,
name|__IP
block|,
literal|"static-routes"
block|}
block|,
block|{
literal|34
block|,
name|__8
block|,
literal|"trailer-encapsulation"
block|}
block|,
block|{
literal|35
block|,
name|__32
block|,
literal|"arp-cache-timeout"
block|}
block|,
block|{
literal|36
block|,
name|__8
block|,
literal|"ieee802-3-encapsulation"
block|}
block|,
block|{
literal|37
block|,
name|__8
block|,
literal|"default-tcp-ttl"
block|}
block|,
block|{
literal|38
block|,
name|__32
block|,
literal|"tcp-keepalive-interval"
block|}
block|,
block|{
literal|39
block|,
name|__8
block|,
literal|"tcp-keepalive-garbage"
block|}
block|,
block|{
literal|40
block|,
name|__TXT
block|,
literal|"nis-domain"
block|}
block|,
block|{
literal|41
block|,
name|__IP
block|,
literal|"nis-servers"
block|}
block|,
block|{
literal|42
block|,
name|__IP
block|,
literal|"ntp-servers"
block|}
block|,
block|{
literal|43
block|,
name|__VE
block|,
literal|"vendor-encapsulated-options"
block|}
block|,
block|{
literal|44
block|,
name|__IP
block|,
literal|"netbios-name-servers"
block|}
block|,
block|{
literal|45
block|,
name|__IP
block|,
literal|"netbios-dd-server"
block|}
block|,
block|{
literal|46
block|,
name|__8
block|,
literal|"netbios-node-type"
block|}
block|,
block|{
literal|47
block|,
name|__TXT
block|,
literal|"netbios-scope"
block|}
block|,
block|{
literal|48
block|,
name|__IP
block|,
literal|"x-font-servers"
block|}
block|,
block|{
literal|49
block|,
name|__IP
block|,
literal|"x-display-managers"
block|}
block|,
block|{
literal|50
block|,
name|__IP
block|,
literal|"dhcp-requested-address"
block|}
block|,
block|{
literal|51
block|,
name|__32
block|,
literal|"dhcp-lease-time"
block|}
block|,
block|{
literal|52
block|,
name|__8
block|,
literal|"dhcp-option-overload"
block|}
block|,
block|{
literal|53
block|,
name|__8
block|,
literal|"dhcp-message-type"
block|}
block|,
block|{
literal|54
block|,
name|__IP
block|,
literal|"dhcp-server-identifier"
block|}
block|,
block|{
literal|55
block|,
name|__8
block|,
literal|"dhcp-parameter-request-list"
block|}
block|,
block|{
literal|56
block|,
name|__TXT
block|,
literal|"dhcp-message"
block|}
block|,
block|{
literal|57
block|,
name|__16
block|,
literal|"dhcp-max-message-size"
block|}
block|,
block|{
literal|58
block|,
name|__32
block|,
literal|"dhcp-renewal-time"
block|}
block|,
block|{
literal|59
block|,
name|__32
block|,
literal|"dhcp-rebinding-time"
block|}
block|,
block|{
literal|60
block|,
name|__TXT
block|,
literal|"vendor-class-identifier"
block|}
block|,
block|{
literal|61
block|,
name|__TXT
block|,
literal|"dhcp-client-identifier"
block|}
block|,
block|{
literal|64
block|,
name|__TXT
block|,
literal|"nisplus-domain"
block|}
block|,
block|{
literal|65
block|,
name|__IP
block|,
literal|"nisplus-servers"
block|}
block|,
block|{
literal|66
block|,
name|__TXT
block|,
literal|"tftp-server-name"
block|}
block|,
block|{
literal|67
block|,
name|__TXT
block|,
literal|"bootfile-name"
block|}
block|,
block|{
literal|68
block|,
name|__IP
block|,
literal|"mobile-ip-home-agent"
block|}
block|,
block|{
literal|69
block|,
name|__IP
block|,
literal|"smtp-server"
block|}
block|,
block|{
literal|70
block|,
name|__IP
block|,
literal|"pop-server"
block|}
block|,
block|{
literal|71
block|,
name|__IP
block|,
literal|"nntp-server"
block|}
block|,
block|{
literal|72
block|,
name|__IP
block|,
literal|"www-server"
block|}
block|,
block|{
literal|73
block|,
name|__IP
block|,
literal|"finger-server"
block|}
block|,
block|{
literal|74
block|,
name|__IP
block|,
literal|"irc-server"
block|}
block|,
block|{
literal|75
block|,
name|__IP
block|,
literal|"streettalk-server"
block|}
block|,
block|{
literal|76
block|,
name|__IP
block|,
literal|"streettalk-directory-assistance-server"
block|}
block|,
block|{
literal|77
block|,
name|__TXT
block|,
literal|"user-class"
block|}
block|,
block|{
literal|85
block|,
name|__IP
block|,
literal|"nds-servers"
block|}
block|,
block|{
literal|86
block|,
name|__TXT
block|,
literal|"nds-tree-name"
block|}
block|,
block|{
literal|87
block|,
name|__TXT
block|,
literal|"nds-context"
block|}
block|,
block|{
literal|210
block|,
name|__TXT
block|,
literal|"authenticate"
block|}
block|,
comment|/* use the following entries for arbitrary variables */
block|{
literal|246
block|,
name|__ILIST
block|,
literal|""
block|}
block|,
block|{
literal|247
block|,
name|__ILIST
block|,
literal|""
block|}
block|,
block|{
literal|248
block|,
name|__ILIST
block|,
literal|""
block|}
block|,
block|{
literal|249
block|,
name|__ILIST
block|,
literal|""
block|}
block|,
block|{
literal|250
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|251
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|252
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|253
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|254
block|,
name|__INDIR
block|,
literal|""
block|}
block|,
block|{
literal|0
block|,
name|__TXT
block|,
literal|"%soption-%d"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * parse a dhcp response, set environment variables translating options  * names and values according to the tables above. Also set dhcp.tags  * to the list of selected tags.  */
end_comment

begin_function
specifier|static
name|void
name|setenv_
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|ep
parameter_list|,
name|struct
name|dhcp_opt
modifier|*
name|opts
parameter_list|)
block|{
name|u_char
modifier|*
name|ncp
decl_stmt|;
name|u_char
name|tag
decl_stmt|;
name|char
name|tags
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
comment|/* the list of tags */
define|#
directive|define
name|FLD_SEP
value|','
comment|/* separator in list of elements */
name|ncp
operator|=
name|cp
expr_stmt|;
name|tp
operator|=
name|tags
expr_stmt|;
if|if
condition|(
name|opts
operator|==
name|NULL
condition|)
name|opts
operator|=
name|dhcp_opt
expr_stmt|;
while|while
condition|(
name|ncp
operator|<
name|ep
condition|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* option size */
name|char
modifier|*
name|vp
decl_stmt|,
modifier|*
name|endv
decl_stmt|,
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* the value buffer */
name|struct
name|dhcp_opt
modifier|*
name|op
decl_stmt|;
name|tag
operator|=
operator|*
name|ncp
operator|++
expr_stmt|;
comment|/* extract tag and size */
name|size
operator|=
operator|*
name|ncp
operator|++
expr_stmt|;
name|cp
operator|=
name|ncp
expr_stmt|;
comment|/* current payload */
name|ncp
operator|+=
name|size
expr_stmt|;
comment|/* point to the next option */
if|if
condition|(
name|tag
operator|==
name|TAG_END
condition|)
break|break;
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|op
operator|=
name|opts
operator|+
literal|1
init|;
name|op
operator|->
name|tag
operator|&&
name|op
operator|->
name|tag
operator|!=
name|tag
condition|;
name|op
operator|++
control|)
empty_stmt|;
comment|/* if not found we end up on the default entry */
comment|/* 	 * Copy data into the buffer. libstand does not have snprintf so we 	 * need to be careful with sprintf(). With strings, the source is 	 * always<256 char so shorter than the buffer so we are safe; with 	 * other arguments, the longest string is inet_ntoa which is 16 bytes 	 * so we make sure to have always enough room in the string before 	 * trying an sprint. 	 */
name|vp
operator|=
name|buf
expr_stmt|;
operator|*
name|vp
operator|=
literal|'\0'
expr_stmt|;
name|endv
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
operator|-
literal|16
expr_stmt|;
comment|/* last valid write position */
switch|switch
condition|(
name|op
operator|->
name|fmt
condition|)
block|{
case|case
name|__NONE
case|:
break|break;
comment|/* should not happen */
case|case
name|__VE
case|:
comment|/* recurse, vendor specific */
name|setenv_
argument_list|(
name|cp
argument_list|,
name|cp
operator|+
name|size
argument_list|,
name|vndr_opt
argument_list|)
expr_stmt|;
break|break;
case|case
name|__IP
case|:
comment|/* ip address */
for|for
control|(
init|;
name|size
operator|>
literal|0
operator|&&
name|vp
operator|<
name|endv
condition|;
name|size
operator|-=
literal|4
operator|,
name|cp
operator|+=
literal|4
control|)
block|{
name|struct
name|in_addr
name|in_ip
decl_stmt|;
comment|/* ip addresses */
if|if
condition|(
name|vp
operator|!=
name|buf
condition|)
operator|*
name|vp
operator|++
operator|=
name|FLD_SEP
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|in_ip
operator|.
name|s_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|in_ip
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|vp
argument_list|,
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|in_ip
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|strlen
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|__BYTES
case|:
comment|/* opaque byte string */
for|for
control|(
init|;
name|size
operator|>
literal|0
operator|&&
name|vp
operator|<
name|endv
condition|;
name|size
operator|-=
literal|1
operator|,
name|cp
operator|+=
literal|1
control|)
block|{
name|sprintf
argument_list|(
name|vp
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|strlen
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|__TXT
case|:
name|bcopy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* cannot overflow */
name|buf
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|__32
case|:
case|case
name|__16
case|:
case|case
name|__8
case|:
comment|/* op->fmt is also the length of each field */
for|for
control|(
init|;
name|size
operator|>
literal|0
operator|&&
name|vp
operator|<
name|endv
condition|;
name|size
operator|-=
name|op
operator|->
name|fmt
operator|,
name|cp
operator|+=
name|op
operator|->
name|fmt
control|)
block|{
name|uint32_t
name|v
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|fmt
operator|==
name|__32
condition|)
name|v
operator|=
operator|(
name|cp
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|cp
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|cp
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|cp
index|[
literal|3
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|fmt
operator|==
name|__16
condition|)
name|v
operator|=
operator|(
name|cp
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|cp
index|[
literal|1
index|]
expr_stmt|;
else|else
name|v
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|buf
condition|)
operator|*
name|vp
operator|++
operator|=
name|FLD_SEP
expr_stmt|;
name|sprintf
argument_list|(
name|vp
argument_list|,
literal|"%u"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|vp
operator|+=
name|strlen
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|__INDIR
case|:
comment|/* name=value */
case|case
name|__ILIST
case|:
comment|/* name=value;name=value... */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* cannot overflow */
name|buf
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|endv
operator|=
name|buf
init|;
name|endv
condition|;
name|endv
operator|=
name|vp
control|)
block|{
name|u_char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
comment|/* semicolon ? */
comment|/* skip leading whitespace */
while|while
condition|(
operator|*
name|endv
operator|&&
name|strchr
argument_list|(
literal|" \t\n\r"
argument_list|,
operator|*
name|endv
argument_list|)
condition|)
name|endv
operator|++
expr_stmt|;
name|vp
operator|=
name|strchr
argument_list|(
name|endv
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
comment|/* find name=value separator */
if|if
condition|(
operator|!
name|vp
condition|)
break|break;
operator|*
name|vp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|fmt
operator|==
name|__ILIST
operator|&&
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|vp
argument_list|,
literal|';'
argument_list|)
operator|)
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|setenv
argument_list|(
name|endv
argument_list|,
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vp
operator|=
name|s
expr_stmt|;
comment|/* prepare for next round */
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* option already done */
block|}
if|if
condition|(
name|tp
operator|-
name|tags
operator|<
sizeof|sizeof
argument_list|(
name|tags
argument_list|)
operator|-
literal|5
condition|)
block|{
comment|/* add tag to the list */
if|if
condition|(
name|tp
operator|!=
name|tags
condition|)
operator|*
name|tp
operator|++
operator|=
name|FLD_SEP
expr_stmt|;
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|tp
operator|+=
name|strlen
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
name|char
name|env
index|[
literal|128
index|]
decl_stmt|;
comment|/* the string name */
if|if
condition|(
name|op
operator|->
name|tag
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|env
argument_list|,
name|op
operator|->
name|desc
argument_list|,
name|opts
index|[
literal|0
index|]
operator|.
name|desc
argument_list|,
name|tag
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s%s"
argument_list|,
name|opts
index|[
literal|0
index|]
operator|.
name|desc
argument_list|,
name|op
operator|->
name|desc
argument_list|)
expr_stmt|;
comment|/* 	     * Do not replace existing values in the environment, so that 	     * locally-obtained values can override server-provided values. 	     */
name|setenv
argument_list|(
name|env
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp
operator|!=
name|tags
condition|)
block|{
name|char
name|env
index|[
literal|128
index|]
decl_stmt|;
comment|/* the string name */
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%stags"
argument_list|,
name|opts
index|[
literal|0
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|env
argument_list|,
name|tags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* additional dhcp */
end_comment

end_unit

