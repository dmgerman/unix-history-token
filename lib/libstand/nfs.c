begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: nfs.c,v 1.2 1998/01/24 12:43:09 drochner Exp $	*/
end_comment

begin_comment
comment|/*-  *  Copyright (c) 1993 John Brezak  *  All rights reserved.  *   *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|"rpcv2.h"
end_include

begin_include
include|#
directive|include
file|"nfsv2.h"
end_include

begin_include
include|#
directive|include
file|"stand.h"
end_include

begin_include
include|#
directive|include
file|"net.h"
end_include

begin_include
include|#
directive|include
file|"netif.h"
end_include

begin_include
include|#
directive|include
file|"rpc.h"
end_include

begin_define
define|#
directive|define
name|NFS_DEBUGxx
end_define

begin_comment
comment|/* Define our own NFS attributes without NQNFS stuff. */
end_comment

begin_struct
struct|struct
name|nfsv2_fattrs
block|{
name|n_long
name|fa_type
decl_stmt|;
name|n_long
name|fa_mode
decl_stmt|;
name|n_long
name|fa_nlink
decl_stmt|;
name|n_long
name|fa_uid
decl_stmt|;
name|n_long
name|fa_gid
decl_stmt|;
name|n_long
name|fa_size
decl_stmt|;
name|n_long
name|fa_blocksize
decl_stmt|;
name|n_long
name|fa_rdev
decl_stmt|;
name|n_long
name|fa_blocks
decl_stmt|;
name|n_long
name|fa_fsid
decl_stmt|;
name|n_long
name|fa_fileid
decl_stmt|;
name|struct
name|nfsv2_time
name|fa_atime
decl_stmt|;
name|struct
name|nfsv2_time
name|fa_mtime
decl_stmt|;
name|struct
name|nfsv2_time
name|fa_ctime
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nfs_read_args
block|{
name|u_char
name|fh
index|[
name|NFS_FHSIZE
index|]
decl_stmt|;
name|n_long
name|off
decl_stmt|;
name|n_long
name|len
decl_stmt|;
name|n_long
name|xxx
decl_stmt|;
comment|/* XXX what's this for? */
block|}
struct|;
end_struct

begin_comment
comment|/* Data part of nfs rpc reply (also the largest thing we receive) */
end_comment

begin_define
define|#
directive|define
name|NFSREAD_SIZE
value|1024
end_define

begin_struct
struct|struct
name|nfs_read_repl
block|{
name|n_long
name|errno
decl_stmt|;
name|struct
name|nfsv2_fattrs
name|fa
decl_stmt|;
name|n_long
name|count
decl_stmt|;
name|u_char
name|data
index|[
name|NFSREAD_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
end_ifndef

begin_struct
struct|struct
name|nfs_readlnk_repl
block|{
name|n_long
name|errno
decl_stmt|;
name|n_long
name|len
decl_stmt|;
name|char
name|path
index|[
name|NFS_MAXPATHLEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|nfs_readdir_args
block|{
name|u_char
name|fh
index|[
name|NFS_FHSIZE
index|]
decl_stmt|;
name|n_long
name|cookie
decl_stmt|;
name|n_long
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nfs_readdir_data
block|{
name|n_long
name|fileid
decl_stmt|;
name|n_long
name|len
decl_stmt|;
name|char
name|name
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nfs_readdir_off
block|{
name|n_long
name|cookie
decl_stmt|;
name|n_long
name|follows
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nfs_iodesc
block|{
name|struct
name|iodesc
modifier|*
name|iodesc
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|u_char
name|fh
index|[
name|NFS_FHSIZE
index|]
decl_stmt|;
name|struct
name|nfsv2_fattrs
name|fa
decl_stmt|;
comment|/* all in network order */
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX interactions with tftp? See nfswrapper.c for a confusing  *     issue.  */
end_comment

begin_function_decl
name|int
name|nfs_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_read
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_write
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|nfs_seek
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|where
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_stat
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_readdir
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|dirent
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|nfs_iodesc
name|nfs_root_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs_ops
name|nfs_fsops
init|=
block|{
literal|"nfs"
block|,
name|nfs_open
block|,
name|nfs_close
block|,
name|nfs_read
block|,
name|nfs_write
block|,
name|nfs_seek
block|,
name|nfs_stat
block|,
name|nfs_readdir
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fetch the root file handle (call mount daemon)  * Return zero or error number.  */
end_comment

begin_function
name|int
name|nfs_getrootfh
parameter_list|(
name|d
parameter_list|,
name|path
parameter_list|,
name|fhp
parameter_list|)
specifier|register
name|struct
name|iodesc
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|u_char
modifier|*
name|fhp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
struct|struct
name|args
block|{
name|n_long
name|len
decl_stmt|;
name|char
name|path
index|[
name|FNAME_SIZE
index|]
decl_stmt|;
block|}
modifier|*
name|args
struct|;
struct|struct
name|repl
block|{
name|n_long
name|errno
decl_stmt|;
name|u_char
name|fh
index|[
name|NFS_FHSIZE
index|]
decl_stmt|;
block|}
modifier|*
name|repl
struct|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|repl
name|d
decl_stmt|;
block|}
name|rdata
struct|;
name|size_t
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_getrootfh: %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|repl
operator|=
operator|&
name|rdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|args
operator|->
name|path
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|args
operator|->
name|path
argument_list|)
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|path
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
operator|+
name|roundup
argument_list|(
name|len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
argument_list|,
name|RPCPROG_MNT
argument_list|,
name|RPCMNT_VER1
argument_list|,
name|RPCMNT_MOUNT
argument_list|,
name|args
argument_list|,
name|len
argument_list|,
name|repl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|repl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* errno was set by rpc_call */
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|<
literal|4
condition|)
return|return
operator|(
name|EBADRPC
operator|)
return|;
if|if
condition|(
name|repl
operator|->
name|errno
condition|)
return|return
operator|(
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
operator|)
return|;
name|bcopy
argument_list|(
name|repl
operator|->
name|fh
argument_list|,
name|fhp
argument_list|,
sizeof|sizeof
argument_list|(
name|repl
operator|->
name|fh
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a file.  Store handle and attributes.  * Return zero or error number.  */
end_comment

begin_function
name|int
name|nfs_lookupfh
parameter_list|(
name|d
parameter_list|,
name|name
parameter_list|,
name|newfd
parameter_list|)
name|struct
name|nfs_iodesc
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|nfs_iodesc
modifier|*
name|newfd
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|rlen
decl_stmt|;
struct|struct
name|args
block|{
name|u_char
name|fh
index|[
name|NFS_FHSIZE
index|]
decl_stmt|;
name|n_long
name|len
decl_stmt|;
name|char
name|name
index|[
name|FNAME_SIZE
index|]
decl_stmt|;
block|}
modifier|*
name|args
struct|;
struct|struct
name|repl
block|{
name|n_long
name|errno
decl_stmt|;
name|u_char
name|fh
index|[
name|NFS_FHSIZE
index|]
decl_stmt|;
name|struct
name|nfsv2_fattrs
name|fa
decl_stmt|;
block|}
modifier|*
name|repl
struct|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|repl
name|d
decl_stmt|;
block|}
name|rdata
struct|;
name|ssize_t
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"lookupfh: called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|repl
operator|=
operator|&
name|rdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|d
operator|->
name|fh
argument_list|,
name|args
operator|->
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
name|args
operator|->
name|fh
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|args
operator|->
name|name
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|args
operator|->
name|name
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
operator|+
name|roundup
argument_list|(
name|len
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|+=
name|NFS_FHSIZE
expr_stmt|;
name|rlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|repl
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER2
argument_list|,
name|NFSPROC_LOOKUP
argument_list|,
name|args
argument_list|,
name|len
argument_list|,
name|repl
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX - from rpc_call */
if|if
condition|(
name|cc
operator|<
literal|4
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|repl
operator|->
name|errno
condition|)
block|{
comment|/* saerrno.h now matches NFS error numbers. */
return|return
operator|(
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|repl
operator|->
name|fh
argument_list|,
operator|&
name|newfd
operator|->
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
name|newfd
operator|->
name|fh
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|repl
operator|->
name|fa
argument_list|,
operator|&
name|newfd
operator|->
name|fa
argument_list|,
sizeof|sizeof
argument_list|(
name|newfd
operator|->
name|fa
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
end_ifndef

begin_comment
comment|/*  * Get the destination of a symbolic link.  */
end_comment

begin_function
name|int
name|nfs_readlink
parameter_list|(
name|d
parameter_list|,
name|buf
parameter_list|)
name|struct
name|nfs_iodesc
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|u_char
name|fh
index|[
name|NFS_FHSIZE
index|]
decl_stmt|;
block|}
name|sdata
struct|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|nfs_readlnk_repl
name|d
decl_stmt|;
block|}
name|rdata
struct|;
name|ssize_t
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"readlink: called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|d
operator|->
name|fh
argument_list|,
name|sdata
operator|.
name|fh
argument_list|,
name|NFS_FHSIZE
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER2
argument_list|,
name|NFSPROC_READLINK
argument_list|,
name|sdata
operator|.
name|fh
argument_list|,
name|NFS_FHSIZE
argument_list|,
operator|&
name|rdata
operator|.
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|rdata
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|cc
operator|<
literal|4
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|rdata
operator|.
name|d
operator|.
name|errno
condition|)
return|return
operator|(
name|ntohl
argument_list|(
name|rdata
operator|.
name|d
operator|.
name|errno
argument_list|)
operator|)
return|;
name|rdata
operator|.
name|d
operator|.
name|len
operator|=
name|ntohl
argument_list|(
name|rdata
operator|.
name|d
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|.
name|d
operator|.
name|len
operator|>
name|NFS_MAXPATHLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|bcopy
argument_list|(
name|rdata
operator|.
name|d
operator|.
name|path
argument_list|,
name|buf
argument_list|,
name|rdata
operator|.
name|d
operator|.
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|rdata
operator|.
name|d
operator|.
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read data from a file.  * Return transfer count or -1 (and set errno)  */
end_comment

begin_function
name|ssize_t
name|nfs_readdata
parameter_list|(
name|d
parameter_list|,
name|off
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|struct
name|nfs_iodesc
modifier|*
name|d
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|struct
name|nfs_read_args
modifier|*
name|args
decl_stmt|;
name|struct
name|nfs_read_repl
modifier|*
name|repl
decl_stmt|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|nfs_read_args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|nfs_read_repl
name|d
decl_stmt|;
block|}
name|rdata
struct|;
name|size_t
name|cc
decl_stmt|;
name|long
name|x
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|rlen
decl_stmt|;
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|repl
operator|=
operator|&
name|rdata
operator|.
name|d
expr_stmt|;
name|bcopy
argument_list|(
name|d
operator|->
name|fh
argument_list|,
name|args
operator|->
name|fh
argument_list|,
name|NFS_FHSIZE
argument_list|)
expr_stmt|;
name|args
operator|->
name|off
operator|=
name|htonl
argument_list|(
operator|(
name|n_long
operator|)
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NFSREAD_SIZE
condition|)
name|len
operator|=
name|NFSREAD_SIZE
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|htonl
argument_list|(
operator|(
name|n_long
operator|)
name|len
argument_list|)
expr_stmt|;
name|args
operator|->
name|xxx
operator|=
name|htonl
argument_list|(
operator|(
name|n_long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|repl
argument_list|)
operator|-
name|NFSREAD_SIZE
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER2
argument_list|,
name|NFSPROC_READ
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|repl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|repl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* errno was already set by rpc_call */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|<
name|hlen
condition|)
block|{
name|errno
operator|=
name|EBADRPC
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|repl
operator|->
name|errno
condition|)
block|{
name|errno
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rlen
operator|=
name|cc
operator|-
name|hlen
expr_stmt|;
name|x
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
name|x
condition|)
block|{
name|printf
argument_list|(
literal|"nfsread: short packet, %d< %ld\n"
argument_list|,
name|rlen
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADRPC
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|repl
operator|->
name|data
argument_list|,
name|addr
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a file.  * return zero or error number  */
end_comment

begin_function
name|int
name|nfs_open
parameter_list|(
name|upath
parameter_list|,
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|upath
decl_stmt|;
name|struct
name|open_file
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|iodesc
modifier|*
name|desc
decl_stmt|;
name|struct
name|nfs_iodesc
modifier|*
name|currfd
decl_stmt|;
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
name|struct
name|nfs_iodesc
modifier|*
name|newfd
decl_stmt|;
name|struct
name|nfsv2_fattrs
modifier|*
name|fa
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ncp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|namebuf
index|[
name|NFS_MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|linkbuf
index|[
name|NFS_MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|nlinks
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_open: %s (rootpath=%s)\n"
argument_list|,
name|path
argument_list|,
name|rootpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|rootpath
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"no rootpath, no nfs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|desc
operator|=
name|socktodesc
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|f
operator|->
name|f_devdata
operator|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Bind to a reserved port. */
name|desc
operator|->
name|myport
operator|=
name|htons
argument_list|(
operator|--
name|rpc_port
argument_list|)
expr_stmt|;
name|desc
operator|->
name|destip
operator|=
name|rootip
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|nfs_getrootfh
argument_list|(
name|desc
argument_list|,
name|rootpath
argument_list|,
name|nfs_root_node
operator|.
name|fh
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nfs_root_node
operator|.
name|iodesc
operator|=
name|desc
expr_stmt|;
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
comment|/* Fake up attributes for the root dir. */
name|fa
operator|=
operator|&
name|nfs_root_node
operator|.
name|fa
expr_stmt|;
name|fa
operator|->
name|fa_type
operator|=
name|htonl
argument_list|(
name|NFDIR
argument_list|)
expr_stmt|;
name|fa
operator|->
name|fa_mode
operator|=
name|htonl
argument_list|(
literal|0755
argument_list|)
expr_stmt|;
name|fa
operator|->
name|fa_nlink
operator|=
name|htonl
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|currfd
operator|=
operator|&
name|nfs_root_node
expr_stmt|;
name|newfd
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|path
operator|=
name|strdup
argument_list|(
name|upath
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* 		 * Remove extra separators 		 */
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* 		 * Check that current node is a directory. 		 */
if|if
condition|(
name|currfd
operator|->
name|fa
operator|.
name|fa_type
operator|!=
name|htonl
argument_list|(
name|NFDIR
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* allocate file system specific data structure */
name|newfd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newfd
argument_list|)
argument_list|)
expr_stmt|;
name|newfd
operator|->
name|iodesc
operator|=
name|currfd
operator|->
name|iodesc
expr_stmt|;
name|newfd
operator|->
name|off
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Get next component of path name. 		 */
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|ncp
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
operator|++
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* lookup a file handle */
name|error
operator|=
name|nfs_lookupfh
argument_list|(
name|currfd
argument_list|,
name|ncp
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Check for symbolic link 		 */
if|if
condition|(
name|newfd
operator|->
name|fa
operator|.
name|fa_type
operator|==
name|htonl
argument_list|(
name|NFLNK
argument_list|)
condition|)
block|{
name|int
name|link_len
decl_stmt|,
name|len
decl_stmt|;
name|error
operator|=
name|nfs_readlink
argument_list|(
name|newfd
argument_list|,
name|linkbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|link_len
operator|=
name|strlen
argument_list|(
name|linkbuf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_len
operator|+
name|len
operator|>
name|MAXPATHLEN
operator|||
operator|++
name|nlinks
operator|>
name|MAXSYMLINKS
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|namebuf
index|[
name|link_len
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|linkbuf
argument_list|,
name|namebuf
argument_list|,
name|link_len
argument_list|)
expr_stmt|;
comment|/* 			 * If absolute pathname, restart at root. 			 * If relative pathname, restart at parent directory. 			 */
name|cp
operator|=
name|namebuf
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|currfd
operator|!=
operator|&
name|nfs_root_node
condition|)
name|free
argument_list|(
name|currfd
argument_list|)
expr_stmt|;
name|currfd
operator|=
operator|&
name|nfs_root_node
expr_stmt|;
block|}
name|free
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|newfd
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|currfd
operator|!=
operator|&
name|nfs_root_node
condition|)
name|free
argument_list|(
name|currfd
argument_list|)
expr_stmt|;
name|currfd
operator|=
name|newfd
expr_stmt|;
name|newfd
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|newfd
condition|)
name|free
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* allocate file system specific data structure */
name|currfd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|currfd
argument_list|)
argument_list|)
expr_stmt|;
name|currfd
operator|->
name|iodesc
operator|=
name|desc
expr_stmt|;
name|currfd
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nfs_lookupfh
argument_list|(
operator|&
name|nfs_root_node
argument_list|,
name|upath
argument_list|,
name|currfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|f
operator|->
name|f_fsdata
operator|=
operator|(
name|void
operator|*
operator|)
name|currfd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_open: %s lookupfh failed: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
if|if
condition|(
name|currfd
operator|!=
operator|&
name|nfs_root_node
condition|)
endif|#
directive|endif
name|free
argument_list|(
name|currfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nfs_close
parameter_list|(
name|f
parameter_list|)
name|struct
name|open_file
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_close: fp=0x%lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|!=
operator|&
name|nfs_root_node
operator|&&
name|fp
condition|)
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|f
operator|->
name|f_fsdata
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * read a portion of a file  */
end_comment

begin_function
name|int
name|nfs_read
parameter_list|(
name|f
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|,
name|resid
parameter_list|)
name|struct
name|open_file
modifier|*
name|f
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
modifier|*
name|resid
decl_stmt|;
comment|/* out */
block|{
specifier|register
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
specifier|register
name|ssize_t
name|cc
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
init|=
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_read: size=%lu off=%d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|size
argument_list|,
operator|(
name|int
operator|)
name|fp
operator|->
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|int
operator|)
name|size
operator|>
literal|0
condition|)
block|{
name|twiddle
argument_list|()
expr_stmt|;
name|cc
operator|=
name|nfs_readdata
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|off
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* XXX maybe should retry on certain errors */
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_read: read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX - from nfs_readdata */
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_read: hit EOF unexpectantly"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
name|fp
operator|->
name|off
operator|+=
name|cc
expr_stmt|;
name|addr
operator|+=
name|cc
expr_stmt|;
name|size
operator|-=
name|cc
expr_stmt|;
block|}
name|ret
label|:
if|if
condition|(
name|resid
condition|)
operator|*
name|resid
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Not implemented.  */
end_comment

begin_function
name|int
name|nfs_write
parameter_list|(
name|f
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|,
name|resid
parameter_list|)
name|struct
name|open_file
modifier|*
name|f
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
modifier|*
name|resid
decl_stmt|;
comment|/* out */
block|{
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
name|off_t
name|nfs_seek
parameter_list|(
name|f
parameter_list|,
name|offset
parameter_list|,
name|where
parameter_list|)
name|struct
name|open_file
modifier|*
name|f
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
specifier|register
name|struct
name|nfs_iodesc
modifier|*
name|d
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
name|n_long
name|size
init|=
name|ntohl
argument_list|(
name|d
operator|->
name|fa
operator|.
name|fa_size
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|where
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|d
operator|->
name|off
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|d
operator|->
name|off
operator|+=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|d
operator|->
name|off
operator|=
name|size
operator|-
name|offset
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|d
operator|->
name|off
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NFNON=0, NFREG=1, NFDIR=2, NFBLK=3, NFCHR=4, NFLNK=5 */
end_comment

begin_decl_stmt
name|int
name|nfs_stat_types
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|S_IFREG
block|,
name|S_IFDIR
block|,
name|S_IFBLK
block|,
name|S_IFCHR
block|,
name|S_IFLNK
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|nfs_stat
parameter_list|(
name|f
parameter_list|,
name|sb
parameter_list|)
name|struct
name|open_file
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
modifier|*
name|sb
decl_stmt|;
block|{
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
specifier|register
name|n_long
name|ftype
decl_stmt|,
name|mode
decl_stmt|;
name|ftype
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_type
argument_list|)
expr_stmt|;
name|mode
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_mode
argument_list|)
expr_stmt|;
name|mode
operator||=
name|nfs_stat_types
index|[
name|ftype
operator|&
literal|7
index|]
expr_stmt|;
name|sb
operator|->
name|st_mode
operator|=
name|mode
expr_stmt|;
name|sb
operator|->
name|st_nlink
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_nlink
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_uid
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_uid
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_gid
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_gid
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_size
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_readdir
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|dirent
modifier|*
name|d
parameter_list|)
block|{
specifier|register
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
name|struct
name|nfs_readdir_args
modifier|*
name|args
decl_stmt|;
name|struct
name|nfs_readdir_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|nfs_readdir_off
modifier|*
name|roff
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|n_long
name|cookie
init|=
literal|0
decl_stmt|;
name|size_t
name|cc
decl_stmt|;
name|n_long
name|eof
decl_stmt|;
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|nfs_readdir_args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
specifier|static
struct|struct
block|{
name|n_long
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|u_char
name|d
index|[
name|NFS_READDIRSIZE
index|]
decl_stmt|;
block|}
name|rdata
struct|;
if|if
condition|(
name|cookie
operator|==
literal|0
condition|)
block|{
name|refill
label|:
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fp
operator|->
name|fh
argument_list|,
name|args
operator|->
name|fh
argument_list|,
name|NFS_FHSIZE
argument_list|)
expr_stmt|;
name|args
operator|->
name|cookie
operator|=
name|htonl
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|args
operator|->
name|count
operator|=
name|htonl
argument_list|(
name|NFS_READDIRSIZE
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|fp
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER2
argument_list|,
name|NFSPROC_READDIR
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|,
name|rdata
operator|.
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|rdata
operator|.
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|rdata
operator|.
name|d
expr_stmt|;
name|roff
operator|=
operator|(
expr|struct
name|nfs_readdir_off
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|roff
operator|->
name|cookie
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
block|}
name|roff
operator|=
operator|(
expr|struct
name|nfs_readdir_off
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|roff
operator|->
name|follows
argument_list|)
operator|==
literal|0
condition|)
block|{
name|eof
operator|=
name|ntohl
argument_list|(
operator|(
name|roff
operator|+
literal|1
operator|)
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|cookie
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
goto|goto
name|refill
goto|;
block|}
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nfs_readdir_off
argument_list|)
expr_stmt|;
name|rd
operator|=
operator|(
expr|struct
name|nfs_readdir_data
operator|*
operator|)
name|buf
expr_stmt|;
name|d
operator|->
name|d_namlen
operator|=
name|ntohl
argument_list|(
name|rd
operator|->
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rd
operator|->
name|name
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|d
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
name|d
operator|->
name|d_name
index|[
name|d
operator|->
name|d_namlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfs_readdir_data
argument_list|)
operator|+
name|roundup
argument_list|(
name|htonl
argument_list|(
name|rd
operator|->
name|len
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|)
expr_stmt|;
name|roff
operator|=
operator|(
expr|struct
name|nfs_readdir_off
operator|*
operator|)
name|buf
expr_stmt|;
name|cookie
operator|=
name|ntohl
argument_list|(
name|roff
operator|->
name|cookie
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

