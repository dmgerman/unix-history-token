begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: nfs.c,v 1.2 1998/01/24 12:43:09 drochner Exp $	*/
end_comment

begin_comment
comment|/*-  *  Copyright (c) 1993 John Brezak  *  All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|"rpcv2.h"
end_include

begin_include
include|#
directive|include
file|"nfsv2.h"
end_include

begin_include
include|#
directive|include
file|"stand.h"
end_include

begin_include
include|#
directive|include
file|"net.h"
end_include

begin_include
include|#
directive|include
file|"netif.h"
end_include

begin_include
include|#
directive|include
file|"rpc.h"
end_include

begin_define
define|#
directive|define
name|NFS_DEBUGxx
end_define

begin_define
define|#
directive|define
name|NFSREAD_MIN_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|NFSREAD_MAX_SIZE
value|4096
end_define

begin_comment
comment|/* NFSv3 definitions */
end_comment

begin_define
define|#
directive|define
name|NFS_V3MAXFHSIZE
value|64
end_define

begin_define
define|#
directive|define
name|NFS_VER3
value|3
end_define

begin_define
define|#
directive|define
name|RPCMNT_VER3
value|3
end_define

begin_define
define|#
directive|define
name|NFSPROCV3_LOOKUP
value|3
end_define

begin_define
define|#
directive|define
name|NFSPROCV3_READLINK
value|5
end_define

begin_define
define|#
directive|define
name|NFSPROCV3_READ
value|6
end_define

begin_define
define|#
directive|define
name|NFSPROCV3_READDIR
value|16
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|val
index|[
literal|2
index|]
decl_stmt|;
block|}
name|n_quad
typedef|;
end_typedef

begin_struct
struct|struct
name|nfsv3_time
block|{
name|uint32_t
name|nfs_sec
decl_stmt|;
name|uint32_t
name|nfs_nsec
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nfsv3_fattrs
block|{
name|uint32_t
name|fa_type
decl_stmt|;
name|uint32_t
name|fa_mode
decl_stmt|;
name|uint32_t
name|fa_nlink
decl_stmt|;
name|uint32_t
name|fa_uid
decl_stmt|;
name|uint32_t
name|fa_gid
decl_stmt|;
name|n_quad
name|fa_size
decl_stmt|;
name|n_quad
name|fa_used
decl_stmt|;
name|n_quad
name|fa_rdev
decl_stmt|;
name|n_quad
name|fa_fsid
decl_stmt|;
name|n_quad
name|fa_fileid
decl_stmt|;
name|struct
name|nfsv3_time
name|fa_atime
decl_stmt|;
name|struct
name|nfsv3_time
name|fa_mtime
decl_stmt|;
name|struct
name|nfsv3_time
name|fa_ctime
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * For NFSv3, the file handle is variable in size, so most fixed sized  * structures for arguments won't work. For most cases, a structure  * that starts with any fixed size section is followed by an array  * that covers the maximum size required.  */
end_comment

begin_struct
struct|struct
name|nfsv3_readdir_repl
block|{
name|uint32_t
name|errno
decl_stmt|;
name|uint32_t
name|ok
decl_stmt|;
name|struct
name|nfsv3_fattrs
name|fa
decl_stmt|;
name|uint32_t
name|cookiev0
decl_stmt|;
name|uint32_t
name|cookiev1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nfsv3_readdir_entry
block|{
name|uint32_t
name|follows
decl_stmt|;
name|uint32_t
name|fid0
decl_stmt|;
name|uint32_t
name|fid1
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|nameplus
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nfs_iodesc
block|{
name|struct
name|iodesc
modifier|*
name|iodesc
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|uint32_t
name|fhsize
decl_stmt|;
name|u_char
name|fh
index|[
name|NFS_V3MAXFHSIZE
index|]
decl_stmt|;
name|struct
name|nfsv3_fattrs
name|fa
decl_stmt|;
comment|/* all in network order */
name|uint64_t
name|cookie
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX interactions with tftp? See nfswrapper.c for a confusing  *     issue.  */
end_comment

begin_function_decl
name|int
name|nfs_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_read
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_write
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|nfs_seek
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|where
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_stat
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_readdir
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|dirent
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|nfs_iodesc
name|nfs_root_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs_ops
name|nfs_fsops
init|=
block|{
literal|"nfs"
block|,
name|nfs_open
block|,
name|nfs_close
block|,
name|nfs_read
block|,
name|nfs_write
block|,
name|nfs_seek
block|,
name|nfs_stat
block|,
name|nfs_readdir
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_read_size
init|=
name|NFSREAD_MIN_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Improve boot performance over NFS  */
end_comment

begin_function
specifier|static
name|void
name|set_nfs_read_size
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"nfs.read_size"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|nfs_read_size
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|env
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|env
operator|==
literal|'\0'
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad value: \"%s\", defaulting to %d\n"
argument_list|,
literal|"nfs.read_size"
argument_list|,
name|env
argument_list|,
name|NFSREAD_MIN_SIZE
argument_list|)
expr_stmt|;
name|nfs_read_size
operator|=
name|NFSREAD_MIN_SIZE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfs_read_size
operator|<
name|NFSREAD_MIN_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad value: \"%d\", defaulting to %d\n"
argument_list|,
literal|"nfs.read_size"
argument_list|,
name|nfs_read_size
argument_list|,
name|NFSREAD_MIN_SIZE
argument_list|)
expr_stmt|;
name|nfs_read_size
operator|=
name|NFSREAD_MIN_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|nfs_read_size
operator|>
name|NFSREAD_MAX_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad value: \"%d\", defaulting to %d\n"
argument_list|,
literal|"nfs.read_size"
argument_list|,
name|nfs_read_size
argument_list|,
name|NFSREAD_MIN_SIZE
argument_list|)
expr_stmt|;
name|nfs_read_size
operator|=
name|NFSREAD_MAX_SIZE
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|nfs_read_size
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"nfs.read_size"
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch the root file handle (call mount daemon)  * Return zero or error number.  */
end_comment

begin_function
name|int
name|nfs_getrootfh
parameter_list|(
name|struct
name|iodesc
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|uint32_t
modifier|*
name|fhlenp
parameter_list|,
name|u_char
modifier|*
name|fhp
parameter_list|)
block|{
name|void
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
struct|struct
name|args
block|{
name|uint32_t
name|len
decl_stmt|;
name|char
name|path
index|[
name|FNAME_SIZE
index|]
decl_stmt|;
block|}
modifier|*
name|args
struct|;
struct|struct
name|repl
block|{
name|uint32_t
name|errno
decl_stmt|;
name|uint32_t
name|fhsize
decl_stmt|;
name|u_char
name|fh
index|[
name|NFS_V3MAXFHSIZE
index|]
decl_stmt|;
name|uint32_t
name|authcnt
decl_stmt|;
name|uint32_t
name|auth
index|[
literal|7
index|]
decl_stmt|;
block|}
modifier|*
name|repl
struct|;
struct|struct
block|{
name|uint32_t
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
name|size_t
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_getrootfh: %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|args
operator|->
name|path
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|args
operator|->
name|path
argument_list|)
expr_stmt|;
name|args
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|path
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|roundup
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
argument_list|,
name|RPCPROG_MNT
argument_list|,
name|RPCMNT_VER3
argument_list|,
name|RPCMNT_MOUNT
argument_list|,
name|args
argument_list|,
name|len
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|repl
argument_list|,
operator|&
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* errno was set by rpc_call */
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADRPC
operator|)
return|;
block|}
if|if
condition|(
name|repl
operator|->
name|errno
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
operator|)
return|;
block|}
operator|*
name|fhlenp
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|repl
operator|->
name|fh
argument_list|,
name|fhp
argument_list|,
operator|*
name|fhlenp
argument_list|)
expr_stmt|;
name|set_nfs_read_size
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a file.  Store handle and attributes.  * Return zero or error number.  */
end_comment

begin_function
name|int
name|nfs_lookupfh
parameter_list|(
name|struct
name|nfs_iodesc
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|nfs_iodesc
modifier|*
name|newfd
parameter_list|)
block|{
name|void
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rlen
decl_stmt|,
name|pos
decl_stmt|;
struct|struct
name|args
block|{
name|uint32_t
name|fhsize
decl_stmt|;
name|uint32_t
name|fhplusname
index|[
literal|1
operator|+
operator|(
name|NFS_V3MAXFHSIZE
operator|+
name|FNAME_SIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
decl_stmt|;
block|}
modifier|*
name|args
struct|;
struct|struct
name|repl
block|{
name|uint32_t
name|errno
decl_stmt|;
name|uint32_t
name|fhsize
decl_stmt|;
name|uint32_t
name|fhplusattr
index|[
operator|(
name|NFS_V3MAXFHSIZE
operator|+
literal|2
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nfsv3_fattrs
argument_list|)
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
decl_stmt|;
block|}
modifier|*
name|repl
struct|;
struct|struct
block|{
name|uint32_t
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
name|ssize_t
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"lookupfh: called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhsize
operator|=
name|htonl
argument_list|(
name|d
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|d
operator|->
name|fh
argument_list|,
name|args
operator|->
name|fhplusname
argument_list|,
name|d
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|FNAME_SIZE
condition|)
name|len
operator|=
name|FNAME_SIZE
expr_stmt|;
name|pos
operator|=
name|roundup
argument_list|(
name|d
operator|->
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhplusname
index|[
name|pos
operator|++
index|]
operator|=
name|htonl
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|&
name|args
operator|->
name|fhplusname
index|[
name|pos
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|pos
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|roundup
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER3
argument_list|,
name|NFSPROCV3_LOOKUP
argument_list|,
name|args
argument_list|,
name|len
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|repl
argument_list|,
operator|&
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX - from rpc_call */
block|}
if|if
condition|(
name|cc
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|repl
operator|->
name|errno
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* saerrno.h now matches NFS error numbers. */
return|return
operator|(
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
operator|)
return|;
block|}
name|newfd
operator|->
name|fhsize
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|repl
operator|->
name|fhplusattr
argument_list|,
operator|&
name|newfd
operator|->
name|fh
argument_list|,
name|newfd
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|pos
operator|=
name|roundup
argument_list|(
name|newfd
operator|->
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl
operator|->
name|fhplusattr
index|[
name|pos
operator|++
index|]
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|repl
operator|->
name|fhplusattr
index|[
name|pos
index|]
argument_list|,
operator|&
name|newfd
operator|->
name|fa
argument_list|,
sizeof|sizeof
argument_list|(
name|newfd
operator|->
name|fa
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
end_ifndef

begin_comment
comment|/*  * Get the destination of a symbolic link.  */
end_comment

begin_function
name|int
name|nfs_readlink
parameter_list|(
name|struct
name|nfs_iodesc
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|void
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
struct|struct
name|args
block|{
name|uint32_t
name|fhsize
decl_stmt|;
name|u_char
name|fh
index|[
name|NFS_V3MAXFHSIZE
index|]
decl_stmt|;
block|}
modifier|*
name|args
struct|;
struct|struct
name|repl
block|{
name|uint32_t
name|errno
decl_stmt|;
name|uint32_t
name|ok
decl_stmt|;
name|struct
name|nfsv3_fattrs
name|fa
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|u_char
name|path
index|[
name|NFS_MAXPATHLEN
index|]
decl_stmt|;
block|}
modifier|*
name|repl
struct|;
struct|struct
block|{
name|uint32_t
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
name|ssize_t
name|cc
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"readlink: called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhsize
operator|=
name|htonl
argument_list|(
name|d
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|d
operator|->
name|fh
argument_list|,
name|args
operator|->
name|fh
argument_list|,
name|d
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER3
argument_list|,
name|NFSPROCV3_READLINK
argument_list|,
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|roundup
argument_list|(
name|d
operator|->
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|repl
argument_list|,
operator|&
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|cc
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|repl
operator|->
name|errno
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|repl
operator|->
name|ok
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|repl
operator|->
name|len
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl
operator|->
name|len
operator|>
name|NFS_MAXPATHLEN
condition|)
block|{
name|rc
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bcopy
argument_list|(
name|repl
operator|->
name|path
argument_list|,
name|buf
argument_list|,
name|repl
operator|->
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|repl
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read data from a file.  * Return transfer count or -1 (and set errno)  */
end_comment

begin_function
name|ssize_t
name|nfs_readdata
parameter_list|(
name|struct
name|nfs_iodesc
modifier|*
name|d
parameter_list|,
name|off_t
name|off
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|void
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
struct|struct
name|args
block|{
name|uint32_t
name|fhsize
decl_stmt|;
name|uint32_t
name|fhoffcnt
index|[
name|NFS_V3MAXFHSIZE
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|3
index|]
decl_stmt|;
block|}
modifier|*
name|args
struct|;
struct|struct
name|repl
block|{
name|uint32_t
name|errno
decl_stmt|;
name|uint32_t
name|ok
decl_stmt|;
name|struct
name|nfsv3_fattrs
name|fa
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|uint32_t
name|eof
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|u_char
name|data
index|[
name|NFSREAD_MAX_SIZE
index|]
decl_stmt|;
block|}
modifier|*
name|repl
struct|;
struct|struct
block|{
name|uint32_t
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
name|size_t
name|cc
decl_stmt|;
name|long
name|x
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|rlen
decl_stmt|,
name|pos
decl_stmt|;
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhsize
operator|=
name|htonl
argument_list|(
name|d
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|d
operator|->
name|fh
argument_list|,
name|args
operator|->
name|fhoffcnt
argument_list|,
name|d
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|pos
operator|=
name|roundup
argument_list|(
name|d
operator|->
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhoffcnt
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|fhoffcnt
index|[
name|pos
operator|++
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|uint32_t
operator|)
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|nfs_read_size
condition|)
name|len
operator|=
name|nfs_read_size
expr_stmt|;
name|args
operator|->
name|fhoffcnt
index|[
name|pos
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|uint32_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|offsetof
argument_list|(
expr|struct
name|repl
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|d
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER3
argument_list|,
name|NFSPROCV3_READ
argument_list|,
name|args
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|roundup
argument_list|(
name|d
operator|->
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|repl
argument_list|,
operator|&
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* errno was already set by rpc_call */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|<
name|hlen
condition|)
block|{
name|errno
operator|=
name|EBADRPC
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|repl
operator|->
name|errno
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rlen
operator|=
name|cc
operator|-
name|hlen
expr_stmt|;
name|x
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
name|x
condition|)
block|{
name|printf
argument_list|(
literal|"nfsread: short packet, %d< %ld\n"
argument_list|,
name|rlen
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADRPC
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|repl
operator|->
name|data
argument_list|,
name|addr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a file.  * return zero or error number  */
end_comment

begin_function
name|int
name|nfs_open
parameter_list|(
specifier|const
name|char
modifier|*
name|upath
parameter_list|,
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|iodesc
modifier|*
name|desc
decl_stmt|;
name|struct
name|nfs_iodesc
modifier|*
name|currfd
decl_stmt|;
name|char
name|buf
index|[
literal|2
operator|*
name|NFS_V3MAXFHSIZE
operator|+
literal|3
index|]
decl_stmt|;
name|u_char
modifier|*
name|fh
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
name|struct
name|nfs_iodesc
modifier|*
name|newfd
decl_stmt|;
name|struct
name|nfsv3_fattrs
modifier|*
name|fa
decl_stmt|;
name|char
modifier|*
name|ncp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|namebuf
index|[
name|NFS_MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|linkbuf
index|[
name|NFS_MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|nlinks
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|netproto
operator|!=
name|NET_NFS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_open: %s (rootpath=%s)\n"
argument_list|,
name|upath
argument_list|,
name|rootpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|rootpath
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"no rootpath, no nfs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|f
operator|->
name|f_dev
operator|->
name|dv_type
operator|!=
name|DEVT_NET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|=
name|socktodesc
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|f
operator|->
name|f_devdata
operator|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Bind to a reserved port. */
name|desc
operator|->
name|myport
operator|=
name|htons
argument_list|(
operator|--
name|rpc_port
argument_list|)
expr_stmt|;
name|desc
operator|->
name|destip
operator|=
name|rootip
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|nfs_getrootfh
argument_list|(
name|desc
argument_list|,
name|rootpath
argument_list|,
operator|&
name|nfs_root_node
operator|.
name|fhsize
argument_list|,
name|nfs_root_node
operator|.
name|fh
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nfs_root_node
operator|.
name|fa
operator|.
name|fa_type
operator|=
name|htonl
argument_list|(
name|NFDIR
argument_list|)
expr_stmt|;
name|nfs_root_node
operator|.
name|fa
operator|.
name|fa_mode
operator|=
name|htonl
argument_list|(
literal|0755
argument_list|)
expr_stmt|;
name|nfs_root_node
operator|.
name|fa
operator|.
name|fa_nlink
operator|=
name|htonl
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|nfs_root_node
operator|.
name|iodesc
operator|=
name|desc
expr_stmt|;
name|fh
operator|=
operator|&
name|nfs_root_node
operator|.
name|fh
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'X'
expr_stmt|;
name|cp
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfs_root_node
operator|.
name|fhsize
condition|;
name|i
operator|++
operator|,
name|cp
operator|+=
literal|2
control|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%02x"
argument_list|,
name|fh
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"boot.nfsroot.server"
argument_list|,
name|inet_ntoa
argument_list|(
name|rootip
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"boot.nfsroot.path"
argument_list|,
name|rootpath
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"boot.nfsroot.nfshandle"
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|nfs_root_node
operator|.
name|fhsize
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"boot.nfsroot.nfshandlelen"
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate file system specific data structure */
name|currfd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|currfd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifndef|#
directive|ifndef
name|NFS_NOSYMLINK
name|bcopy
argument_list|(
operator|&
name|nfs_root_node
argument_list|,
name|currfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|currfd
argument_list|)
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|path
operator|=
name|strdup
argument_list|(
name|upath
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* 		 * Remove extra separators 		 */
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* 		 * Check that current node is a directory. 		 */
if|if
condition|(
name|currfd
operator|->
name|fa
operator|.
name|fa_type
operator|!=
name|htonl
argument_list|(
name|NFDIR
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* allocate file system specific data structure */
name|newfd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|newfd
operator|->
name|iodesc
operator|=
name|currfd
operator|->
name|iodesc
expr_stmt|;
comment|/* 		 * Get next component of path name. 		 */
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|ncp
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
operator|++
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* lookup a file handle */
name|error
operator|=
name|nfs_lookupfh
argument_list|(
name|currfd
argument_list|,
name|ncp
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Check for symbolic link 		 */
if|if
condition|(
name|newfd
operator|->
name|fa
operator|.
name|fa_type
operator|==
name|htonl
argument_list|(
name|NFLNK
argument_list|)
condition|)
block|{
name|int
name|link_len
decl_stmt|,
name|len
decl_stmt|;
name|error
operator|=
name|nfs_readlink
argument_list|(
name|newfd
argument_list|,
name|linkbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|link_len
operator|=
name|strlen
argument_list|(
name|linkbuf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_len
operator|+
name|len
operator|>
name|MAXPATHLEN
operator|||
operator|++
name|nlinks
operator|>
name|MAXSYMLINKS
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|&
name|namebuf
index|[
name|link_len
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|linkbuf
argument_list|,
name|namebuf
argument_list|,
name|link_len
argument_list|)
expr_stmt|;
comment|/* 			 * If absolute pathname, restart at root. 			 * If relative pathname, restart at parent directory. 			 */
name|cp
operator|=
name|namebuf
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|bcopy
argument_list|(
operator|&
name|nfs_root_node
argument_list|,
name|currfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|currfd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|currfd
argument_list|)
expr_stmt|;
name|currfd
operator|=
name|newfd
expr_stmt|;
name|newfd
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
else|#
directive|else
name|currfd
operator|->
name|iodesc
operator|=
name|desc
expr_stmt|;
name|error
operator|=
name|nfs_lookupfh
argument_list|(
operator|&
name|nfs_root_node
argument_list|,
name|upath
argument_list|,
name|currfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|currfd
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|currfd
operator|->
name|cookie
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|f_fsdata
operator|=
operator|(
name|void
operator|*
operator|)
name|currfd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_open: %s lookupfh failed: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|currfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nfs_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_close: fp=0x%lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|f
operator|->
name|f_fsdata
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * read a portion of a file  */
end_comment

begin_function
name|int
name|nfs_read
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
block|{
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
name|ssize_t
name|cc
decl_stmt|;
name|char
modifier|*
name|addr
init|=
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_read: size=%lu off=%d\n"
argument_list|,
operator|(
name|u_long
operator|)
name|size
argument_list|,
operator|(
name|int
operator|)
name|fp
operator|->
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|int
operator|)
name|size
operator|>
literal|0
condition|)
block|{
name|twiddle
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|cc
operator|=
name|nfs_readdata
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|off
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* XXX maybe should retry on certain errors */
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_read: read: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|errno
operator|)
return|;
comment|/* XXX - from nfs_readdata */
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NFS_DEBUG
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"nfs_read: hit EOF unexpectantly"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
name|fp
operator|->
name|off
operator|+=
name|cc
expr_stmt|;
name|addr
operator|+=
name|cc
expr_stmt|;
name|size
operator|-=
name|cc
expr_stmt|;
block|}
name|ret
label|:
if|if
condition|(
name|resid
condition|)
operator|*
name|resid
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Not implemented.  */
end_comment

begin_function
name|int
name|nfs_write
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
block|{
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
name|off_t
name|nfs_seek
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|struct
name|nfs_iodesc
modifier|*
name|d
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
name|uint32_t
name|size
init|=
name|ntohl
argument_list|(
name|d
operator|->
name|fa
operator|.
name|fa_size
operator|.
name|val
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|where
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|d
operator|->
name|off
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|d
operator|->
name|off
operator|+=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|d
operator|->
name|off
operator|=
name|size
operator|-
name|offset
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|d
operator|->
name|off
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NFNON=0, NFREG=1, NFDIR=2, NFBLK=3, NFCHR=4, NFLNK=5, NFSOCK=6, NFFIFO=7 */
end_comment

begin_decl_stmt
name|int
name|nfs_stat_types
index|[
literal|9
index|]
init|=
block|{
literal|0
block|,
name|S_IFREG
block|,
name|S_IFDIR
block|,
name|S_IFBLK
block|,
name|S_IFCHR
block|,
name|S_IFLNK
block|,
name|S_IFSOCK
block|,
name|S_IFIFO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|nfs_stat
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
name|uint32_t
name|ftype
decl_stmt|,
name|mode
decl_stmt|;
name|ftype
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_type
argument_list|)
expr_stmt|;
name|mode
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_mode
argument_list|)
expr_stmt|;
name|mode
operator||=
name|nfs_stat_types
index|[
name|ftype
operator|&
literal|7
index|]
expr_stmt|;
name|sb
operator|->
name|st_mode
operator|=
name|mode
expr_stmt|;
name|sb
operator|->
name|st_nlink
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_nlink
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_uid
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_uid
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_gid
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_gid
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_size
operator|=
name|ntohl
argument_list|(
name|fp
operator|->
name|fa
operator|.
name|fa_size
operator|.
name|val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_readdir
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|dirent
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|nfs_iodesc
modifier|*
name|fp
init|=
operator|(
expr|struct
name|nfs_iodesc
operator|*
operator|)
name|f
operator|->
name|f_fsdata
decl_stmt|;
name|struct
name|nfsv3_readdir_repl
modifier|*
name|repl
decl_stmt|;
name|struct
name|nfsv3_readdir_entry
modifier|*
name|rent
decl_stmt|;
specifier|static
name|void
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|struct
name|nfs_iodesc
modifier|*
name|pfp
init|=
name|NULL
decl_stmt|;
specifier|static
name|uint64_t
name|cookie
init|=
literal|0
decl_stmt|;
name|size_t
name|cc
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|rc
decl_stmt|;
struct|struct
name|args
block|{
name|uint32_t
name|fhsize
decl_stmt|;
name|uint32_t
name|fhpluscookie
index|[
literal|5
operator|+
name|NFS_V3MAXFHSIZE
index|]
decl_stmt|;
block|}
modifier|*
name|args
struct|;
struct|struct
block|{
name|uint32_t
name|h
index|[
name|RPC_HEADER_WORDS
index|]
decl_stmt|;
name|struct
name|args
name|d
decl_stmt|;
block|}
name|sdata
struct|;
if|if
condition|(
name|fp
operator|!=
name|pfp
operator|||
name|fp
operator|->
name|off
operator|!=
name|cookie
condition|)
block|{
name|pfp
operator|=
name|NULL
expr_stmt|;
name|refill
label|:
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|NULL
expr_stmt|;
name|args
operator|=
operator|&
name|sdata
operator|.
name|d
expr_stmt|;
name|bzero
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhsize
operator|=
name|htonl
argument_list|(
name|fp
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fp
operator|->
name|fh
argument_list|,
name|args
operator|->
name|fhpluscookie
argument_list|,
name|fp
operator|->
name|fhsize
argument_list|)
expr_stmt|;
name|pos
operator|=
name|roundup
argument_list|(
name|fp
operator|->
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhpluscookie
index|[
name|pos
operator|++
index|]
operator|=
name|htonl
argument_list|(
name|fp
operator|->
name|off
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhpluscookie
index|[
name|pos
operator|++
index|]
operator|=
name|htonl
argument_list|(
name|fp
operator|->
name|off
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhpluscookie
index|[
name|pos
operator|++
index|]
operator|=
name|htonl
argument_list|(
name|fp
operator|->
name|cookie
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhpluscookie
index|[
name|pos
operator|++
index|]
operator|=
name|htonl
argument_list|(
name|fp
operator|->
name|cookie
argument_list|)
expr_stmt|;
name|args
operator|->
name|fhpluscookie
index|[
name|pos
index|]
operator|=
name|htonl
argument_list|(
name|NFS_READDIRSIZE
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rpc_call
argument_list|(
name|fp
operator|->
name|iodesc
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER3
argument_list|,
name|NFSPROCV3_READDIR
argument_list|,
name|args
argument_list|,
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|roundup
argument_list|(
name|fp
operator|->
name|fhsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
name|rc
operator|=
name|errno
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|repl
operator|=
operator|(
expr|struct
name|nfsv3_readdir_repl
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|repl
operator|->
name|errno
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|ntohl
argument_list|(
name|repl
operator|->
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|pfp
operator|=
name|fp
expr_stmt|;
name|cookie
operator|=
name|fp
operator|->
name|off
expr_stmt|;
name|fp
operator|->
name|cookie
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|ntohl
argument_list|(
name|repl
operator|->
name|cookiev0
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|ntohl
argument_list|(
name|repl
operator|->
name|cookiev1
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nfsv3_readdir_repl
argument_list|)
expr_stmt|;
block|}
name|rent
operator|=
operator|(
expr|struct
name|nfsv3_readdir_entry
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|rent
operator|->
name|follows
operator|==
literal|0
condition|)
block|{
comment|/* fid0 is actually eof */
if|if
condition|(
name|rent
operator|->
name|fid0
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
goto|goto
name|refill
goto|;
block|}
name|d
operator|->
name|d_namlen
operator|=
name|ntohl
argument_list|(
name|rent
operator|->
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rent
operator|->
name|nameplus
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|d
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
name|d
operator|->
name|d_name
index|[
name|d
operator|->
name|d_namlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pos
operator|=
name|roundup
argument_list|(
name|d
operator|->
name|d_namlen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|fp
operator|->
name|off
operator|=
name|cookie
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|ntohl
argument_list|(
name|rent
operator|->
name|nameplus
index|[
name|pos
index|]
argument_list|)
operator|<<
literal|32
operator|)
operator||
name|ntohl
argument_list|(
name|rent
operator|->
name|nameplus
index|[
name|pos
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rent
operator|->
name|nameplus
index|[
name|pos
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|NULL
expr_stmt|;
name|pfp
operator|=
name|NULL
expr_stmt|;
name|cookie
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

