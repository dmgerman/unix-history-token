begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This module derived from code donated to the FreeBSD Project by   * Matthew Dillon<dillon@backplane.com>  *  * Copyright (c) 1998 The FreeBSD Project  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * LIB/MEMORY/ZALLOC.C	- self contained low-overhead memory pool/allocation   *			  subsystem  *  *	This subsystem implements memory pools and memory allocation   *	routines.  *  *	Pools are managed via a linked list of 'free' areas.  Allocating  *	memory creates holes in the freelist, freeing memory fills them.  *	Since the freelist consists only of free memory areas, it is possible  *	to allocate the entire pool without incuring any structural overhead.  *  *	The system works best when allocating similarly-sized chunks of  *	memory.  Care must be taken to avoid fragmentation when   *	allocating/deallocating dissimilar chunks.  *  *	When a memory pool is first allocated, the entire pool is marked as  *	allocated.  This is done mainly because we do not want to modify any  *	portion of a pool's data area until we are given permission.  The  *	caller must explicitly deallocate portions of the pool to make them  *	available.  *  *	z[n]xalloc() works like z[n]alloc() but the allocation is made from  *	within the specified address range.  If the segment could not be   *	allocated, NULL is returned.  WARNING!  The address range will be  *	aligned to an 8 or 16 byte boundry depending on the cpu so if you  *	give an unaligned address range, unexpected results may occur.  *  *	If a standard allocation fails, the reclaim function will be called  *	to recover some space.  This usually causes other portions of the  *	same pool to be released.  Memory allocations at this low level  *	should not block but you can do that too in your reclaim function  *	if you want.  Reclaim does not function when z[n]xalloc() is used,  *	only for z[n]alloc().  *  *	Allocation and frees of 0 bytes are valid operations.  */
end_comment

begin_include
include|#
directive|include
file|"zalloc_defs.h"
end_include

begin_comment
comment|/*  * znalloc() -	allocate memory (without zeroing) from pool.  Call reclaim  *		and retry if appropriate, return NULL if unable to allocate  *		memory.  */
end_comment

begin_function
name|void
modifier|*
name|znalloc
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
comment|/*      * align according to pool object size (can be 0).  This is      * inclusive of the MEMNODE_SIZE_MASK minimum alignment.      *      */
name|bytes
operator|=
operator|(
name|bytes
operator|+
name|MEMNODE_SIZE_MASK
operator|)
operator|&
operator|~
name|MEMNODE_SIZE_MASK
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
comment|/*      * locate freelist entry big enough to hold the object.  If all objects      * are the same size, this is a constant-time function.      */
if|if
condition|(
name|bytes
operator|<=
name|mp
operator|->
name|mp_Size
operator|-
name|mp
operator|->
name|mp_Used
condition|)
block|{
name|MemNode
modifier|*
modifier|*
name|pmn
decl_stmt|;
name|MemNode
modifier|*
name|mn
decl_stmt|;
for|for
control|(
name|pmn
operator|=
operator|&
name|mp
operator|->
name|mp_First
init|;
operator|(
name|mn
operator|=
operator|*
name|pmn
operator|)
operator|!=
name|NULL
condition|;
name|pmn
operator|=
operator|&
name|mn
operator|->
name|mr_Next
control|)
block|{
if|if
condition|(
name|bytes
operator|>
name|mn
operator|->
name|mr_Bytes
condition|)
continue|continue;
comment|/* 	     *  Cut a chunk of memory out of the beginning of this 	     *  block and fixup the link appropriately. 	     */
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|mn
decl_stmt|;
if|if
condition|(
name|mn
operator|->
name|mr_Bytes
operator|==
name|bytes
condition|)
block|{
operator|*
name|pmn
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
block|}
else|else
block|{
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|bytes
operator|)
expr_stmt|;
name|mn
operator|->
name|mr_Next
operator|=
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
expr_stmt|;
name|mn
operator|->
name|mr_Bytes
operator|=
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|-
name|bytes
expr_stmt|;
operator|*
name|pmn
operator|=
name|mn
expr_stmt|;
block|}
name|mp
operator|->
name|mp_Used
operator|+=
name|bytes
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
block|}
block|}
comment|/*      * Memory pool is full, return NULL.      */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfree() - free previously allocated memory  */
end_comment

begin_function
name|void
name|zfree
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
comment|/*      * align according to pool object size (can be 0).  This is      * inclusive of the MEMNODE_SIZE_MASK minimum alignment.      */
name|bytes
operator|=
operator|(
name|bytes
operator|+
name|MEMNODE_SIZE_MASK
operator|)
operator|&
operator|~
name|MEMNODE_SIZE_MASK
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
return|return;
comment|/*      * panic if illegal pointer      */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
operator|||
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|bytes
operator|>
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_End
operator|||
operator|(
operator|(
name|iaddr_t
operator|)
name|ptr
operator|&
name|MEMNODE_SIZE_MASK
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"zfree(%p,%d): wild pointer"
argument_list|,
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/*      * free the segment      */
block|{
name|MemNode
modifier|*
modifier|*
name|pmn
decl_stmt|;
name|MemNode
modifier|*
name|mn
decl_stmt|;
name|mp
operator|->
name|mp_Used
operator|-=
name|bytes
expr_stmt|;
for|for
control|(
name|pmn
operator|=
operator|&
name|mp
operator|->
name|mp_First
init|;
operator|(
name|mn
operator|=
operator|*
name|pmn
operator|)
operator|!=
name|NULL
condition|;
name|pmn
operator|=
operator|&
name|mn
operator|->
name|mr_Next
control|)
block|{
comment|/* 	     * If area between last node and current node 	     *  - check range 	     *  - check merge with next area 	     *  - check merge with previous area 	     */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<=
operator|(
name|char
operator|*
operator|)
name|mn
condition|)
block|{
comment|/* 		 * range check 		 */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|bytes
operator|>
operator|(
name|char
operator|*
operator|)
name|mn
condition|)
name|panic
argument_list|(
literal|"zfree(%p,%d): corrupt memlist1"
argument_list|,
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/* 		 * merge against next area or create independant area 		 */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|bytes
operator|==
operator|(
name|char
operator|*
operator|)
name|mn
condition|)
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|=
name|bytes
operator|+
name|mn
operator|->
name|mr_Bytes
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
operator|=
name|mn
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|=
name|bytes
expr_stmt|;
block|}
operator|*
name|pmn
operator|=
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* 		 * merge against previous area (if there is a previous 		 * area). 		 */
if|if
condition|(
name|pmn
operator|!=
operator|&
name|mp
operator|->
name|mp_First
condition|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|pmn
operator|+
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|==
operator|(
name|char
operator|*
operator|)
name|ptr
condition|)
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Next
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|+=
name|mn
operator|->
name|mr_Bytes
expr_stmt|;
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|pmn
expr_stmt|;
block|}
block|}
return|return;
comment|/* NOT REACHED */
block|}
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|mn
operator|->
name|mr_Bytes
condition|)
name|panic
argument_list|(
literal|"zfree(%p,%d): corrupt memlist2"
argument_list|,
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We are beyond the last MemNode, append new MemNode.  Merge against 	 * previous area if possible. 	 */
if|if
condition|(
name|pmn
operator|==
operator|&
name|mp
operator|->
name|mp_First
operator|||
operator|(
name|char
operator|*
operator|)
name|pmn
operator|+
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|!=
operator|(
name|char
operator|*
operator|)
name|ptr
condition|)
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|=
name|bytes
expr_stmt|;
operator|*
name|pmn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|ptr
expr_stmt|;
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|+=
name|bytes
expr_stmt|;
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|pmn
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * zextendPool() - extend memory pool to cover additional space.  *  *		   Note: the added memory starts out as allocated, you  *		   must free it to make it available to the memory subsystem.  *  *		   Note: mp_Size may not reflect (mp_End - mp_Base) range  *		   due to other parts of the system doing their own sbrk()  *		   calls.  */
end_comment

begin_function
name|void
name|zextendPool
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|mp_Size
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|mp_Base
operator|=
name|base
expr_stmt|;
name|mp
operator|->
name|mp_Used
operator|=
name|bytes
expr_stmt|;
name|mp
operator|->
name|mp_End
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|bytes
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|pend
init|=
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
operator|+
name|mp
operator|->
name|mp_Size
decl_stmt|;
if|if
condition|(
name|base
operator|<
name|mp
operator|->
name|mp_Base
condition|)
block|{
comment|/* mp->mp_Size += (char *)mp->mp_Base - (char *)base; */
name|mp
operator|->
name|mp_Used
operator|+=
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
operator|-
operator|(
name|char
operator|*
operator|)
name|base
expr_stmt|;
name|mp
operator|->
name|mp_Base
operator|=
name|base
expr_stmt|;
block|}
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|bytes
expr_stmt|;
if|if
condition|(
name|base
operator|>
name|pend
condition|)
block|{
comment|/* mp->mp_Size += (char *)base - (char *)pend; */
name|mp
operator|->
name|mp_Used
operator|+=
operator|(
name|char
operator|*
operator|)
name|base
operator|-
operator|(
name|char
operator|*
operator|)
name|pend
expr_stmt|;
name|mp
operator|->
name|mp_End
operator|=
operator|(
name|char
operator|*
operator|)
name|base
expr_stmt|;
block|}
block|}
name|mp
operator|->
name|mp_Size
operator|+=
name|bytes
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZALLOCDEBUG
end_ifdef

begin_function
name|void
name|zallocstats
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|abytes
init|=
literal|0
decl_stmt|;
name|int
name|hbytes
init|=
literal|0
decl_stmt|;
name|int
name|fcount
init|=
literal|0
decl_stmt|;
name|MemNode
modifier|*
name|mn
decl_stmt|;
name|printf
argument_list|(
literal|"%d bytes reserved"
argument_list|,
operator|(
name|int
operator|)
name|mp
operator|->
name|mp_Size
argument_list|)
expr_stmt|;
name|mn
operator|=
name|mp
operator|->
name|mp_First
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|mn
operator|!=
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|mp_Base
condition|)
block|{
name|abytes
operator|+=
operator|(
name|char
operator|*
operator|)
name|mn
operator|-
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
expr_stmt|;
block|}
while|while
condition|(
name|mn
condition|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|mn
operator|->
name|mr_Bytes
operator|!=
name|mp
operator|->
name|mp_End
condition|)
block|{
name|hbytes
operator|+=
name|mn
operator|->
name|mr_Bytes
expr_stmt|;
operator|++
name|fcount
expr_stmt|;
block|}
if|if
condition|(
name|mn
operator|->
name|mr_Next
condition|)
name|abytes
operator|+=
operator|(
name|char
operator|*
operator|)
name|mn
operator|->
name|mr_Next
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|mn
operator|->
name|mr_Bytes
operator|)
expr_stmt|;
name|mn
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %d bytes allocated\n%d fragments (%d bytes fragmented)\n"
argument_list|,
name|abytes
argument_list|,
name|fcount
argument_list|,
name|hbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

