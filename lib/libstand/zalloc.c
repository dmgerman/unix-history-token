begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This module derived from code donated to the FreeBSD Project by   * Matthew Dillon<dillon@backplane.com>  *  * Copyright (c) 1998 The FreeBSD Project  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id$  */
end_comment

begin_comment
comment|/*  * LIB/MEMORY/ZALLOC.C	- self contained low-overhead memory pool/allocation   *			  subsystem  *  *	This subsystem implements memory pools and memory allocation   *	routines.  *  *	Pools are managed via a linked list of 'free' areas.  Allocating  *	memory creates holes in the freelist, freeing memory fills them.  *	Since the freelist consists only of free memory areas, it is possible  *	to allocate the entire pool without incuring any structural overhead.  *  *	The system works best when allocating similarly-sized chunks of  *	memory.  Care must be taken to avoid fragmentation when   *	allocating/deallocating dissimilar chunks.  *  *	When a memory pool is first allocated, the entire pool is marked as  *	allocated.  This is done mainly because we do not want to modify any  *	portion of a pool's data area until we are given permission.  The  *	caller must explicitly deallocate portions of the pool to make them  *	available.  *  *	z[n]xalloc() works like z[n]alloc() but the allocation is made from  *	within the specified address range.  If the segment could not be   *	allocated, NULL is returned.  WARNING!  The address range will be  *	aligned to an 8 or 16 byte boundry depending on the cpu so if you  *	give an unaligned address range, unexpected results may occur.  *  *	If a standard allocation fails, the reclaim function will be called  *	to recover some space.  This usually causes other portions of the  *	same pool to be released.  Memory allocations at this low level  *	should not block but you can do that too in your reclaim function  *	if you want.  Reclaim does not function when z[n]xalloc() is used,  *	only for z[n]alloc().  *  *	Allocation and frees of 0 bytes are valid operations.  */
end_comment

begin_include
include|#
directive|include
file|"zalloc_defs.h"
end_include

begin_decl_stmt
name|Prototype
name|struct
name|MemPool
modifier|*
name|DummyStructMemPool
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Library
name|void
modifier|*
name|znalloc
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mpool
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
modifier|*
name|zalloc
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mpool
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
modifier|*
name|zallocAlign
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mpool
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|,
name|iaddr_t
name|align
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
modifier|*
name|zxalloc
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|addr1
parameter_list|,
name|void
modifier|*
name|addr2
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
modifier|*
name|znxalloc
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|addr1
parameter_list|,
name|void
modifier|*
name|addr2
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|char
modifier|*
name|zallocStr
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mpool
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|slen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
name|zfree
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mpool
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
name|zfreeStr
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mpool
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
name|zinitPool
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|void
function_decl|(
modifier|*
name|fpanic
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|freclaim
function_decl|)
parameter_list|(
name|struct
name|MemPool
modifier|*
name|memPool
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
parameter_list|,
name|void
modifier|*
name|pBase
parameter_list|,
name|iaddr_t
name|pSize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
name|zclearPool
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
name|znop
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|int
name|znot
parameter_list|(
name|struct
name|MemPool
modifier|*
name|memPool
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|Library
name|void
name|zallocstats
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * znop() - panic function if none supplied.  */
end_comment

begin_function
name|void
name|znop
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * znot() - reclaim function if none supplied  */
end_comment

begin_function
name|int
name|znot
parameter_list|(
name|struct
name|MemPool
modifier|*
name|memPool
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOCLIB
end_ifndef

begin_comment
comment|/*  * zalloc() -	allocate and zero memory from pool.  Call reclaim  *		and retry if appropriate, return NULL if unable to allocate  *		memory.  */
end_comment

begin_function
name|void
modifier|*
name|zalloc
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|znalloc
argument_list|(
name|mp
argument_list|,
name|bytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zallocAlign() - allocate and zero memory from pool, enforce specified  *		   alignment (must be power of 2) on allocated memory.  */
end_comment

begin_function
name|void
modifier|*
name|zallocAlign
parameter_list|(
name|struct
name|MemPool
modifier|*
name|mp
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|,
name|iaddr_t
name|align
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
operator|--
name|align
expr_stmt|;
name|bytes
operator|=
operator|(
name|bytes
operator|+
name|align
operator|)
operator|&
operator|~
name|align
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|znalloc
argument_list|(
name|mp
argument_list|,
name|bytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * znalloc() -	allocate memory (without zeroing) from pool.  Call reclaim  *		and retry if appropriate, return NULL if unable to allocate  *		memory.  */
end_comment

begin_function
name|void
modifier|*
name|znalloc
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
comment|/*      * align according to pool object size (can be 0).  This is      * inclusive of the MEMNODE_SIZE_MASK minimum alignment.      *      */
name|bytes
operator|=
operator|(
name|bytes
operator|+
name|MEMNODE_SIZE_MASK
operator|)
operator|&
operator|~
name|MEMNODE_SIZE_MASK
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
do|do
block|{
comment|/* 	 * locate freelist entry big enough to hold the object.  If all objects 	 * are the same size, this is a constant-time function. 	 */
if|if
condition|(
name|bytes
operator|<=
name|mp
operator|->
name|mp_Size
operator|-
name|mp
operator|->
name|mp_Used
condition|)
block|{
name|MemNode
modifier|*
modifier|*
name|pmn
decl_stmt|;
name|MemNode
modifier|*
name|mn
decl_stmt|;
for|for
control|(
name|pmn
operator|=
operator|&
name|mp
operator|->
name|mp_First
init|;
operator|(
name|mn
operator|=
operator|*
name|pmn
operator|)
operator|!=
name|NULL
condition|;
name|pmn
operator|=
operator|&
name|mn
operator|->
name|mr_Next
control|)
block|{
if|if
condition|(
name|bytes
operator|>
name|mn
operator|->
name|mr_Bytes
condition|)
continue|continue;
comment|/* 		 *  Cut a chunk of memory out of the beginning of this 		 *  block and fixup the link appropriately. 		 */
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|mn
decl_stmt|;
if|if
condition|(
name|mn
operator|->
name|mr_Bytes
operator|==
name|bytes
condition|)
block|{
operator|*
name|pmn
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
block|}
else|else
block|{
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|bytes
operator|)
expr_stmt|;
name|mn
operator|->
name|mr_Next
operator|=
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
expr_stmt|;
name|mn
operator|->
name|mr_Bytes
operator|=
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|-
name|bytes
expr_stmt|;
operator|*
name|pmn
operator|=
name|mn
expr_stmt|;
block|}
name|mp
operator|->
name|mp_Used
operator|+=
name|bytes
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|mp
operator|->
name|mp_Reclaim
argument_list|(
name|mp
argument_list|,
name|bytes
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/*      * Memory pool is full, return NULL.      */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOCLIB
end_ifndef

begin_comment
comment|/*  * z[n]xalloc() -  allocate memory from within a specific address region.  *		   If allocating AT a specific address, then addr2 must be  *		   set to addr1 + bytes (and this only works if addr1 is  *		   already aligned).  addr1 and addr2 are aligned by  *		   MEMNODE_SIZE_MASK + 1 (i.e. they wlill be 8 or 16 byte   *		   aligned depending on the machine core).  */
end_comment

begin_function
name|void
modifier|*
name|zxalloc
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|addr1
parameter_list|,
name|void
modifier|*
name|addr2
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|znxalloc
argument_list|(
name|mp
argument_list|,
name|addr1
argument_list|,
name|addr2
argument_list|,
name|bytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|znxalloc
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|addr1
parameter_list|,
name|void
modifier|*
name|addr2
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
comment|/*      * align according to pool object size (can be 0).  This is      * inclusive of the MEMNODE_SIZE_MASK minimum alignment.      */
name|bytes
operator|=
operator|(
name|bytes
operator|+
name|MEMNODE_SIZE_MASK
operator|)
operator|&
operator|~
name|MEMNODE_SIZE_MASK
expr_stmt|;
name|addr1
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|iaddr_t
operator|)
name|addr1
operator|+
name|MEMNODE_SIZE_MASK
operator|)
operator|&
operator|~
name|MEMNODE_SIZE_MASK
operator|)
expr_stmt|;
name|addr2
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|iaddr_t
operator|)
name|addr2
operator|+
name|MEMNODE_SIZE_MASK
operator|)
operator|&
operator|~
name|MEMNODE_SIZE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|addr1
operator|)
return|;
comment|/*      * Locate freelist entry big enough to hold the object that is within      * the allowed address range.      */
if|if
condition|(
name|bytes
operator|<=
name|mp
operator|->
name|mp_Size
operator|-
name|mp
operator|->
name|mp_Used
condition|)
block|{
name|MemNode
modifier|*
modifier|*
name|pmn
decl_stmt|;
name|MemNode
modifier|*
name|mn
decl_stmt|;
for|for
control|(
name|pmn
operator|=
operator|&
name|mp
operator|->
name|mp_First
init|;
operator|(
name|mn
operator|=
operator|*
name|pmn
operator|)
operator|!=
name|NULL
condition|;
name|pmn
operator|=
operator|&
name|mn
operator|->
name|mr_Next
control|)
block|{
name|int
name|mrbytes
init|=
name|mn
operator|->
name|mr_Bytes
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* 	     * offset from base of mn to satisfy addr1.  0 or positive 	     */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|<
operator|(
name|char
operator|*
operator|)
name|addr1
condition|)
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
name|addr1
operator|-
operator|(
name|char
operator|*
operator|)
name|mn
expr_stmt|;
comment|/* 	     * truncate mrbytes to satisfy addr2.  mrbytes may go negative 	     * if the mn is beyond the last acceptable address. 	     */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|mrbytes
operator|>
operator|(
name|char
operator|*
operator|)
name|addr2
condition|)
name|mrbytes
operator|=
call|(
name|saddr_t
call|)
argument_list|(
operator|(
name|iaddr_t
operator|)
name|addr2
operator|-
operator|(
name|iaddr_t
operator|)
name|mn
argument_list|)
expr_stmt|;
comment|/* signed */
comment|/* 	     * beyond last acceptable address. 	     * 	     * before first acceptable address (if offset> mrbytes, the 	     * second conditional will always succeed). 	     * 	     * area overlapping acceptable address range is not big enough. 	     */
if|if
condition|(
name|mrbytes
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|mrbytes
operator|-
name|offset
operator|<
name|bytes
condition|)
continue|continue;
comment|/* 	     *  Cut a chunk of memory out of the block and fixup the link 	     *  appropriately. 	     * 	     *  If offset != 0, we have to cut a chunk out from the middle of  	     *  the block. 	     */
if|if
condition|(
name|offset
condition|)
block|{
name|MemNode
modifier|*
name|mnew
init|=
operator|(
name|MemNode
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|offset
operator|)
decl_stmt|;
name|mnew
operator|->
name|mr_Bytes
operator|=
name|mn
operator|->
name|mr_Bytes
operator|-
name|offset
expr_stmt|;
name|mnew
operator|->
name|mr_Next
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
name|mn
operator|->
name|mr_Bytes
operator|=
name|offset
expr_stmt|;
name|mn
operator|->
name|mr_Next
operator|=
name|mnew
expr_stmt|;
name|pmn
operator|=
operator|&
name|mn
operator|->
name|mr_Next
expr_stmt|;
name|mn
operator|=
name|mnew
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|mn
decl_stmt|;
if|if
condition|(
name|mn
operator|->
name|mr_Bytes
operator|==
name|bytes
condition|)
block|{
operator|*
name|pmn
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
block|}
else|else
block|{
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|bytes
operator|)
expr_stmt|;
name|mn
operator|->
name|mr_Next
operator|=
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
expr_stmt|;
name|mn
operator|->
name|mr_Bytes
operator|=
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|-
name|bytes
expr_stmt|;
operator|*
name|pmn
operator|=
name|mn
expr_stmt|;
block|}
name|mp
operator|->
name|mp_Used
operator|+=
name|bytes
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * zfree() - free previously allocated memory  */
end_comment

begin_function
name|void
name|zfree
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
comment|/*      * align according to pool object size (can be 0).  This is      * inclusive of the MEMNODE_SIZE_MASK minimum alignment.      */
name|bytes
operator|=
operator|(
name|bytes
operator|+
name|MEMNODE_SIZE_MASK
operator|)
operator|&
operator|~
name|MEMNODE_SIZE_MASK
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
return|return;
comment|/*      * panic if illegal pointer      */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
operator|||
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|bytes
operator|>
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_End
operator|||
operator|(
operator|(
name|iaddr_t
operator|)
name|ptr
operator|&
name|MEMNODE_SIZE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|mp
operator|->
name|mp_Panic
argument_list|(
literal|"zfree(%s,0x%08lx,%d): wild pointer"
argument_list|,
name|mp
operator|->
name|mp_Ident
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/*      * free the segment      */
block|{
name|MemNode
modifier|*
modifier|*
name|pmn
decl_stmt|;
name|MemNode
modifier|*
name|mn
decl_stmt|;
name|mp
operator|->
name|mp_Used
operator|-=
name|bytes
expr_stmt|;
for|for
control|(
name|pmn
operator|=
operator|&
name|mp
operator|->
name|mp_First
init|;
operator|(
name|mn
operator|=
operator|*
name|pmn
operator|)
operator|!=
name|NULL
condition|;
name|pmn
operator|=
operator|&
name|mn
operator|->
name|mr_Next
control|)
block|{
comment|/* 	     * If area between last node and current node 	     *  - check range 	     *  - check merge with next area 	     *  - check merge with previous area 	     */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<=
operator|(
name|char
operator|*
operator|)
name|mn
condition|)
block|{
comment|/* 		 * range check 		 */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|bytes
operator|>
operator|(
name|char
operator|*
operator|)
name|mn
condition|)
block|{
name|mp
operator|->
name|mp_Panic
argument_list|(
literal|"zfree(%s,0x%08lx,%d): corrupt memlist1"
argument_list|,
name|mp
operator|->
name|mp_Ident
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * merge against next area or create independant area 		 */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|bytes
operator|==
operator|(
name|char
operator|*
operator|)
name|mn
condition|)
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|=
name|bytes
operator|+
name|mn
operator|->
name|mr_Bytes
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
operator|=
name|mn
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|=
name|bytes
expr_stmt|;
block|}
operator|*
name|pmn
operator|=
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* 		 * merge against previous area (if there is a previous 		 * area). 		 */
if|if
condition|(
name|pmn
operator|!=
operator|&
name|mp
operator|->
name|mp_First
condition|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|pmn
operator|+
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|==
operator|(
name|char
operator|*
operator|)
name|ptr
condition|)
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Next
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|+=
name|mn
operator|->
name|mr_Bytes
expr_stmt|;
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|pmn
expr_stmt|;
block|}
block|}
return|return;
comment|/* NOT REACHED */
block|}
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|mn
operator|->
name|mr_Bytes
condition|)
block|{
name|mp
operator|->
name|mp_Panic
argument_list|(
literal|"zfree(%s,0x%08lx,%d): corrupt memlist2"
argument_list|,
name|mp
operator|->
name|mp_Ident
argument_list|,
operator|(
name|long
operator|)
name|ptr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We are beyond the last MemNode, append new MemNode.  Merge against 	 * previous area if possible. 	 */
if|if
condition|(
name|pmn
operator|==
operator|&
name|mp
operator|->
name|mp_First
operator|||
operator|(
name|char
operator|*
operator|)
name|pmn
operator|+
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|!=
operator|(
name|char
operator|*
operator|)
name|ptr
condition|)
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|ptr
operator|)
operator|->
name|mr_Bytes
operator|=
name|bytes
expr_stmt|;
operator|*
name|pmn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|ptr
expr_stmt|;
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|MemNode
operator|*
operator|)
name|pmn
operator|)
operator|->
name|mr_Bytes
operator|+=
name|bytes
expr_stmt|;
name|mn
operator|=
operator|(
name|MemNode
operator|*
operator|)
name|pmn
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOCLIB
end_ifndef

begin_comment
comment|/*  * zallocStr() - allocate memory and copy string.  */
end_comment

begin_function
name|char
modifier|*
name|zallocStr
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|slen
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|slen
operator|<
literal|0
condition|)
name|slen
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|znalloc
argument_list|(
name|mp
argument_list|,
name|slen
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|s
argument_list|,
name|ptr
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|ptr
index|[
name|slen
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfreeStr() - free memory associated with an allocated string.  */
end_comment

begin_function
name|void
name|zfreeStr
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|zfree
argument_list|(
name|mp
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * zinitpool() - initialize a memory pool  */
end_comment

begin_function
name|void
name|zinitPool
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|void
function_decl|(
modifier|*
name|fpanic
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|ctl
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|freclaim
function_decl|)
parameter_list|(
name|MemPool
modifier|*
name|memPool
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
parameter_list|,
name|void
modifier|*
name|pBase
parameter_list|,
name|iaddr_t
name|pSize
parameter_list|)
block|{
if|if
condition|(
name|fpanic
operator|==
name|NULL
condition|)
name|fpanic
operator|=
name|znop
expr_stmt|;
if|if
condition|(
name|freclaim
operator|==
name|NULL
condition|)
name|freclaim
operator|=
name|znot
expr_stmt|;
if|if
condition|(
name|id
operator|!=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|mp
operator|->
name|mp_Ident
operator|=
name|id
expr_stmt|;
name|mp
operator|->
name|mp_Base
operator|=
name|pBase
expr_stmt|;
name|mp
operator|->
name|mp_End
operator|=
operator|(
name|char
operator|*
operator|)
name|pBase
operator|+
name|pSize
expr_stmt|;
name|mp
operator|->
name|mp_First
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|mp_Size
operator|=
name|pSize
expr_stmt|;
name|mp
operator|->
name|mp_Used
operator|=
name|pSize
expr_stmt|;
name|mp
operator|->
name|mp_Panic
operator|=
name|fpanic
expr_stmt|;
name|mp
operator|->
name|mp_Reclaim
operator|=
name|freclaim
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zextendPool() - extend memory pool to cover additional space.  *  *		   Note: the added memory starts out as allocated, you  *		   must free it to make it available to the memory subsystem.  *  *		   Note: mp_Size may not reflect (mp_End - mp_Base) range  *		   due to other parts of the system doing their own sbrk()  *		   calls.  */
end_comment

begin_function
name|void
name|zextendPool
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|iaddr_t
name|bytes
parameter_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|mp_Size
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|mp_Base
operator|=
name|base
expr_stmt|;
name|mp
operator|->
name|mp_Used
operator|=
name|bytes
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|pend
init|=
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
operator|+
name|mp
operator|->
name|mp_Size
decl_stmt|;
if|if
condition|(
name|base
operator|<
name|mp
operator|->
name|mp_Base
condition|)
block|{
comment|/* mp->mp_Size += (char *)mp->mp_Base - (char *)base; */
name|mp
operator|->
name|mp_Used
operator|+=
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
operator|-
operator|(
name|char
operator|*
operator|)
name|base
expr_stmt|;
name|mp
operator|->
name|mp_Base
operator|=
name|base
expr_stmt|;
block|}
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|bytes
expr_stmt|;
if|if
condition|(
name|base
operator|>
name|pend
condition|)
block|{
comment|/* mp->mp_Size += (char *)base - (char *)pend; */
name|mp
operator|->
name|mp_Used
operator|+=
operator|(
name|char
operator|*
operator|)
name|base
operator|-
operator|(
name|char
operator|*
operator|)
name|pend
expr_stmt|;
block|}
name|mp
operator|->
name|mp_End
operator|=
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
operator|+
name|mp
operator|->
name|mp_Size
expr_stmt|;
block|}
name|mp
operator|->
name|mp_Size
operator|+=
name|bytes
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOCLIB
end_ifndef

begin_comment
comment|/*  * zclearpool() - Free all memory associated with a memory pool,  *		  destroying any previous allocations.  Commonly  *		  called afte zinitPool() to make a pool available  *		  for use.  */
end_comment

begin_function
name|void
name|zclearPool
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|)
block|{
name|MemNode
modifier|*
name|mn
init|=
name|mp
operator|->
name|mp_Base
decl_stmt|;
name|mn
operator|->
name|mr_Next
operator|=
name|NULL
expr_stmt|;
name|mn
operator|->
name|mr_Bytes
operator|=
name|mp
operator|->
name|mp_Size
expr_stmt|;
name|mp
operator|->
name|mp_First
operator|=
name|mn
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ZALLOCDEBUG
end_ifdef

begin_function
name|void
name|zallocstats
parameter_list|(
name|MemPool
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|abytes
init|=
literal|0
decl_stmt|;
name|int
name|hbytes
init|=
literal|0
decl_stmt|;
name|int
name|fcount
init|=
literal|0
decl_stmt|;
name|MemNode
modifier|*
name|mn
decl_stmt|;
name|printf
argument_list|(
literal|"Pool %s, %d bytes reserved"
argument_list|,
name|mp
operator|->
name|mp_Ident
argument_list|,
name|mp
operator|->
name|mp_Size
argument_list|)
expr_stmt|;
name|mn
operator|=
name|mp
operator|->
name|mp_First
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|mn
operator|!=
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|mp_Base
condition|)
block|{
name|abytes
operator|+=
operator|(
name|char
operator|*
operator|)
name|mn
operator|-
operator|(
name|char
operator|*
operator|)
name|mp
operator|->
name|mp_Base
expr_stmt|;
block|}
while|while
condition|(
name|mn
condition|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|mn
operator|->
name|mr_Bytes
operator|!=
name|mp
operator|->
name|mp_End
condition|)
block|{
name|hbytes
operator|+=
name|mn
operator|->
name|mr_Bytes
expr_stmt|;
operator|++
name|fcount
expr_stmt|;
block|}
if|if
condition|(
name|mn
operator|->
name|mr_Next
condition|)
name|abytes
operator|+=
operator|(
name|char
operator|*
operator|)
name|mn
operator|->
name|mr_Next
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|mn
operator|+
name|mn
operator|->
name|mr_Bytes
operator|)
expr_stmt|;
name|mn
operator|=
name|mn
operator|->
name|mr_Next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %d bytes allocated\n%d fragments (%d bytes fragmented)\n"
argument_list|,
name|abytes
argument_list|,
name|fcount
argument_list|,
name|hbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

