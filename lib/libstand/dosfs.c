begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, 1998 Robert Nordier  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Readonly filesystem for Microsoft FAT12/FAT16/FAT32 filesystems,  * also supports VFAT.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|"stand.h"
end_include

begin_include
include|#
directive|include
file|"dosfs.h"
end_include

begin_function_decl
specifier|static
name|int
name|dos_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|open_file
modifier|*
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dos_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dos_read
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|dos_seek
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dos_stat
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dos_readdir
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|struct
name|dirent
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fs_ops
name|dosfs_fsops
init|=
block|{
literal|"dosfs"
block|,
name|dos_open
block|,
name|dos_close
block|,
name|dos_read
block|,
name|null_write
block|,
name|dos_seek
block|,
name|dos_stat
block|,
name|dos_readdir
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SECSIZ
value|512
end_define

begin_comment
comment|/* sector size */
end_comment

begin_define
define|#
directive|define
name|SSHIFT
value|9
end_define

begin_comment
comment|/* SECSIZ shift */
end_comment

begin_define
define|#
directive|define
name|DEPSEC
value|16
end_define

begin_comment
comment|/* directory entries per sector */
end_comment

begin_define
define|#
directive|define
name|DSHIFT
value|4
end_define

begin_comment
comment|/* DEPSEC shift */
end_comment

begin_define
define|#
directive|define
name|LOCLUS
value|2
end_define

begin_comment
comment|/* lowest cluster number */
end_comment

begin_comment
comment|/* DOS "BIOS Parameter Block" */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
name|secsiz
index|[
literal|2
index|]
decl_stmt|;
comment|/* sector size */
name|u_char
name|spc
decl_stmt|;
comment|/* sectors per cluster */
name|u_char
name|ressec
index|[
literal|2
index|]
decl_stmt|;
comment|/* reserved sectors */
name|u_char
name|fats
decl_stmt|;
comment|/* FATs */
name|u_char
name|dirents
index|[
literal|2
index|]
decl_stmt|;
comment|/* root directory entries */
name|u_char
name|secs
index|[
literal|2
index|]
decl_stmt|;
comment|/* total sectors */
name|u_char
name|media
decl_stmt|;
comment|/* media descriptor */
name|u_char
name|spf
index|[
literal|2
index|]
decl_stmt|;
comment|/* sectors per FAT */
name|u_char
name|spt
index|[
literal|2
index|]
decl_stmt|;
comment|/* sectors per track */
name|u_char
name|heads
index|[
literal|2
index|]
decl_stmt|;
comment|/* drive heads */
name|u_char
name|hidsec
index|[
literal|4
index|]
decl_stmt|;
comment|/* hidden sectors */
name|u_char
name|lsecs
index|[
literal|4
index|]
decl_stmt|;
comment|/* huge sectors */
name|u_char
name|lspf
index|[
literal|4
index|]
decl_stmt|;
comment|/* huge sectors per FAT */
name|u_char
name|xflg
index|[
literal|2
index|]
decl_stmt|;
comment|/* flags */
name|u_char
name|vers
index|[
literal|2
index|]
decl_stmt|;
comment|/* filesystem version */
name|u_char
name|rdcl
index|[
literal|4
index|]
decl_stmt|;
comment|/* root directory start cluster */
name|u_char
name|infs
index|[
literal|2
index|]
decl_stmt|;
comment|/* filesystem info sector */
name|u_char
name|bkbs
index|[
literal|2
index|]
decl_stmt|;
comment|/* backup boot sector */
block|}
name|DOS_BPB
typedef|;
end_typedef

begin_comment
comment|/* Initial portion of DOS boot sector */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
name|jmp
index|[
literal|3
index|]
decl_stmt|;
comment|/* usually 80x86 'jmp' opcode */
name|u_char
name|oem
index|[
literal|8
index|]
decl_stmt|;
comment|/* OEM name and version */
name|DOS_BPB
name|bpb
decl_stmt|;
comment|/* BPB */
block|}
name|DOS_BS
typedef|;
end_typedef

begin_comment
comment|/* Supply missing "." and ".." root directory entries */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dotstr
index|[
literal|2
index|]
init|=
block|{
literal|"."
block|,
literal|".."
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DOS_DE
name|dot
index|[
literal|2
index|]
init|=
block|{
block|{
literal|".       "
block|,
literal|"   "
block|,
name|FA_DIR
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x21
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
literal|"..      "
block|,
literal|"   "
block|,
name|FA_DIR
block|,
block|{
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0x21
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The usual conversion macros to avoid multiplication and division */
end_comment

begin_define
define|#
directive|define
name|bytsec
parameter_list|(
name|n
parameter_list|)
value|((n)>> SSHIFT)
end_define

begin_define
define|#
directive|define
name|secbyt
parameter_list|(
name|s
parameter_list|)
value|((s)<< SSHIFT)
end_define

begin_define
define|#
directive|define
name|entsec
parameter_list|(
name|e
parameter_list|)
value|((e)>> DSHIFT)
end_define

begin_define
define|#
directive|define
name|bytblk
parameter_list|(
name|fs
parameter_list|,
name|n
parameter_list|)
value|((n)>> (fs)->bshift)
end_define

begin_define
define|#
directive|define
name|blkbyt
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|((b)<< (fs)->bshift)
end_define

begin_define
define|#
directive|define
name|secblk
parameter_list|(
name|fs
parameter_list|,
name|s
parameter_list|)
value|((s)>> ((fs)->bshift - SSHIFT))
end_define

begin_define
define|#
directive|define
name|blksec
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|((b)<< ((fs)->bshift - SSHIFT))
end_define

begin_comment
comment|/* Convert cluster number to offset within filesystem */
end_comment

begin_define
define|#
directive|define
name|blkoff
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|(secbyt((fs)->lsndta) + blkbyt(fs, (b) - LOCLUS))
end_define

begin_comment
comment|/* Convert cluster number to logical sector number */
end_comment

begin_define
define|#
directive|define
name|blklsn
parameter_list|(
name|fs
parameter_list|,
name|b
parameter_list|)
value|((fs)->lsndta + blksec(fs, (b) - LOCLUS))
end_define

begin_comment
comment|/* Convert cluster number to offset within FAT */
end_comment

begin_define
define|#
directive|define
name|fatoff
parameter_list|(
name|sz
parameter_list|,
name|c
parameter_list|)
value|((sz) == 12 ? (c) + ((c)>> 1) :  \                         (sz) == 16 ? (c)<< 1 :          \ 			(c)<< 2)
end_define

begin_comment
comment|/* Does cluster number reference a valid data cluster? */
end_comment

begin_define
define|#
directive|define
name|okclus
parameter_list|(
name|fs
parameter_list|,
name|c
parameter_list|)
value|((c)>= LOCLUS&& (c)<= (fs)->xclus)
end_define

begin_comment
comment|/* Get start cluster from directory entry */
end_comment

begin_define
define|#
directive|define
name|stclus
parameter_list|(
name|sz
parameter_list|,
name|de
parameter_list|)
value|((sz) != 32 ? cv2((de)->clus) :          \                          ((u_int)cv2((de)->dex.h_clus)<< 16) |  \ 			 cv2((de)->clus))
end_define

begin_comment
comment|/*  * fat cache metadata  */
end_comment

begin_struct
struct|struct
name|fatcache
block|{
name|int
name|unit
decl_stmt|;
comment|/* disk unit number */
name|int
name|size
decl_stmt|;
comment|/* buffer (and fat) size in sectors */
name|u_char
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|fatcache
name|fat
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|dosunmount
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parsebs
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|,
name|DOS_BS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|namede
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|DOS_DE
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|DOS_DE
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_xdnm
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|DOS_XDE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cp_sfn
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|DOS_DE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|fsize
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|,
name|DOS_DE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fatcnt
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fatget
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fatend
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ioread
parameter_list|(
name|DOS_FS
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ioget
parameter_list|(
name|struct
name|open_file
modifier|*
parameter_list|,
name|daddr_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|dos_read_fat
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|struct
name|open_file
modifier|*
name|fd
parameter_list|)
block|{
name|struct
name|devdesc
modifier|*
name|dd
init|=
name|fd
operator|->
name|f_devdata
decl_stmt|;
if|if
condition|(
name|fat
operator|.
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* can we reuse old buffer? */
if|if
condition|(
name|fat
operator|.
name|size
operator|!=
name|fs
operator|->
name|spf
condition|)
block|{
name|free
argument_list|(
name|fat
operator|.
name|buf
argument_list|)
expr_stmt|;
comment|/* no, free old buffer */
name|fat
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fat
operator|.
name|buf
operator|==
name|NULL
condition|)
name|fat
operator|.
name|buf
operator|=
name|malloc
argument_list|(
name|secbyt
argument_list|(
name|fs
operator|->
name|spf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat
operator|.
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ioget
argument_list|(
name|fd
argument_list|,
name|fs
operator|->
name|lsnfat
argument_list|,
name|fat
operator|.
name|buf
argument_list|,
name|secbyt
argument_list|(
name|fs
operator|->
name|spf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fat
operator|.
name|size
operator|=
name|fs
operator|->
name|spf
expr_stmt|;
name|fat
operator|.
name|unit
operator|=
name|dd
operator|->
name|d_unit
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|fat
operator|.
name|buf
operator|!=
name|NULL
condition|)
comment|/* got IO error */
name|free
argument_list|(
name|fat
operator|.
name|buf
argument_list|)
expr_stmt|;
name|fat
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|fat
operator|.
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* impossible unit */
name|fat
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mount DOS filesystem  */
end_comment

begin_function
specifier|static
name|int
name|dos_mount
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|struct
name|open_file
modifier|*
name|fd
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|devdesc
modifier|*
name|dd
init|=
name|fd
operator|->
name|f_devdata
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|bzero
argument_list|(
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
name|DOS_FS
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
operator|!
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|secbyt
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
condition|?
name|errno
else|:
literal|0
operator|)
operator|||
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|secbyt
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|err
operator|=
name|parsebs
argument_list|(
name|fs
argument_list|,
operator|(
name|DOS_BS
operator|*
operator|)
name|buf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dosunmount
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fat
operator|.
name|buf
operator|==
name|NULL
operator|||
name|fat
operator|.
name|unit
operator|!=
name|dd
operator|->
name|d_unit
condition|)
name|dos_read_fat
argument_list|(
name|fs
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fs
operator|->
name|root
operator|=
name|dot
index|[
literal|0
index|]
expr_stmt|;
name|fs
operator|->
name|root
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fatsz
operator|==
literal|32
condition|)
block|{
name|fs
operator|->
name|root
operator|.
name|clus
index|[
literal|0
index|]
operator|=
name|fs
operator|->
name|rdcl
operator|&
literal|0xff
expr_stmt|;
name|fs
operator|->
name|root
operator|.
name|clus
index|[
literal|1
index|]
operator|=
operator|(
name|fs
operator|->
name|rdcl
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fs
operator|->
name|root
operator|.
name|dex
operator|.
name|h_clus
index|[
literal|0
index|]
operator|=
operator|(
name|fs
operator|->
name|rdcl
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fs
operator|->
name|root
operator|.
name|dex
operator|.
name|h_clus
index|[
literal|1
index|]
operator|=
operator|(
name|fs
operator|->
name|rdcl
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount mounted filesystem  */
end_comment

begin_function
specifier|static
name|int
name|dos_unmount
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|links
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|dosunmount
argument_list|(
name|fs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code shared by dos_mount() and dos_unmount()  */
end_comment

begin_function
specifier|static
name|int
name|dosunmount
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|)
block|{
name|free
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open DOS file  */
end_comment

begin_function
specifier|static
name|int
name|dos_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|open_file
modifier|*
name|fd
parameter_list|)
block|{
name|DOS_DE
modifier|*
name|de
decl_stmt|;
name|DOS_FILE
modifier|*
name|f
decl_stmt|;
name|DOS_FS
modifier|*
name|fs
decl_stmt|;
name|u_int
name|size
decl_stmt|,
name|clus
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* Allocate mount structure, associate with open */
name|fs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DOS_FS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dos_mount
argument_list|(
name|fs
argument_list|,
name|fd
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|err
operator|=
name|namede
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
operator|&
name|de
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|clus
operator|=
name|stclus
argument_list|(
name|fs
operator|->
name|fatsz
argument_list|,
name|de
argument_list|)
expr_stmt|;
name|size
operator|=
name|cv4
argument_list|(
name|de
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
operator|&&
operator|(
operator|!
name|clus
operator|!=
operator|!
name|size
operator|)
operator|)
operator|||
operator|(
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
operator|&&
name|size
operator|)
operator|||
operator|(
name|clus
operator|&&
operator|!
name|okclus
argument_list|(
name|fs
argument_list|,
name|clus
argument_list|)
operator|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|f
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DOS_FILE
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|DOS_FILE
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|fs
operator|->
name|links
operator|++
expr_stmt|;
name|f
operator|->
name|de
operator|=
operator|*
name|de
expr_stmt|;
name|fd
operator|->
name|f_fsdata
operator|=
operator|(
name|void
operator|*
operator|)
name|f
expr_stmt|;
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read from file  */
end_comment

begin_function
specifier|static
name|int
name|dos_read
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbyte
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
block|{
name|off_t
name|size
decl_stmt|;
name|u_int
name|nb
decl_stmt|,
name|off
decl_stmt|,
name|clus
decl_stmt|,
name|c
decl_stmt|,
name|cnt
decl_stmt|,
name|n
decl_stmt|;
name|DOS_FILE
modifier|*
name|f
init|=
operator|(
name|DOS_FILE
operator|*
operator|)
name|fd
operator|->
name|f_fsdata
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/*      * as ioget() can be called *a lot*, use twiddle here.      * also 4 seems to be good value not to slow loading down too much:      * with 270MB file (~540k ioget() calls, twiddle can easily waste 4-5sec.      */
name|twiddle
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|nb
operator|=
operator|(
name|u_int
operator|)
name|nbyte
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|fsize
argument_list|(
name|f
operator|->
name|fs
argument_list|,
operator|&
name|f
operator|->
name|de
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|nb
operator|>
operator|(
name|n
operator|=
name|size
operator|-
name|f
operator|->
name|offset
operator|)
condition|)
name|nb
operator|=
name|n
expr_stmt|;
name|off
operator|=
name|f
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|clus
operator|=
name|stclus
argument_list|(
name|f
operator|->
name|fs
operator|->
name|fatsz
argument_list|,
operator|&
name|f
operator|->
name|de
argument_list|)
operator|)
condition|)
name|off
operator|&=
name|f
operator|->
name|fs
operator|->
name|bsize
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|f
operator|->
name|c
expr_stmt|;
name|cnt
operator|=
name|nb
expr_stmt|;
while|while
condition|(
name|cnt
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|clus
operator|)
condition|)
name|n
operator|=
name|bytblk
argument_list|(
name|f
operator|->
name|fs
argument_list|,
name|f
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|off
condition|)
name|n
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|fatget
argument_list|(
name|f
operator|->
name|fs
argument_list|,
operator|&
name|c
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|okclus
argument_list|(
name|f
operator|->
name|fs
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|clus
operator|||
operator|(
name|n
operator|=
name|f
operator|->
name|fs
operator|->
name|bsize
operator|-
name|off
operator|)
operator|>
name|cnt
condition|)
name|n
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|ioread
argument_list|(
name|f
operator|->
name|fs
argument_list|,
operator|(
name|c
condition|?
name|blkoff
argument_list|(
name|f
operator|->
name|fs
argument_list|,
name|c
argument_list|)
else|:
name|secbyt
argument_list|(
name|f
operator|->
name|fs
operator|->
name|lsndir
argument_list|)
operator|)
operator|+
name|off
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|f
operator|->
name|offset
operator|+=
name|n
expr_stmt|;
name|f
operator|->
name|c
operator|=
name|c
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|n
expr_stmt|;
name|cnt
operator|-=
name|n
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|resid
condition|)
operator|*
name|resid
operator|=
name|nbyte
operator|-
name|nb
operator|+
name|cnt
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reposition within file  */
end_comment

begin_function
specifier|static
name|off_t
name|dos_seek
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|off_t
name|off
decl_stmt|;
name|u_int
name|size
decl_stmt|;
name|DOS_FILE
modifier|*
name|f
init|=
operator|(
name|DOS_FILE
operator|*
operator|)
name|fd
operator|->
name|f_fsdata
decl_stmt|;
name|size
operator|=
name|cv4
argument_list|(
name|f
operator|->
name|de
operator|.
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|off
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|off
operator|=
name|f
operator|->
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|off
operator|=
name|size
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|off
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|off
operator|>
name|size
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|f
operator|->
name|offset
operator|=
operator|(
name|u_int
operator|)
name|off
expr_stmt|;
name|f
operator|->
name|c
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close open file  */
end_comment

begin_function
specifier|static
name|int
name|dos_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|)
block|{
name|DOS_FILE
modifier|*
name|f
init|=
operator|(
name|DOS_FILE
operator|*
operator|)
name|fd
operator|->
name|f_fsdata
decl_stmt|;
name|DOS_FS
modifier|*
name|fs
init|=
name|f
operator|->
name|fs
decl_stmt|;
name|f
operator|->
name|fs
operator|->
name|links
operator|--
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|dos_unmount
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return some stat information on a file.  */
end_comment

begin_function
specifier|static
name|int
name|dos_stat
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|DOS_FILE
modifier|*
name|f
init|=
operator|(
name|DOS_FILE
operator|*
operator|)
name|fd
operator|->
name|f_fsdata
decl_stmt|;
comment|/* only important stuff */
name|sb
operator|->
name|st_mode
operator|=
name|f
operator|->
name|de
operator|.
name|attr
operator|&
name|FA_DIR
condition|?
name|S_IFDIR
operator||
literal|0555
else|:
name|S_IFREG
operator||
literal|0444
expr_stmt|;
name|sb
operator|->
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|sb
operator|->
name|st_uid
operator|=
literal|0
expr_stmt|;
name|sb
operator|->
name|st_gid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|->
name|st_size
operator|=
name|fsize
argument_list|(
name|f
operator|->
name|fs
argument_list|,
operator|&
name|f
operator|->
name|de
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_checksum
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|11
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ext
argument_list|,
name|buf
operator|+
literal|8
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|x
operator|>>
literal|1
operator|)
expr_stmt|;
name|x
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|x
operator|&=
literal|0xff
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_readdir
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|struct
name|dirent
modifier|*
name|d
parameter_list|)
block|{
comment|/* DOS_FILE *f = (DOS_FILE *)fd->f_fsdata; */
name|u_char
name|fn
index|[
literal|261
index|]
decl_stmt|;
name|DOS_DIR
name|dd
decl_stmt|;
name|size_t
name|res
decl_stmt|;
name|u_int
name|chk
decl_stmt|,
name|x
decl_stmt|,
name|xdn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|x
operator|=
name|chk
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|xdn
operator|=
name|x
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|dos_read
argument_list|(
name|fd
argument_list|,
operator|&
name|dd
argument_list|,
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|res
operator|==
sizeof|sizeof
argument_list|(
name|dd
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|dd
operator|.
name|de
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Skip deleted entries */
if|if
condition|(
name|dd
operator|.
name|de
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0xe5
condition|)
continue|continue;
comment|/* Check if directory entry is volume label */
if|if
condition|(
name|dd
operator|.
name|de
operator|.
name|attr
operator|&
name|FA_LABEL
condition|)
block|{
comment|/*  	     * If volume label set, check if the current entry is 	     * extended entry (FA_XDE) for long file names. 	     */
if|if
condition|(
operator|(
name|dd
operator|.
name|de
operator|.
name|attr
operator|&
name|FA_MASK
operator|)
operator|==
name|FA_XDE
condition|)
block|{
comment|/* 		 * Read through all following extended entries 		 * to get the long file name. 0x40 marks the 		 * last entry containing part of long file name. 		 */
if|if
condition|(
name|dd
operator|.
name|xde
operator|.
name|seq
operator|&
literal|0x40
condition|)
name|chk
operator|=
name|dd
operator|.
name|xde
operator|.
name|chk
expr_stmt|;
elseif|else
if|if
condition|(
name|dd
operator|.
name|xde
operator|.
name|seq
operator|!=
name|xdn
operator|-
literal|1
operator|||
name|dd
operator|.
name|xde
operator|.
name|chk
operator|!=
name|chk
condition|)
continue|continue;
name|x
operator|=
name|dd
operator|.
name|xde
operator|.
name|seq
operator|&
operator|~
literal|0x40
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|1
operator|||
name|x
operator|>
literal|20
condition|)
block|{
name|x
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cp_xdnm
argument_list|(
name|fn
argument_list|,
operator|&
name|dd
operator|.
name|xde
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* skip only volume label entries */
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|xdn
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|dos_checksum
argument_list|(
name|dd
operator|.
name|de
operator|.
name|name
argument_list|,
name|dd
operator|.
name|de
operator|.
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|chk
condition|)
break|break;
block|}
else|else
block|{
name|cp_sfn
argument_list|(
name|fn
argument_list|,
operator|&
name|dd
operator|.
name|de
argument_list|)
expr_stmt|;
break|break;
block|}
name|x
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|d
operator|->
name|d_fileno
operator|=
operator|(
name|dd
operator|.
name|de
operator|.
name|clus
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|dd
operator|.
name|de
operator|.
name|clus
index|[
literal|0
index|]
expr_stmt|;
name|d
operator|->
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|d_type
operator|=
operator|(
name|dd
operator|.
name|de
operator|.
name|attr
operator|&
name|FA_DIR
operator|)
condition|?
name|DT_DIR
else|:
name|DT_REG
expr_stmt|;
name|memcpy
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
name|fn
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse DOS boot sector  */
end_comment

begin_function
specifier|static
name|int
name|parsebs
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_BS
modifier|*
name|bs
parameter_list|)
block|{
name|u_int
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|bs
operator|->
name|jmp
index|[
literal|0
index|]
operator|!=
literal|0x69
operator|&&
name|bs
operator|->
name|jmp
index|[
literal|0
index|]
operator|!=
literal|0xe9
operator|&&
operator|(
name|bs
operator|->
name|jmp
index|[
literal|0
index|]
operator|!=
literal|0xeb
operator|||
name|bs
operator|->
name|jmp
index|[
literal|2
index|]
operator|!=
literal|0x90
operator|)
operator|)
operator|||
name|bs
operator|->
name|bpb
operator|.
name|media
operator|<
literal|0xf0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|secsiz
argument_list|)
operator|!=
name|SECSIZ
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|spc
operator|=
name|bs
operator|->
name|bpb
operator|.
name|spc
operator|)
operator|||
name|fs
operator|->
name|spc
operator|&
operator|(
name|fs
operator|->
name|spc
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fs
operator|->
name|bsize
operator|=
name|secbyt
argument_list|(
name|fs
operator|->
name|spc
argument_list|)
expr_stmt|;
name|fs
operator|->
name|bshift
operator|=
name|ffs
argument_list|(
name|fs
operator|->
name|bsize
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|spf
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|spf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|bpb
operator|.
name|fats
operator|!=
literal|2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|dirents
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|dirents
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|spf
operator|=
name|cv4
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|lspf
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|bs
operator|->
name|bpb
operator|.
name|fats
operator|||
name|bs
operator|->
name|bpb
operator|.
name|fats
operator|>
literal|16
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|fs
operator|->
name|rdcl
operator|=
name|cv4
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|rdcl
argument_list|)
operator|)
operator|<
name|LOCLUS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|lsnfat
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|ressec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fs
operator|->
name|lsndir
operator|=
name|fs
operator|->
name|lsnfat
operator|+
name|fs
operator|->
name|spf
operator|*
name|bs
operator|->
name|bpb
operator|.
name|fats
expr_stmt|;
name|fs
operator|->
name|lsndta
operator|=
name|fs
operator|->
name|lsndir
operator|+
name|entsec
argument_list|(
name|fs
operator|->
name|dirents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|=
name|cv2
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|secs
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|=
name|cv4
argument_list|(
name|bs
operator|->
name|bpb
operator|.
name|lsecs
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fs
operator|->
name|lsndta
operator|>
name|sc
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|fs
operator|->
name|xclus
operator|=
name|secblk
argument_list|(
name|fs
argument_list|,
name|sc
operator|-
name|fs
operator|->
name|lsndta
argument_list|)
operator|+
literal|1
operator|)
operator|<
name|LOCLUS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fs
operator|->
name|fatsz
operator|=
name|fs
operator|->
name|dirents
condition|?
name|fs
operator|->
name|xclus
operator|<
literal|0xff6
condition|?
literal|12
else|:
literal|16
else|:
literal|32
expr_stmt|;
name|sc
operator|=
operator|(
name|secbyt
argument_list|(
name|fs
operator|->
name|spf
argument_list|)
operator|<<
literal|1
operator|)
operator|/
operator|(
name|fs
operator|->
name|fatsz
operator|>>
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|xclus
operator|>
name|sc
condition|)
name|fs
operator|->
name|xclus
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return directory entry from path  */
end_comment

begin_function
specifier|static
name|int
name|namede
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|DOS_DE
modifier|*
modifier|*
name|dep
parameter_list|)
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|DOS_DE
modifier|*
name|de
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|de
operator|=
operator|&
name|fs
operator|->
name|root
expr_stmt|;
while|while
condition|(
operator|*
name|path
condition|)
block|{
while|while
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|path
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|path
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|s
operator|-
name|path
operator|)
operator|>
literal|255
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|path
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|name
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|path
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|de
operator|->
name|attr
operator|&
name|FA_DIR
operator|)
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|lookup
argument_list|(
name|fs
argument_list|,
name|stclus
argument_list|(
name|fs
operator|->
name|fatsz
argument_list|,
name|de
argument_list|)
argument_list|,
name|name
argument_list|,
operator|&
name|de
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|*
name|dep
operator|=
name|de
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup path segment  */
end_comment

begin_function
specifier|static
name|int
name|lookup
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_int
name|clus
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DOS_DE
modifier|*
modifier|*
name|dep
parameter_list|)
block|{
specifier|static
name|DOS_DIR
name|dir
index|[
name|DEPSEC
index|]
decl_stmt|;
name|u_char
name|lfn
index|[
literal|261
index|]
decl_stmt|;
name|u_char
name|sfn
index|[
literal|13
index|]
decl_stmt|;
name|u_int
name|nsec
decl_stmt|,
name|lsec
decl_stmt|,
name|xdn
decl_stmt|,
name|chk
decl_stmt|,
name|sec
decl_stmt|,
name|ent
decl_stmt|,
name|x
decl_stmt|;
name|int
name|err
decl_stmt|,
name|ok
decl_stmt|;
if|if
condition|(
operator|!
name|clus
condition|)
for|for
control|(
name|ent
operator|=
literal|0
init|;
name|ent
operator|<
literal|2
condition|;
name|ent
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|dotstr
index|[
name|ent
index|]
argument_list|)
condition|)
block|{
operator|*
name|dep
operator|=
name|dot
operator|+
name|ent
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|clus
operator|&&
name|fs
operator|->
name|fatsz
operator|==
literal|32
condition|)
name|clus
operator|=
name|fs
operator|->
name|rdcl
expr_stmt|;
name|nsec
operator|=
operator|!
name|clus
condition|?
name|entsec
argument_list|(
name|fs
operator|->
name|dirents
argument_list|)
else|:
name|fs
operator|->
name|spc
expr_stmt|;
name|lsec
operator|=
literal|0
expr_stmt|;
name|xdn
operator|=
name|chk
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|clus
operator|&&
operator|!
name|lsec
condition|)
name|lsec
operator|=
name|fs
operator|->
name|lsndir
expr_stmt|;
elseif|else
if|if
condition|(
name|okclus
argument_list|(
name|fs
argument_list|,
name|clus
argument_list|)
condition|)
name|lsec
operator|=
name|blklsn
argument_list|(
name|fs
argument_list|,
name|clus
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|sec
operator|=
literal|0
init|;
name|sec
operator|<
name|nsec
condition|;
name|sec
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
name|lsec
operator|+
name|sec
argument_list|,
name|dir
argument_list|,
name|secbyt
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|ent
operator|=
literal|0
init|;
name|ent
operator|<
name|DEPSEC
condition|;
name|ent
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|dir
index|[
name|ent
index|]
operator|.
name|de
operator|.
name|name
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
operator|*
name|dir
index|[
name|ent
index|]
operator|.
name|de
operator|.
name|name
operator|!=
literal|0xe5
condition|)
block|{
if|if
condition|(
operator|(
name|dir
index|[
name|ent
index|]
operator|.
name|de
operator|.
name|attr
operator|&
name|FA_MASK
operator|)
operator|==
name|FA_XDE
condition|)
block|{
name|x
operator|=
name|dir
index|[
name|ent
index|]
operator|.
name|xde
operator|.
name|seq
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0x40
operator|||
operator|(
name|x
operator|+
literal|1
operator|==
name|xdn
operator|&&
name|dir
index|[
name|ent
index|]
operator|.
name|xde
operator|.
name|chk
operator|==
name|chk
operator|)
condition|)
block|{
if|if
condition|(
name|x
operator|&
literal|0x40
condition|)
block|{
name|chk
operator|=
name|dir
index|[
name|ent
index|]
operator|.
name|xde
operator|.
name|chk
expr_stmt|;
name|x
operator|&=
operator|~
literal|0x40
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|>=
literal|1
operator|&&
name|x
operator|<=
literal|20
condition|)
block|{
name|cp_xdnm
argument_list|(
name|lfn
argument_list|,
operator|&
name|dir
index|[
name|ent
index|]
operator|.
name|xde
argument_list|)
expr_stmt|;
name|xdn
operator|=
name|x
expr_stmt|;
continue|continue;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|dir
index|[
name|ent
index|]
operator|.
name|de
operator|.
name|attr
operator|&
name|FA_LABEL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ok
operator|=
name|xdn
operator|==
literal|1
operator|)
condition|)
block|{
name|x
operator|=
name|dos_checksum
argument_list|(
name|dir
index|[
name|ent
index|]
operator|.
name|de
operator|.
name|name
argument_list|,
name|dir
index|[
name|ent
index|]
operator|.
name|de
operator|.
name|ext
argument_list|)
expr_stmt|;
name|ok
operator|=
name|chk
operator|==
name|x
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|lfn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|cp_sfn
argument_list|(
name|sfn
argument_list|,
operator|&
name|dir
index|[
name|ent
index|]
operator|.
name|de
argument_list|)
expr_stmt|;
name|ok
operator|=
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|sfn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
operator|*
name|dep
operator|=
operator|&
name|dir
index|[
name|ent
index|]
operator|.
name|de
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|xdn
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|clus
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|fatget
argument_list|(
name|fs
argument_list|,
operator|&
name|clus
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|fatend
argument_list|(
name|fs
operator|->
name|fatsz
argument_list|,
name|clus
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy name from extended directory entry  */
end_comment

begin_function
specifier|static
name|void
name|cp_xdnm
parameter_list|(
name|u_char
modifier|*
name|lfn
parameter_list|,
name|DOS_XDE
modifier|*
name|xde
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_int
name|off
decl_stmt|;
name|u_int
name|dim
decl_stmt|;
block|}
name|ix
index|[
literal|3
index|]
init|=
block|{
block|{
name|offsetof
argument_list|(
name|DOS_XDE
argument_list|,
name|name1
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|xde
operator|->
name|name1
argument_list|)
operator|/
literal|2
block|}
block|,
block|{
name|offsetof
argument_list|(
name|DOS_XDE
argument_list|,
name|name2
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|xde
operator|->
name|name2
argument_list|)
operator|/
literal|2
block|}
block|,
block|{
name|offsetof
argument_list|(
name|DOS_XDE
argument_list|,
name|name3
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|xde
operator|->
name|name3
argument_list|)
operator|/
literal|2
block|}
block|}
struct|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_int
name|n
decl_stmt|,
name|x
decl_stmt|,
name|c
decl_stmt|;
name|lfn
operator|+=
literal|13
operator|*
operator|(
operator|(
name|xde
operator|->
name|seq
operator|&
operator|~
literal|0x40
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|3
condition|;
name|n
operator|++
control|)
for|for
control|(
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|xde
operator|+
name|ix
index|[
name|n
index|]
operator|.
name|off
operator|,
name|x
operator|=
name|ix
index|[
name|n
index|]
operator|.
name|dim
init|;
name|x
condition|;
name|p
operator|+=
literal|2
operator|,
name|x
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|cv2
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
operator|(
name|c
operator|<
literal|32
operator|||
name|c
operator|>
literal|127
operator|)
condition|)
name|c
operator|=
literal|'?'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|lfn
operator|++
operator|=
name|c
operator|)
condition|)
return|return;
block|}
if|if
condition|(
name|xde
operator|->
name|seq
operator|&
literal|0x40
condition|)
operator|*
name|lfn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy short filename  */
end_comment

begin_function
specifier|static
name|void
name|cp_sfn
parameter_list|(
name|u_char
modifier|*
name|sfn
parameter_list|,
name|DOS_DE
modifier|*
name|de
parameter_list|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|j
decl_stmt|,
name|i
decl_stmt|;
name|p
operator|=
name|sfn
expr_stmt|;
if|if
condition|(
operator|*
name|de
operator|->
name|name
operator|!=
literal|' '
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|7
init|;
name|de
operator|->
name|name
index|[
name|j
index|]
operator|==
literal|' '
condition|;
name|j
operator|--
control|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|de
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|de
operator|->
name|ext
operator|!=
literal|' '
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|de
operator|->
name|ext
index|[
name|j
index|]
operator|==
literal|' '
condition|;
name|j
operator|--
control|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|de
operator|->
name|ext
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|sfn
operator|==
literal|5
condition|)
operator|*
name|sfn
operator|=
literal|0xe5
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return size of file in bytes  */
end_comment

begin_function
specifier|static
name|off_t
name|fsize
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|DOS_DE
modifier|*
name|de
parameter_list|)
block|{
name|u_long
name|size
decl_stmt|;
name|u_int
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|size
operator|=
name|cv4
argument_list|(
name|de
operator|->
name|size
argument_list|)
operator|)
operator|&&
name|de
operator|->
name|attr
operator|&
name|FA_DIR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|cv2
argument_list|(
name|de
operator|->
name|clus
argument_list|)
operator|)
condition|)
name|size
operator|=
name|fs
operator|->
name|dirents
operator|*
sizeof|sizeof
argument_list|(
name|DOS_DE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|fatcnt
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|size
operator|=
name|blkbyt
argument_list|(
name|fs
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Count number of clusters in chain  */
end_comment

begin_function
specifier|static
name|int
name|fatcnt
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_int
name|c
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|okclus
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|fatget
argument_list|(
name|fs
argument_list|,
operator|&
name|c
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|fatend
argument_list|(
name|fs
operator|->
name|fatsz
argument_list|,
name|c
argument_list|)
condition|?
name|n
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get next cluster in cluster chain. Use in core fat cache unless another  * device replaced it.  */
end_comment

begin_function
specifier|static
name|int
name|fatget
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_int
modifier|*
name|c
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|u_int
name|x
decl_stmt|,
name|offset
decl_stmt|,
name|n
decl_stmt|,
name|nbyte
decl_stmt|;
name|struct
name|devdesc
modifier|*
name|dd
init|=
name|fs
operator|->
name|fd
operator|->
name|f_devdata
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fat
operator|.
name|unit
operator|!=
name|dd
operator|->
name|d_unit
condition|)
block|{
comment|/* fat cache was changed to another device, don't use it */
name|err
operator|=
name|ioread
argument_list|(
name|fs
argument_list|,
name|secbyt
argument_list|(
name|fs
operator|->
name|lsnfat
argument_list|)
operator|+
name|fatoff
argument_list|(
name|fs
operator|->
name|fatsz
argument_list|,
operator|*
name|c
argument_list|)
argument_list|,
name|buf
argument_list|,
name|fs
operator|->
name|fatsz
operator|!=
literal|32
condition|?
literal|2
else|:
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
else|else
block|{
name|offset
operator|=
name|fatoff
argument_list|(
name|fs
operator|->
name|fatsz
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
name|nbyte
operator|=
name|fs
operator|->
name|fatsz
operator|!=
literal|32
condition|?
literal|2
else|:
literal|4
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|nbyte
operator|>
name|secbyt
argument_list|(
name|fat
operator|.
name|size
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|fat
operator|.
name|buf
operator|+
name|offset
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|fs
operator|->
name|fatsz
operator|!=
literal|32
condition|?
name|cv2
argument_list|(
name|buf
argument_list|)
else|:
name|cv4
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|fs
operator|->
name|fatsz
operator|==
literal|12
condition|?
operator|*
name|c
operator|&
literal|1
condition|?
name|x
operator|>>
literal|4
else|:
name|x
operator|&
literal|0xfff
else|:
name|x
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is cluster an end-of-chain marker?  */
end_comment

begin_function
specifier|static
name|int
name|fatend
parameter_list|(
name|u_int
name|sz
parameter_list|,
name|u_int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>
operator|(
name|sz
operator|==
literal|12
condition|?
literal|0xff7U
else|:
name|sz
operator|==
literal|16
condition|?
literal|0xfff7U
else|:
literal|0xffffff7
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Offset-based I/O primitive  */
end_comment

begin_function
specifier|static
name|int
name|ioread
parameter_list|(
name|DOS_FS
modifier|*
name|fs
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|nbyte
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|u_int
name|off
decl_stmt|,
name|n
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u_char
name|local_buf
index|[
name|SECSIZ
index|]
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
name|offset
operator|&
operator|(
name|SECSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|offset
operator|-=
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|SECSIZ
operator|-
name|off
operator|)
operator|>
name|nbyte
condition|)
name|n
operator|=
name|nbyte
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
name|bytsec
argument_list|(
name|offset
argument_list|)
argument_list|,
name|local_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|local_buf
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|local_buf
operator|+
name|off
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|SECSIZ
expr_stmt|;
name|s
operator|+=
name|n
expr_stmt|;
name|nbyte
operator|-=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|nbyte
operator|&
operator|(
name|SECSIZ
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nbyte
operator|-=
name|n
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
name|bytsec
argument_list|(
name|offset
argument_list|)
argument_list|,
name|s
argument_list|,
name|nbyte
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|offset
operator|+=
name|nbyte
expr_stmt|;
name|s
operator|+=
name|nbyte
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ioget
argument_list|(
name|fs
operator|->
name|fd
argument_list|,
name|bytsec
argument_list|(
name|offset
argument_list|)
argument_list|,
name|local_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|local_buf
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|local_buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sector-based I/O primitive  */
end_comment

begin_function
specifier|static
name|int
name|ioget
parameter_list|(
name|struct
name|open_file
modifier|*
name|fd
parameter_list|,
name|daddr_t
name|lsec
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
return|return
operator|(
call|(
name|fd
operator|->
name|f_dev
operator|->
name|dv_strategy
call|)
argument_list|(
name|fd
operator|->
name|f_devdata
argument_list|,
name|F_READ
argument_list|,
name|lsec
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

