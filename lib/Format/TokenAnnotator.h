begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- TokenAnnotator.h - Format C++ code ---------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief This file implements a token annotator, i.e. creates
end_comment

begin_comment
comment|/// \c AnnotatedTokens out of \c FormatTokens with required extra information.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_FORMAT_TOKEN_ANNOTATOR_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_FORMAT_TOKEN_ANNOTATOR_H
end_define

begin_include
include|#
directive|include
file|"UnwrappedLineParser.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OperatorPrecedence.h"
end_include

begin_include
include|#
directive|include
file|"clang/Format/Format.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|Lexer
decl_stmt|;
name|class
name|SourceManager
decl_stmt|;
name|namespace
name|format
block|{
enum|enum
name|TokenType
block|{
name|TT_BinaryOperator
block|,
name|TT_BlockComment
block|,
name|TT_CastRParen
block|,
name|TT_ConditionalExpr
block|,
name|TT_CtorInitializerColon
block|,
name|TT_ImplicitStringLiteral
block|,
name|TT_InlineASMColon
block|,
name|TT_InheritanceColon
block|,
name|TT_LineComment
block|,
name|TT_ObjCArrayLiteral
block|,
name|TT_ObjCBlockLParen
block|,
name|TT_ObjCDecl
block|,
name|TT_ObjCForIn
block|,
name|TT_ObjCMethodExpr
block|,
name|TT_ObjCMethodSpecifier
block|,
name|TT_ObjCProperty
block|,
name|TT_ObjCSelectorName
block|,
name|TT_OverloadedOperatorLParen
block|,
name|TT_PointerOrReference
block|,
name|TT_PureVirtualSpecifier
block|,
name|TT_RangeBasedForLoopColon
block|,
name|TT_StartOfName
block|,
name|TT_TemplateCloser
block|,
name|TT_TemplateOpener
block|,
name|TT_TrailingUnaryOperator
block|,
name|TT_UnaryOperator
block|,
name|TT_Unknown
block|}
enum|;
enum|enum
name|LineType
block|{
name|LT_Invalid
block|,
name|LT_Other
block|,
name|LT_BuilderTypeCall
block|,
name|LT_PreprocessorDirective
block|,
name|LT_VirtualFunctionDecl
block|,
name|LT_ObjCDecl
block|,
comment|// An @interface, @implementation, or @protocol line.
name|LT_ObjCMethodDecl
block|,
name|LT_ObjCProperty
comment|// An @property line.
block|}
enum|;
name|class
name|AnnotatedToken
block|{
name|public
label|:
name|explicit
name|AnnotatedToken
argument_list|(
specifier|const
name|FormatToken
operator|&
name|FormatTok
argument_list|)
operator|:
name|FormatTok
argument_list|(
name|FormatTok
argument_list|)
operator|,
name|Type
argument_list|(
name|TT_Unknown
argument_list|)
operator|,
name|SpacesRequiredBefore
argument_list|(
literal|0
argument_list|)
operator|,
name|CanBreakBefore
argument_list|(
name|false
argument_list|)
operator|,
name|MustBreakBefore
argument_list|(
name|false
argument_list|)
operator|,
name|ClosesTemplateDeclaration
argument_list|(
name|false
argument_list|)
operator|,
name|MatchingParen
argument_list|(
name|NULL
argument_list|)
operator|,
name|ParameterCount
argument_list|(
literal|0
argument_list|)
operator|,
name|BindingStrength
argument_list|(
literal|0
argument_list|)
operator|,
name|SplitPenalty
argument_list|(
literal|0
argument_list|)
operator|,
name|LongestObjCSelectorName
argument_list|(
literal|0
argument_list|)
operator|,
name|Parent
argument_list|(
name|NULL
argument_list|)
operator|,
name|FakeLParens
argument_list|(
literal|0
argument_list|)
operator|,
name|FakeRParens
argument_list|(
literal|0
argument_list|)
operator|,
name|LastInChainOfCalls
argument_list|(
name|false
argument_list|)
operator|,
name|PartOfMultiVariableDeclStmt
argument_list|(
argument|false
argument_list|)
block|{}
name|bool
name|is
argument_list|(
argument|tok::TokenKind Kind
argument_list|)
specifier|const
block|{
return|return
name|FormatTok
operator|.
name|Tok
operator|.
name|is
argument_list|(
name|Kind
argument_list|)
return|;
block|}
name|bool
name|isOneOf
argument_list|(
name|tok
operator|::
name|TokenKind
name|K1
argument_list|,
name|tok
operator|::
name|TokenKind
name|K2
argument_list|)
decl|const
block|{
return|return
name|is
argument_list|(
name|K1
argument_list|)
operator|||
name|is
argument_list|(
name|K2
argument_list|)
return|;
block|}
name|bool
name|isOneOf
argument_list|(
name|tok
operator|::
name|TokenKind
name|K1
argument_list|,
name|tok
operator|::
name|TokenKind
name|K2
argument_list|,
name|tok
operator|::
name|TokenKind
name|K3
argument_list|)
decl|const
block|{
return|return
name|is
argument_list|(
name|K1
argument_list|)
operator|||
name|is
argument_list|(
name|K2
argument_list|)
operator|||
name|is
argument_list|(
name|K3
argument_list|)
return|;
block|}
name|bool
name|isOneOf
argument_list|(
name|tok
operator|::
name|TokenKind
name|K1
argument_list|,
name|tok
operator|::
name|TokenKind
name|K2
argument_list|,
name|tok
operator|::
name|TokenKind
name|K3
argument_list|,
name|tok
operator|::
name|TokenKind
name|K4
argument_list|,
name|tok
operator|::
name|TokenKind
name|K5
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|,
name|tok
operator|::
name|TokenKind
name|K6
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|,
name|tok
operator|::
name|TokenKind
name|K7
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|,
name|tok
operator|::
name|TokenKind
name|K8
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|,
name|tok
operator|::
name|TokenKind
name|K9
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|,
name|tok
operator|::
name|TokenKind
name|K10
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|,
name|tok
operator|::
name|TokenKind
name|K11
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|,
name|tok
operator|::
name|TokenKind
name|K12
operator|=
name|tok
operator|::
name|NUM_TOKENS
argument_list|)
decl|const
block|{
return|return
name|is
argument_list|(
name|K1
argument_list|)
operator|||
name|is
argument_list|(
name|K2
argument_list|)
operator|||
name|is
argument_list|(
name|K3
argument_list|)
operator|||
name|is
argument_list|(
name|K4
argument_list|)
operator|||
name|is
argument_list|(
name|K5
argument_list|)
operator|||
name|is
argument_list|(
name|K6
argument_list|)
operator|||
name|is
argument_list|(
name|K7
argument_list|)
operator|||
name|is
argument_list|(
name|K8
argument_list|)
operator|||
name|is
argument_list|(
name|K9
argument_list|)
operator|||
name|is
argument_list|(
name|K10
argument_list|)
operator|||
name|is
argument_list|(
name|K11
argument_list|)
operator|||
name|is
argument_list|(
name|K12
argument_list|)
return|;
block|}
name|bool
name|isNot
argument_list|(
name|tok
operator|::
name|TokenKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|FormatTok
operator|.
name|Tok
operator|.
name|isNot
argument_list|(
name|Kind
argument_list|)
return|;
block|}
name|bool
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|ObjCKeywordKind
name|Kind
argument_list|)
decl|const
block|{
return|return
name|FormatTok
operator|.
name|Tok
operator|.
name|isObjCAtKeyword
argument_list|(
name|Kind
argument_list|)
return|;
block|}
name|bool
name|isAccessSpecifier
argument_list|(
name|bool
name|ColonRequired
operator|=
name|true
argument_list|)
decl|const
block|{
return|return
name|isOneOf
argument_list|(
name|tok
operator|::
name|kw_public
argument_list|,
name|tok
operator|::
name|kw_protected
argument_list|,
name|tok
operator|::
name|kw_private
argument_list|)
operator|&&
operator|(
operator|!
name|ColonRequired
operator|||
operator|(
operator|!
name|Children
operator|.
name|empty
argument_list|()
operator|&&
name|Children
index|[
literal|0
index|]
operator|.
name|is
argument_list|(
name|tok
operator|::
name|colon
argument_list|)
operator|)
operator|)
return|;
block|}
name|bool
name|isObjCAccessSpecifier
argument_list|()
specifier|const
block|{
return|return
name|is
argument_list|(
name|tok
operator|::
name|at
argument_list|)
operator|&&
operator|!
name|Children
operator|.
name|empty
argument_list|()
operator|&&
operator|(
name|Children
index|[
literal|0
index|]
operator|.
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_public
argument_list|)
operator|||
name|Children
index|[
literal|0
index|]
operator|.
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_protected
argument_list|)
operator|||
name|Children
index|[
literal|0
index|]
operator|.
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_package
argument_list|)
operator|||
name|Children
index|[
literal|0
index|]
operator|.
name|isObjCAtKeyword
argument_list|(
name|tok
operator|::
name|objc_private
argument_list|)
operator|)
return|;
block|}
name|FormatToken
name|FormatTok
decl_stmt|;
name|TokenType
name|Type
decl_stmt|;
name|unsigned
name|SpacesRequiredBefore
decl_stmt|;
name|bool
name|CanBreakBefore
decl_stmt|;
name|bool
name|MustBreakBefore
decl_stmt|;
name|bool
name|ClosesTemplateDeclaration
decl_stmt|;
name|AnnotatedToken
modifier|*
name|MatchingParen
decl_stmt|;
comment|/// \brief Number of parameters, if this is "(", "[" or "<".
comment|///
comment|/// This is initialized to 1 as we don't need to distinguish functions with
comment|/// 0 parameters from functions with 1 parameter. Thus, we can simply count
comment|/// the number of commas.
name|unsigned
name|ParameterCount
decl_stmt|;
comment|/// \brief The total length of the line up to and including this token.
name|unsigned
name|TotalLength
decl_stmt|;
comment|// FIXME: Come up with a 'cleaner' concept.
comment|/// \brief The binding strength of a token. This is a combined value of
comment|/// operator precedence, parenthesis nesting, etc.
name|unsigned
name|BindingStrength
decl_stmt|;
comment|/// \brief Penalty for inserting a line break before this token.
name|unsigned
name|SplitPenalty
decl_stmt|;
comment|/// \brief If this is the first ObjC selector name in an ObjC method
comment|/// definition or call, this contains the length of the longest name.
name|unsigned
name|LongestObjCSelectorName
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|AnnotatedToken
operator|>
name|Children
expr_stmt|;
name|AnnotatedToken
modifier|*
name|Parent
decl_stmt|;
comment|/// \brief Insert this many fake ( before this token for correct indentation.
name|unsigned
name|FakeLParens
decl_stmt|;
comment|/// \brief Insert this many fake ) after this token for correct indentation.
name|unsigned
name|FakeRParens
decl_stmt|;
comment|/// \brief Is this the last "." or "->" in a builder-type call?
name|bool
name|LastInChainOfCalls
decl_stmt|;
comment|/// \brief Is this token part of a \c DeclStmt defining multiple variables?
comment|///
comment|/// Only set if \c Type == \c TT_StartOfName.
name|bool
name|PartOfMultiVariableDeclStmt
decl_stmt|;
specifier|const
name|AnnotatedToken
operator|*
name|getPreviousNoneComment
argument_list|()
specifier|const
block|{
name|AnnotatedToken
operator|*
name|Tok
operator|=
name|Parent
block|;
while|while
condition|(
name|Tok
operator|!=
name|NULL
operator|&&
name|Tok
operator|->
name|is
argument_list|(
name|tok
operator|::
name|comment
argument_list|)
condition|)
name|Tok
operator|=
name|Tok
operator|->
name|Parent
expr_stmt|;
return|return
name|Tok
return|;
block|}
block|}
empty_stmt|;
name|class
name|AnnotatedLine
block|{
name|public
label|:
name|AnnotatedLine
argument_list|(
specifier|const
name|UnwrappedLine
operator|&
name|Line
argument_list|)
operator|:
name|First
argument_list|(
name|Line
operator|.
name|Tokens
operator|.
name|front
argument_list|()
argument_list|)
operator|,
name|Level
argument_list|(
name|Line
operator|.
name|Level
argument_list|)
operator|,
name|InPPDirective
argument_list|(
name|Line
operator|.
name|InPPDirective
argument_list|)
operator|,
name|MustBeDeclaration
argument_list|(
name|Line
operator|.
name|MustBeDeclaration
argument_list|)
operator|,
name|MightBeFunctionDecl
argument_list|(
argument|false
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Line
operator|.
name|Tokens
operator|.
name|empty
argument_list|()
argument_list|)
block|;
name|AnnotatedToken
operator|*
name|Current
operator|=
operator|&
name|First
block|;
for|for
control|(
name|std
operator|::
name|list
operator|<
name|FormatToken
operator|>
operator|::
name|const_iterator
name|I
operator|=
operator|++
name|Line
operator|.
name|Tokens
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Line
operator|.
name|Tokens
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|Current
operator|->
name|Children
operator|.
name|push_back
argument_list|(
name|AnnotatedToken
argument_list|(
operator|*
name|I
argument_list|)
argument_list|)
expr_stmt|;
name|Current
operator|->
name|Children
index|[
literal|0
index|]
operator|.
name|Parent
operator|=
name|Current
expr_stmt|;
name|Current
operator|=
operator|&
name|Current
operator|->
name|Children
index|[
literal|0
index|]
expr_stmt|;
block|}
name|Last
operator|=
name|Current
expr_stmt|;
block|}
name|AnnotatedLine
argument_list|(
specifier|const
name|AnnotatedLine
operator|&
name|Other
argument_list|)
operator|:
name|First
argument_list|(
name|Other
operator|.
name|First
argument_list|)
operator|,
name|Type
argument_list|(
name|Other
operator|.
name|Type
argument_list|)
operator|,
name|Level
argument_list|(
name|Other
operator|.
name|Level
argument_list|)
operator|,
name|InPPDirective
argument_list|(
name|Other
operator|.
name|InPPDirective
argument_list|)
operator|,
name|MustBeDeclaration
argument_list|(
name|Other
operator|.
name|MustBeDeclaration
argument_list|)
operator|,
name|MightBeFunctionDecl
argument_list|(
argument|Other.MightBeFunctionDecl
argument_list|)
block|{
name|Last
operator|=
operator|&
name|First
block|;
while|while
condition|(
operator|!
name|Last
operator|->
name|Children
operator|.
name|empty
argument_list|()
condition|)
block|{
name|Last
operator|->
name|Children
index|[
literal|0
index|]
operator|.
name|Parent
operator|=
name|Last
expr_stmt|;
name|Last
operator|=
operator|&
name|Last
operator|->
name|Children
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
name|AnnotatedToken
name|First
expr_stmt|;
name|AnnotatedToken
modifier|*
name|Last
decl_stmt|;
name|LineType
name|Type
decl_stmt|;
name|unsigned
name|Level
decl_stmt|;
name|bool
name|InPPDirective
decl_stmt|;
name|bool
name|MustBeDeclaration
decl_stmt|;
name|bool
name|MightBeFunctionDecl
decl_stmt|;
block|}
empty_stmt|;
specifier|inline
name|prec
operator|::
name|Level
name|getPrecedence
argument_list|(
argument|const AnnotatedToken&Tok
argument_list|)
block|{
return|return
name|getBinOpPrecedence
argument_list|(
name|Tok
operator|.
name|FormatTok
operator|.
name|Tok
operator|.
name|getKind
argument_list|()
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|/// \brief Determines extra information about the tokens comprising an
comment|/// \c UnwrappedLine.
name|class
name|TokenAnnotator
block|{
name|public
label|:
name|TokenAnnotator
argument_list|(
specifier|const
name|FormatStyle
operator|&
name|Style
argument_list|,
name|SourceManager
operator|&
name|SourceMgr
argument_list|,
name|Lexer
operator|&
name|Lex
argument_list|,
name|IdentifierInfo
operator|&
name|Ident_in
argument_list|)
operator|:
name|Style
argument_list|(
name|Style
argument_list|)
operator|,
name|SourceMgr
argument_list|(
name|SourceMgr
argument_list|)
operator|,
name|Lex
argument_list|(
name|Lex
argument_list|)
operator|,
name|Ident_in
argument_list|(
argument|Ident_in
argument_list|)
block|{   }
name|void
name|annotate
argument_list|(
name|AnnotatedLine
operator|&
name|Line
argument_list|)
expr_stmt|;
name|void
name|calculateFormattingInformation
parameter_list|(
name|AnnotatedLine
modifier|&
name|Line
parameter_list|)
function_decl|;
name|private
label|:
comment|/// \brief Calculate the penalty for splitting before \c Tok.
name|unsigned
name|splitPenalty
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|AnnotatedToken
modifier|&
name|Tok
parameter_list|)
function_decl|;
name|bool
name|spaceRequiredBetween
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|AnnotatedToken
modifier|&
name|Left
parameter_list|,
specifier|const
name|AnnotatedToken
modifier|&
name|Right
parameter_list|)
function_decl|;
name|bool
name|spaceRequiredBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|AnnotatedToken
modifier|&
name|Tok
parameter_list|)
function_decl|;
name|bool
name|canBreakBefore
parameter_list|(
specifier|const
name|AnnotatedLine
modifier|&
name|Line
parameter_list|,
specifier|const
name|AnnotatedToken
modifier|&
name|Right
parameter_list|)
function_decl|;
specifier|const
name|FormatStyle
modifier|&
name|Style
decl_stmt|;
name|SourceManager
modifier|&
name|SourceMgr
decl_stmt|;
name|Lexer
modifier|&
name|Lex
decl_stmt|;
comment|// Contextual keywords:
name|IdentifierInfo
modifier|&
name|Ident_in
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace format
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_FORMAT_TOKEN_ANNOTATOR_H
end_comment

end_unit

