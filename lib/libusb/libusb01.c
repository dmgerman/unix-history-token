begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This file contains the emulation layer for LibUSB v0.1 from sourceforge.  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"libusb20.h"
end_include

begin_include
include|#
directive|include
file|"libusb20_desc.h"
end_include

begin_include
include|#
directive|include
file|"libusb20_int.h"
end_include

begin_include
include|#
directive|include
file|"usb.h"
end_include

begin_comment
comment|/*  * The two following macros were taken from the original LibUSB v0.1  * for sake of compatibility:  */
end_comment

begin_define
define|#
directive|define
name|LIST_ADD
parameter_list|(
name|begin
parameter_list|,
name|ent
parameter_list|)
define|\
value|do {				   \     if (begin) {		   \       ent->next = begin;	   \       ent->next->prev = ent;	   \     } else {			   \       ent->next = NULL;		   \     }				   \     ent->prev = NULL;		   \     begin = ent;		   \   } while(0)
end_define

begin_define
define|#
directive|define
name|LIST_DEL
parameter_list|(
name|begin
parameter_list|,
name|ent
parameter_list|)
define|\
value|do {					 \     if (ent->prev) {			 \       ent->prev->next = ent->next;	 \     } else {				 \       begin = ent->next;		 \     }					 \     if (ent->next) {			 \       ent->next->prev = ent->prev;	 \     }					 \     ent->prev = NULL;			 \     ent->next = NULL;			 \   } while (0)
end_define

begin_decl_stmt
name|struct
name|usb_bus
modifier|*
name|usb_busses
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|usb_bus
name|usb_global_bus
init|=
block|{
operator|.
name|dirname
operator|=
block|{
literal|"/dev/usb"
block|}
block|,
operator|.
name|root_dev
operator|=
name|NULL
block|,
operator|.
name|devices
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|libusb20_backend
modifier|*
name|usb_backend
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|usb_parse_state
block|{
struct|struct
block|{
name|struct
name|libusb20_endpoint
modifier|*
name|currep
decl_stmt|;
name|struct
name|libusb20_interface
modifier|*
name|currifc
decl_stmt|;
name|struct
name|libusb20_config
modifier|*
name|currcfg
decl_stmt|;
name|struct
name|libusb20_me_struct
modifier|*
name|currextra
decl_stmt|;
block|}
name|a
struct|;
struct|struct
block|{
name|struct
name|usb_config_descriptor
modifier|*
name|currcfg
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|currifc
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|currep
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|currifcw
decl_stmt|;
name|uint8_t
modifier|*
name|currextra
decl_stmt|;
block|}
name|b
struct|;
name|uint8_t
name|preparse
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|libusb20_transfer
modifier|*
name|usb_get_transfer_by_ep_no
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|uint8_t
name|ep_no
parameter_list|)
block|{
name|struct
name|libusb20_device
modifier|*
name|pdev
init|=
operator|(
name|void
operator|*
operator|)
name|dev
decl_stmt|;
name|struct
name|libusb20_transfer
modifier|*
name|xfer
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint32_t
name|bufsize
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|uint8_t
name|speed
decl_stmt|;
name|x
operator|=
operator|(
name|ep_no
operator|&
name|LIBUSB20_ENDPOINT_ADDRESS_MASK
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|ep_no
operator|&
name|LIBUSB20_ENDPOINT_DIR_MASK
condition|)
block|{
comment|/* this is an IN endpoint */
name|x
operator||=
literal|1
expr_stmt|;
block|}
name|speed
operator|=
name|libusb20_dev_get_speed
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
comment|/* select a sensible buffer size */
if|if
condition|(
name|speed
operator|==
name|LIBUSB20_SPEED_LOW
condition|)
block|{
name|bufsize
operator|=
literal|256
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|speed
operator|==
name|LIBUSB20_SPEED_FULL
condition|)
block|{
name|bufsize
operator|=
literal|4096
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|speed
operator|==
name|LIBUSB20_SPEED_SUPER
condition|)
block|{
name|bufsize
operator|=
literal|65536
expr_stmt|;
block|}
else|else
block|{
name|bufsize
operator|=
literal|16384
expr_stmt|;
block|}
name|xfer
operator|=
name|libusb20_tr_get_pointer
argument_list|(
name|pdev
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return
operator|(
name|xfer
operator|)
return|;
name|err
operator|=
name|libusb20_tr_open
argument_list|(
name|xfer
argument_list|,
name|bufsize
argument_list|,
literal|1
argument_list|,
name|ep_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|LIBUSB20_ERROR_BUSY
condition|)
block|{
comment|/* already opened */
return|return
operator|(
name|xfer
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* success */
return|return
operator|(
name|xfer
operator|)
return|;
block|}
end_function

begin_function
name|usb_dev_handle
modifier|*
name|usb_open
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|libusb20_dev_open
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
literal|16
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|LIBUSB20_ERROR_BUSY
condition|)
block|{
comment|/* 		 * Workaround buggy USB applications which open the USB 		 * device multiple times: 		 */
return|return
operator|(
name|dev
operator|->
name|dev
operator|)
return|;
block|}
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Dequeue USB device from backend queue so that it does not get 	 * freed when the backend is re-scanned: 	 */
name|libusb20_be_dequeue_device
argument_list|(
name|usb_backend
argument_list|,
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|dev
operator|->
name|dev
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_close
parameter_list|(
name|usb_dev_handle
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|libusb20_dev_close
argument_list|(
operator|(
name|void
operator|*
operator|)
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|usb_backend
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Enqueue USB device to backend queue so that it gets freed 		 * when the backend is re-scanned: 		 */
name|libusb20_be_enqueue_device
argument_list|(
name|usb_backend
argument_list|,
operator|(
name|void
operator|*
operator|)
name|udev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The backend is gone. Free device data so that we 		 * don't start leaking memory! 		 */
name|dev
operator|=
name|usb_device
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|libusb20_dev_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|udev
argument_list|)
expr_stmt|;
name|LIST_DEL
argument_list|(
name|usb_global_bus
operator|.
name|devices
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_get_string
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|strindex
parameter_list|,
name|int
name|langid
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|buflen
operator|>
literal|65535
condition|)
name|buflen
operator|=
literal|65535
expr_stmt|;
name|err
operator|=
name|libusb20_dev_req_string_sync
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|,
name|strindex
argument_list|,
name|langid
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_get_string_simple
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|strindex
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|buflen
operator|>
literal|65535
condition|)
name|buflen
operator|=
literal|65535
expr_stmt|;
name|err
operator|=
name|libusb20_dev_req_string_simple_sync
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|,
name|strindex
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_get_descriptor_by_endpoint
parameter_list|(
name|usb_dev_handle
modifier|*
name|udev
parameter_list|,
name|int
name|ep
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|ep_index
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|size
operator|>
literal|65535
condition|)
name|size
operator|=
literal|65535
expr_stmt|;
return|return
operator|(
name|usb_control_msg
argument_list|(
name|udev
argument_list|,
name|ep
operator||
name|USB_ENDPOINT_IN
argument_list|,
name|USB_REQ_GET_DESCRIPTOR
argument_list|,
operator|(
name|type
operator|<<
literal|8
operator|)
operator|+
name|ep_index
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|1000
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_get_descriptor
parameter_list|(
name|usb_dev_handle
modifier|*
name|udev
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|desc_index
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|size
operator|>
literal|65535
condition|)
name|size
operator|=
literal|65535
expr_stmt|;
return|return
operator|(
name|usb_control_msg
argument_list|(
name|udev
argument_list|,
name|USB_ENDPOINT_IN
argument_list|,
name|USB_REQ_GET_DESCRIPTOR
argument_list|,
operator|(
name|type
operator|<<
literal|8
operator|)
operator|+
name|desc_index
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|1000
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_parse_descriptor
parameter_list|(
name|uint8_t
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|description
parameter_list|,
name|void
modifier|*
name|dest
parameter_list|)
block|{
name|uint8_t
modifier|*
name|sp
init|=
name|source
decl_stmt|;
name|uint8_t
modifier|*
name|dp
init|=
name|dest
decl_stmt|;
name|uint16_t
name|w
decl_stmt|;
name|uint32_t
name|d
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|description
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* 8-bit byte */
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
break|break;
comment|/* 			 * 16-bit word, convert from little endian to CPU 			 */
case|case
literal|'w'
case|:
name|w
operator|=
operator|(
name|sp
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
comment|/* Align to word boundary */
name|dp
operator|+=
operator|(
operator|(
name|dp
operator|-
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|dp
operator|)
operator|=
name|w
expr_stmt|;
name|dp
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* 			 * 32-bit dword, convert from little endian to CPU 			 */
case|case
literal|'d'
case|:
name|d
operator|=
operator|(
name|sp
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sp
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sp
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|+=
literal|4
expr_stmt|;
comment|/* Align to word boundary */
name|dp
operator|+=
operator|(
operator|(
name|dp
operator|-
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* Align to double word boundary */
name|dp
operator|+=
operator|(
operator|(
name|dp
operator|-
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|&
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dp
operator|)
operator|=
name|d
expr_stmt|;
name|dp
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|sp
operator|-
name|source
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_parse_extra
parameter_list|(
name|struct
name|usb_parse_state
modifier|*
name|ps
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|pptr
parameter_list|,
name|int
modifier|*
name|plen
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|ptr
operator|=
name|ps
operator|->
name|a
operator|.
name|currextra
operator|->
name|ptr
expr_stmt|;
name|len
operator|=
name|ps
operator|->
name|a
operator|.
name|currextra
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|preparse
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ps
operator|->
name|b
operator|.
name|currextra
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|pptr
operator|=
name|ps
operator|->
name|b
operator|.
name|currextra
expr_stmt|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
block|}
name|ps
operator|->
name|b
operator|.
name|currextra
operator|+=
name|len
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_parse_endpoint
parameter_list|(
name|struct
name|usb_parse_state
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|usb_endpoint_descriptor
modifier|*
name|bep
decl_stmt|;
name|struct
name|libusb20_endpoint
modifier|*
name|aep
decl_stmt|;
name|aep
operator|=
name|ps
operator|->
name|a
operator|.
name|currep
expr_stmt|;
name|bep
operator|=
name|ps
operator|->
name|b
operator|.
name|currep
operator|++
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|preparse
operator|==
literal|0
condition|)
block|{
comment|/* copy descriptor fields */
name|bep
operator|->
name|bLength
operator|=
name|aep
operator|->
name|desc
operator|.
name|bLength
expr_stmt|;
name|bep
operator|->
name|bDescriptorType
operator|=
name|aep
operator|->
name|desc
operator|.
name|bDescriptorType
expr_stmt|;
name|bep
operator|->
name|bEndpointAddress
operator|=
name|aep
operator|->
name|desc
operator|.
name|bEndpointAddress
expr_stmt|;
name|bep
operator|->
name|bmAttributes
operator|=
name|aep
operator|->
name|desc
operator|.
name|bmAttributes
expr_stmt|;
name|bep
operator|->
name|wMaxPacketSize
operator|=
name|aep
operator|->
name|desc
operator|.
name|wMaxPacketSize
expr_stmt|;
name|bep
operator|->
name|bInterval
operator|=
name|aep
operator|->
name|desc
operator|.
name|bInterval
expr_stmt|;
name|bep
operator|->
name|bRefresh
operator|=
name|aep
operator|->
name|desc
operator|.
name|bRefresh
expr_stmt|;
name|bep
operator|->
name|bSynchAddress
operator|=
name|aep
operator|->
name|desc
operator|.
name|bSynchAddress
expr_stmt|;
block|}
name|ps
operator|->
name|a
operator|.
name|currextra
operator|=
operator|&
name|aep
operator|->
name|extra
expr_stmt|;
name|usb_parse_extra
argument_list|(
name|ps
argument_list|,
operator|&
name|bep
operator|->
name|extra
argument_list|,
operator|&
name|bep
operator|->
name|extralen
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_parse_iface_sub
parameter_list|(
name|struct
name|usb_parse_state
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|libusb20_interface
modifier|*
name|aifc
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|bifc
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|aifc
operator|=
name|ps
operator|->
name|a
operator|.
name|currifc
expr_stmt|;
name|bifc
operator|=
name|ps
operator|->
name|b
operator|.
name|currifc
operator|++
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|preparse
operator|==
literal|0
condition|)
block|{
comment|/* copy descriptor fields */
name|bifc
operator|->
name|bLength
operator|=
name|aifc
operator|->
name|desc
operator|.
name|bLength
expr_stmt|;
name|bifc
operator|->
name|bDescriptorType
operator|=
name|aifc
operator|->
name|desc
operator|.
name|bDescriptorType
expr_stmt|;
name|bifc
operator|->
name|bInterfaceNumber
operator|=
name|aifc
operator|->
name|desc
operator|.
name|bInterfaceNumber
expr_stmt|;
name|bifc
operator|->
name|bAlternateSetting
operator|=
name|aifc
operator|->
name|desc
operator|.
name|bAlternateSetting
expr_stmt|;
name|bifc
operator|->
name|bNumEndpoints
operator|=
name|aifc
operator|->
name|num_endpoints
expr_stmt|;
name|bifc
operator|->
name|bInterfaceClass
operator|=
name|aifc
operator|->
name|desc
operator|.
name|bInterfaceClass
expr_stmt|;
name|bifc
operator|->
name|bInterfaceSubClass
operator|=
name|aifc
operator|->
name|desc
operator|.
name|bInterfaceSubClass
expr_stmt|;
name|bifc
operator|->
name|bInterfaceProtocol
operator|=
name|aifc
operator|->
name|desc
operator|.
name|bInterfaceProtocol
expr_stmt|;
name|bifc
operator|->
name|iInterface
operator|=
name|aifc
operator|->
name|desc
operator|.
name|iInterface
expr_stmt|;
name|bifc
operator|->
name|endpoint
operator|=
name|ps
operator|->
name|b
operator|.
name|currep
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|aifc
operator|->
name|num_endpoints
condition|;
name|x
operator|++
control|)
block|{
name|ps
operator|->
name|a
operator|.
name|currep
operator|=
name|aifc
operator|->
name|endpoints
operator|+
name|x
expr_stmt|;
name|usb_parse_endpoint
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
name|ps
operator|->
name|a
operator|.
name|currextra
operator|=
operator|&
name|aifc
operator|->
name|extra
expr_stmt|;
name|usb_parse_extra
argument_list|(
name|ps
argument_list|,
operator|&
name|bifc
operator|->
name|extra
argument_list|,
operator|&
name|bifc
operator|->
name|extralen
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_parse_iface
parameter_list|(
name|struct
name|usb_parse_state
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|libusb20_interface
modifier|*
name|aifc
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|bifc
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|aifc
operator|=
name|ps
operator|->
name|a
operator|.
name|currifc
expr_stmt|;
name|bifc
operator|=
name|ps
operator|->
name|b
operator|.
name|currifcw
operator|++
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|preparse
operator|==
literal|0
condition|)
block|{
comment|/* initialise interface wrapper */
name|bifc
operator|->
name|altsetting
operator|=
name|ps
operator|->
name|b
operator|.
name|currifc
expr_stmt|;
name|bifc
operator|->
name|num_altsetting
operator|=
name|aifc
operator|->
name|num_altsetting
operator|+
literal|1
expr_stmt|;
block|}
name|usb_parse_iface_sub
argument_list|(
name|ps
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|aifc
operator|->
name|num_altsetting
condition|;
name|x
operator|++
control|)
block|{
name|ps
operator|->
name|a
operator|.
name|currifc
operator|=
name|aifc
operator|->
name|altsetting
operator|+
name|x
expr_stmt|;
name|usb_parse_iface_sub
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_parse_config
parameter_list|(
name|struct
name|usb_parse_state
modifier|*
name|ps
parameter_list|)
block|{
name|struct
name|libusb20_config
modifier|*
name|acfg
decl_stmt|;
name|struct
name|usb_config_descriptor
modifier|*
name|bcfg
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
name|acfg
operator|=
name|ps
operator|->
name|a
operator|.
name|currcfg
expr_stmt|;
name|bcfg
operator|=
name|ps
operator|->
name|b
operator|.
name|currcfg
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|preparse
operator|==
literal|0
condition|)
block|{
comment|/* initialise config wrapper */
name|bcfg
operator|->
name|bLength
operator|=
name|acfg
operator|->
name|desc
operator|.
name|bLength
expr_stmt|;
name|bcfg
operator|->
name|bDescriptorType
operator|=
name|acfg
operator|->
name|desc
operator|.
name|bDescriptorType
expr_stmt|;
name|bcfg
operator|->
name|wTotalLength
operator|=
name|acfg
operator|->
name|desc
operator|.
name|wTotalLength
expr_stmt|;
name|bcfg
operator|->
name|bNumInterfaces
operator|=
name|acfg
operator|->
name|num_interface
expr_stmt|;
name|bcfg
operator|->
name|bConfigurationValue
operator|=
name|acfg
operator|->
name|desc
operator|.
name|bConfigurationValue
expr_stmt|;
name|bcfg
operator|->
name|iConfiguration
operator|=
name|acfg
operator|->
name|desc
operator|.
name|iConfiguration
expr_stmt|;
name|bcfg
operator|->
name|bmAttributes
operator|=
name|acfg
operator|->
name|desc
operator|.
name|bmAttributes
expr_stmt|;
name|bcfg
operator|->
name|MaxPower
operator|=
name|acfg
operator|->
name|desc
operator|.
name|bMaxPower
expr_stmt|;
name|bcfg
operator|->
name|interface
operator|=
name|ps
operator|->
name|b
operator|.
name|currifcw
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|acfg
operator|->
name|num_interface
condition|;
name|x
operator|++
control|)
block|{
name|ps
operator|->
name|a
operator|.
name|currifc
operator|=
name|acfg
operator|->
name|interface
operator|+
name|x
expr_stmt|;
name|usb_parse_iface
argument_list|(
name|ps
argument_list|)
expr_stmt|;
block|}
name|ps
operator|->
name|a
operator|.
name|currextra
operator|=
operator|&
name|acfg
operator|->
name|extra
expr_stmt|;
name|usb_parse_extra
argument_list|(
name|ps
argument_list|,
operator|&
name|bcfg
operator|->
name|extra
argument_list|,
operator|&
name|bcfg
operator|->
name|extralen
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|usb_parse_configuration
parameter_list|(
name|struct
name|usb_config_descriptor
modifier|*
name|config
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|)
block|{
name|struct
name|usb_parse_state
name|ps
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|uint32_t
name|a
decl_stmt|;
name|uint32_t
name|b
decl_stmt|;
name|uint32_t
name|c
decl_stmt|;
name|uint32_t
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|buffer
operator|==
name|NULL
operator|)
operator|||
operator|(
name|config
operator|==
name|NULL
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ps
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|.
name|a
operator|.
name|currcfg
operator|=
name|libusb20_parse_config_desc
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|ps
operator|.
name|b
operator|.
name|currcfg
operator|=
name|config
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|a
operator|.
name|currcfg
operator|==
name|NULL
condition|)
block|{
comment|/* could not parse config or out of memory */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* do the pre-parse */
name|ps
operator|.
name|preparse
operator|=
literal|1
expr_stmt|;
name|usb_parse_config
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ps
operator|.
name|b
operator|.
name|currifcw
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|)
expr_stmt|;
name|b
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ps
operator|.
name|b
operator|.
name|currifc
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ps
operator|.
name|b
operator|.
name|currep
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|)
expr_stmt|;
name|d
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|ps
operator|.
name|b
operator|.
name|currextra
operator|)
operator|-
operator|(
operator|(
name|uint8_t
operator|*
operator|)
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* allocate memory for our configuration */
name|ptr
operator|=
name|malloc
argument_list|(
name|a
operator|+
name|b
operator|+
name|c
operator|+
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
comment|/* free config structure */
name|free
argument_list|(
name|ps
operator|.
name|a
operator|.
name|currcfg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* "currifcw" must be first, hence this pointer is freed */
name|ps
operator|.
name|b
operator|.
name|currifcw
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ptr
operator|)
expr_stmt|;
name|ps
operator|.
name|b
operator|.
name|currifc
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ptr
operator|+
name|a
operator|)
expr_stmt|;
name|ps
operator|.
name|b
operator|.
name|currep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ptr
operator|+
name|a
operator|+
name|b
operator|)
expr_stmt|;
name|ps
operator|.
name|b
operator|.
name|currextra
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ptr
operator|+
name|a
operator|+
name|b
operator|+
name|c
operator|)
expr_stmt|;
comment|/* generate a libusb v0.1 compatible structure */
name|ps
operator|.
name|preparse
operator|=
literal|0
expr_stmt|;
name|usb_parse_config
argument_list|(
operator|&
name|ps
argument_list|)
expr_stmt|;
comment|/* free config structure */
name|free
argument_list|(
name|ps
operator|.
name|a
operator|.
name|currcfg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
name|void
name|usb_destroy_configuration
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|)
block|{
name|uint8_t
name|c
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|config
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|!=
name|dev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
condition|;
name|c
operator|++
control|)
block|{
name|struct
name|usb_config_descriptor
modifier|*
name|cf
init|=
operator|&
name|dev
operator|->
name|config
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|cf
operator|->
name|interface
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cf
operator|->
name|interface
argument_list|)
expr_stmt|;
name|cf
operator|->
name|interface
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|dev
operator|->
name|config
argument_list|)
expr_stmt|;
name|dev
operator|->
name|config
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|usb_fetch_and_parse_descriptors
parameter_list|(
name|usb_dev_handle
modifier|*
name|udev
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|libusb20_device
modifier|*
name|pdev
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|uint8_t
name|x
decl_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
block|{
comment|/* be NULL safe */
return|return;
block|}
name|dev
operator|=
name|usb_device
argument_list|(
name|udev
argument_list|)
expr_stmt|;
name|pdev
operator|=
operator|(
name|void
operator|*
operator|)
name|udev
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
operator|==
literal|0
condition|)
block|{
comment|/* invalid device */
return|return;
block|}
name|size
operator|=
name|dev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|usb_config_descriptor
argument_list|)
expr_stmt|;
name|dev
operator|->
name|config
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|config
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return;
block|}
name|memset
argument_list|(
name|dev
operator|->
name|config
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|dev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
condition|;
name|x
operator|++
control|)
block|{
name|error
operator|=
call|(
name|pdev
operator|->
name|methods
operator|->
name|get_config_desc_full
call|)
argument_list|(
name|pdev
argument_list|,
operator|&
name|ptr
argument_list|,
operator|&
name|len
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|usb_destroy_configuration
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|usb_parse_configuration
argument_list|(
name|dev
operator|->
name|config
operator|+
name|x
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* free config buffer */
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|usb_std_io
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|ep
parameter_list|,
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|is_intr
parameter_list|)
block|{
name|struct
name|libusb20_transfer
modifier|*
name|xfer
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|uint32_t
name|maxsize
decl_stmt|;
name|uint32_t
name|actlen
decl_stmt|;
name|char
modifier|*
name|oldbytes
decl_stmt|;
name|xfer
operator|=
name|usb_get_transfer_by_ep_no
argument_list|(
name|dev
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|libusb20_tr_pending
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
comment|/* there is already a transfer ongoing */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|maxsize
operator|=
name|libusb20_tr_get_max_total_length
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|oldbytes
operator|=
name|bytes
expr_stmt|;
comment|/* 	 * We allow transferring zero bytes which is the same 	 * equivalent to a zero length USB packet. 	 */
do|do
block|{
name|temp
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|maxsize
condition|)
block|{
comment|/* find maximum possible length */
name|temp
operator|=
name|maxsize
expr_stmt|;
block|}
if|if
condition|(
name|is_intr
condition|)
name|libusb20_tr_setup_intr
argument_list|(
name|xfer
argument_list|,
name|bytes
argument_list|,
name|temp
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
else|else
name|libusb20_tr_setup_bulk
argument_list|(
name|xfer
argument_list|,
name|bytes
argument_list|,
name|temp
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|libusb20_tr_start
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|libusb20_dev_process
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* device detached */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|libusb20_tr_pending
argument_list|(
name|xfer
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* transfer complete */
break|break;
block|}
comment|/* wait for USB event from kernel */
name|libusb20_dev_wait_process
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|libusb20_tr_get_status
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* success */
break|break;
case|case
name|LIBUSB20_TRANSFER_TIMED_OUT
case|:
comment|/* transfer timeout */
return|return
operator|(
operator|-
name|ETIMEDOUT
operator|)
return|;
default|default:
comment|/* other transfer error */
return|return
operator|(
operator|-
name|ENXIO
operator|)
return|;
block|}
name|actlen
operator|=
name|libusb20_tr_get_actual_length
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|actlen
expr_stmt|;
name|size
operator|-=
name|actlen
expr_stmt|;
if|if
condition|(
name|actlen
operator|!=
name|temp
condition|)
block|{
comment|/* short transfer */
break|break;
block|}
block|}
do|while
condition|(
name|size
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|bytes
operator|-
name|oldbytes
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_bulk_write
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|ep
parameter_list|,
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
return|return
operator|(
name|usb_std_io
argument_list|(
name|dev
argument_list|,
name|ep
operator|&
operator|~
name|USB_ENDPOINT_DIR_MASK
argument_list|,
name|bytes
argument_list|,
name|size
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_bulk_read
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|ep
parameter_list|,
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
return|return
operator|(
name|usb_std_io
argument_list|(
name|dev
argument_list|,
name|ep
operator||
name|USB_ENDPOINT_DIR_MASK
argument_list|,
name|bytes
argument_list|,
name|size
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_interrupt_write
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|ep
parameter_list|,
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
return|return
operator|(
name|usb_std_io
argument_list|(
name|dev
argument_list|,
name|ep
operator|&
operator|~
name|USB_ENDPOINT_DIR_MASK
argument_list|,
name|bytes
argument_list|,
name|size
argument_list|,
name|timeout
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_interrupt_read
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|ep
parameter_list|,
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
return|return
operator|(
name|usb_std_io
argument_list|(
name|dev
argument_list|,
name|ep
operator||
name|USB_ENDPOINT_DIR_MASK
argument_list|,
name|bytes
argument_list|,
name|size
argument_list|,
name|timeout
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_control_msg
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|requesttype
parameter_list|,
name|int
name|request
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|wIndex
parameter_list|,
name|char
modifier|*
name|bytes
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|LIBUSB20_CONTROL_SETUP_DECODED
name|req
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint16_t
name|actlen
decl_stmt|;
name|LIBUSB20_INIT
argument_list|(
name|LIBUSB20_CONTROL_SETUP
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|requesttype
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|request
expr_stmt|;
name|req
operator|.
name|wValue
operator|=
name|value
expr_stmt|;
name|req
operator|.
name|wIndex
operator|=
name|wIndex
expr_stmt|;
name|req
operator|.
name|wLength
operator|=
name|size
expr_stmt|;
name|err
operator|=
name|libusb20_dev_request_sync
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|,
operator|&
name|req
argument_list|,
name|bytes
argument_list|,
operator|&
name|actlen
argument_list|,
name|timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|actlen
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_set_configuration
parameter_list|(
name|usb_dev_handle
modifier|*
name|udev
parameter_list|,
name|int
name|bConfigurationValue
parameter_list|)
block|{
name|struct
name|usb_device
modifier|*
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
comment|/* 	 * Need to translate from "bConfigurationValue" to 	 * configuration index: 	 */
if|if
condition|(
name|bConfigurationValue
operator|==
literal|0
condition|)
block|{
comment|/* unconfigure */
name|i
operator|=
literal|255
expr_stmt|;
block|}
else|else
block|{
comment|/* lookup configuration index */
name|dev
operator|=
name|usb_device
argument_list|(
name|udev
argument_list|)
expr_stmt|;
comment|/* check if the configuration array is not there */
if|if
condition|(
name|dev
operator|->
name|config
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|dev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
condition|)
block|{
comment|/* "bConfigurationValue" not found */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|config
operator|+
name|i
operator|)
operator|->
name|bConfigurationValue
operator|==
name|bConfigurationValue
condition|)
block|{
break|break;
block|}
block|}
block|}
name|err
operator|=
name|libusb20_dev_set_config_index
argument_list|(
operator|(
name|void
operator|*
operator|)
name|udev
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_claim_interface
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|interface
parameter_list|)
block|{
name|struct
name|libusb20_device
modifier|*
name|pdev
init|=
operator|(
name|void
operator|*
operator|)
name|dev
decl_stmt|;
name|pdev
operator|->
name|claimed_interface
operator|=
name|interface
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_release_interface
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|interface
parameter_list|)
block|{
comment|/* do nothing */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_set_altinterface
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|alternate
parameter_list|)
block|{
name|struct
name|libusb20_device
modifier|*
name|pdev
init|=
operator|(
name|void
operator|*
operator|)
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|iface
decl_stmt|;
name|iface
operator|=
name|pdev
operator|->
name|claimed_interface
expr_stmt|;
name|err
operator|=
name|libusb20_dev_set_alt_index
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|,
name|iface
argument_list|,
name|alternate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_resetep
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|ep
parameter_list|)
block|{
comment|/* emulate an endpoint reset through clear-STALL */
return|return
operator|(
name|usb_clear_halt
argument_list|(
name|dev
argument_list|,
name|ep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_clear_halt
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|ep
parameter_list|)
block|{
name|struct
name|libusb20_transfer
modifier|*
name|xfer
decl_stmt|;
name|xfer
operator|=
name|usb_get_transfer_by_ep_no
argument_list|(
name|dev
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|libusb20_tr_clear_stall_sync
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_reset
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|libusb20_dev_reset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Be compatible with LibUSB from sourceforge and close the 	 * handle after reset! 	 */
return|return
operator|(
name|usb_close
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_check_connected
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|libusb20_dev_check_connected
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|usb_strerror
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* TODO */
return|return
operator|(
literal|"Unknown error"
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usb_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* nothing to do */
return|return;
block|}
end_function

begin_function
name|void
name|usb_set_debug
parameter_list|(
name|int
name|level
parameter_list|)
block|{
comment|/* use kernel UGEN debugging if you need to see what is going on */
return|return;
block|}
end_function

begin_function
name|int
name|usb_find_busses
parameter_list|(
name|void
parameter_list|)
block|{
name|usb_busses
operator|=
operator|&
name|usb_global_bus
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_find_devices
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|libusb20_device
modifier|*
name|pdev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
decl_stmt|;
name|struct
name|LIBUSB20_DEVICE_DESC_DECODED
modifier|*
name|ddesc
decl_stmt|;
name|int
name|devnum
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* cleanup after last device search */
comment|/* close all opened devices, if any */
while|while
condition|(
operator|(
name|pdev
operator|=
name|libusb20_be_device_foreach
argument_list|(
name|usb_backend
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|udev
operator|=
name|pdev
operator|->
name|privLuData
expr_stmt|;
name|libusb20_be_dequeue_device
argument_list|(
name|usb_backend
argument_list|,
name|pdev
argument_list|)
expr_stmt|;
name|libusb20_dev_free
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|!=
name|NULL
condition|)
block|{
name|LIST_DEL
argument_list|(
name|usb_global_bus
operator|.
name|devices
argument_list|,
name|udev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|udev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* free old USB backend, if any */
name|libusb20_be_free
argument_list|(
name|usb_backend
argument_list|)
expr_stmt|;
comment|/* do a new backend device search */
name|usb_backend
operator|=
name|libusb20_be_alloc_default
argument_list|()
expr_stmt|;
if|if
condition|(
name|usb_backend
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* iterate all devices */
name|devnum
operator|=
literal|1
expr_stmt|;
name|pdev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|pdev
operator|=
name|libusb20_be_device_foreach
argument_list|(
name|usb_backend
argument_list|,
name|pdev
argument_list|)
operator|)
condition|)
block|{
name|udev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|udev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|==
name|NULL
condition|)
break|break;
name|memset
argument_list|(
name|udev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|udev
argument_list|)
argument_list|)
expr_stmt|;
name|udev
operator|->
name|bus
operator|=
operator|&
name|usb_global_bus
expr_stmt|;
name|snprintf
argument_list|(
name|udev
operator|->
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|filename
argument_list|)
argument_list|,
literal|"/dev/ugen%u.%u"
argument_list|,
name|libusb20_dev_get_bus_number
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|libusb20_dev_get_address
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|ddesc
operator|=
name|libusb20_dev_get_device_desc
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bLength
operator|=
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|descriptor
argument_list|)
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bDescriptorType
operator|=
name|ddesc
operator|->
name|bDescriptorType
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bcdUSB
operator|=
name|ddesc
operator|->
name|bcdUSB
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bDeviceClass
operator|=
name|ddesc
operator|->
name|bDeviceClass
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bDeviceSubClass
operator|=
name|ddesc
operator|->
name|bDeviceSubClass
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bDeviceProtocol
operator|=
name|ddesc
operator|->
name|bDeviceProtocol
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bMaxPacketSize0
operator|=
name|ddesc
operator|->
name|bMaxPacketSize0
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|idVendor
operator|=
name|ddesc
operator|->
name|idVendor
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|idProduct
operator|=
name|ddesc
operator|->
name|idProduct
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bcdDevice
operator|=
name|ddesc
operator|->
name|bcdDevice
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|iManufacturer
operator|=
name|ddesc
operator|->
name|iManufacturer
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|iProduct
operator|=
name|ddesc
operator|->
name|iProduct
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|iSerialNumber
operator|=
name|ddesc
operator|->
name|iSerialNumber
expr_stmt|;
name|udev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
operator|=
name|ddesc
operator|->
name|bNumConfigurations
expr_stmt|;
if|if
condition|(
name|udev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
operator|>
name|USB_MAXCONFIG
condition|)
block|{
comment|/* truncate number of configurations */
name|udev
operator|->
name|descriptor
operator|.
name|bNumConfigurations
operator|=
name|USB_MAXCONFIG
expr_stmt|;
block|}
name|udev
operator|->
name|devnum
operator|=
name|devnum
operator|++
expr_stmt|;
comment|/* link together the two structures */
name|udev
operator|->
name|dev
operator|=
name|pdev
expr_stmt|;
name|pdev
operator|->
name|privLuData
operator|=
name|udev
expr_stmt|;
name|err
operator|=
name|libusb20_dev_open
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* XXX get all config descriptors by default */
name|usb_fetch_and_parse_descriptors
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pdev
argument_list|)
expr_stmt|;
name|libusb20_dev_close
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
block|}
name|LIST_ADD
argument_list|(
name|usb_global_bus
operator|.
name|devices
argument_list|,
name|udev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|devnum
operator|-
literal|1
operator|)
return|;
comment|/* success */
block|}
end_function

begin_function
name|struct
name|usb_device
modifier|*
name|usb_device
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|libusb20_device
modifier|*
name|pdev
decl_stmt|;
name|pdev
operator|=
operator|(
name|void
operator|*
operator|)
name|dev
expr_stmt|;
return|return
operator|(
name|pdev
operator|->
name|privLuData
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|usb_bus
modifier|*
name|usb_get_busses
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|usb_busses
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_get_driver_np
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|interface
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|struct
name|libusb20_device
modifier|*
name|pdev
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|pdev
operator|=
operator|(
name|void
operator|*
operator|)
name|dev
expr_stmt|;
if|if
condition|(
name|pdev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|namelen
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|namelen
operator|>
literal|255
condition|)
name|namelen
operator|=
literal|255
expr_stmt|;
name|err
operator|=
name|libusb20_dev_get_iface_desc
argument_list|(
name|pdev
argument_list|,
name|interface
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* we only want the driver name */
name|ptr
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usb_detach_kernel_driver_np
parameter_list|(
name|usb_dev_handle
modifier|*
name|dev
parameter_list|,
name|int
name|interface
parameter_list|)
block|{
name|struct
name|libusb20_device
modifier|*
name|pdev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|pdev
operator|=
operator|(
name|void
operator|*
operator|)
name|dev
expr_stmt|;
if|if
condition|(
name|pdev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|libusb20_dev_detach_kernel_driver
argument_list|(
name|pdev
argument_list|,
name|interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

