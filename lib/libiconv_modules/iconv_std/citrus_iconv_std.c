begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: citrus_iconv_std.c,v 1.16 2012/02/12 13:51:29 wiz Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c)2003 Citrus Project,  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"citrus_namespace.h"
end_include

begin_include
include|#
directive|include
file|"citrus_types.h"
end_include

begin_include
include|#
directive|include
file|"citrus_module.h"
end_include

begin_include
include|#
directive|include
file|"citrus_region.h"
end_include

begin_include
include|#
directive|include
file|"citrus_mmap.h"
end_include

begin_include
include|#
directive|include
file|"citrus_hash.h"
end_include

begin_include
include|#
directive|include
file|"citrus_iconv.h"
end_include

begin_include
include|#
directive|include
file|"citrus_stdenc.h"
end_include

begin_include
include|#
directive|include
file|"citrus_mapper.h"
end_include

begin_include
include|#
directive|include
file|"citrus_csmapper.h"
end_include

begin_include
include|#
directive|include
file|"citrus_memstream.h"
end_include

begin_include
include|#
directive|include
file|"citrus_iconv_std.h"
end_include

begin_include
include|#
directive|include
file|"citrus_esdb.h"
end_include

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_expr_stmt
name|_CITRUS_ICONV_DECLS
argument_list|(
name|iconv_std
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_CITRUS_ICONV_DEF_OPS
argument_list|(
name|iconv_std
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|_citrus_iconv_std_iconv_getops
parameter_list|(
name|struct
name|_citrus_iconv_ops
modifier|*
name|ops
parameter_list|)
block|{
name|memcpy
argument_list|(
name|ops
argument_list|,
operator|&
name|_citrus_iconv_std_iconv_ops
argument_list|,
sizeof|sizeof
argument_list|(
name|_citrus_iconv_std_iconv_ops
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * convenience routines for stdenc.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|save_encoding_state
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_ps
condition|)
name|memcpy
argument_list|(
name|se
operator|->
name|se_pssaved
argument_list|,
name|se
operator|->
name|se_ps
argument_list|,
name|_stdenc_get_state_size
argument_list|(
name|se
operator|->
name|se_handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|restore_encoding_state
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_ps
condition|)
name|memcpy
argument_list|(
name|se
operator|->
name|se_ps
argument_list|,
name|se
operator|->
name|se_pssaved
argument_list|,
name|_stdenc_get_state_size
argument_list|(
name|se
operator|->
name|se_handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|init_encoding_state
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_ps
condition|)
name|_stdenc_init_state
argument_list|(
name|se
operator|->
name|se_handle
argument_list|,
name|se
operator|->
name|se_ps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|mbtocsx
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|,
name|_csid_t
modifier|*
name|csid
parameter_list|,
name|_index_t
modifier|*
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|,
name|size_t
modifier|*
name|nresult
parameter_list|,
name|struct
name|iconv_hooks
modifier|*
name|hooks
parameter_list|)
block|{
return|return
operator|(
name|_stdenc_mbtocs
argument_list|(
name|se
operator|->
name|se_handle
argument_list|,
name|csid
argument_list|,
name|idx
argument_list|,
name|s
argument_list|,
name|n
argument_list|,
name|se
operator|->
name|se_ps
argument_list|,
name|nresult
argument_list|,
name|hooks
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|cstombx
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|,
name|_csid_t
name|csid
parameter_list|,
name|_index_t
name|idx
parameter_list|,
name|size_t
modifier|*
name|nresult
parameter_list|,
name|struct
name|iconv_hooks
modifier|*
name|hooks
parameter_list|)
block|{
return|return
operator|(
name|_stdenc_cstomb
argument_list|(
name|se
operator|->
name|se_handle
argument_list|,
name|s
argument_list|,
name|n
argument_list|,
name|csid
argument_list|,
name|idx
argument_list|,
name|se
operator|->
name|se_ps
argument_list|,
name|nresult
argument_list|,
name|hooks
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|wctombx
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|,
name|_wc_t
name|wc
parameter_list|,
name|size_t
modifier|*
name|nresult
parameter_list|,
name|struct
name|iconv_hooks
modifier|*
name|hooks
parameter_list|)
block|{
return|return
operator|(
name|_stdenc_wctomb
argument_list|(
name|se
operator|->
name|se_handle
argument_list|,
name|s
argument_list|,
name|n
argument_list|,
name|wc
argument_list|,
name|se
operator|->
name|se_ps
argument_list|,
name|nresult
argument_list|,
name|hooks
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|put_state_resetx
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|,
name|size_t
modifier|*
name|nresult
parameter_list|)
block|{
return|return
operator|(
name|_stdenc_put_state_reset
argument_list|(
name|se
operator|->
name|se_handle
argument_list|,
name|s
argument_list|,
name|n
argument_list|,
name|se
operator|->
name|se_ps
argument_list|,
name|nresult
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|get_state_desc_gen
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|,
name|int
modifier|*
name|rstate
parameter_list|)
block|{
name|struct
name|_stdenc_state_desc
name|ssd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|_stdenc_get_state_desc
argument_list|(
name|se
operator|->
name|se_handle
argument_list|,
name|se
operator|->
name|se_ps
argument_list|,
name|_STDENC_SDID_GENERIC
argument_list|,
operator|&
name|ssd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|*
name|rstate
operator|=
name|ssd
operator|.
name|u
operator|.
name|generic
operator|.
name|state
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * init encoding context  */
end_comment

begin_function
specifier|static
name|int
name|init_encoding
parameter_list|(
name|struct
name|_citrus_iconv_std_encoding
modifier|*
name|se
parameter_list|,
name|struct
name|_stdenc
modifier|*
name|cs
parameter_list|,
name|void
modifier|*
name|ps1
parameter_list|,
name|void
modifier|*
name|ps2
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|se
operator|->
name|se_handle
operator|=
name|cs
expr_stmt|;
name|se
operator|->
name|se_ps
operator|=
name|ps1
expr_stmt|;
name|se
operator|->
name|se_pssaved
operator|=
name|ps2
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_ps
condition|)
name|ret
operator|=
name|_stdenc_init_state
argument_list|(
name|cs
argument_list|,
name|se
operator|->
name|se_ps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|se
operator|->
name|se_pssaved
condition|)
name|ret
operator|=
name|_stdenc_init_state
argument_list|(
name|cs
argument_list|,
name|se
operator|->
name|se_pssaved
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|open_csmapper
parameter_list|(
name|struct
name|_csmapper
modifier|*
modifier|*
name|rcm
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|unsigned
name|long
modifier|*
name|rnorm
parameter_list|)
block|{
name|struct
name|_csmapper
modifier|*
name|cm
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|_csmapper_open
argument_list|(
operator|&
name|cm
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
name|rnorm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|_csmapper_get_src_max
argument_list|(
name|cm
argument_list|)
operator|!=
literal|1
operator|||
name|_csmapper_get_dst_max
argument_list|(
name|cm
argument_list|)
operator|!=
literal|1
operator|||
name|_csmapper_get_state_size
argument_list|(
name|cm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_csmapper_close
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|rcm
operator|=
name|cm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_dsts
parameter_list|(
name|struct
name|_citrus_iconv_std_dst_list
modifier|*
name|dl
parameter_list|)
block|{
name|struct
name|_citrus_iconv_std_dst
modifier|*
name|sd
decl_stmt|;
while|while
condition|(
operator|(
name|sd
operator|=
name|TAILQ_FIRST
argument_list|(
name|dl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|dl
argument_list|,
name|sd
argument_list|,
name|sd_entry
argument_list|)
expr_stmt|;
name|_csmapper_close
argument_list|(
name|sd
operator|->
name|sd_mapper
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|open_dsts
parameter_list|(
name|struct
name|_citrus_iconv_std_dst_list
modifier|*
name|dl
parameter_list|,
specifier|const
name|struct
name|_esdb_charset
modifier|*
name|ec
parameter_list|,
specifier|const
name|struct
name|_esdb
modifier|*
name|dbdst
parameter_list|)
block|{
name|struct
name|_citrus_iconv_std_dst
modifier|*
name|sd
decl_stmt|,
modifier|*
name|sdtmp
decl_stmt|;
name|unsigned
name|long
name|norm
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|sd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbdst
operator|->
name|db_num_charsets
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|open_csmapper
argument_list|(
operator|&
name|sd
operator|->
name|sd_mapper
argument_list|,
name|ec
operator|->
name|ec_csname
argument_list|,
name|dbdst
operator|->
name|db_charsets
index|[
name|i
index|]
operator|.
name|ec_csname
argument_list|,
operator|&
name|norm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|sd
operator|->
name|sd_csid
operator|=
name|dbdst
operator|->
name|db_charsets
index|[
name|i
index|]
operator|.
name|ec_csid
expr_stmt|;
name|sd
operator|->
name|sd_norm
operator|=
name|norm
expr_stmt|;
comment|/* insert this mapper by sorted order. */
name|TAILQ_FOREACH
argument_list|(
argument|sdtmp
argument_list|,
argument|dl
argument_list|,
argument|sd_entry
argument_list|)
block|{
if|if
condition|(
name|sdtmp
operator|->
name|sd_norm
operator|>
name|norm
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|sdtmp
argument_list|,
name|sd
argument_list|,
name|sd_entry
argument_list|)
expr_stmt|;
name|sd
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sd
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
name|dl
argument_list|,
name|sd
argument_list|,
name|sd_entry
argument_list|)
expr_stmt|;
name|sd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
name|close_dsts
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|ENOENT
condition|)
block|{
name|close_dsts
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|sd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_srcs
parameter_list|(
name|struct
name|_citrus_iconv_std_src_list
modifier|*
name|sl
parameter_list|)
block|{
name|struct
name|_citrus_iconv_std_src
modifier|*
name|ss
decl_stmt|;
while|while
condition|(
operator|(
name|ss
operator|=
name|TAILQ_FIRST
argument_list|(
name|sl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|sl
argument_list|,
name|ss
argument_list|,
name|ss_entry
argument_list|)
expr_stmt|;
name|close_dsts
argument_list|(
operator|&
name|ss
operator|->
name|ss_dsts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|open_srcs
parameter_list|(
name|struct
name|_citrus_iconv_std_src_list
modifier|*
name|sl
parameter_list|,
specifier|const
name|struct
name|_esdb
modifier|*
name|dbsrc
parameter_list|,
specifier|const
name|struct
name|_esdb
modifier|*
name|dbdst
parameter_list|)
block|{
name|struct
name|_citrus_iconv_std_src
modifier|*
name|ss
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|ss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ss
operator|->
name|ss_dsts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbsrc
operator|->
name|db_num_charsets
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|open_dsts
argument_list|(
operator|&
name|ss
operator|->
name|ss_dsts
argument_list|,
operator|&
name|dbsrc
operator|->
name|db_charsets
index|[
name|i
index|]
argument_list|,
name|dbdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ss
operator|->
name|ss_dsts
argument_list|)
condition|)
block|{
name|ss
operator|->
name|ss_csid
operator|=
name|dbsrc
operator|->
name|db_charsets
index|[
name|i
index|]
operator|.
name|ec_csid
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|sl
argument_list|,
name|ss
argument_list|,
name|ss_entry
argument_list|)
expr_stmt|;
name|ss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|count
operator|++
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ss
operator|->
name|ss_dsts
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
condition|?
literal|0
else|:
name|ENOENT
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|close_srcs
argument_list|(
name|sl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* do convert a character */
end_comment

begin_define
define|#
directive|define
name|E_NO_CORRESPONDING_CHAR
value|ENOENT
end_define

begin_comment
comment|/* XXX */
end_comment

begin_function
specifier|static
name|int
comment|/*ARGSUSED*/
name|do_conv
parameter_list|(
specifier|const
name|struct
name|_citrus_iconv_std_shared
modifier|*
name|is
parameter_list|,
name|_csid_t
modifier|*
name|csid
parameter_list|,
name|_index_t
modifier|*
name|idx
parameter_list|)
block|{
name|struct
name|_citrus_iconv_std_dst
modifier|*
name|sd
decl_stmt|;
name|struct
name|_citrus_iconv_std_src
modifier|*
name|ss
decl_stmt|;
name|_index_t
name|tmpidx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ss
argument_list|,
argument|&is->is_srcs
argument_list|,
argument|ss_entry
argument_list|)
block|{
if|if
condition|(
name|ss
operator|->
name|ss_csid
operator|==
operator|*
name|csid
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&ss->ss_dsts
argument_list|,
argument|sd_entry
argument_list|)
block|{
name|ret
operator|=
name|_csmapper_convert
argument_list|(
name|sd
operator|->
name|sd_mapper
argument_list|,
operator|&
name|tmpidx
argument_list|,
operator|*
name|idx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|_MAPPER_CONVERT_SUCCESS
case|:
operator|*
name|csid
operator|=
name|sd
operator|->
name|sd_csid
expr_stmt|;
operator|*
name|idx
operator|=
name|tmpidx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_MAPPER_CONVERT_NONIDENTICAL
case|:
break|break;
case|case
name|_MAPPER_CONVERT_SRC_MORE
case|:
comment|/*FALLTHROUGH*/
case|case
name|_MAPPER_CONVERT_DST_MORE
case|:
comment|/*FALLTHROUGH*/
case|case
name|_MAPPER_CONVERT_ILSEQ
case|:
return|return
operator|(
name|EILSEQ
operator|)
return|;
case|case
name|_MAPPER_CONVERT_FATAL
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
break|break;
block|}
block|}
return|return
operator|(
name|E_NO_CORRESPONDING_CHAR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
comment|/*ARGSUSED*/
name|_citrus_iconv_std_iconv_init_shared
parameter_list|(
name|struct
name|_citrus_iconv_shared
modifier|*
name|ci
parameter_list|,
specifier|const
name|char
modifier|*
name|__restrict
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|__restrict
name|dst
parameter_list|)
block|{
name|struct
name|_citrus_esdb
name|esdbdst
decl_stmt|,
name|esdbsrc
decl_stmt|;
name|struct
name|_citrus_iconv_std_shared
modifier|*
name|is
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|is
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|is
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
name|ret
operator|=
name|_citrus_esdb_open
argument_list|(
operator|&
name|esdbsrc
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err1
goto|;
name|ret
operator|=
name|_citrus_esdb_open
argument_list|(
operator|&
name|esdbdst
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err2
goto|;
name|ret
operator|=
name|_stdenc_open
argument_list|(
operator|&
name|is
operator|->
name|is_src_encoding
argument_list|,
name|esdbsrc
operator|.
name|db_encname
argument_list|,
name|esdbsrc
operator|.
name|db_variable
argument_list|,
name|esdbsrc
operator|.
name|db_len_variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err3
goto|;
name|ret
operator|=
name|_stdenc_open
argument_list|(
operator|&
name|is
operator|->
name|is_dst_encoding
argument_list|,
name|esdbdst
operator|.
name|db_encname
argument_list|,
name|esdbdst
operator|.
name|db_variable
argument_list|,
name|esdbdst
operator|.
name|db_len_variable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err4
goto|;
name|is
operator|->
name|is_use_invalid
operator|=
name|esdbdst
operator|.
name|db_use_invalid
expr_stmt|;
name|is
operator|->
name|is_invalid
operator|=
name|esdbdst
operator|.
name|db_invalid
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|is
operator|->
name|is_srcs
argument_list|)
expr_stmt|;
name|ret
operator|=
name|open_srcs
argument_list|(
operator|&
name|is
operator|->
name|is_srcs
argument_list|,
operator|&
name|esdbsrc
argument_list|,
operator|&
name|esdbdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err5
goto|;
name|_esdb_close
argument_list|(
operator|&
name|esdbsrc
argument_list|)
expr_stmt|;
name|_esdb_close
argument_list|(
operator|&
name|esdbdst
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ci_closure
operator|=
name|is
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err5
label|:
name|_stdenc_close
argument_list|(
name|is
operator|->
name|is_dst_encoding
argument_list|)
expr_stmt|;
name|err4
label|:
name|_stdenc_close
argument_list|(
name|is
operator|->
name|is_src_encoding
argument_list|)
expr_stmt|;
name|err3
label|:
name|_esdb_close
argument_list|(
operator|&
name|esdbdst
argument_list|)
expr_stmt|;
name|err2
label|:
name|_esdb_close
argument_list|(
operator|&
name|esdbsrc
argument_list|)
expr_stmt|;
name|err1
label|:
name|free
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|err0
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_citrus_iconv_std_iconv_uninit_shared
parameter_list|(
name|struct
name|_citrus_iconv_shared
modifier|*
name|ci
parameter_list|)
block|{
name|struct
name|_citrus_iconv_std_shared
modifier|*
name|is
init|=
name|ci
operator|->
name|ci_closure
decl_stmt|;
if|if
condition|(
name|is
operator|==
name|NULL
condition|)
return|return;
name|_stdenc_close
argument_list|(
name|is
operator|->
name|is_src_encoding
argument_list|)
expr_stmt|;
name|_stdenc_close
argument_list|(
name|is
operator|->
name|is_dst_encoding
argument_list|)
expr_stmt|;
name|close_srcs
argument_list|(
operator|&
name|is
operator|->
name|is_srcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_citrus_iconv_std_iconv_init_context
parameter_list|(
name|struct
name|_citrus_iconv
modifier|*
name|cv
parameter_list|)
block|{
specifier|const
name|struct
name|_citrus_iconv_std_shared
modifier|*
name|is
init|=
name|cv
operator|->
name|cv_shared
operator|->
name|ci_closure
decl_stmt|;
name|struct
name|_citrus_iconv_std_context
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|szpsdst
decl_stmt|,
name|szpssrc
decl_stmt|;
name|szpssrc
operator|=
name|_stdenc_get_state_size
argument_list|(
name|is
operator|->
name|is_src_encoding
argument_list|)
expr_stmt|;
name|szpsdst
operator|=
name|_stdenc_get_state_size
argument_list|(
name|is
operator|->
name|is_dst_encoding
argument_list|)
expr_stmt|;
name|sz
operator|=
operator|(
name|szpssrc
operator|+
name|szpsdst
operator|)
operator|*
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_citrus_iconv_std_context
argument_list|)
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|szpssrc
operator|>
literal|0
condition|)
name|init_encoding
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|,
name|is
operator|->
name|is_src_encoding
argument_list|,
name|ptr
argument_list|,
name|ptr
operator|+
name|szpssrc
argument_list|)
expr_stmt|;
else|else
name|init_encoding
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|,
name|is
operator|->
name|is_src_encoding
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|szpssrc
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|szpsdst
operator|>
literal|0
condition|)
name|init_encoding
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|,
name|is
operator|->
name|is_dst_encoding
argument_list|,
name|ptr
argument_list|,
name|ptr
operator|+
name|szpsdst
argument_list|)
expr_stmt|;
else|else
name|init_encoding
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|,
name|is
operator|->
name|is_dst_encoding
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv
operator|->
name|cv_closure
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_citrus_iconv_std_iconv_uninit_context
parameter_list|(
name|struct
name|_citrus_iconv
modifier|*
name|cv
parameter_list|)
block|{
name|free
argument_list|(
name|cv
operator|->
name|cv_closure
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_citrus_iconv_std_iconv_convert
parameter_list|(
name|struct
name|_citrus_iconv
modifier|*
name|__restrict
name|cv
parameter_list|,
specifier|const
name|char
modifier|*
name|__restrict
modifier|*
name|__restrict
name|in
parameter_list|,
name|size_t
modifier|*
name|__restrict
name|inbytes
parameter_list|,
name|char
modifier|*
name|__restrict
modifier|*
name|__restrict
name|out
parameter_list|,
name|size_t
modifier|*
name|__restrict
name|outbytes
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|size_t
modifier|*
name|__restrict
name|invalids
parameter_list|)
block|{
specifier|const
name|struct
name|_citrus_iconv_std_shared
modifier|*
name|is
init|=
name|cv
operator|->
name|cv_shared
operator|->
name|ci_closure
decl_stmt|;
name|struct
name|_citrus_iconv_std_context
modifier|*
name|sc
init|=
name|cv
operator|->
name|cv_closure
decl_stmt|;
name|_csid_t
name|csid
decl_stmt|;
name|_index_t
name|idx
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmpin
decl_stmt|;
name|size_t
name|inval
decl_stmt|,
name|szrin
decl_stmt|,
name|szrout
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|state
init|=
literal|0
decl_stmt|;
name|inval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
operator|*
name|in
operator|==
name|NULL
condition|)
block|{
comment|/* special cases */
if|if
condition|(
name|out
operator|!=
name|NULL
operator|&&
operator|*
name|out
operator|!=
name|NULL
condition|)
block|{
comment|/* init output state and store the shift sequence */
name|save_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|)
expr_stmt|;
name|save_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|)
expr_stmt|;
name|szrout
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|put_state_resetx
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|,
operator|*
name|out
argument_list|,
operator|*
name|outbytes
argument_list|,
operator|&
name|szrout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|szrout
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
comment|/* too small to store the character */
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|out
operator|+=
name|szrout
expr_stmt|;
operator|*
name|outbytes
operator|-=
name|szrout
expr_stmt|;
block|}
else|else
comment|/* otherwise, discard the shift sequence */
name|init_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|)
expr_stmt|;
name|init_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|)
expr_stmt|;
operator|*
name|invalids
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* normal case */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|inbytes
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|get_state_desc_gen
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|_STDENC_SDGEN_INITIAL
operator|||
name|state
operator|==
name|_STDENC_SDGEN_STABLE
condition|)
break|break;
block|}
comment|/* save the encoding states for the error recovery */
name|save_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|)
expr_stmt|;
name|save_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|)
expr_stmt|;
comment|/* mb -> csid/index */
name|tmpin
operator|=
operator|*
name|in
expr_stmt|;
name|szrin
operator|=
name|szrout
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|mbtocsx
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|,
operator|&
name|csid
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|tmpin
argument_list|,
operator|*
name|inbytes
argument_list|,
operator|&
name|szrin
argument_list|,
name|cv
operator|->
name|cv_shared
operator|->
name|ci_hooks
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|szrin
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
comment|/* incompleted character */
name|ret
operator|=
name|get_state_desc_gen
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|_STDENC_SDGEN_INITIAL
case|:
case|case
name|_STDENC_SDGEN_STABLE
case|:
comment|/* fetch shift sequences only. */
goto|goto
name|next
goto|;
block|}
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* convert the character */
name|ret
operator|=
name|do_conv
argument_list|(
name|is
argument_list|,
operator|&
name|csid
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|E_NO_CORRESPONDING_CHAR
condition|)
block|{
comment|/* 				 * GNU iconv returns EILSEQ when no 				 * corresponding character in the output. 				 * Some software depends on this behavior 				 * though this is against POSIX specification. 				 */
if|if
condition|(
name|cv
operator|->
name|cv_shared
operator|->
name|ci_ilseq_invalid
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|EILSEQ
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|inval
operator|++
expr_stmt|;
name|szrout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|flags
operator|&
name|_CITRUS_ICONV_F_HIDE_INVALID
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|cv
operator|->
name|cv_shared
operator|->
name|ci_discard_ilseq
operator|)
operator|&&
name|is
operator|->
name|is_use_invalid
condition|)
block|{
name|ret
operator|=
name|wctombx
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|,
operator|*
name|out
argument_list|,
operator|*
name|outbytes
argument_list|,
name|is
operator|->
name|is_invalid
argument_list|,
operator|&
name|szrout
argument_list|,
name|cv
operator|->
name|cv_shared
operator|->
name|ci_hooks
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
block|}
goto|goto
name|next
goto|;
block|}
else|else
goto|goto
name|err
goto|;
block|}
comment|/* csid/index -> mb */
name|ret
operator|=
name|cstombx
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|,
operator|*
name|out
argument_list|,
operator|*
name|outbytes
argument_list|,
name|csid
argument_list|,
name|idx
argument_list|,
operator|&
name|szrout
argument_list|,
name|cv
operator|->
name|cv_shared
operator|->
name|ci_hooks
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err
goto|;
name|next
label|:
operator|*
name|inbytes
operator|-=
name|tmpin
operator|-
operator|*
name|in
expr_stmt|;
comment|/* szrin is insufficient on \0. */
operator|*
name|in
operator|=
name|tmpin
expr_stmt|;
operator|*
name|outbytes
operator|-=
name|szrout
expr_stmt|;
operator|*
name|out
operator|+=
name|szrout
expr_stmt|;
block|}
operator|*
name|invalids
operator|=
name|inval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|restore_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_src_encoding
argument_list|)
expr_stmt|;
name|restore_encoding_state
argument_list|(
operator|&
name|sc
operator|->
name|sc_dst_encoding
argument_list|)
expr_stmt|;
operator|*
name|invalids
operator|=
name|inval
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

