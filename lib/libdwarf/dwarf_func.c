begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2009, 2011, Juniper Networks, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  *  *	JNPR: dwarf_func.c 336441 2009-10-17 09:19:54Z deo  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<libdwarf.h>
end_include

begin_include
include|#
directive|include
file|<_libdwarf.h>
end_include

begin_function
specifier|static
name|void
name|dwarf_add_function
parameter_list|(
name|Dwarf_Debug
name|dbg
parameter_list|,
name|Dwarf_Func
name|func
parameter_list|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dbg
operator|->
name|dbg_func
argument_list|,
name|func
argument_list|,
name|func_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dwarf_function_get_addr_range
parameter_list|(
name|Dwarf_Func
name|f
parameter_list|,
name|Dwarf_Addr
modifier|*
name|low_pc
parameter_list|,
name|Dwarf_Addr
modifier|*
name|high_pc
parameter_list|)
block|{
operator|*
name|low_pc
operator|=
name|f
operator|->
name|func_low_pc
expr_stmt|;
operator|*
name|high_pc
operator|=
name|f
operator|->
name|func_high_pc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dwarf_inlined_function_get_addr_range
parameter_list|(
name|Dwarf_Inlined_Func
name|f
parameter_list|,
name|Dwarf_Addr
modifier|*
name|low_pc
parameter_list|,
name|Dwarf_Addr
modifier|*
name|high_pc
parameter_list|)
block|{
operator|*
name|low_pc
operator|=
name|f
operator|->
name|ifunc_low_pc
expr_stmt|;
operator|*
name|high_pc
operator|=
name|f
operator|->
name|ifunc_high_pc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dwarf_function_is_inlined
parameter_list|(
name|Dwarf_Func
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|func_is_inlined
operator|==
name|DW_INL_inlined
operator|||
name|f
operator|->
name|func_is_inlined
operator|==
name|DW_INL_declared_inlined
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|Dwarf_Func
name|dwarf_find_function_by_name
parameter_list|(
name|Dwarf_Debug
name|dbg
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* XXX: replace with a fast version */
name|Dwarf_Func
name|func
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|func
argument_list|,
argument|&dbg->dbg_func
argument_list|,
argument|func_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|func
operator|->
name|func_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|func
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Dwarf_Func
name|dwarf_find_function_by_offset
parameter_list|(
name|Dwarf_Debug
name|dbg
parameter_list|,
name|Dwarf_Off
name|off
parameter_list|)
block|{
name|Dwarf_Func
name|func
decl_stmt|;
name|Dwarf_Die
name|die
decl_stmt|;
comment|/* printf("look for %llx\n", off); */
name|STAILQ_FOREACH
argument_list|(
argument|func
argument_list|,
argument|&dbg->dbg_func
argument_list|,
argument|func_next
argument_list|)
block|{
name|die
operator|=
name|func
operator|->
name|func_die
expr_stmt|;
if|if
condition|(
operator|(
name|off_t
operator|)
name|die
operator|->
name|die_offset
operator|==
name|off
condition|)
block|{
return|return
name|func
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|dwarf_build_function_table
parameter_list|(
name|Dwarf_Debug
name|dbg
parameter_list|)
block|{
name|Dwarf_CU
name|cu
decl_stmt|;
name|Dwarf_AttrValue
name|av
decl_stmt|;
name|Dwarf_Die
name|die
decl_stmt|,
name|origin_die
decl_stmt|;
name|Dwarf_Func
name|func
decl_stmt|,
name|origin_func
decl_stmt|;
name|Dwarf_Inlined_Func
name|ifunc
decl_stmt|;
name|unsigned
name|long
name|long
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Dwarf_Error
name|error
decl_stmt|;
comment|/* 	 * find out all the functions 	 */
name|STAILQ_FOREACH
argument_list|(
argument|cu
argument_list|,
argument|&dbg->dbg_cu
argument_list|,
argument|cu_next
argument_list|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|die
argument_list|,
argument|&cu->cu_die
argument_list|,
argument|die_next
argument_list|)
block|{
if|if
condition|(
name|die
operator|->
name|die_a
operator|->
name|a_tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
comment|/* 				 * Some function has multiple entries, i.e. 				 * if a function is inlined, it has many 				 * abstract/concrete instances, the abstract 				 * instances are with DW_TAG_subprogram. 				 */
name|dwarf_attrval_string
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|func
operator|=
name|dwarf_find_function_by_name
argument_list|(
name|dbg
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|func
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_Dwarf_Func
argument_list|)
argument_list|)
expr_stmt|;
name|DWARF_ASSERT
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|func
operator|->
name|func_die
operator|=
name|die
expr_stmt|;
name|func
operator|->
name|func_name
operator|=
name|name
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|func
operator|->
name|func_inlined_instances
argument_list|)
expr_stmt|;
name|dwarf_add_function
argument_list|(
name|dbg
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|av
argument_list|,
argument|&die->die_attrval
argument_list|,
argument|av_next
argument_list|)
block|{
switch|switch
condition|(
name|av
operator|->
name|av_attrib
condition|)
block|{
case|case
name|DW_AT_low_pc
case|:
name|func
operator|->
name|func_low_pc
operator|=
name|av
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|u64
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|func
operator|->
name|func_high_pc
operator|=
name|av
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|u64
expr_stmt|;
break|break;
case|case
name|DW_AT_inline
case|:
name|func
operator|->
name|func_is_inlined
operator|=
name|av
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|u64
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* 	 * Now check the concrete inlined instances. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|cu
argument_list|,
argument|&dbg->dbg_cu
argument_list|,
argument|cu_next
argument_list|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|die
argument_list|,
argument|&cu->cu_die
argument_list|,
argument|die_next
argument_list|)
block|{
if|if
condition|(
name|die
operator|->
name|die_a
operator|->
name|a_tag
operator|==
name|DW_TAG_inlined_subroutine
condition|)
block|{
name|ifunc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_Dwarf_Inlined_Func
argument_list|)
argument_list|)
expr_stmt|;
name|DWARF_ASSERT
argument_list|(
name|ifunc
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|av
argument_list|,
argument|&die->die_attrval
argument_list|,
argument|av_next
argument_list|)
block|{
switch|switch
condition|(
name|av
operator|->
name|av_attrib
condition|)
block|{
case|case
name|DW_AT_abstract_origin
case|:
name|offset
operator|=
name|av
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|u64
operator|+
name|die
operator|->
name|die_cu
operator|->
name|cu_offset
expr_stmt|;
name|origin_die
operator|=
name|dwarf_die_find
argument_list|(
name|die
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|DWARF_ASSERT
argument_list|(
name|origin_die
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 						 * the abstract origin must 						 * have been merged with 						 * another die 						 */
name|dwarf_attrval_string
argument_list|(
name|origin_die
argument_list|,
name|DW_AT_name
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|origin_func
operator|=
name|dwarf_find_function_by_name
argument_list|(
name|dbg
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DWARF_ASSERT
argument_list|(
name|origin_func
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|origin_func
operator|->
name|func_inlined_instances
argument_list|,
name|ifunc
argument_list|,
name|ifunc_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|ifunc
operator|->
name|ifunc_low_pc
operator|=
name|av
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|u64
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|ifunc
operator|->
name|ifunc_high_pc
operator|=
name|av
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|u64
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|dwarf_function_iterate_inlined_instance
parameter_list|(
name|Dwarf_Func
name|func
parameter_list|,
name|Dwarf_Inlined_Callback
name|f
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Dwarf_Inlined_Func
name|ifunc
decl_stmt|;
if|if
condition|(
operator|!
name|dwarf_function_is_inlined
argument_list|(
name|func
argument_list|)
condition|)
return|return;
name|STAILQ_FOREACH
argument_list|(
argument|ifunc
argument_list|,
argument|&func->func_inlined_instances
argument_list|,
argument|ifunc_next
argument_list|)
block|{
name|f
argument_list|(
name|ifunc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

