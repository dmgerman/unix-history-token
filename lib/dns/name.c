begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2008  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: name.c,v 1.165 2008/04/01 23:47:10 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/hash.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/thread.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/compress.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_define
define|#
directive|define
name|VALID_NAME
parameter_list|(
name|n
parameter_list|)
value|ISC_MAGIC_VALID(n, DNS_NAME_MAGIC)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|ft_init
init|=
literal|0
block|,
name|ft_start
block|,
name|ft_ordinary
block|,
name|ft_initialescape
block|,
name|ft_escape
block|,
name|ft_escdecimal
block|,
name|ft_at
block|}
name|ft_state
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|fw_start
init|=
literal|0
block|,
name|fw_ordinary
block|,
name|fw_copy
block|,
name|fw_newcurrent
block|}
name|fw_state
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|digitvalue
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*16*/
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*32*/
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*48*/
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*64*/
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*80*/
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*96*/
operator|-
literal|1
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*112*/
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*128*/
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*256*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|maptolower
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x1a
block|,
literal|0x1b
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1e
block|,
literal|0x1f
block|,
literal|0x20
block|,
literal|0x21
block|,
literal|0x22
block|,
literal|0x23
block|,
literal|0x24
block|,
literal|0x25
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x2b
block|,
literal|0x2c
block|,
literal|0x2d
block|,
literal|0x2e
block|,
literal|0x2f
block|,
literal|0x30
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x39
block|,
literal|0x3a
block|,
literal|0x3b
block|,
literal|0x3c
block|,
literal|0x3d
block|,
literal|0x3e
block|,
literal|0x3f
block|,
literal|0x40
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6a
block|,
literal|0x6b
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0x6e
block|,
literal|0x6f
block|,
literal|0x70
block|,
literal|0x71
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x7a
block|,
literal|0x5b
block|,
literal|0x5c
block|,
literal|0x5d
block|,
literal|0x5e
block|,
literal|0x5f
block|,
literal|0x60
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x6a
block|,
literal|0x6b
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0x6e
block|,
literal|0x6f
block|,
literal|0x70
block|,
literal|0x71
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x7a
block|,
literal|0x7b
block|,
literal|0x7c
block|,
literal|0x7d
block|,
literal|0x7e
block|,
literal|0x7f
block|,
literal|0x80
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x83
block|,
literal|0x84
block|,
literal|0x85
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|,
literal|0x89
block|,
literal|0x8a
block|,
literal|0x8b
block|,
literal|0x8c
block|,
literal|0x8d
block|,
literal|0x8e
block|,
literal|0x8f
block|,
literal|0x90
block|,
literal|0x91
block|,
literal|0x92
block|,
literal|0x93
block|,
literal|0x94
block|,
literal|0x95
block|,
literal|0x96
block|,
literal|0x97
block|,
literal|0x98
block|,
literal|0x99
block|,
literal|0x9a
block|,
literal|0x9b
block|,
literal|0x9c
block|,
literal|0x9d
block|,
literal|0x9e
block|,
literal|0x9f
block|,
literal|0xa0
block|,
literal|0xa1
block|,
literal|0xa2
block|,
literal|0xa3
block|,
literal|0xa4
block|,
literal|0xa5
block|,
literal|0xa6
block|,
literal|0xa7
block|,
literal|0xa8
block|,
literal|0xa9
block|,
literal|0xaa
block|,
literal|0xab
block|,
literal|0xac
block|,
literal|0xad
block|,
literal|0xae
block|,
literal|0xaf
block|,
literal|0xb0
block|,
literal|0xb1
block|,
literal|0xb2
block|,
literal|0xb3
block|,
literal|0xb4
block|,
literal|0xb5
block|,
literal|0xb6
block|,
literal|0xb7
block|,
literal|0xb8
block|,
literal|0xb9
block|,
literal|0xba
block|,
literal|0xbb
block|,
literal|0xbc
block|,
literal|0xbd
block|,
literal|0xbe
block|,
literal|0xbf
block|,
literal|0xc0
block|,
literal|0xc1
block|,
literal|0xc2
block|,
literal|0xc3
block|,
literal|0xc4
block|,
literal|0xc5
block|,
literal|0xc6
block|,
literal|0xc7
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0xca
block|,
literal|0xcb
block|,
literal|0xcc
block|,
literal|0xcd
block|,
literal|0xce
block|,
literal|0xcf
block|,
literal|0xd0
block|,
literal|0xd1
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0xda
block|,
literal|0xdb
block|,
literal|0xdc
block|,
literal|0xdd
block|,
literal|0xde
block|,
literal|0xdf
block|,
literal|0xe0
block|,
literal|0xe1
block|,
literal|0xe2
block|,
literal|0xe3
block|,
literal|0xe4
block|,
literal|0xe5
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xe8
block|,
literal|0xe9
block|,
literal|0xea
block|,
literal|0xeb
block|,
literal|0xec
block|,
literal|0xed
block|,
literal|0xee
block|,
literal|0xef
block|,
literal|0xf0
block|,
literal|0xf1
block|,
literal|0xf2
block|,
literal|0xf3
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf6
block|,
literal|0xf7
block|,
literal|0xf8
block|,
literal|0xf9
block|,
literal|0xfa
block|,
literal|0xfb
block|,
literal|0xfc
block|,
literal|0xfd
block|,
literal|0xfe
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CONVERTTOASCII
parameter_list|(
name|c
parameter_list|)
end_define

begin_define
define|#
directive|define
name|CONVERTFROMASCII
parameter_list|(
name|c
parameter_list|)
end_define

begin_define
define|#
directive|define
name|INIT_OFFSETS
parameter_list|(
name|name
parameter_list|,
name|var
parameter_list|,
define|default) \ 	if (name->offsets != NULL) \ 		var = name->offsets; \ 	else \ 		var = default;
end_define

begin_define
define|#
directive|define
name|SETUP_OFFSETS
parameter_list|(
name|name
parameter_list|,
name|var
parameter_list|,
define|default) \ 	if (name->offsets != NULL) \ 		var = name->offsets; \ 	else { \ 		var = default; \ 		set_offsets(name, var, NULL); \ 	}
end_define

begin_comment
comment|/*%  * Note:  If additional attributes are added that should not be set for  *	  empty names, MAKE_EMPTY() must be changed so it clears them.  */
end_comment

begin_define
define|#
directive|define
name|MAKE_EMPTY
parameter_list|(
name|name
parameter_list|)
define|\
value|do { \ 	name->ndata = NULL; \ 	name->length = 0; \ 	name->labels = 0; \ 	name->attributes&= ~DNS_NAMEATTR_ABSOLUTE; \ } while (0);
end_define

begin_comment
comment|/*%  * A name is "bindable" if it can be set to point to a new value, i.e.  * name->ndata and name->length may be changed.  */
end_comment

begin_define
define|#
directive|define
name|BINDABLE
parameter_list|(
name|name
parameter_list|)
define|\
value|((name->attributes& (DNS_NAMEATTR_READONLY|DNS_NAMEATTR_DYNAMIC)) \ 	 == 0)
end_define

begin_comment
comment|/*%  * Note that the name data must be a char array, not a string  * literal, to avoid compiler warnings about discarding  * the const attribute of a string.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|root_ndata
index|[]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|root_offsets
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dns_name_t
name|root
init|=
block|{
name|DNS_NAME_MAGIC
block|,
name|root_ndata
block|,
literal|1
block|,
literal|1
block|,
name|DNS_NAMEATTR_READONLY
operator||
name|DNS_NAMEATTR_ABSOLUTE
block|,
name|root_offsets
block|,
name|NULL
block|,
block|{
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|,
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXXDCL make const? */
end_comment

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
name|dns_name_t
modifier|*
name|dns_rootname
init|=
operator|&
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|wild_ndata
index|[]
init|=
block|{
literal|'\001'
block|,
literal|'*'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|wild_offsets
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dns_name_t
name|wild
init|=
block|{
name|DNS_NAME_MAGIC
block|,
name|wild_ndata
block|,
literal|2
block|,
literal|1
block|,
name|DNS_NAMEATTR_READONLY
block|,
name|wild_offsets
block|,
name|NULL
block|,
block|{
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|,
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXXDCL make const? */
end_comment

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
name|dns_name_t
modifier|*
name|dns_wildcardname
init|=
operator|&
name|wild
decl_stmt|;
end_decl_stmt

begin_function_decl
name|unsigned
name|int
name|dns_fullname_hash
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * dns_name_t to text post-conversion procedure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|thread_key_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_mutex_t
name|thread_key_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_mem_t
modifier|*
name|thread_key_mctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_thread_key_t
name|totext_filter_proc_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_once_t
name|once
init|=
name|ISC_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|dns_name_totextfilter_t
name|totext_filter_proc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|set_offsets
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|char
modifier|*
name|offsets
parameter_list|,
name|dns_name_t
modifier|*
name|set_name
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dns_name_init
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|char
modifier|*
name|offsets
parameter_list|)
block|{
comment|/* 	 * Initialize 'name'. 	 */
name|DNS_NAME_INIT
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_name_reset
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|DNS_NAME_RESET
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_name_invalidate
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
comment|/* 	 * Make 'name' invalid. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|ndata
operator|=
name|NULL
expr_stmt|;
name|name
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|labels
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|offsets
operator|=
name|NULL
expr_stmt|;
name|name
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_name_setbuffer
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|)
block|{
comment|/* 	 * Dedicate a buffer for use with 'name'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|buffer
operator|!=
name|NULL
operator|&&
name|name
operator|->
name|buffer
operator|==
name|NULL
operator|)
operator|||
operator|(
name|buffer
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|name
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_hasbuffer
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
comment|/* 	 * Does 'name' have a dedicated buffer? 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|buffer
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_isabsolute
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
comment|/* 	 * Does 'name' end in the root label? 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|hyphenchar
parameter_list|(
name|c
parameter_list|)
value|((c) == 0x2d)
end_define

begin_define
define|#
directive|define
name|asterchar
parameter_list|(
name|c
parameter_list|)
value|((c) == 0x2a)
end_define

begin_define
define|#
directive|define
name|alphachar
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 0x41&& (c)<= 0x5a) \ 		      || ((c)>= 0x61&& (c)<= 0x7a))
end_define

begin_define
define|#
directive|define
name|digitchar
parameter_list|(
name|c
parameter_list|)
value|((c)>= 0x30&& (c)<= 0x39)
end_define

begin_define
define|#
directive|define
name|borderchar
parameter_list|(
name|c
parameter_list|)
value|(alphachar(c) || digitchar(c))
end_define

begin_define
define|#
directive|define
name|middlechar
parameter_list|(
name|c
parameter_list|)
value|(borderchar(c) || hyphenchar(c))
end_define

begin_define
define|#
directive|define
name|domainchar
parameter_list|(
name|c
parameter_list|)
value|((c)> 0x20&& (c)< 0x7f)
end_define

begin_function
name|isc_boolean_t
name|dns_name_ismailbox
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|,
name|ch
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
argument_list|)
expr_stmt|;
comment|/* 	 * Root label. 	 */
if|if
condition|(
name|name
operator|->
name|length
operator|==
literal|1
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|ndata
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
name|n
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|n
operator|<=
literal|63
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|ch
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|domainchar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ndata
operator|==
name|name
operator|->
name|ndata
operator|+
name|name
operator|->
name|length
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * RFC292/RFC1123 hostname. 	 */
while|while
condition|(
name|ndata
operator|<
operator|(
name|name
operator|->
name|ndata
operator|+
name|name
operator|->
name|length
operator|)
condition|)
block|{
name|n
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|n
operator|<=
literal|63
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|ch
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
if|if
condition|(
name|first
operator|||
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|borderchar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|middlechar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_ishostname
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|wildcard
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|,
name|ch
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
argument_list|)
expr_stmt|;
comment|/* 	 * Root label. 	 */
if|if
condition|(
name|name
operator|->
name|length
operator|==
literal|1
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Skip wildcard if this is a ownername. 	 */
name|ndata
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
if|if
condition|(
name|wildcard
operator|&&
name|ndata
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|ndata
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|ndata
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * RFC292/RFC1123 hostname. 	 */
while|while
condition|(
name|ndata
operator|<
operator|(
name|name
operator|->
name|ndata
operator|+
name|name
operator|->
name|length
operator|)
condition|)
block|{
name|n
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|n
operator|<=
literal|63
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|ch
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
if|if
condition|(
name|first
operator|||
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|borderchar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|middlechar
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_iswildcard
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|;
comment|/* 	 * Is 'name' a wildcard name? 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|length
operator|>=
literal|2
condition|)
block|{
name|ndata
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
if|if
condition|(
name|ndata
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|ndata
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_internalwildcard
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|label
decl_stmt|;
comment|/* 	 * Does 'name' contain a internal wildcard? 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Skip first label. 	 */
name|ndata
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
name|count
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|count
operator|<=
literal|63
argument_list|)
expr_stmt|;
name|ndata
operator|+=
name|count
expr_stmt|;
name|label
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check all but the last of the remaining labels. 	 */
while|while
condition|(
name|label
operator|+
literal|1
operator|<
name|name
operator|->
name|labels
condition|)
block|{
name|count
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|count
operator|<=
literal|63
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
operator|*
name|ndata
operator|==
literal|'*'
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|ndata
operator|+=
name|count
expr_stmt|;
name|label
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|name_hash
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|length
operator|=
name|name
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|16
condition|)
name|length
operator|=
literal|16
expr_stmt|;
comment|/* 	 * This hash function is similar to the one Ousterhout 	 * uses in Tcl. 	 */
name|s
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
if|if
condition|(
name|case_sensitive
condition|)
block|{
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
operator|+
operator|*
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|maptolower
index|[
operator|*
name|s
index|]
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
operator|+
name|c
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_name_hash
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
comment|/* 	 * Provide a hash value for 'name'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|labels
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|name_hash
argument_list|(
name|name
argument_list|,
name|case_sensitive
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_name_fullhash
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
comment|/* 	 * Provide a hash value for 'name'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|labels
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|isc_hash_calc
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|name
operator|->
name|ndata
argument_list|,
name|name
operator|->
name|length
argument_list|,
name|case_sensitive
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_fullname_hash
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
comment|/* 	 * This function was deprecated due to the breakage of the name space 	 * convention.  We only keep this internally to provide binary backward 	 * compatibility. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_name_fullhash
argument_list|(
name|name
argument_list|,
name|case_sensitive
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_name_hashbylabel
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|case_sensitive
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|offsets
decl_stmt|;
name|dns_offsets_t
name|odata
decl_stmt|;
name|dns_name_t
name|tname
decl_stmt|;
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* 	 * Provide a hash value for 'name'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|labels
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|name
operator|->
name|labels
operator|==
literal|1
condition|)
return|return
operator|(
name|name_hash
argument_list|(
name|name
argument_list|,
name|case_sensitive
argument_list|)
operator|)
return|;
name|SETUP_OFFSETS
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|odata
argument_list|)
expr_stmt|;
name|DNS_NAME_INIT
argument_list|(
operator|&
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tname
operator|.
name|labels
operator|=
literal|1
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name
operator|->
name|labels
condition|;
name|i
operator|++
control|)
block|{
name|tname
operator|.
name|ndata
operator|=
name|name
operator|->
name|ndata
operator|+
name|offsets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|name
operator|->
name|labels
operator|-
literal|1
condition|)
name|tname
operator|.
name|length
operator|=
name|name
operator|->
name|length
operator|-
name|offsets
index|[
name|i
index|]
expr_stmt|;
else|else
name|tname
operator|.
name|length
operator|=
name|offsets
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|offsets
index|[
name|i
index|]
expr_stmt|;
name|h
operator|+=
name|name_hash
argument_list|(
operator|&
name|tname
argument_list|,
name|case_sensitive
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
name|dns_namereln_t
name|dns_name_fullcompare
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name1
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|name2
parameter_list|,
name|int
modifier|*
name|orderp
parameter_list|,
name|unsigned
name|int
modifier|*
name|nlabelsp
parameter_list|)
block|{
name|unsigned
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|l
decl_stmt|,
name|count1
decl_stmt|,
name|count2
decl_stmt|,
name|count
decl_stmt|,
name|nlabels
decl_stmt|;
name|int
name|cdiff
decl_stmt|,
name|ldiff
decl_stmt|,
name|chdiff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|label1
decl_stmt|,
modifier|*
name|label2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|offsets1
decl_stmt|,
modifier|*
name|offsets2
decl_stmt|;
name|dns_offsets_t
name|odata1
decl_stmt|,
name|odata2
decl_stmt|;
name|dns_namereln_t
name|namereln
init|=
name|dns_namereln_none
decl_stmt|;
comment|/* 	 * Determine the relative ordering under the DNSSEC order relation of 	 * 'name1' and 'name2', and also determine the hierarchical 	 * relationship of the names. 	 * 	 * Note: It makes no sense for one of the names to be relative and the 	 * other absolute.  If both names are relative, then to be meaningfully 	 * compared the caller must ensure that they are both relative to the 	 * same domain. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name1
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name2
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|orderp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nlabelsp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Either name1 is absolute and name2 is absolute, or neither is. 	 */
name|REQUIRE
argument_list|(
operator|(
name|name1
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|==
operator|(
name|name2
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
argument_list|)
expr_stmt|;
name|SETUP_OFFSETS
argument_list|(
name|name1
argument_list|,
name|offsets1
argument_list|,
name|odata1
argument_list|)
expr_stmt|;
name|SETUP_OFFSETS
argument_list|(
name|name2
argument_list|,
name|offsets2
argument_list|,
name|odata2
argument_list|)
expr_stmt|;
name|nlabels
operator|=
literal|0
expr_stmt|;
name|l1
operator|=
name|name1
operator|->
name|labels
expr_stmt|;
name|l2
operator|=
name|name2
operator|->
name|labels
expr_stmt|;
name|ldiff
operator|=
operator|(
name|int
operator|)
name|l1
operator|-
operator|(
name|int
operator|)
name|l2
expr_stmt|;
if|if
condition|(
name|ldiff
operator|<
literal|0
condition|)
name|l
operator|=
name|l1
expr_stmt|;
else|else
name|l
operator|=
name|l2
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|l1
operator|--
expr_stmt|;
name|l2
operator|--
expr_stmt|;
name|label1
operator|=
operator|&
name|name1
operator|->
name|ndata
index|[
name|offsets1
index|[
name|l1
index|]
index|]
expr_stmt|;
name|label2
operator|=
operator|&
name|name2
operator|->
name|ndata
index|[
name|offsets2
index|[
name|l2
index|]
index|]
expr_stmt|;
name|count1
operator|=
operator|*
name|label1
operator|++
expr_stmt|;
name|count2
operator|=
operator|*
name|label2
operator|++
expr_stmt|;
comment|/* 		 * We dropped bitstring labels, and we don't support any 		 * other extended label types. 		 */
name|INSIST
argument_list|(
name|count1
operator|<=
literal|63
operator|&&
name|count2
operator|<=
literal|63
argument_list|)
expr_stmt|;
name|cdiff
operator|=
operator|(
name|int
operator|)
name|count1
operator|-
operator|(
name|int
operator|)
name|count2
expr_stmt|;
if|if
condition|(
name|cdiff
operator|<
literal|0
condition|)
name|count
operator|=
name|count1
expr_stmt|;
else|else
name|count
operator|=
name|count2
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|chdiff
operator|=
operator|(
name|int
operator|)
name|maptolower
index|[
operator|*
name|label1
index|]
operator|-
operator|(
name|int
operator|)
name|maptolower
index|[
operator|*
name|label2
index|]
expr_stmt|;
if|if
condition|(
name|chdiff
operator|!=
literal|0
condition|)
block|{
operator|*
name|orderp
operator|=
name|chdiff
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|count
operator|--
expr_stmt|;
name|label1
operator|++
expr_stmt|;
name|label2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cdiff
operator|!=
literal|0
condition|)
block|{
operator|*
name|orderp
operator|=
name|cdiff
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nlabels
operator|++
expr_stmt|;
block|}
operator|*
name|orderp
operator|=
name|ldiff
expr_stmt|;
if|if
condition|(
name|ldiff
operator|<
literal|0
condition|)
name|namereln
operator|=
name|dns_namereln_contains
expr_stmt|;
elseif|else
if|if
condition|(
name|ldiff
operator|>
literal|0
condition|)
name|namereln
operator|=
name|dns_namereln_subdomain
expr_stmt|;
else|else
name|namereln
operator|=
name|dns_namereln_equal
expr_stmt|;
name|done
label|:
operator|*
name|nlabelsp
operator|=
name|nlabels
expr_stmt|;
if|if
condition|(
name|nlabels
operator|>
literal|0
operator|&&
name|namereln
operator|==
name|dns_namereln_none
condition|)
name|namereln
operator|=
name|dns_namereln_commonancestor
expr_stmt|;
return|return
operator|(
name|namereln
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dns_name_compare
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name1
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|name2
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|;
comment|/* 	 * Determine the relative ordering under the DNSSEC order relation of 	 * 'name1' and 'name2'. 	 * 	 * Note: It makes no sense for one of the names to be relative and the 	 * other absolute.  If both names are relative, then to be meaningfully 	 * compared the caller must ensure that they are both relative to the 	 * same domain. 	 */
operator|(
name|void
operator|)
name|dns_name_fullcompare
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
return|return
operator|(
name|order
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_equal
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name1
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|name2
parameter_list|)
block|{
name|unsigned
name|int
name|l
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
modifier|*
name|label1
decl_stmt|,
modifier|*
name|label2
decl_stmt|;
comment|/* 	 * Are 'name1' and 'name2' equal? 	 * 	 * Note: It makes no sense for one of the names to be relative and the 	 * other absolute.  If both names are relative, then to be meaningfully 	 * compared the caller must ensure that they are both relative to the 	 * same domain. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name1
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Either name1 is absolute and name2 is absolute, or neither is. 	 */
name|REQUIRE
argument_list|(
operator|(
name|name1
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|==
operator|(
name|name2
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name1
operator|->
name|length
operator|!=
name|name2
operator|->
name|length
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|l
operator|=
name|name1
operator|->
name|labels
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|name2
operator|->
name|labels
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|label1
operator|=
name|name1
operator|->
name|ndata
expr_stmt|;
name|label2
operator|=
name|name2
operator|->
name|ndata
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|count
operator|=
operator|*
name|label1
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|!=
operator|*
name|label2
operator|++
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|INSIST
argument_list|(
name|count
operator|<=
literal|63
argument_list|)
expr_stmt|;
comment|/* no bitstring support */
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|c
operator|=
name|maptolower
index|[
operator|*
name|label1
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|maptolower
index|[
operator|*
name|label2
operator|++
index|]
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_caseequal
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name1
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|name2
parameter_list|)
block|{
comment|/* 	 * Are 'name1' and 'name2' equal? 	 * 	 * Note: It makes no sense for one of the names to be relative and the 	 * other absolute.  If both names are relative, then to be meaningfully 	 * compared the caller must ensure that they are both relative to the 	 * same domain. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name1
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Either name1 is absolute and name2 is absolute, or neither is. 	 */
name|REQUIRE
argument_list|(
operator|(
name|name1
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|==
operator|(
name|name2
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name1
operator|->
name|length
operator|!=
name|name2
operator|->
name|length
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|name1
operator|->
name|ndata
argument_list|,
name|name2
operator|->
name|ndata
argument_list|,
name|name1
operator|->
name|length
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dns_name_rdatacompare
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name1
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|name2
parameter_list|)
block|{
name|unsigned
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|l
decl_stmt|,
name|count1
decl_stmt|,
name|count2
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|label1
decl_stmt|,
modifier|*
name|label2
decl_stmt|;
comment|/* 	 * Compare two absolute names as rdata. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name1
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name1
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|name1
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name2
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name2
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|name2
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|l1
operator|=
name|name1
operator|->
name|labels
expr_stmt|;
name|l2
operator|=
name|name2
operator|->
name|labels
expr_stmt|;
name|l
operator|=
operator|(
name|l1
operator|<
name|l2
operator|)
condition|?
name|l1
else|:
name|l2
expr_stmt|;
name|label1
operator|=
name|name1
operator|->
name|ndata
expr_stmt|;
name|label2
operator|=
name|name2
operator|->
name|ndata
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|count1
operator|=
operator|*
name|label1
operator|++
expr_stmt|;
name|count2
operator|=
operator|*
name|label2
operator|++
expr_stmt|;
comment|/* no bitstring support */
name|INSIST
argument_list|(
name|count1
operator|<=
literal|63
operator|&&
name|count2
operator|<=
literal|63
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
name|count2
condition|)
return|return
operator|(
operator|(
name|count1
operator|<
name|count2
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
name|count
operator|=
name|count1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|c1
operator|=
name|maptolower
index|[
operator|*
name|label1
operator|++
index|]
expr_stmt|;
name|c2
operator|=
name|maptolower
index|[
operator|*
name|label2
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * If one name had more labels than the other, their common 	 * prefix must have been different because the shorter name 	 * ended with the root label and the longer one can't have 	 * a root label in the middle of it.  Therefore, if we get 	 * to this point, the lengths must be equal. 	 */
name|INSIST
argument_list|(
name|l1
operator|==
name|l2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_issubdomain
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name1
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|name2
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|;
name|dns_namereln_t
name|namereln
decl_stmt|;
comment|/* 	 * Is 'name1' a subdomain of 'name2'? 	 * 	 * Note: It makes no sense for one of the names to be relative and the 	 * other absolute.  If both names are relative, then to be meaningfully 	 * compared the caller must ensure that they are both relative to the 	 * same domain. 	 */
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
if|if
condition|(
name|namereln
operator|==
name|dns_namereln_subdomain
operator|||
name|namereln
operator|==
name|dns_namereln_equal
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_matcheswildcard
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|wname
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|,
name|labels
decl_stmt|;
name|dns_name_t
name|tname
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|wname
argument_list|)
argument_list|)
expr_stmt|;
name|labels
operator|=
name|wname
operator|->
name|labels
expr_stmt|;
name|REQUIRE
argument_list|(
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_iswildcard
argument_list|(
name|wname
argument_list|)
argument_list|)
expr_stmt|;
name|DNS_NAME_INIT
argument_list|(
operator|&
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|wname
argument_list|,
literal|1
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
operator|&
name|tname
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
operator|==
name|dns_namereln_subdomain
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_name_countlabels
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
comment|/* 	 * How many labels does 'name' have? 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|name
operator|->
name|labels
operator|<=
literal|128
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|->
name|labels
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_name_getlabel
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|dns_label_t
modifier|*
name|label
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|offsets
decl_stmt|;
name|dns_offsets_t
name|odata
decl_stmt|;
comment|/* 	 * Make 'label' refer to the 'n'th least significant label of 'name'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|n
operator|<
name|name
operator|->
name|labels
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|label
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SETUP_OFFSETS
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|odata
argument_list|)
expr_stmt|;
name|label
operator|->
name|base
operator|=
operator|&
name|name
operator|->
name|ndata
index|[
name|offsets
index|[
name|n
index|]
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|name
operator|->
name|labels
operator|-
literal|1
condition|)
name|label
operator|->
name|length
operator|=
name|name
operator|->
name|length
operator|-
name|offsets
index|[
name|n
index|]
expr_stmt|;
else|else
name|label
operator|->
name|length
operator|=
name|offsets
index|[
name|n
operator|+
literal|1
index|]
operator|-
name|offsets
index|[
name|n
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_name_getlabelsequence
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|first
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|dns_name_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|offsets
decl_stmt|;
name|dns_offsets_t
name|odata
decl_stmt|;
name|unsigned
name|int
name|firstoffset
decl_stmt|,
name|endoffset
decl_stmt|;
comment|/* 	 * Make 'target' refer to the 'n' labels including and following 	 * 'first' in 'source'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|first
operator|<=
name|source
operator|->
name|labels
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|first
operator|+
name|n
operator|<=
name|source
operator|->
name|labels
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|SETUP_OFFSETS
argument_list|(
name|source
argument_list|,
name|offsets
argument_list|,
name|odata
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|source
operator|->
name|labels
condition|)
name|firstoffset
operator|=
name|source
operator|->
name|length
expr_stmt|;
else|else
name|firstoffset
operator|=
name|offsets
index|[
name|first
index|]
expr_stmt|;
if|if
condition|(
name|first
operator|+
name|n
operator|==
name|source
operator|->
name|labels
condition|)
name|endoffset
operator|=
name|source
operator|->
name|length
expr_stmt|;
else|else
name|endoffset
operator|=
name|offsets
index|[
name|first
operator|+
name|n
index|]
expr_stmt|;
name|target
operator|->
name|ndata
operator|=
operator|&
name|source
operator|->
name|ndata
index|[
name|firstoffset
index|]
expr_stmt|;
name|target
operator|->
name|length
operator|=
name|endoffset
operator|-
name|firstoffset
expr_stmt|;
if|if
condition|(
name|first
operator|+
name|n
operator|==
name|source
operator|->
name|labels
operator|&&
name|n
operator|>
literal|0
operator|&&
operator|(
name|source
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
name|target
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
else|else
name|target
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
name|target
operator|->
name|labels
operator|=
name|n
expr_stmt|;
comment|/* 	 * If source and target are the same, and we're making target 	 * a prefix of source, the offsets table is correct already 	 * so we don't need to call set_offsets(). 	 */
if|if
condition|(
name|target
operator|->
name|offsets
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|!=
name|source
operator|||
name|first
operator|!=
literal|0
operator|)
condition|)
name|set_offsets
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|offsets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_name_clone
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|dns_name_t
modifier|*
name|target
parameter_list|)
block|{
comment|/* 	 * Make 'target' refer to the same name as 'source'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|->
name|ndata
operator|=
name|source
operator|->
name|ndata
expr_stmt|;
name|target
operator|->
name|length
operator|=
name|source
operator|->
name|length
expr_stmt|;
name|target
operator|->
name|labels
operator|=
name|source
operator|->
name|labels
expr_stmt|;
name|target
operator|->
name|attributes
operator|=
name|source
operator|->
name|attributes
operator|&
operator|(
name|unsigned
name|int
operator|)
operator|~
operator|(
name|DNS_NAMEATTR_READONLY
operator||
name|DNS_NAMEATTR_DYNAMIC
operator||
name|DNS_NAMEATTR_DYNOFFSETS
operator|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|offsets
operator|!=
name|NULL
operator|&&
name|source
operator|->
name|labels
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|source
operator|->
name|offsets
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|target
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|labels
argument_list|)
expr_stmt|;
else|else
name|set_offsets
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|offsets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dns_name_fromregion
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|isc_region_t
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|offsets
decl_stmt|;
name|dns_offsets_t
name|odata
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|isc_region_t
name|r2
decl_stmt|;
comment|/* 	 * Make 'name' refer to region 'r'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_OFFSETS
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|odata
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|isc_buffer_clear
argument_list|(
name|name
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|name
operator|->
name|buffer
argument_list|,
operator|&
name|r2
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|r
operator|->
name|length
operator|<
name|r2
operator|.
name|length
operator|)
condition|?
name|r
operator|->
name|length
else|:
name|r2
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|DNS_NAME_MAXWIRE
condition|)
name|len
operator|=
name|DNS_NAME_MAXWIRE
expr_stmt|;
name|memcpy
argument_list|(
name|r2
operator|.
name|base
argument_list|,
name|r
operator|->
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
operator|->
name|ndata
operator|=
name|r2
operator|.
name|base
expr_stmt|;
name|name
operator|->
name|length
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|name
operator|->
name|ndata
operator|=
name|r
operator|->
name|base
expr_stmt|;
name|name
operator|->
name|length
operator|=
operator|(
name|r
operator|->
name|length
operator|<=
name|DNS_NAME_MAXWIRE
operator|)
condition|?
name|r
operator|->
name|length
else|:
name|DNS_NAME_MAXWIRE
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|length
operator|>
literal|0
condition|)
name|set_offsets
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|name
operator|->
name|labels
operator|=
literal|0
expr_stmt|;
name|name
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|->
name|buffer
operator|!=
name|NULL
condition|)
name|isc_buffer_add
argument_list|(
name|name
operator|->
name|buffer
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_name_toregion
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_region_t
modifier|*
name|r
parameter_list|)
block|{
comment|/* 	 * Make 'r' refer to 'name'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|r
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DNS_NAME_TOREGION
argument_list|(
name|name
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_fromtext
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|source
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|,
modifier|*
name|label
decl_stmt|;
name|char
modifier|*
name|tdata
decl_stmt|;
name|char
name|c
decl_stmt|;
name|ft_state
name|state
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|tlen
decl_stmt|,
name|nrem
decl_stmt|,
name|nused
decl_stmt|,
name|digits
decl_stmt|,
name|labels
decl_stmt|,
name|tused
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
name|unsigned
name|char
modifier|*
name|offsets
decl_stmt|;
name|dns_offsets_t
name|odata
decl_stmt|;
name|isc_boolean_t
name|downcase
decl_stmt|;
comment|/* 	 * Convert the textual representation of a DNS name at source 	 * into uncompressed wire form stored in target. 	 * 	 * Notes: 	 *	Relative domain names will have 'origin' appended to them 	 *	unless 'origin' is NULL, in which case relative domain names 	 *	will remain relative. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|target
argument_list|)
operator|)
operator|||
operator|(
name|target
operator|==
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|name
operator|->
name|buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|downcase
operator|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_NAME_DOWNCASE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
operator|&&
name|name
operator|->
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|target
operator|=
name|name
operator|->
name|buffer
expr_stmt|;
name|isc_buffer_clear
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_OFFSETS
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|odata
argument_list|)
expr_stmt|;
name|offsets
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize things to make the compiler happy; they're not required. 	 */
name|n1
operator|=
literal|0
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|NULL
expr_stmt|;
name|digits
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make 'name' empty in case of failure. 	 */
name|MAKE_EMPTY
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the state machine. 	 */
name|tdata
operator|=
operator|(
name|char
operator|*
operator|)
name|source
operator|->
name|base
operator|+
name|source
operator|->
name|current
expr_stmt|;
name|tlen
operator|=
name|isc_buffer_remaininglength
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|tused
operator|=
literal|0
expr_stmt|;
name|ndata
operator|=
name|isc_buffer_used
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|nrem
operator|=
name|isc_buffer_availablelength
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrem
operator|>
literal|255
condition|)
name|nrem
operator|=
literal|255
expr_stmt|;
name|nused
operator|=
literal|0
expr_stmt|;
name|labels
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|state
operator|=
name|ft_init
expr_stmt|;
while|while
condition|(
name|nrem
operator|>
literal|0
operator|&&
name|tlen
operator|>
literal|0
operator|&&
operator|!
name|done
condition|)
block|{
name|c
operator|=
operator|*
name|tdata
operator|++
expr_stmt|;
name|tlen
operator|--
expr_stmt|;
name|tused
operator|++
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ft_init
case|:
comment|/* 			 * Is this the root name? 			 */
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|tlen
operator|!=
literal|0
condition|)
return|return
operator|(
name|DNS_R_EMPTYLABEL
operator|)
return|;
name|labels
operator|++
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
literal|0
expr_stmt|;
name|nrem
operator|--
expr_stmt|;
name|nused
operator|++
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'@'
operator|&&
name|tlen
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|ft_at
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|ft_start
case|:
name|label
operator|=
name|ndata
expr_stmt|;
name|ndata
operator|++
expr_stmt|;
name|nrem
operator|--
expr_stmt|;
name|nused
operator|++
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|state
operator|=
name|ft_initialescape
expr_stmt|;
break|break;
block|}
name|state
operator|=
name|ft_ordinary
expr_stmt|;
if|if
condition|(
name|nrem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|ft_ordinary
case|:
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_EMPTYLABEL
operator|)
return|;
operator|*
name|label
operator|=
name|count
expr_stmt|;
name|labels
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|labels
operator|<=
literal|127
argument_list|)
expr_stmt|;
name|offsets
index|[
name|labels
index|]
operator|=
name|nused
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
literal|0
condition|)
block|{
name|labels
operator|++
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
literal|0
expr_stmt|;
name|nrem
operator|--
expr_stmt|;
name|nused
operator|++
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|state
operator|=
name|ft_start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|state
operator|=
name|ft_escape
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|>=
literal|63
condition|)
return|return
operator|(
name|DNS_R_LABELTOOLONG
operator|)
return|;
name|count
operator|++
expr_stmt|;
name|CONVERTTOASCII
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|downcase
condition|)
name|c
operator|=
name|maptolower
index|[
operator|(
name|int
operator|)
name|c
index|]
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
name|c
expr_stmt|;
name|nrem
operator|--
expr_stmt|;
name|nused
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ft_initialescape
case|:
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
comment|/* 				 * This looks like a bitstring label, which 				 * was deprecated.  Intentionally drop it. 				 */
return|return
operator|(
name|DNS_R_BADLABELTYPE
operator|)
return|;
block|}
name|state
operator|=
name|ft_escape
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ft_escape
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
operator|>=
literal|63
condition|)
return|return
operator|(
name|DNS_R_LABELTOOLONG
operator|)
return|;
name|count
operator|++
expr_stmt|;
name|CONVERTTOASCII
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|downcase
condition|)
name|c
operator|=
name|maptolower
index|[
operator|(
name|int
operator|)
name|c
index|]
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
name|c
expr_stmt|;
name|nrem
operator|--
expr_stmt|;
name|nused
operator|++
expr_stmt|;
name|state
operator|=
name|ft_ordinary
expr_stmt|;
break|break;
block|}
name|digits
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|ft_escdecimal
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ft_escdecimal
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_BADESCAPE
operator|)
return|;
name|value
operator|*=
literal|10
expr_stmt|;
name|value
operator|+=
name|digitvalue
index|[
operator|(
name|int
operator|)
name|c
index|]
expr_stmt|;
name|digits
operator|++
expr_stmt|;
if|if
condition|(
name|digits
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|value
operator|>
literal|255
condition|)
return|return
operator|(
name|DNS_R_BADESCAPE
operator|)
return|;
if|if
condition|(
name|count
operator|>=
literal|63
condition|)
return|return
operator|(
name|DNS_R_LABELTOOLONG
operator|)
return|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|downcase
condition|)
name|value
operator|=
name|maptolower
index|[
name|value
index|]
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
name|value
expr_stmt|;
name|nrem
operator|--
expr_stmt|;
name|nused
operator|++
expr_stmt|;
name|state
operator|=
name|ft_ordinary
expr_stmt|;
block|}
break|break;
default|default:
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unexpected state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Does not return. */
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|nrem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|INSIST
argument_list|(
name|tlen
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|ft_ordinary
operator|&&
name|state
operator|!=
name|ft_at
condition|)
return|return
operator|(
name|ISC_R_UNEXPECTEDEND
operator|)
return|;
if|if
condition|(
name|state
operator|==
name|ft_ordinary
condition|)
block|{
name|INSIST
argument_list|(
name|count
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|label
operator|=
name|count
expr_stmt|;
name|labels
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|labels
operator|<=
literal|127
argument_list|)
expr_stmt|;
name|offsets
index|[
name|labels
index|]
operator|=
name|nused
expr_stmt|;
block|}
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nrem
operator|<
name|origin
operator|->
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|label
operator|=
name|origin
operator|->
name|ndata
expr_stmt|;
name|n1
operator|=
name|origin
operator|->
name|length
expr_stmt|;
name|nrem
operator|-=
name|n1
expr_stmt|;
while|while
condition|(
name|n1
operator|>
literal|0
condition|)
block|{
name|n2
operator|=
operator|*
name|label
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|n2
operator|<=
literal|63
argument_list|)
expr_stmt|;
comment|/* no bitstring support */
operator|*
name|ndata
operator|++
operator|=
name|n2
expr_stmt|;
name|n1
operator|-=
name|n2
operator|+
literal|1
expr_stmt|;
name|nused
operator|+=
name|n2
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|n2
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|label
operator|++
expr_stmt|;
if|if
condition|(
name|downcase
condition|)
name|c
operator|=
name|maptolower
index|[
operator|(
name|int
operator|)
name|c
index|]
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
name|c
expr_stmt|;
name|n2
operator|--
expr_stmt|;
block|}
name|labels
operator|++
expr_stmt|;
if|if
condition|(
name|n1
operator|>
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|labels
operator|<=
literal|127
argument_list|)
expr_stmt|;
name|offsets
index|[
name|labels
index|]
operator|=
name|nused
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|origin
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
block|}
block|}
else|else
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
name|name
operator|->
name|ndata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|target
operator|->
name|base
operator|+
name|target
operator|->
name|used
expr_stmt|;
name|name
operator|->
name|labels
operator|=
name|labels
expr_stmt|;
name|name
operator|->
name|length
operator|=
name|nused
expr_stmt|;
name|isc_buffer_forward
argument_list|(
name|source
argument_list|,
name|tused
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_function
specifier|static
name|void
name|free_specific
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dns_name_totextfilter_t
modifier|*
name|mem
init|=
name|arg
decl_stmt|;
name|isc_mem_put
argument_list|(
name|thread_key_mctx
argument_list|,
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stop use being called again. */
operator|(
name|void
operator|)
name|isc_thread_key_setspecific
argument_list|(
name|totext_filter_proc_key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_key_mutex_init
parameter_list|(
name|void
parameter_list|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|isc_mutex_init
argument_list|(
operator|&
name|thread_key_mutex
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|totext_filter_proc_key_init
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * We need the call to isc_once_do() to support profiled mutex 	 * otherwise thread_key_mutex could be initialized at compile time. 	 */
name|result
operator|=
name|isc_once_do
argument_list|(
operator|&
name|once
argument_list|,
name|thread_key_mutex_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
operator|!
name|thread_key_initialized
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|thread_key_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_key_mctx
operator|==
name|NULL
condition|)
name|result
operator|=
name|isc_mem_create2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|thread_key_mctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
name|isc_mem_setname
argument_list|(
name|thread_key_mctx
argument_list|,
literal|"threadkey"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_mem_setdestroycheck
argument_list|(
name|thread_key_mctx
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread_key_initialized
operator|&&
name|isc_thread_key_create
argument_list|(
operator|&
name|totext_filter_proc_key
argument_list|,
name|free_specific
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|thread_key_mctx
argument_list|)
expr_stmt|;
block|}
else|else
name|thread_key_initialized
operator|=
literal|1
expr_stmt|;
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|thread_key_mutex
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_result_t
name|dns_name_totext
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|omit_final_dot
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|;
name|char
modifier|*
name|tdata
decl_stmt|;
name|unsigned
name|int
name|nlen
decl_stmt|,
name|tlen
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|trem
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|isc_boolean_t
name|saw_root
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|oused
init|=
name|target
operator|->
name|used
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|dns_name_totextfilter_t
modifier|*
name|mem
decl_stmt|;
name|dns_name_totextfilter_t
name|totext_filter_proc
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * This function assumes the name is in proper uncompressed 	 * wire format. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|result
operator|=
name|totext_filter_proc_key_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
name|ndata
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
name|nlen
operator|=
name|name
operator|->
name|length
expr_stmt|;
name|labels
operator|=
name|name
operator|->
name|labels
expr_stmt|;
name|tdata
operator|=
name|isc_buffer_used
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|isc_buffer_availablelength
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|trem
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
name|labels
operator|==
literal|0
operator|&&
name|nlen
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Special handling for an empty name. 		 */
if|if
condition|(
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
comment|/* 		 * The names of these booleans are misleading in this case. 		 * This empty name is not necessarily from the root node of 		 * the DNS root zone, nor is a final dot going to be included. 		 * They need to be set this way, though, to keep the "@" 		 * from being trounced. 		 */
name|saw_root
operator|=
name|ISC_TRUE
expr_stmt|;
name|omit_final_dot
operator|=
name|ISC_FALSE
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
literal|'@'
expr_stmt|;
name|trem
operator|--
expr_stmt|;
comment|/* 		 * Skip the while() loop. 		 */
name|nlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nlen
operator|==
literal|1
operator|&&
name|labels
operator|==
literal|1
operator|&&
operator|*
name|ndata
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Special handling for the root label. 		 */
if|if
condition|(
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|saw_root
operator|=
name|ISC_TRUE
expr_stmt|;
name|omit_final_dot
operator|=
name|ISC_FALSE
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
literal|'.'
expr_stmt|;
name|trem
operator|--
expr_stmt|;
comment|/* 		 * Skip the while() loop. 		 */
name|nlen
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|labels
operator|>
literal|0
operator|&&
name|nlen
operator|>
literal|0
operator|&&
name|trem
operator|>
literal|0
condition|)
block|{
name|labels
operator|--
expr_stmt|;
name|count
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|saw_root
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|count
operator|<
literal|64
condition|)
block|{
name|INSIST
argument_list|(
name|nlen
operator|>=
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|ndata
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0x22
case|:
comment|/* '"' */
case|case
literal|0x28
case|:
comment|/* '(' */
case|case
literal|0x29
case|:
comment|/* ')' */
case|case
literal|0x2E
case|:
comment|/* '.' */
case|case
literal|0x3B
case|:
comment|/* ';' */
case|case
literal|0x5C
case|:
comment|/* '\\' */
comment|/* Special modifiers in zone files. */
case|case
literal|0x40
case|:
comment|/* '@' */
case|case
literal|0x24
case|:
comment|/* '$' */
if|if
condition|(
name|trem
operator|<
literal|2
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
operator|*
name|tdata
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|CONVERTFROMASCII
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
name|c
expr_stmt|;
name|ndata
operator|++
expr_stmt|;
name|trem
operator|-=
literal|2
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>
literal|0x20
operator|&&
name|c
operator|<
literal|0x7f
condition|)
block|{
if|if
condition|(
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|CONVERTFROMASCII
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
name|c
expr_stmt|;
name|ndata
operator|++
expr_stmt|;
name|trem
operator|--
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|trem
operator|<
literal|4
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
operator|*
name|tdata
operator|++
operator|=
literal|0x5c
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
literal|0x30
operator|+
operator|(
operator|(
name|c
operator|/
literal|100
operator|)
operator|%
literal|10
operator|)
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
literal|0x30
operator|+
operator|(
operator|(
name|c
operator|/
literal|10
operator|)
operator|%
literal|10
operator|)
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
literal|0x30
operator|+
operator|(
name|c
operator|%
literal|10
operator|)
expr_stmt|;
name|trem
operator|-=
literal|4
expr_stmt|;
name|ndata
operator|++
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
block|}
block|}
name|count
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unexpected label type %02x"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 		 * The following assumes names are absolute.  If not, we 		 * fix things up later.  Note that this means that in some 		 * cases one more byte of text buffer is required than is 		 * needed in the final output. 		 */
if|if
condition|(
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
operator|*
name|tdata
operator|++
operator|=
literal|'.'
expr_stmt|;
name|trem
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|!=
literal|0
operator|&&
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
if|if
condition|(
operator|!
name|saw_root
operator|||
name|omit_final_dot
condition|)
name|trem
operator|++
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|tlen
operator|-
name|trem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|mem
operator|=
name|isc_thread_key_getspecific
argument_list|(
name|totext_filter_proc_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
name|totext_filter_proc
operator|=
operator|*
name|mem
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|totext_filter_proc
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|totext_filter_proc
call|)
argument_list|(
name|target
argument_list|,
name|oused
argument_list|,
name|saw_root
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_tofilenametext
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|omit_final_dot
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|;
name|char
modifier|*
name|tdata
decl_stmt|;
name|unsigned
name|int
name|nlen
decl_stmt|,
name|tlen
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|trem
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
comment|/* 	 * This function assumes the name is in proper uncompressed 	 * wire format. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|ndata
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
name|nlen
operator|=
name|name
operator|->
name|length
expr_stmt|;
name|labels
operator|=
name|name
operator|->
name|labels
expr_stmt|;
name|tdata
operator|=
name|isc_buffer_used
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|isc_buffer_availablelength
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|trem
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|1
operator|&&
name|labels
operator|==
literal|1
operator|&&
operator|*
name|ndata
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Special handling for the root label. 		 */
if|if
condition|(
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|omit_final_dot
operator|=
name|ISC_FALSE
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
literal|'.'
expr_stmt|;
name|trem
operator|--
expr_stmt|;
comment|/* 		 * Skip the while() loop. 		 */
name|nlen
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|labels
operator|>
literal|0
operator|&&
name|nlen
operator|>
literal|0
operator|&&
name|trem
operator|>
literal|0
condition|)
block|{
name|labels
operator|--
expr_stmt|;
name|count
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|count
operator|<
literal|64
condition|)
block|{
name|INSIST
argument_list|(
name|nlen
operator|>=
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|ndata
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|0x30
operator|&&
name|c
operator|<=
literal|0x39
operator|)
operator|||
comment|/* digit */
operator|(
name|c
operator|>=
literal|0x41
operator|&&
name|c
operator|<=
literal|0x5A
operator|)
operator|||
comment|/* uppercase */
operator|(
name|c
operator|>=
literal|0x61
operator|&&
name|c
operator|<=
literal|0x7A
operator|)
operator|||
comment|/* lowercase */
name|c
operator|==
literal|0x2D
operator|||
comment|/* hyphen */
name|c
operator|==
literal|0x5F
condition|)
comment|/* underscore */
block|{
if|if
condition|(
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
comment|/* downcase */
if|if
condition|(
name|c
operator|>=
literal|0x41
operator|&&
name|c
operator|<=
literal|0x5A
condition|)
name|c
operator|+=
literal|0x20
expr_stmt|;
name|CONVERTFROMASCII
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|tdata
operator|++
operator|=
name|c
expr_stmt|;
name|ndata
operator|++
expr_stmt|;
name|trem
operator|--
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|trem
operator|<
literal|3
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|sprintf
argument_list|(
name|tdata
argument_list|,
literal|"%%%02X"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|tdata
operator|+=
literal|3
expr_stmt|;
name|trem
operator|-=
literal|3
expr_stmt|;
name|ndata
operator|++
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unexpected label type %02x"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 		 * The following assumes names are absolute.  If not, we 		 * fix things up later.  Note that this means that in some 		 * cases one more byte of text buffer is required than is 		 * needed in the final output. 		 */
if|if
condition|(
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
operator|*
name|tdata
operator|++
operator|=
literal|'.'
expr_stmt|;
name|trem
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|!=
literal|0
operator|&&
name|trem
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
if|if
condition|(
name|omit_final_dot
condition|)
name|trem
operator|++
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|tlen
operator|-
name|trem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_downcase
parameter_list|(
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|sndata
decl_stmt|,
modifier|*
name|ndata
decl_stmt|;
name|unsigned
name|int
name|nlen
decl_stmt|,
name|count
decl_stmt|,
name|labels
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
comment|/* 	 * Downcase 'source'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|name
condition|)
block|{
name|REQUIRE
argument_list|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_READONLY
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|source
operator|->
name|ndata
argument_list|,
name|source
operator|->
name|length
argument_list|)
expr_stmt|;
name|target
operator|=
operator|&
name|buffer
expr_stmt|;
name|ndata
operator|=
name|source
operator|->
name|ndata
expr_stmt|;
block|}
else|else
block|{
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|target
argument_list|)
operator|)
operator|||
operator|(
name|target
operator|==
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|name
operator|->
name|buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|target
operator|=
name|name
operator|->
name|buffer
expr_stmt|;
name|isc_buffer_clear
argument_list|(
name|name
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|ndata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|target
operator|->
name|base
operator|+
name|target
operator|->
name|used
expr_stmt|;
name|name
operator|->
name|ndata
operator|=
name|ndata
expr_stmt|;
block|}
name|sndata
operator|=
name|source
operator|->
name|ndata
expr_stmt|;
name|nlen
operator|=
name|source
operator|->
name|length
expr_stmt|;
name|labels
operator|=
name|source
operator|->
name|labels
expr_stmt|;
if|if
condition|(
name|nlen
operator|>
operator|(
name|target
operator|->
name|length
operator|-
name|target
operator|->
name|used
operator|)
condition|)
block|{
name|MAKE_EMPTY
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
block|}
while|while
condition|(
name|labels
operator|>
literal|0
operator|&&
name|nlen
operator|>
literal|0
condition|)
block|{
name|labels
operator|--
expr_stmt|;
name|count
operator|=
operator|*
name|sndata
operator|++
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
name|count
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|64
condition|)
block|{
name|INSIST
argument_list|(
name|nlen
operator|>=
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
operator|*
name|ndata
operator|++
operator|=
name|maptolower
index|[
operator|(
operator|*
name|sndata
operator|++
operator|)
index|]
expr_stmt|;
name|nlen
operator|--
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unexpected label type %02x"
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Does not return. */
block|}
block|}
if|if
condition|(
name|source
operator|!=
name|name
condition|)
block|{
name|name
operator|->
name|labels
operator|=
name|source
operator|->
name|labels
expr_stmt|;
name|name
operator|->
name|length
operator|=
name|source
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|source
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
name|name
operator|->
name|attributes
operator|=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
else|else
name|name
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|labels
operator|>
literal|0
operator|&&
name|name
operator|->
name|offsets
operator|!=
name|NULL
condition|)
name|set_offsets
argument_list|(
name|name
argument_list|,
name|name
operator|->
name|offsets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_offsets
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|char
modifier|*
name|offsets
parameter_list|,
name|dns_name_t
modifier|*
name|set_name
parameter_list|)
block|{
name|unsigned
name|int
name|offset
decl_stmt|,
name|count
decl_stmt|,
name|length
decl_stmt|,
name|nlabels
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|;
name|isc_boolean_t
name|absolute
decl_stmt|;
name|ndata
operator|=
name|name
operator|->
name|ndata
expr_stmt|;
name|length
operator|=
name|name
operator|->
name|length
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|nlabels
operator|=
literal|0
expr_stmt|;
name|absolute
operator|=
name|ISC_FALSE
expr_stmt|;
while|while
condition|(
name|offset
operator|!=
name|length
condition|)
block|{
name|INSIST
argument_list|(
name|nlabels
operator|<
literal|128
argument_list|)
expr_stmt|;
name|offsets
index|[
name|nlabels
operator|++
index|]
operator|=
name|offset
expr_stmt|;
name|count
operator|=
operator|*
name|ndata
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|count
operator|<=
literal|63
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|count
expr_stmt|;
name|ndata
operator|+=
name|count
expr_stmt|;
name|INSIST
argument_list|(
name|offset
operator|<=
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|absolute
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|set_name
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|set_name
operator|==
name|name
argument_list|)
expr_stmt|;
name|set_name
operator|->
name|labels
operator|=
name|nlabels
expr_stmt|;
name|set_name
operator|->
name|length
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|absolute
condition|)
name|set_name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
else|else
name|set_name
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|nlabels
operator|==
name|name
operator|->
name|labels
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|offset
operator|==
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_fromwire
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|source
parameter_list|,
name|dns_decompress_t
modifier|*
name|dctx
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|cdata
decl_stmt|,
modifier|*
name|ndata
decl_stmt|;
name|unsigned
name|int
name|cused
decl_stmt|;
comment|/* Bytes of compressed name data used */
name|unsigned
name|int
name|nused
decl_stmt|,
name|labels
decl_stmt|,
name|n
decl_stmt|,
name|nmax
decl_stmt|;
name|unsigned
name|int
name|current
decl_stmt|,
name|new_current
decl_stmt|,
name|biggest_pointer
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
name|fw_state
name|state
init|=
name|fw_start
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|unsigned
name|char
modifier|*
name|offsets
decl_stmt|;
name|dns_offsets_t
name|odata
decl_stmt|;
name|isc_boolean_t
name|downcase
decl_stmt|;
name|isc_boolean_t
name|seen_pointer
decl_stmt|;
comment|/* 	 * Copy the possibly-compressed name at source into target, 	 * decompressing it.  Loop prevention is performed by checking 	 * the new pointer against biggest_pointer. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|target
argument_list|)
operator|)
operator|||
operator|(
name|target
operator|==
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|name
operator|->
name|buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|downcase
operator|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_NAME_DOWNCASE
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
operator|&&
name|name
operator|->
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|target
operator|=
name|name
operator|->
name|buffer
expr_stmt|;
name|isc_buffer_clear
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|dctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_OFFSETS
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|odata
argument_list|)
expr_stmt|;
comment|/* 	 * Make 'name' empty in case of failure. 	 */
name|MAKE_EMPTY
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize things to make the compiler happy; they're not required. 	 */
name|n
operator|=
literal|0
expr_stmt|;
name|new_current
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up. 	 */
name|labels
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|ndata
operator|=
name|isc_buffer_used
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|nused
operator|=
literal|0
expr_stmt|;
name|seen_pointer
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Find the maximum number of uncompressed target name 	 * bytes we are willing to generate.  This is the smaller 	 * of the available target buffer length and the 	 * maximum legal domain name length (255). 	 */
name|nmax
operator|=
name|isc_buffer_availablelength
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmax
operator|>
name|DNS_NAME_MAXWIRE
condition|)
name|nmax
operator|=
name|DNS_NAME_MAXWIRE
expr_stmt|;
name|cdata
operator|=
name|isc_buffer_current
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|cused
operator|=
literal|0
expr_stmt|;
name|current
operator|=
name|source
operator|->
name|current
expr_stmt|;
name|biggest_pointer
operator|=
name|current
expr_stmt|;
comment|/* 	 * Note:  The following code is not optimized for speed, but 	 * rather for correctness.  Speed will be addressed in the future. 	 */
while|while
condition|(
name|current
operator|<
name|source
operator|->
name|active
operator|&&
operator|!
name|done
condition|)
block|{
name|c
operator|=
operator|*
name|cdata
operator|++
expr_stmt|;
name|current
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|seen_pointer
condition|)
name|cused
operator|++
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|fw_start
case|:
if|if
condition|(
name|c
operator|<
literal|64
condition|)
block|{
name|offsets
index|[
name|labels
index|]
operator|=
name|nused
expr_stmt|;
name|labels
operator|++
expr_stmt|;
if|if
condition|(
name|nused
operator|+
name|c
operator|+
literal|1
operator|>
name|nmax
condition|)
goto|goto
name|full
goto|;
name|nused
operator|+=
name|c
operator|+
literal|1
expr_stmt|;
operator|*
name|ndata
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
name|n
operator|=
name|c
expr_stmt|;
name|state
operator|=
name|fw_ordinary
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|128
operator|&&
name|c
operator|<
literal|192
condition|)
block|{
comment|/* 				 * 14 bit local compression pointer. 				 * Local compression is no longer an 				 * IETF draft. 				 */
return|return
operator|(
name|DNS_R_BADLABELTYPE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|192
condition|)
block|{
comment|/* 				 * Ordinary 14-bit pointer. 				 */
if|if
condition|(
operator|(
name|dctx
operator|->
name|allowed
operator|&
name|DNS_COMPRESS_GLOBAL14
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_R_DISALLOWED
operator|)
return|;
name|new_current
operator|=
name|c
operator|&
literal|0x3F
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|fw_newcurrent
expr_stmt|;
block|}
else|else
return|return
operator|(
name|DNS_R_BADLABELTYPE
operator|)
return|;
break|break;
case|case
name|fw_ordinary
case|:
if|if
condition|(
name|downcase
condition|)
name|c
operator|=
name|maptolower
index|[
name|c
index|]
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|fw_copy
case|:
operator|*
name|ndata
operator|++
operator|=
name|c
expr_stmt|;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|state
operator|=
name|fw_start
expr_stmt|;
break|break;
case|case
name|fw_newcurrent
case|:
name|new_current
operator|*=
literal|256
expr_stmt|;
name|new_current
operator|+=
name|c
expr_stmt|;
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|new_current
operator|>=
name|biggest_pointer
condition|)
return|return
operator|(
name|DNS_R_BADPOINTER
operator|)
return|;
name|biggest_pointer
operator|=
name|new_current
expr_stmt|;
name|current
operator|=
name|new_current
expr_stmt|;
name|cdata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|source
operator|->
name|base
operator|+
name|current
expr_stmt|;
name|seen_pointer
operator|=
name|ISC_TRUE
expr_stmt|;
name|state
operator|=
name|fw_start
expr_stmt|;
break|break;
default|default:
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unknown state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Does not return. */
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
return|return
operator|(
name|ISC_R_UNEXPECTEDEND
operator|)
return|;
name|name
operator|->
name|ndata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|target
operator|->
name|base
operator|+
name|target
operator|->
name|used
expr_stmt|;
name|name
operator|->
name|labels
operator|=
name|labels
expr_stmt|;
name|name
operator|->
name|length
operator|=
name|nused
expr_stmt|;
name|name
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
name|isc_buffer_forward
argument_list|(
name|source
argument_list|,
name|cused
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|full
label|:
if|if
condition|(
name|nmax
operator|==
name|DNS_NAME_MAXWIRE
condition|)
comment|/* 		 * The name did not fit even though we had a buffer 		 * big enough to fit a maximum-length name. 		 */
return|return
operator|(
name|DNS_R_NAMETOOLONG
operator|)
return|;
else|else
comment|/* 		 * The name might fit if only the caller could give us a 		 * big enough buffer. 		 */
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_towire
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_compress_t
modifier|*
name|cctx
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|int
name|methods
decl_stmt|;
name|isc_uint16_t
name|offset
decl_stmt|;
name|dns_name_t
name|gp
decl_stmt|;
comment|/* Global compression prefix */
name|isc_boolean_t
name|gf
decl_stmt|;
comment|/* Global compression target found */
name|isc_uint16_t
name|go
decl_stmt|;
comment|/* Global compression offset */
name|dns_offsets_t
name|clo
decl_stmt|;
name|dns_name_t
name|clname
decl_stmt|;
comment|/* 	 * Convert 'name' into wire format, compressing it as specified by the 	 * compression context 'cctx', and storing the result in 'target'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|cctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If 'name' doesn't have an offsets table, make a clone which 	 * has one. 	 */
if|if
condition|(
name|name
operator|->
name|offsets
operator|==
name|NULL
condition|)
block|{
name|DNS_NAME_INIT
argument_list|(
operator|&
name|clname
argument_list|,
name|clo
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|name
argument_list|,
operator|&
name|clname
argument_list|)
expr_stmt|;
name|name
operator|=
operator|&
name|clname
expr_stmt|;
block|}
name|DNS_NAME_INIT
argument_list|(
operator|&
name|gp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset
operator|=
name|target
operator|->
name|used
expr_stmt|;
comment|/*XXX*/
name|methods
operator|=
name|dns_compress_getmethods
argument_list|(
name|cctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_NOCOMPRESS
operator|)
operator|==
literal|0
operator|&&
operator|(
name|methods
operator|&
name|DNS_COMPRESS_GLOBAL14
operator|)
operator|!=
literal|0
condition|)
name|gf
operator|=
name|dns_compress_findglobal
argument_list|(
name|cctx
argument_list|,
name|name
argument_list|,
operator|&
name|gp
argument_list|,
operator|&
name|go
argument_list|)
expr_stmt|;
else|else
name|gf
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * If the offset is too high for 14 bit global compression, we're 	 * out of luck. 	 */
if|if
condition|(
name|gf
operator|&&
name|go
operator|>=
literal|0x4000
condition|)
name|gf
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Will the compression pointer reduce the message size? 	 */
if|if
condition|(
name|gf
operator|&&
operator|(
name|gp
operator|.
name|length
operator|+
literal|2
operator|)
operator|>=
name|name
operator|->
name|length
condition|)
name|gf
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|gf
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|length
operator|-
name|target
operator|->
name|used
operator|<
name|gp
operator|.
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|target
operator|->
name|base
operator|+
name|target
operator|->
name|used
argument_list|,
name|gp
operator|.
name|ndata
argument_list|,
operator|(
name|size_t
operator|)
name|gp
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|gp
operator|.
name|length
argument_list|)
expr_stmt|;
name|go
operator||=
literal|0xc000
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|length
operator|-
name|target
operator|->
name|used
operator|<
literal|2
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|isc_buffer_putuint16
argument_list|(
name|target
argument_list|,
name|go
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|.
name|length
operator|!=
literal|0
condition|)
name|dns_compress_add
argument_list|(
name|cctx
argument_list|,
name|name
argument_list|,
operator|&
name|gp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|->
name|length
operator|-
name|target
operator|->
name|used
operator|<
name|name
operator|->
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|target
operator|->
name|base
operator|+
name|target
operator|->
name|used
argument_list|,
name|name
operator|->
name|ndata
argument_list|,
operator|(
name|size_t
operator|)
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
name|dns_compress_add
argument_list|(
name|cctx
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_concatenate
parameter_list|(
name|dns_name_t
modifier|*
name|prefix
parameter_list|,
name|dns_name_t
modifier|*
name|suffix
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|,
modifier|*
name|offsets
decl_stmt|;
name|unsigned
name|int
name|nrem
decl_stmt|,
name|labels
decl_stmt|,
name|prefix_length
decl_stmt|,
name|length
decl_stmt|;
name|isc_boolean_t
name|copy_prefix
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|copy_suffix
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|absolute
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_name_t
name|tmp_name
decl_stmt|;
name|dns_offsets_t
name|odata
decl_stmt|;
comment|/* 	 * Concatenate 'prefix' and 'suffix'. 	 */
name|REQUIRE
argument_list|(
name|prefix
operator|==
name|NULL
operator|||
name|VALID_NAME
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|suffix
operator|==
name|NULL
operator|||
name|VALID_NAME
argument_list|(
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|==
name|NULL
operator|||
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|target
argument_list|)
operator|)
operator|||
operator|(
name|target
operator|==
name|NULL
operator|&&
name|name
operator|!=
name|NULL
operator|&&
name|ISC_BUFFER_VALID
argument_list|(
name|name
operator|->
name|buffer
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|==
name|NULL
operator|||
name|prefix
operator|->
name|labels
operator|==
literal|0
condition|)
name|copy_prefix
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|suffix
operator|==
name|NULL
operator|||
name|suffix
operator|->
name|labels
operator|==
literal|0
condition|)
name|copy_suffix
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|copy_prefix
operator|&&
operator|(
name|prefix
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
block|{
name|absolute
operator|=
name|ISC_TRUE
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|copy_suffix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|DNS_NAME_INIT
argument_list|(
operator|&
name|tmp_name
argument_list|,
name|odata
argument_list|)
expr_stmt|;
name|name
operator|=
operator|&
name|tmp_name
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|name
operator|->
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|target
operator|=
name|name
operator|->
name|buffer
expr_stmt|;
name|isc_buffer_clear
argument_list|(
name|name
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up. 	 */
name|nrem
operator|=
name|target
operator|->
name|length
operator|-
name|target
operator|->
name|used
expr_stmt|;
name|ndata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|target
operator|->
name|base
operator|+
name|target
operator|->
name|used
expr_stmt|;
if|if
condition|(
name|nrem
operator|>
name|DNS_NAME_MAXWIRE
condition|)
name|nrem
operator|=
name|DNS_NAME_MAXWIRE
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|prefix_length
operator|=
literal|0
expr_stmt|;
name|labels
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|copy_prefix
condition|)
block|{
name|prefix_length
operator|=
name|prefix
operator|->
name|length
expr_stmt|;
name|length
operator|+=
name|prefix_length
expr_stmt|;
name|labels
operator|+=
name|prefix
operator|->
name|labels
expr_stmt|;
block|}
if|if
condition|(
name|copy_suffix
condition|)
block|{
name|length
operator|+=
name|suffix
operator|->
name|length
expr_stmt|;
name|labels
operator|+=
name|suffix
operator|->
name|labels
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
name|DNS_NAME_MAXWIRE
condition|)
block|{
name|MAKE_EMPTY
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_NAMETOOLONG
operator|)
return|;
block|}
if|if
condition|(
name|length
operator|>
name|nrem
condition|)
block|{
name|MAKE_EMPTY
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
block|}
if|if
condition|(
name|copy_suffix
condition|)
block|{
if|if
condition|(
operator|(
name|suffix
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
name|absolute
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|suffix
operator|==
name|name
operator|&&
name|suffix
operator|->
name|buffer
operator|==
name|target
condition|)
name|memmove
argument_list|(
name|ndata
operator|+
name|prefix_length
argument_list|,
name|suffix
operator|->
name|ndata
argument_list|,
name|suffix
operator|->
name|length
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ndata
operator|+
name|prefix_length
argument_list|,
name|suffix
operator|->
name|ndata
argument_list|,
name|suffix
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If 'prefix' and 'name' are the same object, and the object has 	 * a dedicated buffer, and we're using it, then we don't have to 	 * copy anything. 	 */
if|if
condition|(
name|copy_prefix
operator|&&
operator|(
name|prefix
operator|!=
name|name
operator|||
name|prefix
operator|->
name|buffer
operator|!=
name|target
operator|)
condition|)
name|memcpy
argument_list|(
name|ndata
argument_list|,
name|prefix
operator|->
name|ndata
argument_list|,
name|prefix_length
argument_list|)
expr_stmt|;
name|name
operator|->
name|ndata
operator|=
name|ndata
expr_stmt|;
name|name
operator|->
name|labels
operator|=
name|labels
expr_stmt|;
name|name
operator|->
name|length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|absolute
condition|)
name|name
operator|->
name|attributes
operator|=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
else|else
name|name
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|->
name|labels
operator|>
literal|0
operator|&&
name|name
operator|->
name|offsets
operator|!=
name|NULL
condition|)
block|{
name|INIT_OFFSETS
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|odata
argument_list|)
expr_stmt|;
name|set_offsets
argument_list|(
name|name
argument_list|,
name|offsets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_name_split
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|suffixlabels
parameter_list|,
name|dns_name_t
modifier|*
name|prefix
parameter_list|,
name|dns_name_t
modifier|*
name|suffix
parameter_list|)
block|{
name|unsigned
name|int
name|splitlabel
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|suffixlabels
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|suffixlabels
operator|<
name|name
operator|->
name|labels
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|prefix
operator|!=
name|NULL
operator|||
name|suffix
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|prefix
operator|==
name|NULL
operator|||
operator|(
name|VALID_NAME
argument_list|(
name|prefix
argument_list|)
operator|&&
name|prefix
operator|->
name|buffer
operator|!=
name|NULL
operator|&&
name|BINDABLE
argument_list|(
name|prefix
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|suffix
operator|==
name|NULL
operator|||
operator|(
name|VALID_NAME
argument_list|(
name|suffix
argument_list|)
operator|&&
name|suffix
operator|->
name|buffer
operator|!=
name|NULL
operator|&&
name|BINDABLE
argument_list|(
name|suffix
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|splitlabel
operator|=
name|name
operator|->
name|labels
operator|-
name|suffixlabels
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|splitlabel
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
operator|!=
name|NULL
condition|)
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
name|splitlabel
argument_list|,
name|suffixlabels
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_dup
parameter_list|(
specifier|const
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|target
parameter_list|)
block|{
comment|/* 	 * Make 'target' a dynamically allocated copy of 'source'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|source
operator|->
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Make 'target' empty in case of failure. 	 */
name|MAKE_EMPTY
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|->
name|ndata
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|source
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|ndata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memcpy
argument_list|(
name|target
operator|->
name|ndata
argument_list|,
name|source
operator|->
name|ndata
argument_list|,
name|source
operator|->
name|length
argument_list|)
expr_stmt|;
name|target
operator|->
name|length
operator|=
name|source
operator|->
name|length
expr_stmt|;
name|target
operator|->
name|labels
operator|=
name|source
operator|->
name|labels
expr_stmt|;
name|target
operator|->
name|attributes
operator|=
name|DNS_NAMEATTR_DYNAMIC
expr_stmt|;
if|if
condition|(
operator|(
name|source
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
name|target
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|offsets
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|source
operator|->
name|offsets
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|target
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|labels
argument_list|)
expr_stmt|;
else|else
name|set_offsets
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|offsets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_dupwithoffsets
parameter_list|(
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|target
parameter_list|)
block|{
comment|/* 	 * Make 'target' a read-only dynamically allocated copy of 'source'. 	 * 'target' will also have a dynamically allocated offsets table. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|source
operator|->
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|->
name|offsets
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Make 'target' empty in case of failure. 	 */
name|MAKE_EMPTY
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|->
name|ndata
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|source
operator|->
name|length
operator|+
name|source
operator|->
name|labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|ndata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memcpy
argument_list|(
name|target
operator|->
name|ndata
argument_list|,
name|source
operator|->
name|ndata
argument_list|,
name|source
operator|->
name|length
argument_list|)
expr_stmt|;
name|target
operator|->
name|length
operator|=
name|source
operator|->
name|length
expr_stmt|;
name|target
operator|->
name|labels
operator|=
name|source
operator|->
name|labels
expr_stmt|;
name|target
operator|->
name|attributes
operator|=
name|DNS_NAMEATTR_DYNAMIC
operator||
name|DNS_NAMEATTR_DYNOFFSETS
operator||
name|DNS_NAMEATTR_READONLY
expr_stmt|;
if|if
condition|(
operator|(
name|source
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
name|target
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
name|target
operator|->
name|offsets
operator|=
name|target
operator|->
name|ndata
operator|+
name|source
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|offsets
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|target
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|labels
argument_list|)
expr_stmt|;
else|else
name|set_offsets
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|offsets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_name_free
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
comment|/* 	 * Free 'name'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_DYNAMIC
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
name|name
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_DYNOFFSETS
operator|)
operator|!=
literal|0
condition|)
name|size
operator|+=
name|name
operator|->
name|labels
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|name
operator|->
name|ndata
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dns_name_invalidate
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_digest
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_digestfunc_t
name|digest
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dns_name_t
name|downname
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|256
index|]
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
comment|/* 	 * Send 'name' in DNSSEC canonical form to 'digest'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|digest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DNS_NAME_INIT
argument_list|(
operator|&
name|downname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_downcase
argument_list|(
name|name
argument_list|,
operator|&
name|downname
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|digest
call|)
argument_list|(
name|arg
argument_list|,
operator|&
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_name_dynamic
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Returns whether there is dynamic memory associated with this name. 	 */
return|return
operator|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_DYNAMIC
operator|)
operator|!=
literal|0
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_print
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|char
name|t
index|[
literal|1024
index|]
decl_stmt|;
comment|/* 	 * Print 'name' on 'stream'. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_totext
argument_list|(
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|r
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_settotextfilter
parameter_list|(
name|dns_name_totextfilter_t
name|proc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_totextfilter_t
modifier|*
name|mem
decl_stmt|;
name|int
name|res
decl_stmt|;
name|result
operator|=
name|totext_filter_proc_key_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * If we already have been here set / clear as appropriate. 	 * Otherwise allocate memory. 	 */
name|mem
operator|=
name|isc_thread_key_getspecific
argument_list|(
name|totext_filter_proc_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
operator|&&
name|proc
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mem
operator|=
name|proc
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|proc
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|thread_key_mctx
argument_list|,
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|isc_thread_key_setspecific
argument_list|(
name|totext_filter_proc_key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|mem
operator|=
name|isc_mem_get
argument_list|(
name|thread_key_mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|*
name|mem
operator|=
name|proc
expr_stmt|;
if|if
condition|(
name|isc_thread_key_setspecific
argument_list|(
name|totext_filter_proc_key
argument_list|,
name|mem
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isc_mem_put
argument_list|(
name|thread_key_mctx
argument_list|,
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
name|totext_filter_proc
operator|=
name|proc
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dns_name_format
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|buf
decl_stmt|;
name|REQUIRE
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Leave room for null termination after buffer. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|cp
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_totext
argument_list|(
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Null terminate. 		 */
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
operator|)
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|cp
argument_list|,
name|size
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_name_copy
parameter_list|(
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|dns_name_t
modifier|*
name|dest
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ndata
decl_stmt|;
comment|/* 	 * Make dest a copy of source. 	 */
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_NAME
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|||
name|dest
operator|->
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|target
operator|=
name|dest
operator|->
name|buffer
expr_stmt|;
name|isc_buffer_clear
argument_list|(
name|dest
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|BINDABLE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up. 	 */
if|if
condition|(
name|target
operator|->
name|length
operator|-
name|target
operator|->
name|used
operator|<
name|source
operator|->
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|ndata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|target
operator|->
name|base
operator|+
name|target
operator|->
name|used
expr_stmt|;
name|dest
operator|->
name|ndata
operator|=
name|target
operator|->
name|base
expr_stmt|;
name|memcpy
argument_list|(
name|ndata
argument_list|,
name|source
operator|->
name|ndata
argument_list|,
name|source
operator|->
name|length
argument_list|)
expr_stmt|;
name|dest
operator|->
name|ndata
operator|=
name|ndata
expr_stmt|;
name|dest
operator|->
name|labels
operator|=
name|source
operator|->
name|labels
expr_stmt|;
name|dest
operator|->
name|length
operator|=
name|source
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|source
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
name|dest
operator|->
name|attributes
operator|=
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
else|else
name|dest
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|labels
operator|>
literal|0
operator|&&
name|dest
operator|->
name|offsets
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|source
operator|->
name|offsets
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|dest
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|offsets
argument_list|,
name|source
operator|->
name|labels
argument_list|)
expr_stmt|;
else|else
name|set_offsets
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|offsets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|dest
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_name_destroy
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|once
argument_list|,
name|thread_key_mutex_init
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|thread_key_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_key_initialized
condition|)
block|{
name|isc_mem_detach
argument_list|(
operator|&
name|thread_key_mctx
argument_list|)
expr_stmt|;
name|isc_thread_key_delete
argument_list|(
name|totext_filter_proc_key
argument_list|)
expr_stmt|;
name|thread_key_initialized
operator|=
literal|0
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|thread_key_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

