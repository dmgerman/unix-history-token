begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===----- HexagonMCChecker.h - Instruction bundle checking ---------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This implements the checking of insns inside a bundle according to the
end_comment

begin_comment
comment|// packet constraint rules of the Hexagon ISA.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HEXAGONMCCHECKER_H
end_ifndef

begin_define
define|#
directive|define
name|HEXAGONMCCHECKER_H
end_define

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_include
include|#
directive|include
file|<queue>
end_include

begin_include
include|#
directive|include
file|"MCTargetDesc/HexagonMCShuffler.h"
end_include

begin_decl_stmt
name|using
name|namespace
name|llvm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MCOperandInfo
decl_stmt|;
typedef|typedef
struct|struct
block|{
name|unsigned
name|Error
decl_stmt|,
name|Warning
decl_stmt|,
name|ShuffleError
decl_stmt|;
name|unsigned
name|Register
decl_stmt|;
block|}
name|ErrInfo_T
typedef|;
name|class
name|HexagonMCErrInfo
block|{
name|public
label|:
enum|enum
block|{
name|CHECK_SUCCESS
init|=
literal|0
block|,
comment|// Errors.
name|CHECK_ERROR_BRANCHES
init|=
literal|0x00001
block|,
name|CHECK_ERROR_NEWP
init|=
literal|0x00002
block|,
name|CHECK_ERROR_NEWV
init|=
literal|0x00004
block|,
name|CHECK_ERROR_REGISTERS
init|=
literal|0x00008
block|,
name|CHECK_ERROR_READONLY
init|=
literal|0x00010
block|,
name|CHECK_ERROR_LOOP
init|=
literal|0x00020
block|,
name|CHECK_ERROR_ENDLOOP
init|=
literal|0x00040
block|,
name|CHECK_ERROR_SOLO
init|=
literal|0x00080
block|,
name|CHECK_ERROR_SHUFFLE
init|=
literal|0x00100
block|,
name|CHECK_ERROR_NOSLOTS
init|=
literal|0x00200
block|,
name|CHECK_ERROR_UNKNOWN
init|=
literal|0x00400
block|,
comment|// Warnings.
name|CHECK_WARN_CURRENT
init|=
literal|0x10000
block|,
name|CHECK_WARN_TEMPORARY
init|=
literal|0x20000
block|}
enum|;
name|ErrInfo_T
name|s
decl_stmt|;
name|void
name|reset
parameter_list|()
block|{
name|s
operator|.
name|Error
operator|=
name|CHECK_SUCCESS
expr_stmt|;
name|s
operator|.
name|Warning
operator|=
name|CHECK_SUCCESS
expr_stmt|;
name|s
operator|.
name|ShuffleError
operator|=
name|HexagonShuffler
operator|::
name|SHUFFLE_SUCCESS
expr_stmt|;
name|s
operator|.
name|Register
operator|=
name|Hexagon
operator|::
name|NoRegister
expr_stmt|;
block|}
empty_stmt|;
name|HexagonMCErrInfo
argument_list|()
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
name|void
name|setError
parameter_list|(
name|unsigned
name|e
parameter_list|,
name|unsigned
name|r
init|=
name|Hexagon
operator|::
name|NoRegister
parameter_list|)
block|{
name|s
operator|.
name|Error
operator|=
name|e
expr_stmt|;
name|s
operator|.
name|Register
operator|=
name|r
expr_stmt|;
block|}
empty_stmt|;
name|void
name|setWarning
parameter_list|(
name|unsigned
name|w
parameter_list|,
name|unsigned
name|r
init|=
name|Hexagon
operator|::
name|NoRegister
parameter_list|)
block|{
name|s
operator|.
name|Warning
operator|=
name|w
expr_stmt|;
name|s
operator|.
name|Register
operator|=
name|r
expr_stmt|;
block|}
empty_stmt|;
name|void
name|setShuffleError
parameter_list|(
name|unsigned
name|e
parameter_list|)
block|{
name|s
operator|.
name|ShuffleError
operator|=
name|e
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/// Check for a valid bundle.
name|class
name|HexagonMCChecker
block|{
comment|/// Insn bundle.
name|MCInst
modifier|&
name|MCB
decl_stmt|;
name|MCInst
modifier|&
name|MCBDX
decl_stmt|;
specifier|const
name|MCRegisterInfo
modifier|&
name|RI
decl_stmt|;
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
decl_stmt|;
name|MCSubtargetInfo
specifier|const
modifier|&
name|STI
decl_stmt|;
name|bool
name|bLoadErrInfo
decl_stmt|;
comment|/// Set of definitions: register #, if predicated, if predicated true.
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|bool
operator|>
name|PredSense
expr_stmt|;
specifier|static
specifier|const
name|PredSense
name|Unconditional
decl_stmt|;
typedef|typedef
name|std
operator|::
name|multiset
operator|<
name|PredSense
operator|>
name|PredSet
expr_stmt|;
typedef|typedef
name|std
operator|::
name|multiset
operator|<
name|PredSense
operator|>
operator|::
name|iterator
name|PredSetIterator
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|PredSet
operator|>
operator|::
name|iterator
name|DefsIterator
expr_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|PredSet
operator|>
name|Defs
expr_stmt|;
comment|/// Information about how a new-value register is defined or used:
comment|///   PredReg = predicate register, 0 if use/def not predicated,
comment|///   Cond    = true/false for if(PredReg)/if(!PredReg) respectively,
comment|///   IsFloat = true if definition produces a floating point value
comment|///             (not valid for uses),
comment|///   IsNVJ   = true if the use is a new-value branch (not valid for
comment|///             definitions).
struct|struct
name|NewSense
block|{
name|unsigned
name|PredReg
decl_stmt|;
name|bool
name|IsFloat
decl_stmt|,
name|IsNVJ
decl_stmt|,
name|Cond
decl_stmt|;
comment|// The special-case "constructors":
specifier|static
name|NewSense
name|Jmp
parameter_list|(
name|bool
name|isNVJ
parameter_list|)
block|{
name|NewSense
name|NS
init|=
block|{
comment|/*PredReg=*/
literal|0
block|,
comment|/*IsFloat=*/
name|false
block|,
comment|/*IsNVJ=*/
name|isNVJ
block|,
comment|/*Cond=*/
name|false
block|}
decl_stmt|;
return|return
name|NS
return|;
block|}
specifier|static
name|NewSense
name|Use
parameter_list|(
name|unsigned
name|PR
parameter_list|,
name|bool
name|True
parameter_list|)
block|{
name|NewSense
name|NS
init|=
block|{
comment|/*PredReg=*/
name|PR
block|,
comment|/*IsFloat=*/
name|false
block|,
comment|/*IsNVJ=*/
name|false
block|,
comment|/*Cond=*/
name|True
block|}
decl_stmt|;
return|return
name|NS
return|;
block|}
specifier|static
name|NewSense
name|Def
parameter_list|(
name|unsigned
name|PR
parameter_list|,
name|bool
name|True
parameter_list|,
name|bool
name|Float
parameter_list|)
block|{
name|NewSense
name|NS
init|=
block|{
comment|/*PredReg=*/
name|PR
block|,
comment|/*IsFloat=*/
name|Float
block|,
comment|/*IsNVJ=*/
name|false
block|,
comment|/*Cond=*/
name|True
block|}
decl_stmt|;
return|return
name|NS
return|;
block|}
block|}
struct|;
comment|/// Set of definitions that produce new register:
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|NewSense
operator|,
literal|2
operator|>
name|NewSenseList
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|NewSenseList
operator|>
operator|::
name|iterator
name|NewDefsIterator
expr_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|NewSenseList
operator|>
name|NewDefs
expr_stmt|;
comment|/// Set of weak definitions whose clashes should be enforced selectively.
typedef|typedef
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|SoftDefsIterator
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|SoftDefs
expr_stmt|;
comment|/// Set of current definitions committed to the register file.
typedef|typedef
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|CurDefsIterator
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|CurDefs
expr_stmt|;
comment|/// Set of temporary definitions not committed to the register file.
typedef|typedef
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|TmpDefsIterator
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|TmpDefs
expr_stmt|;
comment|/// Set of new predicates used.
typedef|typedef
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|NewPredsIterator
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|NewPreds
expr_stmt|;
comment|/// Set of predicates defined late.
typedef|typedef
name|std
operator|::
name|multiset
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|LatePredsIterator
expr_stmt|;
name|std
operator|::
name|multiset
operator|<
name|unsigned
operator|>
name|LatePreds
expr_stmt|;
comment|/// Set of uses.
typedef|typedef
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|UsesIterator
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|Uses
expr_stmt|;
comment|/// Set of new values used: new register, if new-value jump.
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|NewSense
operator|>
operator|::
name|iterator
name|NewUsesIterator
expr_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
name|unsigned
operator|,
name|NewSense
operator|>
name|NewUses
expr_stmt|;
comment|/// Pre-defined set of read-only registers.
typedef|typedef
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|ReadOnlyIterator
expr_stmt|;
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
name|ReadOnly
expr_stmt|;
name|std
operator|::
name|queue
operator|<
name|ErrInfo_T
operator|>
name|ErrInfoQ
expr_stmt|;
name|HexagonMCErrInfo
name|CrntErrInfo
decl_stmt|;
name|void
name|getErrInfo
parameter_list|()
block|{
if|if
condition|(
name|bLoadErrInfo
operator|==
name|true
condition|)
block|{
if|if
condition|(
name|ErrInfoQ
operator|.
name|empty
argument_list|()
condition|)
block|{
name|CrntErrInfo
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|CrntErrInfo
operator|.
name|s
operator|=
name|ErrInfoQ
operator|.
name|front
argument_list|()
expr_stmt|;
name|ErrInfoQ
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
name|bLoadErrInfo
operator|=
name|false
expr_stmt|;
block|}
name|void
name|init
parameter_list|()
function_decl|;
name|void
name|init
parameter_list|(
name|MCInst
specifier|const
modifier|&
parameter_list|)
function_decl|;
comment|// Checks performed.
name|bool
name|checkBranches
parameter_list|()
function_decl|;
name|bool
name|checkPredicates
parameter_list|()
function_decl|;
name|bool
name|checkNewValues
parameter_list|()
function_decl|;
name|bool
name|checkRegisters
parameter_list|()
function_decl|;
name|bool
name|checkSolo
parameter_list|()
function_decl|;
name|bool
name|checkShuffle
parameter_list|()
function_decl|;
name|bool
name|checkSlots
parameter_list|()
function_decl|;
specifier|static
name|void
name|compoundRegisterMap
parameter_list|(
name|unsigned
modifier|&
parameter_list|)
function_decl|;
name|bool
name|isPredicateRegister
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
return|return
operator|(
name|Hexagon
operator|::
name|P0
operator|==
name|R
operator|||
name|Hexagon
operator|::
name|P1
operator|==
name|R
operator|||
name|Hexagon
operator|::
name|P2
operator|==
name|R
operator|||
name|Hexagon
operator|::
name|P3
operator|==
name|R
operator|)
return|;
block|}
empty_stmt|;
name|bool
name|isLoopRegister
argument_list|(
name|unsigned
name|R
argument_list|)
decl|const
block|{
return|return
operator|(
name|Hexagon
operator|::
name|SA0
operator|==
name|R
operator|||
name|Hexagon
operator|::
name|LC0
operator|==
name|R
operator|||
name|Hexagon
operator|::
name|SA1
operator|==
name|R
operator|||
name|Hexagon
operator|::
name|LC1
operator|==
name|R
operator|)
return|;
block|}
empty_stmt|;
name|bool
name|hasValidNewValueDef
argument_list|(
specifier|const
name|NewSense
operator|&
name|Use
argument_list|,
specifier|const
name|NewSenseList
operator|&
name|Defs
argument_list|)
decl|const
decl_stmt|;
name|public
label|:
name|explicit
name|HexagonMCChecker
parameter_list|(
name|MCInstrInfo
specifier|const
modifier|&
name|MCII
parameter_list|,
name|MCSubtargetInfo
specifier|const
modifier|&
name|STI
parameter_list|,
name|MCInst
modifier|&
name|mcb
parameter_list|,
name|MCInst
modifier|&
name|mcbdx
parameter_list|,
specifier|const
name|MCRegisterInfo
modifier|&
name|ri
parameter_list|)
function_decl|;
name|bool
name|check
parameter_list|()
function_decl|;
comment|/// add a new error/warning
name|void
name|addErrInfo
parameter_list|(
name|HexagonMCErrInfo
modifier|&
name|err
parameter_list|)
block|{
name|ErrInfoQ
operator|.
name|push
argument_list|(
name|err
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/// Return the error code for the last operation in the insn bundle.
name|unsigned
name|getError
parameter_list|()
block|{
name|getErrInfo
argument_list|()
expr_stmt|;
return|return
name|CrntErrInfo
operator|.
name|s
operator|.
name|Error
return|;
block|}
empty_stmt|;
name|unsigned
name|getWarning
parameter_list|()
block|{
name|getErrInfo
argument_list|()
expr_stmt|;
return|return
name|CrntErrInfo
operator|.
name|s
operator|.
name|Warning
return|;
block|}
empty_stmt|;
name|unsigned
name|getShuffleError
parameter_list|()
block|{
name|getErrInfo
argument_list|()
expr_stmt|;
return|return
name|CrntErrInfo
operator|.
name|s
operator|.
name|ShuffleError
return|;
block|}
empty_stmt|;
name|unsigned
name|getErrRegister
parameter_list|()
block|{
name|getErrInfo
argument_list|()
expr_stmt|;
return|return
name|CrntErrInfo
operator|.
name|s
operator|.
name|Register
return|;
block|}
empty_stmt|;
name|bool
name|getNextErrInfo
parameter_list|()
block|{
name|bLoadErrInfo
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|ErrInfoQ
operator|.
name|empty
argument_list|()
operator|)
condition|?
name|false
else|:
operator|(
name|getErrInfo
argument_list|()
operator|,
name|true
operator|)
return|;
block|}
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// HEXAGONMCCHECKER_H
end_comment

end_unit

