begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===- X86DisassemblerDecoder.c - Disassembler decoder -------------*- C -*-==*  *  *                     The LLVM Compiler Infrastructure  *  * This file is distributed under the University of Illinois Open Source  * License. See LICENSE.TXT for details.  *  *===----------------------------------------------------------------------===*  *  * This file is part of the X86 Disassembler.  * It contains the implementation of the instruction decoder.  * Documentation for the disassembler can be found in X86Disassembler.h.  *  *===----------------------------------------------------------------------===*/
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/* for assert()     */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_comment
comment|/* for va_*()       */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* for vsnprintf()  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for exit()       */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* for memset()     */
end_comment

begin_include
include|#
directive|include
file|"X86DisassemblerDecoder.h"
end_include

begin_include
include|#
directive|include
file|"X86GenDisassemblerTables.inc"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|NORETURN
value|__attribute__((noreturn))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|unreachable
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                      \     fprintf(stderr, "%s:%d: %s\n", __FILE__, __LINE__, s);  \     exit(-1);                                               \   } while (0);
end_define

begin_comment
comment|/*  * contextForAttrs - Client for the instruction context table.  Takes a set of  *   attributes and returns the appropriate decode context.  *  * @param attrMask  - Attributes, from the enumeration attributeBits.  * @return          - The InstructionContext to use when looking up an  *                    an instruction with these attributes.  */
end_comment

begin_function
specifier|static
name|InstructionContext
name|contextForAttrs
parameter_list|(
name|uint8_t
name|attrMask
parameter_list|)
block|{
return|return
name|CONTEXTS_SYM
index|[
name|attrMask
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * modRMRequired - Reads the appropriate instruction table to determine whether  *   the ModR/M byte is required to decode a particular instruction.  *  * @param type        - The opcode type (i.e., how many bytes it has).  * @param insnContext - The context for the instruction, as returned by  *                      contextForAttrs.  * @param opcode      - The last byte of the instruction's opcode, not counting  *                      ModR/M extensions and escapes.  * @return            - TRUE if the ModR/M byte is required, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|modRMRequired
parameter_list|(
name|OpcodeType
name|type
parameter_list|,
name|InstructionContext
name|insnContext
parameter_list|,
name|uint8_t
name|opcode
parameter_list|)
block|{
specifier|const
name|struct
name|ContextDecision
modifier|*
name|decision
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ONEBYTE
case|:
name|decision
operator|=
operator|&
name|ONEBYTE_SYM
expr_stmt|;
break|break;
case|case
name|TWOBYTE
case|:
name|decision
operator|=
operator|&
name|TWOBYTE_SYM
expr_stmt|;
break|break;
case|case
name|THREEBYTE_38
case|:
name|decision
operator|=
operator|&
name|THREEBYTE38_SYM
expr_stmt|;
break|break;
case|case
name|THREEBYTE_3A
case|:
name|decision
operator|=
operator|&
name|THREEBYTE3A_SYM
expr_stmt|;
break|break;
block|}
return|return
name|decision
operator|->
name|opcodeDecisions
index|[
name|insnContext
index|]
operator|.
name|modRMDecisions
index|[
name|opcode
index|]
operator|.
name|modrm_type
operator|!=
name|MODRM_ONEENTRY
return|;
name|unreachable
argument_list|(
literal|"Unknown opcode type"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * decode - Reads the appropriate instruction table to obtain the unique ID of  *   an instruction.  *  * @param type        - See modRMRequired().  * @param insnContext - See modRMRequired().  * @param opcode      - See modRMRequired().  * @param modRM       - The ModR/M byte if required, or any value if not.  */
end_comment

begin_function
specifier|static
name|InstrUID
name|decode
parameter_list|(
name|OpcodeType
name|type
parameter_list|,
name|InstructionContext
name|insnContext
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|uint8_t
name|modRM
parameter_list|)
block|{
name|struct
name|ModRMDecision
modifier|*
name|dec
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
name|unreachable
argument_list|(
literal|"Unknown opcode type"
argument_list|)
expr_stmt|;
case|case
name|ONEBYTE
case|:
name|dec
operator|=
operator|&
name|ONEBYTE_SYM
operator|.
name|opcodeDecisions
index|[
name|insnContext
index|]
operator|.
name|modRMDecisions
index|[
name|opcode
index|]
expr_stmt|;
break|break;
case|case
name|TWOBYTE
case|:
name|dec
operator|=
operator|&
name|TWOBYTE_SYM
operator|.
name|opcodeDecisions
index|[
name|insnContext
index|]
operator|.
name|modRMDecisions
index|[
name|opcode
index|]
expr_stmt|;
break|break;
case|case
name|THREEBYTE_38
case|:
name|dec
operator|=
operator|&
name|THREEBYTE38_SYM
operator|.
name|opcodeDecisions
index|[
name|insnContext
index|]
operator|.
name|modRMDecisions
index|[
name|opcode
index|]
expr_stmt|;
break|break;
case|case
name|THREEBYTE_3A
case|:
name|dec
operator|=
operator|&
name|THREEBYTE3A_SYM
operator|.
name|opcodeDecisions
index|[
name|insnContext
index|]
operator|.
name|modRMDecisions
index|[
name|opcode
index|]
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|dec
operator|->
name|modrm_type
condition|)
block|{
default|default:
name|unreachable
argument_list|(
literal|"Corrupt table!  Unknown modrm_type"
argument_list|)
expr_stmt|;
case|case
name|MODRM_ONEENTRY
case|:
return|return
name|dec
operator|->
name|instructionIDs
index|[
literal|0
index|]
return|;
case|case
name|MODRM_SPLITRM
case|:
if|if
condition|(
name|modFromModRM
argument_list|(
name|modRM
argument_list|)
operator|==
literal|0x3
condition|)
return|return
name|dec
operator|->
name|instructionIDs
index|[
literal|1
index|]
return|;
else|else
return|return
name|dec
operator|->
name|instructionIDs
index|[
literal|0
index|]
return|;
case|case
name|MODRM_FULL
case|:
return|return
name|dec
operator|->
name|instructionIDs
index|[
name|modRM
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * specifierForUID - Given a UID, returns the name and operand specification for  *   that instruction.  *  * @param uid - The unique ID for the instruction.  This should be returned by  *              decode(); specifierForUID will not check bounds.  * @return    - A pointer to the specification for that instruction.  */
end_comment

begin_function
specifier|static
name|struct
name|InstructionSpecifier
modifier|*
name|specifierForUID
parameter_list|(
name|InstrUID
name|uid
parameter_list|)
block|{
return|return
operator|&
name|INSTRUCTIONS_SYM
index|[
name|uid
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * consumeByte - Uses the reader function provided by the user to consume one  *   byte from the instruction's memory and advance the cursor.  *  * @param insn  - The instruction with the reader function to use.  The cursor  *                for this instruction is advanced.  * @param byte  - A pointer to a pre-allocated memory buffer to be populated  *                with the data read.  * @return      - 0 if the read was successful; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|consumeByte
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|uint8_t
modifier|*
name|byte
parameter_list|)
block|{
name|int
name|ret
init|=
name|insn
operator|->
name|reader
argument_list|(
name|insn
operator|->
name|readerArg
argument_list|,
name|byte
argument_list|,
name|insn
operator|->
name|readerCursor
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
operator|++
operator|(
name|insn
operator|->
name|readerCursor
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * lookAtByte - Like consumeByte, but does not advance the cursor.  *  * @param insn  - See consumeByte().  * @param byte  - See consumeByte().  * @return      - See consumeByte().  */
end_comment

begin_function
specifier|static
name|int
name|lookAtByte
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|uint8_t
modifier|*
name|byte
parameter_list|)
block|{
return|return
name|insn
operator|->
name|reader
argument_list|(
name|insn
operator|->
name|readerArg
argument_list|,
name|byte
argument_list|,
name|insn
operator|->
name|readerCursor
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unconsumeByte
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|insn
operator|->
name|readerCursor
operator|--
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CONSUME_FUNC
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|static int name(struct InternalInstruction* insn, type* ptr) {  \     type combined = 0;                                            \     unsigned offset;                                              \     for (offset = 0; offset< sizeof(type); ++offset) {           \       uint8_t byte;                                               \       int ret = insn->reader(insn->readerArg,                     \&byte,                               \                              insn->readerCursor + offset);        \       if (ret)                                                    \         return ret;                                               \       combined = combined | ((type)byte<< ((type)offset * 8));   \     }                                                             \     *ptr = combined;                                              \     insn->readerCursor += sizeof(type);                           \     return 0;                                                     \   }
end_define

begin_comment
comment|/*  * consume* - Use the reader function provided by the user to consume data  *   values of various sizes from the instruction's memory and advance the  *   cursor appropriately.  These readers perform endian conversion.  *  * @param insn    - See consumeByte().  * @param ptr     - A pointer to a pre-allocated memory of appropriate size to  *                  be populated with the data read.  * @return        - See consumeByte().  */
end_comment

begin_macro
name|CONSUME_FUNC
argument_list|(
argument|consumeInt8
argument_list|,
argument|int8_t
argument_list|)
end_macro

begin_macro
name|CONSUME_FUNC
argument_list|(
argument|consumeInt16
argument_list|,
argument|int16_t
argument_list|)
end_macro

begin_macro
name|CONSUME_FUNC
argument_list|(
argument|consumeInt32
argument_list|,
argument|int32_t
argument_list|)
end_macro

begin_macro
name|CONSUME_FUNC
argument_list|(
argument|consumeUInt16
argument_list|,
argument|uint16_t
argument_list|)
end_macro

begin_macro
name|CONSUME_FUNC
argument_list|(
argument|consumeUInt32
argument_list|,
argument|uint32_t
argument_list|)
end_macro

begin_macro
name|CONSUME_FUNC
argument_list|(
argument|consumeUInt64
argument_list|,
argument|uint64_t
argument_list|)
end_macro

begin_comment
comment|/*  * dbgprintf - Uses the logging function provided by the user to log a single  *   message, typically without a carriage-return.  *  * @param insn    - The instruction containing the logging function.  * @param format  - See printf().  * @param ...     - See printf().  */
end_comment

begin_function
specifier|static
name|void
name|dbgprintf
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|insn
operator|->
name|dlog
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|insn
operator|->
name|dlog
argument_list|(
name|insn
operator|->
name|dlogArg
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * setPrefixPresent - Marks that a particular prefix is present at a particular  *   location.  *  * @param insn      - The instruction to be marked as having the prefix.  * @param prefix    - The prefix that is present.  * @param location  - The location where the prefix is located (in the address  *                    space of the instruction's reader).  */
end_comment

begin_function
specifier|static
name|void
name|setPrefixPresent
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|uint8_t
name|prefix
parameter_list|,
name|uint64_t
name|location
parameter_list|)
block|{
name|insn
operator|->
name|prefixPresent
index|[
name|prefix
index|]
operator|=
literal|1
expr_stmt|;
name|insn
operator|->
name|prefixLocations
index|[
name|prefix
index|]
operator|=
name|location
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * isPrefixAtLocation - Queries an instruction to determine whether a prefix is  *   present at a given location.  *  * @param insn      - The instruction to be queried.  * @param prefix    - The prefix.  * @param location  - The location to query.  * @return          - Whether the prefix is at that location.  */
end_comment

begin_function
specifier|static
name|BOOL
name|isPrefixAtLocation
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|uint8_t
name|prefix
parameter_list|,
name|uint64_t
name|location
parameter_list|)
block|{
if|if
condition|(
name|insn
operator|->
name|prefixPresent
index|[
name|prefix
index|]
operator|==
literal|1
operator|&&
name|insn
operator|->
name|prefixLocations
index|[
name|prefix
index|]
operator|==
name|location
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * readPrefixes - Consumes all of an instruction's prefix bytes, and marks the  *   instruction as having them.  Also sets the instruction's default operand,  *   address, and other relevant data sizes to report operands correctly.  *  * @param insn  - The instruction whose prefixes are to be read.  * @return      - 0 if the instruction could be read until the end of the prefix  *                bytes, and no prefixes conflicted; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|readPrefixes
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|BOOL
name|isPrefix
init|=
name|TRUE
decl_stmt|;
name|BOOL
name|prefixGroups
index|[
literal|4
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
name|uint64_t
name|prefixLocation
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|BOOL
name|hasAdSize
init|=
name|FALSE
decl_stmt|;
name|BOOL
name|hasOpSize
init|=
name|FALSE
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readPrefixes()"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isPrefix
condition|)
block|{
name|prefixLocation
operator|=
name|insn
operator|->
name|readerCursor
expr_stmt|;
if|if
condition|(
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|byte
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|byte
condition|)
block|{
case|case
literal|0xf0
case|:
comment|/* LOCK */
case|case
literal|0xf2
case|:
comment|/* REPNE/REPNZ */
case|case
literal|0xf3
case|:
comment|/* REP or REPE/REPZ */
if|if
condition|(
name|prefixGroups
index|[
literal|0
index|]
condition|)
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Redundant Group 1 prefix"
argument_list|)
expr_stmt|;
name|prefixGroups
index|[
literal|0
index|]
operator|=
name|TRUE
expr_stmt|;
name|setPrefixPresent
argument_list|(
name|insn
argument_list|,
name|byte
argument_list|,
name|prefixLocation
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2e
case|:
comment|/* CS segment override -OR- Branch not taken */
case|case
literal|0x36
case|:
comment|/* SS segment override -OR- Branch taken */
case|case
literal|0x3e
case|:
comment|/* DS segment override */
case|case
literal|0x26
case|:
comment|/* ES segment override */
case|case
literal|0x64
case|:
comment|/* FS segment override */
case|case
literal|0x65
case|:
comment|/* GS segment override */
switch|switch
condition|(
name|byte
condition|)
block|{
case|case
literal|0x2e
case|:
name|insn
operator|->
name|segmentOverride
operator|=
name|SEG_OVERRIDE_CS
expr_stmt|;
break|break;
case|case
literal|0x36
case|:
name|insn
operator|->
name|segmentOverride
operator|=
name|SEG_OVERRIDE_SS
expr_stmt|;
break|break;
case|case
literal|0x3e
case|:
name|insn
operator|->
name|segmentOverride
operator|=
name|SEG_OVERRIDE_DS
expr_stmt|;
break|break;
case|case
literal|0x26
case|:
name|insn
operator|->
name|segmentOverride
operator|=
name|SEG_OVERRIDE_ES
expr_stmt|;
break|break;
case|case
literal|0x64
case|:
name|insn
operator|->
name|segmentOverride
operator|=
name|SEG_OVERRIDE_FS
expr_stmt|;
break|break;
case|case
literal|0x65
case|:
name|insn
operator|->
name|segmentOverride
operator|=
name|SEG_OVERRIDE_GS
expr_stmt|;
break|break;
default|default:
name|unreachable
argument_list|(
literal|"Unhandled override"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefixGroups
index|[
literal|1
index|]
condition|)
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Redundant Group 2 prefix"
argument_list|)
expr_stmt|;
name|prefixGroups
index|[
literal|1
index|]
operator|=
name|TRUE
expr_stmt|;
name|setPrefixPresent
argument_list|(
name|insn
argument_list|,
name|byte
argument_list|,
name|prefixLocation
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x66
case|:
comment|/* Operand-size override */
if|if
condition|(
name|prefixGroups
index|[
literal|2
index|]
condition|)
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Redundant Group 3 prefix"
argument_list|)
expr_stmt|;
name|prefixGroups
index|[
literal|2
index|]
operator|=
name|TRUE
expr_stmt|;
name|hasOpSize
operator|=
name|TRUE
expr_stmt|;
name|setPrefixPresent
argument_list|(
name|insn
argument_list|,
name|byte
argument_list|,
name|prefixLocation
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x67
case|:
comment|/* Address-size override */
if|if
condition|(
name|prefixGroups
index|[
literal|3
index|]
condition|)
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Redundant Group 4 prefix"
argument_list|)
expr_stmt|;
name|prefixGroups
index|[
literal|3
index|]
operator|=
name|TRUE
expr_stmt|;
name|hasAdSize
operator|=
name|TRUE
expr_stmt|;
name|setPrefixPresent
argument_list|(
name|insn
argument_list|,
name|byte
argument_list|,
name|prefixLocation
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Not a prefix byte */
name|isPrefix
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isPrefix
condition|)
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Found prefix 0x%hhx"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|->
name|mode
operator|==
name|MODE_64BIT
condition|)
block|{
if|if
condition|(
operator|(
name|byte
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
condition|)
block|{
name|uint8_t
name|opcodeByte
decl_stmt|;
if|if
condition|(
name|lookAtByte
argument_list|(
name|insn
argument_list|,
operator|&
name|opcodeByte
argument_list|)
operator|||
operator|(
operator|(
name|opcodeByte
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
operator|)
condition|)
block|{
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Redundant REX prefix"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|insn
operator|->
name|rexPrefix
operator|=
name|byte
expr_stmt|;
name|insn
operator|->
name|necessaryPrefixLocation
operator|=
name|insn
operator|->
name|readerCursor
operator|-
literal|2
expr_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Found REX prefix 0x%hhx"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unconsumeByte
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|->
name|necessaryPrefixLocation
operator|=
name|insn
operator|->
name|readerCursor
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|unconsumeByte
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|->
name|mode
operator|==
name|MODE_16BIT
condition|)
block|{
name|insn
operator|->
name|registerSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|4
else|:
literal|2
operator|)
expr_stmt|;
name|insn
operator|->
name|addressSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|4
else|:
literal|2
operator|)
expr_stmt|;
name|insn
operator|->
name|displacementSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|4
else|:
literal|2
operator|)
expr_stmt|;
name|insn
operator|->
name|immediateSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|4
else|:
literal|2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|->
name|mode
operator|==
name|MODE_32BIT
condition|)
block|{
name|insn
operator|->
name|registerSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|insn
operator|->
name|addressSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|insn
operator|->
name|displacementSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|insn
operator|->
name|immediateSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|->
name|mode
operator|==
name|MODE_64BIT
condition|)
block|{
if|if
condition|(
name|insn
operator|->
name|rexPrefix
operator|&&
name|wFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
condition|)
block|{
name|insn
operator|->
name|registerSize
operator|=
literal|8
expr_stmt|;
name|insn
operator|->
name|addressSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|4
else|:
literal|8
operator|)
expr_stmt|;
name|insn
operator|->
name|displacementSize
operator|=
literal|4
expr_stmt|;
name|insn
operator|->
name|immediateSize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|->
name|rexPrefix
condition|)
block|{
name|insn
operator|->
name|registerSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|insn
operator|->
name|addressSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|4
else|:
literal|8
operator|)
expr_stmt|;
name|insn
operator|->
name|displacementSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|insn
operator|->
name|immediateSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|->
name|registerSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|insn
operator|->
name|addressSize
operator|=
operator|(
name|hasAdSize
condition|?
literal|4
else|:
literal|8
operator|)
expr_stmt|;
name|insn
operator|->
name|displacementSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|insn
operator|->
name|immediateSize
operator|=
operator|(
name|hasOpSize
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * readOpcode - Reads the opcode (excepting the ModR/M byte in the case of  *   extended or escape opcodes).  *  * @param insn  - The instruction whose opcode is to be read.  * @return      - 0 if the opcode could be read successfully; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|readOpcode
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
comment|/* Determine the length of the primary opcode */
name|uint8_t
name|current
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readOpcode()"
argument_list|)
expr_stmt|;
name|insn
operator|->
name|opcodeType
operator|=
name|ONEBYTE
expr_stmt|;
if|if
condition|(
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|current
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|current
operator|==
literal|0x0f
condition|)
block|{
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Found a two-byte escape prefix (0x%hhx)"
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|insn
operator|->
name|twoByteEscape
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|current
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|current
operator|==
literal|0x38
condition|)
block|{
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Found a three-byte escape prefix (0x%hhx)"
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|insn
operator|->
name|threeByteEscape
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|current
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|opcodeType
operator|=
name|THREEBYTE_38
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|==
literal|0x3a
condition|)
block|{
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Found a three-byte escape prefix (0x%hhx)"
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|insn
operator|->
name|threeByteEscape
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|current
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|opcodeType
operator|=
name|THREEBYTE_3A
expr_stmt|;
block|}
else|else
block|{
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Didn't find a three-byte escape prefix"
argument_list|)
expr_stmt|;
name|insn
operator|->
name|opcodeType
operator|=
name|TWOBYTE
expr_stmt|;
block|}
block|}
comment|/*    * At this point we have consumed the full opcode.    * Anything we consume from here on must be unconsumed.    */
name|insn
operator|->
name|opcode
operator|=
name|current
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|readModRM
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * getIDWithAttrMask - Determines the ID of an instruction, consuming  *   the ModR/M byte as appropriate for extended and escape opcodes,  *   and using a supplied attribute mask.  *  * @param instructionID - A pointer whose target is filled in with the ID of the  *                        instruction.  * @param insn          - The instruction whose ID is to be determined.  * @param attrMask      - The attribute mask to search.  * @return              - 0 if the ModR/M could be read when needed or was not  *                        needed; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|getIDWithAttrMask
parameter_list|(
name|uint16_t
modifier|*
name|instructionID
parameter_list|,
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|uint8_t
name|attrMask
parameter_list|)
block|{
name|BOOL
name|hasModRMExtension
decl_stmt|;
name|uint8_t
name|instructionClass
decl_stmt|;
name|instructionClass
operator|=
name|contextForAttrs
argument_list|(
name|attrMask
argument_list|)
expr_stmt|;
name|hasModRMExtension
operator|=
name|modRMRequired
argument_list|(
name|insn
operator|->
name|opcodeType
argument_list|,
name|instructionClass
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasModRMExtension
condition|)
block|{
name|readModRM
argument_list|(
name|insn
argument_list|)
expr_stmt|;
operator|*
name|instructionID
operator|=
name|decode
argument_list|(
name|insn
operator|->
name|opcodeType
argument_list|,
name|instructionClass
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
name|insn
operator|->
name|modRM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|instructionID
operator|=
name|decode
argument_list|(
name|insn
operator|->
name|opcodeType
argument_list|,
name|instructionClass
argument_list|,
name|insn
operator|->
name|opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * is16BitEquivalent - Determines whether two instruction names refer to  * equivalent instructions but one is 16-bit whereas the other is not.  *  * @param orig  - The instruction that is not 16-bit  * @param equiv - The instruction that is 16-bit  */
end_comment

begin_function
specifier|static
name|BOOL
name|is16BitEquvalent
parameter_list|(
specifier|const
name|char
modifier|*
name|orig
parameter_list|,
specifier|const
name|char
modifier|*
name|equiv
parameter_list|)
block|{
name|off_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|orig
index|[
name|i
index|]
operator|==
literal|'\0'
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|orig
index|[
name|i
index|]
operator|==
literal|'\0'
operator|||
name|equiv
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|orig
index|[
name|i
index|]
operator|!=
name|equiv
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|orig
index|[
name|i
index|]
operator|==
literal|'Q'
operator|||
name|orig
index|[
name|i
index|]
operator|==
literal|'L'
operator|)
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'W'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|orig
index|[
name|i
index|]
operator|==
literal|'6'
operator|||
name|orig
index|[
name|i
index|]
operator|==
literal|'3'
operator|)
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'1'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|orig
index|[
name|i
index|]
operator|==
literal|'4'
operator|||
name|orig
index|[
name|i
index|]
operator|==
literal|'2'
operator|)
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'6'
condition|)
continue|continue;
return|return
name|FALSE
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * is64BitEquivalent - Determines whether two instruction names refer to  * equivalent instructions but one is 64-bit whereas the other is not.  *  * @param orig  - The instruction that is not 64-bit  * @param equiv - The instruction that is 64-bit  */
end_comment

begin_function
specifier|static
name|BOOL
name|is64BitEquivalent
parameter_list|(
specifier|const
name|char
modifier|*
name|orig
parameter_list|,
specifier|const
name|char
modifier|*
name|equiv
parameter_list|)
block|{
name|off_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|orig
index|[
name|i
index|]
operator|==
literal|'\0'
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|orig
index|[
name|i
index|]
operator|==
literal|'\0'
operator|||
name|equiv
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|orig
index|[
name|i
index|]
operator|!=
name|equiv
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|orig
index|[
name|i
index|]
operator|==
literal|'W'
operator|||
name|orig
index|[
name|i
index|]
operator|==
literal|'L'
operator|)
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'Q'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|orig
index|[
name|i
index|]
operator|==
literal|'1'
operator|||
name|orig
index|[
name|i
index|]
operator|==
literal|'3'
operator|)
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'6'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|orig
index|[
name|i
index|]
operator|==
literal|'6'
operator|||
name|orig
index|[
name|i
index|]
operator|==
literal|'2'
operator|)
operator|&&
name|equiv
index|[
name|i
index|]
operator|==
literal|'4'
condition|)
continue|continue;
return|return
name|FALSE
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * getID - Determines the ID of an instruction, consuming the ModR/M byte as   *   appropriate for extended and escape opcodes.  Determines the attributes and   *   context for the instruction before doing so.  *  * @param insn  - The instruction whose ID is to be determined.  * @return      - 0 if the ModR/M could be read when needed or was not needed;  *                nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|getID
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|uint8_t
name|attrMask
decl_stmt|;
name|uint16_t
name|instructionID
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"getID()"
argument_list|)
expr_stmt|;
name|attrMask
operator|=
name|ATTR_NONE
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|mode
operator|==
name|MODE_64BIT
condition|)
name|attrMask
operator||=
name|ATTR_64BIT
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|rexPrefix
operator|&
literal|0x08
condition|)
name|attrMask
operator||=
name|ATTR_REXW
expr_stmt|;
if|if
condition|(
name|isPrefixAtLocation
argument_list|(
name|insn
argument_list|,
literal|0x66
argument_list|,
name|insn
operator|->
name|necessaryPrefixLocation
argument_list|)
condition|)
name|attrMask
operator||=
name|ATTR_OPSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|isPrefixAtLocation
argument_list|(
name|insn
argument_list|,
literal|0xf3
argument_list|,
name|insn
operator|->
name|necessaryPrefixLocation
argument_list|)
condition|)
name|attrMask
operator||=
name|ATTR_XS
expr_stmt|;
elseif|else
if|if
condition|(
name|isPrefixAtLocation
argument_list|(
name|insn
argument_list|,
literal|0xf2
argument_list|,
name|insn
operator|->
name|necessaryPrefixLocation
argument_list|)
condition|)
name|attrMask
operator||=
name|ATTR_XD
expr_stmt|;
if|if
condition|(
name|getIDWithAttrMask
argument_list|(
operator|&
name|instructionID
argument_list|,
name|insn
argument_list|,
name|attrMask
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The following clauses compensate for limitations of the tables. */
if|if
condition|(
operator|(
name|attrMask
operator|&
name|ATTR_XD
operator|)
operator|&&
operator|(
name|attrMask
operator|&
name|ATTR_REXW
operator|)
condition|)
block|{
comment|/*      * Although for SSE instructions it is usually necessary to treat REX.W+F2      * as F2 for decode (in the absence of a 64BIT_REXW_XD category) there is      * an occasional instruction where F2 is incidental and REX.W is the more      * significant.  If the decoded instruction is 32-bit and adding REX.W      * instead of F2 changes a 32 to a 64, we adopt the new encoding.      */
name|struct
name|InstructionSpecifier
modifier|*
name|spec
decl_stmt|;
name|uint16_t
name|instructionIDWithREXw
decl_stmt|;
name|struct
name|InstructionSpecifier
modifier|*
name|specWithREXw
decl_stmt|;
name|spec
operator|=
name|specifierForUID
argument_list|(
name|instructionID
argument_list|)
expr_stmt|;
if|if
condition|(
name|getIDWithAttrMask
argument_list|(
operator|&
name|instructionIDWithREXw
argument_list|,
name|insn
argument_list|,
name|attrMask
operator|&
operator|(
operator|~
name|ATTR_XD
operator|)
argument_list|)
condition|)
block|{
comment|/*        * Decoding with REX.w would yield nothing; give up and return original        * decode.        */
name|insn
operator|->
name|instructionID
operator|=
name|instructionID
expr_stmt|;
name|insn
operator|->
name|spec
operator|=
name|spec
expr_stmt|;
return|return
literal|0
return|;
block|}
name|specWithREXw
operator|=
name|specifierForUID
argument_list|(
name|instructionIDWithREXw
argument_list|)
expr_stmt|;
if|if
condition|(
name|is64BitEquivalent
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|specWithREXw
operator|->
name|name
argument_list|)
condition|)
block|{
name|insn
operator|->
name|instructionID
operator|=
name|instructionIDWithREXw
expr_stmt|;
name|insn
operator|->
name|spec
operator|=
name|specWithREXw
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|->
name|instructionID
operator|=
name|instructionID
expr_stmt|;
name|insn
operator|->
name|spec
operator|=
name|spec
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|insn
operator|->
name|prefixPresent
index|[
literal|0x66
index|]
operator|&&
operator|!
operator|(
name|attrMask
operator|&
name|ATTR_OPSIZE
operator|)
condition|)
block|{
comment|/*      * The instruction tables make no distinction between instructions that      * allow OpSize anywhere (i.e., 16-bit operations) and that need it in a      * particular spot (i.e., many MMX operations).  In general we're      * conservative, but in the specific case where OpSize is present but not      * in the right place we check if there's a 16-bit operation.      */
name|struct
name|InstructionSpecifier
modifier|*
name|spec
decl_stmt|;
name|uint16_t
name|instructionIDWithOpsize
decl_stmt|;
name|struct
name|InstructionSpecifier
modifier|*
name|specWithOpsize
decl_stmt|;
name|spec
operator|=
name|specifierForUID
argument_list|(
name|instructionID
argument_list|)
expr_stmt|;
if|if
condition|(
name|getIDWithAttrMask
argument_list|(
operator|&
name|instructionIDWithOpsize
argument_list|,
name|insn
argument_list|,
name|attrMask
operator||
name|ATTR_OPSIZE
argument_list|)
condition|)
block|{
comment|/*         * ModRM required with OpSize but not present; give up and return version        * without OpSize set        */
name|insn
operator|->
name|instructionID
operator|=
name|instructionID
expr_stmt|;
name|insn
operator|->
name|spec
operator|=
name|spec
expr_stmt|;
return|return
literal|0
return|;
block|}
name|specWithOpsize
operator|=
name|specifierForUID
argument_list|(
name|instructionIDWithOpsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|is16BitEquvalent
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|specWithOpsize
operator|->
name|name
argument_list|)
condition|)
block|{
name|insn
operator|->
name|instructionID
operator|=
name|instructionIDWithOpsize
expr_stmt|;
name|insn
operator|->
name|spec
operator|=
name|specWithOpsize
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|->
name|instructionID
operator|=
name|instructionID
expr_stmt|;
name|insn
operator|->
name|spec
operator|=
name|spec
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|insn
operator|->
name|instructionID
operator|=
name|instructionID
expr_stmt|;
name|insn
operator|->
name|spec
operator|=
name|specifierForUID
argument_list|(
name|insn
operator|->
name|instructionID
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * readSIB - Consumes the SIB byte to determine addressing information for an  *   instruction.  *  * @param insn  - The instruction whose SIB byte is to be read.  * @return      - 0 if the SIB byte was successfully read; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|readSIB
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|SIBIndex
name|sibIndexBase
init|=
literal|0
decl_stmt|;
name|SIBBase
name|sibBaseBase
init|=
literal|0
decl_stmt|;
name|uint8_t
name|index
decl_stmt|,
name|base
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readSIB()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|consumedSIB
condition|)
return|return
literal|0
return|;
name|insn
operator|->
name|consumedSIB
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|insn
operator|->
name|addressSize
condition|)
block|{
case|case
literal|2
case|:
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"SIB-based addressing doesn't work in 16-bit mode"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|4
case|:
name|sibIndexBase
operator|=
name|SIB_INDEX_EAX
expr_stmt|;
name|sibBaseBase
operator|=
name|SIB_BASE_EAX
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|sibIndexBase
operator|=
name|SIB_INDEX_RAX
expr_stmt|;
name|sibBaseBase
operator|=
name|SIB_BASE_RAX
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|insn
operator|->
name|sib
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|index
operator|=
name|indexFromSIB
argument_list|(
name|insn
operator|->
name|sib
argument_list|)
operator||
operator|(
name|xFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
operator|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
literal|0x4
case|:
name|insn
operator|->
name|sibIndex
operator|=
name|SIB_INDEX_NONE
expr_stmt|;
break|break;
default|default:
name|insn
operator|->
name|sibIndex
operator|=
call|(
name|EABase
call|)
argument_list|(
name|sibIndexBase
operator|+
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|sibIndex
operator|==
name|SIB_INDEX_sib
operator|||
name|insn
operator|->
name|sibIndex
operator|==
name|SIB_INDEX_sib64
condition|)
name|insn
operator|->
name|sibIndex
operator|=
name|SIB_INDEX_NONE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|scaleFromSIB
argument_list|(
name|insn
operator|->
name|sib
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|insn
operator|->
name|sibScale
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|insn
operator|->
name|sibScale
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|insn
operator|->
name|sibScale
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|insn
operator|->
name|sibScale
operator|=
literal|8
expr_stmt|;
break|break;
block|}
name|base
operator|=
name|baseFromSIB
argument_list|(
name|insn
operator|->
name|sib
argument_list|)
operator||
operator|(
name|bFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
operator|)
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|0x5
case|:
switch|switch
condition|(
name|modFromModRM
argument_list|(
name|insn
operator|->
name|modRM
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_32
expr_stmt|;
name|insn
operator|->
name|sibBase
operator|=
name|SIB_BASE_NONE
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_8
expr_stmt|;
name|insn
operator|->
name|sibBase
operator|=
operator|(
name|insn
operator|->
name|addressSize
operator|==
literal|4
condition|?
name|SIB_BASE_EBP
else|:
name|SIB_BASE_RBP
operator|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_32
expr_stmt|;
name|insn
operator|->
name|sibBase
operator|=
operator|(
name|insn
operator|->
name|addressSize
operator|==
literal|4
condition|?
name|SIB_BASE_EBP
else|:
name|SIB_BASE_RBP
operator|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|unreachable
argument_list|(
literal|"Cannot have Mod = 0b11 and a SIB byte"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|insn
operator|->
name|sibBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|sibBaseBase
operator|+
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * readDisplacement - Consumes the displacement of an instruction.  *  * @param insn  - The instruction whose displacement is to be read.  * @return      - 0 if the displacement byte was successfully read; nonzero   *                otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|readDisplacement
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|int8_t
name|d8
decl_stmt|;
name|int16_t
name|d16
decl_stmt|;
name|int32_t
name|d32
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readDisplacement()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|consumedDisplacement
condition|)
return|return
literal|0
return|;
name|insn
operator|->
name|consumedDisplacement
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|insn
operator|->
name|eaDisplacement
condition|)
block|{
case|case
name|EA_DISP_NONE
case|:
name|insn
operator|->
name|consumedDisplacement
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|EA_DISP_8
case|:
if|if
condition|(
name|consumeInt8
argument_list|(
name|insn
argument_list|,
operator|&
name|d8
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|displacement
operator|=
name|d8
expr_stmt|;
break|break;
case|case
name|EA_DISP_16
case|:
if|if
condition|(
name|consumeInt16
argument_list|(
name|insn
argument_list|,
operator|&
name|d16
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|displacement
operator|=
name|d16
expr_stmt|;
break|break;
case|case
name|EA_DISP_32
case|:
if|if
condition|(
name|consumeInt32
argument_list|(
name|insn
argument_list|,
operator|&
name|d32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|displacement
operator|=
name|d32
expr_stmt|;
break|break;
block|}
name|insn
operator|->
name|consumedDisplacement
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * readModRM - Consumes all addressing information (ModR/M byte, SIB byte, and  *   displacement) for an instruction and interprets it.  *  * @param insn  - The instruction whose addressing information is to be read.  * @return      - 0 if the information was successfully read; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|readModRM
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|uint8_t
name|mod
decl_stmt|,
name|rm
decl_stmt|,
name|reg
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readModRM()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|consumedModRM
condition|)
return|return
literal|0
return|;
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|insn
operator|->
name|modRM
argument_list|)
expr_stmt|;
name|insn
operator|->
name|consumedModRM
operator|=
name|TRUE
expr_stmt|;
name|mod
operator|=
name|modFromModRM
argument_list|(
name|insn
operator|->
name|modRM
argument_list|)
expr_stmt|;
name|rm
operator|=
name|rmFromModRM
argument_list|(
name|insn
operator|->
name|modRM
argument_list|)
expr_stmt|;
name|reg
operator|=
name|regFromModRM
argument_list|(
name|insn
operator|->
name|modRM
argument_list|)
expr_stmt|;
comment|/*    * This goes by insn->registerSize to pick the correct register, which messes    * up if we're using (say) XMM or 8-bit register operands.  That gets fixed in    * fixupReg().    */
switch|switch
condition|(
name|insn
operator|->
name|registerSize
condition|)
block|{
case|case
literal|2
case|:
name|insn
operator|->
name|regBase
operator|=
name|MODRM_REG_AX
expr_stmt|;
name|insn
operator|->
name|eaRegBase
operator|=
name|EA_REG_AX
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|insn
operator|->
name|regBase
operator|=
name|MODRM_REG_EAX
expr_stmt|;
name|insn
operator|->
name|eaRegBase
operator|=
name|EA_REG_EAX
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|insn
operator|->
name|regBase
operator|=
name|MODRM_REG_RAX
expr_stmt|;
name|insn
operator|->
name|eaRegBase
operator|=
name|EA_REG_RAX
expr_stmt|;
break|break;
block|}
name|reg
operator||=
name|rFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|rm
operator||=
name|bFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|insn
operator|->
name|reg
operator|=
call|(
name|Reg
call|)
argument_list|(
name|insn
operator|->
name|regBase
operator|+
name|reg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|insn
operator|->
name|addressSize
condition|)
block|{
case|case
literal|2
case|:
name|insn
operator|->
name|eaBaseBase
operator|=
name|EA_BASE_BX_SI
expr_stmt|;
switch|switch
condition|(
name|mod
condition|)
block|{
case|case
literal|0x0
case|:
if|if
condition|(
name|rm
operator|==
literal|0x6
condition|)
block|{
name|insn
operator|->
name|eaBase
operator|=
name|EA_BASE_NONE
expr_stmt|;
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_16
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|insn
operator|->
name|eaBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|insn
operator|->
name|eaBaseBase
operator|+
name|rm
argument_list|)
expr_stmt|;
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_NONE
expr_stmt|;
block|}
break|break;
case|case
literal|0x1
case|:
name|insn
operator|->
name|eaBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|insn
operator|->
name|eaBaseBase
operator|+
name|rm
argument_list|)
expr_stmt|;
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_8
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|0x2
case|:
name|insn
operator|->
name|eaBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|insn
operator|->
name|eaBaseBase
operator|+
name|rm
argument_list|)
expr_stmt|;
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_16
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|0x3
case|:
name|insn
operator|->
name|eaBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|insn
operator|->
name|eaRegBase
operator|+
name|rm
argument_list|)
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
break|break;
case|case
literal|4
case|:
case|case
literal|8
case|:
name|insn
operator|->
name|eaBaseBase
operator|=
operator|(
name|insn
operator|->
name|addressSize
operator|==
literal|4
condition|?
name|EA_BASE_EAX
else|:
name|EA_BASE_RAX
operator|)
expr_stmt|;
switch|switch
condition|(
name|mod
condition|)
block|{
case|case
literal|0x0
case|:
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_NONE
expr_stmt|;
comment|/* readSIB may override this */
switch|switch
condition|(
name|rm
condition|)
block|{
case|case
literal|0x4
case|:
case|case
literal|0xc
case|:
comment|/* in case REXW.b is set */
name|insn
operator|->
name|eaBase
operator|=
operator|(
name|insn
operator|->
name|addressSize
operator|==
literal|4
condition|?
name|EA_BASE_sib
else|:
name|EA_BASE_sib64
operator|)
expr_stmt|;
name|readSIB
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|0x5
case|:
name|insn
operator|->
name|eaBase
operator|=
name|EA_BASE_NONE
expr_stmt|;
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_32
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
default|default:
name|insn
operator|->
name|eaBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|insn
operator|->
name|eaBaseBase
operator|+
name|rm
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x1
case|:
case|case
literal|0x2
case|:
name|insn
operator|->
name|eaDisplacement
operator|=
operator|(
name|mod
operator|==
literal|0x1
condition|?
name|EA_DISP_8
else|:
name|EA_DISP_32
operator|)
expr_stmt|;
switch|switch
condition|(
name|rm
condition|)
block|{
case|case
literal|0x4
case|:
case|case
literal|0xc
case|:
comment|/* in case REXW.b is set */
name|insn
operator|->
name|eaBase
operator|=
name|EA_BASE_sib
expr_stmt|;
name|readSIB
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
default|default:
name|insn
operator|->
name|eaBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|insn
operator|->
name|eaBaseBase
operator|+
name|rm
argument_list|)
expr_stmt|;
if|if
condition|(
name|readDisplacement
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
break|break;
case|case
literal|0x3
case|:
name|insn
operator|->
name|eaDisplacement
operator|=
name|EA_DISP_NONE
expr_stmt|;
name|insn
operator|->
name|eaBase
operator|=
call|(
name|EABase
call|)
argument_list|(
name|insn
operator|->
name|eaRegBase
operator|+
name|rm
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* switch (insn->addressSize) */
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GENERIC_FIXUP_FUNC
parameter_list|(
name|name
parameter_list|,
name|base
parameter_list|,
name|prefix
parameter_list|)
define|\
value|static uint8_t name(struct InternalInstruction *insn,   \                       OperandType type,                   \                       uint8_t index,                      \                       uint8_t *valid) {                   \     *valid = 1;                                           \     switch (type) {                                       \     default:                                              \       unreachable("Unhandled register type");             \     case TYPE_Rv:                                         \       return base + index;                                \     case TYPE_R8:                                         \       if(insn->rexPrefix&&                               \          index>= 4&& index<= 7) {                      \         return prefix##_SPL + (index - 4);                \       } else {                                            \         return prefix##_AL + index;                       \       }                                                   \     case TYPE_R16:                                        \       return prefix##_AX + index;                         \     case TYPE_R32:                                        \       return prefix##_EAX + index;                        \     case TYPE_R64:                                        \       return prefix##_RAX + index;                        \     case TYPE_XMM128:                                     \     case TYPE_XMM64:                                      \     case TYPE_XMM32:                                      \     case TYPE_XMM:                                        \       return prefix##_XMM0 + index;                       \     case TYPE_MM64:                                       \     case TYPE_MM32:                                       \     case TYPE_MM:                                         \       if(index> 7)                                       \         *valid = 0;                                       \       return prefix##_MM0 + index;                        \     case TYPE_SEGMENTREG:                                 \       if(index> 5)                                       \         *valid = 0;                                       \       return prefix##_ES + index;                         \     case TYPE_DEBUGREG:                                   \       if(index> 7)                                       \         *valid = 0;                                       \       return prefix##_DR0 + index;                        \     case TYPE_CR32:                                       \       if(index> 7)                                       \         *valid = 0;                                       \       return prefix##_ECR0 + index;                       \     case TYPE_CR64:                                       \       if(index> 8)                                       \         *valid = 0;                                       \       return prefix##_RCR0 + index;                       \     }                                                     \   }
end_define

begin_comment
comment|/*  * fixup*Value - Consults an operand type to determine the meaning of the  *   reg or R/M field.  If the operand is an XMM operand, for example, an  *   operand would be XMM0 instead of AX, which readModRM() would otherwise  *   misinterpret it as.  *  * @param insn  - The instruction containing the operand.  * @param type  - The operand type.  * @param index - The existing value of the field as reported by readModRM().  * @param valid - The address of a uint8_t.  The target is set to 1 if the  *                field is valid for the register class; 0 if not.  */
end_comment

begin_macro
name|GENERIC_FIXUP_FUNC
argument_list|(
argument|fixupRegValue
argument_list|,
argument|insn->regBase
argument_list|,
argument|MODRM_REG
argument_list|)
end_macro

begin_macro
name|GENERIC_FIXUP_FUNC
argument_list|(
argument|fixupRMValue
argument_list|,
argument|insn->eaRegBase
argument_list|,
argument|EA_REG
argument_list|)
end_macro

begin_comment
comment|/*  * fixupReg - Consults an operand specifier to determine which of the  *   fixup*Value functions to use in correcting readModRM()'ss interpretation.  *  * @param insn  - See fixup*Value().  * @param op    - The operand specifier.  * @return      - 0 if fixup was successful; -1 if the register returned was  *                invalid for its class.  */
end_comment

begin_function
specifier|static
name|int
name|fixupReg
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|struct
name|OperandSpecifier
modifier|*
name|op
parameter_list|)
block|{
name|uint8_t
name|valid
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"fixupReg()"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|OperandEncoding
operator|)
name|op
operator|->
name|encoding
condition|)
block|{
default|default:
name|unreachable
argument_list|(
literal|"Expected a REG or R/M encoding in fixupReg"
argument_list|)
expr_stmt|;
case|case
name|ENCODING_REG
case|:
name|insn
operator|->
name|reg
operator|=
operator|(
name|Reg
operator|)
name|fixupRegValue
argument_list|(
name|insn
argument_list|,
operator|(
name|OperandType
operator|)
name|op
operator|->
name|type
argument_list|,
name|insn
operator|->
name|reg
operator|-
name|insn
operator|->
name|regBase
argument_list|,
operator|&
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ENCODING_RM
case|:
if|if
condition|(
name|insn
operator|->
name|eaBase
operator|>=
name|insn
operator|->
name|eaRegBase
condition|)
block|{
name|insn
operator|->
name|eaBase
operator|=
operator|(
name|EABase
operator|)
name|fixupRMValue
argument_list|(
name|insn
argument_list|,
operator|(
name|OperandType
operator|)
name|op
operator|->
name|type
argument_list|,
name|insn
operator|->
name|eaBase
operator|-
name|insn
operator|->
name|eaRegBase
argument_list|,
operator|&
name|valid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * readOpcodeModifier - Reads an operand from the opcode field of an   *   instruction.  Handles AddRegFrm instructions.  *  * @param insn    - The instruction whose opcode field is to be read.  * @param inModRM - Indicates that the opcode field is to be read from the  *                  ModR/M extension; useful for escape opcodes  */
end_comment

begin_function
specifier|static
name|void
name|readOpcodeModifier
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readOpcodeModifier()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|consumedOpcodeModifier
condition|)
return|return;
name|insn
operator|->
name|consumedOpcodeModifier
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|insn
operator|->
name|spec
operator|->
name|modifierType
condition|)
block|{
default|default:
name|unreachable
argument_list|(
literal|"Unknown modifier type."
argument_list|)
expr_stmt|;
case|case
name|MODIFIER_NONE
case|:
name|unreachable
argument_list|(
literal|"No modifier but an operand expects one."
argument_list|)
expr_stmt|;
case|case
name|MODIFIER_OPCODE
case|:
name|insn
operator|->
name|opcodeModifier
operator|=
name|insn
operator|->
name|opcode
operator|-
name|insn
operator|->
name|spec
operator|->
name|modifierBase
expr_stmt|;
break|break;
case|case
name|MODIFIER_MODRM
case|:
name|insn
operator|->
name|opcodeModifier
operator|=
name|insn
operator|->
name|modRM
operator|-
name|insn
operator|->
name|spec
operator|->
name|modifierBase
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * readOpcodeRegister - Reads an operand from the opcode field of an   *   instruction and interprets it appropriately given the operand width.  *   Handles AddRegFrm instructions.  *  * @param insn  - See readOpcodeModifier().  * @param size  - The width (in bytes) of the register being specified.  *                1 means AL and friends, 2 means AX, 4 means EAX, and 8 means  *                RAX.  */
end_comment

begin_function
specifier|static
name|void
name|readOpcodeRegister
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|uint8_t
name|size
parameter_list|)
block|{
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readOpcodeRegister()"
argument_list|)
expr_stmt|;
name|readOpcodeModifier
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|insn
operator|->
name|registerSize
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|insn
operator|->
name|opcodeRegister
operator|=
call|(
name|Reg
call|)
argument_list|(
name|MODRM_REG_AL
operator|+
operator|(
operator|(
name|bFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
operator|)
operator||
name|insn
operator|->
name|opcodeModifier
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|rexPrefix
operator|&&
name|insn
operator|->
name|opcodeRegister
operator|>=
name|MODRM_REG_AL
operator|+
literal|0x4
operator|&&
name|insn
operator|->
name|opcodeRegister
operator|<
name|MODRM_REG_AL
operator|+
literal|0x8
condition|)
block|{
name|insn
operator|->
name|opcodeRegister
operator|=
call|(
name|Reg
call|)
argument_list|(
name|MODRM_REG_SPL
operator|+
operator|(
name|insn
operator|->
name|opcodeRegister
operator|-
name|MODRM_REG_AL
operator|-
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|insn
operator|->
name|opcodeRegister
operator|=
call|(
name|Reg
call|)
argument_list|(
name|MODRM_REG_AX
operator|+
operator|(
operator|(
name|bFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
operator|)
operator||
name|insn
operator|->
name|opcodeModifier
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|insn
operator|->
name|opcodeRegister
operator|=
call|(
name|Reg
call|)
argument_list|(
name|MODRM_REG_EAX
operator|+
operator|+
operator|(
operator|(
name|bFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
operator|)
operator||
name|insn
operator|->
name|opcodeModifier
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|insn
operator|->
name|opcodeRegister
operator|=
call|(
name|Reg
call|)
argument_list|(
name|MODRM_REG_RAX
operator|+
operator|(
operator|(
name|bFromREX
argument_list|(
name|insn
operator|->
name|rexPrefix
argument_list|)
operator|<<
literal|3
operator|)
operator||
name|insn
operator|->
name|opcodeModifier
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * readImmediate - Consumes an immediate operand from an instruction, given the  *   desired operand size.  *  * @param insn  - The instruction whose operand is to be read.  * @param size  - The width (in bytes) of the operand.  * @return      - 0 if the immediate was successfully consumed; nonzero  *                otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|readImmediate
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|uint8_t
name|size
parameter_list|)
block|{
name|uint8_t
name|imm8
decl_stmt|;
name|uint16_t
name|imm16
decl_stmt|;
name|uint32_t
name|imm32
decl_stmt|;
name|uint64_t
name|imm64
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readImmediate()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|numImmediatesConsumed
operator|==
literal|2
condition|)
name|unreachable
argument_list|(
literal|"Already consumed two immediates"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|insn
operator|->
name|immediateSize
expr_stmt|;
else|else
name|insn
operator|->
name|immediateSize
operator|=
name|size
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|consumeByte
argument_list|(
name|insn
argument_list|,
operator|&
name|imm8
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|immediates
index|[
name|insn
operator|->
name|numImmediatesConsumed
index|]
operator|=
name|imm8
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|consumeUInt16
argument_list|(
name|insn
argument_list|,
operator|&
name|imm16
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|immediates
index|[
name|insn
operator|->
name|numImmediatesConsumed
index|]
operator|=
name|imm16
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|consumeUInt32
argument_list|(
name|insn
argument_list|,
operator|&
name|imm32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|immediates
index|[
name|insn
operator|->
name|numImmediatesConsumed
index|]
operator|=
name|imm32
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|consumeUInt64
argument_list|(
name|insn
argument_list|,
operator|&
name|imm64
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|immediates
index|[
name|insn
operator|->
name|numImmediatesConsumed
index|]
operator|=
name|imm64
expr_stmt|;
break|break;
block|}
name|insn
operator|->
name|numImmediatesConsumed
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * readOperands - Consults the specifier for an instruction and consumes all  *   operands for that instruction, interpreting them as it goes.  *  * @param insn  - The instruction whose operands are to be read and interpreted.  * @return      - 0 if all operands could be read; nonzero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|readOperands
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"readOperands()"
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|X86_MAX_OPERANDS
condition|;
operator|++
name|index
control|)
block|{
switch|switch
condition|(
name|insn
operator|->
name|spec
operator|->
name|operands
index|[
name|index
index|]
operator|.
name|encoding
condition|)
block|{
case|case
name|ENCODING_NONE
case|:
break|break;
case|case
name|ENCODING_REG
case|:
case|case
name|ENCODING_RM
case|:
if|if
condition|(
name|readModRM
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fixupReg
argument_list|(
name|insn
argument_list|,
operator|&
name|insn
operator|->
name|spec
operator|->
name|operands
index|[
name|index
index|]
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ENCODING_CB
case|:
case|case
name|ENCODING_CW
case|:
case|case
name|ENCODING_CD
case|:
case|case
name|ENCODING_CP
case|:
case|case
name|ENCODING_CO
case|:
case|case
name|ENCODING_CT
case|:
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"We currently don't hande code-offset encodings"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
name|ENCODING_IB
case|:
if|if
condition|(
name|readImmediate
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ENCODING_IW
case|:
if|if
condition|(
name|readImmediate
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ENCODING_ID
case|:
if|if
condition|(
name|readImmediate
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ENCODING_IO
case|:
if|if
condition|(
name|readImmediate
argument_list|(
name|insn
argument_list|,
literal|8
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
name|ENCODING_Iv
case|:
name|readImmediate
argument_list|(
name|insn
argument_list|,
name|insn
operator|->
name|immediateSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_Ia
case|:
name|readImmediate
argument_list|(
name|insn
argument_list|,
name|insn
operator|->
name|addressSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_RB
case|:
name|readOpcodeRegister
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_RW
case|:
name|readOpcodeRegister
argument_list|(
name|insn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_RD
case|:
name|readOpcodeRegister
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_RO
case|:
name|readOpcodeRegister
argument_list|(
name|insn
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_Rv
case|:
name|readOpcodeRegister
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_I
case|:
name|readOpcodeModifier
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENCODING_DUP
case|:
break|break;
default|default:
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Encountered an operand with an unknown encoding."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * decodeInstruction - Reads and interprets a full instruction provided by the  *   user.  *  * @param insn      - A pointer to the instruction to be populated.  Must be   *                    pre-allocated.  * @param reader    - The function to be used to read the instruction's bytes.  * @param readerArg - A generic argument to be passed to the reader to store  *                    any internal state.  * @param logger    - If non-NULL, the function to be used to write log messages  *                    and warnings.  * @param loggerArg - A generic argument to be passed to the logger to store  *                    any internal state.  * @param startLoc  - The address (in the reader's address space) of the first  *                    byte in the instruction.  * @param mode      - The mode (real mode, IA-32e, or IA-32e in 64-bit mode) to  *                    decode the instruction in.  * @return          - 0 if the instruction's memory could be read; nonzero if  *                    not.  */
end_comment

begin_function
name|int
name|decodeInstruction
parameter_list|(
name|struct
name|InternalInstruction
modifier|*
name|insn
parameter_list|,
name|byteReader_t
name|reader
parameter_list|,
name|void
modifier|*
name|readerArg
parameter_list|,
name|dlog_t
name|logger
parameter_list|,
name|void
modifier|*
name|loggerArg
parameter_list|,
name|uint64_t
name|startLoc
parameter_list|,
name|DisassemblerMode
name|mode
parameter_list|)
block|{
name|memset
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|InternalInstruction
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|->
name|reader
operator|=
name|reader
expr_stmt|;
name|insn
operator|->
name|readerArg
operator|=
name|readerArg
expr_stmt|;
name|insn
operator|->
name|dlog
operator|=
name|logger
expr_stmt|;
name|insn
operator|->
name|dlogArg
operator|=
name|loggerArg
expr_stmt|;
name|insn
operator|->
name|startLocation
operator|=
name|startLoc
expr_stmt|;
name|insn
operator|->
name|readerCursor
operator|=
name|startLoc
expr_stmt|;
name|insn
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|insn
operator|->
name|numImmediatesConsumed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|readPrefixes
argument_list|(
name|insn
argument_list|)
operator|||
name|readOpcode
argument_list|(
name|insn
argument_list|)
operator|||
name|getID
argument_list|(
name|insn
argument_list|)
operator|||
name|insn
operator|->
name|instructionID
operator|==
literal|0
operator|||
name|readOperands
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|insn
operator|->
name|length
operator|=
name|insn
operator|->
name|readerCursor
operator|-
name|insn
operator|->
name|startLocation
expr_stmt|;
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Read from 0x%llx to 0x%llx: length %zu"
argument_list|,
name|startLoc
argument_list|,
name|insn
operator|->
name|readerCursor
argument_list|,
name|insn
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|->
name|length
operator|>
literal|15
condition|)
name|dbgprintf
argument_list|(
name|insn
argument_list|,
literal|"Instruction exceeds 15-byte limit"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

