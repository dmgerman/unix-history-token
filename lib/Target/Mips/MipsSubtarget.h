begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- MipsSubtarget.h - Define Subtarget for the Mips ---------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the Mips specific subclass of TargetSubtargetInfo.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_MIPS_MIPSSUBTARGET_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_MIPS_MIPSSUBTARGET_H
end_define

begin_include
include|#
directive|include
file|"MCTargetDesc/MipsABIInfo.h"
end_include

begin_include
include|#
directive|include
file|"MipsFrameLowering.h"
end_include

begin_include
include|#
directive|include
file|"MipsISelLowering.h"
end_include

begin_include
include|#
directive|include
file|"MipsInstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"MipsSelectionDAGInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DataLayout.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCInstrItineraries.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetSubtargetInfo.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_define
define|#
directive|define
name|GET_SUBTARGETINFO_HEADER
end_define

begin_include
include|#
directive|include
file|"MipsGenSubtargetInfo.inc"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|StringRef
decl_stmt|;
name|class
name|MipsTargetMachine
decl_stmt|;
name|class
name|MipsSubtarget
range|:
name|public
name|MipsGenSubtargetInfo
block|{
name|virtual
name|void
name|anchor
argument_list|()
block|;    enum
name|MipsArchEnum
block|{
name|MipsDefault
block|,
name|Mips1
block|,
name|Mips2
block|,
name|Mips32
block|,
name|Mips32r2
block|,
name|Mips32r3
block|,
name|Mips32r5
block|,
name|Mips32r6
block|,
name|Mips32Max
block|,
name|Mips3
block|,
name|Mips4
block|,
name|Mips5
block|,
name|Mips64
block|,
name|Mips64r2
block|,
name|Mips64r3
block|,
name|Mips64r5
block|,
name|Mips64r6
block|}
block|;
comment|// Mips architecture version
name|MipsArchEnum
name|MipsArchVersion
block|;
comment|// IsLittle - The target is Little Endian
name|bool
name|IsLittle
block|;
comment|// IsSoftFloat - The target does not support any floating point instructions.
name|bool
name|IsSoftFloat
block|;
comment|// IsSingleFloat - The target only supports single precision float
comment|// point operations. This enable the target to use all 32 32-bit
comment|// floating point registers instead of only using even ones.
name|bool
name|IsSingleFloat
block|;
comment|// IsFPXX - MIPS O32 modeless ABI.
name|bool
name|IsFPXX
block|;
comment|// NoABICalls - Disable SVR4-style position-independent code.
name|bool
name|NoABICalls
block|;
comment|// IsFP64bit - The target processor has 64-bit floating point registers.
name|bool
name|IsFP64bit
block|;
comment|/// Are odd single-precision registers permitted?
comment|/// This corresponds to -modd-spreg and -mno-odd-spreg
name|bool
name|UseOddSPReg
block|;
comment|// IsNan2008 - IEEE 754-2008 NaN encoding.
name|bool
name|IsNaN2008bit
block|;
comment|// IsFP64bit - General-purpose registers are 64 bits wide
name|bool
name|IsGP64bit
block|;
comment|// HasVFPU - Processor has a vector floating point unit.
name|bool
name|HasVFPU
block|;
comment|// CPU supports cnMIPS (Cavium Networks Octeon CPU).
name|bool
name|HasCnMips
block|;
comment|// isLinux - Target system is Linux. Is false we consider ELFOS for now.
name|bool
name|IsLinux
block|;
comment|// UseSmallSection - Small section is used.
name|bool
name|UseSmallSection
block|;
comment|/// Features related to the presence of specific instructions.
comment|// HasMips3_32 - The subset of MIPS-III instructions added to MIPS32
name|bool
name|HasMips3_32
block|;
comment|// HasMips3_32r2 - The subset of MIPS-III instructions added to MIPS32r2
name|bool
name|HasMips3_32r2
block|;
comment|// HasMips4_32 - Has the subset of MIPS-IV present in MIPS32
name|bool
name|HasMips4_32
block|;
comment|// HasMips4_32r2 - Has the subset of MIPS-IV present in MIPS32r2
name|bool
name|HasMips4_32r2
block|;
comment|// HasMips5_32r2 - Has the subset of MIPS-V present in MIPS32r2
name|bool
name|HasMips5_32r2
block|;
comment|// InMips16 -- can process Mips16 instructions
name|bool
name|InMips16Mode
block|;
comment|// Mips16 hard float
name|bool
name|InMips16HardFloat
block|;
comment|// PreviousInMips16 -- the function we just processed was in Mips 16 Mode
name|bool
name|PreviousInMips16Mode
block|;
comment|// InMicroMips -- can process MicroMips instructions
name|bool
name|InMicroMipsMode
block|;
comment|// HasDSP, HasDSPR2 -- supports DSP ASE.
name|bool
name|HasDSP
block|,
name|HasDSPR2
block|;
comment|// Allow mixed Mips16 and Mips32 in one source file
name|bool
name|AllowMixed16_32
block|;
comment|// Optimize for space by compiling all functions as Mips 16 unless
comment|// it needs floating point. Functions needing floating point are
comment|// compiled as Mips32
name|bool
name|Os16
block|;
comment|// HasMSA -- supports MSA ASE.
name|bool
name|HasMSA
block|;
name|InstrItineraryData
name|InstrItins
block|;
comment|// We can override the determination of whether we are in mips16 mode
comment|// as from the command line
block|enum
block|{
name|NoOverride
block|,
name|Mips16Override
block|,
name|NoMips16Override
block|}
name|OverrideMode
block|;
specifier|const
name|MipsTargetMachine
operator|&
name|TM
block|;
name|Triple
name|TargetTriple
block|;
specifier|const
name|MipsSelectionDAGInfo
name|TSInfo
block|;
name|std
operator|::
name|unique_ptr
operator|<
specifier|const
name|MipsInstrInfo
operator|>
name|InstrInfo
block|;
name|std
operator|::
name|unique_ptr
operator|<
specifier|const
name|MipsFrameLowering
operator|>
name|FrameLowering
block|;
name|std
operator|::
name|unique_ptr
operator|<
specifier|const
name|MipsTargetLowering
operator|>
name|TLInfo
block|;
name|public
operator|:
comment|/// This overrides the PostRAScheduler bit in the SchedModel for each CPU.
name|bool
name|enablePostMachineScheduler
argument_list|()
specifier|const
name|override
block|;
name|void
name|getCriticalPathRCs
argument_list|(
argument|RegClassVector&CriticalPathRCs
argument_list|)
specifier|const
name|override
block|;
name|CodeGenOpt
operator|::
name|Level
name|getOptLevelToEnablePostRAScheduler
argument_list|()
specifier|const
name|override
block|;
comment|/// Only O32 and EABI supported right now.
name|bool
name|isABI_EABI
argument_list|()
specifier|const
block|;
name|bool
name|isABI_N64
argument_list|()
specifier|const
block|;
name|bool
name|isABI_N32
argument_list|()
specifier|const
block|;
name|bool
name|isABI_O32
argument_list|()
specifier|const
block|;
specifier|const
name|MipsABIInfo
operator|&
name|getABI
argument_list|()
specifier|const
block|;
name|bool
name|isABI_FPXX
argument_list|()
specifier|const
block|{
return|return
name|isABI_O32
argument_list|()
operator|&&
name|IsFPXX
return|;
block|}
comment|/// This constructor initializes the data members to match that
comment|/// of the specified triple.
name|MipsSubtarget
argument_list|(
argument|const std::string&TT
argument_list|,
argument|const std::string&CPU
argument_list|,
argument|const std::string&FS
argument_list|,
argument|bool little
argument_list|,
argument|const MipsTargetMachine&TM
argument_list|)
block|;
comment|/// ParseSubtargetFeatures - Parses features string setting specified
comment|/// subtarget options.  Definition of function is auto generated by tblgen.
name|void
name|ParseSubtargetFeatures
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|)
block|;
name|bool
name|hasMips1
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips1
return|;
block|}
name|bool
name|hasMips2
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips2
return|;
block|}
name|bool
name|hasMips3
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips3
return|;
block|}
name|bool
name|hasMips4
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips4
return|;
block|}
name|bool
name|hasMips5
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips5
return|;
block|}
name|bool
name|hasMips4_32
argument_list|()
specifier|const
block|{
return|return
name|HasMips4_32
return|;
block|}
name|bool
name|hasMips4_32r2
argument_list|()
specifier|const
block|{
return|return
name|HasMips4_32r2
return|;
block|}
name|bool
name|hasMips32
argument_list|()
specifier|const
block|{
return|return
operator|(
name|MipsArchVersion
operator|>=
name|Mips32
operator|&&
name|MipsArchVersion
operator|<
name|Mips32Max
operator|)
operator|||
name|hasMips64
argument_list|()
return|;
block|}
name|bool
name|hasMips32r2
argument_list|()
specifier|const
block|{
return|return
operator|(
name|MipsArchVersion
operator|>=
name|Mips32r2
operator|&&
name|MipsArchVersion
operator|<
name|Mips32Max
operator|)
operator|||
name|hasMips64r2
argument_list|()
return|;
block|}
name|bool
name|hasMips32r3
argument_list|()
specifier|const
block|{
return|return
operator|(
name|MipsArchVersion
operator|>=
name|Mips32r3
operator|&&
name|MipsArchVersion
operator|<
name|Mips32Max
operator|)
operator|||
name|hasMips64r2
argument_list|()
return|;
block|}
name|bool
name|hasMips32r5
argument_list|()
specifier|const
block|{
return|return
operator|(
name|MipsArchVersion
operator|>=
name|Mips32r5
operator|&&
name|MipsArchVersion
operator|<
name|Mips32Max
operator|)
operator|||
name|hasMips64r2
argument_list|()
return|;
block|}
name|bool
name|hasMips32r6
argument_list|()
specifier|const
block|{
return|return
operator|(
name|MipsArchVersion
operator|>=
name|Mips32r6
operator|&&
name|MipsArchVersion
operator|<
name|Mips32Max
operator|)
operator|||
name|hasMips64r6
argument_list|()
return|;
block|}
name|bool
name|hasMips64
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips64
return|;
block|}
name|bool
name|hasMips64r2
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips64r2
return|;
block|}
name|bool
name|hasMips64r3
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips64r3
return|;
block|}
name|bool
name|hasMips64r5
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips64r5
return|;
block|}
name|bool
name|hasMips64r6
argument_list|()
specifier|const
block|{
return|return
name|MipsArchVersion
operator|>=
name|Mips64r6
return|;
block|}
name|bool
name|hasCnMips
argument_list|()
specifier|const
block|{
return|return
name|HasCnMips
return|;
block|}
name|bool
name|isLittle
argument_list|()
specifier|const
block|{
return|return
name|IsLittle
return|;
block|}
name|bool
name|isABICalls
argument_list|()
specifier|const
block|{
return|return
operator|!
name|NoABICalls
return|;
block|}
name|bool
name|isFPXX
argument_list|()
specifier|const
block|{
return|return
name|IsFPXX
return|;
block|}
name|bool
name|isFP64bit
argument_list|()
specifier|const
block|{
return|return
name|IsFP64bit
return|;
block|}
name|bool
name|useOddSPReg
argument_list|()
specifier|const
block|{
return|return
name|UseOddSPReg
return|;
block|}
name|bool
name|noOddSPReg
argument_list|()
specifier|const
block|{
return|return
operator|!
name|UseOddSPReg
return|;
block|}
name|bool
name|isNaN2008
argument_list|()
specifier|const
block|{
return|return
name|IsNaN2008bit
return|;
block|}
name|bool
name|isGP64bit
argument_list|()
specifier|const
block|{
return|return
name|IsGP64bit
return|;
block|}
name|bool
name|isGP32bit
argument_list|()
specifier|const
block|{
return|return
operator|!
name|IsGP64bit
return|;
block|}
name|unsigned
name|getGPRSizeInBytes
argument_list|()
specifier|const
block|{
return|return
name|isGP64bit
argument_list|()
operator|?
literal|8
operator|:
literal|4
return|;
block|}
name|bool
name|isSingleFloat
argument_list|()
specifier|const
block|{
return|return
name|IsSingleFloat
return|;
block|}
name|bool
name|hasVFPU
argument_list|()
specifier|const
block|{
return|return
name|HasVFPU
return|;
block|}
name|bool
name|inMips16Mode
argument_list|()
specifier|const
block|{
return|return
name|InMips16Mode
return|;
block|}
name|bool
name|inMips16ModeDefault
argument_list|()
specifier|const
block|{
return|return
name|InMips16Mode
return|;
block|}
comment|// Hard float for mips16 means essentially to compile as soft float
comment|// but to use a runtime library for soft float that is written with
comment|// native mips32 floating point instructions (those runtime routines
comment|// run in mips32 hard float mode).
name|bool
name|inMips16HardFloat
argument_list|()
specifier|const
block|{
return|return
name|inMips16Mode
argument_list|()
operator|&&
name|InMips16HardFloat
return|;
block|}
name|bool
name|inMicroMipsMode
argument_list|()
specifier|const
block|{
return|return
name|InMicroMipsMode
return|;
block|}
name|bool
name|inMicroMips32r6Mode
argument_list|()
specifier|const
block|{
return|return
name|InMicroMipsMode
operator|&&
name|hasMips32r6
argument_list|()
return|;
block|}
name|bool
name|hasDSP
argument_list|()
specifier|const
block|{
return|return
name|HasDSP
return|;
block|}
name|bool
name|hasDSPR2
argument_list|()
specifier|const
block|{
return|return
name|HasDSPR2
return|;
block|}
name|bool
name|hasMSA
argument_list|()
specifier|const
block|{
return|return
name|HasMSA
return|;
block|}
name|bool
name|useSmallSection
argument_list|()
specifier|const
block|{
return|return
name|UseSmallSection
return|;
block|}
name|bool
name|hasStandardEncoding
argument_list|()
specifier|const
block|{
return|return
operator|!
name|inMips16Mode
argument_list|()
return|;
block|}
name|bool
name|useSoftFloat
argument_list|()
specifier|const
block|{
return|return
name|IsSoftFloat
return|;
block|}
name|bool
name|enableLongBranchPass
argument_list|()
specifier|const
block|{
return|return
name|hasStandardEncoding
argument_list|()
operator|||
name|allowMixed16_32
argument_list|()
return|;
block|}
comment|/// Features related to the presence of specific instructions.
name|bool
name|hasExtractInsert
argument_list|()
specifier|const
block|{
return|return
operator|!
name|inMips16Mode
argument_list|()
operator|&&
name|hasMips32r2
argument_list|()
return|;
block|}
name|bool
name|hasMTHC1
argument_list|()
specifier|const
block|{
return|return
name|hasMips32r2
argument_list|()
return|;
block|}
name|bool
name|allowMixed16_32
argument_list|()
specifier|const
block|{
return|return
name|inMips16ModeDefault
argument_list|()
operator||
name|AllowMixed16_32
return|;
block|}
name|bool
name|os16
argument_list|()
specifier|const
block|{
return|return
name|Os16
return|;
block|}
name|bool
name|isTargetNaCl
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSNaCl
argument_list|()
return|;
block|}
comment|// for now constant islands are on for the whole compilation unit but we only
comment|// really use them if in addition we are in mips16 mode
specifier|static
name|bool
name|useConstantIslands
argument_list|()
block|;
name|unsigned
name|stackAlignment
argument_list|()
specifier|const
block|{
return|return
name|hasMips64
argument_list|()
condition|?
literal|16
else|:
literal|8
return|;
block|}
comment|// Grab relocation model
name|Reloc
operator|::
name|Model
name|getRelocationModel
argument_list|()
specifier|const
block|;
name|MipsSubtarget
operator|&
name|initializeSubtargetDependencies
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|,
argument|const TargetMachine&TM
argument_list|)
block|;
comment|/// Does the system support unaligned memory access.
comment|///
comment|/// MIPS32r6/MIPS64r6 require full unaligned access support but does not
comment|/// specify which component of the system provides it. Hardware, software, and
comment|/// hybrid implementations are all valid.
name|bool
name|systemSupportsUnalignedAccess
argument_list|()
specifier|const
block|{
return|return
name|hasMips32r6
argument_list|()
return|;
block|}
comment|// Set helper classes
name|void
name|setHelperClassesMips16
argument_list|()
block|;
name|void
name|setHelperClassesMipsSE
argument_list|()
block|;
specifier|const
name|MipsSelectionDAGInfo
operator|*
name|getSelectionDAGInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|TSInfo
return|;
block|}
specifier|const
name|MipsInstrInfo
operator|*
name|getInstrInfo
argument_list|()
specifier|const
name|override
block|{
return|return
name|InstrInfo
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|TargetFrameLowering
operator|*
name|getFrameLowering
argument_list|()
specifier|const
name|override
block|{
return|return
name|FrameLowering
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|MipsRegisterInfo
operator|*
name|getRegisterInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|InstrInfo
operator|->
name|getRegisterInfo
argument_list|()
return|;
block|}
specifier|const
name|MipsTargetLowering
operator|*
name|getTargetLowering
argument_list|()
specifier|const
name|override
block|{
return|return
name|TLInfo
operator|.
name|get
argument_list|()
return|;
block|}
specifier|const
name|InstrItineraryData
operator|*
name|getInstrItineraryData
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|InstrItins
return|;
block|}
expr|}
block|; }
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

