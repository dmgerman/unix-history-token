begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- SIInstrInfo.h - SI Instruction Info Interface -----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// \brief Interface definition for SIInstrInfo.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_AMDGPU_SIINSTRINFO_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_AMDGPU_SIINSTRINFO_H
end_define

begin_include
include|#
directive|include
file|"AMDGPUInstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"SIDefines.h"
end_include

begin_include
include|#
directive|include
file|"SIRegisterInfo.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|SIInstrInfo
name|final
range|:
name|public
name|AMDGPUInstrInfo
block|{
name|private
operator|:
specifier|const
name|SIRegisterInfo
name|RI
block|;
specifier|const
name|SISubtarget
operator|&
name|ST
block|;
comment|// The the inverse predicate should have the negative value.
block|enum
name|BranchPredicate
block|{
name|INVALID_BR
operator|=
literal|0
block|,
name|SCC_TRUE
operator|=
literal|1
block|,
name|SCC_FALSE
operator|=
operator|-
literal|1
block|,
name|VCCNZ
operator|=
literal|2
block|,
name|VCCZ
operator|=
operator|-
literal|2
block|,
name|EXECNZ
operator|=
operator|-
literal|3
block|,
name|EXECZ
operator|=
literal|3
block|}
block|;
specifier|static
name|unsigned
name|getBranchOpcode
argument_list|(
argument|BranchPredicate Cond
argument_list|)
block|;
specifier|static
name|BranchPredicate
name|getBranchPredicate
argument_list|(
argument|unsigned Opcode
argument_list|)
block|;
name|unsigned
name|buildExtractSubReg
argument_list|(
argument|MachineBasicBlock::iterator MI
argument_list|,
argument|MachineRegisterInfo&MRI
argument_list|,
argument|MachineOperand&SuperReg
argument_list|,
argument|const TargetRegisterClass *SuperRC
argument_list|,
argument|unsigned SubIdx
argument_list|,
argument|const TargetRegisterClass *SubRC
argument_list|)
specifier|const
block|;
name|MachineOperand
name|buildExtractSubRegOrImm
argument_list|(
argument|MachineBasicBlock::iterator MI
argument_list|,
argument|MachineRegisterInfo&MRI
argument_list|,
argument|MachineOperand&SuperReg
argument_list|,
argument|const TargetRegisterClass *SuperRC
argument_list|,
argument|unsigned SubIdx
argument_list|,
argument|const TargetRegisterClass *SubRC
argument_list|)
specifier|const
block|;
name|void
name|swapOperands
argument_list|(
argument|MachineInstr&Inst
argument_list|)
specifier|const
block|;
name|void
name|lowerScalarAbs
argument_list|(
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|,
argument|MachineInstr&Inst
argument_list|)
specifier|const
block|;
name|void
name|splitScalar64BitUnaryOp
argument_list|(
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|,
argument|MachineInstr&Inst
argument_list|,
argument|unsigned Opcode
argument_list|)
specifier|const
block|;
name|void
name|splitScalar64BitBinaryOp
argument_list|(
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|,
argument|MachineInstr&Inst
argument_list|,
argument|unsigned Opcode
argument_list|)
specifier|const
block|;
name|void
name|splitScalar64BitBCNT
argument_list|(
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|,
argument|MachineInstr&Inst
argument_list|)
specifier|const
block|;
name|void
name|splitScalar64BitBFE
argument_list|(
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|,
argument|MachineInstr&Inst
argument_list|)
specifier|const
block|;
name|void
name|movePackToVALU
argument_list|(
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|,
argument|MachineRegisterInfo&MRI
argument_list|,
argument|MachineInstr&Inst
argument_list|)
specifier|const
block|;
name|void
name|addUsersToMoveToVALUWorklist
argument_list|(
argument|unsigned Reg
argument_list|,
argument|MachineRegisterInfo&MRI
argument_list|,
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|)
specifier|const
block|;
name|void
name|addSCCDefUsersToVALUWorklist
argument_list|(
argument|MachineInstr&SCCDefInst
argument_list|,
argument|SmallVectorImpl<MachineInstr *>&Worklist
argument_list|)
specifier|const
block|;
specifier|const
name|TargetRegisterClass
operator|*
name|getDestEquivalentVGPRClass
argument_list|(
argument|const MachineInstr&Inst
argument_list|)
specifier|const
block|;
name|bool
name|checkInstOffsetsDoNotOverlap
argument_list|(
argument|MachineInstr&MIa
argument_list|,
argument|MachineInstr&MIb
argument_list|)
specifier|const
block|;
name|unsigned
name|findUsedSGPR
argument_list|(
argument|const MachineInstr&MI
argument_list|,
argument|int OpIndices[
literal|3
argument|]
argument_list|)
specifier|const
block|;
name|protected
operator|:
name|bool
name|swapSourceModifiers
argument_list|(
argument|MachineInstr&MI
argument_list|,
argument|MachineOperand&Src0
argument_list|,
argument|unsigned Src0OpName
argument_list|,
argument|MachineOperand&Src1
argument_list|,
argument|unsigned Src1OpName
argument_list|)
specifier|const
block|;
name|MachineInstr
operator|*
name|commuteInstructionImpl
argument_list|(
argument|MachineInstr&MI
argument_list|,
argument|bool NewMI
argument_list|,
argument|unsigned OpIdx0
argument_list|,
argument|unsigned OpIdx1
argument_list|)
specifier|const
name|override
block|;
name|public
operator|:
expr|enum
name|TargetOperandFlags
block|{
name|MO_MASK
operator|=
literal|0x7
block|,
name|MO_NONE
operator|=
literal|0
block|,
comment|// MO_GOTPCREL -> symbol@GOTPCREL -> R_AMDGPU_GOTPCREL.
name|MO_GOTPCREL
operator|=
literal|1
block|,
comment|// MO_GOTPCREL32_LO -> symbol@gotpcrel32@lo -> R_AMDGPU_GOTPCREL32_LO.
name|MO_GOTPCREL32
operator|=
literal|2
block|,
name|MO_GOTPCREL32_LO
operator|=
literal|2
block|,
comment|// MO_GOTPCREL32_HI -> symbol@gotpcrel32@hi -> R_AMDGPU_GOTPCREL32_HI.
name|MO_GOTPCREL32_HI
operator|=
literal|3
block|,
comment|// MO_REL32_LO -> symbol@rel32@lo -> R_AMDGPU_REL32_LO.
name|MO_REL32
operator|=
literal|4
block|,
name|MO_REL32_LO
operator|=
literal|4
block|,
comment|// MO_REL32_HI -> symbol@rel32@hi -> R_AMDGPU_REL32_HI.
name|MO_REL32_HI
operator|=
literal|5
block|}
block|;
name|explicit
name|SIInstrInfo
argument_list|(
specifier|const
name|SISubtarget
operator|&
argument_list|)
block|;
specifier|const
name|SIRegisterInfo
operator|&
name|getRegisterInfo
argument_list|()
specifier|const
block|{
return|return
name|RI
return|;
block|}
name|bool
name|isReallyTriviallyReMaterializable
argument_list|(
argument|const MachineInstr&MI
argument_list|,
argument|AliasAnalysis *AA
argument_list|)
specifier|const
name|override
block|;
name|bool
name|areLoadsFromSameBasePtr
argument_list|(
argument|SDNode *Load1
argument_list|,
argument|SDNode *Load2
argument_list|,
argument|int64_t&Offset1
argument_list|,
argument|int64_t&Offset2
argument_list|)
specifier|const
name|override
block|;
name|bool
name|getMemOpBaseRegImmOfs
argument_list|(
argument|MachineInstr&LdSt
argument_list|,
argument|unsigned&BaseReg
argument_list|,
argument|int64_t&Offset
argument_list|,
argument|const TargetRegisterInfo *TRI
argument_list|)
specifier|const
name|final
block|;
name|bool
name|shouldClusterMemOps
argument_list|(
argument|MachineInstr&FirstLdSt
argument_list|,
argument|MachineInstr&SecondLdSt
argument_list|,
argument|unsigned NumLoads
argument_list|)
specifier|const
name|final
block|;
name|void
name|copyPhysReg
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator MI
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|unsigned DestReg
argument_list|,
argument|unsigned SrcReg
argument_list|,
argument|bool KillSrc
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|calculateLDSSpillAddress
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineInstr&MI
argument_list|,
argument|RegScavenger *RS
argument_list|,
argument|unsigned TmpReg
argument_list|,
argument|unsigned Offset
argument_list|,
argument|unsigned Size
argument_list|)
specifier|const
block|;
name|void
name|materializeImmediate
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator MI
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|unsigned DestReg
argument_list|,
argument|int64_t Value
argument_list|)
specifier|const
block|;
specifier|const
name|TargetRegisterClass
operator|*
name|getPreferredSelectRegClass
argument_list|(
argument|unsigned Size
argument_list|)
specifier|const
block|;
name|unsigned
name|insertNE
argument_list|(
argument|MachineBasicBlock *MBB
argument_list|,
argument|MachineBasicBlock::iterator I
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|unsigned SrcReg
argument_list|,
argument|int Value
argument_list|)
specifier|const
block|;
name|unsigned
name|insertEQ
argument_list|(
argument|MachineBasicBlock *MBB
argument_list|,
argument|MachineBasicBlock::iterator I
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|unsigned SrcReg
argument_list|,
argument|int Value
argument_list|)
specifier|const
block|;
name|void
name|storeRegToStackSlot
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator MI
argument_list|,
argument|unsigned SrcReg
argument_list|,
argument|bool isKill
argument_list|,
argument|int FrameIndex
argument_list|,
argument|const TargetRegisterClass *RC
argument_list|,
argument|const TargetRegisterInfo *TRI
argument_list|)
specifier|const
name|override
block|;
name|void
name|loadRegFromStackSlot
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator MI
argument_list|,
argument|unsigned DestReg
argument_list|,
argument|int FrameIndex
argument_list|,
argument|const TargetRegisterClass *RC
argument_list|,
argument|const TargetRegisterInfo *TRI
argument_list|)
specifier|const
name|override
block|;
name|bool
name|expandPostRAPseudo
argument_list|(
argument|MachineInstr&MI
argument_list|)
specifier|const
name|override
block|;
comment|// \brief Returns an opcode that can be used to move a value to a \p DstRC
comment|// register.  If there is no hardware instruction that can store to \p
comment|// DstRC, then AMDGPU::COPY is returned.
name|unsigned
name|getMovOpcode
argument_list|(
argument|const TargetRegisterClass *DstRC
argument_list|)
specifier|const
block|;
name|LLVM_READONLY
name|int
name|commuteOpcode
argument_list|(
argument|unsigned Opc
argument_list|)
specifier|const
block|;
name|LLVM_READONLY
specifier|inline
name|int
name|commuteOpcode
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
block|{
return|return
name|commuteOpcode
argument_list|(
name|MI
operator|.
name|getOpcode
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|findCommutedOpIndices
argument_list|(
argument|MachineInstr&MI
argument_list|,
argument|unsigned&SrcOpIdx1
argument_list|,
argument|unsigned&SrcOpIdx2
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isBranchOffsetInRange
argument_list|(
argument|unsigned BranchOpc
argument_list|,
argument|int64_t BrOffset
argument_list|)
specifier|const
name|override
block|;
name|MachineBasicBlock
operator|*
name|getBranchDestBlock
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|insertIndirectBranch
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock&NewDestBB
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|int64_t BrOffset
argument_list|,
argument|RegScavenger *RS = nullptr
argument_list|)
specifier|const
name|override
block|;
name|bool
name|analyzeBranchImpl
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator I
argument_list|,
argument|MachineBasicBlock *&TBB
argument_list|,
argument|MachineBasicBlock *&FBB
argument_list|,
argument|SmallVectorImpl<MachineOperand>&Cond
argument_list|,
argument|bool AllowModify
argument_list|)
specifier|const
block|;
name|bool
name|analyzeBranch
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock *&TBB
argument_list|,
argument|MachineBasicBlock *&FBB
argument_list|,
argument|SmallVectorImpl<MachineOperand>&Cond
argument_list|,
argument|bool AllowModify = false
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|removeBranch
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|int *BytesRemoved = nullptr
argument_list|)
specifier|const
name|override
block|;
name|unsigned
name|insertBranch
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock *TBB
argument_list|,
argument|MachineBasicBlock *FBB
argument_list|,
argument|ArrayRef<MachineOperand> Cond
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|int *BytesAdded = nullptr
argument_list|)
specifier|const
name|override
block|;
name|bool
name|reverseBranchCondition
argument_list|(
argument|SmallVectorImpl<MachineOperand>&Cond
argument_list|)
specifier|const
name|override
block|;
name|bool
name|canInsertSelect
argument_list|(
argument|const MachineBasicBlock&MBB
argument_list|,
argument|ArrayRef<MachineOperand> Cond
argument_list|,
argument|unsigned TrueReg
argument_list|,
argument|unsigned FalseReg
argument_list|,
argument|int&CondCycles
argument_list|,
argument|int&TrueCycles
argument_list|,
argument|int&FalseCycles
argument_list|)
specifier|const
name|override
block|;
name|void
name|insertSelect
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator I
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|unsigned DstReg
argument_list|,
argument|ArrayRef<MachineOperand> Cond
argument_list|,
argument|unsigned TrueReg
argument_list|,
argument|unsigned FalseReg
argument_list|)
specifier|const
name|override
block|;
name|void
name|insertVectorSelect
argument_list|(
argument|MachineBasicBlock&MBB
argument_list|,
argument|MachineBasicBlock::iterator I
argument_list|,
argument|const DebugLoc&DL
argument_list|,
argument|unsigned DstReg
argument_list|,
argument|ArrayRef<MachineOperand> Cond
argument_list|,
argument|unsigned TrueReg
argument_list|,
argument|unsigned FalseReg
argument_list|)
specifier|const
block|;
name|bool
name|areMemAccessesTriviallyDisjoint
argument_list|(
argument|MachineInstr&MIa
argument_list|,
argument|MachineInstr&MIb
argument_list|,
argument|AliasAnalysis *AA = nullptr
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isFoldableCopy
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
block|;
name|bool
name|FoldImmediate
argument_list|(
argument|MachineInstr&UseMI
argument_list|,
argument|MachineInstr&DefMI
argument_list|,
argument|unsigned Reg
argument_list|,
argument|MachineRegisterInfo *MRI
argument_list|)
specifier|const
name|final
block|;
name|unsigned
name|getMachineCSELookAheadLimit
argument_list|()
specifier|const
name|override
block|{
return|return
literal|500
return|;
block|}
name|MachineInstr
operator|*
name|convertToThreeAddress
argument_list|(
argument|MachineFunction::iterator&MBB
argument_list|,
argument|MachineInstr&MI
argument_list|,
argument|LiveVariables *LV
argument_list|)
specifier|const
name|override
block|;
name|bool
name|isSchedulingBoundary
argument_list|(
argument|const MachineInstr&MI
argument_list|,
argument|const MachineBasicBlock *MBB
argument_list|,
argument|const MachineFunction&MF
argument_list|)
specifier|const
name|override
block|;
specifier|static
name|bool
name|isSALU
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SALU
return|;
block|}
name|bool
name|isSALU
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SALU
return|;
block|}
specifier|static
name|bool
name|isVALU
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VALU
return|;
block|}
name|bool
name|isVALU
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VALU
return|;
block|}
specifier|static
name|bool
name|isVMEM
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|isMUBUF
argument_list|(
name|MI
argument_list|)
operator|||
name|isMTBUF
argument_list|(
name|MI
argument_list|)
operator|||
name|isMIMG
argument_list|(
name|MI
argument_list|)
return|;
block|}
name|bool
name|isVMEM
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|isMUBUF
argument_list|(
name|Opcode
argument_list|)
operator|||
name|isMTBUF
argument_list|(
name|Opcode
argument_list|)
operator|||
name|isMIMG
argument_list|(
name|Opcode
argument_list|)
return|;
block|}
specifier|static
name|bool
name|isSOP1
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOP1
return|;
block|}
name|bool
name|isSOP1
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOP1
return|;
block|}
specifier|static
name|bool
name|isSOP2
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOP2
return|;
block|}
name|bool
name|isSOP2
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOP2
return|;
block|}
specifier|static
name|bool
name|isSOPC
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPC
return|;
block|}
name|bool
name|isSOPC
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPC
return|;
block|}
specifier|static
name|bool
name|isSOPK
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPK
return|;
block|}
name|bool
name|isSOPK
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPK
return|;
block|}
specifier|static
name|bool
name|isSOPP
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPP
return|;
block|}
name|bool
name|isSOPP
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPP
return|;
block|}
specifier|static
name|bool
name|isVOP1
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP1
return|;
block|}
name|bool
name|isVOP1
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP1
return|;
block|}
specifier|static
name|bool
name|isVOP2
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP2
return|;
block|}
name|bool
name|isVOP2
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP2
return|;
block|}
specifier|static
name|bool
name|isVOP3
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP3
return|;
block|}
name|bool
name|isVOP3
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP3
return|;
block|}
specifier|static
name|bool
name|isSDWA
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SDWA
return|;
block|}
name|bool
name|isSDWA
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SDWA
return|;
block|}
specifier|static
name|bool
name|isVOPC
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOPC
return|;
block|}
name|bool
name|isVOPC
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOPC
return|;
block|}
specifier|static
name|bool
name|isMUBUF
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|MUBUF
return|;
block|}
name|bool
name|isMUBUF
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|MUBUF
return|;
block|}
specifier|static
name|bool
name|isMTBUF
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|MTBUF
return|;
block|}
name|bool
name|isMTBUF
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|MTBUF
return|;
block|}
specifier|static
name|bool
name|isSMRD
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SMRD
return|;
block|}
name|bool
name|isSMRD
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SMRD
return|;
block|}
specifier|static
name|bool
name|isDS
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|DS
return|;
block|}
name|bool
name|isDS
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|DS
return|;
block|}
specifier|static
name|bool
name|isMIMG
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|MIMG
return|;
block|}
name|bool
name|isMIMG
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|MIMG
return|;
block|}
specifier|static
name|bool
name|isGather4
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|Gather4
return|;
block|}
name|bool
name|isGather4
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|Gather4
return|;
block|}
specifier|static
name|bool
name|isFLAT
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|FLAT
return|;
block|}
name|bool
name|isFLAT
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|FLAT
return|;
block|}
specifier|static
name|bool
name|isEXP
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|EXP
return|;
block|}
name|bool
name|isEXP
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|EXP
return|;
block|}
specifier|static
name|bool
name|isWQM
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|WQM
return|;
block|}
name|bool
name|isWQM
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|WQM
return|;
block|}
specifier|static
name|bool
name|isDisableWQM
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|DisableWQM
return|;
block|}
name|bool
name|isDisableWQM
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|DisableWQM
return|;
block|}
specifier|static
name|bool
name|isVGPRSpill
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VGPRSpill
return|;
block|}
name|bool
name|isVGPRSpill
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VGPRSpill
return|;
block|}
specifier|static
name|bool
name|isSGPRSpill
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SGPRSpill
return|;
block|}
name|bool
name|isSGPRSpill
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SGPRSpill
return|;
block|}
specifier|static
name|bool
name|isDPP
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|DPP
return|;
block|}
name|bool
name|isDPP
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|DPP
return|;
block|}
specifier|static
name|bool
name|isVOP3P
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP3P
return|;
block|}
name|bool
name|isVOP3P
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VOP3P
return|;
block|}
specifier|static
name|bool
name|isVINTRP
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VINTRP
return|;
block|}
name|bool
name|isVINTRP
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VINTRP
return|;
block|}
specifier|static
name|bool
name|isScalarUnit
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
operator|(
name|SIInstrFlags
operator|::
name|SALU
operator||
name|SIInstrFlags
operator|::
name|SMRD
operator|)
return|;
block|}
specifier|static
name|bool
name|usesVM_CNT
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|VM_CNT
return|;
block|}
specifier|static
name|bool
name|sopkIsZext
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPK_ZEXT
return|;
block|}
name|bool
name|sopkIsZext
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SOPK_ZEXT
return|;
block|}
comment|/// \returns true if this is an s_store_dword* instruction. This is more
comment|/// specific than than isSMEM&& mayStore.
specifier|static
name|bool
name|isScalarStore
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SCALAR_STORE
return|;
block|}
name|bool
name|isScalarStore
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|SCALAR_STORE
return|;
block|}
specifier|static
name|bool
name|isFixedSize
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|FIXED_SIZE
return|;
block|}
name|bool
name|isFixedSize
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|FIXED_SIZE
return|;
block|}
specifier|static
name|bool
name|hasFPClamp
argument_list|(
argument|const MachineInstr&MI
argument_list|)
block|{
return|return
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|HasFPClamp
return|;
block|}
name|bool
name|hasFPClamp
argument_list|(
argument|uint16_t Opcode
argument_list|)
specifier|const
block|{
return|return
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|TSFlags
operator|&
name|SIInstrFlags
operator|::
name|HasFPClamp
return|;
block|}
name|bool
name|isVGPRCopy
argument_list|(
argument|const MachineInstr&MI
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|MI
operator|.
name|isCopy
argument_list|()
argument_list|)
block|;
name|unsigned
name|Dest
operator|=
name|MI
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
operator|.
name|getReg
argument_list|()
block|;
specifier|const
name|MachineFunction
operator|&
name|MF
operator|=
operator|*
name|MI
operator|.
name|getParent
argument_list|()
operator|->
name|getParent
argument_list|()
block|;
specifier|const
name|MachineRegisterInfo
operator|&
name|MRI
operator|=
name|MF
operator|.
name|getRegInfo
argument_list|()
block|;
return|return
operator|!
name|RI
operator|.
name|isSGPRReg
argument_list|(
name|MRI
argument_list|,
name|Dest
argument_list|)
return|;
block|}
name|bool
name|isInlineConstant
argument_list|(
argument|const APInt&Imm
argument_list|)
specifier|const
block|;
name|bool
name|isInlineConstant
argument_list|(
argument|const MachineOperand&MO
argument_list|,
argument|uint8_t OperandType
argument_list|)
specifier|const
block|;
name|bool
name|isInlineConstant
argument_list|(
argument|const MachineOperand&MO
argument_list|,
argument|const MCOperandInfo&OpInfo
argument_list|)
specifier|const
block|{
return|return
name|isInlineConstant
argument_list|(
name|MO
argument_list|,
name|OpInfo
operator|.
name|OperandType
argument_list|)
return|;
block|}
comment|/// \p returns true if \p UseMO is substituted with \p DefMO in \p MI it would
comment|/// be an inline immediate.
name|bool
name|isInlineConstant
argument_list|(
argument|const MachineInstr&MI
argument_list|,
argument|const MachineOperand&UseMO
argument_list|,
argument|const MachineOperand&DefMO
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|UseMO
operator|.
name|getParent
argument_list|()
operator|==
operator|&
name|MI
argument_list|)
block|;
name|int
name|OpIdx
operator|=
name|MI
operator|.
name|getOperandNo
argument_list|(
operator|&
name|UseMO
argument_list|)
block|;
if|if
condition|(
operator|!
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|OpInfo
operator|||
name|OpIdx
operator|>=
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|NumOperands
condition|)
block|{
return|return
name|false
return|;
block|}
return|return
name|isInlineConstant
argument_list|(
name|DefMO
argument_list|,
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|OpInfo
index|[
name|OpIdx
index|]
argument_list|)
return|;
block|}
comment|/// \p returns true if the operand \p OpIdx in \p MI is a valid inline
comment|/// immediate.
name|bool
name|isInlineConstant
argument_list|(
argument|const MachineInstr&MI
argument_list|,
argument|unsigned OpIdx
argument_list|)
specifier|const
block|{
specifier|const
name|MachineOperand
operator|&
name|MO
operator|=
name|MI
operator|.
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
block|;
return|return
name|isInlineConstant
argument_list|(
name|MO
argument_list|,
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|OperandType
argument_list|)
return|;
block|}
name|bool
name|isInlineConstant
argument_list|(
argument|const MachineInstr&MI
argument_list|,
argument|unsigned OpIdx
argument_list|,
argument|const MachineOperand&MO
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|OpInfo
operator|||
name|OpIdx
operator|>=
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|NumOperands
condition|)
return|return
name|false
return|;
if|if
condition|(
name|MI
operator|.
name|isCopy
argument_list|()
condition|)
block|{
name|unsigned
name|Size
init|=
name|getOpSize
argument_list|(
name|MI
argument_list|,
name|OpIdx
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Size
operator|==
literal|8
operator|||
name|Size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|uint8_t
name|OpType
init|=
operator|(
name|Size
operator|==
literal|8
operator|)
condition|?
name|AMDGPU
operator|::
name|OPERAND_REG_IMM_INT64
else|:
name|AMDGPU
operator|::
name|OPERAND_REG_IMM_INT32
decl_stmt|;
return|return
name|isInlineConstant
argument_list|(
name|MO
argument_list|,
name|OpType
argument_list|)
return|;
block|}
return|return
name|isInlineConstant
argument_list|(
name|MO
argument_list|,
name|MI
operator|.
name|getDesc
argument_list|()
operator|.
name|OpInfo
index|[
name|OpIdx
index|]
operator|.
name|OperandType
argument_list|)
return|;
block|}
name|bool
name|isInlineConstant
argument_list|(
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|)
decl|const
block|{
specifier|const
name|MachineInstr
modifier|*
name|Parent
init|=
name|MO
operator|.
name|getParent
argument_list|()
decl_stmt|;
return|return
name|isInlineConstant
argument_list|(
operator|*
name|Parent
argument_list|,
name|Parent
operator|->
name|getOperandNo
argument_list|(
operator|&
name|MO
argument_list|)
argument_list|)
return|;
block|}
name|bool
name|isLiteralConstant
argument_list|(
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|,
specifier|const
name|MCOperandInfo
operator|&
name|OpInfo
argument_list|)
decl|const
block|{
return|return
name|MO
operator|.
name|isImm
argument_list|()
operator|&&
operator|!
name|isInlineConstant
argument_list|(
name|MO
argument_list|,
name|OpInfo
operator|.
name|OperandType
argument_list|)
return|;
block|}
name|bool
name|isLiteralConstant
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
name|OpIdx
argument_list|)
decl|const
block|{
specifier|const
name|MachineOperand
modifier|&
name|MO
init|=
name|MI
operator|.
name|getOperand
argument_list|(
name|OpIdx
argument_list|)
decl_stmt|;
return|return
name|MO
operator|.
name|isImm
argument_list|()
operator|&&
operator|!
name|isInlineConstant
argument_list|(
name|MI
argument_list|,
name|OpIdx
argument_list|)
return|;
block|}
comment|// Returns true if this operand could potentially require a 32-bit literal
comment|// operand, but not necessarily. A FrameIndex for example could resolve to an
comment|// inline immediate value that will not require an additional 4-bytes; this
comment|// assumes that it will.
name|bool
name|isLiteralConstantLike
argument_list|(
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|,
specifier|const
name|MCOperandInfo
operator|&
name|OpInfo
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isImmOperandLegal
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNo
argument_list|,
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return true if this 64-bit VALU instruction has a 32-bit encoding.
comment|/// This function will return false if you pass it a 32-bit instruction.
name|bool
name|hasVALU32BitEncoding
argument_list|(
name|unsigned
name|Opcode
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Returns true if this operand uses the constant bus.
name|bool
name|usesConstantBus
argument_list|(
specifier|const
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|,
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|,
specifier|const
name|MCOperandInfo
operator|&
name|OpInfo
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return true if this instruction has any modifiers.
comment|///  e.g. src[012]_mod, omod, clamp.
name|bool
name|hasModifiers
argument_list|(
name|unsigned
name|Opcode
argument_list|)
decl|const
decl_stmt|;
name|bool
name|hasModifiersSet
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpName
argument_list|)
decl|const
decl_stmt|;
name|bool
name|hasAnyModifiersSet
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
name|bool
name|verifyInstruction
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|StringRef
operator|&
name|ErrInfo
argument_list|)
decl|const
name|override
decl_stmt|;
specifier|static
name|unsigned
name|getVALUOp
parameter_list|(
specifier|const
name|MachineInstr
modifier|&
name|MI
parameter_list|)
function_decl|;
name|bool
name|isSALUOpSupportedOnVALU
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return the correct register class for \p OpNo.  For target-specific
comment|/// instructions, this will return the register class that has been defined
comment|/// in tablegen.  For generic instructions, like REG_SEQUENCE it will return
comment|/// the register class of its machine operand.
comment|/// to infer the correct register class base on the other operands.
specifier|const
name|TargetRegisterClass
modifier|*
name|getOpRegClass
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNo
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return the size in bytes of the operand OpNo on the given
comment|// instruction opcode.
name|unsigned
name|getOpSize
argument_list|(
name|uint16_t
name|Opcode
argument_list|,
name|unsigned
name|OpNo
argument_list|)
decl|const
block|{
specifier|const
name|MCOperandInfo
modifier|&
name|OpInfo
init|=
name|get
argument_list|(
name|Opcode
argument_list|)
operator|.
name|OpInfo
index|[
name|OpNo
index|]
decl_stmt|;
if|if
condition|(
name|OpInfo
operator|.
name|RegClass
operator|==
operator|-
literal|1
condition|)
block|{
comment|// If this is an immediate operand, this must be a 32-bit literal.
name|assert
argument_list|(
name|OpInfo
operator|.
name|OperandType
operator|==
name|MCOI
operator|::
name|OPERAND_IMMEDIATE
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
return|return
name|RI
operator|.
name|getRegSizeInBits
argument_list|(
operator|*
name|RI
operator|.
name|getRegClass
argument_list|(
name|OpInfo
operator|.
name|RegClass
argument_list|)
argument_list|)
operator|/
literal|8
return|;
block|}
comment|/// \brief This form should usually be preferred since it handles operands
comment|/// with unknown register classes.
name|unsigned
name|getOpSize
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNo
argument_list|)
decl|const
block|{
return|return
name|RI
operator|.
name|getRegSizeInBits
argument_list|(
operator|*
name|getOpRegClass
argument_list|(
name|MI
argument_list|,
name|OpNo
argument_list|)
argument_list|)
operator|/
literal|8
return|;
block|}
comment|/// \returns true if it is legal for the operand at index \p OpNo
comment|/// to read a VGPR.
name|bool
name|canReadVGPR
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpNo
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Legalize the \p OpIndex operand of this instruction by inserting
comment|/// a MOV.  For example:
comment|/// ADD_I32_e32 VGPR0, 15
comment|/// to
comment|/// MOV VGPR1, 15
comment|/// ADD_I32_e32 VGPR0, VGPR1
comment|///
comment|/// If the operand being legalized is a register, then a COPY will be used
comment|/// instead of MOV.
name|void
name|legalizeOpWithMove
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpIdx
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Check if \p MO is a legal operand if it was the \p OpIdx Operand
comment|/// for \p MI.
name|bool
name|isOperandLegal
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpIdx
argument_list|,
specifier|const
name|MachineOperand
operator|*
name|MO
operator|=
name|nullptr
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Check if \p MO would be a valid operand for the given operand
comment|/// definition \p OpInfo. Note this does not attempt to validate constant bus
comment|/// restrictions (e.g. literal constant usage).
name|bool
name|isLegalVSrcOperand
argument_list|(
specifier|const
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|,
specifier|const
name|MCOperandInfo
operator|&
name|OpInfo
argument_list|,
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Check if \p MO (a register operand) is a legal register for the
comment|/// given operand description.
name|bool
name|isLegalRegOperand
argument_list|(
specifier|const
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|,
specifier|const
name|MCOperandInfo
operator|&
name|OpInfo
argument_list|,
specifier|const
name|MachineOperand
operator|&
name|MO
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Legalize operands in \p MI by either commuting it or inserting a
comment|/// copy of src1.
name|void
name|legalizeOperandsVOP2
argument_list|(
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Fix operands in \p MI to satisfy constant bus requirements.
name|void
name|legalizeOperandsVOP3
argument_list|(
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// Copy a value from a VGPR (\p SrcReg) to SGPR.  This function can only
comment|/// be used when it is know that the value in SrcReg is same across all
comment|/// threads in the wave.
comment|/// \returns The SGPR register that \p SrcReg was copied to.
name|unsigned
name|readlaneVGPRToSGPR
argument_list|(
name|unsigned
name|SrcReg
argument_list|,
name|MachineInstr
operator|&
name|UseMI
argument_list|,
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|)
decl|const
decl_stmt|;
name|void
name|legalizeOperandsSMRD
argument_list|(
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|,
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
name|void
name|legalizeGenericOperand
argument_list|(
name|MachineBasicBlock
operator|&
name|InsertMBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|I
argument_list|,
specifier|const
name|TargetRegisterClass
operator|*
name|DstRC
argument_list|,
name|MachineOperand
operator|&
name|Op
argument_list|,
name|MachineRegisterInfo
operator|&
name|MRI
argument_list|,
specifier|const
name|DebugLoc
operator|&
name|DL
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Legalize all operands in this instruction.  This function may
comment|/// create new instruction and insert them before \p MI.
name|void
name|legalizeOperands
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Replace this instruction's opcode with the equivalent VALU
comment|/// opcode.  This function will also move the users of \p MI to the
comment|/// VALU if necessary.
name|void
name|moveToVALU
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
name|void
name|insertWaitStates
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|,
name|int
name|Count
argument_list|)
decl|const
decl_stmt|;
name|void
name|insertNoop
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|MI
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|insertReturn
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return the number of wait states that result from executing this
comment|/// instruction.
name|unsigned
name|getNumWaitStates
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Returns the operand named \p Op.  If \p MI does not have an
comment|/// operand named \c Op, this function returns nullptr.
name|LLVM_READONLY
name|MachineOperand
modifier|*
name|getNamedOperand
argument_list|(
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OperandName
argument_list|)
decl|const
decl_stmt|;
name|LLVM_READONLY
specifier|const
name|MachineOperand
modifier|*
name|getNamedOperand
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpName
argument_list|)
decl|const
block|{
return|return
name|getNamedOperand
argument_list|(
name|const_cast
operator|<
name|MachineInstr
operator|&
operator|>
operator|(
name|MI
operator|)
argument_list|,
name|OpName
argument_list|)
return|;
block|}
comment|/// Get required immediate operand
name|int64_t
name|getNamedImmOperand
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|unsigned
name|OpName
argument_list|)
decl|const
block|{
name|int
name|Idx
init|=
name|AMDGPU
operator|::
name|getNamedOperandIdx
argument_list|(
name|MI
operator|.
name|getOpcode
argument_list|()
argument_list|,
name|OpName
argument_list|)
decl_stmt|;
return|return
name|MI
operator|.
name|getOperand
argument_list|(
name|Idx
argument_list|)
operator|.
name|getImm
argument_list|()
return|;
block|}
name|uint64_t
name|getDefaultRsrcDataFormat
argument_list|()
specifier|const
expr_stmt|;
name|uint64_t
name|getScratchRsrcWords23
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|isLowLatencyInstruction
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isHighLatencyInstruction
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return the descriptor of the target-specific machine instruction
comment|/// that corresponds to the specified pseudo or native opcode.
specifier|const
name|MCInstrDesc
modifier|&
name|getMCOpcodeFromPseudo
argument_list|(
name|unsigned
name|Opcode
argument_list|)
decl|const
block|{
return|return
name|get
argument_list|(
name|pseudoToMCOpcode
argument_list|(
name|Opcode
argument_list|)
argument_list|)
return|;
block|}
name|unsigned
name|isStackAccess
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|isSGPRStackAccess
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
decl_stmt|;
name|unsigned
name|isLoadFromStackSlot
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|isStoreToStackSlot
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|,
name|int
operator|&
name|FrameIndex
argument_list|)
decl|const
name|override
decl_stmt|;
name|unsigned
name|getInstSizeInBytes
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|mayAccessFlatAddressSpace
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isNonUniformBranchInstr
argument_list|(
name|MachineInstr
operator|&
name|Instr
argument_list|)
decl|const
decl_stmt|;
name|void
name|convertNonUniformIfRegion
argument_list|(
name|MachineBasicBlock
operator|*
name|IfEntry
argument_list|,
name|MachineBasicBlock
operator|*
name|IfEnd
argument_list|)
decl|const
decl_stmt|;
name|void
name|convertNonUniformLoopRegion
argument_list|(
name|MachineBasicBlock
operator|*
name|LoopEntry
argument_list|,
name|MachineBasicBlock
operator|*
name|LoopEnd
argument_list|)
decl|const
decl_stmt|;
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|unsigned
operator|>
name|decomposeMachineOperandsTargetFlags
argument_list|(
argument|unsigned TF
argument_list|)
specifier|const
name|override
expr_stmt|;
name|ArrayRef
operator|<
name|std
operator|::
name|pair
operator|<
name|int
operator|,
specifier|const
name|char
operator|*
operator|>>
name|getSerializableTargetIndices
argument_list|()
specifier|const
name|override
expr_stmt|;
name|ArrayRef
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|>>
name|getSerializableDirectMachineOperandTargetFlags
argument_list|()
specifier|const
name|override
expr_stmt|;
name|ScheduleHazardRecognizer
modifier|*
name|CreateTargetPostRAHazardRecognizer
argument_list|(
specifier|const
name|InstrItineraryData
operator|*
name|II
argument_list|,
specifier|const
name|ScheduleDAG
operator|*
name|DAG
argument_list|)
decl|const
name|override
decl_stmt|;
name|ScheduleHazardRecognizer
modifier|*
name|CreateTargetPostRAHazardRecognizer
argument_list|(
specifier|const
name|MachineFunction
operator|&
name|MF
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|isBasicBlockPrologue
argument_list|(
specifier|const
name|MachineInstr
operator|&
name|MI
argument_list|)
decl|const
name|override
decl_stmt|;
comment|/// \brief Return a partially built integer add instruction without carry.
comment|/// Caller must add source operands.
comment|/// For pre-GFX9 it will generate unused carry destination operand.
comment|/// TODO: After GFX9 it should return a no-carry operation.
name|MachineInstrBuilder
name|getAddNoCarry
argument_list|(
name|MachineBasicBlock
operator|&
name|MBB
argument_list|,
name|MachineBasicBlock
operator|::
name|iterator
name|I
argument_list|,
specifier|const
name|DebugLoc
operator|&
name|DL
argument_list|,
name|unsigned
name|DestReg
argument_list|)
decl|const
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|namespace
name|AMDGPU
block|{
name|LLVM_READONLY
name|int
name|getVOPe64
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getVOPe32
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getSDWAOp
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getBasicFromSDWAOp
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getCommuteRev
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getCommuteOrig
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getAddr64Inst
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getAtomicRetOp
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getAtomicNoRetOp
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
name|LLVM_READONLY
name|int
name|getSOPKOp
parameter_list|(
name|uint16_t
name|Opcode
parameter_list|)
function_decl|;
specifier|const
name|uint64_t
name|RSRC_DATA_FORMAT
init|=
literal|0xf00000000000LL
decl_stmt|;
specifier|const
name|uint64_t
name|RSRC_ELEMENT_SIZE_SHIFT
init|=
operator|(
literal|32
operator|+
literal|19
operator|)
decl_stmt|;
specifier|const
name|uint64_t
name|RSRC_INDEX_STRIDE_SHIFT
init|=
operator|(
literal|32
operator|+
literal|21
operator|)
decl_stmt|;
specifier|const
name|uint64_t
name|RSRC_TID_ENABLE
init|=
name|UINT64_C
argument_list|(
literal|1
argument_list|)
operator|<<
operator|(
literal|32
operator|+
literal|23
operator|)
decl_stmt|;
comment|// For MachineOperands.
enum|enum
name|TargetFlags
block|{
name|TF_LONG_BRANCH_FORWARD
init|=
literal|1
operator|<<
literal|0
block|,
name|TF_LONG_BRANCH_BACKWARD
init|=
literal|1
operator|<<
literal|1
block|}
enum|;
block|}
end_decl_stmt

begin_comment
comment|// End namespace AMDGPU
end_comment

begin_decl_stmt
name|namespace
name|SI
block|{
name|namespace
name|KernelInputOffsets
block|{
comment|/// Offsets in bytes from the start of the input buffer
enum|enum
name|Offsets
block|{
name|NGROUPS_X
init|=
literal|0
block|,
name|NGROUPS_Y
init|=
literal|4
block|,
name|NGROUPS_Z
init|=
literal|8
block|,
name|GLOBAL_SIZE_X
init|=
literal|12
block|,
name|GLOBAL_SIZE_Y
init|=
literal|16
block|,
name|GLOBAL_SIZE_Z
init|=
literal|20
block|,
name|LOCAL_SIZE_X
init|=
literal|24
block|,
name|LOCAL_SIZE_Y
init|=
literal|28
block|,
name|LOCAL_SIZE_Z
init|=
literal|32
block|}
enum|;
block|}
comment|// End namespace KernelInputOffsets
block|}
end_decl_stmt

begin_comment
comment|// End namespace SI
end_comment

begin_comment
unit|}
comment|// End namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

