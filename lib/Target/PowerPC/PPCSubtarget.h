begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- PPCSubtarget.h - Define Subtarget for the PPC ----------*- C++ -*--===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file declares the PowerPC specific subclass of TargetSubtargetInfo.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LIB_TARGET_POWERPC_PPCSUBTARGET_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LIB_TARGET_POWERPC_PPCSUBTARGET_H
end_define

begin_include
include|#
directive|include
file|"PPCFrameLowering.h"
end_include

begin_include
include|#
directive|include
file|"PPCISelLowering.h"
end_include

begin_include
include|#
directive|include
file|"PPCInstrInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Triple.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAGTargetInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/DataLayout.h"
end_include

begin_include
include|#
directive|include
file|"llvm/MC/MCInstrItineraries.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Target/TargetSubtargetInfo.h"
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_define
define|#
directive|define
name|GET_SUBTARGETINFO_HEADER
end_define

begin_include
include|#
directive|include
file|"PPCGenSubtargetInfo.inc"
end_include

begin_comment
comment|// GCC #defines PPC on Linux but we use it as our namespace name
end_comment

begin_undef
undef|#
directive|undef
name|PPC
end_undef

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|StringRef
decl_stmt|;
name|namespace
name|PPC
block|{
comment|// -m directive values.
enum|enum
block|{
name|DIR_NONE
block|,
name|DIR_32
block|,
name|DIR_440
block|,
name|DIR_601
block|,
name|DIR_602
block|,
name|DIR_603
block|,
name|DIR_7400
block|,
name|DIR_750
block|,
name|DIR_970
block|,
name|DIR_A2
block|,
name|DIR_E500mc
block|,
name|DIR_E5500
block|,
name|DIR_PWR3
block|,
name|DIR_PWR4
block|,
name|DIR_PWR5
block|,
name|DIR_PWR5X
block|,
name|DIR_PWR6
block|,
name|DIR_PWR6X
block|,
name|DIR_PWR7
block|,
name|DIR_PWR8
block|,
name|DIR_PWR9
block|,
name|DIR_64
block|}
enum|;
block|}
name|class
name|GlobalValue
decl_stmt|;
name|class
name|TargetMachine
decl_stmt|;
name|class
name|PPCSubtarget
range|:
name|public
name|PPCGenSubtargetInfo
block|{
name|public
operator|:
expr|enum
name|POPCNTDKind
block|{
name|POPCNTD_Unavailable
block|,
name|POPCNTD_Slow
block|,
name|POPCNTD_Fast
block|}
block|;
name|protected
operator|:
comment|/// TargetTriple - What processor and OS we're targeting.
name|Triple
name|TargetTriple
block|;
comment|/// stackAlignment - The minimum alignment known to hold of the stack frame on
comment|/// entry to the function and which must be maintained by every function.
name|unsigned
name|StackAlignment
block|;
comment|/// Selected instruction itineraries (one entry per itinerary class.)
name|InstrItineraryData
name|InstrItins
block|;
comment|/// Which cpu directive was used.
name|unsigned
name|DarwinDirective
block|;
comment|/// Used by the ISel to turn in optimizations for POWER4-derived architectures
name|bool
name|HasMFOCRF
block|;
name|bool
name|Has64BitSupport
block|;
name|bool
name|Use64BitRegs
block|;
name|bool
name|UseCRBits
block|;
name|bool
name|HasHardFloat
block|;
name|bool
name|IsPPC64
block|;
name|bool
name|HasAltivec
block|;
name|bool
name|HasSPE
block|;
name|bool
name|HasQPX
block|;
name|bool
name|HasVSX
block|;
name|bool
name|HasP8Vector
block|;
name|bool
name|HasP8Altivec
block|;
name|bool
name|HasP8Crypto
block|;
name|bool
name|HasP9Vector
block|;
name|bool
name|HasP9Altivec
block|;
name|bool
name|HasFCPSGN
block|;
name|bool
name|HasFSQRT
block|;
name|bool
name|HasFRE
block|,
name|HasFRES
block|,
name|HasFRSQRTE
block|,
name|HasFRSQRTES
block|;
name|bool
name|HasRecipPrec
block|;
name|bool
name|HasSTFIWX
block|;
name|bool
name|HasLFIWAX
block|;
name|bool
name|HasFPRND
block|;
name|bool
name|HasFPCVT
block|;
name|bool
name|HasISEL
block|;
name|bool
name|HasBPERMD
block|;
name|bool
name|HasExtDiv
block|;
name|bool
name|HasCMPB
block|;
name|bool
name|HasLDBRX
block|;
name|bool
name|IsBookE
block|;
name|bool
name|HasOnlyMSYNC
block|;
name|bool
name|IsE500
block|;
name|bool
name|IsPPC4xx
block|;
name|bool
name|IsPPC6xx
block|;
name|bool
name|FeatureMFTB
block|;
name|bool
name|DeprecatedDST
block|;
name|bool
name|HasLazyResolverStubs
block|;
name|bool
name|IsLittleEndian
block|;
name|bool
name|HasICBT
block|;
name|bool
name|HasInvariantFunctionDescriptors
block|;
name|bool
name|HasPartwordAtomics
block|;
name|bool
name|HasDirectMove
block|;
name|bool
name|HasHTM
block|;
name|bool
name|HasFusion
block|;
name|bool
name|HasFloat128
block|;
name|bool
name|IsISA3_0
block|;
name|bool
name|UseLongCalls
block|;
name|POPCNTDKind
name|HasPOPCNTD
block|;
comment|/// When targeting QPX running a stock PPC64 Linux kernel where the stack
comment|/// alignment has not been changed, we need to keep the 16-byte alignment
comment|/// of the stack.
name|bool
name|IsQPXStackUnaligned
block|;
specifier|const
name|PPCTargetMachine
operator|&
name|TM
block|;
name|PPCFrameLowering
name|FrameLowering
block|;
name|PPCInstrInfo
name|InstrInfo
block|;
name|PPCTargetLowering
name|TLInfo
block|;
name|SelectionDAGTargetInfo
name|TSInfo
block|;
name|public
operator|:
comment|/// This constructor initializes the data members to match that
comment|/// of the specified triple.
comment|///
name|PPCSubtarget
argument_list|(
specifier|const
name|Triple
operator|&
name|TT
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|CPU
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|FS
argument_list|,
specifier|const
name|PPCTargetMachine
operator|&
name|TM
argument_list|)
block|;
comment|/// ParseSubtargetFeatures - Parses features string setting specified
comment|/// subtarget options.  Definition of function is auto generated by tblgen.
name|void
name|ParseSubtargetFeatures
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|)
block|;
comment|/// getStackAlignment - Returns the minimum alignment known to hold of the
comment|/// stack frame on entry to the function and which must be maintained by every
comment|/// function for this subtarget.
name|unsigned
name|getStackAlignment
argument_list|()
specifier|const
block|{
return|return
name|StackAlignment
return|;
block|}
comment|/// getDarwinDirective - Returns the -m directive specified for the cpu.
comment|///
name|unsigned
name|getDarwinDirective
argument_list|()
specifier|const
block|{
return|return
name|DarwinDirective
return|;
block|}
comment|/// getInstrItins - Return the instruction itineraries based on subtarget
comment|/// selection.
specifier|const
name|InstrItineraryData
operator|*
name|getInstrItineraryData
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|InstrItins
return|;
block|}
specifier|const
name|PPCFrameLowering
operator|*
name|getFrameLowering
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|FrameLowering
return|;
block|}
specifier|const
name|PPCInstrInfo
operator|*
name|getInstrInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|InstrInfo
return|;
block|}
specifier|const
name|PPCTargetLowering
operator|*
name|getTargetLowering
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|TLInfo
return|;
block|}
specifier|const
name|SelectionDAGTargetInfo
operator|*
name|getSelectionDAGInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|TSInfo
return|;
block|}
specifier|const
name|PPCRegisterInfo
operator|*
name|getRegisterInfo
argument_list|()
specifier|const
name|override
block|{
return|return
operator|&
name|getInstrInfo
argument_list|()
operator|->
name|getRegisterInfo
argument_list|()
return|;
block|}
specifier|const
name|PPCTargetMachine
operator|&
name|getTargetMachine
argument_list|()
specifier|const
block|{
return|return
name|TM
return|;
block|}
comment|/// initializeSubtargetDependencies - Initializes using a CPU and feature string
comment|/// so that we can use initializer lists for subtarget initialization.
name|PPCSubtarget
operator|&
name|initializeSubtargetDependencies
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|)
block|;
name|private
operator|:
name|void
name|initializeEnvironment
argument_list|()
block|;
name|void
name|initSubtargetFeatures
argument_list|(
argument|StringRef CPU
argument_list|,
argument|StringRef FS
argument_list|)
block|;
name|public
operator|:
comment|/// isPPC64 - Return true if we are generating code for 64-bit pointer mode.
comment|///
name|bool
name|isPPC64
argument_list|()
specifier|const
block|;
comment|/// has64BitSupport - Return true if the selected CPU supports 64-bit
comment|/// instructions, regardless of whether we are in 32-bit or 64-bit mode.
name|bool
name|has64BitSupport
argument_list|()
specifier|const
block|{
return|return
name|Has64BitSupport
return|;
block|}
comment|// useSoftFloat - Return true if soft-float option is turned on.
name|bool
name|useSoftFloat
argument_list|()
specifier|const
block|{
return|return
operator|!
name|HasHardFloat
return|;
block|}
comment|/// use64BitRegs - Return true if in 64-bit mode or if we should use 64-bit
comment|/// registers in 32-bit mode when possible.  This can only true if
comment|/// has64BitSupport() returns true.
name|bool
name|use64BitRegs
argument_list|()
specifier|const
block|{
return|return
name|Use64BitRegs
return|;
block|}
comment|/// useCRBits - Return true if we should store and manipulate i1 values in
comment|/// the individual condition register bits.
name|bool
name|useCRBits
argument_list|()
specifier|const
block|{
return|return
name|UseCRBits
return|;
block|}
comment|/// hasLazyResolverStub - Return true if accesses to the specified global have
comment|/// to go through a dyld lazy resolution stub.  This means that an extra load
comment|/// is required to get the address of the global.
name|bool
name|hasLazyResolverStub
argument_list|(
argument|const GlobalValue *GV
argument_list|)
specifier|const
block|;
comment|// isLittleEndian - True if generating little-endian code
name|bool
name|isLittleEndian
argument_list|()
specifier|const
block|{
return|return
name|IsLittleEndian
return|;
block|}
comment|// Specific obvious features.
name|bool
name|hasFCPSGN
argument_list|()
specifier|const
block|{
return|return
name|HasFCPSGN
return|;
block|}
name|bool
name|hasFSQRT
argument_list|()
specifier|const
block|{
return|return
name|HasFSQRT
return|;
block|}
name|bool
name|hasFRE
argument_list|()
specifier|const
block|{
return|return
name|HasFRE
return|;
block|}
name|bool
name|hasFRES
argument_list|()
specifier|const
block|{
return|return
name|HasFRES
return|;
block|}
name|bool
name|hasFRSQRTE
argument_list|()
specifier|const
block|{
return|return
name|HasFRSQRTE
return|;
block|}
name|bool
name|hasFRSQRTES
argument_list|()
specifier|const
block|{
return|return
name|HasFRSQRTES
return|;
block|}
name|bool
name|hasRecipPrec
argument_list|()
specifier|const
block|{
return|return
name|HasRecipPrec
return|;
block|}
name|bool
name|hasSTFIWX
argument_list|()
specifier|const
block|{
return|return
name|HasSTFIWX
return|;
block|}
name|bool
name|hasLFIWAX
argument_list|()
specifier|const
block|{
return|return
name|HasLFIWAX
return|;
block|}
name|bool
name|hasFPRND
argument_list|()
specifier|const
block|{
return|return
name|HasFPRND
return|;
block|}
name|bool
name|hasFPCVT
argument_list|()
specifier|const
block|{
return|return
name|HasFPCVT
return|;
block|}
name|bool
name|hasAltivec
argument_list|()
specifier|const
block|{
return|return
name|HasAltivec
return|;
block|}
name|bool
name|hasSPE
argument_list|()
specifier|const
block|{
return|return
name|HasSPE
return|;
block|}
name|bool
name|hasQPX
argument_list|()
specifier|const
block|{
return|return
name|HasQPX
return|;
block|}
name|bool
name|hasVSX
argument_list|()
specifier|const
block|{
return|return
name|HasVSX
return|;
block|}
name|bool
name|hasP8Vector
argument_list|()
specifier|const
block|{
return|return
name|HasP8Vector
return|;
block|}
name|bool
name|hasP8Altivec
argument_list|()
specifier|const
block|{
return|return
name|HasP8Altivec
return|;
block|}
name|bool
name|hasP8Crypto
argument_list|()
specifier|const
block|{
return|return
name|HasP8Crypto
return|;
block|}
name|bool
name|hasP9Vector
argument_list|()
specifier|const
block|{
return|return
name|HasP9Vector
return|;
block|}
name|bool
name|hasP9Altivec
argument_list|()
specifier|const
block|{
return|return
name|HasP9Altivec
return|;
block|}
name|bool
name|hasMFOCRF
argument_list|()
specifier|const
block|{
return|return
name|HasMFOCRF
return|;
block|}
name|bool
name|hasISEL
argument_list|()
specifier|const
block|{
return|return
name|HasISEL
return|;
block|}
name|bool
name|hasBPERMD
argument_list|()
specifier|const
block|{
return|return
name|HasBPERMD
return|;
block|}
name|bool
name|hasExtDiv
argument_list|()
specifier|const
block|{
return|return
name|HasExtDiv
return|;
block|}
name|bool
name|hasCMPB
argument_list|()
specifier|const
block|{
return|return
name|HasCMPB
return|;
block|}
name|bool
name|hasLDBRX
argument_list|()
specifier|const
block|{
return|return
name|HasLDBRX
return|;
block|}
name|bool
name|isBookE
argument_list|()
specifier|const
block|{
return|return
name|IsBookE
return|;
block|}
name|bool
name|hasOnlyMSYNC
argument_list|()
specifier|const
block|{
return|return
name|HasOnlyMSYNC
return|;
block|}
name|bool
name|isPPC4xx
argument_list|()
specifier|const
block|{
return|return
name|IsPPC4xx
return|;
block|}
name|bool
name|isPPC6xx
argument_list|()
specifier|const
block|{
return|return
name|IsPPC6xx
return|;
block|}
name|bool
name|isE500
argument_list|()
specifier|const
block|{
return|return
name|IsE500
return|;
block|}
name|bool
name|isFeatureMFTB
argument_list|()
specifier|const
block|{
return|return
name|FeatureMFTB
return|;
block|}
name|bool
name|isDeprecatedDST
argument_list|()
specifier|const
block|{
return|return
name|DeprecatedDST
return|;
block|}
name|bool
name|hasICBT
argument_list|()
specifier|const
block|{
return|return
name|HasICBT
return|;
block|}
name|bool
name|hasInvariantFunctionDescriptors
argument_list|()
specifier|const
block|{
return|return
name|HasInvariantFunctionDescriptors
return|;
block|}
name|bool
name|hasPartwordAtomics
argument_list|()
specifier|const
block|{
return|return
name|HasPartwordAtomics
return|;
block|}
name|bool
name|hasDirectMove
argument_list|()
specifier|const
block|{
return|return
name|HasDirectMove
return|;
block|}
name|bool
name|isQPXStackUnaligned
argument_list|()
specifier|const
block|{
return|return
name|IsQPXStackUnaligned
return|;
block|}
name|unsigned
name|getPlatformStackAlignment
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|(
name|hasQPX
argument_list|()
operator|||
name|isBGQ
argument_list|()
operator|)
operator|&&
operator|!
name|isQPXStackUnaligned
argument_list|()
condition|)
return|return
literal|32
return|;
return|return
literal|16
return|;
block|}
comment|// DarwinABI has a 224-byte red zone. PPC32 SVR4ABI(Non-DarwinABI) has no
comment|// red zone and PPC64 SVR4ABI has a 288-byte red zone.
name|unsigned
name|getRedZoneSize
argument_list|()
specifier|const
block|{
return|return
name|isDarwinABI
argument_list|()
operator|?
literal|224
operator|:
operator|(
name|isPPC64
argument_list|()
operator|?
literal|288
operator|:
literal|0
operator|)
return|;
block|}
name|bool
name|hasHTM
argument_list|()
specifier|const
block|{
return|return
name|HasHTM
return|;
block|}
name|bool
name|hasFusion
argument_list|()
specifier|const
block|{
return|return
name|HasFusion
return|;
block|}
name|bool
name|hasFloat128
argument_list|()
specifier|const
block|{
return|return
name|HasFloat128
return|;
block|}
name|bool
name|isISA3_0
argument_list|()
specifier|const
block|{
return|return
name|IsISA3_0
return|;
block|}
name|bool
name|useLongCalls
argument_list|()
specifier|const
block|{
return|return
name|UseLongCalls
return|;
block|}
name|bool
name|needsSwapsForVSXMemOps
argument_list|()
specifier|const
block|{
return|return
name|hasVSX
argument_list|()
operator|&&
name|isLittleEndian
argument_list|()
operator|&&
operator|!
name|hasP9Vector
argument_list|()
return|;
block|}
name|POPCNTDKind
name|hasPOPCNTD
argument_list|()
specifier|const
block|{
return|return
name|HasPOPCNTD
return|;
block|}
specifier|const
name|Triple
operator|&
name|getTargetTriple
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
return|;
block|}
comment|/// isDarwin - True if this is any darwin platform.
name|bool
name|isDarwin
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isMacOSX
argument_list|()
return|;
block|}
comment|/// isBGQ - True if this is a BG/Q platform.
name|bool
name|isBGQ
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|getVendor
argument_list|()
operator|==
name|Triple
operator|::
name|BGQ
return|;
block|}
name|bool
name|isTargetELF
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSBinFormatELF
argument_list|()
return|;
block|}
name|bool
name|isTargetMachO
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSBinFormatMachO
argument_list|()
return|;
block|}
name|bool
name|isTargetLinux
argument_list|()
specifier|const
block|{
return|return
name|TargetTriple
operator|.
name|isOSLinux
argument_list|()
return|;
block|}
name|bool
name|isDarwinABI
argument_list|()
specifier|const
block|{
return|return
name|isTargetMachO
argument_list|()
operator|||
name|isDarwin
argument_list|()
return|;
block|}
name|bool
name|isSVR4ABI
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isDarwinABI
argument_list|()
return|;
block|}
name|bool
name|isELFv2ABI
argument_list|()
specifier|const
expr_stmt|;
comment|/// Originally, this function return hasISEL(). Now we always enable it,
comment|/// but may expand the ISEL instruction later.
name|bool
name|enableEarlyIfConversion
argument_list|()
specifier|const
name|override
block|{
return|return
name|true
return|;
block|}
comment|// Scheduling customization.
name|bool
name|enableMachineScheduler
argument_list|()
specifier|const
name|override
expr_stmt|;
comment|// This overrides the PostRAScheduler bit in the SchedModel for each CPU.
name|bool
name|enablePostRAScheduler
argument_list|()
specifier|const
name|override
expr_stmt|;
name|AntiDepBreakMode
name|getAntiDepBreakMode
argument_list|()
specifier|const
name|override
expr_stmt|;
name|void
name|getCriticalPathRCs
argument_list|(
name|RegClassVector
operator|&
name|CriticalPathRCs
argument_list|)
decl|const
name|override
decl_stmt|;
name|void
name|overrideSchedPolicy
argument_list|(
name|MachineSchedPolicy
operator|&
name|Policy
argument_list|,
name|unsigned
name|NumRegionInstrs
argument_list|)
decl|const
name|override
decl_stmt|;
name|bool
name|useAA
argument_list|()
specifier|const
name|override
expr_stmt|;
name|bool
name|enableSubRegLiveness
argument_list|()
specifier|const
name|override
expr_stmt|;
comment|/// classifyGlobalReference - Classify a global variable reference for the
comment|/// current subtarget accourding to how we should reference it.
name|unsigned
name|char
name|classifyGlobalReference
argument_list|(
specifier|const
name|GlobalValue
operator|*
name|GV
argument_list|)
decl|const
decl_stmt|;
name|bool
name|isXRaySupported
argument_list|()
specifier|const
name|override
block|{
return|return
name|IsPPC64
operator|&&
name|IsLittleEndian
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

