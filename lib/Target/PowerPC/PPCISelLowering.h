begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- PPCISelLowering.h - PPC32 DAG Lowering Interface --------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines the interfaces that PPC uses to lower LLVM code into a
end_comment

begin_comment
comment|// selection DAG.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TARGET_POWERPC_PPC32ISELLOWERING_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TARGET_POWERPC_PPC32ISELLOWERING_H
end_define

begin_include
include|#
directive|include
file|"llvm/Target/TargetLowering.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAG.h"
end_include

begin_include
include|#
directive|include
file|"PPC.h"
end_include

begin_include
include|#
directive|include
file|"PPCSubtarget.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|PPCISD
block|{
enum|enum
name|NodeType
block|{
comment|// Start the numbering where the builtin ops and target ops leave off.
name|FIRST_NUMBER
init|=
name|ISD
operator|::
name|BUILTIN_OP_END
block|,
comment|/// FSEL - Traditional three-operand fsel node.
comment|///
name|FSEL
block|,
comment|/// FCFID - The FCFID instruction, taking an f64 operand and producing
comment|/// and f64 value containing the FP representation of the integer that
comment|/// was temporarily in the f64 operand.
name|FCFID
block|,
comment|/// FCTI[D,W]Z - The FCTIDZ and FCTIWZ instructions, taking an f32 or f64
comment|/// operand, producing an f64 value containing the integer representation
comment|/// of that FP value.
name|FCTIDZ
block|,
name|FCTIWZ
block|,
comment|/// STFIWX - The STFIWX instruction.  The first operand is an input token
comment|/// chain, then an f64 value to store, then an address to store it to.
name|STFIWX
block|,
comment|// VMADDFP, VNMSUBFP - The VMADDFP and VNMSUBFP instructions, taking
comment|// three v4f32 operands and producing a v4f32 result.
name|VMADDFP
block|,
name|VNMSUBFP
block|,
comment|/// VPERM - The PPC VPERM Instruction.
comment|///
name|VPERM
block|,
comment|/// Hi/Lo - These represent the high and low 16-bit parts of a global
comment|/// address respectively.  These nodes have two operands, the first of
comment|/// which must be a TargetGlobalAddress, and the second of which must be a
comment|/// Constant.  Selected naively, these turn into 'lis G+C' and 'li G+C',
comment|/// though these are usually folded into other nodes.
name|Hi
block|,
name|Lo
block|,
name|TOC_ENTRY
block|,
comment|/// The following three target-specific nodes are used for calls through
comment|/// function pointers in the 64-bit SVR4 ABI.
comment|/// Restore the TOC from the TOC save area of the current stack frame.
comment|/// This is basically a hard coded load instruction which additionally
comment|/// takes/produces a flag.
name|TOC_RESTORE
block|,
comment|/// Like a regular LOAD but additionally taking/producing a flag.
name|LOAD
block|,
comment|/// LOAD into r2 (also taking/producing a flag). Like TOC_RESTORE, this is
comment|/// a hard coded load instruction.
name|LOAD_TOC
block|,
comment|/// OPRC, CHAIN = DYNALLOC(CHAIN, NEGSIZE, FRAME_INDEX)
comment|/// This instruction is lowered in PPCRegisterInfo::eliminateFrameIndex to
comment|/// compute an allocation on the stack.
name|DYNALLOC
block|,
comment|/// GlobalBaseReg - On Darwin, this node represents the result of the mflr
comment|/// at function entry, used for PIC code.
name|GlobalBaseReg
block|,
comment|/// These nodes represent the 32-bit PPC shifts that operate on 6-bit
comment|/// shift amounts.  These nodes are generated by the multi-precision shift
comment|/// code.
name|SRL
block|,
name|SRA
block|,
name|SHL
block|,
comment|/// EXTSW_32 - This is the EXTSW instruction for use with "32-bit"
comment|/// registers.
name|EXTSW_32
block|,
comment|/// CALL - A direct function call.
name|CALL_Darwin
block|,
name|CALL_SVR4
block|,
comment|/// NOP - Special NOP which follows 64-bit SVR4 calls.
name|NOP
block|,
comment|/// CHAIN,FLAG = MTCTR(VAL, CHAIN[, INFLAG]) - Directly corresponds to a
comment|/// MTCTR instruction.
name|MTCTR
block|,
comment|/// CHAIN,FLAG = BCTRL(CHAIN, INFLAG) - Directly corresponds to a
comment|/// BCTRL instruction.
name|BCTRL_Darwin
block|,
name|BCTRL_SVR4
block|,
comment|/// Return with a flag operand, matched by 'blr'
name|RET_FLAG
block|,
comment|/// R32 = MFCR(CRREG, INFLAG) - Represents the MFCR/MFOCRF instructions.
comment|/// This copies the bits corresponding to the specified CRREG into the
comment|/// resultant GPR.  Bits corresponding to other CR regs are undefined.
name|MFCR
block|,
comment|/// RESVEC = VCMP(LHS, RHS, OPC) - Represents one of the altivec VCMP*
comment|/// instructions.  For lack of better number, we use the opcode number
comment|/// encoding for the OPC field to identify the compare.  For example, 838
comment|/// is VCMPGTSH.
name|VCMP
block|,
comment|/// RESVEC, OUTFLAG = VCMPo(LHS, RHS, OPC) - Represents one of the
comment|/// altivec VCMP*o instructions.  For lack of better number, we use the
comment|/// opcode number encoding for the OPC field to identify the compare.  For
comment|/// example, 838 is VCMPGTSH.
name|VCMPo
block|,
comment|/// CHAIN = COND_BRANCH CHAIN, CRRC, OPC, DESTBB [, INFLAG] - This
comment|/// corresponds to the COND_BRANCH pseudo instruction.  CRRC is the
comment|/// condition register to branch on, OPC is the branch opcode to use (e.g.
comment|/// PPC::BLE), DESTBB is the destination block to branch to, and INFLAG is
comment|/// an optional input flag argument.
name|COND_BRANCH
block|,
comment|// The following 5 instructions are used only as part of the
comment|// long double-to-int conversion sequence.
comment|/// OUTFLAG = MFFS F8RC - This moves the FPSCR (not modelled) into the
comment|/// register.
name|MFFS
block|,
comment|/// OUTFLAG = MTFSB0 INFLAG - This clears a bit in the FPSCR.
name|MTFSB0
block|,
comment|/// OUTFLAG = MTFSB1 INFLAG - This sets a bit in the FPSCR.
name|MTFSB1
block|,
comment|/// F8RC, OUTFLAG = FADDRTZ F8RC, F8RC, INFLAG - This is an FADD done with
comment|/// rounding towards zero.  It has flags added so it won't move past the
comment|/// FPSCR-setting instructions.
name|FADDRTZ
block|,
comment|/// MTFSF = F8RC, INFLAG - This moves the register into the FPSCR.
name|MTFSF
block|,
comment|/// LARX = This corresponds to PPC l{w|d}arx instrcution: load and
comment|/// reserve indexed. This is used to implement atomic operations.
name|LARX
block|,
comment|/// STCX = This corresponds to PPC stcx. instrcution: store conditional
comment|/// indexed. This is used to implement atomic operations.
name|STCX
block|,
comment|/// TC_RETURN - A tail call return.
comment|///   operand #0 chain
comment|///   operand #1 callee (register or absolute)
comment|///   operand #2 stack adjustment
comment|///   operand #3 optional in flag
name|TC_RETURN
block|,
comment|/// STD_32 - This is the STD instruction for use with "32-bit" registers.
name|STD_32
init|=
name|ISD
operator|::
name|FIRST_TARGET_MEMORY_OPCODE
block|,
comment|/// CHAIN = STBRX CHAIN, GPRC, Ptr, Type - This is a
comment|/// byte-swapping store instruction.  It byte-swaps the low "Type" bits of
comment|/// the GPRC input, then stores it through Ptr.  Type can be either i16 or
comment|/// i32.
name|STBRX
block|,
comment|/// GPRC, CHAIN = LBRX CHAIN, Ptr, Type - This is a
comment|/// byte-swapping load instruction.  It loads "Type" bits, byte swaps it,
comment|/// then puts it in the bottom bits of the GPRC.  TYPE can be either i16
comment|/// or i32.
name|LBRX
block|}
enum|;
block|}
comment|/// Define some predicates that are used for node matching.
name|namespace
name|PPC
block|{
comment|/// isVPKUHUMShuffleMask - Return true if this is the shuffle mask for a
comment|/// VPKUHUM instruction.
name|bool
name|isVPKUHUMShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVPKUWUMShuffleMask - Return true if this is the shuffle mask for a
comment|/// VPKUWUM instruction.
name|bool
name|isVPKUWUMShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVMRGLShuffleMask - Return true if this is a shuffle mask suitable for
comment|/// a VRGL* instruction with the specified unit size (1,2 or 4 bytes).
name|bool
name|isVMRGLShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|UnitSize
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVMRGHShuffleMask - Return true if this is a shuffle mask suitable for
comment|/// a VRGH* instruction with the specified unit size (1,2 or 4 bytes).
name|bool
name|isVMRGHShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|UnitSize
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isVSLDOIShuffleMask - If this is a vsldoi shuffle mask, return the shift
comment|/// amount, otherwise return -1.
name|int
name|isVSLDOIShuffleMask
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|bool
name|isUnary
parameter_list|)
function_decl|;
comment|/// isSplatShuffleMask - Return true if the specified VECTOR_SHUFFLE operand
comment|/// specifies a splat of a single element that is suitable for input to
comment|/// VSPLTB/VSPLTH/VSPLTW.
name|bool
name|isSplatShuffleMask
parameter_list|(
name|ShuffleVectorSDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|EltSize
parameter_list|)
function_decl|;
comment|/// isAllNegativeZeroVector - Returns true if all elements of build_vector
comment|/// are -0.0.
name|bool
name|isAllNegativeZeroVector
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|)
function_decl|;
comment|/// getVSPLTImmediate - Return the appropriate VSPLT* immediate to splat the
comment|/// specified isSplatShuffleMask VECTOR_SHUFFLE mask.
name|unsigned
name|getVSPLTImmediate
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|EltSize
parameter_list|)
function_decl|;
comment|/// get_VSPLTI_elt - If this is a build_vector of constants which can be
comment|/// formed by using a vspltis[bhw] instruction of the specified element
comment|/// size, return the constant being splatted.  The ByteSize field indicates
comment|/// the number of bytes of each element [124] -> [bhw].
name|SDValue
name|get_VSPLTI_elt
parameter_list|(
name|SDNode
modifier|*
name|N
parameter_list|,
name|unsigned
name|ByteSize
parameter_list|,
name|SelectionDAG
modifier|&
name|DAG
parameter_list|)
function_decl|;
block|}
name|class
name|PPCTargetLowering
range|:
name|public
name|TargetLowering
block|{
name|int
name|VarArgsFrameIndex
block|;
comment|// FrameIndex for start of varargs area.
name|int
name|VarArgsStackOffset
block|;
comment|// StackOffset for start of stack
comment|// arguments.
name|unsigned
name|VarArgsNumGPR
block|;
comment|// Index of the first unused integer
comment|// register for parameter passing.
name|unsigned
name|VarArgsNumFPR
block|;
comment|// Index of the first unused double
comment|// register for parameter passing.
specifier|const
name|PPCSubtarget
operator|&
name|PPCSubTarget
block|;
name|public
operator|:
name|explicit
name|PPCTargetLowering
argument_list|(
name|PPCTargetMachine
operator|&
name|TM
argument_list|)
block|;
comment|/// getTargetNodeName() - This method returns the name of a target specific
comment|/// DAG node.
name|virtual
specifier|const
name|char
operator|*
name|getTargetNodeName
argument_list|(
argument|unsigned Opcode
argument_list|)
specifier|const
block|;
comment|/// getSetCCResultType - Return the ISD::SETCC ValueType
name|virtual
name|MVT
operator|::
name|SimpleValueType
name|getSetCCResultType
argument_list|(
argument|EVT VT
argument_list|)
specifier|const
block|;
comment|/// getPreIndexedAddressParts - returns true by value, base pointer and
comment|/// offset pointer and addressing mode by reference if the node's address
comment|/// can be legally represented as pre-indexed load / store address.
name|virtual
name|bool
name|getPreIndexedAddressParts
argument_list|(
argument|SDNode *N
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SDValue&Offset
argument_list|,
argument|ISD::MemIndexedMode&AM
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// SelectAddressRegReg - Given the specified addressed, check to see if it
comment|/// can be represented as an indexed [r+r] operation.  Returns false if it
comment|/// can be more efficiently represented with [r+imm].
name|bool
name|SelectAddressRegReg
argument_list|(
argument|SDValue N
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SDValue&Index
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// SelectAddressRegImm - Returns true if the address N can be represented
comment|/// by a base register plus a signed 16-bit displacement [r+imm], and if it
comment|/// is not better represented as reg+reg.
name|bool
name|SelectAddressRegImm
argument_list|(
argument|SDValue N
argument_list|,
argument|SDValue&Disp
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// SelectAddressRegRegOnly - Given the specified addressed, force it to be
comment|/// represented as an indexed [r+r] operation.
name|bool
name|SelectAddressRegRegOnly
argument_list|(
argument|SDValue N
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SDValue&Index
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// SelectAddressRegImmShift - Returns true if the address N can be
comment|/// represented by a base register plus a signed 14-bit displacement
comment|/// [r+imm*4].  Suitable for use by STD and friends.
name|bool
name|SelectAddressRegImmShift
argument_list|(
argument|SDValue N
argument_list|,
argument|SDValue&Disp
argument_list|,
argument|SDValue&Base
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// LowerOperation - Provide custom lowering hooks for some operations.
comment|///
name|virtual
name|SDValue
name|LowerOperation
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
comment|/// ReplaceNodeResults - Replace the results of node with an illegal result
comment|/// type with new values built out of custom code.
comment|///
name|virtual
name|void
name|ReplaceNodeResults
argument_list|(
name|SDNode
operator|*
name|N
argument_list|,
name|SmallVectorImpl
operator|<
name|SDValue
operator|>
operator|&
name|Results
argument_list|,
name|SelectionDAG
operator|&
name|DAG
argument_list|)
block|;
name|virtual
name|SDValue
name|PerformDAGCombine
argument_list|(
argument|SDNode *N
argument_list|,
argument|DAGCombinerInfo&DCI
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|computeMaskedBitsForTargetNode
argument_list|(
argument|const SDValue Op
argument_list|,
argument|const APInt&Mask
argument_list|,
argument|APInt&KnownZero
argument_list|,
argument|APInt&KnownOne
argument_list|,
argument|const SelectionDAG&DAG
argument_list|,
argument|unsigned Depth =
literal|0
argument_list|)
specifier|const
block|;
name|virtual
name|MachineBasicBlock
operator|*
name|EmitInstrWithCustomInserter
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|,
argument|DenseMap<MachineBasicBlock*
argument_list|,
argument|MachineBasicBlock*> *EM
argument_list|)
specifier|const
block|;
name|MachineBasicBlock
operator|*
name|EmitAtomicBinary
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|,
argument|bool is64Bit
argument_list|,
argument|unsigned BinOpcode
argument_list|)
specifier|const
block|;
name|MachineBasicBlock
operator|*
name|EmitPartwordAtomicBinary
argument_list|(
argument|MachineInstr *MI
argument_list|,
argument|MachineBasicBlock *MBB
argument_list|,
argument|bool is8bit
argument_list|,
argument|unsigned Opcode
argument_list|)
specifier|const
block|;
name|ConstraintType
name|getConstraintType
argument_list|(
argument|const std::string&Constraint
argument_list|)
specifier|const
block|;
name|std
operator|::
name|pair
operator|<
name|unsigned
block|,
specifier|const
name|TargetRegisterClass
operator|*
operator|>
name|getRegForInlineAsmConstraint
argument_list|(
argument|const std::string&Constraint
argument_list|,
argument|EVT VT
argument_list|)
specifier|const
block|;
comment|/// getByValTypeAlignment - Return the desired alignment for ByVal aggregate
comment|/// function arguments in the caller parameter area.  This is the actual
comment|/// alignment, not its logarithm.
name|unsigned
name|getByValTypeAlignment
argument_list|(
argument|const Type *Ty
argument_list|)
specifier|const
block|;
comment|/// LowerAsmOperandForConstraint - Lower the specified operand into the Ops
comment|/// vector.  If it is invalid, don't add anything to Ops. If hasMemory is
comment|/// true it means one of the asm constraint of the inline asm instruction
comment|/// being processed is 'm'.
name|virtual
name|void
name|LowerAsmOperandForConstraint
argument_list|(
argument|SDValue Op
argument_list|,
argument|char ConstraintLetter
argument_list|,
argument|bool hasMemory
argument_list|,
argument|std::vector<SDValue>&Ops
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// isLegalAddressingMode - Return true if the addressing mode represented
comment|/// by AM is legal for this target, for a load/store of the specified type.
name|virtual
name|bool
name|isLegalAddressingMode
argument_list|(
argument|const AddrMode&AM
argument_list|,
argument|const Type *Ty
argument_list|)
specifier|const
block|;
comment|/// isLegalAddressImmediate - Return true if the integer value can be used
comment|/// as the offset of the target addressing mode for load / store of the
comment|/// given type.
name|virtual
name|bool
name|isLegalAddressImmediate
argument_list|(
argument|int64_t V
argument_list|,
argument|const Type *Ty
argument_list|)
specifier|const
block|;
comment|/// isLegalAddressImmediate - Return true if the GlobalValue can be used as
comment|/// the offset of the target addressing mode.
name|virtual
name|bool
name|isLegalAddressImmediate
argument_list|(
argument|GlobalValue *GV
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|IsEligibleForTailCallOptimization
argument_list|(
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CalleeCC
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SelectionDAG& DAG
argument_list|)
specifier|const
block|;
name|virtual
name|bool
name|isOffsetFoldingLegal
argument_list|(
argument|const GlobalAddressSDNode *GA
argument_list|)
specifier|const
block|;
name|virtual
name|EVT
name|getOptimalMemOpType
argument_list|(
argument|uint64_t Size
argument_list|,
argument|unsigned Align
argument_list|,
argument|bool isSrcConst
argument_list|,
argument|bool isSrcStr
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
specifier|const
block|;
comment|/// getFunctionAlignment - Return the Log2 alignment of this function.
name|virtual
name|unsigned
name|getFunctionAlignment
argument_list|(
argument|const Function *F
argument_list|)
specifier|const
block|;
name|private
operator|:
name|SDValue
name|getFramePointerFrameIndex
argument_list|(
argument|SelectionDAG& DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|getReturnAddrFrameIndex
argument_list|(
argument|SelectionDAG& DAG
argument_list|)
specifier|const
block|;
name|SDValue
name|EmitTailCallLoadFPAndRetAddr
argument_list|(
argument|SelectionDAG& DAG
argument_list|,
argument|int SPDiff
argument_list|,
argument|SDValue Chain
argument_list|,
argument|SDValue&LROpOut
argument_list|,
argument|SDValue&FPOpOut
argument_list|,
argument|bool isDarwinABI
argument_list|,
argument|DebugLoc dl
argument_list|)
block|;
name|SDValue
name|LowerRETURNADDR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerFRAMEADDR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerConstantPool
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerBlockAddress
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerGlobalAddress
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerGlobalTLSAddress
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerJumpTable
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerSETCC
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerTRAMPOLINE
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerVASTART
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|int VarArgsFrameIndex
argument_list|,
argument|int VarArgsStackOffset
argument_list|,
argument|unsigned VarArgsNumGPR
argument_list|,
argument|unsigned VarArgsNumFPR
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
block|;
name|SDValue
name|LowerVAARG
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|int VarArgsFrameIndex
argument_list|,
argument|int VarArgsStackOffset
argument_list|,
argument|unsigned VarArgsNumGPR
argument_list|,
argument|unsigned VarArgsNumFPR
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
block|;
name|SDValue
name|LowerSTACKRESTORE
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
block|;
name|SDValue
name|LowerDYNAMIC_STACKALLOC
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|const PPCSubtarget&Subtarget
argument_list|)
block|;
name|SDValue
name|LowerSELECT_CC
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerFP_TO_INT
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|DebugLoc dl
argument_list|)
block|;
name|SDValue
name|LowerSINT_TO_FP
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerFLT_ROUNDS_
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerSHL_PARTS
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerSRL_PARTS
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerSRA_PARTS
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerBUILD_VECTOR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerVECTOR_SHUFFLE
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerINTRINSIC_WO_CHAIN
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerSCALAR_TO_VECTOR
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerMUL
argument_list|(
argument|SDValue Op
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerCallResult
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue InFlag
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;
name|SDValue
name|FinishCall
argument_list|(
argument|CallingConv::ID CallConv
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|bool isTailCall
argument_list|,
argument|bool isVarArg
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVector<std::pair<unsigned
argument_list|,
argument|SDValue>
argument_list|,
literal|8
argument|>&RegsToPass
argument_list|,
argument|SDValue InFlag
argument_list|,
argument|SDValue Chain
argument_list|,
argument|SDValue&Callee
argument_list|,
argument|int SPDiff
argument_list|,
argument|unsigned NumBytes
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;
name|virtual
name|SDValue
name|LowerFormalArguments
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;
name|virtual
name|SDValue
name|LowerCall
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|bool isTailCall
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;
name|virtual
name|SDValue
name|LowerReturn
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|)
block|;
name|SDValue
name|LowerFormalArguments_Darwin
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;
name|SDValue
name|LowerFormalArguments_SVR4
argument_list|(
argument|SDValue Chain
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;
name|SDValue
name|LowerCall_Darwin
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|bool isTailCall
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;
name|SDValue
name|LowerCall_SVR4
argument_list|(
argument|SDValue Chain
argument_list|,
argument|SDValue Callee
argument_list|,
argument|CallingConv::ID CallConv
argument_list|,
argument|bool isVarArg
argument_list|,
argument|bool isTailCall
argument_list|,
argument|const SmallVectorImpl<ISD::OutputArg>&Outs
argument_list|,
argument|const SmallVectorImpl<ISD::InputArg>&Ins
argument_list|,
argument|DebugLoc dl
argument_list|,
argument|SelectionDAG&DAG
argument_list|,
argument|SmallVectorImpl<SDValue>&InVals
argument_list|)
block|;   }
decl_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_TARGET_POWERPC_PPC32ISELLOWERING_H
end_comment

end_unit

