begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- ARMAddressingModes.h - ARM Addressing Modes --------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file contains the ARM addressing mode implementation stuff.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TARGET_ARM_ARMADDRESSINGMODES_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TARGET_ARM_ARMADDRESSINGMODES_H
end_define

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAGNodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// ARM_AM - ARM Addressing Mode Stuff
name|namespace
name|ARM_AM
block|{
enum|enum
name|ShiftOpc
block|{
name|no_shift
init|=
literal|0
block|,
name|asr
block|,
name|lsl
block|,
name|lsr
block|,
name|ror
block|,
name|rrx
block|}
enum|;
enum|enum
name|AddrOpc
block|{
name|add
init|=
literal|'+'
block|,
name|sub
init|=
literal|'-'
block|}
enum|;
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|getAddrOpcStr
parameter_list|(
name|AddrOpc
name|Op
parameter_list|)
block|{
return|return
name|Op
operator|==
name|sub
condition|?
literal|"-"
else|:
literal|""
return|;
block|}
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|getShiftOpcStr
parameter_list|(
name|ShiftOpc
name|Op
parameter_list|)
block|{
switch|switch
condition|(
name|Op
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown shift opc!"
argument_list|)
expr_stmt|;
case|case
name|ARM_AM
operator|::
name|asr
case|:
return|return
literal|"asr"
return|;
case|case
name|ARM_AM
operator|::
name|lsl
case|:
return|return
literal|"lsl"
return|;
case|case
name|ARM_AM
operator|::
name|lsr
case|:
return|return
literal|"lsr"
return|;
case|case
name|ARM_AM
operator|::
name|ror
case|:
return|return
literal|"ror"
return|;
case|case
name|ARM_AM
operator|::
name|rrx
case|:
return|return
literal|"rrx"
return|;
block|}
block|}
specifier|static
specifier|inline
name|ShiftOpc
name|getShiftOpcForNode
parameter_list|(
name|SDValue
name|N
parameter_list|)
block|{
switch|switch
condition|(
name|N
operator|.
name|getOpcode
argument_list|()
condition|)
block|{
default|default:
return|return
name|ARM_AM
operator|::
name|no_shift
return|;
case|case
name|ISD
operator|::
name|SHL
case|:
return|return
name|ARM_AM
operator|::
name|lsl
return|;
case|case
name|ISD
operator|::
name|SRL
case|:
return|return
name|ARM_AM
operator|::
name|lsr
return|;
case|case
name|ISD
operator|::
name|SRA
case|:
return|return
name|ARM_AM
operator|::
name|asr
return|;
case|case
name|ISD
operator|::
name|ROTR
case|:
return|return
name|ARM_AM
operator|::
name|ror
return|;
comment|//case ISD::ROTL:  // Only if imm -> turn into ROTR.
comment|// Can't handle RRX here, because it would require folding a flag into
comment|// the addressing mode.  :(  This causes us to miss certain things.
comment|//case ARMISD::RRX: return ARM_AM::rrx;
block|}
block|}
enum|enum
name|AMSubMode
block|{
name|bad_am_submode
init|=
literal|0
block|,
name|ia
block|,
name|ib
block|,
name|da
block|,
name|db
block|}
enum|;
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|getAMSubModeStr
parameter_list|(
name|AMSubMode
name|Mode
parameter_list|)
block|{
switch|switch
condition|(
name|Mode
condition|)
block|{
default|default:
name|assert
argument_list|(
literal|0
operator|&&
literal|"Unknown addressing sub-mode!"
argument_list|)
expr_stmt|;
case|case
name|ARM_AM
operator|::
name|ia
case|:
return|return
literal|"ia"
return|;
case|case
name|ARM_AM
operator|::
name|ib
case|:
return|return
literal|"ib"
return|;
case|case
name|ARM_AM
operator|::
name|da
case|:
return|return
literal|"da"
return|;
case|case
name|ARM_AM
operator|::
name|db
case|:
return|return
literal|"db"
return|;
block|}
block|}
comment|/// rotr32 - Rotate a 32-bit unsigned value right by a specified # bits.
comment|///
specifier|static
specifier|inline
name|unsigned
name|rotr32
parameter_list|(
name|unsigned
name|Val
parameter_list|,
name|unsigned
name|Amt
parameter_list|)
block|{
name|assert
argument_list|(
name|Amt
operator|<
literal|32
operator|&&
literal|"Invalid rotate amount"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Val
operator|>>
name|Amt
operator|)
operator||
operator|(
name|Val
operator|<<
operator|(
operator|(
literal|32
operator|-
name|Amt
operator|)
operator|&
literal|31
operator|)
operator|)
return|;
block|}
comment|/// rotl32 - Rotate a 32-bit unsigned value left by a specified # bits.
comment|///
specifier|static
specifier|inline
name|unsigned
name|rotl32
parameter_list|(
name|unsigned
name|Val
parameter_list|,
name|unsigned
name|Amt
parameter_list|)
block|{
name|assert
argument_list|(
name|Amt
operator|<
literal|32
operator|&&
literal|"Invalid rotate amount"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Val
operator|<<
name|Amt
operator|)
operator||
operator|(
name|Val
operator|>>
operator|(
operator|(
literal|32
operator|-
name|Amt
operator|)
operator|&
literal|31
operator|)
operator|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #1: shift_operand with registers
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This 'addressing mode' is used for arithmetic instructions.  It can
comment|// represent things like:
comment|//   reg
comment|//   reg [asr|lsl|lsr|ror|rrx] reg
comment|//   reg [asr|lsl|lsr|ror|rrx] imm
comment|//
comment|// This is stored three operands [rega, regb, opc].  The first is the base
comment|// reg, the second is the shift amount (or reg0 if not present or imm).  The
comment|// third operand encodes the shift opcode and the imm if a reg isn't present.
comment|//
specifier|static
specifier|inline
name|unsigned
name|getSORegOpc
parameter_list|(
name|ShiftOpc
name|ShOp
parameter_list|,
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
name|ShOp
operator||
operator|(
name|Imm
operator|<<
literal|3
operator|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getSORegOffset
parameter_list|(
name|unsigned
name|Op
parameter_list|)
block|{
return|return
name|Op
operator|>>
literal|3
return|;
block|}
specifier|static
specifier|inline
name|ShiftOpc
name|getSORegShOp
parameter_list|(
name|unsigned
name|Op
parameter_list|)
block|{
return|return
call|(
name|ShiftOpc
call|)
argument_list|(
name|Op
operator|&
literal|7
argument_list|)
return|;
block|}
comment|/// getSOImmValImm - Given an encoded imm field for the reg/imm form, return
comment|/// the 8-bit imm value.
specifier|static
specifier|inline
name|unsigned
name|getSOImmValImm
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
name|Imm
operator|&
literal|0xFF
return|;
block|}
comment|/// getSOImmValRot - Given an encoded imm field for the reg/imm form, return
comment|/// the rotate amount.
specifier|static
specifier|inline
name|unsigned
name|getSOImmValRot
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
return|return
operator|(
name|Imm
operator|>>
literal|8
operator|)
operator|*
literal|2
return|;
block|}
comment|/// getSOImmValRotate - Try to handle Imm with an immediate shifter operand,
comment|/// computing the rotate amount to use.  If this immediate value cannot be
comment|/// handled with a single shifter-op, determine a good rotate amount that will
comment|/// take a maximal chunk of bits out of the immediate.
specifier|static
specifier|inline
name|unsigned
name|getSOImmValRotate
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// 8-bit (or less) immediates are trivially shifter_operands with a rotate
comment|// of zero.
if|if
condition|(
operator|(
name|Imm
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the rotate amount.
name|unsigned
name|TZ
init|=
name|CountTrailingZeros_32
argument_list|(
name|Imm
argument_list|)
decl_stmt|;
comment|// Rotate amount must be even.  Something like 0x200 must be rotated 8 bits,
comment|// not 9.
name|unsigned
name|RotAmt
init|=
name|TZ
operator|&
operator|~
literal|1
decl_stmt|;
comment|// If we can handle this spread, return it.
if|if
condition|(
operator|(
name|rotr32
argument_list|(
name|Imm
argument_list|,
name|RotAmt
argument_list|)
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|32
operator|-
name|RotAmt
operator|)
operator|&
literal|31
return|;
comment|// HW rotates right, not left.
comment|// For values like 0xF000000F, we should ignore the low 6 bits, then
comment|// retry the hunt.
if|if
condition|(
name|Imm
operator|&
literal|63U
condition|)
block|{
name|unsigned
name|TZ2
init|=
name|CountTrailingZeros_32
argument_list|(
name|Imm
operator|&
operator|~
literal|63U
argument_list|)
decl_stmt|;
name|unsigned
name|RotAmt2
init|=
name|TZ2
operator|&
operator|~
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|rotr32
argument_list|(
name|Imm
argument_list|,
name|RotAmt2
argument_list|)
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|32
operator|-
name|RotAmt2
operator|)
operator|&
literal|31
return|;
comment|// HW rotates right, not left.
block|}
comment|// Otherwise, we have no way to cover this span of bits with a single
comment|// shifter_op immediate.  Return a chunk of bits that will be useful to
comment|// handle.
return|return
operator|(
literal|32
operator|-
name|RotAmt
operator|)
operator|&
literal|31
return|;
comment|// HW rotates right, not left.
block|}
comment|/// getSOImmVal - Given a 32-bit immediate, if it is something that can fit
comment|/// into an shifter_operand immediate operand, return the 12-bit encoding for
comment|/// it.  If not, return -1.
specifier|static
specifier|inline
name|int
name|getSOImmVal
parameter_list|(
name|unsigned
name|Arg
parameter_list|)
block|{
comment|// 8-bit (or less) immediates are trivially shifter_operands with a rotate
comment|// of zero.
if|if
condition|(
operator|(
name|Arg
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
name|Arg
return|;
name|unsigned
name|RotAmt
init|=
name|getSOImmValRotate
argument_list|(
name|Arg
argument_list|)
decl_stmt|;
comment|// If this cannot be handled with a single shifter_op, bail out.
if|if
condition|(
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|RotAmt
argument_list|)
operator|&
name|Arg
condition|)
return|return
operator|-
literal|1
return|;
comment|// Encode this correctly.
return|return
name|rotl32
argument_list|(
name|Arg
argument_list|,
name|RotAmt
argument_list|)
operator||
operator|(
operator|(
name|RotAmt
operator|>>
literal|1
operator|)
operator|<<
literal|8
operator|)
return|;
block|}
comment|/// isSOImmTwoPartVal - Return true if the specified value can be obtained by
comment|/// or'ing together two SOImmVal's.
specifier|static
specifier|inline
name|bool
name|isSOImmTwoPartVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// If this can be handled with a single shifter_op, bail out.
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
if|if
condition|(
name|V
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|// If this can be handled with two shifter_op's, accept.
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
return|return
name|V
operator|==
literal|0
return|;
block|}
comment|/// getSOImmTwoPartFirst - If V is a value that satisfies isSOImmTwoPartVal,
comment|/// return the first chunk of it.
specifier|static
specifier|inline
name|unsigned
name|getSOImmTwoPartFirst
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
return|return
name|rotr32
argument_list|(
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
return|;
block|}
comment|/// getSOImmTwoPartSecond - If V is a value that satisfies isSOImmTwoPartVal,
comment|/// return the second chunk of it.
specifier|static
specifier|inline
name|unsigned
name|getSOImmTwoPartSecond
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// Mask out the first hunk.
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
comment|// Take what's left.
name|assert
argument_list|(
name|V
operator|==
operator|(
name|rotr32
argument_list|(
literal|255U
argument_list|,
name|getSOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
operator|)
argument_list|)
expr_stmt|;
return|return
name|V
return|;
block|}
comment|/// getThumbImmValShift - Try to handle Imm with a 8-bit immediate followed
comment|/// by a left shift. Returns the shift amount to use.
specifier|static
specifier|inline
name|unsigned
name|getThumbImmValShift
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// 8-bit (or less) immediates are trivially immediate operand with a shift
comment|// of zero.
if|if
condition|(
operator|(
name|Imm
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the shift amount.
return|return
name|CountTrailingZeros_32
argument_list|(
name|Imm
argument_list|)
return|;
block|}
comment|/// isThumbImmShiftedVal - Return true if the specified value can be obtained
comment|/// by left shifting a 8-bit immediate.
specifier|static
specifier|inline
name|bool
name|isThumbImmShiftedVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// If this can be handled with
name|V
operator|=
operator|(
operator|~
literal|255U
operator|<<
name|getThumbImmValShift
argument_list|(
name|V
argument_list|)
operator|)
operator|&
name|V
expr_stmt|;
return|return
name|V
operator|==
literal|0
return|;
block|}
comment|/// getThumbImm16ValShift - Try to handle Imm with a 16-bit immediate followed
comment|/// by a left shift. Returns the shift amount to use.
specifier|static
specifier|inline
name|unsigned
name|getThumbImm16ValShift
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// 16-bit (or less) immediates are trivially immediate operand with a shift
comment|// of zero.
if|if
condition|(
operator|(
name|Imm
operator|&
operator|~
literal|65535U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the shift amount.
return|return
name|CountTrailingZeros_32
argument_list|(
name|Imm
argument_list|)
return|;
block|}
comment|/// isThumbImm16ShiftedVal - Return true if the specified value can be
comment|/// obtained by left shifting a 16-bit immediate.
specifier|static
specifier|inline
name|bool
name|isThumbImm16ShiftedVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
comment|// If this can be handled with
name|V
operator|=
operator|(
operator|~
literal|65535U
operator|<<
name|getThumbImm16ValShift
argument_list|(
name|V
argument_list|)
operator|)
operator|&
name|V
expr_stmt|;
return|return
name|V
operator|==
literal|0
return|;
block|}
comment|/// getThumbImmNonShiftedVal - If V is a value that satisfies
comment|/// isThumbImmShiftedVal, return the non-shiftd value.
specifier|static
specifier|inline
name|unsigned
name|getThumbImmNonShiftedVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
return|return
name|V
operator|>>
name|getThumbImmValShift
argument_list|(
name|V
argument_list|)
return|;
block|}
comment|/// getT2SOImmValSplat - Return the 12-bit encoded representation
comment|/// if the specified value can be obtained by splatting the low 8 bits
comment|/// into every other byte or every byte of a 32-bit value. i.e.,
comment|///     00000000 00000000 00000000 abcdefgh    control = 0
comment|///     00000000 abcdefgh 00000000 abcdefgh    control = 1
comment|///     abcdefgh 00000000 abcdefgh 00000000    control = 2
comment|///     abcdefgh abcdefgh abcdefgh abcdefgh    control = 3
comment|/// Return -1 if none of the above apply.
comment|/// See ARM Reference Manual A6.3.2.
specifier|static
specifier|inline
name|int
name|getT2SOImmValSplatVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
name|unsigned
name|u
decl_stmt|,
name|Vs
decl_stmt|,
name|Imm
decl_stmt|;
comment|// control = 0
if|if
condition|(
operator|(
name|V
operator|&
literal|0xffffff00
operator|)
operator|==
literal|0
condition|)
return|return
name|V
return|;
comment|// If the value is zeroes in the first byte, just shift those off
name|Vs
operator|=
operator|(
operator|(
name|V
operator|&
literal|0xff
operator|)
operator|==
literal|0
operator|)
condition|?
name|V
operator|>>
literal|8
else|:
name|V
expr_stmt|;
comment|// Any passing value only has 8 bits of payload, splatted across the word
name|Imm
operator|=
name|Vs
operator|&
literal|0xff
expr_stmt|;
comment|// Likewise, any passing values have the payload splatted into the 3rd byte
name|u
operator|=
name|Imm
operator||
operator|(
name|Imm
operator|<<
literal|16
operator|)
expr_stmt|;
comment|// control = 1 or 2
if|if
condition|(
name|Vs
operator|==
name|u
condition|)
return|return
operator|(
operator|(
operator|(
name|Vs
operator|==
name|V
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
operator|<<
literal|8
operator|)
operator||
name|Imm
return|;
comment|// control = 3
if|if
condition|(
name|Vs
operator|==
operator|(
name|u
operator||
operator|(
name|u
operator|<<
literal|8
operator|)
operator|)
condition|)
return|return
operator|(
literal|3
operator|<<
literal|8
operator|)
operator||
name|Imm
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/// getT2SOImmValRotateVal - Return the 12-bit encoded representation if the
comment|/// specified value is a rotated 8-bit value. Return -1 if no rotation
comment|/// encoding is possible.
comment|/// See ARM Reference Manual A6.3.2.
specifier|static
specifier|inline
name|int
name|getT2SOImmValRotateVal
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
name|unsigned
name|RotAmt
init|=
name|CountLeadingZeros_32
argument_list|(
name|V
argument_list|)
decl_stmt|;
if|if
condition|(
name|RotAmt
operator|>=
literal|24
condition|)
return|return
operator|-
literal|1
return|;
comment|// If 'Arg' can be handled with a single shifter_op return the value.
if|if
condition|(
operator|(
name|rotr32
argument_list|(
literal|0xff000000U
argument_list|,
name|RotAmt
argument_list|)
operator|&
name|V
operator|)
operator|==
name|V
condition|)
return|return
operator|(
name|rotr32
argument_list|(
name|V
argument_list|,
literal|24
operator|-
name|RotAmt
argument_list|)
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|RotAmt
operator|+
literal|8
operator|)
operator|<<
literal|7
operator|)
return|;
return|return
operator|-
literal|1
return|;
block|}
comment|/// getT2SOImmVal - Given a 32-bit immediate, if it is something that can fit
comment|/// into a Thumb-2 shifter_operand immediate operand, return the 12-bit
comment|/// encoding for it.  If not, return -1.
comment|/// See ARM Reference Manual A6.3.2.
specifier|static
specifier|inline
name|int
name|getT2SOImmVal
parameter_list|(
name|unsigned
name|Arg
parameter_list|)
block|{
comment|// If 'Arg' is an 8-bit splat, then get the encoded value.
name|int
name|Splat
init|=
name|getT2SOImmValSplatVal
argument_list|(
name|Arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|Splat
operator|!=
operator|-
literal|1
condition|)
return|return
name|Splat
return|;
comment|// If 'Arg' can be handled with a single shifter_op return the value.
name|int
name|Rot
init|=
name|getT2SOImmValRotateVal
argument_list|(
name|Arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|Rot
operator|!=
operator|-
literal|1
condition|)
return|return
name|Rot
return|;
return|return
operator|-
literal|1
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getT2SOImmValRotate
parameter_list|(
name|unsigned
name|V
parameter_list|)
block|{
if|if
condition|(
operator|(
name|V
operator|&
operator|~
literal|255U
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|// Use CTZ to compute the rotate amount.
name|unsigned
name|RotAmt
init|=
name|CountTrailingZeros_32
argument_list|(
name|V
argument_list|)
decl_stmt|;
return|return
operator|(
literal|32
operator|-
name|RotAmt
operator|)
operator|&
literal|31
return|;
block|}
specifier|static
specifier|inline
name|bool
name|isT2SOImmTwoPartVal
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
name|unsigned
name|V
init|=
name|Imm
decl_stmt|;
comment|// Passing values can be any combination of splat values and shifter
comment|// values. If this can be handled with a single shifter or splat, bail
comment|// out. Those should be handled directly, not with a two-part val.
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|V
operator|=
name|rotr32
argument_list|(
operator|~
literal|255U
argument_list|,
name|getT2SOImmValRotate
argument_list|(
name|V
argument_list|)
argument_list|)
operator|&
name|V
expr_stmt|;
if|if
condition|(
name|V
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|// If this can be handled as an immediate, accept.
if|if
condition|(
name|getT2SOImmVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|true
return|;
comment|// Likewise, try masking out a splat value first.
name|V
operator|=
name|Imm
expr_stmt|;
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|V
operator|&
literal|0xff00ff00U
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|V
operator|&=
operator|~
literal|0xff00ff00U
expr_stmt|;
elseif|else
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|V
operator|&
literal|0x00ff00ffU
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|V
operator|&=
operator|~
literal|0x00ff00ffU
expr_stmt|;
comment|// If what's left can be handled as an immediate, accept.
if|if
condition|(
name|getT2SOImmVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|true
return|;
comment|// Otherwise, do not accept.
return|return
name|false
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getT2SOImmTwoPartFirst
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
name|assert
argument_list|(
name|isT2SOImmTwoPartVal
argument_list|(
name|Imm
argument_list|)
operator|&&
literal|"Immedate cannot be encoded as two part immediate!"
argument_list|)
expr_stmt|;
comment|// Try a shifter operand as one part
name|unsigned
name|V
init|=
name|rotr32
argument_list|(
operator|~
literal|255
argument_list|,
name|getT2SOImmValRotate
argument_list|(
name|Imm
argument_list|)
argument_list|)
operator|&
name|Imm
decl_stmt|;
comment|// If the rest is encodable as an immediate, then return it.
if|if
condition|(
name|getT2SOImmVal
argument_list|(
name|V
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|V
return|;
comment|// Try masking out a splat value first.
if|if
condition|(
name|getT2SOImmValSplatVal
argument_list|(
name|Imm
operator|&
literal|0xff00ff00U
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|Imm
operator|&
literal|0xff00ff00U
return|;
comment|// The other splat is all that's left as an option.
name|assert
argument_list|(
name|getT2SOImmValSplatVal
argument_list|(
name|Imm
operator|&
literal|0x00ff00ffU
argument_list|)
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|Imm
operator|&
literal|0x00ff00ffU
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getT2SOImmTwoPartSecond
parameter_list|(
name|unsigned
name|Imm
parameter_list|)
block|{
comment|// Mask out the first hunk
name|Imm
operator|^=
name|getT2SOImmTwoPartFirst
argument_list|(
name|Imm
argument_list|)
expr_stmt|;
comment|// Return what's left
name|assert
argument_list|(
name|getT2SOImmVal
argument_list|(
name|Imm
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
literal|"Unable to encode second part of T2 two part SO immediate"
argument_list|)
expr_stmt|;
return|return
name|Imm
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #2
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for most simple load/store instructions.
comment|//
comment|// addrmode2 := reg +/- reg shop imm
comment|// addrmode2 := reg +/- imm12
comment|//
comment|// The first operand is always a Reg.  The second operand is a reg if in
comment|// reg/reg form, otherwise it's reg#0.  The third field encodes the operation
comment|// in bit 12, the immediate in bits 0-11, and the shift op in 13-15.
comment|//
comment|// If this addressing mode is a frame index (before prolog/epilog insertion
comment|// and code rewriting), this operand will have the form:  FI#, reg0,<offs>
comment|// with no shift amount for the frame offset.
comment|//
specifier|static
specifier|inline
name|unsigned
name|getAM2Opc
parameter_list|(
name|AddrOpc
name|Opc
parameter_list|,
name|unsigned
name|Imm12
parameter_list|,
name|ShiftOpc
name|SO
parameter_list|)
block|{
name|assert
argument_list|(
name|Imm12
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|&&
literal|"Imm too large!"
argument_list|)
expr_stmt|;
name|bool
name|isSub
init|=
name|Opc
operator|==
name|sub
decl_stmt|;
return|return
name|Imm12
operator||
operator|(
operator|(
name|int
operator|)
name|isSub
operator|<<
literal|12
operator|)
operator||
operator|(
name|SO
operator|<<
literal|13
operator|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getAM2Offset
parameter_list|(
name|unsigned
name|AM2Opc
parameter_list|)
block|{
return|return
name|AM2Opc
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
return|;
block|}
specifier|static
specifier|inline
name|AddrOpc
name|getAM2Op
parameter_list|(
name|unsigned
name|AM2Opc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AM2Opc
operator|>>
literal|12
operator|)
operator|&
literal|1
operator|)
condition|?
name|sub
else|:
name|add
return|;
block|}
specifier|static
specifier|inline
name|ShiftOpc
name|getAM2ShiftOpc
parameter_list|(
name|unsigned
name|AM2Opc
parameter_list|)
block|{
return|return
call|(
name|ShiftOpc
call|)
argument_list|(
name|AM2Opc
operator|>>
literal|13
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #3
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for sign-extending loads, and load/store-pair instructions.
comment|//
comment|// addrmode3 := reg +/- reg
comment|// addrmode3 := reg +/- imm8
comment|//
comment|// The first operand is always a Reg.  The second operand is a reg if in
comment|// reg/reg form, otherwise it's reg#0.  The third field encodes the operation
comment|// in bit 8, the immediate in bits 0-7.
comment|/// getAM3Opc - This function encodes the addrmode3 opc field.
specifier|static
specifier|inline
name|unsigned
name|getAM3Opc
parameter_list|(
name|AddrOpc
name|Opc
parameter_list|,
name|unsigned
name|char
name|Offset
parameter_list|)
block|{
name|bool
name|isSub
init|=
name|Opc
operator|==
name|sub
decl_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|isSub
operator|<<
literal|8
operator|)
operator||
name|Offset
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|char
name|getAM3Offset
parameter_list|(
name|unsigned
name|AM3Opc
parameter_list|)
block|{
return|return
name|AM3Opc
operator|&
literal|0xFF
return|;
block|}
specifier|static
specifier|inline
name|AddrOpc
name|getAM3Op
parameter_list|(
name|unsigned
name|AM3Opc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AM3Opc
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
condition|?
name|sub
else|:
name|add
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #4
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for load / store multiple instructions.
comment|//
comment|// addrmode4 := reg,<mode>
comment|//
comment|// The four modes are:
comment|//    IA - Increment after
comment|//    IB - Increment before
comment|//    DA - Decrement after
comment|//    DB - Decrement before
specifier|static
specifier|inline
name|AMSubMode
name|getAM4SubMode
parameter_list|(
name|unsigned
name|Mode
parameter_list|)
block|{
return|return
call|(
name|AMSubMode
call|)
argument_list|(
name|Mode
operator|&
literal|0x7
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|getAM4ModeImm
parameter_list|(
name|AMSubMode
name|SubMode
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|SubMode
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #5
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for coprocessor instructions, such as FP load/stores.
comment|//
comment|// addrmode5 := reg +/- imm8*4
comment|//
comment|// The first operand is always a Reg.  The second operand encodes the
comment|// operation in bit 8 and the immediate in bits 0-7.
comment|//
comment|// This is also used for FP load/store multiple ops. The second operand
comment|// encodes the number of registers (or 2 times the number of registers
comment|// for DPR ops) in bits 0-7. In addition, bits 8-10 encode one of the
comment|// following two sub-modes:
comment|//
comment|//    IA - Increment after
comment|//    DB - Decrement before
comment|/// getAM5Opc - This function encodes the addrmode5 opc field.
specifier|static
specifier|inline
name|unsigned
name|getAM5Opc
parameter_list|(
name|AddrOpc
name|Opc
parameter_list|,
name|unsigned
name|char
name|Offset
parameter_list|)
block|{
name|bool
name|isSub
init|=
name|Opc
operator|==
name|sub
decl_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|isSub
operator|<<
literal|8
operator|)
operator||
name|Offset
return|;
block|}
specifier|static
specifier|inline
name|unsigned
name|char
name|getAM5Offset
parameter_list|(
name|unsigned
name|AM5Opc
parameter_list|)
block|{
return|return
name|AM5Opc
operator|&
literal|0xFF
return|;
block|}
specifier|static
specifier|inline
name|AddrOpc
name|getAM5Op
parameter_list|(
name|unsigned
name|AM5Opc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|AM5Opc
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
condition|?
name|sub
else|:
name|add
return|;
block|}
comment|/// getAM5Opc - This function encodes the addrmode5 opc field for VLDM and
comment|/// VSTM instructions.
specifier|static
specifier|inline
name|unsigned
name|getAM5Opc
parameter_list|(
name|AMSubMode
name|SubMode
parameter_list|,
name|unsigned
name|char
name|Offset
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|SubMode
operator|==
name|ia
operator|||
name|SubMode
operator|==
name|db
operator|)
operator|&&
literal|"Illegal addressing mode 5 sub-mode!"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|SubMode
operator|<<
literal|8
operator|)
operator||
name|Offset
return|;
block|}
specifier|static
specifier|inline
name|AMSubMode
name|getAM5SubMode
parameter_list|(
name|unsigned
name|AM5Opc
parameter_list|)
block|{
return|return
call|(
name|AMSubMode
call|)
argument_list|(
operator|(
name|AM5Opc
operator|>>
literal|8
operator|)
operator|&
literal|0x7
argument_list|)
return|;
block|}
comment|//===--------------------------------------------------------------------===//
comment|// Addressing Mode #6
comment|//===--------------------------------------------------------------------===//
comment|//
comment|// This is used for NEON load / store instructions.
comment|//
comment|// addrmode6 := reg with optional alignment
comment|//
comment|// This is stored in two operands [regaddr, align].  The first is the
comment|// address register.  The second operand is the value of the alignment
comment|// specifier to use or zero if no explicit alignment.
block|}
comment|// end namespace ARM_AM
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

