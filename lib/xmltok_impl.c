begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1998, 1999 Thai Open Source Software Center Ltd    See the file COPYING for copying permission. */
end_comment

begin_comment
comment|/* This file is included! */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XML_TOK_IMPL_C
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IS_INVALID_CHAR
end_ifndef

begin_define
define|#
directive|define
name|IS_INVALID_CHAR
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|n
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INVALID_LEAD_CASE
parameter_list|(
name|n
parameter_list|,
name|ptr
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|case BT_LEAD ## n: \       if (end - ptr< n) \         return XML_TOK_PARTIAL_CHAR; \       if (IS_INVALID_CHAR(enc, ptr, n)) { \         *(nextTokPtr) = (ptr); \         return XML_TOK_INVALID; \       } \       ptr += n; \       break;
end_define

begin_define
define|#
directive|define
name|INVALID_CASES
parameter_list|(
name|ptr
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|INVALID_LEAD_CASE(2, ptr, nextTokPtr) \   INVALID_LEAD_CASE(3, ptr, nextTokPtr) \   INVALID_LEAD_CASE(4, ptr, nextTokPtr) \   case BT_NONXML: \   case BT_MALFORM: \   case BT_TRAIL: \     *(nextTokPtr) = (ptr); \     return XML_TOK_INVALID;
end_define

begin_define
define|#
directive|define
name|CHECK_NAME_CASE
parameter_list|(
name|n
parameter_list|,
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|case BT_LEAD ## n: \      if (end - ptr< n) \        return XML_TOK_PARTIAL_CHAR; \      if (!IS_NAME_CHAR(enc, ptr, n)) { \        *nextTokPtr = ptr; \        return XML_TOK_INVALID; \      } \      ptr += n; \      break;
end_define

begin_define
define|#
directive|define
name|CHECK_NAME_CASES
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|case BT_NONASCII: \     if (!IS_NAME_CHAR_MINBPC(enc, ptr)) { \       *nextTokPtr = ptr; \       return XML_TOK_INVALID; \     } \   case BT_NMSTRT: \   case BT_HEX: \   case BT_DIGIT: \   case BT_NAME: \   case BT_MINUS: \     ptr += MINBPC(enc); \     break; \   CHECK_NAME_CASE(2, enc, ptr, end, nextTokPtr) \   CHECK_NAME_CASE(3, enc, ptr, end, nextTokPtr) \   CHECK_NAME_CASE(4, enc, ptr, end, nextTokPtr)
end_define

begin_define
define|#
directive|define
name|CHECK_NMSTRT_CASE
parameter_list|(
name|n
parameter_list|,
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|case BT_LEAD ## n: \      if (end - ptr< n) \        return XML_TOK_PARTIAL_CHAR; \      if (!IS_NMSTRT_CHAR(enc, ptr, n)) { \        *nextTokPtr = ptr; \        return XML_TOK_INVALID; \      } \      ptr += n; \      break;
end_define

begin_define
define|#
directive|define
name|CHECK_NMSTRT_CASES
parameter_list|(
name|enc
parameter_list|,
name|ptr
parameter_list|,
name|end
parameter_list|,
name|nextTokPtr
parameter_list|)
define|\
value|case BT_NONASCII: \     if (!IS_NMSTRT_CHAR_MINBPC(enc, ptr)) { \       *nextTokPtr = ptr; \       return XML_TOK_INVALID; \     } \   case BT_NMSTRT: \   case BT_HEX: \     ptr += MINBPC(enc); \     break; \   CHECK_NMSTRT_CASE(2, enc, ptr, end, nextTokPtr) \   CHECK_NMSTRT_CASE(3, enc, ptr, end, nextTokPtr) \   CHECK_NMSTRT_CASE(4, enc, ptr, end, nextTokPtr)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PREFIX
end_ifndef

begin_define
define|#
directive|define
name|PREFIX
parameter_list|(
name|ident
parameter_list|)
value|ident
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ptr points to character following "<!-" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanComment
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_MINUS
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|INVALID_CASES
argument_list|(
argument|ptr
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_MINUS
case|:
if|if
condition|(
operator|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_MINUS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_COMMENT
return|;
block|}
break|break;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "<!" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanDecl
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_MINUS
case|:
return|return
name|PREFIX
argument_list|(
name|scanComment
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_LSQB
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_COND_SECT_OPEN
return|;
case|case
name|BT_NMSTRT
case|:
case|case
name|BT_HEX
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_PERCNT
case|:
if|if
condition|(
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
comment|/* don't allow<!ENTITY% foo "whatever"> */
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_PERCNT
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
comment|/* fall through */
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DECL_OPEN
return|;
case|case
name|BT_NMSTRT
case|:
case|case
name|BT_HEX
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|checkPiTarget
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|int
modifier|*
name|tokPtr
parameter_list|)
block|{
name|int
name|upper
init|=
literal|0
decl_stmt|;
operator|*
name|tokPtr
operator|=
name|XML_TOK_PI
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|ptr
operator|!=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|*
literal|3
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|ASCII_x
case|:
break|break;
case|case
name|ASCII_X
case|:
name|upper
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|1
return|;
block|}
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|ASCII_m
case|:
break|break;
case|case
name|ASCII_M
case|:
name|upper
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|1
return|;
block|}
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|ASCII_l
case|:
break|break;
case|case
name|ASCII_L
case|:
name|upper
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|1
return|;
block|}
if|if
condition|(
name|upper
condition|)
return|return
literal|0
return|;
operator|*
name|tokPtr
operator|=
name|XML_TOK_XML_DECL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "<?" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanPi
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
name|int
name|tok
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
init|=
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|checkPiTarget
argument_list|)
argument_list|(
name|enc
argument_list|,
name|target
argument_list|,
name|ptr
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|INVALID_CASES
argument_list|(
argument|ptr
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_QUEST
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|tok
return|;
block|}
break|break;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
case|case
name|BT_QUEST
case|:
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|checkPiTarget
argument_list|)
argument_list|(
name|enc
argument_list|,
name|target
argument_list|,
name|ptr
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|tok
return|;
block|}
comment|/* fall through */
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanCdataSection
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|CDATA_LSQB
index|[]
init|=
block|{
name|ASCII_C
block|,
name|ASCII_D
block|,
name|ASCII_A
block|,
name|ASCII_T
block|,
name|ASCII_A
block|,
name|ASCII_LSQB
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* CDATA[ */
if|if
condition|(
name|end
operator|-
name|ptr
operator|<
literal|6
operator|*
name|MINBPC
argument_list|(
name|enc
argument_list|)
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
operator|,
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|CDATA_LSQB
index|[
name|i
index|]
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_CDATA_SECT_OPEN
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|cdataSectionTok
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_NONE
return|;
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|>
literal|1
condition|)
block|{
name|size_t
name|n
init|=
name|end
operator|-
name|ptr
decl_stmt|;
if|if
condition|(
name|n
operator|&
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|n
operator|&=
operator|~
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
name|end
operator|=
name|ptr
operator|+
name|n
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_RSQB
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_RSQB
argument_list|)
condition|)
break|break;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
name|ptr
operator|-=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_CDATA_SECT_CLOSE
return|;
case|case
name|BT_CR
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
operator|==
name|BT_LF
condition|)
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
case|case
name|BT_LF
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
name|INVALID_CASES
argument_list|(
argument|ptr
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: \       if (end - ptr< n || IS_INVALID_CHAR(enc, ptr, n)) { \         *nextTokPtr = ptr; \         return XML_TOK_DATA_CHARS; \       } \       ptr += n; \       break;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_NONXML
case|:
case|case
name|BT_MALFORM
case|:
case|case
name|BT_TRAIL
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_RSQB
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "</" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanEndTag
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
for|for
control|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
init|;
name|ptr
operator|!=
name|end
condition|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
break|break;
case|case
name|BT_GT
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_END_TAG
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
comment|/* no need to check qname syntax here,          since end-tag must match exactly */
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|BT_GT
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_END_TAG
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "&#X" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanHexCharRef
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_DIGIT
case|:
case|case
name|BT_HEX
case|:
break|break;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
for|for
control|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
init|;
name|ptr
operator|!=
name|end
condition|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_DIGIT
case|:
case|case
name|BT_HEX
case|:
break|break;
case|case
name|BT_SEMI
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_CHAR_REF
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "&#" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanCharRef
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_x
argument_list|)
condition|)
return|return
name|PREFIX
argument_list|(
name|scanHexCharRef
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_DIGIT
case|:
break|break;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
for|for
control|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
init|;
name|ptr
operator|!=
name|end
condition|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_DIGIT
case|:
break|break;
case|case
name|BT_SEMI
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_CHAR_REF
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "&" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanRef
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_NUM
case|:
return|return
name|PREFIX
argument_list|(
name|scanCharRef
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_SEMI
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_ENTITY_REF
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following first character of attribute name */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanAtts
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XML_NS
name|int
name|hadColon
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
if|if
condition|(
name|hadColon
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
name|hadColon
operator|=
literal|1
expr_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
break|break;
endif|#
directive|endif
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|t
decl_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
name|t
operator|=
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|BT_EQUALS
condition|)
break|break;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|BT_S
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_CR
case|:
break|break;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
comment|/* fall through */
case|case
name|BT_EQUALS
case|:
block|{
name|int
name|open
decl_stmt|;
ifdef|#
directive|ifdef
name|XML_NS
name|hadColon
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
name|open
operator|=
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
operator|==
name|BT_QUOT
operator|||
name|open
operator|==
name|BT_APOS
condition|)
break|break;
switch|switch
condition|(
name|open
condition|)
block|{
case|case
name|BT_S
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_CR
case|:
break|break;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
comment|/* in attribute value */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
name|t
operator|=
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|open
condition|)
break|break;
switch|switch
condition|(
name|t
condition|)
block|{
name|INVALID_CASES
argument_list|(
argument|ptr
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_AMP
case|:
block|{
name|int
name|tok
init|=
name|PREFIX
argument_list|(
name|scanRef
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
operator|&
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|tok
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|tok
operator|==
name|XML_TOK_INVALID
condition|)
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|tok
return|;
block|}
break|break;
block|}
case|case
name|BT_LT
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
break|break;
case|case
name|BT_SOL
case|:
goto|goto
name|sol
goto|;
case|case
name|BT_GT
case|:
goto|goto
name|gt
goto|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
comment|/* ptr points to closing quote */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
continue|continue;
case|case
name|BT_GT
case|:
name|gt
label|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_START_TAG_WITH_ATTS
return|;
case|case
name|BT_SOL
case|:
name|sol
label|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_EMPTY_ELEMENT_WITH_ATTS
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
break|break;
block|}
break|break;
block|}
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "<" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanLt
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|XML_NS
name|int
name|hadColon
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_EXCL
case|:
if|if
condition|(
operator|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_MINUS
case|:
return|return
name|PREFIX
argument_list|(
name|scanComment
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_LSQB
case|:
return|return
name|PREFIX
argument_list|(
name|scanCdataSection
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
case|case
name|BT_QUEST
case|:
return|return
name|PREFIX
argument_list|(
name|scanPi
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_SOL
case|:
return|return
name|PREFIX
argument_list|(
name|scanEndTag
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
ifdef|#
directive|ifdef
name|XML_NS
name|hadColon
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* we have a start-tag */
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
if|if
condition|(
name|hadColon
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
name|hadColon
operator|=
literal|1
expr_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
break|break;
endif|#
directive|endif
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_GT
case|:
goto|goto
name|gt
goto|;
case|case
name|BT_SOL
case|:
goto|goto
name|sol
goto|;
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
continue|continue;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
return|return
name|PREFIX
argument_list|(
name|scanAtts
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
case|case
name|BT_GT
case|:
name|gt
label|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_START_TAG_NO_ATTS
return|;
case|case
name|BT_SOL
case|:
name|sol
label|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_EMPTY_ELEMENT_NO_ATTS
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|contentTok
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_NONE
return|;
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|>
literal|1
condition|)
block|{
name|size_t
name|n
init|=
name|end
operator|-
name|ptr
decl_stmt|;
if|if
condition|(
name|n
operator|&
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|n
operator|&=
operator|~
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
name|end
operator|=
name|ptr
operator|+
name|n
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_LT
case|:
return|return
name|PREFIX
argument_list|(
name|scanLt
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_AMP
case|:
return|return
name|PREFIX
argument_list|(
name|scanRef
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_CR
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_TRAILING_CR
return|;
if|if
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
operator|==
name|BT_LF
condition|)
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
case|case
name|BT_LF
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
case|case
name|BT_RSQB
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_TRAILING_RSQB
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_RSQB
argument_list|)
condition|)
break|break;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_TRAILING_RSQB
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
name|ptr
operator|-=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
name|INVALID_CASES
argument_list|(
argument|ptr
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: \       if (end - ptr< n || IS_INVALID_CHAR(enc, ptr, n)) { \         *nextTokPtr = ptr; \         return XML_TOK_DATA_CHARS; \       } \       ptr += n; \       break;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_RSQB
case|:
if|if
condition|(
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|ASCII_RSQB
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ptr
operator|+
literal|2
operator|*
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
literal|2
operator|*
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
literal|2
operator|*
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
comment|/* fall through */
case|case
name|BT_AMP
case|:
case|case
name|BT_LT
case|:
case|case
name|BT_NONXML
case|:
case|case
name|BT_MALFORM
case|:
case|case
name|BT_TRAIL
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
block|}
end_function

begin_comment
comment|/* ptr points to character following "%" */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanPercent
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
operator|-
name|XML_TOK_PERCENT
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_S
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_PERCNT
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_PERCENT
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_SEMI
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_PARAM_ENTITY_REF
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanPoundName
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NMSTRT_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_S
case|:
case|case
name|BT_RPAR
case|:
case|case
name|BT_GT
case|:
case|case
name|BT_PERCNT
case|:
case|case
name|BT_VERBAR
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_POUND_NAME
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
operator|-
name|XML_TOK_POUND_NAME
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|scanLit
function|)
parameter_list|(
name|int
name|open
parameter_list|,
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
name|int
name|t
init|=
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
name|INVALID_CASES
argument_list|(
argument|ptr
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_QUOT
case|:
case|case
name|BT_APOS
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|open
condition|)
break|break;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
operator|-
name|XML_TOK_LITERAL
return|;
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_GT
case|:
case|case
name|BT_PERCNT
case|:
case|case
name|BT_LSQB
case|:
return|return
name|XML_TOK_LITERAL
return|;
default|default:
return|return
name|XML_TOK_INVALID
return|;
block|}
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|prologTok
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
name|int
name|tok
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_NONE
return|;
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|>
literal|1
condition|)
block|{
name|size_t
name|n
init|=
name|end
operator|-
name|ptr
decl_stmt|;
if|if
condition|(
name|n
operator|&
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|n
operator|&=
operator|~
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
name|end
operator|=
name|ptr
operator|+
name|n
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_QUOT
case|:
return|return
name|PREFIX
argument_list|(
name|scanLit
argument_list|)
argument_list|(
name|BT_QUOT
argument_list|,
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_APOS
case|:
return|return
name|PREFIX
argument_list|(
name|scanLit
argument_list|)
argument_list|(
name|BT_APOS
argument_list|,
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_LT
case|:
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_EXCL
case|:
return|return
name|PREFIX
argument_list|(
name|scanDecl
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_QUEST
case|:
return|return
name|PREFIX
argument_list|(
name|scanPi
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_NMSTRT
case|:
case|case
name|BT_HEX
case|:
case|case
name|BT_NONASCII
case|:
case|case
name|BT_LEAD2
case|:
case|case
name|BT_LEAD3
case|:
case|case
name|BT_LEAD4
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|-
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_INSTANCE_START
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
case|case
name|BT_CR
case|:
if|if
condition|(
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|==
name|end
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|end
expr_stmt|;
comment|/* indicate that this might be part of a CR/LF pair */
return|return
operator|-
name|XML_TOK_PROLOG_S
return|;
block|}
comment|/* fall through */
case|case
name|BT_S
case|:
case|case
name|BT_LF
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
break|break;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_S
case|:
case|case
name|BT_LF
case|:
break|break;
case|case
name|BT_CR
case|:
comment|/* don't split CR/LF pair */
if|if
condition|(
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|!=
name|end
condition|)
break|break;
comment|/* fall through */
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_PROLOG_S
return|;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_PROLOG_S
return|;
case|case
name|BT_PERCNT
case|:
return|return
name|PREFIX
argument_list|(
name|scanPercent
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
case|case
name|BT_COMMA
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_COMMA
return|;
case|case
name|BT_LSQB
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_OPEN_BRACKET
return|;
case|case
name|BT_RSQB
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
operator|-
name|XML_TOK_CLOSE_BRACKET
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_RSQB
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
literal|2
operator|*
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_COND_SECT_CLOSE
return|;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_CLOSE_BRACKET
return|;
case|case
name|BT_LPAR
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_OPEN_PAREN
return|;
case|case
name|BT_RPAR
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
operator|-
name|XML_TOK_CLOSE_PAREN
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_AST
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_CLOSE_PAREN_ASTERISK
return|;
case|case
name|BT_QUEST
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_CLOSE_PAREN_QUESTION
return|;
case|case
name|BT_PLUS
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_CLOSE_PAREN_PLUS
return|;
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_S
case|:
case|case
name|BT_GT
case|:
case|case
name|BT_COMMA
case|:
case|case
name|BT_VERBAR
case|:
case|case
name|BT_RPAR
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_CLOSE_PAREN
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
case|case
name|BT_VERBAR
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_OR
return|;
case|case
name|BT_GT
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_DECL_CLOSE
return|;
case|case
name|BT_NUM
case|:
return|return
name|PREFIX
argument_list|(
name|scanPoundName
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: \     if (end - ptr< n) \       return XML_TOK_PARTIAL_CHAR; \     if (IS_NMSTRT_CHAR(enc, ptr, n)) { \       ptr += n; \       tok = XML_TOK_NAME; \       break; \     } \     if (IS_NAME_CHAR(enc, ptr, n)) { \       ptr += n; \       tok = XML_TOK_NMTOKEN; \       break; \     } \     *nextTokPtr = ptr; \     return XML_TOK_INVALID;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_NMSTRT
case|:
case|case
name|BT_HEX
case|:
name|tok
operator|=
name|XML_TOK_NAME
expr_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_DIGIT
case|:
case|case
name|BT_NAME
case|:
case|case
name|BT_MINUS
case|:
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
endif|#
directive|endif
name|tok
operator|=
name|XML_TOK_NMTOKEN
expr_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_NONASCII
case|:
if|if
condition|(
name|IS_NMSTRT_CHAR_MINBPC
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|tok
operator|=
name|XML_TOK_NAME
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_NAME_CHAR_MINBPC
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|tok
operator|=
name|XML_TOK_NMTOKEN
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_GT
case|:
case|case
name|BT_RPAR
case|:
case|case
name|BT_COMMA
case|:
case|case
name|BT_VERBAR
case|:
case|case
name|BT_LSQB
case|:
case|case
name|BT_PERCNT
case|:
case|case
name|BT_S
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|tok
return|;
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|XML_TOK_NAME
case|:
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
name|tok
operator|=
name|XML_TOK_PREFIXED_NAME
expr_stmt|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|CHECK_NAME_CASES
argument_list|(
argument|enc
argument_list|,
argument|ptr
argument_list|,
argument|end
argument_list|,
argument|nextTokPtr
argument_list|)
default|default:
name|tok
operator|=
name|XML_TOK_NMTOKEN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|XML_TOK_PREFIXED_NAME
case|:
name|tok
operator|=
name|XML_TOK_NMTOKEN
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
case|case
name|BT_PLUS
case|:
if|if
condition|(
name|tok
operator|==
name|XML_TOK_NMTOKEN
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_NAME_PLUS
return|;
case|case
name|BT_AST
case|:
if|if
condition|(
name|tok
operator|==
name|XML_TOK_NMTOKEN
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_NAME_ASTERISK
return|;
case|case
name|BT_QUEST
case|:
if|if
condition|(
name|tok
operator|==
name|XML_TOK_NMTOKEN
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_NAME_QUESTION
return|;
default|default:
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
block|}
block|}
return|return
operator|-
name|tok
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|attributeValueTok
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_NONE
return|;
name|start
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: ptr += n; break;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_AMP
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
return|return
name|PREFIX
argument_list|(
name|scanRef
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
case|case
name|BT_LT
case|:
comment|/* this is for inside entity references */
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_INVALID
return|;
case|case
name|BT_LF
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
case|case
name|BT_CR
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_TRAILING_CR
return|;
if|if
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
operator|==
name|BT_LF
condition|)
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
case|case
name|BT_S
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_ATTRIBUTE_VALUE_S
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|entityValueTok
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_NONE
return|;
name|start
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: ptr += n; break;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_AMP
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
return|return
name|PREFIX
argument_list|(
name|scanRef
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
return|;
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
case|case
name|BT_PERCNT
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
block|{
name|int
name|tok
init|=
name|PREFIX
argument_list|(
name|scanPercent
argument_list|)
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|end
argument_list|,
name|nextTokPtr
argument_list|)
decl_stmt|;
return|return
operator|(
name|tok
operator|==
name|XML_TOK_PERCENT
operator|)
condition|?
name|XML_TOK_INVALID
else|:
name|tok
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
case|case
name|BT_LF
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
case|case
name|BT_CR
case|:
if|if
condition|(
name|ptr
operator|==
name|start
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|end
condition|)
return|return
name|XML_TOK_TRAILING_CR
return|;
if|if
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
operator|==
name|BT_LF
condition|)
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_NEWLINE
return|;
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_DATA_CHARS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XML_DTD
end_ifdef

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|ignoreSectionTok
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|nextTokPtr
parameter_list|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|>
literal|1
condition|)
block|{
name|size_t
name|n
init|=
name|end
operator|-
name|ptr
decl_stmt|;
if|if
condition|(
name|n
operator|&
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|n
operator|&=
operator|~
operator|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|n
expr_stmt|;
block|}
block|}
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
name|INVALID_CASES
argument_list|(
argument|ptr
argument_list|,
argument|nextTokPtr
argument_list|)
case|case
name|BT_LT
case|:
if|if
condition|(
operator|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_EXCL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_LSQB
argument_list|)
condition|)
block|{
operator|++
name|level
expr_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|BT_RSQB
case|:
if|if
condition|(
operator|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_RSQB
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|)
operator|==
name|end
condition|)
return|return
name|XML_TOK_PARTIAL
return|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_GT
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
operator|*
name|nextTokPtr
operator|=
name|ptr
expr_stmt|;
return|return
name|XML_TOK_IGNORE_SECT
return|;
block|}
operator|--
name|level
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|XML_TOK_PARTIAL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_DTD */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|isPublicId
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|badPtr
parameter_list|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|end
operator|-=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ptr
operator|!=
name|end
condition|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_DIGIT
case|:
case|case
name|BT_HEX
case|:
case|case
name|BT_MINUS
case|:
case|case
name|BT_APOS
case|:
case|case
name|BT_LPAR
case|:
case|case
name|BT_RPAR
case|:
case|case
name|BT_PLUS
case|:
case|case
name|BT_COMMA
case|:
case|case
name|BT_SOL
case|:
case|case
name|BT_EQUALS
case|:
case|case
name|BT_QUEST
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
case|case
name|BT_SEMI
case|:
case|case
name|BT_EXCL
case|:
case|case
name|BT_AST
case|:
case|case
name|BT_PERCNT
case|:
case|case
name|BT_NUM
case|:
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
endif|#
directive|endif
break|break;
case|case
name|BT_S
case|:
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_TAB
argument_list|)
condition|)
block|{
operator|*
name|badPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|BT_NAME
case|:
case|case
name|BT_NMSTRT
case|:
if|if
condition|(
operator|!
operator|(
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
operator|&
operator|~
literal|0x7f
operator|)
condition|)
break|break;
default|default:
switch|switch
condition|(
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
literal|0x24
case|:
comment|/* $ */
case|case
literal|0x40
case|:
comment|/* @ */
break|break;
default|default:
operator|*
name|badPtr
operator|=
name|ptr
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This must only be called for a well-formed start-tag or empty    element tag.  Returns the number of attributes.  Pointers to the    first attsMax attributes are stored in atts. */
end_comment

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|getAtts
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|attsMax
parameter_list|,
name|ATTRIBUTE
modifier|*
name|atts
parameter_list|)
block|{
enum|enum
block|{
name|other
block|,
name|inName
block|,
name|inValue
block|}
name|state
init|=
name|inName
enum|;
name|int
name|nAtts
init|=
literal|0
decl_stmt|;
name|int
name|open
init|=
literal|0
decl_stmt|;
comment|/* defined when state == inValue;                    initialization just to shut up compilers */
for|for
control|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
init|;
condition|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
define|#
directive|define
name|START_NAME
define|\
value|if (state == other) { \         if (nAtts< attsMax) { \           atts[nAtts].name = ptr; \           atts[nAtts].normalized = 1; \         } \         state = inName; \       }
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: START_NAME ptr += (n - MINBPC(enc)); break;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_NONASCII
case|:
case|case
name|BT_NMSTRT
case|:
case|case
name|BT_HEX
case|:
name|START_NAME
break|break;
undef|#
directive|undef
name|START_NAME
case|case
name|BT_QUOT
case|:
if|if
condition|(
name|state
operator|!=
name|inValue
condition|)
block|{
if|if
condition|(
name|nAtts
operator|<
name|attsMax
condition|)
name|atts
index|[
name|nAtts
index|]
operator|.
name|valuePtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|state
operator|=
name|inValue
expr_stmt|;
name|open
operator|=
name|BT_QUOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|open
operator|==
name|BT_QUOT
condition|)
block|{
name|state
operator|=
name|other
expr_stmt|;
if|if
condition|(
name|nAtts
operator|<
name|attsMax
condition|)
name|atts
index|[
name|nAtts
index|]
operator|.
name|valueEnd
operator|=
name|ptr
expr_stmt|;
name|nAtts
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BT_APOS
case|:
if|if
condition|(
name|state
operator|!=
name|inValue
condition|)
block|{
if|if
condition|(
name|nAtts
operator|<
name|attsMax
condition|)
name|atts
index|[
name|nAtts
index|]
operator|.
name|valuePtr
operator|=
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|state
operator|=
name|inValue
expr_stmt|;
name|open
operator|=
name|BT_APOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|open
operator|==
name|BT_APOS
condition|)
block|{
name|state
operator|=
name|other
expr_stmt|;
if|if
condition|(
name|nAtts
operator|<
name|attsMax
condition|)
name|atts
index|[
name|nAtts
index|]
operator|.
name|valueEnd
operator|=
name|ptr
expr_stmt|;
name|nAtts
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BT_AMP
case|:
if|if
condition|(
name|nAtts
operator|<
name|attsMax
condition|)
name|atts
index|[
name|nAtts
index|]
operator|.
name|normalized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BT_S
case|:
if|if
condition|(
name|state
operator|==
name|inName
condition|)
name|state
operator|=
name|other
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|inValue
operator|&&
name|nAtts
operator|<
name|attsMax
operator|&&
name|atts
index|[
name|nAtts
index|]
operator|.
name|normalized
operator|&&
operator|(
name|ptr
operator|==
name|atts
index|[
name|nAtts
index|]
operator|.
name|valuePtr
operator|||
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
operator|!=
name|ASCII_SPACE
operator|||
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|)
operator|==
name|ASCII_SPACE
operator|||
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|)
operator|==
name|open
operator|)
condition|)
name|atts
index|[
name|nAtts
index|]
operator|.
name|normalized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BT_CR
case|:
case|case
name|BT_LF
case|:
comment|/* This case ensures that the first attribute name is counted          Apart from that we could just change state on the quote. */
if|if
condition|(
name|state
operator|==
name|inName
condition|)
name|state
operator|=
name|other
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|inValue
operator|&&
name|nAtts
operator|<
name|attsMax
condition|)
name|atts
index|[
name|nAtts
index|]
operator|.
name|normalized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BT_GT
case|:
case|case
name|BT_SOL
case|:
if|if
condition|(
name|state
operator|!=
name|inValue
condition|)
return|return
name|nAtts
return|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_function
specifier|static
name|int
name|PTRFASTCALL
name|PREFIX
function|(
name|charRefNumber
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* skip&# */
name|ptr
operator|+=
literal|2
operator|*
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_x
argument_list|)
condition|)
block|{
for|for
control|(
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
init|;
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_SEMI
argument_list|)
condition|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
name|int
name|c
init|=
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ASCII_0
case|:
case|case
name|ASCII_1
case|:
case|case
name|ASCII_2
case|:
case|case
name|ASCII_3
case|:
case|case
name|ASCII_4
case|:
case|case
name|ASCII_5
case|:
case|case
name|ASCII_6
case|:
case|case
name|ASCII_7
case|:
case|case
name|ASCII_8
case|:
case|case
name|ASCII_9
case|:
name|result
operator|<<=
literal|4
expr_stmt|;
name|result
operator||=
operator|(
name|c
operator|-
name|ASCII_0
operator|)
expr_stmt|;
break|break;
case|case
name|ASCII_A
case|:
case|case
name|ASCII_B
case|:
case|case
name|ASCII_C
case|:
case|case
name|ASCII_D
case|:
case|case
name|ASCII_E
case|:
case|case
name|ASCII_F
case|:
name|result
operator|<<=
literal|4
expr_stmt|;
name|result
operator|+=
literal|10
operator|+
operator|(
name|c
operator|-
name|ASCII_A
operator|)
expr_stmt|;
break|break;
case|case
name|ASCII_a
case|:
case|case
name|ASCII_b
case|:
case|case
name|ASCII_c
case|:
case|case
name|ASCII_d
case|:
case|case
name|ASCII_e
case|:
case|case
name|ASCII_f
case|:
name|result
operator|<<=
literal|4
expr_stmt|;
name|result
operator|+=
literal|10
operator|+
operator|(
name|c
operator|-
name|ASCII_a
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|>=
literal|0x110000
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_SEMI
argument_list|)
condition|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
control|)
block|{
name|int
name|c
init|=
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
decl_stmt|;
name|result
operator|*=
literal|10
expr_stmt|;
name|result
operator|+=
operator|(
name|c
operator|-
name|ASCII_0
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0x110000
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|checkCharRefNumber
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|predefinedEntityName
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|end
operator|-
name|ptr
operator|)
operator|/
name|MINBPC
argument_list|(
name|enc
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
operator|+
name|MINBPC
argument_list|(
name|enc
argument_list|)
argument_list|,
name|ASCII_t
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|ASCII_l
case|:
return|return
name|ASCII_LT
return|;
case|case
name|ASCII_g
case|:
return|return
name|ASCII_GT
return|;
block|}
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_a
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_m
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_p
argument_list|)
condition|)
return|return
name|ASCII_AMP
return|;
block|}
block|}
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|BYTE_TO_ASCII
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|ASCII_q
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_u
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_o
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_t
argument_list|)
condition|)
return|return
name|ASCII_QUOT
return|;
block|}
block|}
break|break;
case|case
name|ASCII_a
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_p
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_o
argument_list|)
condition|)
block|{
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|,
name|ASCII_s
argument_list|)
condition|)
return|return
name|ASCII_APOS
return|;
block|}
block|}
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|sameName
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr1
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr2
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr1
argument_list|)
condition|)
block|{
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: \       if (*ptr1++ != *ptr2++) \         return 0;
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
comment|/* fall through */
if|if
condition|(
operator|*
name|ptr1
operator|++
operator|!=
operator|*
name|ptr2
operator|++
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|BT_NONASCII
case|:
case|case
name|BT_NMSTRT
case|:
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
endif|#
directive|endif
case|case
name|BT_HEX
case|:
case|case
name|BT_DIGIT
case|:
case|case
name|BT_NAME
case|:
case|case
name|BT_MINUS
case|:
if|if
condition|(
operator|*
name|ptr2
operator|++
operator|!=
operator|*
name|ptr1
operator|++
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|ptr2
operator|++
operator|!=
operator|*
name|ptr1
operator|++
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|*
name|ptr2
operator|++
operator|!=
operator|*
name|ptr1
operator|++
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|>
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|ptr2
operator|++
operator|!=
operator|*
name|ptr1
operator|++
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|==
literal|1
operator|&&
operator|*
name|ptr1
operator|==
operator|*
name|ptr2
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr2
argument_list|)
condition|)
block|{
case|case
name|BT_LEAD2
case|:
case|case
name|BT_LEAD3
case|:
case|case
name|BT_LEAD4
case|:
case|case
name|BT_NONASCII
case|:
case|case
name|BT_NMSTRT
case|:
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
endif|#
directive|endif
case|case
name|BT_HEX
case|:
case|case
name|BT_DIGIT
case|:
case|case
name|BT_NAME
case|:
case|case
name|BT_MINUS
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* not reached */
block|}
end_function

begin_function
specifier|static
name|int
name|PTRCALL
name|PREFIX
function|(
name|nameMatchesAscii
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr1
parameter_list|,
specifier|const
name|char
modifier|*
name|end1
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr2
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|ptr2
condition|;
name|ptr1
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
operator|,
name|ptr2
operator|++
control|)
block|{
if|if
condition|(
name|ptr1
operator|==
name|end1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|CHAR_MATCHES
argument_list|(
name|enc
argument_list|,
name|ptr1
argument_list|,
operator|*
name|ptr2
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
name|ptr1
operator|==
name|end1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|PTRFASTCALL
name|PREFIX
function|(
name|nameLength
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
init|=
name|ptr
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: ptr += n; break;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_NONASCII
case|:
case|case
name|BT_NMSTRT
case|:
ifdef|#
directive|ifdef
name|XML_NS
case|case
name|BT_COLON
case|:
endif|#
directive|endif
case|case
name|BT_HEX
case|:
case|case
name|BT_DIGIT
case|:
case|case
name|BT_NAME
case|:
case|case
name|BT_MINUS
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|start
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|PTRFASTCALL
name|PREFIX
function|(
name|skipS
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
case|case
name|BT_LF
case|:
case|case
name|BT_CR
case|:
case|case
name|BT_S
case|:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ptr
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|PTRCALL
name|PREFIX
function|(
name|updatePosition
function|)
parameter_list|(
specifier|const
name|ENCODING
modifier|*
name|enc
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
name|POSITION
modifier|*
name|pos
parameter_list|)
block|{
while|while
condition|(
name|ptr
operator|!=
name|end
condition|)
block|{
switch|switch
condition|(
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
define|#
directive|define
name|LEAD_CASE
parameter_list|(
name|n
parameter_list|)
define|\
value|case BT_LEAD ## n: \       ptr += n; \       break;
name|LEAD_CASE
argument_list|(
literal|2
argument_list|)
name|LEAD_CASE
argument_list|(
literal|3
argument_list|)
name|LEAD_CASE
argument_list|(
literal|4
argument_list|)
undef|#
directive|undef
name|LEAD_CASE
case|case
name|BT_LF
case|:
name|pos
operator|->
name|columnNumber
operator|=
operator|(
name|XML_Size
operator|)
operator|-
literal|1
expr_stmt|;
name|pos
operator|->
name|lineNumber
operator|++
expr_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_CR
case|:
name|pos
operator|->
name|lineNumber
operator|++
expr_stmt|;
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|end
operator|&&
name|BYTE_TYPE
argument_list|(
name|enc
argument_list|,
name|ptr
argument_list|)
operator|==
name|BT_LF
condition|)
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
name|pos
operator|->
name|columnNumber
operator|=
operator|(
name|XML_Size
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|ptr
operator|+=
name|MINBPC
argument_list|(
name|enc
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|->
name|columnNumber
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|DO_LEAD_CASE
end_undef

begin_undef
undef|#
directive|undef
name|MULTIBYTE_CASES
end_undef

begin_undef
undef|#
directive|undef
name|INVALID_CASES
end_undef

begin_undef
undef|#
directive|undef
name|CHECK_NAME_CASE
end_undef

begin_undef
undef|#
directive|undef
name|CHECK_NAME_CASES
end_undef

begin_undef
undef|#
directive|undef
name|CHECK_NMSTRT_CASE
end_undef

begin_undef
undef|#
directive|undef
name|CHECK_NMSTRT_CASES
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XML_TOK_IMPL_C */
end_comment

end_unit

