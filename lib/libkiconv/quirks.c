begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Ryuichiro Imura  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * kiconv(3) requires shared linked, and reduce module size  * when statically linked.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PIC
end_ifdef

begin_comment
comment|/*  * Why do we need quirks?  * Since each vendors has their own Unicode mapping rules,  * we need some quirks until iconv(3) supports them.  * We can define Microsoft mappings here.  *   * For example, the eucJP and Unocode mapping rule is based on  * the JIS standard. Since Microsoft uses cp932 for Unicode mapping  * witch is not truly based on the JIS standard, reading a file  * system created by Microsoft Windows family using eucJP/Unicode  * mapping rule will cause a problem. That's why we define eucJP-ms here.  * The eucJP-ms has been defined by The Open Group Japan Vendor Coucil.  *  * Well, Apple Mac OS also has their own Unicode mappings,  * but we won't require these quirks here, because HFS doesn't have  * Unicode and HFS+ has decomposed Unicode which can not be  * handled by this xlat16 converter.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/iconv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"quirks.h"
end_include

begin_comment
comment|/*  * All lists of quirk character set  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|vendor
decl_stmt|;
comment|/* reserved for non MS mapping */
specifier|const
name|char
modifier|*
name|base_codeset
decl_stmt|,
modifier|*
name|quirk_codeset
decl_stmt|;
block|}
name|quirk_list
index|[]
init|=
block|{
block|{
name|KICONV_VENDOR_MICSFT
block|,
literal|"eucJP"
block|,
literal|"eucJP-ms"
block|}
block|,
block|{
name|KICONV_VENDOR_MICSFT
block|,
literal|"EUC-JP"
block|,
literal|"eucJP-ms"
block|}
block|,
block|{
name|KICONV_VENDOR_MICSFT
block|,
literal|"SJIS"
block|,
literal|"SJIS-ms"
block|}
block|,
block|{
name|KICONV_VENDOR_MICSFT
block|,
literal|"Shift_JIS"
block|,
literal|"SJIS-ms"
block|}
block|,
block|{
name|KICONV_VENDOR_MICSFT
block|,
literal|"Big5"
block|,
literal|"Big5-ms"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * The character list to replace for Japanese MS-Windows.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|quirk_replace_list
name|quirk_jis_cp932
index|[]
init|=
block|{
block|{
literal|0x00a2
block|,
literal|0xffe0
block|}
block|,
comment|/* Cent Sign, Fullwidth Cent Sign */
block|{
literal|0x00a3
block|,
literal|0xffe1
block|}
block|,
comment|/* Pound Sign, Fullwidth Pound Sign */
block|{
literal|0x00ac
block|,
literal|0xffe2
block|}
block|,
comment|/* Not Sign, Fullwidth Not Sign */
block|{
literal|0x2016
block|,
literal|0x2225
block|}
block|,
comment|/* Double Vertical Line, Parallel To */
block|{
literal|0x203e
block|,
literal|0x007e
block|}
block|,
comment|/* Overline, Tilde */
block|{
literal|0x2212
block|,
literal|0xff0d
block|}
block|,
comment|/* Minus Sign, Fullwidth Hyphenminus */
block|{
literal|0x301c
block|,
literal|0xff5e
block|}
comment|/* Wave Dash, Fullwidth Tilde */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All entries of quirks  */
end_comment

begin_define
define|#
directive|define
name|NumOf
parameter_list|(
name|n
parameter_list|)
value|(sizeof((n)) / sizeof((n)[0]))
end_define

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|quirk_codeset
decl_stmt|,
modifier|*
name|iconv_codeset
decl_stmt|,
modifier|*
name|pair_codeset
decl_stmt|;
name|struct
name|quirk_replace_list
argument_list|(
operator|*
name|replace_list
argument_list|)
decl|[]
decl_stmt|;
name|size_t
name|num_of_replaces
decl_stmt|;
block|}
name|quirk_table
index|[]
init|=
block|{
block|{
literal|"eucJP-ms"
block|,
literal|"eucJP"
block|,
name|ENCODING_UNICODE
block|,
operator|(
expr|struct
name|quirk_replace_list
argument_list|(
operator|*
argument_list|)
index|[]
operator|)
operator|&
name|quirk_jis_cp932
block|,
name|NumOf
argument_list|(
argument|quirk_jis_cp932
argument_list|)
block|}
block|,
block|{
literal|"SJIS-ms"
block|,
literal|"CP932"
block|,
name|ENCODING_UNICODE
block|,
comment|/* XXX - quirk_replace_list should be NULL */
operator|(
expr|struct
name|quirk_replace_list
argument_list|(
operator|*
argument_list|)
index|[]
operator|)
operator|&
name|quirk_jis_cp932
block|,
name|NumOf
argument_list|(
argument|quirk_jis_cp932
argument_list|)
block|}
block|,
block|{
literal|"Big5-ms"
block|,
literal|"CP950"
block|,
name|ENCODING_UNICODE
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|const
name|char
modifier|*
name|kiconv_quirkcs
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|vendor
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* 	 * We should compare codeset names ignoring case here, 	 * so that quirk could be used for all of the user input 	 * patterns. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumOf
argument_list|(
name|quirk_list
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|quirk_list
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|vendor
operator|&&
name|strcasecmp
argument_list|(
name|quirk_list
index|[
name|i
index|]
operator|.
name|base_codeset
argument_list|,
name|base
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|quirk_list
index|[
name|i
index|]
operator|.
name|quirk_codeset
operator|)
return|;
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal Functions  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|search_quirk
parameter_list|(
specifier|const
name|char
modifier|*
name|given_codeset
parameter_list|,
specifier|const
name|char
modifier|*
name|pair_codeset
parameter_list|,
name|struct
name|quirk_replace_list
modifier|*
modifier|*
name|replace_list
parameter_list|,
name|size_t
modifier|*
name|num_of_replaces
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
operator|*
name|replace_list
operator|=
name|NULL
expr_stmt|;
operator|*
name|num_of_replaces
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumOf
argument_list|(
name|quirk_table
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|quirk_table
index|[
name|i
index|]
operator|.
name|quirk_codeset
argument_list|,
name|given_codeset
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|quirk_table
index|[
name|i
index|]
operator|.
name|pair_codeset
argument_list|,
name|pair_codeset
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|replace_list
operator|=
operator|*
name|quirk_table
index|[
name|i
index|]
operator|.
name|replace_list
expr_stmt|;
operator|*
name|num_of_replaces
operator|=
name|quirk_table
index|[
name|i
index|]
operator|.
name|num_of_replaces
expr_stmt|;
block|}
return|return
operator|(
name|quirk_table
index|[
name|i
index|]
operator|.
name|iconv_codeset
operator|)
return|;
block|}
return|return
operator|(
name|given_codeset
operator|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|quirk_vendor2unix
parameter_list|(
name|uint16_t
name|c
parameter_list|,
name|struct
name|quirk_replace_list
modifier|*
name|replace_list
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|replace_list
index|[
name|i
index|]
operator|.
name|vendor_code
operator|==
name|c
condition|)
return|return
operator|(
name|replace_list
index|[
name|i
index|]
operator|.
name|standard_code
operator|)
return|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|quirk_unix2vendor
parameter_list|(
name|uint16_t
name|c
parameter_list|,
name|struct
name|quirk_replace_list
modifier|*
name|replace_list
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|replace_list
index|[
name|i
index|]
operator|.
name|standard_code
operator|==
name|c
condition|)
return|return
operator|(
name|replace_list
index|[
name|i
index|]
operator|.
name|vendor_code
operator|)
return|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* statically linked */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|kiconv_quirkcs
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|int
name|vendor
parameter_list|)
block|{
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIC */
end_comment

end_unit

