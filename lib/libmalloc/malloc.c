begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Author: Mark Moraes<moraes@csri.toronto.edu> */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.c"
end_include

begin_macro
name|RCSID
argument_list|(
literal|"$Id: malloc.c,v 1.20 1993/05/23 05:10:52 moraes Exp $"
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|grabhunk
parameter_list|(
name|nwords
parameter_list|)
name|size_t
name|nwords
decl_stmt|;
block|{
name|univptr_t
name|cp
decl_stmt|;
name|size_t
name|morecore
decl_stmt|;
name|Word
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|sbrkwords
decl_stmt|;
name|size_t
name|blksize
decl_stmt|;
specifier|static
name|char
modifier|*
name|spare
decl_stmt|;
specifier|static
name|int
name|nspare
decl_stmt|;
comment|/*  	 *  two words for fake boundary tags for the entire block, and one 	 *  for the next ptr of the block. 	 */
define|#
directive|define
name|EXCESS
value|3
name|sbrkwords
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
name|nwords
operator|+
name|EXCESS
operator|)
operator|/
name|_malloc_sbrkunits
operator|+
literal|1
operator|)
operator|*
name|_malloc_sbrkunits
argument_list|)
expr_stmt|;
name|morecore
operator|=
name|sbrkwords
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|+
name|SBRKEXTRA
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
call|(
modifier|*
name|_malloc_memfunc
call|)
argument_list|(
name|morecore
argument_list|)
operator|)
operator|==
operator|(
name|univptr_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * Should first GUARANTEE that what sbrk returns is aligned to 	 * Word boundaries - see align.h. Unfortunately, to guarantee 	 * that the pointer returned by sbrk is aligned on a word 	 * boundary, we must ask for sizeof(Word) -1 extra bytes, since 	 * we have no guarantee what other sbrk'ed blocks exist. (Sun 	 * sbrk always returns an aligned value, that is another story!) 	 * We use spare and nspare to keep track of the bytes wasted, so 	 * that we can try and reuse them later. If no other sbrk()s are 	 * called, then nspare rotates through the values 3, 2, 1, 0, 	 * and the first branch of the if() is always taken. 	 */
if|if
condition|(
operator|(
name|spare
operator|+
name|nspare
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|cp
condition|)
block|{
name|ptr
operator|=
operator|(
name|Word
operator|*
operator|)
name|SBRKALIGN
argument_list|(
name|spare
argument_list|)
expr_stmt|;
name|morecore
operator|+=
name|nspare
expr_stmt|;
name|sbrkwords
operator|=
name|morecore
operator|/
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|Word
operator|*
operator|)
name|SBRKALIGN
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|morecore
operator|-=
operator|(
name|char
operator|*
operator|)
name|ptr
operator|-
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
block|}
name|spare
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ptr
operator|+
name|sbrkwords
operator|)
expr_stmt|;
name|nspare
operator|=
operator|(
name|morecore
operator|-
name|sbrkwords
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|)
expr_stmt|;
name|_malloc_totalavail
operator|+=
name|sbrkwords
expr_stmt|;
name|PRTRACE
argument_list|(
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"sbrk %lu\n"
argument_list|,
operator|(
name|ulong
operator|)
name|sbrkwords
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Here we need to check if it adjoins the _malloc_hiword.  If it 	 *  does, then _malloc_hiword need not be a fake boundary tag any 	 *  longer, (its a real one) and the higher end of the block we 	 *  sbrk'ed is the fake tag.  So we tag it appropriately, make 	 *  the start of the block point to the old _malloc_hiword, and free it. 	 *  If we aren't next to _malloc_hiword, then someone else sbrk'ed in 	 *  between, so we can't coalesce over the boundary anyway, in 	 *  which case we just change _malloc_hiword to be in the new sbrk'ed 	 *  block without damaging the old one. And we free the block. 	 */
if|if
condition|(
name|ptr
operator|!=
name|_malloc_hiword
operator|+
literal|1
operator|||
name|_malloc_rover
operator|==
name|NULL
condition|)
block|{
comment|/* Non-contiguous sbrk'ed block, or first sbrk we've done. */
comment|/*  		 * First push this block on the stack of non-contiguous blocks 		 * we've sbrked. !! For real paranoia, we'd also check 		 * _malloc_mem... 		 */
name|REGISTER
name|Word
modifier|*
name|tmp
init|=
name|_malloc_mem
decl_stmt|;
name|_malloc_mem
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|sbrkwords
operator|--
expr_stmt|;
name|_malloc_hiword
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|_malloc_loword
operator|==
name|NULL
operator|||
name|_malloc_loword
operator|>
name|ptr
condition|)
block|{
comment|/* First time - set lower bound. */
name|PRTRACE
argument_list|(
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"heapstart 0x%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|_malloc_loword
operator|=
name|ptr
expr_stmt|;
block|}
comment|/* 		 *  Fake boundary tags to indicate the ends of an arena. Since they 		 *  are marked as allocated, no attempt will be made to coalesce 		 *  before or after them. 		 */
name|SIZEFIELD
argument_list|(
name|ptr
argument_list|)
operator|=
name|ALLOCED
operator||
name|sbrkwords
expr_stmt|;
name|_malloc_hiword
operator|+=
name|sbrkwords
operator|-
literal|1
expr_stmt|;
name|PRTRACE
argument_list|(
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"heapend 0x%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|_malloc_hiword
argument_list|)
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|_malloc_hiword
argument_list|)
operator|=
name|ALLOCED
operator||
name|sbrkwords
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* 		 *  The 2 we subtract are the special arena end tags, which is 		 *  why we don't use HEADERWORDS and TRAILERWORDS 		 */
name|sbrkwords
operator|-=
literal|2
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|ptr
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|sbrkwords
argument_list|)
expr_stmt|;
name|DMEMSET
argument_list|(
name|ptr
operator|+
name|FREEHEADERWORDS
argument_list|,
name|sbrkwords
operator|-
name|FREE_OVERHEAD
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|_malloc_hiword
operator|-
literal|1
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|ptr
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|sbrkwords
argument_list|)
expr_stmt|;
comment|/* links */
if|if
condition|(
name|_malloc_rover
operator|==
name|NULL
condition|)
block|{
comment|/* Only block in free list - links point to itself */
name|NEXT
argument_list|(
name|ptr
argument_list|)
operator|=
name|ptr
expr_stmt|;
name|PREV
argument_list|(
name|ptr
argument_list|)
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *  Non-contiguous sbrk - insert into free list. No 			 *  point calling free() because we know this cannot be 			 *  coalesced 			 */
name|NEXT
argument_list|(
name|ptr
argument_list|)
operator|=
name|_malloc_rover
expr_stmt|;
name|tmp
operator|=
name|PREV
argument_list|(
name|_malloc_rover
argument_list|)
expr_stmt|;
name|PREV
argument_list|(
name|ptr
argument_list|)
operator|=
name|tmp
expr_stmt|;
comment|/* PREV(ptr) = PREV(_malloc_rover); */
name|NEXT
argument_list|(
name|tmp
argument_list|)
operator|=
name|ptr
expr_stmt|;
comment|/* NEXT(PREV(_malloc_rover)) = ptr; */
name|PREV
argument_list|(
name|_malloc_rover
argument_list|)
operator|=
name|ptr
expr_stmt|;
block|}
name|_malloc_rover
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Set boundary tags and size */
name|ptr
operator|--
expr_stmt|;
name|blksize
operator|=
name|SIZE
argument_list|(
name|ptr
argument_list|)
operator|+
name|sbrkwords
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|ptr
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|sbrkwords
argument_list|)
expr_stmt|;
name|_malloc_hiword
operator|+=
name|sbrkwords
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|_malloc_hiword
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* Update fake end tags of the memory chunk */
name|SIZEFIELD
argument_list|(
name|_malloc_hiword
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|blksize
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|_malloc_hiword
operator|-
name|blksize
operator|+
literal|1
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|blksize
argument_list|)
expr_stmt|;
name|SET_REALSIZE
argument_list|(
name|ptr
argument_list|,
operator|(
name|sbrkwords
operator|-
name|ALLOC_OVERHEAD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
call|(
name|univptr_t
call|)
argument_list|(
name|ptr
operator|+
name|HEADERWORDS
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|univptr_t
name|malloc
parameter_list|(
name|nbytes
parameter_list|)
name|size_t
name|nbytes
decl_stmt|;
block|{
name|REGISTER
name|Word
modifier|*
name|start
decl_stmt|,
modifier|*
name|search
decl_stmt|;
name|REGISTER
name|Word
modifier|*
name|p
decl_stmt|;
name|REGISTER
name|size_t
name|required
decl_stmt|;
name|REGISTER
name|size_t
name|searchsize
decl_stmt|;
name|REGISTER
name|size_t
name|rest
decl_stmt|;
name|size_t
name|roversize
decl_stmt|;
ifndef|#
directive|ifndef
name|BUGCOMPATIBILITY
name|ASSERT
argument_list|(
name|nbytes
operator|!=
literal|0
argument_list|,
literal|"What do you expect when you malloc(0)?!!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* If we're debugging, then we died on the ASSERT */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* BUGCOMPATIBILITY */
name|required
operator|=
name|ALLOC_OVERHEAD
operator|+
operator|(
name|nbytes
operator|+
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
if|if
condition|(
name|required
operator|<
operator|(
name|size_t
operator|)
name|_malloc_minchunk
condition|)
name|required
operator|=
name|_malloc_minchunk
expr_stmt|;
name|search
operator|=
name|_malloc_rover
expr_stmt|;
if|if
condition|(
operator|!
name|search
operator|||
name|required
operator|>
name|_malloc_totalavail
condition|)
block|{
comment|/* Not enough memory in free list - allocate enough memory. */
if|if
condition|(
name|grabhunk
argument_list|(
name|required
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|search
operator|=
name|_malloc_rover
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt rover pointer in malloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_END_SIZE_FIELD
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt block in malloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt block in malloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt block in malloc()"
argument_list|)
expr_stmt|;
name|CHECKHEAP
argument_list|()
expr_stmt|;
name|roversize
operator|=
name|FREESIZE
argument_list|(
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|==
name|_malloc_hiword
operator|-
literal|1
condition|)
block|{
comment|/* avoid wilderness */
name|search
operator|=
name|NEXT
argument_list|(
name|search
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{ 			char buf[1024]; 			sprintf(buf, "wilderness = 0x%x, skipping to 0x%x\n", 				_malloc_hiword - 1, search); 			fputs(buf, stderr); 		}
endif|#
directive|endif
block|}
name|start
operator|=
name|search
expr_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|search
argument_list|)
argument_list|,
literal|"corrupt pointer in malloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_END_SIZE_FIELD
argument_list|(
name|search
argument_list|)
argument_list|,
literal|"corrupt pointer in malloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|search
argument_list|)
argument_list|,
literal|"corrupt pointer in malloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|search
argument_list|)
argument_list|,
literal|"corrupt pointer in malloc()"
argument_list|)
expr_stmt|;
name|searchsize
operator|=
name|FREESIZE
argument_list|(
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchsize
operator|>=
name|required
condition|)
block|{
break|break;
block|}
else|else
block|{
name|search
operator|=
name|NEXT
argument_list|(
name|search
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|search
operator|!=
name|start
condition|)
do|;
if|if
condition|(
name|searchsize
operator|<
name|required
condition|)
block|{
if|if
condition|(
name|grabhunk
argument_list|(
name|required
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  		 * We made sure in grabhunk() or free() that 		 * _malloc_rover is pointing to the newly sbrked (and 		 * freed) block. 		 */
name|search
operator|=
name|_malloc_rover
expr_stmt|;
name|roversize
operator|=
name|searchsize
operator|=
name|FREESIZE
argument_list|(
name|search
argument_list|)
expr_stmt|;
block|}
name|rest
operator|=
name|searchsize
operator|-
name|required
expr_stmt|;
if|if
condition|(
name|rest
operator|>=
name|_malloc_minchunk
condition|)
block|{
name|SIZEFIELD
argument_list|(
name|search
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|p
operator|=
name|search
operator|-
name|rest
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p
operator|+
literal|1
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|required
argument_list|)
expr_stmt|;
name|p
operator|-=
name|required
operator|-
literal|1
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|required
argument_list|)
expr_stmt|;
name|_malloc_totalavail
operator|-=
name|required
expr_stmt|;
comment|/* keep rover at the larger block */
if|if
condition|(
name|rest
operator|>
name|roversize
condition|)
name|_malloc_rover
operator|=
name|search
expr_stmt|;
block|}
else|else
block|{
comment|/* alloc the entire block */
name|REGISTER
name|Word
modifier|*
name|nextp
init|=
name|NEXT
argument_list|(
name|search
argument_list|)
decl_stmt|;
name|SIZEFIELD
argument_list|(
name|search
argument_list|)
operator||=
name|ALLOCED
expr_stmt|;
name|p
operator|=
name|search
operator|-
name|searchsize
operator|+
literal|1
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|==
name|nextp
condition|)
block|{
name|_malloc_rover
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|REGISTER
name|Word
modifier|*
name|prevp
init|=
name|PREV
argument_list|(
name|search
argument_list|)
decl_stmt|;
name|NEXT
argument_list|(
name|prevp
argument_list|)
operator|=
name|nextp
expr_stmt|;
name|PREV
argument_list|(
name|nextp
argument_list|)
operator|=
name|prevp
expr_stmt|;
comment|/* keep rover at the larger block, unless we just allocated rover*/
if|if
condition|(
name|search
operator|==
name|_malloc_rover
operator|||
name|FREESIZE
argument_list|(
name|nextp
argument_list|)
operator|>
name|roversize
condition|)
name|_malloc_rover
operator|=
name|nextp
expr_stmt|;
block|}
name|_malloc_totalavail
operator|-=
name|searchsize
expr_stmt|;
block|}
name|PRTRACE
argument_list|(
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"+ %lu %lu 0x%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|nbytes
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|SIZE
argument_list|(
name|p
argument_list|)
operator|-
name|ALLOC_OVERHEAD
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|p
operator|+
name|HEADERWORDS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|COUNTSIZE
argument_list|(
name|SIZE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|SET_REALSIZE
argument_list|(
name|p
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|univptr_t
call|)
argument_list|(
name|p
operator|+
name|HEADERWORDS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free
parameter_list|(
name|cp
parameter_list|)
name|univptr_t
name|cp
decl_stmt|;
block|{
comment|/*  	 * This is where the boundary tags come into their own. The 	 * boundary tag guarantees a constant time insert with full 	 * coalescing (the time varies slightly for the four case possible, 	 * but still, essentially a very fast free. 	 */
comment|/* 	 *  P0 is the block being freed. P1 is the pointer to the block 	 *  before the block being freed, and P2 is the block after it. 	 *  We can either coalesce with P1, P2, both, or neither 	 */
name|REGISTER
name|Word
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
name|p0
operator|=
operator|(
name|Word
operator|*
operator|)
name|cp
expr_stmt|;
name|p0
operator|-=
name|HEADERWORDS
expr_stmt|;
comment|/* A little paranoia... */
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|p0
argument_list|)
argument_list|,
literal|"bad pointer passed to free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|TAG
argument_list|(
name|p0
argument_list|)
operator|!=
name|FREE
argument_list|,
literal|"freed block passed to free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_START_SIZE_FIELD
argument_list|(
name|p0
argument_list|)
argument_list|,
literal|"corrupt block passed to free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_MAGIC
argument_list|(
name|p0
argument_list|)
argument_list|,
literal|"block with end overwritten passed to free()"
argument_list|)
expr_stmt|;
comment|/* With debugging, the assert would have already aborted */
if|if
condition|(
name|TAG
argument_list|(
name|p0
argument_list|)
operator|==
name|FREE
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
comment|/* 	 *  clear the entire block that used to be p0's, just in case someone 	 *  tries to refer to it or anything in it again.  We leave the end tags 	 *  alone for now - we'll smash them individually depending on the way p0 	 *  merges with p1 and/or p2. 	 */
name|DMEMSET
argument_list|(
name|p0
operator|+
name|FREEHEADERWORDS
argument_list|,
name|SIZE
argument_list|(
name|p0
argument_list|)
operator|-
name|FREE_OVERHEAD
argument_list|)
expr_stmt|;
name|PRTRACE
argument_list|(
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"- %lu 0x%lx\n"
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|SIZE
argument_list|(
name|p0
argument_list|)
operator|-
name|ALLOC_OVERHEAD
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|p0
operator|+
name|HEADERWORDS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|_malloc_totalavail
operator|+=
name|SIZE
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p0
operator|-
literal|1
expr_stmt|;
comment|/* 	 * p0 now points to the end of the block -- we start treating it as 	 * a free block 	 */
name|p0
operator|+=
name|SIZE
argument_list|(
name|p0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p2
operator|=
name|p0
operator|+
literal|1
expr_stmt|;
comment|/* 	 * More paranoia.... We can't match the SIZEFIELDs of p1/p2 with 	 * p1/p2 + SIZE(p1/p2) -1 because they might be a fake tag to 	 * indicate the bounds of the arena. Further, we should only check 	 * p1 if p0-1 is not the _malloc_loword or an arena bound - else p1 is 	 * probably not a valid pointer. If tag p0-1 is allocated, then it 	 * could be an arena bound. 	 */
if|if
condition|(
name|TAG
argument_list|(
name|p2
argument_list|)
operator|==
name|FREE
condition|)
block|{
comment|/*  		 *  Aha - block which is physically after p0 is free. 		 *  Merging with it merely means increasing its size to 		 *  incorporate the block being freed - no pointer 		 *  shuffling. 		 */
name|p2
operator|+=
name|FREESIZE
argument_list|(
name|p2
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|p2
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|TAG
argument_list|(
name|p2
argument_list|)
operator|==
name|FREE
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_END_SIZE_FIELD
argument_list|(
name|p2
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|p2
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|p2
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p2
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|FREESIZE
argument_list|(
name|p2
argument_list|)
operator|+
name|SIZE
argument_list|(
name|p0
argument_list|)
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p2
operator|-
name|FREESIZE
argument_list|(
name|p2
argument_list|)
operator|+
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p2
argument_list|)
expr_stmt|;
comment|/* 		 *  Smash p0's old end tag and p2's old start tag. 		 */
name|DMEMSET
argument_list|(
name|p0
operator|-
name|FREETRAILERWORDS
operator|+
literal|1
argument_list|,
name|FREETRAILERWORDS
operator|+
name|FREEHEADERWORDS
argument_list|)
expr_stmt|;
name|p0
operator|=
name|p2
expr_stmt|;
comment|/* p0 just vanished - became part of p2 */
block|}
if|if
condition|(
name|TAG
argument_list|(
name|p1
argument_list|)
operator|==
name|FREE
condition|)
block|{
comment|/*  		 * Block that physically precedes p0 in memory is free. Merging 		 * with it means rearranging the links to because the end of 		 * the block (the handle it is known by) is now the end of p0 		 * rather than itself. So the blocks after and before it in the 		 * free list need to be told. 		 */
name|REGISTER
name|Word
modifier|*
name|nextp1
decl_stmt|,
modifier|*
name|prevp1
decl_stmt|;
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|p1
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_END_SIZE_FIELD
argument_list|(
name|p1
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|p1
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|p1
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
comment|/* p0 grows to absorb p1 */
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|SIZE
argument_list|(
name|p0
argument_list|)
operator|+
name|FREESIZE
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p0
operator|-
name|FREESIZE
argument_list|(
name|p0
argument_list|)
operator|+
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|nextp1
operator|=
name|NEXT
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|prevp1
operator|=
name|PREV
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* 		 * We smash the free list pointers in p1 (SIZE, NEXT, PREV) to 		 * make sure no one refers to them again. We cannot smash the 		 * start boundary tag because in both cases, it becomes the start 		 * tag for the new block.  We also trash p0's start tag. 		 */
name|DMEMSET
argument_list|(
name|p1
operator|-
name|FREETRAILERWORDS
operator|+
literal|1
argument_list|,
name|FREETRAILERWORDS
operator|+
name|FREEHEADERWORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|p0
operator|!=
name|p2
condition|)
block|{
comment|/* 			 *  Ok - p0 coalesced with the block physically 			 *  before it (p1) (which is why we're here, but 			 *  it didn't coalesce with the block after it 			 *  (p2) which is why p0 != p2.  So we need to 			 *  insert p0 in the list in place of p1. 			 */
if|if
condition|(
name|nextp1
operator|!=
name|p1
condition|)
block|{
comment|/* Fix the PREV ptr of the next blk in the list */
name|PREV
argument_list|(
name|nextp1
argument_list|)
operator|=
name|p0
expr_stmt|;
comment|/* Fix the NEXT ptr of the previous blk in the list */
name|NEXT
argument_list|(
name|prevp1
argument_list|)
operator|=
name|p0
expr_stmt|;
comment|/* Copy the link info from p1 to p0 */
name|NEXT
argument_list|(
name|p0
argument_list|)
operator|=
name|nextp1
expr_stmt|;
name|PREV
argument_list|(
name|p0
argument_list|)
operator|=
name|prevp1
expr_stmt|;
block|}
else|else
block|{
name|NEXT
argument_list|(
name|p0
argument_list|)
operator|=
name|p0
expr_stmt|;
name|PREV
argument_list|(
name|p0
argument_list|)
operator|=
name|p0
expr_stmt|;
block|}
comment|/* p1 just vanished - became part of p0 */
name|_malloc_rover
operator|=
name|p0
expr_stmt|;
name|CHECKHEAP
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 			 *  p0 merged with p2, and with p1, which 			 *  essentially means that p2 grows to absorb p1 			 *  in the free list (bridged by p0). So we 			 *  simply delete p1. Free list reduces by one blk. 			 */
comment|/* Fix the PREV ptr of the next blk in the list */
name|PREV
argument_list|(
name|nextp1
argument_list|)
operator|=
name|prevp1
expr_stmt|;
comment|/* Fix the NEXT ptr of the previous blk in the list */
name|NEXT
argument_list|(
name|prevp1
argument_list|)
operator|=
name|nextp1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p0
operator|!=
name|p2
condition|)
block|{
comment|/* 		 *  If we're here, it means block P0 didn't coalesce, so 		 *  we need to insert it in the free list - we put it 		 *  before ROVER, and make ROVER point to it. Or it 		 *  means ROVER was NULL, i.e. free list is empty, which 		 *  means we have to take care of the boundary linking 		 *  Free list grows by one. 		 */
if|if
condition|(
name|_malloc_rover
operator|==
name|NULL
condition|)
block|{
comment|/*  			 *  Free list was empty - so we point _malloc_rover at 			 *  the block we're freeing to get a proper 			 *  circular linking. 			 */
name|_malloc_rover
operator|=
name|p0
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt rover pointer in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_END_SIZE_FIELD
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|_malloc_rover
argument_list|)
argument_list|,
literal|"corrupt block in free()"
argument_list|)
expr_stmt|;
block|}
name|NEXT
argument_list|(
name|p0
argument_list|)
operator|=
name|_malloc_rover
expr_stmt|;
name|PREV
argument_list|(
name|p0
argument_list|)
operator|=
name|PREV
argument_list|(
name|_malloc_rover
argument_list|)
expr_stmt|;
name|PREV
argument_list|(
name|_malloc_rover
argument_list|)
operator|=
name|p0
expr_stmt|;
name|NEXT
argument_list|(
name|PREV
argument_list|(
name|p0
argument_list|)
argument_list|)
operator|=
name|p0
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
operator|&=
name|SIZEMASK
expr_stmt|;
comment|/* sets the boundary tag to FREE */
name|SIZEFIELD
argument_list|(
name|p0
operator|-
name|FREESIZE
argument_list|(
name|p0
argument_list|)
operator|+
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
expr_stmt|;
block|}
name|_malloc_rover
operator|=
name|p0
expr_stmt|;
name|CHECKHEAP
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *  WARNING: This realloc() IS *NOT* upwards compatible with the  *  convention that the last freed block since the last malloc may be  *  realloced. Allegedly, this was because the old free() didn't  *  coalesce blocks, and reallocing a freed block would perform the  *  compaction. Yuk!  */
end_comment

begin_function
name|univptr_t
name|realloc
parameter_list|(
name|cp
parameter_list|,
name|nbytes
parameter_list|)
name|univptr_t
name|cp
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
block|{
name|REGISTER
name|Word
modifier|*
name|p0
init|=
operator|(
name|Word
operator|*
operator|)
name|cp
decl_stmt|;
name|REGISTER
name|Word
modifier|*
name|p1
decl_stmt|;
name|univptr_t
name|tmp
decl_stmt|;
name|REGISTER
name|size_t
name|required
decl_stmt|;
name|REGISTER
name|size_t
name|sizep0
decl_stmt|;
if|if
condition|(
name|p0
operator|==
name|NULL
condition|)
return|return
operator|(
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
return|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|required
operator|=
name|ALLOC_OVERHEAD
operator|+
operator|(
name|nbytes
operator|+
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
if|if
condition|(
name|required
operator|<
operator|(
name|size_t
operator|)
name|_malloc_minchunk
condition|)
name|required
operator|=
name|_malloc_minchunk
expr_stmt|;
name|p0
operator|-=
name|HEADERWORDS
expr_stmt|;
comment|/* A little paranoia... */
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|p0
argument_list|)
argument_list|,
literal|"bad pointer passed to realloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|TAG
argument_list|(
name|p0
argument_list|)
operator|!=
name|FREE
argument_list|,
literal|"freed block passed to realloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_START_SIZE_FIELD
argument_list|(
name|p0
argument_list|)
argument_list|,
literal|"corrupt block passed to realloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_MAGIC
argument_list|(
name|p0
argument_list|)
argument_list|,
literal|"block with end overwritten passed to realloc()"
argument_list|)
expr_stmt|;
comment|/* With debugging, the assert would have already aborted */
if|if
condition|(
name|TAG
argument_list|(
name|p0
argument_list|)
operator|==
name|FREE
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sizep0
operator|=
name|SIZE
argument_list|(
name|p0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizep0
operator|>=
name|required
condition|)
block|{
comment|/* Shrinking the block */
name|size_t
name|after
init|=
name|sizep0
operator|-
name|required
decl_stmt|;
name|SET_REALSIZE
argument_list|(
name|p0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|<
name|_malloc_minchunk
condition|)
block|{
comment|/*  			 *  Not enough to free what's left so we return the block 			 *  intact - print no-op for neatness in output. 			 */
name|PRTRACE
argument_list|(
name|strcpy
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"no-op\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|required
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p0
operator|+
name|required
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|p0
operator|+=
name|required
expr_stmt|;
comment|/* 		 *  We free what's after the block - mark it alloced and 		 *  throw it to free() to figure out whether to merge it 		 *  with what follows... 		 */
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p0
operator|+
name|after
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|SET_REALSIZE
argument_list|(
name|p0
argument_list|,
operator|(
name|after
operator|-
name|ALLOC_OVERHEAD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
call|(
name|univptr_t
call|)
argument_list|(
name|p0
operator|+
name|HEADERWORDS
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
comment|/*  	 *  If we get here, then we are growing the block to something 	 *  bigger. If the following block is free and big enough to be 	 *  realloced, then we grow using that block. This resembles the 	 *  malloc code slightly. 	 */
name|p1
operator|=
name|p0
operator|+
name|sizep0
expr_stmt|;
name|required
operator|-=
name|sizep0
expr_stmt|;
if|if
condition|(
name|TAG
argument_list|(
name|p1
argument_list|)
operator|==
name|FREE
condition|)
block|{
comment|/* p1 not free, may be an arena bound or hiword */
name|ASSERT
argument_list|(
name|PTR_IN_HEAP
argument_list|(
name|p1
argument_list|)
argument_list|,
literal|"corrupt pointer in realloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_START_SIZE_FIELD
argument_list|(
name|p1
argument_list|)
argument_list|,
literal|"corrupt block in realloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_NEXT_PTR
argument_list|(
name|p1
operator|+
name|FREESIZE
argument_list|(
name|p1
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
literal|"corrupt block in realloc()"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|VALID_PREV_PTR
argument_list|(
name|p1
operator|+
name|FREESIZE
argument_list|(
name|p1
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
literal|"corrupt block in realloc()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAG
argument_list|(
name|p1
argument_list|)
operator|==
name|FREE
operator|&&
name|FREESIZE
argument_list|(
name|p1
argument_list|)
operator|>=
name|required
condition|)
block|{
name|size_t
name|rest
init|=
name|FREESIZE
argument_list|(
name|p1
argument_list|)
operator|-
name|required
decl_stmt|;
name|REGISTER
name|Word
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|rest
operator|>=
name|_malloc_minchunk
condition|)
block|{
name|sizep0
operator|+=
name|required
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|sizep0
argument_list|)
expr_stmt|;
name|p
operator|=
name|p0
operator|+
name|sizep0
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
expr_stmt|;
empty_stmt|;
name|SIZEFIELD
argument_list|(
name|p
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p
operator|+
name|rest
operator|-
literal|1
argument_list|)
operator|=
name|FREEMASK
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|_malloc_totalavail
operator|-=
name|required
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * alloc the entire block and merge into p0. Free list 			 * shrinks by a block 			 */
name|REGISTER
name|Word
modifier|*
name|nextp1
decl_stmt|,
modifier|*
name|prevp1
decl_stmt|;
name|sizep0
operator|+=
name|FREESIZE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|sizep0
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p0
operator|+
name|sizep0
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|FREESIZE
argument_list|(
name|p1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|nextp1
operator|=
name|NEXT
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|nextp1
condition|)
block|{
name|_malloc_rover
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|prevp1
operator|=
name|PREV
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|PREV
argument_list|(
name|nextp1
argument_list|)
operator|=
name|prevp1
expr_stmt|;
name|NEXT
argument_list|(
name|prevp1
argument_list|)
operator|=
name|nextp1
expr_stmt|;
name|_malloc_rover
operator|=
name|nextp1
expr_stmt|;
block|}
name|_malloc_totalavail
operator|-=
name|SIZE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|SET_REALSIZE
argument_list|(
name|p0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|CHECKHEAP
argument_list|()
expr_stmt|;
name|PRTRACE
argument_list|(
name|sprintf
argument_list|(
name|_malloc_statsbuf
argument_list|,
literal|"++ %lu %lu 0x%lx %lu 0x%lx\n"
argument_list|,
operator|(
name|ulong
operator|)
name|nbytes
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|SIZE
argument_list|(
name|p0
argument_list|)
operator|-
name|ALLOC_OVERHEAD
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|cp
argument_list|,
operator|(
name|ulong
operator|)
name|SIZE
argument_list|(
name|p
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|,
operator|(
name|ulong
operator|)
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
comment|/* Have to do it the hard way */
name|tmp
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|MEMCPY
argument_list|(
name|tmp
argument_list|,
name|cp
argument_list|,
operator|(
operator|(
name|SIZE
argument_list|(
name|p0
argument_list|)
operator|-
name|ALLOC_OVERHEAD
operator|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  !! Given what we know about alignment, we should be able to do better  *  than memset and set words. Hopefully memset has been tuned.  */
end_comment

begin_function
name|univptr_t
name|calloc
parameter_list|(
name|nelem
parameter_list|,
name|elsize
parameter_list|)
name|size_t
name|nelem
decl_stmt|,
name|elsize
decl_stmt|;
block|{
name|REGISTER
name|size_t
name|nbytes
init|=
name|nelem
operator|*
name|elsize
decl_stmt|;
name|REGISTER
name|univptr_t
name|cp
init|=
name|malloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
condition|)
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|univptr_t
operator|)
name|cp
argument_list|,
literal|0
argument_list|,
operator|(
name|memsize_t
operator|)
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Why would anyone want this.... ?  */
end_comment

begin_function
name|void
name|cfree
parameter_list|(
name|cp
parameter_list|)
name|univptr_t
name|cp
decl_stmt|;
block|{
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

