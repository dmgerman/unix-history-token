begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  Author: Mark Moraes<moraes@csri.toronto.edu> */
end_comment

begin_comment
comment|/*LINTLIBRARY*/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_macro
name|RCSID
argument_list|(
literal|"$Id: memalign.c,v 1.13 1993/05/23 03:38:27 moraes Exp $"
argument_list|)
end_macro

begin_comment
comment|/*   * !! memalign may leave small (< _malloc_minchunk) blocks as garbage.  * Not worth fixing now -- I've only seen two applications call valloc()  * or memalign(), and they do it only once in their life.  */
end_comment

begin_comment
comment|/*   * This is needed to be compatible with Sun mallocs - Dunno how many  * programs need it - the X server sure does... Returns a block 'size'  * bytes long, such that the address is a multiple of 'alignment'.  * (alignment MUST be a power of 2). This routine is possibly more  * convoluted than free() - certainly uglier. Since it is rarely called  * - possibly once in a program, it should be ok.  Since this is called  * from valloc() which is usually needed in conjunction with  * mmap()/munmap(), note the comment in the Sun manual page about  * freeing segments of size 128K and greater. Ugh.  */
end_comment

begin_function
name|univptr_t
name|memalign
parameter_list|(
name|alignment
parameter_list|,
name|size
parameter_list|)
name|size_t
name|alignment
decl_stmt|,
name|size
decl_stmt|;
block|{
name|univptr_t
name|cp
decl_stmt|;
name|univptr_t
name|addr
decl_stmt|;
name|REGISTER
name|Word
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|REGISTER
name|size_t
name|before
decl_stmt|,
name|after
decl_stmt|;
name|size_t
name|blksize
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|tmp_debugging
init|=
name|_malloc_debugging
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|alignment
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|||
operator|!
name|is_power_of_2
argument_list|(
name|alignment
argument_list|)
operator|||
name|size
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|alignment
operator|<
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
condition|)
return|return
operator|(
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
return|;
comment|/* We guarantee this alignment anyway */
comment|/*  	 *  Life starts to get complicated - need to get a block large 	 *  enough to hold a block 'size' long, starting on an 'alignment' 	 *  boundary 	 */
if|if
condition|(
operator|(
name|cp
operator|=
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|size
operator|+
name|alignment
operator|-
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|addr
operator|=
name|SIMPLEALIGN
argument_list|(
name|cp
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
comment|/*  	 *  This is all we really need - can go back now, except that we 	 *  might be wasting 'alignment - 1' bytes, which can be large since 	 *  this junk is usually called to align with things like pagesize. 	 *  So we try to push any free space before 'addr' and after 'addr + 	 *  size' back on the free list by making the memaligned chunk 	 *  ('addr' to 'addr + size') a block, and then doing stuff with the 	 *  space left over - either making them free blocks or coelescing 	 *  them whichever way is simplest. This usually involves making 	 *  them look like allocated blocks and calling free() which has all 	 *  the code to deal with this, and should do it reasonably fast. 	 */
name|p0
operator|=
operator|(
name|Word
operator|*
operator|)
name|cp
expr_stmt|;
name|p0
operator|-=
name|HEADERWORDS
expr_stmt|;
comment|/* 	 *  p0 now points to the word tag starting the block which we got 	 *  from malloc. This remains invariant from now on - p1 is our 	 *  temporary pointer 	 */
name|p1
operator|=
operator|(
name|Word
operator|*
operator|)
name|addr
expr_stmt|;
name|p1
operator|-=
name|HEADERWORDS
expr_stmt|;
name|blksize
operator|=
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
expr_stmt|;
name|before
operator|=
name|p1
operator|-
name|p0
expr_stmt|;
name|after
operator|=
name|SIZE
argument_list|(
name|p0
argument_list|)
operator|-
name|ALLOC_OVERHEAD
operator|-
name|blksize
operator|-
name|before
expr_stmt|;
comment|/* 	 *  p1 now points to the word before addr - this is going to be the 	 *  start of the memaligned block 	 */
if|if
condition|(
name|after
operator|<
name|_malloc_minchunk
condition|)
block|{
comment|/* 		 * We merge the extra space after the memaligned block into it 		 * since that space isn't enough for a separate block. Note 		 * that if the block after the one malloc returned is free, we 		 * might be able to merge the space into that block even if it 		 * is too small - unfortunately, free() won't accept a block of 		 * this size, and I don't want to do that code here, so we'll 		 * just let it go to waste in the memaligned block. !! fix later, maybe 		 */
name|blksize
operator|+=
name|after
expr_stmt|;
name|after
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  We mark the newly carved memaligned block p1 as alloced. addr is 	 *  (p1 + 1) which is the address we'll return 	 */
name|SIZEFIELD
argument_list|(
name|p1
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|blksize
operator|+
name|ALLOC_OVERHEAD
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p1
operator|+
name|blksize
operator|+
name|ALLOC_OVERHEAD
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|SET_REALSIZE
argument_list|(
name|p1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|>
literal|0
condition|)
block|{
comment|/* We can now free the block after the memaligned block. */
name|p1
operator|+=
name|blksize
operator|+
name|ALLOC_OVERHEAD
expr_stmt|;
comment|/* SIZE(p1) */
comment|/*  		 * p1 now points to the space after the memaligned block. we 		 * fix the size, mark it alloced, and call free - the block 		 * after this may be free, which isn't simple to coalesce - let 		 * free() do it. 		 */
name|SIZEFIELD
argument_list|(
name|p1
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p1
operator|+
name|after
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|SET_REALSIZE
argument_list|(
name|p1
argument_list|,
operator|(
name|after
operator|-
name|ALLOC_OVERHEAD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Full heap checking will break till we finish memalign */
name|_malloc_debugging
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|free
argument_list|(
call|(
name|univptr_t
call|)
argument_list|(
name|p1
operator|+
name|HEADERWORDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
name|cp
condition|)
block|{
comment|/* 		 *  If what's 'before' is large enough to be freed, add p0 to 		 *  free list after changing its size to just consist of the 		 *  space before the memaligned block, also setting the 		 *  alloced flag. Then call free() -- may merge with preceding 		 *  block. (block after it is the memaligned block) 		 */
comment|/*  		 *  Else the space before the block is too small to form a 		 *  free block, and the preceding block isn't free, so we 		 *  aren't touching it. Theoretically, we could put it in 		 *  the preceding alloc'ed block, but there are painful 		 *  complications if this is the start of the arena. We 		 *  pass, but MUST mark it as allocated. This sort of garbage 		 *  can split up the arena -- fix later with special case maybe?!! 		 */
name|p1
operator|=
name|p0
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p1
argument_list|)
operator|=
name|ALLOCMASK
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|SIZEFIELD
argument_list|(
name|p1
operator|+
name|before
operator|-
literal|1
argument_list|)
operator|=
name|SIZEFIELD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|SET_REALSIZE
argument_list|(
name|p1
argument_list|,
operator|(
name|before
operator|-
name|ALLOC_OVERHEAD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Word
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
operator|>=
name|_malloc_minchunk
condition|)
block|{
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|_malloc_debugging
operator|=
name|tmp_debugging
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Just following the Sun manual page here */
end_comment

begin_function
name|univptr_t
name|valloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|static
name|size_t
name|pagesz
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pagesz
operator|==
literal|0
condition|)
name|pagesz
operator|=
operator|(
name|size_t
operator|)
name|getpagesize
argument_list|()
expr_stmt|;
return|return
operator|(
name|memalign
argument_list|(
name|pagesz
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

