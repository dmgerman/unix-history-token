begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===- InstrProfilingFile.c - Write instrumentation to a file -------------===*\ |* |*                     The LLVM Compiler Infrastructure |* |* This file is distributed under the University of Illinois Open Source |* License. See LICENSE.TXT for details. |* \*===----------------------------------------------------------------------===*/
end_comment

begin_include
include|#
directive|include
file|"InstrProfiling.h"
end_include

begin_include
include|#
directive|include
file|"InstrProfilingInternal.h"
end_include

begin_include
include|#
directive|include
file|"InstrProfilingUtil.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* For _alloca. */
end_comment

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
end_if

begin_include
include|#
directive|include
file|"WindowsMMap.h"
end_include

begin_comment
comment|/* For _chsize_s */
end_comment

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From where is profile name specified.  * The order the enumerators define their  * precedence. Re-order them may lead to  * runtime behavior change. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|ProfileNameSpecifier
block|{
name|PNS_unknown
init|=
literal|0
block|,
name|PNS_default
block|,
name|PNS_command_line
block|,
name|PNS_environment
block|,
name|PNS_runtime_api
block|}
name|ProfileNameSpecifier
typedef|;
end_typedef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getPNSStr
parameter_list|(
name|ProfileNameSpecifier
name|PNS
parameter_list|)
block|{
switch|switch
condition|(
name|PNS
condition|)
block|{
case|case
name|PNS_default
case|:
return|return
literal|"default setting"
return|;
case|case
name|PNS_command_line
case|:
return|return
literal|"command line"
return|;
case|case
name|PNS_environment
case|:
return|return
literal|"environment variable"
return|;
case|case
name|PNS_runtime_api
case|:
return|return
literal|"runtime API"
return|;
default|default:
return|return
literal|"Unknown"
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAX_PID_SIZE
value|16
end_define

begin_comment
comment|/* Data structure holding the result of parsed filename pattern. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lprofFilename
block|{
comment|/* File name string possibly with %p or %h specifiers. */
specifier|const
name|char
modifier|*
name|FilenamePat
decl_stmt|;
comment|/* A flag indicating if FilenamePat's memory is allocated    * by runtime. */
name|unsigned
name|OwnsFilenamePat
decl_stmt|;
specifier|const
name|char
modifier|*
name|ProfilePathPrefix
decl_stmt|;
name|char
name|PidChars
index|[
name|MAX_PID_SIZE
index|]
decl_stmt|;
name|char
name|Hostname
index|[
name|COMPILER_RT_MAX_HOSTLEN
index|]
decl_stmt|;
name|unsigned
name|NumPids
decl_stmt|;
name|unsigned
name|NumHosts
decl_stmt|;
comment|/* When in-process merging is enabled, this parameter specifies    * the total number of profile data files shared by all the processes    * spawned from the same binary. By default the value is 1. If merging    * is not enabled, its value should be 0. This parameter is specified    * by the %[0-9]m specifier. For instance %2m enables merging using    * 2 profile data files. %1m is equivalent to %m. Also %m specifier    * can only appear once at the end of the name pattern. */
name|unsigned
name|MergePoolSize
decl_stmt|;
name|ProfileNameSpecifier
name|PNS
decl_stmt|;
block|}
name|lprofFilename
typedef|;
end_typedef

begin_decl_stmt
name|COMPILER_RT_WEAK
name|lprofFilename
name|lprofCurFilename
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PNS_unknown
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|getpid
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getCurFilenameLength
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|getCurFilename
parameter_list|(
name|char
modifier|*
name|FilenameBuf
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|unsigned
name|doMerging
parameter_list|()
block|{
return|return
name|lprofCurFilename
operator|.
name|MergePoolSize
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if there is an error, otherwise return  0.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|fileWriter
parameter_list|(
name|ProfDataIOVec
modifier|*
name|IOVecs
parameter_list|,
name|uint32_t
name|NumIOVecs
parameter_list|,
name|void
modifier|*
modifier|*
name|WriterCtx
parameter_list|)
block|{
name|uint32_t
name|I
decl_stmt|;
name|FILE
modifier|*
name|File
init|=
operator|(
name|FILE
operator|*
operator|)
operator|*
name|WriterCtx
decl_stmt|;
for|for
control|(
name|I
operator|=
literal|0
init|;
name|I
operator|<
name|NumIOVecs
condition|;
name|I
operator|++
control|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|IOVecs
index|[
name|I
index|]
operator|.
name|Data
argument_list|,
name|IOVecs
index|[
name|I
index|]
operator|.
name|ElmSize
argument_list|,
name|IOVecs
index|[
name|I
index|]
operator|.
name|NumElm
argument_list|,
name|File
argument_list|)
operator|!=
name|IOVecs
index|[
name|I
index|]
operator|.
name|NumElm
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|COMPILER_RT_VISIBILITY
name|ProfBufferIO
modifier|*
name|lprofCreateBufferIOInternal
parameter_list|(
name|void
modifier|*
name|File
parameter_list|,
name|uint32_t
name|BufferSz
parameter_list|)
block|{
name|FreeHook
operator|=
operator|&
name|free
expr_stmt|;
name|DynamicBufferIOBuffer
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|calloc
argument_list|(
name|BufferSz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VPBufferSize
operator|=
name|BufferSz
expr_stmt|;
return|return
name|lprofCreateBufferIO
argument_list|(
name|fileWriter
argument_list|,
name|File
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setupIOBuffer
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|BufferSzStr
init|=
literal|0
decl_stmt|;
name|BufferSzStr
operator|=
name|getenv
argument_list|(
literal|"LLVM_VP_BUFFER_SIZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferSzStr
operator|&&
name|BufferSzStr
index|[
literal|0
index|]
condition|)
block|{
name|VPBufferSize
operator|=
name|atoi
argument_list|(
name|BufferSzStr
argument_list|)
expr_stmt|;
name|DynamicBufferIOBuffer
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|calloc
argument_list|(
name|VPBufferSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read profile data in \c ProfileFile and merge with in-memory    profile counters. Returns -1 if there is fatal error, otheriwse    0 is returned. */
end_comment

begin_function
specifier|static
name|int
name|doProfileMerging
parameter_list|(
name|FILE
modifier|*
name|ProfileFile
parameter_list|)
block|{
name|uint64_t
name|ProfileFileSize
decl_stmt|;
name|char
modifier|*
name|ProfileBuffer
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|ProfileFile
argument_list|,
literal|0L
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PROF_ERR
argument_list|(
literal|"Unable to merge profile data, unable to get size: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ProfileFileSize
operator|=
name|ftell
argument_list|(
name|ProfileFile
argument_list|)
expr_stmt|;
comment|/* Restore file offset.  */
if|if
condition|(
name|fseek
argument_list|(
name|ProfileFile
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PROF_ERR
argument_list|(
literal|"Unable to merge profile data, unable to rewind: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Nothing to merge.  */
if|if
condition|(
name|ProfileFileSize
operator|<
sizeof|sizeof
argument_list|(
name|__llvm_profile_header
argument_list|)
condition|)
block|{
if|if
condition|(
name|ProfileFileSize
condition|)
name|PROF_WARN
argument_list|(
literal|"Unable to merge profile data: %s\n"
argument_list|,
literal|"source profile file is too small."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ProfileBuffer
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|ProfileFileSize
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
operator||
name|MAP_FILE
argument_list|,
name|fileno
argument_list|(
name|ProfileFile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ProfileBuffer
operator|==
name|MAP_FAILED
condition|)
block|{
name|PROF_ERR
argument_list|(
literal|"Unable to merge profile data, mmap failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|__llvm_profile_check_compatibility
argument_list|(
name|ProfileBuffer
argument_list|,
name|ProfileFileSize
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|ProfileBuffer
argument_list|,
name|ProfileFileSize
argument_list|)
expr_stmt|;
name|PROF_WARN
argument_list|(
literal|"Unable to merge profile data: %s\n"
argument_list|,
literal|"source profile file is not compatible."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Now start merging */
name|__llvm_profile_merge_from_buffer
argument_list|(
name|ProfileBuffer
argument_list|,
name|ProfileFileSize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|ProfileBuffer
argument_list|,
name|ProfileFileSize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Create the directory holding the file, if needed. */
end_comment

begin_function
specifier|static
name|void
name|createProfileDir
parameter_list|(
specifier|const
name|char
modifier|*
name|Filename
parameter_list|)
block|{
name|size_t
name|Length
init|=
name|strlen
argument_list|(
name|Filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|lprofFindFirstDirSeparator
argument_list|(
name|Filename
argument_list|)
condition|)
block|{
name|char
modifier|*
name|Copy
init|=
operator|(
name|char
operator|*
operator|)
name|COMPILER_RT_ALLOCA
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|Copy
argument_list|,
name|Filename
argument_list|,
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|__llvm_profile_recursive_mkdir
argument_list|(
name|Copy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Open the profile data for merging. It opens the file in r+b mode with  * file locking.  If the file has content which is compatible with the  * current process, it also reads in the profile data in the file and merge  * it with in-memory counters. After the profile data is merged in memory,  * the original profile data is truncated and gets ready for the profile  * dumper. With profile merging enabled, each executable as well as any of  * its instrumented shared libraries dump profile data into their own data file. */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|openFileForMerging
parameter_list|(
specifier|const
name|char
modifier|*
name|ProfileFileName
parameter_list|)
block|{
name|FILE
modifier|*
name|ProfileFile
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|createProfileDir
argument_list|(
name|ProfileFileName
argument_list|)
expr_stmt|;
name|ProfileFile
operator|=
name|lprofOpenFileEx
argument_list|(
name|ProfileFileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ProfileFile
condition|)
return|return
name|NULL
return|;
name|rc
operator|=
name|doProfileMerging
argument_list|(
name|ProfileFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|COMPILER_RT_FTRUNCATE
argument_list|(
name|ProfileFile
argument_list|,
literal|0L
argument_list|)
operator|||
name|fseek
argument_list|(
name|ProfileFile
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PROF_ERR
argument_list|(
literal|"Profile Merging of file %s failed: %s\n"
argument_list|,
name|ProfileFileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ProfileFile
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fseek
argument_list|(
name|ProfileFile
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
return|return
name|ProfileFile
return|;
block|}
end_function

begin_comment
comment|/* Write profile data to file \c OutputName.  */
end_comment

begin_function
specifier|static
name|int
name|writeFile
parameter_list|(
specifier|const
name|char
modifier|*
name|OutputName
parameter_list|)
block|{
name|int
name|RetVal
decl_stmt|;
name|FILE
modifier|*
name|OutputFile
decl_stmt|;
if|if
condition|(
operator|!
name|doMerging
argument_list|()
condition|)
name|OutputFile
operator|=
name|fopen
argument_list|(
name|OutputName
argument_list|,
literal|"ab"
argument_list|)
expr_stmt|;
else|else
name|OutputFile
operator|=
name|openFileForMerging
argument_list|(
name|OutputName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OutputFile
condition|)
return|return
operator|-
literal|1
return|;
name|FreeHook
operator|=
operator|&
name|free
expr_stmt|;
name|setupIOBuffer
argument_list|()
expr_stmt|;
name|RetVal
operator|=
name|lprofWriteData
argument_list|(
name|fileWriter
argument_list|,
name|OutputFile
argument_list|,
name|lprofGetVPDataReader
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|OutputFile
argument_list|)
expr_stmt|;
return|return
name|RetVal
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|truncateCurrentFile
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|Filename
decl_stmt|;
name|char
modifier|*
name|FilenameBuf
decl_stmt|;
name|FILE
modifier|*
name|File
decl_stmt|;
name|int
name|Length
decl_stmt|;
name|Length
operator|=
name|getCurFilenameLength
argument_list|()
expr_stmt|;
name|FilenameBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|COMPILER_RT_ALLOCA
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Filename
operator|=
name|getCurFilename
argument_list|(
name|FilenameBuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Filename
condition|)
return|return;
comment|/* By pass file truncation to allow online raw profile    * merging. */
if|if
condition|(
name|lprofCurFilename
operator|.
name|MergePoolSize
condition|)
return|return;
name|createProfileDir
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
comment|/* Truncate the file.  Later we'll reopen and append. */
name|File
operator|=
name|fopen
argument_list|(
name|Filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|File
condition|)
return|return;
name|fclose
argument_list|(
name|File
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|DefaultProfileName
init|=
literal|"default.profraw"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|resetFilenameToDefault
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|lprofCurFilename
operator|.
name|FilenamePat
operator|&&
name|lprofCurFilename
operator|.
name|OwnsFilenamePat
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lprofCurFilename
operator|.
name|FilenamePat
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|lprofCurFilename
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lprofCurFilename
argument_list|)
argument_list|)
expr_stmt|;
name|lprofCurFilename
operator|.
name|FilenamePat
operator|=
name|DefaultProfileName
expr_stmt|;
name|lprofCurFilename
operator|.
name|PNS
operator|=
name|PNS_default
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|containsMergeSpecifier
parameter_list|(
specifier|const
name|char
modifier|*
name|FilenamePat
parameter_list|,
name|int
name|I
parameter_list|)
block|{
return|return
operator|(
name|FilenamePat
index|[
name|I
index|]
operator|==
literal|'m'
operator|||
operator|(
name|FilenamePat
index|[
name|I
index|]
operator|>=
literal|'1'
operator|&&
name|FilenamePat
index|[
name|I
index|]
operator|<=
literal|'9'
operator|&&
comment|/* If FilenamePat[I] is not '\0', the next byte is guaranteed             * to be in-bound as the string is null terminated. */
name|FilenamePat
index|[
name|I
operator|+
literal|1
index|]
operator|==
literal|'m'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the pattern string \p FilenamePat and stores the result to  * lprofcurFilename structure. */
end_comment

begin_function
specifier|static
name|int
name|parseFilenamePattern
parameter_list|(
specifier|const
name|char
modifier|*
name|FilenamePat
parameter_list|,
name|unsigned
name|CopyFilenamePat
parameter_list|)
block|{
name|int
name|NumPids
init|=
literal|0
decl_stmt|,
name|NumHosts
init|=
literal|0
decl_stmt|,
name|I
decl_stmt|;
name|char
modifier|*
name|PidChars
init|=
operator|&
name|lprofCurFilename
operator|.
name|PidChars
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|Hostname
init|=
operator|&
name|lprofCurFilename
operator|.
name|Hostname
index|[
literal|0
index|]
decl_stmt|;
name|int
name|MergingEnabled
init|=
literal|0
decl_stmt|;
comment|/* Clean up cached prefix.  */
if|if
condition|(
name|lprofCurFilename
operator|.
name|ProfilePathPrefix
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lprofCurFilename
operator|.
name|ProfilePathPrefix
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|lprofCurFilename
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lprofCurFilename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lprofCurFilename
operator|.
name|FilenamePat
operator|&&
name|lprofCurFilename
operator|.
name|OwnsFilenamePat
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lprofCurFilename
operator|.
name|FilenamePat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CopyFilenamePat
condition|)
name|lprofCurFilename
operator|.
name|FilenamePat
operator|=
name|FilenamePat
expr_stmt|;
else|else
block|{
name|lprofCurFilename
operator|.
name|FilenamePat
operator|=
name|strdup
argument_list|(
name|FilenamePat
argument_list|)
expr_stmt|;
name|lprofCurFilename
operator|.
name|OwnsFilenamePat
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check the filename for "%p", which indicates a pid-substitution. */
for|for
control|(
name|I
operator|=
literal|0
init|;
name|FilenamePat
index|[
name|I
index|]
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|FilenamePat
index|[
name|I
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|FilenamePat
index|[
operator|++
name|I
index|]
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
operator|!
name|NumPids
operator|++
condition|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|PidChars
argument_list|,
name|MAX_PID_SIZE
argument_list|,
literal|"%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|PROF_WARN
argument_list|(
literal|"Unable to get pid for filename pattern %s. Using the "
literal|"default name."
argument_list|,
name|FilenamePat
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|FilenamePat
index|[
name|I
index|]
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
operator|!
name|NumHosts
operator|++
condition|)
if|if
condition|(
name|COMPILER_RT_GETHOSTNAME
argument_list|(
name|Hostname
argument_list|,
name|COMPILER_RT_MAX_HOSTLEN
argument_list|)
condition|)
block|{
name|PROF_WARN
argument_list|(
literal|"Unable to get hostname for filename pattern %s. Using "
literal|"the default name."
argument_list|,
name|FilenamePat
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|containsMergeSpecifier
argument_list|(
name|FilenamePat
argument_list|,
name|I
argument_list|)
condition|)
block|{
if|if
condition|(
name|MergingEnabled
condition|)
block|{
name|PROF_WARN
argument_list|(
literal|"%%m specifier can only be specified once in %s.\n"
argument_list|,
name|FilenamePat
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|MergingEnabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FilenamePat
index|[
name|I
index|]
operator|==
literal|'m'
condition|)
name|lprofCurFilename
operator|.
name|MergePoolSize
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|lprofCurFilename
operator|.
name|MergePoolSize
operator|=
name|FilenamePat
index|[
name|I
index|]
operator|-
literal|'0'
expr_stmt|;
name|I
operator|++
expr_stmt|;
comment|/* advance to 'm' */
block|}
block|}
block|}
name|lprofCurFilename
operator|.
name|NumPids
operator|=
name|NumPids
expr_stmt|;
name|lprofCurFilename
operator|.
name|NumHosts
operator|=
name|NumHosts
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parseAndSetFilename
parameter_list|(
specifier|const
name|char
modifier|*
name|FilenamePat
parameter_list|,
name|ProfileNameSpecifier
name|PNS
parameter_list|,
name|unsigned
name|CopyFilenamePat
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|OldFilenamePat
init|=
name|lprofCurFilename
operator|.
name|FilenamePat
decl_stmt|;
name|ProfileNameSpecifier
name|OldPNS
init|=
name|lprofCurFilename
operator|.
name|PNS
decl_stmt|;
if|if
condition|(
name|PNS
operator|<
name|OldPNS
condition|)
return|return;
if|if
condition|(
operator|!
name|FilenamePat
condition|)
name|FilenamePat
operator|=
name|DefaultProfileName
expr_stmt|;
if|if
condition|(
name|OldFilenamePat
operator|&&
operator|!
name|strcmp
argument_list|(
name|OldFilenamePat
argument_list|,
name|FilenamePat
argument_list|)
condition|)
block|{
name|lprofCurFilename
operator|.
name|PNS
operator|=
name|PNS
expr_stmt|;
return|return;
block|}
comment|/* When PNS>= OldPNS, the last one wins. */
if|if
condition|(
operator|!
name|FilenamePat
operator|||
name|parseFilenamePattern
argument_list|(
name|FilenamePat
argument_list|,
name|CopyFilenamePat
argument_list|)
condition|)
name|resetFilenameToDefault
argument_list|()
expr_stmt|;
name|lprofCurFilename
operator|.
name|PNS
operator|=
name|PNS
expr_stmt|;
if|if
condition|(
operator|!
name|OldFilenamePat
condition|)
block|{
if|if
condition|(
name|getenv
argument_list|(
literal|"LLVM_PROFILE_VERBOSE"
argument_list|)
condition|)
name|PROF_NOTE
argument_list|(
literal|"Set profile file path to \"%s\" via %s.\n"
argument_list|,
name|lprofCurFilename
operator|.
name|FilenamePat
argument_list|,
name|getPNSStr
argument_list|(
name|PNS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|getenv
argument_list|(
literal|"LLVM_PROFILE_VERBOSE"
argument_list|)
condition|)
name|PROF_NOTE
argument_list|(
literal|"Override old profile path \"%s\" via %s to \"%s\" via %s.\n"
argument_list|,
name|OldFilenamePat
argument_list|,
name|getPNSStr
argument_list|(
name|OldPNS
argument_list|)
argument_list|,
name|lprofCurFilename
operator|.
name|FilenamePat
argument_list|,
name|getPNSStr
argument_list|(
name|PNS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|truncateCurrentFile
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return buffer length that is required to store the current profile  * filename with PID and hostname substitutions. */
end_comment

begin_comment
comment|/* The length to hold uint64_t followed by 2 digit pool id including '_' */
end_comment

begin_define
define|#
directive|define
name|SIGLEN
value|24
end_define

begin_function
specifier|static
name|int
name|getCurFilenameLength
parameter_list|()
block|{
name|int
name|Len
decl_stmt|;
if|if
condition|(
operator|!
name|lprofCurFilename
operator|.
name|FilenamePat
operator|||
operator|!
name|lprofCurFilename
operator|.
name|FilenamePat
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|lprofCurFilename
operator|.
name|NumPids
operator|||
name|lprofCurFilename
operator|.
name|NumHosts
operator|||
name|lprofCurFilename
operator|.
name|MergePoolSize
operator|)
condition|)
return|return
name|strlen
argument_list|(
name|lprofCurFilename
operator|.
name|FilenamePat
argument_list|)
return|;
name|Len
operator|=
name|strlen
argument_list|(
name|lprofCurFilename
operator|.
name|FilenamePat
argument_list|)
operator|+
name|lprofCurFilename
operator|.
name|NumPids
operator|*
operator|(
name|strlen
argument_list|(
name|lprofCurFilename
operator|.
name|PidChars
argument_list|)
operator|-
literal|2
operator|)
operator|+
name|lprofCurFilename
operator|.
name|NumHosts
operator|*
operator|(
name|strlen
argument_list|(
name|lprofCurFilename
operator|.
name|Hostname
argument_list|)
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|lprofCurFilename
operator|.
name|MergePoolSize
condition|)
name|Len
operator|+=
name|SIGLEN
expr_stmt|;
return|return
name|Len
return|;
block|}
end_function

begin_comment
comment|/* Return the pointer to the current profile file name (after substituting  * PIDs and Hostnames in filename pattern. \p FilenameBuf is the buffer  * to store the resulting filename. If no substitution is needed, the  * current filename pattern string is directly returned. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getCurFilename
parameter_list|(
name|char
modifier|*
name|FilenameBuf
parameter_list|)
block|{
name|int
name|I
decl_stmt|,
name|J
decl_stmt|,
name|PidLength
decl_stmt|,
name|HostNameLength
decl_stmt|;
specifier|const
name|char
modifier|*
name|FilenamePat
init|=
name|lprofCurFilename
operator|.
name|FilenamePat
decl_stmt|;
if|if
condition|(
operator|!
name|lprofCurFilename
operator|.
name|FilenamePat
operator|||
operator|!
name|lprofCurFilename
operator|.
name|FilenamePat
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|lprofCurFilename
operator|.
name|NumPids
operator|||
name|lprofCurFilename
operator|.
name|NumHosts
operator|||
name|lprofCurFilename
operator|.
name|MergePoolSize
operator|)
condition|)
return|return
name|lprofCurFilename
operator|.
name|FilenamePat
return|;
name|PidLength
operator|=
name|strlen
argument_list|(
name|lprofCurFilename
operator|.
name|PidChars
argument_list|)
expr_stmt|;
name|HostNameLength
operator|=
name|strlen
argument_list|(
name|lprofCurFilename
operator|.
name|Hostname
argument_list|)
expr_stmt|;
comment|/* Construct the new filename. */
for|for
control|(
name|I
operator|=
literal|0
operator|,
name|J
operator|=
literal|0
init|;
name|FilenamePat
index|[
name|I
index|]
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|FilenamePat
index|[
name|I
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|FilenamePat
index|[
operator|++
name|I
index|]
operator|==
literal|'p'
condition|)
block|{
name|memcpy
argument_list|(
name|FilenameBuf
operator|+
name|J
argument_list|,
name|lprofCurFilename
operator|.
name|PidChars
argument_list|,
name|PidLength
argument_list|)
expr_stmt|;
name|J
operator|+=
name|PidLength
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FilenamePat
index|[
name|I
index|]
operator|==
literal|'h'
condition|)
block|{
name|memcpy
argument_list|(
name|FilenameBuf
operator|+
name|J
argument_list|,
name|lprofCurFilename
operator|.
name|Hostname
argument_list|,
name|HostNameLength
argument_list|)
expr_stmt|;
name|J
operator|+=
name|HostNameLength
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|containsMergeSpecifier
argument_list|(
name|FilenamePat
argument_list|,
name|I
argument_list|)
condition|)
block|{
name|char
name|LoadModuleSignature
index|[
name|SIGLEN
index|]
decl_stmt|;
name|int
name|S
decl_stmt|;
name|int
name|ProfilePoolId
init|=
name|getpid
argument_list|()
operator|%
name|lprofCurFilename
operator|.
name|MergePoolSize
decl_stmt|;
name|S
operator|=
name|snprintf
argument_list|(
name|LoadModuleSignature
argument_list|,
name|SIGLEN
argument_list|,
literal|"%"
name|PRIu64
literal|"_%d"
argument_list|,
name|lprofGetLoadModuleSignature
argument_list|()
argument_list|,
name|ProfilePoolId
argument_list|)
expr_stmt|;
if|if
condition|(
name|S
operator|==
operator|-
literal|1
operator|||
name|S
operator|>
name|SIGLEN
condition|)
name|S
operator|=
name|SIGLEN
expr_stmt|;
name|memcpy
argument_list|(
name|FilenameBuf
operator|+
name|J
argument_list|,
name|LoadModuleSignature
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|J
operator|+=
name|S
expr_stmt|;
if|if
condition|(
name|FilenamePat
index|[
name|I
index|]
operator|!=
literal|'m'
condition|)
name|I
operator|++
expr_stmt|;
block|}
comment|/* Drop any unknown substitutions. */
block|}
else|else
name|FilenameBuf
index|[
name|J
operator|++
index|]
operator|=
name|FilenamePat
index|[
name|I
index|]
expr_stmt|;
name|FilenameBuf
index|[
name|J
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|FilenameBuf
return|;
block|}
end_function

begin_comment
comment|/* Returns the pointer to the environment variable  * string. Returns null if the env var is not set. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getFilenamePatFromEnv
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|Filename
init|=
name|getenv
argument_list|(
literal|"LLVM_PROFILE_FILE"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Filename
operator|||
operator|!
name|Filename
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
return|return
name|Filename
return|;
block|}
end_function

begin_function
name|COMPILER_RT_VISIBILITY
specifier|const
name|char
modifier|*
name|__llvm_profile_get_path_prefix
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|Length
decl_stmt|;
name|char
modifier|*
name|FilenameBuf
decl_stmt|,
modifier|*
name|Prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|Filename
decl_stmt|,
modifier|*
name|PrefixEnd
decl_stmt|;
if|if
condition|(
name|lprofCurFilename
operator|.
name|ProfilePathPrefix
condition|)
return|return
name|lprofCurFilename
operator|.
name|ProfilePathPrefix
return|;
name|Length
operator|=
name|getCurFilenameLength
argument_list|()
expr_stmt|;
name|FilenameBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|COMPILER_RT_ALLOCA
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Filename
operator|=
name|getCurFilename
argument_list|(
name|FilenameBuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Filename
condition|)
return|return
literal|"\0"
return|;
name|PrefixEnd
operator|=
name|lprofFindLastDirSeparator
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PrefixEnd
condition|)
return|return
literal|"\0"
return|;
name|Length
operator|=
name|PrefixEnd
operator|-
name|Filename
operator|+
literal|1
expr_stmt|;
name|Prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Prefix
condition|)
block|{
name|PROF_ERR
argument_list|(
literal|"Failed to %s\n"
argument_list|,
literal|"allocate memory."
argument_list|)
expr_stmt|;
return|return
literal|"\0"
return|;
block|}
name|memcpy
argument_list|(
name|Prefix
argument_list|,
name|Filename
argument_list|,
name|Length
argument_list|)
expr_stmt|;
name|Prefix
index|[
name|Length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lprofCurFilename
operator|.
name|ProfilePathPrefix
operator|=
name|Prefix
expr_stmt|;
return|return
name|Prefix
return|;
block|}
end_function

begin_comment
comment|/* This method is invoked by the runtime initialization hook  * InstrProfilingRuntime.o if it is linked in. Both user specified  * profile path via -fprofile-instr-generate= and LLVM_PROFILE_FILE  * environment variable can override this default value. */
end_comment

begin_function
name|COMPILER_RT_VISIBILITY
name|void
name|__llvm_profile_initialize_file
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|EnvFilenamePat
decl_stmt|;
specifier|const
name|char
modifier|*
name|SelectedPat
init|=
name|NULL
decl_stmt|;
name|ProfileNameSpecifier
name|PNS
init|=
name|PNS_unknown
decl_stmt|;
name|int
name|hasCommandLineOverrider
init|=
operator|(
name|INSTR_PROF_PROFILE_NAME_VAR
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
decl_stmt|;
name|EnvFilenamePat
operator|=
name|getFilenamePatFromEnv
argument_list|()
expr_stmt|;
if|if
condition|(
name|EnvFilenamePat
condition|)
block|{
name|SelectedPat
operator|=
name|EnvFilenamePat
expr_stmt|;
name|PNS
operator|=
name|PNS_environment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasCommandLineOverrider
condition|)
block|{
name|SelectedPat
operator|=
name|INSTR_PROF_PROFILE_NAME_VAR
expr_stmt|;
name|PNS
operator|=
name|PNS_command_line
expr_stmt|;
block|}
else|else
block|{
name|SelectedPat
operator|=
name|NULL
expr_stmt|;
name|PNS
operator|=
name|PNS_default
expr_stmt|;
block|}
name|parseAndSetFilename
argument_list|(
name|SelectedPat
argument_list|,
name|PNS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This API is directly called by the user application code. It has the  * highest precedence compared with LLVM_PROFILE_FILE environment variable  * and command line option -fprofile-instr-generate=<profile_name>.  */
end_comment

begin_function
name|COMPILER_RT_VISIBILITY
name|void
name|__llvm_profile_set_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|FilenamePat
parameter_list|)
block|{
name|parseAndSetFilename
argument_list|(
name|FilenamePat
argument_list|,
name|PNS_runtime_api
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The public API for writing profile data into the file with name  * set by previous calls to __llvm_profile_set_filename or  * __llvm_profile_override_default_filename or  * __llvm_profile_initialize_file. */
end_comment

begin_function
name|COMPILER_RT_VISIBILITY
name|int
name|__llvm_profile_write_file
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|Length
decl_stmt|;
specifier|const
name|char
modifier|*
name|Filename
decl_stmt|;
name|char
modifier|*
name|FilenameBuf
decl_stmt|;
name|int
name|PDeathSig
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lprofProfileDumped
argument_list|()
condition|)
block|{
name|PROF_NOTE
argument_list|(
literal|"Profile data not written to file: %s.\n"
argument_list|,
literal|"already written"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Length
operator|=
name|getCurFilenameLength
argument_list|()
expr_stmt|;
name|FilenameBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|COMPILER_RT_ALLOCA
argument_list|(
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Filename
operator|=
name|getCurFilename
argument_list|(
name|FilenameBuf
argument_list|)
expr_stmt|;
comment|/* Check the filename. */
if|if
condition|(
operator|!
name|Filename
condition|)
block|{
name|PROF_ERR
argument_list|(
literal|"Failed to write file : %s\n"
argument_list|,
literal|"Filename not set"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if there is llvm/runtime version mismatch.  */
if|if
condition|(
name|GET_VERSION
argument_list|(
name|__llvm_profile_get_version
argument_list|()
argument_list|)
operator|!=
name|INSTR_PROF_RAW_VERSION
condition|)
block|{
name|PROF_ERR
argument_list|(
literal|"Runtime and instrumentation version mismatch : "
literal|"expected %d, but get %d\n"
argument_list|,
name|INSTR_PROF_RAW_VERSION
argument_list|,
operator|(
name|int
operator|)
name|GET_VERSION
argument_list|(
name|__llvm_profile_get_version
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// Temporarily suspend getting SIGKILL when the parent exits.
name|PDeathSig
operator|=
name|lprofSuspendSigKill
argument_list|()
expr_stmt|;
comment|/* Write profile data to the file. */
name|rc
operator|=
name|writeFile
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|PROF_ERR
argument_list|(
literal|"Failed to write file \"%s\": %s\n"
argument_list|,
name|Filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|// Restore SIGKILL.
if|if
condition|(
name|PDeathSig
operator|==
literal|1
condition|)
name|lprofRestoreSigKill
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|COMPILER_RT_VISIBILITY
name|int
name|__llvm_profile_dump
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|doMerging
argument_list|()
condition|)
name|PROF_WARN
argument_list|(
literal|"Later invocation of __llvm_profile_dump can lead to clobbering "
literal|" of previously dumped profile data : %s. Either use %%m "
literal|"in profile name or change profile name before dumping.\n"
argument_list|,
literal|"online profile merging is not on"
argument_list|)
expr_stmt|;
name|int
name|rc
init|=
name|__llvm_profile_write_file
argument_list|()
decl_stmt|;
name|lprofSetProfileDumped
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writeFileWithoutReturn
parameter_list|(
name|void
parameter_list|)
block|{
name|__llvm_profile_write_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|COMPILER_RT_VISIBILITY
name|int
name|__llvm_profile_register_write_file_atexit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|HasBeenRegistered
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|HasBeenRegistered
condition|)
return|return
literal|0
return|;
name|lprofSetupValueProfiler
argument_list|()
expr_stmt|;
name|HasBeenRegistered
operator|=
literal|1
expr_stmt|;
return|return
name|atexit
argument_list|(
name|writeFileWithoutReturn
argument_list|)
return|;
block|}
end_function

end_unit

