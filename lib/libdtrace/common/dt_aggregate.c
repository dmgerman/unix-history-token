begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, Joyent, Inc. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|DTRACE_AHASHSIZE
value|32779
end_define

begin_comment
comment|/* big 'ol prime */
end_comment

begin_comment
comment|/*  * Because qsort(3C) does not allow an argument to be passed to a comparison  * function, the variables that affect comparison must regrettably be global;  * they are protected by a global static lock, dt_qsort_lock.  */
end_comment

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|dt_qsort_lock
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dt_revsort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dt_keysort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dt_keypos
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DT_LESSTHAN
value|(dt_revsort == 0 ? -1 : 1)
end_define

begin_define
define|#
directive|define
name|DT_GREATERTHAN
value|(dt_revsort == 0 ? 1 : -1)
end_define

begin_function
specifier|static
name|void
name|dt_aggregate_count
parameter_list|(
name|int64_t
modifier|*
name|existing
parameter_list|,
name|int64_t
modifier|*
name|new
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|existing
index|[
name|i
index|]
operator|=
name|existing
index|[
name|i
index|]
operator|+
name|new
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_countcmp
parameter_list|(
name|int64_t
modifier|*
name|lhs
parameter_list|,
name|int64_t
modifier|*
name|rhs
parameter_list|)
block|{
name|int64_t
name|lvar
init|=
operator|*
name|lhs
decl_stmt|;
name|int64_t
name|rvar
init|=
operator|*
name|rhs
decl_stmt|;
if|if
condition|(
name|lvar
operator|<
name|rvar
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lvar
operator|>
name|rvar
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_aggregate_min
parameter_list|(
name|int64_t
modifier|*
name|existing
parameter_list|,
name|int64_t
modifier|*
name|new
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
operator|*
name|new
operator|<
operator|*
name|existing
condition|)
operator|*
name|existing
operator|=
operator|*
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_aggregate_max
parameter_list|(
name|int64_t
modifier|*
name|existing
parameter_list|,
name|int64_t
modifier|*
name|new
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
operator|*
name|new
operator|>
operator|*
name|existing
condition|)
operator|*
name|existing
operator|=
operator|*
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_averagecmp
parameter_list|(
name|int64_t
modifier|*
name|lhs
parameter_list|,
name|int64_t
modifier|*
name|rhs
parameter_list|)
block|{
name|int64_t
name|lavg
init|=
name|lhs
index|[
literal|0
index|]
condition|?
operator|(
name|lhs
index|[
literal|1
index|]
operator|/
name|lhs
index|[
literal|0
index|]
operator|)
else|:
literal|0
decl_stmt|;
name|int64_t
name|ravg
init|=
name|rhs
index|[
literal|0
index|]
condition|?
operator|(
name|rhs
index|[
literal|1
index|]
operator|/
name|rhs
index|[
literal|0
index|]
operator|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|lavg
operator|<
name|ravg
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lavg
operator|>
name|ravg
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_stddevcmp
parameter_list|(
name|int64_t
modifier|*
name|lhs
parameter_list|,
name|int64_t
modifier|*
name|rhs
parameter_list|)
block|{
name|uint64_t
name|lsd
init|=
name|dt_stddev
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|lhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|uint64_t
name|rsd
init|=
name|dt_stddev
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|lsd
operator|<
name|rsd
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lsd
operator|>
name|rsd
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_aggregate_lquantize
parameter_list|(
name|int64_t
modifier|*
name|existing
parameter_list|,
name|int64_t
modifier|*
name|new
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int64_t
name|arg
init|=
operator|*
name|existing
operator|++
decl_stmt|;
name|uint16_t
name|levels
init|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|levels
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|existing
index|[
name|i
index|]
operator|=
name|existing
index|[
name|i
index|]
operator|+
name|new
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|dt_aggregate_lquantizedsum
parameter_list|(
name|int64_t
modifier|*
name|lquanta
parameter_list|)
block|{
name|int64_t
name|arg
init|=
operator|*
name|lquanta
operator|++
decl_stmt|;
name|int32_t
name|base
init|=
name|DTRACE_LQUANTIZE_BASE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|step
init|=
name|DTRACE_LQUANTIZE_STEP
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|levels
init|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|arg
argument_list|)
decl_stmt|,
name|i
decl_stmt|;
name|long
name|double
name|total
init|=
operator|(
name|long
name|double
operator|)
name|lquanta
index|[
literal|0
index|]
operator|*
call|(
name|long
name|double
call|)
argument_list|(
name|base
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|levels
condition|;
name|base
operator|+=
name|step
operator|,
name|i
operator|++
control|)
name|total
operator|+=
operator|(
name|long
name|double
operator|)
name|lquanta
index|[
name|i
operator|+
literal|1
index|]
operator|*
operator|(
name|long
name|double
operator|)
name|base
expr_stmt|;
return|return
operator|(
name|total
operator|+
operator|(
name|long
name|double
operator|)
name|lquanta
index|[
name|levels
operator|+
literal|1
index|]
operator|*
call|(
name|long
name|double
call|)
argument_list|(
name|base
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|dt_aggregate_lquantizedzero
parameter_list|(
name|int64_t
modifier|*
name|lquanta
parameter_list|)
block|{
name|int64_t
name|arg
init|=
operator|*
name|lquanta
operator|++
decl_stmt|;
name|int32_t
name|base
init|=
name|DTRACE_LQUANTIZE_BASE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|step
init|=
name|DTRACE_LQUANTIZE_STEP
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|levels
init|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|arg
argument_list|)
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|base
operator|-
literal|1
operator|==
literal|0
condition|)
return|return
operator|(
name|lquanta
index|[
literal|0
index|]
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|levels
condition|;
name|base
operator|+=
name|step
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|base
operator|!=
literal|0
condition|)
continue|continue;
return|return
operator|(
name|lquanta
index|[
name|i
operator|+
literal|1
index|]
operator|)
return|;
block|}
if|if
condition|(
name|base
operator|+
literal|1
operator|==
literal|0
condition|)
return|return
operator|(
name|lquanta
index|[
name|levels
operator|+
literal|1
index|]
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_lquantizedcmp
parameter_list|(
name|int64_t
modifier|*
name|lhs
parameter_list|,
name|int64_t
modifier|*
name|rhs
parameter_list|)
block|{
name|long
name|double
name|lsum
init|=
name|dt_aggregate_lquantizedsum
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|long
name|double
name|rsum
init|=
name|dt_aggregate_lquantizedsum
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|int64_t
name|lzero
decl_stmt|,
name|rzero
decl_stmt|;
if|if
condition|(
name|lsum
operator|<
name|rsum
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lsum
operator|>
name|rsum
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
comment|/* 	 * If they're both equal, then we will compare based on the weights at 	 * zero.  If the weights at zero are equal (or if zero is not within 	 * the range of the linear quantization), then this will be judged a 	 * tie and will be resolved based on the key comparison. 	 */
name|lzero
operator|=
name|dt_aggregate_lquantizedzero
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|rzero
operator|=
name|dt_aggregate_lquantizedzero
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lzero
operator|<
name|rzero
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lzero
operator|>
name|rzero
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_aggregate_llquantize
parameter_list|(
name|int64_t
modifier|*
name|existing
parameter_list|,
name|int64_t
modifier|*
name|new
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
operator|/
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|existing
index|[
name|i
index|]
operator|=
name|existing
index|[
name|i
index|]
operator|+
name|new
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|double
name|dt_aggregate_llquantizedsum
parameter_list|(
name|int64_t
modifier|*
name|llquanta
parameter_list|)
block|{
name|int64_t
name|arg
init|=
operator|*
name|llquanta
operator|++
decl_stmt|;
name|uint16_t
name|factor
init|=
name|DTRACE_LLQUANTIZE_FACTOR
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|low
init|=
name|DTRACE_LLQUANTIZE_LOW
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|high
init|=
name|DTRACE_LLQUANTIZE_HIGH
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|nsteps
init|=
name|DTRACE_LLQUANTIZE_NSTEP
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|bin
init|=
literal|0
decl_stmt|,
name|order
decl_stmt|;
name|int64_t
name|value
init|=
literal|1
decl_stmt|,
name|next
decl_stmt|,
name|step
decl_stmt|;
name|long
name|double
name|total
decl_stmt|;
name|assert
argument_list|(
name|nsteps
operator|>=
name|factor
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nsteps
operator|%
name|factor
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|order
operator|=
literal|0
init|;
name|order
operator|<
name|low
condition|;
name|order
operator|++
control|)
name|value
operator|*=
name|factor
expr_stmt|;
name|total
operator|=
operator|(
name|long
name|double
operator|)
name|llquanta
index|[
name|bin
operator|++
index|]
operator|*
call|(
name|long
name|double
call|)
argument_list|(
name|value
operator|-
literal|1
argument_list|)
expr_stmt|;
name|next
operator|=
name|value
operator|*
name|factor
expr_stmt|;
name|step
operator|=
name|next
operator|>
name|nsteps
condition|?
name|next
operator|/
name|nsteps
else|:
literal|1
expr_stmt|;
while|while
condition|(
name|order
operator|<=
name|high
condition|)
block|{
name|assert
argument_list|(
name|value
operator|<
name|next
argument_list|)
expr_stmt|;
name|total
operator|+=
operator|(
name|long
name|double
operator|)
name|llquanta
index|[
name|bin
operator|++
index|]
operator|*
call|(
name|long
name|double
call|)
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|+=
name|step
operator|)
operator|!=
name|next
condition|)
continue|continue;
name|next
operator|=
name|value
operator|*
name|factor
expr_stmt|;
name|step
operator|=
name|next
operator|>
name|nsteps
condition|?
name|next
operator|/
name|nsteps
else|:
literal|1
expr_stmt|;
name|order
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|+
operator|(
name|long
name|double
operator|)
name|llquanta
index|[
name|bin
index|]
operator|*
operator|(
name|long
name|double
operator|)
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_llquantizedcmp
parameter_list|(
name|int64_t
modifier|*
name|lhs
parameter_list|,
name|int64_t
modifier|*
name|rhs
parameter_list|)
block|{
name|long
name|double
name|lsum
init|=
name|dt_aggregate_llquantizedsum
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|long
name|double
name|rsum
init|=
name|dt_aggregate_llquantizedsum
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|int64_t
name|lzero
decl_stmt|,
name|rzero
decl_stmt|;
if|if
condition|(
name|lsum
operator|<
name|rsum
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lsum
operator|>
name|rsum
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
comment|/* 	 * If they're both equal, then we will compare based on the weights at 	 * zero.  If the weights at zero are equal, then this will be judged a 	 * tie and will be resolved based on the key comparison. 	 */
name|lzero
operator|=
name|lhs
index|[
literal|1
index|]
expr_stmt|;
name|rzero
operator|=
name|rhs
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|lzero
operator|<
name|rzero
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lzero
operator|>
name|rzero
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_quantizedcmp
parameter_list|(
name|int64_t
modifier|*
name|lhs
parameter_list|,
name|int64_t
modifier|*
name|rhs
parameter_list|)
block|{
name|int
name|nbuckets
init|=
name|DTRACE_QUANTIZE_NBUCKETS
decl_stmt|,
name|i
decl_stmt|;
name|long
name|double
name|ltotal
init|=
literal|0
decl_stmt|,
name|rtotal
init|=
literal|0
decl_stmt|;
name|int64_t
name|lzero
decl_stmt|,
name|rzero
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuckets
condition|;
name|i
operator|++
control|)
block|{
name|int64_t
name|bucketval
init|=
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketval
operator|==
literal|0
condition|)
block|{
name|lzero
operator|=
name|lhs
index|[
name|i
index|]
expr_stmt|;
name|rzero
operator|=
name|rhs
index|[
name|i
index|]
expr_stmt|;
block|}
name|ltotal
operator|+=
operator|(
name|long
name|double
operator|)
name|bucketval
operator|*
operator|(
name|long
name|double
operator|)
name|lhs
index|[
name|i
index|]
expr_stmt|;
name|rtotal
operator|+=
operator|(
name|long
name|double
operator|)
name|bucketval
operator|*
operator|(
name|long
name|double
operator|)
name|rhs
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ltotal
operator|<
name|rtotal
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|ltotal
operator|>
name|rtotal
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
comment|/* 	 * If they're both equal, then we will compare based on the weights at 	 * zero.  If the weights at zero are equal, then this will be judged a 	 * tie and will be resolved based on the key comparison. 	 */
if|if
condition|(
name|lzero
operator|<
name|rzero
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lzero
operator|>
name|rzero
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_aggregate_usym
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|)
block|{
name|uint64_t
name|pid
init|=
name|data
index|[
literal|0
index|]
decl_stmt|;
name|uint64_t
modifier|*
name|pc
init|=
operator|&
name|data
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_vector
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|dt_proc_lock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|Plookup_by_addr
argument_list|(
name|P
argument_list|,
operator|*
name|pc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|pc
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_aggregate_umod
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|)
block|{
name|uint64_t
name|pid
init|=
name|data
index|[
literal|0
index|]
decl_stmt|;
name|uint64_t
modifier|*
name|pc
init|=
operator|&
name|data
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
specifier|const
name|prmap_t
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_vector
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|dt_proc_lock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|=
name|Paddr_to_map
argument_list|(
name|P
argument_list|,
operator|*
name|pc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|pc
operator|=
name|map
operator|->
name|pr_vaddr
expr_stmt|;
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_aggregate_sym
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|)
block|{
name|GElf_Sym
name|sym
decl_stmt|;
name|uint64_t
modifier|*
name|pc
init|=
name|data
decl_stmt|;
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
operator|*
name|pc
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|pc
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_aggregate_mod
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|uint64_t
modifier|*
name|data
parameter_list|)
block|{
name|uint64_t
modifier|*
name|pc
init|=
name|data
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_vector
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We don't have a way of just getting the module for a 		 * vectored open, and it doesn't seem to be worth defining 		 * one.  This means that use of mod() won't get true 		 * aggregation in the postmortem case (some modules may 		 * appear more than once in aggregation output).  It seems 		 * unlikely that anyone will ever notice or care... 		 */
return|return;
block|}
for|for
control|(
name|dmp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|)
init|;
name|dmp
operator|!=
name|NULL
condition|;
name|dmp
operator|=
name|dt_list_next
argument_list|(
name|dmp
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|pc
operator|-
name|dmp
operator|->
name|dm_text_va
operator|<
name|dmp
operator|->
name|dm_text_size
condition|)
block|{
operator|*
name|pc
operator|=
name|dmp
operator|->
name|dm_text_va
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|dtrace_aggvarid_t
name|dt_aggregate_aggvarid
parameter_list|(
name|dt_ahashent_t
modifier|*
name|ent
parameter_list|)
block|{
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|ent
operator|->
name|dtahe_data
operator|.
name|dtada_desc
decl_stmt|;
name|caddr_t
name|data
init|=
name|ent
operator|->
name|dtahe_data
operator|.
name|dtada_data
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
name|agg
operator|->
name|dtagd_rec
decl_stmt|;
comment|/* 	 * First, we'll check the variable ID in the aggdesc.  If it's valid, 	 * we'll return it.  If not, we'll use the compiler-generated ID 	 * present as the first record. 	 */
if|if
condition|(
name|agg
operator|->
name|dtagd_varid
operator|!=
name|DTRACE_AGGVARIDNONE
condition|)
return|return
operator|(
name|agg
operator|->
name|dtagd_varid
operator|)
return|;
name|agg
operator|->
name|dtagd_varid
operator|=
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|data
operator|+
name|rec
operator|->
name|dtrd_offset
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|agg
operator|->
name|dtagd_varid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_snap_cpu
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|processorid_t
name|cpu
parameter_list|)
block|{
name|dtrace_epid_t
name|id
decl_stmt|;
name|uint64_t
name|hashval
decl_stmt|;
name|size_t
name|offs
decl_stmt|,
name|roffs
decl_stmt|,
name|size
decl_stmt|,
name|ndx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rval
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|,
name|data
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|agg
decl_stmt|;
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|agp
operator|->
name|dtat_hash
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|h
decl_stmt|;
name|dtrace_bufdesc_t
name|b
init|=
name|agp
operator|->
name|dtat_buf
decl_stmt|,
modifier|*
name|buf
init|=
operator|&
name|b
decl_stmt|;
name|dtrace_aggdata_t
modifier|*
name|aggdata
decl_stmt|;
name|int
name|flags
init|=
name|agp
operator|->
name|dtat_flags
decl_stmt|;
name|buf
operator|->
name|dtbd_cpu
operator|=
name|cpu
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_AGGSNAP
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* 			 * If that failed with ENOENT, it may be because the 			 * CPU was unconfigured.  This is okay; we'll just 			 * do nothing but return success. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtbd_drops
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dt_handle_cpudrop
argument_list|(
name|dtp
argument_list|,
name|cpu
argument_list|,
name|DTRACEDROP_AGGREGATION
argument_list|,
name|buf
operator|->
name|dtbd_drops
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtbd_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|hash
operator|->
name|dtah_hash
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|hash
operator|->
name|dtah_size
operator|=
name|DTRACE_AHASHSIZE
expr_stmt|;
name|size
operator|=
name|hash
operator|->
name|dtah_size
operator|*
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hash
operator|->
name|dtah_hash
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|hash
operator|->
name|dtah_hash
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|offs
operator|=
literal|0
init|;
name|offs
operator|<
name|buf
operator|->
name|dtbd_size
condition|;
control|)
block|{
comment|/* 		 * We're guaranteed to have an ID. 		 */
name|id
operator|=
operator|*
operator|(
operator|(
name|dtrace_epid_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|buf
operator|->
name|dtbd_data
operator|+
operator|(
name|uintptr_t
operator|)
name|offs
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|DTRACE_AGGIDNONE
condition|)
block|{
comment|/* 			 * This is filler to assure proper alignment of the 			 * next record; we simply ignore it. 			 */
name|offs
operator|+=
sizeof|sizeof
argument_list|(
name|id
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggid_lookup
argument_list|(
name|dtp
argument_list|,
name|id
argument_list|,
operator|&
name|agg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|addr
operator|=
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
expr_stmt|;
name|size
operator|=
name|agg
operator|->
name|dtagd_size
expr_stmt|;
name|hashval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|agg
operator|->
name|dtagd_nrecs
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|rec
operator|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
name|j
index|]
expr_stmt|;
name|roffs
operator|=
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|dtrd_action
condition|)
block|{
case|case
name|DTRACEACT_USYM
case|:
name|dt_aggregate_usym
argument_list|(
name|dtp
argument_list|,
comment|/* LINTED - alignment */
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|addr
index|[
name|roffs
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEACT_UMOD
case|:
name|dt_aggregate_umod
argument_list|(
name|dtp
argument_list|,
comment|/* LINTED - alignment */
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|addr
index|[
name|roffs
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEACT_SYM
case|:
comment|/* LINTED - alignment */
name|dt_aggregate_sym
argument_list|(
name|dtp
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|addr
index|[
name|roffs
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEACT_MOD
case|:
comment|/* LINTED - alignment */
name|dt_aggregate_mod
argument_list|(
name|dtp
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|addr
index|[
name|roffs
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|->
name|dtrd_size
condition|;
name|i
operator|++
control|)
name|hashval
operator|+=
name|addr
index|[
name|roffs
operator|+
name|i
index|]
expr_stmt|;
block|}
name|ndx
operator|=
name|hashval
operator|%
name|hash
operator|->
name|dtah_size
expr_stmt|;
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_hash
index|[
name|ndx
index|]
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|dtahe_next
control|)
block|{
if|if
condition|(
name|h
operator|->
name|dtahe_hashval
operator|!=
name|hashval
condition|)
continue|continue;
if|if
condition|(
name|h
operator|->
name|dtahe_size
operator|!=
name|size
condition|)
continue|continue;
name|aggdata
operator|=
operator|&
name|h
operator|->
name|dtahe_data
expr_stmt|;
name|data
operator|=
name|aggdata
operator|->
name|dtada_data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|agg
operator|->
name|dtagd_nrecs
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|rec
operator|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
name|j
index|]
expr_stmt|;
name|roffs
operator|=
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rec
operator|->
name|dtrd_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|addr
index|[
name|roffs
operator|+
name|i
index|]
operator|!=
name|data
index|[
name|roffs
operator|+
name|i
index|]
condition|)
goto|goto
name|hashnext
goto|;
block|}
comment|/* 			 * We found it.  Now we need to apply the aggregating 			 * action on the data here. 			 */
name|rec
operator|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
name|agg
operator|->
name|dtagd_nrecs
operator|-
literal|1
index|]
expr_stmt|;
name|roffs
operator|=
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
comment|/* LINTED - alignment */
name|h
operator|->
name|dtahe_aggregate
argument_list|(
operator|(
name|int64_t
operator|*
operator|)
operator|&
name|data
index|[
name|roffs
index|]
argument_list|,
comment|/* LINTED - alignment */
operator|(
name|int64_t
operator|*
operator|)
operator|&
name|addr
index|[
name|roffs
index|]
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
comment|/* 			 * If we're keeping per CPU data, apply the aggregating 			 * action there as well. 			 */
if|if
condition|(
name|aggdata
operator|->
name|dtada_percpu
operator|!=
name|NULL
condition|)
block|{
name|data
operator|=
name|aggdata
operator|->
name|dtada_percpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* LINTED - alignment */
name|h
operator|->
name|dtahe_aggregate
argument_list|(
operator|(
name|int64_t
operator|*
operator|)
name|data
argument_list|,
comment|/* LINTED - alignment */
operator|(
name|int64_t
operator|*
operator|)
operator|&
name|addr
index|[
name|roffs
index|]
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bufnext
goto|;
name|hashnext
label|:
continue|continue;
block|}
comment|/* 		 * If we're here, we couldn't find an entry for this record. 		 */
if|if
condition|(
operator|(
name|h
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
argument_list|)
argument_list|)
expr_stmt|;
name|aggdata
operator|=
operator|&
name|h
operator|->
name|dtahe_data
expr_stmt|;
if|if
condition|(
operator|(
name|aggdata
operator|->
name|dtada_data
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|addr
argument_list|,
name|aggdata
operator|->
name|dtada_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|aggdata
operator|->
name|dtada_size
operator|=
name|size
expr_stmt|;
name|aggdata
operator|->
name|dtada_desc
operator|=
name|agg
expr_stmt|;
name|aggdata
operator|->
name|dtada_handle
operator|=
name|dtp
expr_stmt|;
operator|(
name|void
operator|)
name|dt_epid_lookup
argument_list|(
name|dtp
argument_list|,
name|agg
operator|->
name|dtagd_epid
argument_list|,
operator|&
name|aggdata
operator|->
name|dtada_edesc
argument_list|,
operator|&
name|aggdata
operator|->
name|dtada_pdesc
argument_list|)
expr_stmt|;
name|aggdata
operator|->
name|dtada_normal
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|dtahe_hashval
operator|=
name|hashval
expr_stmt|;
name|h
operator|->
name|dtahe_size
operator|=
name|size
expr_stmt|;
operator|(
name|void
operator|)
name|dt_aggregate_aggvarid
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|rec
operator|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
name|agg
operator|->
name|dtagd_nrecs
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DTRACE_A_PERCPU
condition|)
block|{
name|int
name|max_cpus
init|=
name|agp
operator|->
name|dtat_maxcpu
decl_stmt|;
name|caddr_t
modifier|*
name|percpu
init|=
name|malloc
argument_list|(
name|max_cpus
operator|*
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|percpu
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_cpus
condition|;
name|j
operator|++
control|)
block|{
name|percpu
index|[
name|j
index|]
operator|=
name|malloc
argument_list|(
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|percpu
index|[
name|j
index|]
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|free
argument_list|(
name|percpu
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|j
operator|==
name|cpu
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|addr
index|[
name|rec
operator|->
name|dtrd_offset
index|]
argument_list|,
name|percpu
index|[
name|j
index|]
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|percpu
index|[
name|j
index|]
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
block|}
block|}
name|aggdata
operator|->
name|dtada_percpu
operator|=
name|percpu
expr_stmt|;
block|}
switch|switch
condition|(
name|rec
operator|->
name|dtrd_action
condition|)
block|{
case|case
name|DTRACEAGG_MIN
case|:
name|h
operator|->
name|dtahe_aggregate
operator|=
name|dt_aggregate_min
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_MAX
case|:
name|h
operator|->
name|dtahe_aggregate
operator|=
name|dt_aggregate_max
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_LQUANTIZE
case|:
name|h
operator|->
name|dtahe_aggregate
operator|=
name|dt_aggregate_lquantize
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_LLQUANTIZE
case|:
name|h
operator|->
name|dtahe_aggregate
operator|=
name|dt_aggregate_llquantize
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_COUNT
case|:
case|case
name|DTRACEAGG_SUM
case|:
case|case
name|DTRACEAGG_AVG
case|:
case|case
name|DTRACEAGG_STDDEV
case|:
case|case
name|DTRACEAGG_QUANTIZE
case|:
name|h
operator|->
name|dtahe_aggregate
operator|=
name|dt_aggregate_count
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADAGG
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|hash
operator|->
name|dtah_hash
index|[
name|ndx
index|]
operator|!=
name|NULL
condition|)
name|hash
operator|->
name|dtah_hash
index|[
name|ndx
index|]
operator|->
name|dtahe_prev
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|dtahe_next
operator|=
name|hash
operator|->
name|dtah_hash
index|[
name|ndx
index|]
expr_stmt|;
name|hash
operator|->
name|dtah_hash
index|[
name|ndx
index|]
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|dtah_all
operator|!=
name|NULL
condition|)
name|hash
operator|->
name|dtah_all
operator|->
name|dtahe_prevall
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|dtahe_nextall
operator|=
name|hash
operator|->
name|dtah_all
expr_stmt|;
name|hash
operator|->
name|dtah_all
operator|=
name|h
expr_stmt|;
name|bufnext
label|:
name|offs
operator|+=
name|agg
operator|->
name|dtagd_size
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_snap
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|;
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|hrtime_t
name|now
init|=
name|gethrtime
argument_list|()
decl_stmt|;
name|dtrace_optval_t
name|interval
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_AGGRATE
index|]
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_lastagg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|now
operator|-
name|dtp
operator|->
name|dt_lastagg
operator|<
name|interval
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dtp
operator|->
name|dt_lastagg
operator|+=
name|interval
expr_stmt|;
block|}
else|else
block|{
name|dtp
operator|->
name|dt_lastagg
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_active
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|agp
operator|->
name|dtat_buf
operator|.
name|dtbd_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|agp
operator|->
name|dtat_ncpus
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rval
operator|=
name|dt_aggregate_snap_cpu
argument_list|(
name|dtp
argument_list|,
name|agp
operator|->
name|dtat_cpus
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|rval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_hashcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|dt_ahashent_t
modifier|*
name|lh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|lhs
operator|)
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|rh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|rhs
operator|)
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|lagg
init|=
name|lh
operator|->
name|dtahe_data
operator|.
name|dtada_desc
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|ragg
init|=
name|rh
operator|->
name|dtahe_data
operator|.
name|dtada_desc
decl_stmt|;
if|if
condition|(
name|lagg
operator|->
name|dtagd_nrecs
operator|<
name|ragg
operator|->
name|dtagd_nrecs
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lagg
operator|->
name|dtagd_nrecs
operator|>
name|ragg
operator|->
name|dtagd_nrecs
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_varcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|dt_ahashent_t
modifier|*
name|lh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|lhs
operator|)
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|rh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|rhs
operator|)
decl_stmt|;
name|dtrace_aggvarid_t
name|lid
decl_stmt|,
name|rid
decl_stmt|;
name|lid
operator|=
name|dt_aggregate_aggvarid
argument_list|(
name|lh
argument_list|)
expr_stmt|;
name|rid
operator|=
name|dt_aggregate_aggvarid
argument_list|(
name|rh
argument_list|)
expr_stmt|;
if|if
condition|(
name|lid
operator|<
name|rid
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lid
operator|>
name|rid
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_keycmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|dt_ahashent_t
modifier|*
name|lh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|lhs
operator|)
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|rh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|rhs
operator|)
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|lagg
init|=
name|lh
operator|->
name|dtahe_data
operator|.
name|dtada_desc
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|ragg
init|=
name|rh
operator|->
name|dtahe_data
operator|.
name|dtada_desc
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|lrec
decl_stmt|,
modifier|*
name|rrec
decl_stmt|;
name|char
modifier|*
name|ldata
decl_stmt|,
modifier|*
name|rdata
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|keypos
decl_stmt|,
name|nrecs
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_hashcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|nrecs
operator|=
name|lagg
operator|->
name|dtagd_nrecs
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|nrecs
operator|==
name|ragg
operator|->
name|dtagd_nrecs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|keypos
operator|=
name|dt_keypos
operator|+
literal|1
operator|>=
name|nrecs
condition|?
literal|0
else|:
name|dt_keypos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nrecs
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|lval
decl_stmt|,
name|rval
decl_stmt|;
name|int
name|ndx
init|=
name|i
operator|+
name|keypos
decl_stmt|;
if|if
condition|(
name|ndx
operator|>=
name|nrecs
condition|)
name|ndx
operator|=
name|ndx
operator|-
name|nrecs
operator|+
literal|1
expr_stmt|;
name|lrec
operator|=
operator|&
name|lagg
operator|->
name|dtagd_rec
index|[
name|ndx
index|]
expr_stmt|;
name|rrec
operator|=
operator|&
name|ragg
operator|->
name|dtagd_rec
index|[
name|ndx
index|]
expr_stmt|;
name|ldata
operator|=
name|lh
operator|->
name|dtahe_data
operator|.
name|dtada_data
operator|+
name|lrec
operator|->
name|dtrd_offset
expr_stmt|;
name|rdata
operator|=
name|rh
operator|->
name|dtahe_data
operator|.
name|dtada_data
operator|+
name|rrec
operator|->
name|dtrd_offset
expr_stmt|;
if|if
condition|(
name|lrec
operator|->
name|dtrd_size
operator|<
name|rrec
operator|->
name|dtrd_size
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lrec
operator|->
name|dtrd_size
operator|>
name|rrec
operator|->
name|dtrd_size
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
switch|switch
condition|(
name|lrec
operator|->
name|dtrd_size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|lval
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|ldata
operator|)
expr_stmt|;
comment|/* LINTED - alignment */
name|rval
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|rdata
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|lval
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|ldata
operator|)
expr_stmt|;
comment|/* LINTED - alignment */
name|rval
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|rdata
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|lval
operator|=
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|ldata
operator|)
expr_stmt|;
comment|/* LINTED - alignment */
name|rval
operator|=
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|rdata
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
name|lval
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ldata
operator|)
expr_stmt|;
name|rval
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rdata
operator|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|lrec
operator|->
name|dtrd_action
condition|)
block|{
case|case
name|DTRACEACT_UMOD
case|:
case|case
name|DTRACEACT_UADDR
case|:
case|case
name|DTRACEACT_USYM
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
comment|/* LINTED - alignment */
name|lval
operator|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|ldata
operator|)
index|[
name|j
index|]
expr_stmt|;
comment|/* LINTED - alignment */
name|rval
operator|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|rdata
operator|)
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|lval
operator|<
name|rval
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lval
operator|>
name|rval
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
block|}
break|break;
default|default:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lrec
operator|->
name|dtrd_size
condition|;
name|j
operator|++
control|)
block|{
name|lval
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ldata
operator|)
index|[
name|j
index|]
expr_stmt|;
name|rval
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|rdata
operator|)
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|lval
operator|<
name|rval
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lval
operator|>
name|rval
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|lval
operator|<
name|rval
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lval
operator|>
name|rval
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_valcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|dt_ahashent_t
modifier|*
name|lh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|lhs
operator|)
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|rh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|)
name|rhs
operator|)
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|lagg
init|=
name|lh
operator|->
name|dtahe_data
operator|.
name|dtada_desc
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|ragg
init|=
name|rh
operator|->
name|dtahe_data
operator|.
name|dtada_desc
decl_stmt|;
name|caddr_t
name|ldata
init|=
name|lh
operator|->
name|dtahe_data
operator|.
name|dtada_data
decl_stmt|;
name|caddr_t
name|rdata
init|=
name|rh
operator|->
name|dtahe_data
operator|.
name|dtada_data
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|lrec
decl_stmt|,
modifier|*
name|rrec
decl_stmt|;
name|int64_t
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|raddr
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_hashcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|lagg
operator|->
name|dtagd_nrecs
operator|>
name|ragg
operator|->
name|dtagd_nrecs
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
if|if
condition|(
name|lagg
operator|->
name|dtagd_nrecs
operator|<
name|ragg
operator|->
name|dtagd_nrecs
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lagg
operator|->
name|dtagd_nrecs
condition|;
name|i
operator|++
control|)
block|{
name|lrec
operator|=
operator|&
name|lagg
operator|->
name|dtagd_rec
index|[
name|i
index|]
expr_stmt|;
name|rrec
operator|=
operator|&
name|ragg
operator|->
name|dtagd_rec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lrec
operator|->
name|dtrd_offset
operator|<
name|rrec
operator|->
name|dtrd_offset
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lrec
operator|->
name|dtrd_offset
operator|>
name|rrec
operator|->
name|dtrd_offset
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
if|if
condition|(
name|lrec
operator|->
name|dtrd_action
operator|<
name|rrec
operator|->
name|dtrd_action
condition|)
return|return
operator|(
name|DT_LESSTHAN
operator|)
return|;
if|if
condition|(
name|lrec
operator|->
name|dtrd_action
operator|>
name|rrec
operator|->
name|dtrd_action
condition|)
return|return
operator|(
name|DT_GREATERTHAN
operator|)
return|;
block|}
name|laddr
operator|=
operator|(
name|int64_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|ldata
operator|+
name|lrec
operator|->
name|dtrd_offset
argument_list|)
expr_stmt|;
name|raddr
operator|=
operator|(
name|int64_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|rdata
operator|+
name|rrec
operator|->
name|dtrd_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lrec
operator|->
name|dtrd_action
condition|)
block|{
case|case
name|DTRACEAGG_AVG
case|:
name|rval
operator|=
name|dt_aggregate_averagecmp
argument_list|(
name|laddr
argument_list|,
name|raddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_STDDEV
case|:
name|rval
operator|=
name|dt_aggregate_stddevcmp
argument_list|(
name|laddr
argument_list|,
name|raddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_QUANTIZE
case|:
name|rval
operator|=
name|dt_aggregate_quantizedcmp
argument_list|(
name|laddr
argument_list|,
name|raddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_LQUANTIZE
case|:
name|rval
operator|=
name|dt_aggregate_lquantizedcmp
argument_list|(
name|laddr
argument_list|,
name|raddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_LLQUANTIZE
case|:
name|rval
operator|=
name|dt_aggregate_llquantizedcmp
argument_list|(
name|laddr
argument_list|,
name|raddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_COUNT
case|:
case|case
name|DTRACEAGG_SUM
case|:
case|case
name|DTRACEAGG_MIN
case|:
case|case
name|DTRACEAGG_MAX
case|:
name|rval
operator|=
name|dt_aggregate_countcmp
argument_list|(
name|laddr
argument_list|,
name|raddr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_valkeycmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_valcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* 	 * If we're here, the values for the two aggregation elements are 	 * equal.  We already know that the key layout is the same for the two 	 * elements; we must now compare the keys themselves as a tie-breaker. 	 */
return|return
operator|(
name|dt_aggregate_keycmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_keyvarcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_keycmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
return|return
operator|(
name|dt_aggregate_varcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_varkeycmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_varcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
return|return
operator|(
name|dt_aggregate_keycmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_valvarcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_valkeycmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
return|return
operator|(
name|dt_aggregate_varcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_varvalcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_varcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
return|return
operator|(
name|dt_aggregate_valkeycmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_keyvarrevcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_keyvarcmp
argument_list|(
name|rhs
argument_list|,
name|lhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_varkeyrevcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_varkeycmp
argument_list|(
name|rhs
argument_list|,
name|lhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_valvarrevcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_valvarcmp
argument_list|(
name|rhs
argument_list|,
name|lhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_varvalrevcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_varvalcmp
argument_list|(
name|rhs
argument_list|,
name|lhs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_bundlecmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
name|dt_ahashent_t
modifier|*
modifier|*
name|lh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|*
operator|)
name|lhs
operator|)
decl_stmt|;
name|dt_ahashent_t
modifier|*
modifier|*
name|rh
init|=
operator|*
operator|(
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|*
operator|)
name|rhs
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|;
if|if
condition|(
name|dt_keysort
condition|)
block|{
comment|/* 		 * If we're sorting on keys, we need to scan until we find the 		 * last entry -- that's the representative key.  (The order of 		 * the bundle is values followed by key to accommodate the 		 * default behavior of sorting by value.)  If the keys are 		 * equal, we'll fall into the value comparison loop, below. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lh
index|[
name|i
operator|+
literal|1
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
continue|continue;
name|assert
argument_list|(
name|i
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rh
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_keycmp
argument_list|(
operator|&
name|lh
index|[
name|i
index|]
argument_list|,
operator|&
name|rh
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lh
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * All of the values are equal; if we're sorting on 			 * keys, then we're only here because the keys were 			 * found to be equal and these records are therefore 			 * equal.  If we're not sorting on keys, we'll use the 			 * key comparison from the representative key as the 			 * tie-breaker. 			 */
if|if
condition|(
name|dt_keysort
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|assert
argument_list|(
name|i
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rh
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_aggregate_keycmp
argument_list|(
operator|&
name|lh
index|[
name|i
index|]
argument_list|,
operator|&
name|rh
index|[
name|i
index|]
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_aggregate_valcmp
argument_list|(
operator|&
name|lh
index|[
name|i
index|]
argument_list|,
operator|&
name|rh
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|dt_aggregate_go
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|dtrace_optval_t
name|size
decl_stmt|,
name|cpu
decl_stmt|;
name|dtrace_bufdesc_t
modifier|*
name|buf
init|=
operator|&
name|agp
operator|->
name|dtat_buf
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|;
name|assert
argument_list|(
name|agp
operator|->
name|dtat_maxcpu
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|agp
operator|->
name|dtat_ncpu
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|agp
operator|->
name|dtat_cpus
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|agp
operator|->
name|dtat_maxcpu
operator|=
name|dt_sysconf
argument_list|(
name|dtp
argument_list|,
name|_SC_CPUID_MAX
argument_list|)
operator|+
literal|1
expr_stmt|;
name|agp
operator|->
name|dtat_ncpu
operator|=
name|dt_sysconf
argument_list|(
name|dtp
argument_list|,
name|_SC_NPROCESSORS_MAX
argument_list|)
expr_stmt|;
name|agp
operator|->
name|dtat_cpus
operator|=
name|malloc
argument_list|(
name|agp
operator|->
name|dtat_ncpu
operator|*
sizeof|sizeof
argument_list|(
name|processorid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agp
operator|->
name|dtat_cpus
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
comment|/* 	 * Use the aggregation buffer size as reloaded from the kernel. 	 */
name|size
operator|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_AGGSIZE
index|]
expr_stmt|;
name|rval
operator|=
name|dtrace_getopt
argument_list|(
name|dtp
argument_list|,
literal|"aggsize"
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rval
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|size
operator|==
name|DTRACEOPT_UNSET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|buf
operator|=
operator|&
name|agp
operator|->
name|dtat_buf
expr_stmt|;
name|buf
operator|->
name|dtbd_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|->
name|dtbd_data
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|dtbd_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
comment|/* 	 * Now query for the CPUs enabled. 	 */
name|rval
operator|=
name|dtrace_getopt
argument_list|(
name|dtp
argument_list|,
literal|"cpu"
argument_list|,
operator|&
name|cpu
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|rval
operator|==
literal|0
operator|&&
name|cpu
operator|!=
name|DTRACEOPT_UNSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|!=
name|DTRACE_CPUALL
condition|)
block|{
name|assert
argument_list|(
name|cpu
operator|<
name|agp
operator|->
name|dtat_ncpu
argument_list|)
expr_stmt|;
name|agp
operator|->
name|dtat_cpus
index|[
name|agp
operator|->
name|dtat_ncpus
operator|++
index|]
operator|=
operator|(
name|processorid_t
operator|)
name|cpu
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|agp
operator|->
name|dtat_ncpus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|agp
operator|->
name|dtat_maxcpu
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dt_status
argument_list|(
name|dtp
argument_list|,
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|agp
operator|->
name|dtat_cpus
index|[
name|agp
operator|->
name|dtat_ncpus
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggwalk_rval
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_ahashent_t
modifier|*
name|h
parameter_list|,
name|int
name|rval
parameter_list|)
block|{
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|dtrace_aggdata_t
modifier|*
name|data
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|aggdesc
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|rval
condition|)
block|{
case|case
name|DTRACE_AGGWALK_NEXT
case|:
break|break;
case|case
name|DTRACE_AGGWALK_CLEAR
case|:
block|{
name|uint32_t
name|size
decl_stmt|,
name|offs
init|=
literal|0
decl_stmt|;
name|aggdesc
operator|=
name|h
operator|->
name|dtahe_data
operator|.
name|dtada_desc
expr_stmt|;
name|rec
operator|=
operator|&
name|aggdesc
operator|->
name|dtagd_rec
index|[
name|aggdesc
operator|->
name|dtagd_nrecs
operator|-
literal|1
index|]
expr_stmt|;
name|size
operator|=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
name|data
operator|=
operator|&
name|h
operator|->
name|dtahe_data
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_action
operator|==
name|DTRACEAGG_LQUANTIZE
condition|)
block|{
name|offs
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|data
operator|->
name|dtada_data
index|[
name|rec
operator|->
name|dtrd_offset
index|]
operator|+
name|offs
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|dtada_percpu
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtp
operator|->
name|dt_aggregate
operator|.
name|dtat_maxcpu
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
name|data
operator|->
name|dtada_percpu
index|[
name|i
index|]
operator|+
name|offs
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DTRACE_AGGWALK_ERROR
case|:
comment|/* 		 * We assume that errno is already set in this case. 		 */
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
case|case
name|DTRACE_AGGWALK_ABORT
case|:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DIRABORT
argument_list|)
operator|)
return|;
case|case
name|DTRACE_AGGWALK_DENORMALIZE
case|:
name|h
operator|->
name|dtahe_data
operator|.
name|dtada_normal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DTRACE_AGGWALK_NORMALIZE
case|:
if|if
condition|(
name|h
operator|->
name|dtahe_data
operator|.
name|dtada_normal
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|dtahe_data
operator|.
name|dtada_normal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADRVAL
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DTRACE_AGGWALK_REMOVE
case|:
block|{
name|dtrace_aggdata_t
modifier|*
name|aggdata
init|=
operator|&
name|h
operator|->
name|dtahe_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_cpus
init|=
name|agp
operator|->
name|dtat_maxcpu
decl_stmt|;
comment|/* 		 * First, remove this hash entry from its hash chain. 		 */
if|if
condition|(
name|h
operator|->
name|dtahe_prev
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|dtahe_prev
operator|->
name|dtahe_next
operator|=
name|h
operator|->
name|dtahe_next
expr_stmt|;
block|}
else|else
block|{
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|agp
operator|->
name|dtat_hash
decl_stmt|;
name|size_t
name|ndx
init|=
name|h
operator|->
name|dtahe_hashval
operator|%
name|hash
operator|->
name|dtah_size
decl_stmt|;
name|assert
argument_list|(
name|hash
operator|->
name|dtah_hash
index|[
name|ndx
index|]
operator|==
name|h
argument_list|)
expr_stmt|;
name|hash
operator|->
name|dtah_hash
index|[
name|ndx
index|]
operator|=
name|h
operator|->
name|dtahe_next
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|dtahe_next
operator|!=
name|NULL
condition|)
name|h
operator|->
name|dtahe_next
operator|->
name|dtahe_prev
operator|=
name|h
operator|->
name|dtahe_prev
expr_stmt|;
comment|/* 		 * Now remove it from the list of all hash entries. 		 */
if|if
condition|(
name|h
operator|->
name|dtahe_prevall
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|dtahe_prevall
operator|->
name|dtahe_nextall
operator|=
name|h
operator|->
name|dtahe_nextall
expr_stmt|;
block|}
else|else
block|{
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|agp
operator|->
name|dtat_hash
decl_stmt|;
name|assert
argument_list|(
name|hash
operator|->
name|dtah_all
operator|==
name|h
argument_list|)
expr_stmt|;
name|hash
operator|->
name|dtah_all
operator|=
name|h
operator|->
name|dtahe_nextall
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|dtahe_nextall
operator|!=
name|NULL
condition|)
name|h
operator|->
name|dtahe_nextall
operator|->
name|dtahe_prevall
operator|=
name|h
operator|->
name|dtahe_prevall
expr_stmt|;
comment|/* 		 * We're unlinked.  We can safely destroy the data. 		 */
if|if
condition|(
name|aggdata
operator|->
name|dtada_percpu
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cpus
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_percpu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_percpu
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADRVAL
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_aggregate_qsort
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|nel
parameter_list|,
name|size_t
name|width
parameter_list|,
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|rev
init|=
name|dt_revsort
decl_stmt|,
name|key
init|=
name|dt_keysort
decl_stmt|,
name|keypos
init|=
name|dt_keypos
decl_stmt|;
name|dtrace_optval_t
name|keyposopt
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_AGGSORTKEYPOS
index|]
decl_stmt|;
name|dt_revsort
operator|=
operator|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_AGGSORTREV
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|)
expr_stmt|;
name|dt_keysort
operator|=
operator|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_AGGSORTKEY
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|)
expr_stmt|;
if|if
condition|(
name|keyposopt
operator|!=
name|DTRACEOPT_UNSET
operator|&&
name|keyposopt
operator|<=
name|INT_MAX
condition|)
block|{
name|dt_keypos
operator|=
operator|(
name|int
operator|)
name|keyposopt
expr_stmt|;
block|}
else|else
block|{
name|dt_keypos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|compar
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dt_keysort
condition|)
block|{
name|compar
operator|=
name|dt_aggregate_varvalcmp
expr_stmt|;
block|}
else|else
block|{
name|compar
operator|=
name|dt_aggregate_varkeycmp
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
name|base
argument_list|,
name|nel
argument_list|,
name|width
argument_list|,
name|compar
argument_list|)
expr_stmt|;
name|dt_revsort
operator|=
name|rev
expr_stmt|;
name|dt_keysort
operator|=
name|key
expr_stmt|;
name|dt_keypos
operator|=
name|keypos
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_ahashent_t
modifier|*
name|h
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
operator|.
name|dtat_hash
decl_stmt|;
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_all
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|next
control|)
block|{
comment|/* 		 * dt_aggwalk_rval() can potentially remove the current hash 		 * entry; we need to load the next hash entry before calling 		 * into it. 		 */
name|next
operator|=
name|h
operator|->
name|dtahe_nextall
expr_stmt|;
if|if
condition|(
name|dt_aggwalk_rval
argument_list|(
name|dtp
argument_list|,
name|h
argument_list|,
name|func
argument_list|(
operator|&
name|h
operator|->
name|dtahe_data
argument_list|,
name|arg
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_aggregate_walk_sorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
function_decl|(
modifier|*
name|sfunc
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|h
decl_stmt|,
modifier|*
modifier|*
name|sorted
decl_stmt|;
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|agp
operator|->
name|dtat_hash
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|nentries
init|=
literal|0
decl_stmt|;
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_all
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|dtahe_nextall
control|)
name|nentries
operator|++
expr_stmt|;
name|sorted
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|nentries
operator|*
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorted
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_all
operator|,
name|i
operator|=
literal|0
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|dtahe_nextall
control|)
name|sorted
index|[
name|i
operator|++
index|]
operator|=
name|h
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dt_qsort_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfunc
operator|==
name|NULL
condition|)
block|{
name|dt_aggregate_qsort
argument_list|(
name|dtp
argument_list|,
name|sorted
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we've been explicitly passed a sorting function, 		 * we'll use that -- ignoring the values of the "aggsortrev", 		 * "aggsortkey" and "aggsortkeypos" options. 		 */
name|qsort
argument_list|(
name|sorted
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
argument_list|)
argument_list|,
name|sfunc
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dt_qsort_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|h
operator|=
name|sorted
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dt_aggwalk_rval
argument_list|(
name|dtp
argument_list|,
name|h
argument_list|,
name|func
argument_list|(
operator|&
name|h
operator|->
name|dtahe_data
argument_list|,
name|arg
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_sorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_keysorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_varkeycmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_valsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_varvalcmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_keyvarsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_keyvarcmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_valvarsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_valvarcmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_keyrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_varkeyrevcmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_valrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_varvalrevcmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_keyvarrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_keyvarrevcmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_valvarrevsorted
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggregate_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|dt_aggregate_valvarrevcmp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_walk_joined
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_aggvarid_t
modifier|*
name|aggvars
parameter_list|,
name|int
name|naggvars
parameter_list|,
name|dtrace_aggregate_walk_joined_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|h
decl_stmt|,
modifier|*
modifier|*
name|sorted
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
modifier|*
name|bundle
decl_stmt|,
modifier|*
modifier|*
name|nbundle
decl_stmt|;
specifier|const
name|dtrace_aggdata_t
modifier|*
modifier|*
name|data
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|zaggdata
init|=
name|NULL
decl_stmt|;
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|agp
operator|->
name|dtat_hash
decl_stmt|;
name|size_t
name|nentries
init|=
literal|0
decl_stmt|,
name|nbundles
init|=
literal|0
decl_stmt|,
name|start
decl_stmt|,
name|zsize
init|=
literal|0
decl_stmt|,
name|bundlesize
decl_stmt|;
name|dtrace_aggvarid_t
name|max
init|=
literal|0
decl_stmt|,
name|aggvar
decl_stmt|;
name|int
name|rval
init|=
operator|-
literal|1
decl_stmt|,
modifier|*
name|map
decl_stmt|,
modifier|*
name|remap
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|dtrace_optval_t
name|sortpos
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_AGGSORTPOS
index|]
decl_stmt|;
comment|/* 	 * If the sorting position is greater than the number of aggregation 	 * variable IDs, we silently set it to 0. 	 */
if|if
condition|(
name|sortpos
operator|==
name|DTRACEOPT_UNSET
operator|||
name|sortpos
operator|>=
name|naggvars
condition|)
name|sortpos
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First we need to translate the specified aggregation variable IDs 	 * into a linear map that will allow us to translate an aggregation 	 * variable ID into its position in the specified aggvars. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naggvars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aggvars
index|[
name|i
index|]
operator|==
name|DTRACE_AGGVARIDNONE
operator|||
name|aggvars
index|[
name|i
index|]
operator|<
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADAGGVAR
argument_list|)
operator|)
return|;
if|if
condition|(
name|aggvars
index|[
name|i
index|]
operator|>
name|max
condition|)
name|max
operator|=
name|aggvars
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|map
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
operator|(
name|max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zaggdata
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
name|naggvars
operator|*
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zaggdata
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naggvars
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ndx
init|=
name|i
operator|+
name|sortpos
decl_stmt|;
if|if
condition|(
name|ndx
operator|>=
name|naggvars
condition|)
name|ndx
operator|-=
name|naggvars
expr_stmt|;
name|aggvar
operator|=
name|aggvars
index|[
name|ndx
index|]
expr_stmt|;
name|assert
argument_list|(
name|aggvar
operator|<=
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|aggvar
index|]
condition|)
block|{
comment|/* 			 * We have an aggregation variable that is present 			 * more than once in the array of aggregation 			 * variables.  While it's unclear why one might want 			 * to do this, it's legal.  To support this construct, 			 * we will allocate a remap that will indicate the 			 * position from which this aggregation variable 			 * should be pulled.  (That is, where the remap will 			 * map from one position to another.) 			 */
if|if
condition|(
name|remap
operator|==
name|NULL
condition|)
block|{
name|remap
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
name|naggvars
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remap
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Given that the variable is already present, assert 			 * that following through the mapping and adjusting 			 * for the sort position yields the same aggregation 			 * variable ID. 			 */
name|assert
argument_list|(
name|aggvars
index|[
operator|(
name|map
index|[
name|aggvar
index|]
operator|-
literal|1
operator|+
name|sortpos
operator|)
operator|%
name|naggvars
index|]
operator|==
name|aggvars
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|remap
index|[
name|i
index|]
operator|=
name|map
index|[
name|aggvar
index|]
expr_stmt|;
continue|continue;
block|}
name|map
index|[
name|aggvar
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * We need to take two passes over the data to size our allocation, so 	 * we'll use the first pass to also fill in the zero-filled data to be 	 * used to properly format a zero-valued aggregation. 	 */
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_all
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|dtahe_nextall
control|)
block|{
name|dtrace_aggvarid_t
name|id
decl_stmt|;
name|int
name|ndx
decl_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|dt_aggregate_aggvarid
argument_list|(
name|h
argument_list|)
operator|)
operator|>
name|max
operator|||
operator|!
operator|(
name|ndx
operator|=
name|map
index|[
name|id
index|]
operator|)
condition|)
continue|continue;
if|if
condition|(
name|zaggdata
index|[
name|ndx
operator|-
literal|1
index|]
operator|.
name|dtahe_size
operator|==
literal|0
condition|)
block|{
name|zaggdata
index|[
name|ndx
operator|-
literal|1
index|]
operator|.
name|dtahe_size
operator|=
name|h
operator|->
name|dtahe_size
expr_stmt|;
name|zaggdata
index|[
name|ndx
operator|-
literal|1
index|]
operator|.
name|dtahe_data
operator|=
name|h
operator|->
name|dtahe_data
expr_stmt|;
block|}
name|nentries
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nentries
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We couldn't find any entries; there is nothing else to do. 		 */
name|rval
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Before we sort the data, we're going to look for any holes in our 	 * zero-filled data.  This will occur if an aggregation variable that 	 * we are being asked to print has not yet been assigned the result of 	 * any aggregating action for _any_ tuple.  The issue becomes that we 	 * would like a zero value to be printed for all columns for this 	 * aggregation, but without any record description, we don't know the 	 * aggregating action that corresponds to the aggregation variable.  To 	 * try to find a match, we're simply going to lookup aggregation IDs 	 * (which are guaranteed to be contiguous and to start from 1), looking 	 * for the specified aggregation variable ID.  If we find a match, 	 * we'll use that.  If we iterate over all aggregation IDs and don't 	 * find a match, then we must be an anonymous enabling.  (Anonymous 	 * enablings can't currently derive either aggregation variable IDs or 	 * aggregation variable names given only an aggregation ID.)  In this 	 * obscure case (anonymous enabling, multiple aggregation printa() with 	 * some aggregations not represented for any tuple), our defined 	 * behavior is that the zero will be printed in the format of the first 	 * aggregation variable that contains any non-zero value. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naggvars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_size
operator|==
literal|0
condition|)
block|{
name|dtrace_aggvarid_t
name|aggvar
decl_stmt|;
name|aggvar
operator|=
name|aggvars
index|[
operator|(
name|i
operator|-
name|sortpos
operator|+
name|naggvars
operator|)
operator|%
name|naggvars
index|]
expr_stmt|;
name|assert
argument_list|(
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_data
operator|.
name|dtada_data
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|DTRACE_AGGIDNONE
operator|+
literal|1
init|;
condition|;
name|j
operator|++
control|)
block|{
name|dtrace_aggdesc_t
modifier|*
name|agg
decl_stmt|;
name|dtrace_aggdata_t
modifier|*
name|aggdata
decl_stmt|;
if|if
condition|(
name|dt_aggid_lookup
argument_list|(
name|dtp
argument_list|,
name|j
argument_list|,
operator|&
name|agg
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|agg
operator|->
name|dtagd_varid
operator|!=
name|aggvar
condition|)
continue|continue;
comment|/* 				 * We have our description -- now we need to 				 * cons up the zaggdata entry for it. 				 */
name|aggdata
operator|=
operator|&
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_data
expr_stmt|;
name|aggdata
operator|->
name|dtada_size
operator|=
name|agg
operator|->
name|dtagd_size
expr_stmt|;
name|aggdata
operator|->
name|dtada_desc
operator|=
name|agg
expr_stmt|;
name|aggdata
operator|->
name|dtada_handle
operator|=
name|dtp
expr_stmt|;
operator|(
name|void
operator|)
name|dt_epid_lookup
argument_list|(
name|dtp
argument_list|,
name|agg
operator|->
name|dtagd_epid
argument_list|,
operator|&
name|aggdata
operator|->
name|dtada_edesc
argument_list|,
operator|&
name|aggdata
operator|->
name|dtada_pdesc
argument_list|)
expr_stmt|;
name|aggdata
operator|->
name|dtada_normal
operator|=
literal|1
expr_stmt|;
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_hashval
operator|=
literal|0
expr_stmt|;
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_size
operator|=
name|agg
operator|->
name|dtagd_size
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_size
operator|==
literal|0
condition|)
block|{
name|caddr_t
name|data
decl_stmt|;
comment|/* 				 * We couldn't find this aggregation, meaning 				 * that we have never seen it before for any 				 * tuple _and_ this is an anonymous enabling. 				 * That is, we're in the obscure case outlined 				 * above.  In this case, our defined behavior 				 * is to format the data in the format of the 				 * first non-zero aggregation -- of which, of 				 * course, we know there to be at least one 				 * (or nentries would have been zero). 				 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|naggvars
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|zaggdata
index|[
name|j
index|]
operator|.
name|dtahe_size
operator|!=
literal|0
condition|)
break|break;
block|}
name|assert
argument_list|(
name|j
operator|<
name|naggvars
argument_list|)
expr_stmt|;
name|zaggdata
index|[
name|i
index|]
operator|=
name|zaggdata
index|[
name|j
index|]
expr_stmt|;
name|data
operator|=
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_data
operator|.
name|dtada_data
expr_stmt|;
name|assert
argument_list|(
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now we need to allocate our zero-filled data for use for 	 * aggregations that don't have a value corresponding to a given key. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naggvars
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_aggdata_t
modifier|*
name|aggdata
init|=
operator|&
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_data
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|aggdesc
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|uint64_t
name|larg
decl_stmt|;
name|caddr_t
name|zdata
decl_stmt|;
name|zsize
operator|=
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_size
expr_stmt|;
name|assert
argument_list|(
name|zsize
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zdata
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
name|zsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * If we failed to allocated some zero-filled data, we 			 * need to zero out the remaining dtada_data pointers 			 * to prevent the wrong data from being freed below. 			 */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|naggvars
condition|;
name|j
operator|++
control|)
name|zaggdata
index|[
name|j
index|]
operator|.
name|dtahe_data
operator|.
name|dtada_data
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|aggvar
operator|=
name|aggvars
index|[
operator|(
name|i
operator|-
name|sortpos
operator|+
name|naggvars
operator|)
operator|%
name|naggvars
index|]
expr_stmt|;
comment|/* 		 * First, the easy bit.  To maintain compatibility with 		 * consumers that pull the compiler-generated ID out of the 		 * data, we put that ID at the top of the zero-filled data. 		 */
name|rec
operator|=
operator|&
name|aggdesc
operator|->
name|dtagd_rec
index|[
literal|0
index|]
expr_stmt|;
comment|/* LINTED - alignment */
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
operator|(
name|zdata
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
operator|)
operator|=
name|aggvar
expr_stmt|;
name|rec
operator|=
operator|&
name|aggdesc
operator|->
name|dtagd_rec
index|[
name|aggdesc
operator|->
name|dtagd_nrecs
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 		 * Now for the more complicated part.  If (and only if) this 		 * is an lquantize() aggregating action, zero-filled data is 		 * not equivalent to an empty record:  we must also get the 		 * parameters for the lquantize(). 		 */
if|if
condition|(
name|rec
operator|->
name|dtrd_action
operator|==
name|DTRACEAGG_LQUANTIZE
condition|)
block|{
if|if
condition|(
name|aggdata
operator|->
name|dtada_data
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * The easier case here is if we actually have 				 * some prototype data -- in which case we 				 * manually dig it out of the aggregation 				 * record. 				 */
comment|/* LINTED - alignment */
name|larg
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|aggdata
operator|->
name|dtada_data
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We don't have any prototype data.  As a 				 * result, we know that we _do_ have the 				 * compiler-generated information.  (If this 				 * were an anonymous enabling, all of our 				 * zero-filled data would have prototype data 				 * -- either directly or indirectly.) So as 				 * gross as it is, we'll grovel around in the 				 * compiler-generated information to find the 				 * lquantize() parameters. 				 */
name|dtrace_stmtdesc_t
modifier|*
name|sdp
decl_stmt|;
name|dt_ident_t
modifier|*
name|aid
decl_stmt|;
name|dt_idsig_t
modifier|*
name|isp
decl_stmt|;
name|sdp
operator|=
operator|(
name|dtrace_stmtdesc_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|aggdesc
operator|->
name|dtagd_rec
index|[
literal|0
index|]
operator|.
name|dtrd_uarg
expr_stmt|;
name|aid
operator|=
name|sdp
operator|->
name|dtsd_aggdata
expr_stmt|;
name|isp
operator|=
operator|(
name|dt_idsig_t
operator|*
operator|)
name|aid
operator|->
name|di_data
expr_stmt|;
name|assert
argument_list|(
name|isp
operator|->
name|dis_auxinfo
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|larg
operator|=
name|isp
operator|->
name|dis_auxinfo
expr_stmt|;
block|}
comment|/* LINTED - alignment */
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|zdata
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
operator|)
operator|=
name|larg
expr_stmt|;
block|}
name|aggdata
operator|->
name|dtada_data
operator|=
name|zdata
expr_stmt|;
block|}
comment|/* 	 * Now that we've dealt with setting up our zero-filled data, we can 	 * allocate our sorted array, and take another pass over the data to 	 * fill it. 	 */
name|sorted
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|nentries
operator|*
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorted
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_all
operator|,
name|i
operator|=
literal|0
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|dtahe_nextall
control|)
block|{
name|dtrace_aggvarid_t
name|id
decl_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|dt_aggregate_aggvarid
argument_list|(
name|h
argument_list|)
operator|)
operator|>
name|max
operator|||
operator|!
name|map
index|[
name|id
index|]
condition|)
continue|continue;
name|sorted
index|[
name|i
operator|++
index|]
operator|=
name|h
expr_stmt|;
block|}
name|assert
argument_list|(
name|i
operator|==
name|nentries
argument_list|)
expr_stmt|;
comment|/* 	 * We've loaded our array; now we need to sort by value to allow us 	 * to create bundles of like value.  We're going to acquire the 	 * dt_qsort_lock here, and hold it across all of our subsequent 	 * comparison and sorting. 	 */
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dt_qsort_lock
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
argument_list|)
argument_list|,
name|dt_aggregate_keyvarcmp
argument_list|)
expr_stmt|;
comment|/* 	 * Now we need to go through and create bundles.  Because the number 	 * of bundles is bounded by the size of the sorted array, we're going 	 * to reuse the underlying storage.  And note that "bundle" is an 	 * array of pointers to arrays of pointers to dt_ahashent_t -- making 	 * its type (regrettably) "dt_ahashent_t ***".  (Regrettable because 	 * '*' -- like '_' and 'X' -- should never appear in triplicate in 	 * an ideal world.) 	 */
name|bundle
operator|=
operator|(
name|dt_ahashent_t
operator|*
operator|*
operator|*
operator|)
name|sorted
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|start
operator|=
literal|0
init|;
name|i
operator|<=
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|nentries
operator|&&
name|dt_aggregate_keycmp
argument_list|(
operator|&
name|sorted
index|[
name|i
index|]
argument_list|,
operator|&
name|sorted
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * We have a bundle boundary.  Everything from start to 		 * (i - 1) belongs in one bundle. 		 */
name|assert
argument_list|(
name|i
operator|-
name|start
operator|<=
name|naggvars
argument_list|)
expr_stmt|;
name|bundlesize
operator|=
operator|(
name|naggvars
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nbundle
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
name|bundlesize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dt_qsort_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|j
operator|=
name|start
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|dtrace_aggvarid_t
name|id
init|=
name|dt_aggregate_aggvarid
argument_list|(
name|sorted
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|id
operator|<=
name|max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|map
index|[
name|id
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|map
index|[
name|id
index|]
operator|-
literal|1
operator|<
name|naggvars
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nbundle
index|[
name|map
index|[
name|id
index|]
operator|-
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|nbundle
index|[
name|map
index|[
name|id
index|]
operator|-
literal|1
index|]
operator|=
name|sorted
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|nbundle
index|[
name|naggvars
index|]
operator|==
name|NULL
condition|)
name|nbundle
index|[
name|naggvars
index|]
operator|=
name|sorted
index|[
name|j
index|]
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|naggvars
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nbundle
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* 			 * Before we assume that this aggregation variable 			 * isn't present (and fall back to using the 			 * zero-filled data allocated earlier), check the 			 * remap.  If we have a remapping, we'll drop it in 			 * here.  Note that we might be remapping an 			 * aggregation variable that isn't present for this 			 * key; in this case, the aggregation data that we 			 * copy will point to the zeroed data. 			 */
if|if
condition|(
name|remap
operator|!=
name|NULL
operator|&&
name|remap
index|[
name|j
index|]
condition|)
block|{
name|assert
argument_list|(
name|remap
index|[
name|j
index|]
operator|-
literal|1
operator|<
name|j
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nbundle
index|[
name|remap
index|[
name|j
index|]
operator|-
literal|1
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nbundle
index|[
name|j
index|]
operator|=
name|nbundle
index|[
name|remap
index|[
name|j
index|]
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|nbundle
index|[
name|j
index|]
operator|=
operator|&
name|zaggdata
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|bundle
index|[
name|nbundles
operator|++
index|]
operator|=
name|nbundle
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
block|}
comment|/* 	 * Now we need to re-sort based on the first value. 	 */
name|dt_aggregate_qsort
argument_list|(
name|dtp
argument_list|,
name|bundle
argument_list|,
name|nbundles
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_ahashent_t
operator|*
operator|*
argument_list|)
argument_list|,
name|dt_aggregate_bundlecmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dt_qsort_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We're done!  Now we just need to go back over the sorted bundles, 	 * calling the function. 	 */
name|data
operator|=
name|alloca
argument_list|(
operator|(
name|naggvars
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_aggdata_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbundles
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|naggvars
condition|;
name|j
operator|++
control|)
name|data
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|naggvars
condition|;
name|j
operator|++
control|)
block|{
name|int
name|ndx
init|=
name|j
operator|-
name|sortpos
decl_stmt|;
if|if
condition|(
name|ndx
operator|<
literal|0
condition|)
name|ndx
operator|+=
name|naggvars
expr_stmt|;
name|assert
argument_list|(
name|bundle
index|[
name|i
index|]
index|[
name|ndx
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|data
index|[
name|j
operator|+
literal|1
index|]
operator|=
operator|&
name|bundle
index|[
name|i
index|]
index|[
name|ndx
index|]
operator|->
name|dtahe_data
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|naggvars
condition|;
name|j
operator|++
control|)
name|assert
argument_list|(
name|data
index|[
name|j
operator|+
literal|1
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * The representative key is the last element in the bundle. 		 * Assert that we have one, and then set it to be the first 		 * element of data. 		 */
name|assert
argument_list|(
name|bundle
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
operator|&
name|bundle
index|[
name|i
index|]
index|[
name|j
index|]
operator|->
name|dtahe_data
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|func
argument_list|(
name|data
argument_list|,
name|naggvars
operator|+
literal|1
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
block|}
name|rval
operator|=
literal|0
expr_stmt|;
name|out
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbundles
condition|;
name|i
operator|++
control|)
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|bundle
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zaggdata
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naggvars
condition|;
name|i
operator|++
control|)
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|zaggdata
index|[
name|i
index|]
operator|.
name|dtahe_data
operator|.
name|dtada_data
argument_list|)
expr_stmt|;
block|}
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|zaggdata
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|remap
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_aggregate_print
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|dtrace_aggregate_walk_f
modifier|*
name|func
parameter_list|)
block|{
name|dt_print_aggdata_t
name|pd
decl_stmt|;
name|pd
operator|.
name|dtpa_dtp
operator|=
name|dtp
expr_stmt|;
name|pd
operator|.
name|dtpa_fp
operator|=
name|fp
expr_stmt|;
name|pd
operator|.
name|dtpa_allunprint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
name|func
operator|=
name|dtrace_aggregate_walk_sorted
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|func
call|)
argument_list|(
name|dtp
argument_list|,
name|dt_print_agg
argument_list|,
operator|&
name|pd
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|dtp
operator|->
name|dt_errno
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dtrace_aggregate_clear
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|agp
operator|->
name|dtat_hash
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|h
decl_stmt|;
name|dtrace_aggdata_t
modifier|*
name|data
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|aggdesc
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_cpus
init|=
name|agp
operator|->
name|dtat_maxcpu
decl_stmt|;
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_all
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|dtahe_nextall
control|)
block|{
name|aggdesc
operator|=
name|h
operator|->
name|dtahe_data
operator|.
name|dtada_desc
expr_stmt|;
name|rec
operator|=
operator|&
name|aggdesc
operator|->
name|dtagd_rec
index|[
name|aggdesc
operator|->
name|dtagd_nrecs
operator|-
literal|1
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|h
operator|->
name|dtahe_data
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|data
operator|->
name|dtada_data
index|[
name|rec
operator|->
name|dtrd_offset
index|]
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|dtada_percpu
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cpus
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
name|data
operator|->
name|dtada_percpu
index|[
name|i
index|]
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_aggregate_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_aggregate_t
modifier|*
name|agp
init|=
operator|&
name|dtp
operator|->
name|dt_aggregate
decl_stmt|;
name|dt_ahash_t
modifier|*
name|hash
init|=
operator|&
name|agp
operator|->
name|dtat_hash
decl_stmt|;
name|dt_ahashent_t
modifier|*
name|h
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dtrace_aggdata_t
modifier|*
name|aggdata
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_cpus
init|=
name|agp
operator|->
name|dtat_maxcpu
decl_stmt|;
if|if
condition|(
name|hash
operator|->
name|dtah_hash
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|hash
operator|->
name|dtah_all
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|hash
operator|->
name|dtah_hash
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|hash
operator|->
name|dtah_all
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|next
control|)
block|{
name|next
operator|=
name|h
operator|->
name|dtahe_nextall
expr_stmt|;
name|aggdata
operator|=
operator|&
name|h
operator|->
name|dtahe_data
expr_stmt|;
if|if
condition|(
name|aggdata
operator|->
name|dtada_percpu
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cpus
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_percpu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_percpu
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|aggdata
operator|->
name|dtada_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
name|hash
operator|->
name|dtah_hash
operator|=
name|NULL
expr_stmt|;
name|hash
operator|->
name|dtah_all
operator|=
name|NULL
expr_stmt|;
name|hash
operator|->
name|dtah_size
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|agp
operator|->
name|dtat_buf
operator|.
name|dtbd_data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|agp
operator|->
name|dtat_cpus
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

