begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * This file implements an audit library that can be used to force the loading  * of helper providers. The default disposition for a helper provider -- USDT  * and ustack helpers -- is to load itself from it's containing object's .init  * section. In cases where startup time is deemed critical, USDT authors can  * use the -xlazyload option to dtrace(1M) to disable automatic loading (it's  * difficult to make the case for the utility of this feature for anything  * other than libc which, indeed, was the sole motivation). If a binary has  * been compiled with automatic loading disabled, this audit library may be  * used to force automatic loading:  *  *	LD_AUDIT_32=/usr/lib/dtrace/libdaudit.so  *	LD_AUDIT_64=/usr/lib/dtrace/64/libdaudit.so  */
end_comment

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<libproc.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<dlink.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|obj_list
block|{
name|struct
name|obj_list
modifier|*
name|ol_next
decl_stmt|;
name|char
modifier|*
name|ol_name
decl_stmt|;
name|uintptr_t
name|ol_addr
decl_stmt|;
name|Lmid_t
name|ol_lmid
decl_stmt|;
block|}
name|obj_list_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|obj_list_t
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_pragma
pragma|#
directive|pragma
name|init
name|(
name|dtrace_daudit_init
name|)
end_pragma

begin_function
specifier|static
name|void
name|dtrace_daudit_init
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_link_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|uint_t
name|la_version
parameter_list|(
name|uint_t
name|version
parameter_list|)
block|{
return|return
operator|(
name|LAV_CURRENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Record objects into our linked list as they're loaded.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|uint_t
name|la_objopen
parameter_list|(
name|Link_map
modifier|*
name|lmp
parameter_list|,
name|Lmid_t
name|lmid
parameter_list|,
name|uintptr_t
modifier|*
name|cookie
parameter_list|)
block|{
name|obj_list_t
modifier|*
name|node
decl_stmt|;
comment|/* 	 * If we can't allocate the next node in our list, we'll try to emit a 	 * message, but it's possible that might fail as well. 	 */
if|if
condition|(
operator|(
name|node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|obj_list_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|0
argument_list|,
literal|"libdaudit: failed to allocate"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|node
operator|->
name|ol_next
operator|=
name|list
expr_stmt|;
name|node
operator|->
name|ol_name
operator|=
name|strdup
argument_list|(
name|lmp
operator|->
name|l_name
argument_list|)
expr_stmt|;
name|node
operator|->
name|ol_addr
operator|=
name|lmp
operator|->
name|l_addr
expr_stmt|;
name|node
operator|->
name|ol_lmid
operator|=
name|lmid
expr_stmt|;
name|list
operator|=
name|node
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Once the link maps have reached a consistent state, process the list of  * objects that were loaded. We need to use libproc to search for the  * ___SUNW_dof symbol rather than dlsym(3C) since the symbol is not in the  * dynamic (run-time) symbol table (though it is, of course, in the symtab).  * Once we find it, we ioctl(2) it to the kernel just as we would have from  * the .init section if automatic loading were enabled.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|la_activity
parameter_list|(
name|uintptr_t
modifier|*
name|cookie
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
name|int
name|err
decl_stmt|,
name|ret
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|flags
operator|!=
name|LA_ACT_CONSISTENT
condition|)
return|return;
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|obj_list_t
modifier|*
name|node
init|=
name|list
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|node
operator|->
name|ol_name
decl_stmt|;
name|list
operator|=
name|node
operator|->
name|ol_next
expr_stmt|;
name|P
operator|=
name|Pgrab
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|PGRAB_RDONLY
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|ret
operator|=
name|Plookup_by_name
argument_list|(
name|P
argument_list|,
name|name
argument_list|,
literal|"___SUNW_dof"
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|Prelease
argument_list|(
name|P
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|dtrace_link_dof
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|sym
operator|.
name|st_value
argument_list|,
name|node
operator|->
name|ol_lmid
argument_list|,
name|node
operator|->
name|ol_name
argument_list|,
name|node
operator|->
name|ol_addr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|node
operator|->
name|ol_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

