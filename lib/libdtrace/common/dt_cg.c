begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/isa_defs.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_grammar.h>
end_include

begin_include
include|#
directive|include
file|<dt_parser.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_function_decl
specifier|static
name|void
name|dt_cg_node
parameter_list|(
name|dt_node_t
modifier|*
parameter_list|,
name|dt_irlist_t
modifier|*
parameter_list|,
name|dt_regset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|dt_irnode_t
modifier|*
name|dt_cg_node_alloc
parameter_list|(
name|uint_t
name|label
parameter_list|,
name|dif_instr_t
name|instr
parameter_list|)
block|{
name|dt_irnode_t
modifier|*
name|dip
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_irnode_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dip
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dip
operator|->
name|di_label
operator|=
name|label
expr_stmt|;
name|dip
operator|->
name|di_instr
operator|=
name|instr
expr_stmt|;
name|dip
operator|->
name|di_extern
operator|=
name|NULL
expr_stmt|;
name|dip
operator|->
name|di_next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|dip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Code generator wrapper function for ctf_member_info.  If we are given a  * reference to a forward declaration tag, search the entire type space for  * the actual definition and then call ctf_member_info on the result.  */
end_comment

begin_function
specifier|static
name|ctf_file_t
modifier|*
name|dt_cg_membinfo
parameter_list|(
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|ctf_membinfo_t
modifier|*
name|mp
parameter_list|)
block|{
while|while
condition|(
name|ctf_type_kind
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
operator|==
name|CTF_K_FORWARD
condition|)
block|{
name|char
name|n
index|[
name|DT_TYPE_NAMELEN
index|]
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
if|if
condition|(
name|ctf_type_name
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|n
argument_list|)
argument_list|)
operator|==
name|NULL
operator|||
name|dt_type_lookup
argument_list|(
name|n
argument_list|,
operator|&
name|dtt
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|dtt
operator|.
name|dtt_ctfp
operator|==
name|fp
operator|&&
name|dtt
operator|.
name|dtt_type
operator|==
name|type
operator|)
condition|)
break|break;
comment|/* unable to improve our position */
name|fp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dtt
operator|.
name|dtt_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_member_info
argument_list|(
name|fp
argument_list|,
name|type
argument_list|,
name|s
argument_list|,
name|mp
argument_list|)
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* ctf_errno is set for us */
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_xsetx
parameter_list|(
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|uint_t
name|lbl
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
name|x
parameter_list|)
block|{
name|int
name|flag
init|=
name|idp
operator|!=
name|NULL
condition|?
name|DT_INT_PRIVATE
else|:
name|DT_INT_SHARED
decl_stmt|;
name|int
name|intoff
init|=
name|dt_inttab_insert
argument_list|(
name|yypcb
operator|->
name|pcb_inttab
argument_list|,
name|x
argument_list|,
name|flag
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
init|=
name|DIF_INSTR_SETX
argument_list|(
operator|(
name|uint_t
operator|)
name|intoff
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|intoff
operator|==
operator|-
literal|1
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|intoff
operator|>
name|DIF_INTOFF_MAX
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_INT2BIG
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|!=
name|NULL
condition|)
name|dlp
operator|->
name|dl_last
operator|->
name|di_extern
operator|=
name|idp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_setx
parameter_list|(
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
name|x
parameter_list|)
block|{
name|dt_cg_xsetx
argument_list|(
name|dlp
argument_list|,
name|NULL
argument_list|,
name|DT_LBL_NONE
argument_list|,
name|reg
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When loading bit-fields, we want to convert a byte count in the range  * 1-8 to the closest power of 2 (e.g. 3->4, 5->8, etc).  The clp2() function  * is a clever implementation from "Hacker's Delight" by Henry Warren, Jr.  */
end_comment

begin_function
specifier|static
name|size_t
name|clp2
parameter_list|(
name|size_t
name|x
parameter_list|)
block|{
name|x
operator|--
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|1
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|2
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|4
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
name|x
operator||=
operator|(
name|x
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
operator|(
name|x
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the correct load opcode to use for the specified node and CTF type.  * We determine the size and convert it to a 3-bit index.  Our lookup table  * is constructed to use a 5-bit index, consisting of the 3-bit size 0-7, a  * bit for the sign, and a bit for userland address.  For example, a 4-byte  * signed load from userland would be at the following table index:  * user=1 sign=1 size=4 => binary index 11011 = decimal index 27  */
end_comment

begin_function
specifier|static
name|uint_t
name|dt_cg_load
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|ctf_file_t
modifier|*
name|ctfp
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
specifier|static
specifier|const
name|uint_t
name|ops
index|[]
init|=
block|{
name|DIF_OP_LDUB
block|,
name|DIF_OP_LDUH
block|,
literal|0
block|,
name|DIF_OP_LDUW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|DIF_OP_LDX
block|,
name|DIF_OP_LDSB
block|,
name|DIF_OP_LDSH
block|,
literal|0
block|,
name|DIF_OP_LDSW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|DIF_OP_LDX
block|,
name|DIF_OP_ULDUB
block|,
name|DIF_OP_ULDUH
block|,
literal|0
block|,
name|DIF_OP_ULDUW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|DIF_OP_ULDX
block|,
name|DIF_OP_ULDSB
block|,
name|DIF_OP_ULDSH
block|,
literal|0
block|,
name|DIF_OP_ULDSW
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|DIF_OP_ULDX
block|, 	}
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
comment|/* 	 * If we're loading a bit-field, the size of our load is found by 	 * rounding cte_bits up to a byte boundary and then finding the 	 * nearest power of two to this value (see clp2(), above). 	 */
if|if
condition|(
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
operator|)
operator|&&
name|ctf_type_encoding
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
operator|&
name|e
argument_list|)
operator|!=
name|CTF_ERR
condition|)
name|size
operator|=
name|clp2
argument_list|(
name|P2ROUNDUP
argument_list|(
name|e
operator|.
name|cte_bits
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|8
operator|||
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error -- cg cannot load "
literal|"size %ld when passed by value\n"
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
name|size
operator|--
expr_stmt|;
comment|/* convert size to 3-bit index */
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
name|size
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
condition|)
name|size
operator||=
literal|0x10
expr_stmt|;
return|return
operator|(
name|ops
index|[
name|size
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_ptrsize
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|uint_t
name|op
parameter_list|,
name|int
name|dreg
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_arinfo_t
name|r
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|uint_t
name|kind
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|int
name|sreg
decl_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|kind
operator|==
name|CTF_K_POINTER
operator|||
name|kind
operator|==
name|CTF_K_ARRAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_ARRAY
condition|)
block|{
if|if
condition|(
name|ctf_array_info
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|,
operator|&
name|r
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|ctfp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|r
operator|.
name|ctr_contents
expr_stmt|;
block|}
else|else
name|type
operator|=
name|ctf_type_reference
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
operator|)
operator|==
literal|1
condition|)
return|return;
comment|/* multiply or divide by one can be omitted */
name|sreg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|sreg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|op
argument_list|,
name|dreg
argument_list|,
name|sreg
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the result of a "." or "->" operation is a bit-field, we use this routine  * to generate an epilogue to the load instruction that extracts the value.  In  * the diagrams below the "ld??" is the load instruction that is generated to  * load the containing word that is generating prior to calling this function.  *  * Epilogue for unsigned fields:	Epilogue for signed fields:  *  * ldu?	[r1], r1			lds? [r1], r1  * setx	USHIFT, r2			setx 64 - SSHIFT, r2  * srl	r1, r2, r1			sll  r1, r2, r1  * setx	(1<< bits) - 1, r2		setx 64 - bits, r2  * and	r1, r2, r1			sra  r1, r2, r1  *  * The *SHIFT constants above changes value depending on the endian-ness of our  * target architecture.  Refer to the comments below for more details.  */
end_comment

begin_function
specifier|static
name|void
name|dt_cg_field_get
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|ctf_file_t
modifier|*
name|fp
parameter_list|,
specifier|const
name|ctf_membinfo_t
modifier|*
name|mp
parameter_list|)
block|{
name|ctf_encoding_t
name|e
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|uint64_t
name|shift
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|ctm_type
argument_list|,
operator|&
name|e
argument_list|)
operator|!=
literal|0
operator|||
name|e
operator|.
name|cte_bits
operator|>
literal|64
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"cg: bad field: off %lu type<%ld> "
literal|"bits %u\n"
argument_list|,
name|mp
operator|->
name|ctm_offset
argument_list|,
name|mp
operator|->
name|ctm_type
argument_list|,
name|e
operator|.
name|cte_bits
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_PTR
operator|||
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_DOT
argument_list|)
expr_stmt|;
name|r1
operator|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
expr_stmt|;
name|r2
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
comment|/* 	 * On little-endian architectures, ctm_offset counts from the right so 	 * ctm_offset % NBBY itself is the amount we want to shift right to 	 * move the value bits to the little end of the register to mask them. 	 * On big-endian architectures, ctm_offset counts from the left so we 	 * must subtract (ctm_offset % NBBY + cte_bits) from the size in bits 	 * we used for the load.  The size of our load in turn is found by 	 * rounding cte_bits up to a byte boundary and then finding the 	 * nearest power of two to this value (see clp2(), above).  These 	 * properties are used to compute shift as USHIFT or SSHIFT, below. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
condition|)
block|{
ifdef|#
directive|ifdef
name|_BIG_ENDIAN
name|shift
operator|=
name|clp2
argument_list|(
name|P2ROUNDUP
argument_list|(
name|e
operator|.
name|cte_bits
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|)
operator|*
name|NBBY
operator|-
name|mp
operator|->
name|ctm_offset
operator|%
name|NBBY
expr_stmt|;
else|#
directive|else
name|shift
operator|=
name|mp
operator|->
name|ctm_offset
operator|%
name|NBBY
operator|+
name|e
operator|.
name|cte_bits
expr_stmt|;
endif|#
directive|endif
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r2
argument_list|,
literal|64
operator|-
name|shift
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SLL
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r2
argument_list|,
literal|64
operator|-
name|e
operator|.
name|cte_bits
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SRA
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|_BIG_ENDIAN
name|shift
operator|=
name|clp2
argument_list|(
name|P2ROUNDUP
argument_list|(
name|e
operator|.
name|cte_bits
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|)
operator|*
name|NBBY
operator|-
operator|(
name|mp
operator|->
name|ctm_offset
operator|%
name|NBBY
operator|+
name|e
operator|.
name|cte_bits
operator|)
expr_stmt|;
else|#
directive|else
name|shift
operator|=
name|mp
operator|->
name|ctm_offset
operator|%
name|NBBY
expr_stmt|;
endif|#
directive|endif
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r2
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SRL
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r2
argument_list|,
operator|(
literal|1ULL
operator|<<
name|e
operator|.
name|cte_bits
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_AND
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the destination of a store operation is a bit-field, we use this routine  * to generate a prologue to the store instruction that loads the surrounding  * bits, clears the destination field, and ORs in the new value of the field.  * In the diagram below the "st?" is the store instruction that is generated to  * store the containing word that is generating after calling this function.  *  * ld	[dst->dn_reg], r1  * setx	~(((1<< cte_bits) - 1)<< (ctm_offset % NBBY)), r2  * and	r1, r2, r1  *  * setx	(1<< cte_bits) - 1, r2  * and	src->dn_reg, r2, r2  * setx ctm_offset % NBBY, r3  * sll	r2, r3, r2  *  * or	r1, r2, r1  * st?	r1, [dst->dn_reg]  *  * This routine allocates a new register to hold the value to be stored and  * returns it.  The caller is responsible for freeing this register later.  */
end_comment

begin_function
specifier|static
name|int
name|dt_cg_field_set
parameter_list|(
name|dt_node_t
modifier|*
name|src
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|dt_node_t
modifier|*
name|dst
parameter_list|)
block|{
name|uint64_t
name|cmask
decl_stmt|,
name|fmask
decl_stmt|,
name|shift
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|;
name|ctf_membinfo_t
name|m
decl_stmt|;
name|ctf_encoding_t
name|e
decl_stmt|;
name|ctf_file_t
modifier|*
name|fp
decl_stmt|,
modifier|*
name|ofp
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|assert
argument_list|(
name|dst
operator|->
name|dn_op
operator|==
name|DT_TOK_PTR
operator|||
name|dst
operator|->
name|dn_op
operator|==
name|DT_TOK_DOT
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dst
operator|->
name|dn_right
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
argument_list|)
expr_stmt|;
name|fp
operator|=
name|dst
operator|->
name|dn_left
operator|->
name|dn_ctfp
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|dst
operator|->
name|dn_left
operator|->
name|dn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|dn_op
operator|==
name|DT_TOK_PTR
condition|)
block|{
name|type
operator|=
name|ctf_type_reference
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|fp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|dt_cg_membinfo
argument_list|(
name|ofp
operator|=
name|fp
argument_list|,
name|type
argument_list|,
name|dst
operator|->
name|dn_right
operator|->
name|dn_string
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctf_type_encoding
argument_list|(
name|fp
argument_list|,
name|m
operator|.
name|ctm_type
argument_list|,
operator|&
name|e
argument_list|)
operator|!=
literal|0
operator|||
name|e
operator|.
name|cte_bits
operator|>
literal|64
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"cg: bad field: off %lu type<%ld> "
literal|"bits %u\n"
argument_list|,
name|m
operator|.
name|ctm_offset
argument_list|,
name|m
operator|.
name|ctm_type
argument_list|,
name|e
operator|.
name|cte_bits
argument_list|)
expr_stmt|;
block|}
name|r1
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|r2
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|r3
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute shifts and masks.  We need to compute "shift" as the amount 	 * we need to shift left to position our field in the containing word. 	 * Refer to the comments in dt_cg_field_get(), above, for more info. 	 * We then compute fmask as the mask that truncates the value in the 	 * input register to width cte_bits, and cmask as the mask used to 	 * pass through the containing bits and zero the field bits. 	 */
ifdef|#
directive|ifdef
name|_BIG_ENDIAN
name|shift
operator|=
name|clp2
argument_list|(
name|P2ROUNDUP
argument_list|(
name|e
operator|.
name|cte_bits
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|)
operator|*
name|NBBY
operator|-
operator|(
name|m
operator|.
name|ctm_offset
operator|%
name|NBBY
operator|+
name|e
operator|.
name|cte_bits
operator|)
expr_stmt|;
else|#
directive|else
name|shift
operator|=
name|m
operator|.
name|ctm_offset
operator|%
name|NBBY
expr_stmt|;
endif|#
directive|endif
name|fmask
operator|=
operator|(
literal|1ULL
operator|<<
name|e
operator|.
name|cte_bits
operator|)
operator|-
literal|1
expr_stmt|;
name|cmask
operator|=
operator|~
operator|(
name|fmask
operator|<<
name|shift
operator|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_LOAD
argument_list|(
name|dt_cg_load
argument_list|(
name|dst
argument_list|,
name|fp
argument_list|,
name|m
operator|.
name|ctm_type
argument_list|)
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r2
argument_list|,
name|cmask
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_AND
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r2
argument_list|,
name|fmask
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_AND
argument_list|,
name|src
operator|->
name|dn_reg
argument_list|,
name|r2
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r3
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SLL
argument_list|,
name|r2
argument_list|,
name|r3
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_OR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|r3
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|r2
argument_list|)
expr_stmt|;
return|return
operator|(
name|r1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_store
parameter_list|(
name|dt_node_t
modifier|*
name|src
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|dt_node_t
modifier|*
name|dst
parameter_list|)
block|{
name|ctf_encoding_t
name|e
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* 	 * If we're loading a bit-field, the size of our store is found by 	 * rounding dst's cte_bits up to a byte boundary and then finding the 	 * nearest power of two to this value (see clp2(), above). 	 */
if|if
condition|(
operator|(
name|dst
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
operator|)
operator|&&
name|ctf_type_encoding
argument_list|(
name|dst
operator|->
name|dn_ctfp
argument_list|,
name|dst
operator|->
name|dn_type
argument_list|,
operator|&
name|e
argument_list|)
operator|!=
name|CTF_ERR
condition|)
name|size
operator|=
name|clp2
argument_list|(
name|P2ROUNDUP
argument_list|(
name|e
operator|.
name|cte_bits
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|dt_node_type_size
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
condition|)
block|{
name|reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|reg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_COPYS
argument_list|(
name|src
operator|->
name|dn_reg
argument_list|,
name|reg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dst
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
condition|)
name|reg
operator|=
name|dt_cg_field_set
argument_list|(
name|src
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
name|src
operator|->
name|dn_reg
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STB
argument_list|,
name|reg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STH
argument_list|,
name|reg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STW
argument_list|,
name|reg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STX
argument_list|,
name|reg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error -- cg cannot store "
literal|"size %lu when passed by value\n"
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
condition|)
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Generate code for a typecast or for argument promotion from the type of the  * actual to the type of the formal.  We need to generate code for casts when  * a scalar type is being narrowed or changing signed-ness.  We first shift the  * desired bits high (losing excess bits if narrowing) and then shift them down  * using logical shift (unsigned result) or arithmetic shift (signed result).  */
end_comment

begin_function
specifier|static
name|void
name|dt_cg_typecast
parameter_list|(
specifier|const
name|dt_node_t
modifier|*
name|src
parameter_list|,
specifier|const
name|dt_node_t
modifier|*
name|dst
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|size_t
name|srcsize
init|=
name|dt_node_type_size
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|size_t
name|dstsize
init|=
name|dt_node_type_size
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|int
name|rg
decl_stmt|;
if|if
condition|(
operator|!
name|dt_node_is_scalar
argument_list|(
name|dst
argument_list|)
condition|)
return|return;
comment|/* not a scalar */
if|if
condition|(
name|dstsize
operator|==
name|srcsize
operator|&&
operator|(
operator|(
name|src
operator|->
name|dn_flags
operator|^
name|dst
operator|->
name|dn_flags
operator|)
operator|&
name|DT_NF_SIGNED
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* not narrowing or changing signed-ness */
if|if
condition|(
name|dstsize
operator|>
name|srcsize
operator|&&
operator|(
name|src
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* nothing to do in this case */
name|rg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstsize
operator|>
name|srcsize
condition|)
block|{
name|int
name|n
init|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|NBBY
operator|-
name|srcsize
operator|*
name|NBBY
decl_stmt|;
name|int
name|s
init|=
operator|(
name|dstsize
operator|-
name|srcsize
operator|)
operator|*
name|NBBY
decl_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|rg
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SLL
argument_list|,
name|src
operator|->
name|dn_reg
argument_list|,
name|rg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
operator|||
name|n
operator|==
name|s
condition|)
block|{
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SRA
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|,
name|rg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|rg
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SRA
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|,
name|rg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|rg
argument_list|,
name|n
operator|-
name|s
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SRL
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|,
name|rg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dstsize
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|int
name|n
init|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|NBBY
operator|-
name|dstsize
operator|*
name|NBBY
decl_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|rg
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SLL
argument_list|,
name|src
operator|->
name|dn_reg
argument_list|,
name|rg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
operator|(
name|dst
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SRA
else|:
name|DIF_OP_SRL
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|,
name|rg
argument_list|,
name|dst
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|rg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate code to push the specified argument list on to the tuple stack.  * We use this routine for handling subroutine calls and associative arrays.  * We must first generate code for all subexpressions before loading the stack  * because any subexpression could itself require the use of the tuple stack.  * This holds a number of registers equal to the number of arguments, but this  * is not a huge problem because the number of arguments can't exceed the  * number of tuple register stack elements anyway.  At most one extra register  * is required (either by dt_cg_typecast() or for dtdt_size, below).  This  * implies that a DIF implementation should offer a number of general purpose  * registers at least one greater than the number of tuple registers.  */
end_comment

begin_function
specifier|static
name|void
name|dt_cg_arglist
parameter_list|(
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|dt_node_t
modifier|*
name|args
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
specifier|const
name|dt_idsig_t
modifier|*
name|isp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|dt_node_t
modifier|*
name|dnp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|dnp
operator|=
name|args
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
control|)
name|dt_cg_node
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|DIF_INSTR_FLUSHTS
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dnp
operator|=
name|args
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_list
operator|,
name|i
operator|++
control|)
block|{
name|dtrace_diftype_t
name|t
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|uint_t
name|op
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|dt_node_diftype
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|,
name|dnp
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
operator|.
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_reg
expr_stmt|;
comment|/* re-use register */
name|dt_cg_typecast
argument_list|(
name|dnp
argument_list|,
operator|&
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|isp
operator|->
name|dis_args
index|[
name|i
index|]
operator|.
name|dn_reg
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|op
operator|=
name|DIF_OP_PUSHTR
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|dtdt_size
operator|!=
literal|0
condition|)
block|{
name|reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|reg
argument_list|,
name|t
operator|.
name|dtdt_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|DIF_REG_R0
expr_stmt|;
block|}
block|}
else|else
block|{
name|op
operator|=
name|DIF_OP_PUSHTV
expr_stmt|;
name|reg
operator|=
name|DIF_REG_R0
expr_stmt|;
block|}
name|instr
operator|=
name|DIF_INSTR_PUSHTS
argument_list|(
name|op
argument_list|,
name|t
operator|.
name|dtdt_kind
argument_list|,
name|reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|DIF_REG_R0
condition|)
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_conf
operator|.
name|dtc_diftupregs
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOTUPREG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_arithmetic_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|uint_t
name|op
parameter_list|)
block|{
name|int
name|is_ptr_op
init|=
operator|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_ADD
operator|||
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_SUB
operator|||
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_ADD_EQ
operator|||
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_SUB_EQ
operator|)
decl_stmt|;
name|int
name|lp_is_ptr
init|=
name|dt_node_is_pointer
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|)
decl_stmt|;
name|int
name|rp_is_ptr
init|=
name|dt_node_is_pointer
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
if|if
condition|(
name|lp_is_ptr
operator|&&
name|rp_is_ptr
condition|)
block|{
name|assert
argument_list|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_SUB
argument_list|)
expr_stmt|;
name|is_ptr_op
operator|=
literal|0
expr_stmt|;
block|}
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptr_op
operator|&&
name|rp_is_ptr
condition|)
name|dt_cg_ptrsize
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_MUL
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ptr_op
operator|&&
name|lp_is_ptr
condition|)
name|dt_cg_ptrsize
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_MUL
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|op
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
expr_stmt|;
if|if
condition|(
name|lp_is_ptr
operator|&&
name|rp_is_ptr
condition|)
name|dt_cg_ptrsize
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_UDIV
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint_t
name|dt_cg_stvar
parameter_list|(
specifier|const
name|dt_ident_t
modifier|*
name|idp
parameter_list|)
block|{
specifier|static
specifier|const
name|uint_t
name|aops
index|[]
init|=
block|{
name|DIF_OP_STGAA
block|,
name|DIF_OP_STTAA
block|,
name|DIF_OP_NOP
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint_t
name|sops
index|[]
init|=
block|{
name|DIF_OP_STGS
block|,
name|DIF_OP_STTS
block|,
name|DIF_OP_STLS
block|}
decl_stmt|;
name|uint_t
name|i
init|=
operator|(
operator|(
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
operator|)
operator|!=
literal|0
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_TLS
operator|)
operator|!=
literal|0
operator|)
decl_stmt|;
return|return
operator|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|?
name|aops
index|[
name|i
index|]
else|:
name|sops
index|[
name|i
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_prearith_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|uint_t
name|op
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|ssize_t
name|size
init|=
literal|1
decl_stmt|;
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|dt_node_is_pointer
argument_list|(
name|dnp
argument_list|)
condition|)
block|{
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
operator|==
name|CTF_K_POINTER
argument_list|)
expr_stmt|;
name|size
operator|=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|ctf_type_reference
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
name|reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|reg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|op
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 	 * If we are modifying a variable, generate an stv instruction from 	 * the variable specified by the identifier.  If we are storing to a 	 * memory address, generate code again for the left-hand side using 	 * DT_NF_REF to get the address, and then generate a store to it. 	 * In both paths, we store the value in dnp->dn_reg (the new value). 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
condition|)
block|{
name|dt_ident_t
modifier|*
name|idp
init|=
name|dt_ident_resolve
argument_list|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_ident
argument_list|)
decl_stmt|;
name|idp
operator|->
name|di_flags
operator||=
name|DT_IDFLG_DIFW
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_STV
argument_list|(
name|dt_cg_stvar
argument_list|(
name|idp
argument_list|)
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint_t
name|rbit
init|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator||=
name|DT_NF_REF
expr_stmt|;
comment|/* force pass-by-ref */
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_store
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dnp
operator|->
name|dn_child
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&=
operator|~
name|DT_NF_REF
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator||=
name|rbit
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_postarith_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|uint_t
name|op
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|ssize_t
name|size
init|=
literal|1
decl_stmt|;
name|int
name|nreg
decl_stmt|;
if|if
condition|(
name|dt_node_is_pointer
argument_list|(
name|dnp
argument_list|)
condition|)
block|{
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ctf_type_kind
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
operator|==
name|CTF_K_POINTER
argument_list|)
expr_stmt|;
name|size
operator|=
name|ctf_type_size
argument_list|(
name|ctfp
argument_list|,
name|ctf_type_reference
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
name|nreg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|nreg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|op
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|nreg
argument_list|,
name|nreg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are modifying a variable, generate an stv instruction from 	 * the variable specified by the identifier.  If we are storing to a 	 * memory address, generate code again for the left-hand side using 	 * DT_NF_REF to get the address, and then generate a store to it. 	 * In both paths, we store the value from 'nreg' (the new value). 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
condition|)
block|{
name|dt_ident_t
modifier|*
name|idp
init|=
name|dt_ident_resolve
argument_list|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_ident
argument_list|)
decl_stmt|;
name|idp
operator|->
name|di_flags
operator||=
name|DT_IDFLG_DIFW
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_STV
argument_list|(
name|dt_cg_stvar
argument_list|(
name|idp
argument_list|)
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|nreg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint_t
name|rbit
init|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
decl_stmt|;
name|int
name|oreg
init|=
name|dnp
operator|->
name|dn_reg
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator||=
name|DT_NF_REF
expr_stmt|;
comment|/* force pass-by-ref */
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|nreg
expr_stmt|;
name|dt_cg_store
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dnp
operator|->
name|dn_child
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|oreg
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&=
operator|~
name|DT_NF_REF
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator||=
name|rbit
expr_stmt|;
block|}
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|nreg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine if we should perform signed or unsigned comparison for an OP2.  * If both operands are of arithmetic type, perform the usual arithmetic  * conversions to determine the common real type for comparison [ISOC 6.5.8.3].  */
end_comment

begin_function
specifier|static
name|int
name|dt_cg_compare_signed
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dt_node_t
name|dn
decl_stmt|;
if|if
condition|(
name|dt_node_is_string
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|)
operator|||
name|dt_node_is_string
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* strings always compare signed */
elseif|else
if|if
condition|(
operator|!
name|dt_node_is_arith
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|)
operator|||
operator|!
name|dt_node_is_arith
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* non-arithmetic types always compare unsigned */
name|bzero
argument_list|(
operator|&
name|dn
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_promote
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dnp
operator|->
name|dn_right
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
return|return
operator|(
name|dn
operator|.
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_compare_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|,
name|uint_t
name|op
parameter_list|)
block|{
name|uint_t
name|lbl_true
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|uint_t
name|lbl_post
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|uint_t
name|opc
decl_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_string
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|)
operator|||
name|dt_node_is_string
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|)
condition|)
name|opc
operator|=
name|DIF_OP_SCMP
expr_stmt|;
else|else
name|opc
operator|=
name|DIF_OP_CMP
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_CMP
argument_list|(
name|opc
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|op
argument_list|,
name|lbl_true
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|DIF_REG_R0
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BA
argument_list|,
name|lbl_post
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_xsetx
argument_list|(
name|dlp
argument_list|,
name|NULL
argument_list|,
name|lbl_true
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_post
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Code generation for the ternary op requires some trickery with the assembler  * in order to conserve registers.  We generate code for dn_expr and dn_left  * and free their registers so they do not have be consumed across codegen for  * dn_right.  We insert a dummy MOV at the end of dn_left into the destination  * register, which is not yet known because we haven't done dn_right yet, and  * save the pointer to this instruction node.  We then generate code for  * dn_right and use its register as our output.  Finally, we reach back and  * patch the instruction for dn_left to move its output into this register.  */
end_comment

begin_function
specifier|static
name|void
name|dt_cg_ternary_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|uint_t
name|lbl_false
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|uint_t
name|lbl_post
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_irnode_t
modifier|*
name|dip
decl_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_expr
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_expr
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_expr
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BE
argument_list|,
name|lbl_false
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
name|DIF_REG_R0
argument_list|)
expr_stmt|;
name|dip
operator|=
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
expr_stmt|;
comment|/* save dip for below */
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dip
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BA
argument_list|,
name|lbl_post
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_false
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
comment|/* 	 * Now that dn_reg is assigned, reach back and patch the correct MOV 	 * instruction into the tail of dn_left.  We know dn_reg was unused 	 * at that point because otherwise dn_right couldn't have allocated it. 	 */
name|dip
operator|->
name|di_instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_post
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_logical_and
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|uint_t
name|lbl_false
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|uint_t
name|lbl_post
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BE
argument_list|,
name|lbl_false
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BE
argument_list|,
name|lbl_false
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BA
argument_list|,
name|lbl_post
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|DIF_REG_R0
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_false
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_post
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_logical_xor
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|uint_t
name|lbl_next
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|uint_t
name|lbl_tail
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BE
argument_list|,
name|lbl_next
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_next
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BE
argument_list|,
name|lbl_tail
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_XOR
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_tail
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_logical_or
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|uint_t
name|lbl_true
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|uint_t
name|lbl_false
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|uint_t
name|lbl_post
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BNE
argument_list|,
name|lbl_true
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BE
argument_list|,
name|lbl_false
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_xsetx
argument_list|(
name|dlp
argument_list|,
name|NULL
argument_list|,
name|lbl_true
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BA
argument_list|,
name|lbl_post
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|DIF_REG_R0
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_false
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_post
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_logical_neg
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|uint_t
name|lbl_zero
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|uint_t
name|lbl_post
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BE
argument_list|,
name|lbl_zero
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|DIF_REG_R0
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BA
argument_list|,
name|lbl_post
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_xsetx
argument_list|(
name|dlp
argument_list|,
name|NULL
argument_list|,
name|lbl_zero
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|lbl_post
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_asgn_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
comment|/* 	 * If we are performing a structure assignment of a translated type, 	 * we must instantiate all members and create a snapshot of the object 	 * in scratch space.  We allocs a chunk of memory, generate code for 	 * each member, and then set dnp->dn_reg to the scratch object address. 	 */
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|DT_IDENT_XLSOU
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ctf_membinfo_t
name|ctm
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|idp
operator|->
name|di_data
decl_stmt|;
name|dt_node_t
modifier|*
name|mnp
decl_stmt|,
name|dn
decl_stmt|,
name|mn
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
comment|/* 		 * Create two fake dt_node_t's representing operator "." and a 		 * right-hand identifier child node.  These will be repeatedly 		 * modified according to each instantiated member so that we 		 * can pass them to dt_cg_store() and effect a member store. 		 */
name|bzero
argument_list|(
operator|&
name|dn
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|.
name|dn_kind
operator|=
name|DT_NODE_OP2
expr_stmt|;
name|dn
operator|.
name|dn_op
operator|=
name|DT_TOK_DOT
expr_stmt|;
name|dn
operator|.
name|dn_left
operator|=
name|dnp
expr_stmt|;
name|dn
operator|.
name|dn_right
operator|=
operator|&
name|mn
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mn
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|mn
operator|.
name|dn_kind
operator|=
name|DT_NODE_IDENT
expr_stmt|;
name|mn
operator|.
name|dn_op
operator|=
name|DT_TOK_IDENT
expr_stmt|;
comment|/* 		 * Allocate a register for our scratch data pointer.  First we 		 * set it to the size of our data structure, and then replace 		 * it with the result of an allocs of the specified size. 		 */
name|r1
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r1
argument_list|,
name|ctf_type_size
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_base
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_ALLOCS
argument_list|(
name|r1
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * When dt_cg_asgn_op() is called, we have already generated 		 * code for dnp->dn_right, which is the translator input.  We 		 * now associate this register with the translator's input 		 * identifier so it can be referenced during our member loop. 		 */
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_CGREG
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
for|for
control|(
name|mnp
operator|=
name|dxp
operator|->
name|dx_members
init|;
name|mnp
operator|!=
name|NULL
condition|;
name|mnp
operator|=
name|mnp
operator|->
name|dn_list
control|)
block|{
comment|/* 			 * Generate code for the translator member expression, 			 * and then cast the result to the member type. 			 */
name|dt_cg_node
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|mnp
operator|->
name|dn_reg
operator|=
name|mnp
operator|->
name|dn_membexpr
operator|->
name|dn_reg
expr_stmt|;
name|dt_cg_typecast
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|,
name|mnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
comment|/* 			 * Ask CTF for the offset of the member so we can store 			 * to the appropriate offset.  This call has already 			 * been done once by the parser, so it should succeed. 			 */
if|if
condition|(
name|ctf_member_info
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|,
name|dxp
operator|->
name|dx_dst_base
argument_list|,
name|mnp
operator|->
name|dn_membname
argument_list|,
operator|&
name|ctm
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|dxp
operator|->
name|dx_dst_ctfp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If the destination member is at offset 0, store the 			 * result directly to r1 (the scratch buffer address). 			 * Otherwise allocate another temporary for the offset 			 * and add r1 to it before storing the result. 			 */
if|if
condition|(
name|ctm
operator|.
name|ctm_offset
operator|!=
literal|0
condition|)
block|{
name|r2
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
comment|/* 				 * Add the member offset rounded down to the 				 * nearest byte.  If the offset was not aligned 				 * on a byte boundary, this member is a bit- 				 * field and dt_cg_store() will handle masking. 				 */
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|r2
argument_list|,
name|ctm
operator|.
name|ctm_offset
operator|/
name|NBBY
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_ADD
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_node_type_propagate
argument_list|(
name|mnp
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
name|dn
operator|.
name|dn_right
operator|->
name|dn_string
operator|=
name|mnp
operator|->
name|dn_membname
expr_stmt|;
name|dn
operator|.
name|dn_reg
operator|=
name|r2
expr_stmt|;
name|dt_cg_store
argument_list|(
name|mnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|r2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_node_type_propagate
argument_list|(
name|mnp
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
name|dn
operator|.
name|dn_right
operator|->
name|dn_string
operator|=
name|mnp
operator|->
name|dn_membname
expr_stmt|;
name|dn
operator|.
name|dn_reg
operator|=
name|r1
expr_stmt|;
name|dt_cg_store
argument_list|(
name|mnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
block|}
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|mnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
block|}
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator|&=
operator|~
name|DT_IDFLG_CGREG
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
operator|!=
operator|-
literal|1
condition|)
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_reg
operator|==
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|r1
expr_stmt|;
block|}
comment|/* 	 * If we are storing to a variable, generate an stv instruction from 	 * the variable specified by the identifier.  If we are storing to a 	 * memory address, generate code again for the left-hand side using 	 * DT_NF_REF to get the address, and then generate a store to it. 	 * In both paths, we assume dnp->dn_reg already has the new value. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
condition|)
block|{
name|idp
operator|=
name|dt_ident_resolve
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|)
name|dt_cg_arglist
argument_list|(
name|idp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_args
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|idp
operator|->
name|di_flags
operator||=
name|DT_IDFLG_DIFW
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_STV
argument_list|(
name|dt_cg_stvar
argument_list|(
name|idp
argument_list|)
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint_t
name|rbit
init|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&
name|DT_NF_WRITABLE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&
name|DT_NF_LVALUE
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator||=
name|DT_NF_REF
expr_stmt|;
comment|/* force pass-by-ref */
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_store
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dnp
operator|->
name|dn_left
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&=
operator|~
name|DT_NF_REF
expr_stmt|;
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator||=
name|rbit
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_assoc_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|dif_instr_t
name|instr
decl_stmt|;
name|uint_t
name|op
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_args
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dt_cg_arglist
argument_list|(
name|dnp
operator|->
name|dn_ident
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_TLS
condition|)
name|op
operator|=
name|DIF_OP_LDTAA
expr_stmt|;
else|else
name|op
operator|=
name|DIF_OP_LDGAA
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_DIFR
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_LDV
argument_list|(
name|op
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the associative array is a pass-by-reference type, then we are 	 * loading its value as a pointer to either load or store through it. 	 * The array element in question may not have been faulted in yet, in 	 * which case DIF_OP_LD*AA will return zero.  We append an epilogue 	 * of instructions similar to the following: 	 * 	 *	  ld?aa	 id, %r1	! base ld?aa instruction above 	 *	  tst	 %r1		! start of epilogue 	 *   +--- bne	 label 	 *   |    setx	 size, %r1 	 *   |    allocs %r1, %r1 	 *   |    st?aa	 id, %r1 	 *   |    ld?aa	 id, %r1 	 *   v 	 * label:< rest of code> 	 * 	 * The idea is that we allocs a zero-filled chunk of scratch space and 	 * do a DIF_OP_ST*AA to fault in and initialize the array element, and 	 * then reload it to get the faulted-in address of the new variable 	 * storage.  This isn't cheap, but pass-by-ref associative array values 	 * are (thus far) uncommon and the allocs cost only occurs once.  If 	 * this path becomes important to DTrace users, we can improve things 	 * by adding a new DIF opcode to fault in associative array elements. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
condition|)
block|{
name|uint_t
name|stvop
init|=
name|op
operator|==
name|DIF_OP_LDTAA
condition|?
name|DIF_OP_STTAA
else|:
name|DIF_OP_STGAA
decl_stmt|;
name|uint_t
name|label
init|=
name|dt_irlist_label
argument_list|(
name|dlp
argument_list|)
decl_stmt|;
name|instr
operator|=
name|DIF_INSTR_TST
argument_list|(
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_BRANCH
argument_list|(
name|DIF_OP_BNE
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|dt_node_type_size
argument_list|(
name|dnp
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_ALLOCS
argument_list|(
name|dnp
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_DIFW
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_STV
argument_list|(
name|stvop
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_LDV
argument_list|(
name|op
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|label
argument_list|,
name|DIF_INSTR_NOP
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_array_op
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|dt_probe_t
modifier|*
name|prp
init|=
name|yypcb
operator|->
name|pcb_probe
decl_stmt|;
name|uintmax_t
name|saved
init|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_value
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
init|=
name|dnp
operator|->
name|dn_ident
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|uint_t
name|op
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|n
decl_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_args
operator|->
name|dn_kind
operator|==
name|DT_NODE_INT
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_args
operator|->
name|dn_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a reference in the args[] array, temporarily modify the 	 * array index according to the static argument mapping (if any), 	 * unless the argument reference is provided by a dynamic translator. 	 * If we're using a dynamic translator for args[], then just set dn_reg 	 * to an invalid reg and return: DIF_OP_XLARG will fetch the arg later. 	 */
if|if
condition|(
name|idp
operator|->
name|di_id
operator|==
name|DIF_VAR_ARGS
condition|)
block|{
if|if
condition|(
operator|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_XLPTR
operator|||
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_XLSOU
operator|)
operator|&&
name|dt_xlator_dynamic
argument_list|(
name|idp
operator|->
name|di_data
argument_list|)
condition|)
block|{
name|dnp
operator|->
name|dn_reg
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|dnp
operator|->
name|dn_args
operator|->
name|dn_value
operator|=
name|prp
operator|->
name|pr_mapping
index|[
name|saved
index|]
expr_stmt|;
block|}
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_args
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_args
operator|->
name|dn_value
operator|=
name|saved
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_args
operator|->
name|dn_reg
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_TLS
condition|)
name|op
operator|=
name|DIF_OP_LDTA
expr_stmt|;
else|else
name|op
operator|=
name|DIF_OP_LDGA
expr_stmt|;
name|idp
operator|->
name|di_flags
operator||=
name|DT_IDFLG_DIFR
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_LDA
argument_list|(
name|op
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_args
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a reference to the args[] array, we need to take the 	 * additional step of explicitly eliminating any bits larger than the 	 * type size: the DIF interpreter in the kernel will always give us 	 * the raw (64-bit) argument value, and any bits larger than the type 	 * size may be junk.  As a practical matter, this arises only on 64-bit 	 * architectures and only when the argument index is larger than the 	 * number of arguments passed directly to DTrace: if a 8-, 16- or 	 * 32-bit argument must be retrieved from the stack, it is possible 	 * (and it some cases, likely) that the upper bits will be garbage. 	 */
if|if
condition|(
name|idp
operator|->
name|di_id
operator|!=
name|DIF_VAR_ARGS
operator|||
operator|!
name|dt_node_is_scalar
argument_list|(
name|dnp
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|size
operator|=
name|dt_node_type_size
argument_list|(
name|dnp
argument_list|)
operator|)
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return;
name|reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|NBBY
operator|-
name|size
operator|*
name|NBBY
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|reg
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SLL
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SRA
else|:
name|DIF_OP_SRL
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate code for an inlined variable reference.  Inlines can be used to  * define either scalar or associative array substitutions.  For scalars, we  * simply generate code for the parse tree saved in the identifier's din_root,  * and then cast the resulting expression to the inline's declaration type.  * For arrays, we take the input parameter subtrees from dnp->dn_args and  * temporarily store them in the din_root of each din_argv[i] identifier,  * which are themselves inlines and were set up for us by the parser.  The  * result is that any reference to the inlined parameter inside the top-level  * din_root will turn into a recursive call to dt_cg_inline() for a scalar  * inline whose din_root will refer to the subtree pointed to by the argument.  */
end_comment

begin_function
specifier|static
name|void
name|dt_cg_inline
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
init|=
name|dnp
operator|->
name|dn_ident
decl_stmt|;
name|dt_idnode_t
modifier|*
name|inp
init|=
name|idp
operator|->
name|di_iarg
decl_stmt|;
name|dt_idnode_t
modifier|*
name|pinp
decl_stmt|;
name|dt_node_t
modifier|*
name|pnp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|idp
operator|->
name|di_flags
operator|&
name|DT_IDFLG_INLINE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|idp
operator|->
name|di_ops
operator|==
operator|&
name|dt_idops_inline
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pnp
operator|=
name|dnp
operator|->
name|dn_args
init|;
name|pnp
operator|!=
name|NULL
condition|;
name|pnp
operator|=
name|pnp
operator|->
name|dn_list
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inp
operator|->
name|din_argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|pinp
operator|=
name|inp
operator|->
name|din_argv
index|[
name|i
index|]
operator|->
name|di_iarg
expr_stmt|;
name|pinp
operator|->
name|din_root
operator|=
name|pnp
expr_stmt|;
block|}
block|}
block|}
name|dt_cg_node
argument_list|(
name|inp
operator|->
name|din_root
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|inp
operator|->
name|din_root
operator|->
name|dn_reg
expr_stmt|;
name|dt_cg_typecast
argument_list|(
name|inp
operator|->
name|din_root
argument_list|,
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inp
operator|->
name|din_argc
condition|;
name|i
operator|++
control|)
block|{
name|pinp
operator|=
name|inp
operator|->
name|din_argv
index|[
name|i
index|]
operator|->
name|di_iarg
expr_stmt|;
name|pinp
operator|->
name|din_root
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dt_xlmemb
block|{
name|dt_ident_t
modifier|*
name|dtxl_idp
decl_stmt|;
comment|/* translated ident */
name|dt_irlist_t
modifier|*
name|dtxl_dlp
decl_stmt|;
comment|/* instruction list */
name|dt_regset_t
modifier|*
name|dtxl_drp
decl_stmt|;
comment|/* register set */
name|int
name|dtxl_sreg
decl_stmt|;
comment|/* location of the translation input */
name|int
name|dtxl_dreg
decl_stmt|;
comment|/* location of our allocated buffer */
block|}
name|dt_xlmemb_t
typedef|;
end_typedef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_cg_xlate_member
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ulong_t
name|off
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_xlmemb_t
modifier|*
name|dx
init|=
name|arg
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
init|=
name|dx
operator|->
name|dtxl_idp
decl_stmt|;
name|dt_irlist_t
modifier|*
name|dlp
init|=
name|dx
operator|->
name|dtxl_dlp
decl_stmt|;
name|dt_regset_t
modifier|*
name|drp
init|=
name|dx
operator|->
name|dtxl_drp
decl_stmt|;
name|dt_node_t
modifier|*
name|mnp
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|treg
decl_stmt|;
name|uint32_t
name|instr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* Generate code for the translation. */
name|dxp
operator|=
name|idp
operator|->
name|di_data
expr_stmt|;
name|mnp
operator|=
name|dt_xlator_member
argument_list|(
name|dxp
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If there's no translator for the given member, skip it. */
if|if
condition|(
name|mnp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_CGREG
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
name|dx
operator|->
name|dtxl_sreg
expr_stmt|;
name|dt_cg_node
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator|&=
operator|~
name|DT_IDFLG_CGREG
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
literal|0
expr_stmt|;
name|treg
operator|=
name|mnp
operator|->
name|dn_membexpr
operator|->
name|dn_reg
expr_stmt|;
comment|/* Compute the offset into our buffer and store the result there. */
name|reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|reg
argument_list|,
name|off
operator|/
name|NBBY
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_ADD
argument_list|,
name|dx
operator|->
name|dtxl_dreg
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|ctf_type_size
argument_list|(
name|mnp
operator|->
name|dn_membexpr
operator|->
name|dn_ctfp
argument_list|,
name|mnp
operator|->
name|dn_membexpr
operator|->
name|dn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_node_is_scalar
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|)
condition|)
block|{
comment|/* 		 * Copying scalars is simple. 		 */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STB
argument_list|,
name|treg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STH
argument_list|,
name|treg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STW
argument_list|,
name|treg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|instr
operator|=
name|DIF_INSTR_STORE
argument_list|(
name|DIF_OP_STX
argument_list|,
name|treg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error -- unexpected "
literal|"size: %lu\n"
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dt_node_is_string
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|)
condition|)
block|{
name|int
name|szreg
decl_stmt|;
comment|/* 		 * Use the copys instruction for strings. 		 */
name|szreg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|szreg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_COPYS
argument_list|(
name|treg
argument_list|,
name|szreg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|szreg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|szreg
decl_stmt|;
comment|/* 		 * If it's anything else then we'll just bcopy it. 		 */
name|szreg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|szreg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|DIF_INSTR_FLUSHTS
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_PUSHTS
argument_list|(
name|DIF_OP_PUSHTV
argument_list|,
name|DIF_TYPE_CTF
argument_list|,
name|DIF_REG_R0
argument_list|,
name|treg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_PUSHTS
argument_list|(
name|DIF_OP_PUSHTV
argument_list|,
name|DIF_TYPE_CTF
argument_list|,
name|DIF_REG_R0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_PUSHTS
argument_list|(
name|DIF_OP_PUSHTV
argument_list|,
name|DIF_TYPE_CTF
argument_list|,
name|DIF_REG_R0
argument_list|,
name|szreg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_CALL
argument_list|(
name|DIF_SUBR_BCOPY
argument_list|,
name|szreg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|szreg
argument_list|)
expr_stmt|;
block|}
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|treg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we're expanding a translated type, we create an appropriately sized  * buffer with alloca() and then translate each member into it.  */
end_comment

begin_function
specifier|static
name|int
name|dt_cg_xlate_expand
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_ident_t
modifier|*
name|idp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|dt_xlmemb_t
name|dlm
decl_stmt|;
name|uint32_t
name|instr
decl_stmt|;
name|int
name|dreg
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|dreg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|size
operator|=
name|ctf_type_size
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_ctfp
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_type
argument_list|)
expr_stmt|;
comment|/* Call alloca() to create the buffer. */
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|dreg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|DIF_INSTR_FLUSHTS
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_PUSHTS
argument_list|(
name|DIF_OP_PUSHTV
argument_list|,
name|DIF_TYPE_CTF
argument_list|,
name|DIF_REG_R0
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_CALL
argument_list|(
name|DIF_SUBR_ALLOCA
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the translation for each member. */
name|dlm
operator|.
name|dtxl_idp
operator|=
name|idp
expr_stmt|;
name|dlm
operator|.
name|dtxl_dlp
operator|=
name|dlp
expr_stmt|;
name|dlm
operator|.
name|dtxl_drp
operator|=
name|drp
expr_stmt|;
name|dlm
operator|.
name|dtxl_sreg
operator|=
name|dnp
operator|->
name|dn_reg
expr_stmt|;
name|dlm
operator|.
name|dtxl_dreg
operator|=
name|dreg
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_member_iter
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_ctfp
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_type
argument_list|,
name|dt_cg_xlate_member
argument_list|,
operator|&
name|dlm
argument_list|)
expr_stmt|;
return|return
operator|(
name|dreg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_cg_node
parameter_list|(
name|dt_node_t
modifier|*
name|dnp
parameter_list|,
name|dt_irlist_t
modifier|*
name|dlp
parameter_list|,
name|dt_regset_t
modifier|*
name|drp
parameter_list|)
block|{
name|ctf_file_t
modifier|*
name|ctfp
init|=
name|dnp
operator|->
name|dn_ctfp
decl_stmt|;
name|ctf_file_t
modifier|*
name|octfp
decl_stmt|;
name|ctf_membinfo_t
name|m
decl_stmt|;
name|ctf_id_t
name|type
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|ssize_t
name|stroff
decl_stmt|;
name|uint_t
name|op
decl_stmt|;
switch|switch
condition|(
name|dnp
operator|->
name|dn_op
condition|)
block|{
case|case
name|DT_TOK_COMMA
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
break|break;
case|case
name|DT_TOK_ASGN
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_ADD_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_ADD
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_SUB_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_SUB
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_MUL_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_MUL
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_DIV_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SDIV
else|:
name|DIF_OP_UDIV
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_MOD_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SREM
else|:
name|DIF_OP_UREM
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_AND_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_AND
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_XOR_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_XOR
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_OR_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_OR
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LSH_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_SLL
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_RSH_EQ
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SRA
else|:
name|DIF_OP_SRL
argument_list|)
expr_stmt|;
name|dt_cg_asgn_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_QUESTION
case|:
name|dt_cg_ternary_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LOR
case|:
name|dt_cg_logical_or
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LXOR
case|:
name|dt_cg_logical_xor
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LAND
case|:
name|dt_cg_logical_and
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_BOR
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_OR
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_XOR
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_XOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_BAND
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_AND
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_EQU
case|:
name|dt_cg_compare_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_BE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_NEQ
case|:
name|dt_cg_compare_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_BNE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LT
case|:
name|dt_cg_compare_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dt_cg_compare_signed
argument_list|(
name|dnp
argument_list|)
condition|?
name|DIF_OP_BL
else|:
name|DIF_OP_BLU
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LE
case|:
name|dt_cg_compare_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dt_cg_compare_signed
argument_list|(
name|dnp
argument_list|)
condition|?
name|DIF_OP_BLE
else|:
name|DIF_OP_BLEU
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_GT
case|:
name|dt_cg_compare_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dt_cg_compare_signed
argument_list|(
name|dnp
argument_list|)
condition|?
name|DIF_OP_BG
else|:
name|DIF_OP_BGU
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_GE
case|:
name|dt_cg_compare_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|dt_cg_compare_signed
argument_list|(
name|dnp
argument_list|)
condition|?
name|DIF_OP_BGE
else|:
name|DIF_OP_BGEU
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LSH
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_SLL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_RSH
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SRA
else|:
name|DIF_OP_SRL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_ADD
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_ADD
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_SUB
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_SUB
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_MUL
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_MUL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_DIV
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SDIV
else|:
name|DIF_OP_UDIV
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_MOD
case|:
name|dt_cg_arithmetic_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_SIGNED
operator|)
condition|?
name|DIF_OP_SREM
else|:
name|DIF_OP_UREM
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_LNEG
case|:
name|dt_cg_logical_neg
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_BNEG
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_NOT
argument_list|(
name|dnp
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_PREINC
case|:
name|dt_cg_prearith_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_ADD
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_POSTINC
case|:
name|dt_cg_postarith_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_ADD
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_PREDEC
case|:
name|dt_cg_prearith_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_SUB
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_POSTDEC
case|:
name|dt_cg_postarith_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|DIF_OP_SUB
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_IPOS
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
break|break;
case|case
name|DT_TOK_INEG
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_SUB
argument_list|,
name|DIF_REG_R0
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_DEREF
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
if|if
condition|(
name|dt_node_is_dynamic
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|)
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|DT_IDENT_XLPTR
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|idp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|reg
operator|=
name|dt_cg_xlate_expand
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
operator|)
condition|)
block|{
name|uint_t
name|ubit
init|=
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
decl_stmt|;
comment|/* 			 * Save and restore DT_NF_USERLAND across dt_cg_load(): 			 * we need the sign bit from dnp and the user bit from 			 * dnp->dn_child in order to get the proper opcode. 			 */
name|dnp
operator|->
name|dn_flags
operator||=
operator|(
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
operator|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_LOAD
argument_list|(
name|dt_cg_load
argument_list|(
name|dnp
argument_list|,
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator|&=
operator|~
name|DT_NF_USERLAND
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|ubit
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_TOK_ADDROF
case|:
block|{
name|uint_t
name|rbit
init|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
decl_stmt|;
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator||=
name|DT_NF_REF
expr_stmt|;
comment|/* force pass-by-ref */
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator|&=
operator|~
name|DT_NF_REF
expr_stmt|;
name|dnp
operator|->
name|dn_child
operator|->
name|dn_flags
operator||=
name|rbit
expr_stmt|;
break|break;
block|}
case|case
name|DT_TOK_SIZEOF
case|:
block|{
name|size_t
name|size
init|=
name|dt_node_sizeof
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|)
decl_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DT_TOK_STRINGOF
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_child
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_child
operator|->
name|dn_reg
expr_stmt|;
break|break;
case|case
name|DT_TOK_XLATE
case|:
comment|/* 		 * An xlate operator appears in either an XLATOR, indicating a 		 * reference to a dynamic translator, or an OP2, indicating 		 * use of the xlate operator in the user's program.  For the 		 * dynamic case, generate an xlate opcode with a reference to 		 * the corresponding member, pre-computed for us in dn_members. 		 */
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_XLATOR
condition|)
block|{
name|dt_xlator_t
modifier|*
name|dxp
init|=
name|dnp
operator|->
name|dn_xlator
decl_stmt|;
name|assert
argument_list|(
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_CGREG
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dxp
operator|->
name|dx_arg
operator|==
operator|-
literal|1
condition|)
block|{
name|instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|DIF_OP_XLATE
expr_stmt|;
block|}
else|else
name|op
operator|=
name|DIF_OP_XLARG
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_XLATE
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dlp
operator|->
name|dl_last
operator|->
name|di_extern
operator|=
name|dnp
operator|->
name|dn_xmember
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_OP2
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
break|break;
case|case
name|DT_TOK_LPAR
case|:
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_right
operator|->
name|dn_reg
expr_stmt|;
name|dt_cg_typecast
argument_list|(
name|dnp
operator|->
name|dn_right
argument_list|,
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_PTR
case|:
case|case
name|DT_TOK_DOT
case|:
name|assert
argument_list|(
name|dnp
operator|->
name|dn_right
operator|->
name|dn_kind
operator|==
name|DT_NODE_IDENT
argument_list|)
expr_stmt|;
name|dt_cg_node
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
comment|/* 		 * If the left-hand side of PTR or DOT is a dynamic variable, 		 * we expect it to be the output of a D translator.   In this 		 * case, we look up the parse tree corresponding to the member 		 * that is being accessed and run the code generator over it. 		 * We then cast the result as if by the assignment operator. 		 */
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|DT_IDENT_XLSOU
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|dnp
operator|->
name|dn_left
argument_list|,
name|DT_IDENT_XLPTR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|dt_node_t
modifier|*
name|mnp
decl_stmt|;
name|dxp
operator|=
name|idp
operator|->
name|di_data
expr_stmt|;
name|mnp
operator|=
name|dt_xlator_member
argument_list|(
name|dxp
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_string
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|mnp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_CGREG
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
expr_stmt|;
name|dt_cg_node
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|mnp
operator|->
name|dn_membexpr
operator|->
name|dn_reg
expr_stmt|;
name|dt_cg_typecast
argument_list|(
name|mnp
operator|->
name|dn_membexpr
argument_list|,
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator|&=
operator|~
name|DT_IDFLG_CGREG
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
operator|!=
operator|-
literal|1
condition|)
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctfp
operator|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_ctfp
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_op
operator|==
name|DT_TOK_PTR
condition|)
block|{
name|type
operator|=
name|ctf_type_reference
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|ctf_type_resolve
argument_list|(
name|ctfp
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ctfp
operator|=
name|dt_cg_membinfo
argument_list|(
name|octfp
operator|=
name|ctfp
argument_list|,
name|type
argument_list|,
name|dnp
operator|->
name|dn_right
operator|->
name|dn_string
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yypcb
operator|->
name|pcb_hdl
operator|->
name|dt_ctferr
operator|=
name|ctf_errno
argument_list|(
name|octfp
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_CTF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|.
name|ctm_offset
operator|!=
literal|0
condition|)
block|{
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
comment|/* 			 * If the offset is not aligned on a byte boundary, it 			 * is a bit-field member and we will extract the value 			 * bits below after we generate the appropriate load. 			 */
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|reg
argument_list|,
name|m
operator|.
name|ctm_offset
operator|/
name|NBBY
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_FMT
argument_list|(
name|DIF_OP_ADD
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
name|reg
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|drp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
operator|)
condition|)
block|{
name|uint_t
name|ubit
init|=
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
decl_stmt|;
comment|/* 			 * Save and restore DT_NF_USERLAND across dt_cg_load(): 			 * we need the sign bit from dnp and the user bit from 			 * dnp->dn_left in order to get the proper opcode. 			 */
name|dnp
operator|->
name|dn_flags
operator||=
operator|(
name|dnp
operator|->
name|dn_left
operator|->
name|dn_flags
operator|&
name|DT_NF_USERLAND
operator|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_LOAD
argument_list|(
name|dt_cg_load
argument_list|(
name|dnp
argument_list|,
name|ctfp
argument_list|,
name|m
operator|.
name|ctm_type
argument_list|)
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator|&=
operator|~
name|DT_NF_USERLAND
expr_stmt|;
name|dnp
operator|->
name|dn_flags
operator||=
name|ubit
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_BITFIELD
condition|)
name|dt_cg_field_get
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|,
name|ctfp
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|->
name|dn_reg
operator|=
name|dnp
operator|->
name|dn_left
operator|->
name|dn_reg
expr_stmt|;
break|break;
case|case
name|DT_TOK_STRING
case|:
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_STRING
argument_list|)
expr_stmt|;
name|stroff
operator|=
name|dt_strtab_insert
argument_list|(
name|yypcb
operator|->
name|pcb_strtab
argument_list|,
name|dnp
operator|->
name|dn_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|stroff
operator|==
operator|-
literal|1L
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|stroff
operator|>
name|DIF_STROFF_MAX
condition|)
name|longjmp
argument_list|(
name|yypcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_STR2BIG
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_SETS
argument_list|(
operator|(
name|ulong_t
operator|)
name|stroff
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TOK_IDENT
case|:
comment|/* 		 * If the specified identifier is a variable on which we have 		 * set the code generator register flag, then this variable 		 * has already had code generated for it and saved in di_id. 		 * Allocate a new register and copy the existing value to it. 		 */
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|&&
operator|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_CGREG
operator|)
condition|)
block|{
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_MOV
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Identifiers can represent function calls, variable refs, or 		 * symbols.  First we check for inlined variables, and handle 		 * them by generating code for the inline parse tree. 		 */
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_VAR
operator|&&
operator|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_INLINE
operator|)
condition|)
block|{
name|dt_cg_inline
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|dnp
operator|->
name|dn_kind
condition|)
block|{
case|case
name|DT_NODE_FUNC
case|:
if|if
condition|(
operator|(
name|idp
operator|=
name|dnp
operator|->
name|dn_ident
operator|)
operator|->
name|di_kind
operator|!=
name|DT_IDENT_FUNC
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_CG_EXPR
argument_list|,
literal|"%s %s( ) may not be "
literal|"called from a D expression (D program "
literal|"context required)\n"
argument_list|,
name|dt_idkind_name
argument_list|(
name|idp
operator|->
name|di_kind
argument_list|)
argument_list|,
name|idp
operator|->
name|di_name
argument_list|)
expr_stmt|;
block|}
name|dt_cg_arglist
argument_list|(
name|dnp
operator|->
name|dn_ident
argument_list|,
name|dnp
operator|->
name|dn_args
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_CALL
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_VAR
case|:
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_kind
operator|==
name|DT_IDENT_XLSOU
operator|||
name|dnp
operator|->
name|dn_ident
operator|->
name|di_kind
operator|==
name|DT_IDENT_XLPTR
condition|)
block|{
comment|/* 				 * This can only happen if we have translated 				 * args[].  See dt_idcook_args() for details. 				 */
name|assert
argument_list|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|==
name|DIF_VAR_ARGS
argument_list|)
expr_stmt|;
name|dt_cg_array_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_kind
operator|==
name|DT_IDENT_ARRAY
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
operator|>
name|DIF_VAR_ARRAY_MAX
condition|)
name|dt_cg_assoc_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
else|else
name|dt_cg_array_op
argument_list|(
name|dnp
argument_list|,
name|dlp
argument_list|,
name|drp
argument_list|)
expr_stmt|;
break|break;
block|}
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_LOCAL
condition|)
name|op
operator|=
name|DIF_OP_LDLS
expr_stmt|;
elseif|else
if|if
condition|(
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator|&
name|DT_IDFLG_TLS
condition|)
name|op
operator|=
name|DIF_OP_LDTS
expr_stmt|;
else|else
name|op
operator|=
name|DIF_OP_LDGS
expr_stmt|;
name|dnp
operator|->
name|dn_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_DIFR
expr_stmt|;
name|instr
operator|=
name|DIF_INSTR_LDV
argument_list|(
name|op
argument_list|,
name|dnp
operator|->
name|dn_ident
operator|->
name|di_id
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NODE_SYM
case|:
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|yypcb
operator|->
name|pcb_hdl
decl_stmt|;
name|dtrace_syminfo_t
modifier|*
name|sip
init|=
name|dnp
operator|->
name|dn_ident
operator|->
name|di_data
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
if|if
condition|(
name|dtrace_lookup_by_name
argument_list|(
name|dtp
argument_list|,
name|sip
operator|->
name|dts_object
argument_list|,
name|sip
operator|->
name|dts_name
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"cg failed for symbol %s`%s:"
literal|" %s\n"
argument_list|,
name|sip
operator|->
name|dts_object
argument_list|,
name|sip
operator|->
name|dts_name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_xsetx
argument_list|(
name|dlp
argument_list|,
name|dnp
operator|->
name|dn_ident
argument_list|,
name|DT_LBL_NONE
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DT_NF_REF
operator|)
condition|)
block|{
name|instr
operator|=
name|DIF_INSTR_LOAD
argument_list|(
name|dt_cg_load
argument_list|(
name|dnp
argument_list|,
name|ctfp
argument_list|,
name|dnp
operator|->
name|dn_type
argument_list|)
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
name|dlp
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error -- node type %u is "
literal|"not valid for an identifier\n"
argument_list|,
name|dnp
operator|->
name|dn_kind
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_TOK_INT
case|:
name|dnp
operator|->
name|dn_reg
operator|=
name|dt_regset_alloc
argument_list|(
name|drp
argument_list|)
expr_stmt|;
name|dt_cg_setx
argument_list|(
name|dlp
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|,
name|dnp
operator|->
name|dn_value
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xyerror
argument_list|(
name|D_UNKNOWN
argument_list|,
literal|"internal error -- token type %u is not a "
literal|"valid D compilation token\n"
argument_list|,
name|dnp
operator|->
name|dn_op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_cg
parameter_list|(
name|dt_pcb_t
modifier|*
name|pcb
parameter_list|,
name|dt_node_t
modifier|*
name|dnp
parameter_list|)
block|{
name|dif_instr_t
name|instr
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
if|if
condition|(
name|pcb
operator|->
name|pcb_regs
operator|==
name|NULL
operator|&&
operator|(
name|pcb
operator|->
name|pcb_regs
operator|=
name|dt_regset_create
argument_list|(
name|pcb
operator|->
name|pcb_hdl
operator|->
name|dt_conf
operator|.
name|dtc_difintregs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dt_regset_reset
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_regset_alloc
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|)
expr_stmt|;
comment|/* allocate %r0 */
if|if
condition|(
name|pcb
operator|->
name|pcb_inttab
operator|!=
name|NULL
condition|)
name|dt_inttab_destroy
argument_list|(
name|pcb
operator|->
name|pcb_inttab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcb
operator|->
name|pcb_inttab
operator|=
name|dt_inttab_create
argument_list|(
name|yypcb
operator|->
name|pcb_hdl
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|pcb_strtab
operator|!=
name|NULL
condition|)
name|dt_strtab_destroy
argument_list|(
name|pcb
operator|->
name|pcb_strtab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcb
operator|->
name|pcb_strtab
operator|=
name|dt_strtab_create
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|longjmp
argument_list|(
name|pcb
operator|->
name|pcb_jmpbuf
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
name|dt_irlist_destroy
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_ir
argument_list|)
expr_stmt|;
name|dt_irlist_create
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_ir
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pcb
operator|->
name|pcb_dret
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_dret
operator|=
name|dnp
expr_stmt|;
if|if
condition|(
name|dt_node_resolve
argument_list|(
name|dnp
argument_list|,
name|DT_IDENT_XLPTR
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dnerror
argument_list|(
name|dnp
argument_list|,
name|D_CG_DYN
argument_list|,
literal|"expression cannot evaluate to result "
literal|"of a translated pointer\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're generating code for a translator body, assign the input 	 * parameter to the first available register (i.e. caller passes %r1). 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_MEMBER
condition|)
block|{
name|dxp
operator|=
name|dnp
operator|->
name|dn_membxlator
expr_stmt|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_membexpr
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator||=
name|DT_IDFLG_CGREG
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
name|dt_regset_alloc
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|)
expr_stmt|;
block|}
name|dt_cg_node
argument_list|(
name|dnp
argument_list|,
operator|&
name|pcb
operator|->
name|pcb_ir
argument_list|,
name|pcb
operator|->
name|pcb_regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|=
name|dt_node_resolve
argument_list|(
name|dnp
argument_list|,
name|DT_IDENT_XLSOU
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|reg
init|=
name|dt_cg_xlate_expand
argument_list|(
name|dnp
argument_list|,
name|idp
argument_list|,
operator|&
name|pcb
operator|->
name|pcb_ir
argument_list|,
name|pcb
operator|->
name|pcb_regs
argument_list|)
decl_stmt|;
name|dt_regset_free
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_reg
operator|=
name|reg
expr_stmt|;
block|}
name|instr
operator|=
name|DIF_INSTR_RET
argument_list|(
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_regset_free
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|,
name|dnp
operator|->
name|dn_reg
argument_list|)
expr_stmt|;
name|dt_irlist_append
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_ir
argument_list|,
name|dt_cg_node_alloc
argument_list|(
name|DT_LBL_NONE
argument_list|,
name|instr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_kind
operator|==
name|DT_NODE_MEMBER
condition|)
block|{
name|dt_regset_free
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|,
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
argument_list|)
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_id
operator|=
literal|0
expr_stmt|;
name|dxp
operator|->
name|dx_ident
operator|->
name|di_flags
operator|&=
operator|~
name|DT_IDFLG_CGREG
expr_stmt|;
block|}
name|dt_regset_free
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_regset_assert_free
argument_list|(
name|pcb
operator|->
name|pcb_regs
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

