begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|size_t
name|dtps_offset
decl_stmt|;
name|size_t
name|dtps_len
decl_stmt|;
block|}
name|dtrace_probespecs
index|[]
init|=
block|{
block|{
name|offsetof
argument_list|(
name|dtrace_probedesc_t
argument_list|,
name|dtpd_provider
argument_list|)
block|,
name|DTRACE_PROVNAMELEN
block|}
block|,
block|{
name|offsetof
argument_list|(
name|dtrace_probedesc_t
argument_list|,
name|dtpd_mod
argument_list|)
block|,
name|DTRACE_MODNAMELEN
block|}
block|,
block|{
name|offsetof
argument_list|(
name|dtrace_probedesc_t
argument_list|,
name|dtpd_func
argument_list|)
block|,
name|DTRACE_FUNCNAMELEN
block|}
block|,
block|{
name|offsetof
argument_list|(
name|dtrace_probedesc_t
argument_list|,
name|dtpd_name
argument_list|)
block|,
name|DTRACE_NAMELEN
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|dtrace_xstr2desc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_probespec_t
name|spec
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
name|size_t
name|off
decl_stmt|,
name|len
decl_stmt|,
name|vlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
comment|/* for id_t as %d (see below) */
if|if
condition|(
name|spec
operator|<
name|DTRACE_PROBESPEC_NONE
operator|||
name|spec
operator|>
name|DTRACE_PROBESPEC_NAME
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|pdp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probedesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|p
operator|>=
name|s
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|len
operator|++
control|)
name|p
operator|--
expr_stmt|;
comment|/* move backward until we find a delimiter */
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|vlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'$'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|v
operator|<
name|q
operator|+
name|len
condition|)
block|{
comment|/* 			 * Set vlen to the length of the variable name and then 			 * reset len to the length of the text prior to '$'. If 			 * the name begins with a digit, interpret it using the 			 * the argv[] array.  Otherwise we look in dt_macros. 			 * For the moment, all dt_macros variables are of type 			 * id_t (see dtrace_update() for more details on that). 			 */
name|vlen
operator|=
call|(
name|size_t
call|)
argument_list|(
name|q
operator|+
name|len
operator|-
name|v
argument_list|)
expr_stmt|;
name|len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|v
operator|-
name|q
argument_list|)
expr_stmt|;
comment|/* 			 * If the variable string begins with $$, skip past the 			 * leading dollar sign since $ and $$ are equivalent 			 * macro reference operators in a probe description. 			 */
if|if
condition|(
name|vlen
operator|>
literal|2
operator|&&
name|v
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|vlen
operator|--
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|long
name|i
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|v
operator|+
literal|1
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|argc
operator|||
name|errno
operator|!=
literal|0
operator|||
name|end
operator|!=
name|v
operator|+
name|vlen
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSPCV
argument_list|)
operator|)
return|;
name|v
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|vlen
operator|=
name|strlen
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|yypcb
operator|!=
name|NULL
operator|&&
name|yypcb
operator|->
name|pcb_sargv
operator|==
name|argv
condition|)
name|yypcb
operator|->
name|pcb_sflagv
index|[
name|i
index|]
operator||=
name|DT_IDFLG_REF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vlen
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
name|vstr
init|=
name|alloca
argument_list|(
name|vlen
argument_list|)
decl_stmt|;
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|vstr
argument_list|,
name|v
operator|+
literal|1
argument_list|,
name|vlen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vstr
index|[
name|vlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|idp
operator|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
name|vstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NULL
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSPCV
argument_list|)
operator|)
return|;
name|v
operator|=
name|buf
expr_stmt|;
name|vlen
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|32
argument_list|,
literal|"%d"
argument_list|,
name|idp
operator|->
name|di_id
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSPCV
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|spec
operator|==
name|DTRACE_PROBESPEC_NONE
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSPEC
argument_list|)
operator|)
return|;
if|if
condition|(
name|len
operator|+
name|vlen
operator|>=
name|dtrace_probespecs
index|[
name|spec
index|]
operator|.
name|dtps_len
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
name|off
operator|=
name|dtrace_probespecs
index|[
name|spec
operator|--
index|]
operator|.
name|dtps_offset
expr_stmt|;
name|bcopy
argument_list|(
name|q
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pdp
operator|+
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|v
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pdp
operator|+
name|off
operator|+
name|len
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|p
operator|>=
name|s
condition|)
do|;
name|pdp
operator|->
name|dtpd_id
operator|=
name|DTRACE_IDNONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_str2desc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_probespec_t
name|spec
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
return|return
operator|(
name|dtrace_xstr2desc
argument_list|(
name|dtp
argument_list|,
name|spec
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pdp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_id2desc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
name|bzero
argument_list|(
name|pdp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probedesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|pdp
operator|->
name|dtpd_id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_PROBES
argument_list|,
name|pdp
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|pdp
operator|->
name|dtpd_id
operator|!=
name|id
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADID
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dtrace_desc2str
parameter_list|(
specifier|const
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|pdp
operator|->
name|dtpd_id
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s:%s:%s:%s"
argument_list|,
name|pdp
operator|->
name|dtpd_provider
argument_list|,
name|pdp
operator|->
name|dtpd_mod
argument_list|,
name|pdp
operator|->
name|dtpd_func
argument_list|,
name|pdp
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%u"
argument_list|,
name|pdp
operator|->
name|dtpd_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dtrace_attr2str
parameter_list|(
name|dtrace_attribute_t
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|dtrace_stability_name
argument_list|(
name|attr
operator|.
name|dtat_name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
init|=
name|dtrace_stability_name
argument_list|(
name|attr
operator|.
name|dtat_data
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|class
init|=
name|dtrace_class_name
argument_list|(
name|attr
operator|.
name|dtat_class
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|data
operator|==
name|NULL
operator|||
name|class
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* one or more invalid attributes */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|name
argument_list|,
name|data
argument_list|,
name|class
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dt_getstrattr
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
modifier|*
name|qp
parameter_list|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|qp
operator|=
name|q
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_str2attr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|dtrace_attribute_t
modifier|*
name|attr
parameter_list|)
block|{
name|dtrace_stability_t
name|s
decl_stmt|;
name|dtrace_class_t
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
name|attr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* invalid function arguments */
operator|*
name|attr
operator|=
name|_dtrace_maxattr
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|dt_getstrattr
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|DTRACE_STABILITY_MAX
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|dtrace_stability_name
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|attr
operator|->
name|dtat_name
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>
name|DTRACE_STABILITY_MAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|dt_getstrattr
argument_list|(
name|q
argument_list|,
operator|&
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|DTRACE_STABILITY_MAX
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|dtrace_stability_name
argument_list|(
name|s
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|attr
operator|->
name|dtat_data
operator|=
name|s
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>
name|DTRACE_STABILITY_MAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|dt_getstrattr
argument_list|(
name|q
argument_list|,
operator|&
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<=
name|DTRACE_CLASS_MAX
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|dtrace_class_name
argument_list|(
name|c
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|attr
operator|->
name|dtat_class
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|>
name|DTRACE_CLASS_MAX
operator|||
operator|(
name|p
operator|=
name|dt_getstrattr
argument_list|(
name|q
argument_list|,
operator|&
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dtrace_stability_name
parameter_list|(
name|dtrace_stability_t
name|s
parameter_list|)
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|DTRACE_STABILITY_INTERNAL
case|:
return|return
operator|(
literal|"Internal"
operator|)
return|;
case|case
name|DTRACE_STABILITY_PRIVATE
case|:
return|return
operator|(
literal|"Private"
operator|)
return|;
case|case
name|DTRACE_STABILITY_OBSOLETE
case|:
return|return
operator|(
literal|"Obsolete"
operator|)
return|;
case|case
name|DTRACE_STABILITY_EXTERNAL
case|:
return|return
operator|(
literal|"External"
operator|)
return|;
case|case
name|DTRACE_STABILITY_UNSTABLE
case|:
return|return
operator|(
literal|"Unstable"
operator|)
return|;
case|case
name|DTRACE_STABILITY_EVOLVING
case|:
return|return
operator|(
literal|"Evolving"
operator|)
return|;
case|case
name|DTRACE_STABILITY_STABLE
case|:
return|return
operator|(
literal|"Stable"
operator|)
return|;
case|case
name|DTRACE_STABILITY_STANDARD
case|:
return|return
operator|(
literal|"Standard"
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dtrace_class_name
parameter_list|(
name|dtrace_class_t
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|DTRACE_CLASS_UNKNOWN
case|:
return|return
operator|(
literal|"Unknown"
operator|)
return|;
case|case
name|DTRACE_CLASS_CPU
case|:
return|return
operator|(
literal|"CPU"
operator|)
return|;
case|case
name|DTRACE_CLASS_PLATFORM
case|:
return|return
operator|(
literal|"Platform"
operator|)
return|;
case|case
name|DTRACE_CLASS_GROUP
case|:
return|return
operator|(
literal|"Group"
operator|)
return|;
case|case
name|DTRACE_CLASS_ISA
case|:
return|return
operator|(
literal|"ISA"
operator|)
return|;
case|case
name|DTRACE_CLASS_COMMON
case|:
return|return
operator|(
literal|"Common"
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|dtrace_attribute_t
name|dt_attr_min
parameter_list|(
name|dtrace_attribute_t
name|a1
parameter_list|,
name|dtrace_attribute_t
name|a2
parameter_list|)
block|{
name|dtrace_attribute_t
name|am
decl_stmt|;
name|am
operator|.
name|dtat_name
operator|=
name|MIN
argument_list|(
name|a1
operator|.
name|dtat_name
argument_list|,
name|a2
operator|.
name|dtat_name
argument_list|)
expr_stmt|;
name|am
operator|.
name|dtat_data
operator|=
name|MIN
argument_list|(
name|a1
operator|.
name|dtat_data
argument_list|,
name|a2
operator|.
name|dtat_data
argument_list|)
expr_stmt|;
name|am
operator|.
name|dtat_class
operator|=
name|MIN
argument_list|(
name|a1
operator|.
name|dtat_class
argument_list|,
name|a2
operator|.
name|dtat_class
argument_list|)
expr_stmt|;
return|return
operator|(
name|am
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_attribute_t
name|dt_attr_max
parameter_list|(
name|dtrace_attribute_t
name|a1
parameter_list|,
name|dtrace_attribute_t
name|a2
parameter_list|)
block|{
name|dtrace_attribute_t
name|am
decl_stmt|;
name|am
operator|.
name|dtat_name
operator|=
name|MAX
argument_list|(
name|a1
operator|.
name|dtat_name
argument_list|,
name|a2
operator|.
name|dtat_name
argument_list|)
expr_stmt|;
name|am
operator|.
name|dtat_data
operator|=
name|MAX
argument_list|(
name|a1
operator|.
name|dtat_data
argument_list|,
name|a2
operator|.
name|dtat_data
argument_list|)
expr_stmt|;
name|am
operator|.
name|dtat_class
operator|=
name|MAX
argument_list|(
name|a1
operator|.
name|dtat_class
argument_list|,
name|a2
operator|.
name|dtat_class
argument_list|)
expr_stmt|;
return|return
operator|(
name|am
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two attributes and return an integer value in the following ranges:  *  *<0 if any of a1's attributes are less than a2's attributes  * =0 if all of a1's attributes are equal to a2's attributes  *>0 if all of a1's attributes are greater than or equal to a2's attributes  *  * To implement this function efficiently, we subtract a2's attributes from  * a1's to obtain a negative result if an a1 attribute is less than its a2  * counterpart.  We then OR the intermediate results together, relying on the  * twos-complement property that if any result is negative, the bitwise union  * will also be negative since the highest bit will be set in the result.  */
end_comment

begin_function
name|int
name|dt_attr_cmp
parameter_list|(
name|dtrace_attribute_t
name|a1
parameter_list|,
name|dtrace_attribute_t
name|a2
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|int
operator|)
name|a1
operator|.
name|dtat_name
operator|-
name|a2
operator|.
name|dtat_name
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|a1
operator|.
name|dtat_data
operator|-
name|a2
operator|.
name|dtat_data
operator|)
operator||
operator|(
operator|(
name|int
operator|)
name|a1
operator|.
name|dtat_class
operator|-
name|a2
operator|.
name|dtat_class
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dt_attr_str
parameter_list|(
name|dtrace_attribute_t
name|a
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|stability
index|[]
init|=
literal|"ipoxuesS"
decl_stmt|;
specifier|static
specifier|const
name|char
name|class
index|[]
init|=
literal|"uCpgIc"
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|dtat_name
operator|<
sizeof|sizeof
argument_list|(
name|stability
argument_list|)
operator|&&
name|a
operator|.
name|dtat_data
operator|<
sizeof|sizeof
argument_list|(
name|stability
argument_list|)
operator|&&
name|a
operator|.
name|dtat_class
operator|<
sizeof|sizeof
argument_list|(
name|class
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"[%c/%c/%c]"
argument_list|,
name|stability
index|[
name|a
operator|.
name|dtat_name
index|]
argument_list|,
name|stability
index|[
name|a
operator|.
name|dtat_data
index|]
argument_list|,
name|class
index|[
name|a
operator|.
name|dtat_class
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"[%u/%u/%u]"
argument_list|,
name|a
operator|.
name|dtat_name
argument_list|,
name|a
operator|.
name|dtat_data
argument_list|,
name|a
operator|.
name|dtat_class
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dt_version_num2str
parameter_list|(
name|dt_version_t
name|v
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint_t
name|M
init|=
name|DT_VERSION_MAJOR
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|uint_t
name|m
init|=
name|DT_VERSION_MINOR
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|uint_t
name|u
init|=
name|DT_VERSION_MICRO
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%u.%u"
argument_list|,
name|M
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%u.%u.%u"
argument_list|,
name|M
argument_list|,
name|m
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_version_str2num
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|dt_version_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|n
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|n
index|[
name|i
index|]
operator|=
name|n
index|[
name|i
index|]
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'.'
operator|||
name|i
operator|++
operator|>=
sizeof|sizeof
argument_list|(
name|n
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|n
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
index|[
literal|0
index|]
operator|>
name|DT_VERSION_MAJMAX
operator|||
name|n
index|[
literal|1
index|]
operator|>
name|DT_VERSION_MINMAX
operator|||
name|n
index|[
literal|2
index|]
operator|>
name|DT_VERSION_MICMAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
operator|*
name|vp
operator|=
name|DT_VERSION_NUMBER
argument_list|(
name|n
index|[
literal|0
index|]
argument_list|,
name|n
index|[
literal|1
index|]
argument_list|,
name|n
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_version_defined
parameter_list|(
name|dt_version_t
name|v
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|_dtrace_versions
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_dtrace_versions
index|[
name|i
index|]
operator|==
name|v
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dt_cpp_add_arg
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_cpp_argc
operator|==
name|dtp
operator|->
name|dt_cpp_args
condition|)
block|{
name|int
name|olds
init|=
name|dtp
operator|->
name|dt_cpp_args
decl_stmt|;
name|int
name|news
init|=
name|olds
operator|*
literal|2
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|realloc
argument_list|(
name|dtp
operator|->
name|dt_cpp_argv
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|news
argument_list|)
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|argv
index|[
name|olds
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|olds
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_argv
operator|=
name|argv
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_args
operator|=
name|news
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_cpp_argc
operator|<
name|dtp
operator|->
name|dt_cpp_args
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_argv
index|[
name|dtp
operator|->
name|dt_cpp_argc
operator|++
index|]
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dt_cpp_pop_arg
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_cpp_argc
operator|<=
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_cpp_argv[0] cannot be popped */
name|arg
operator|=
name|dtp
operator|->
name|dt_cpp_argv
index|[
operator|--
name|dtp
operator|->
name|dt_cpp_argc
index|]
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_argv
index|[
name|dtp
operator|->
name|dt_cpp_argc
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
name|void
name|dt_dprintf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|_dtrace_debug
condition|)
block|{
name|va_list
name|alist
decl_stmt|;
name|va_start
argument_list|(
name|alist
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"libdtrace DEBUG: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|alist
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|alist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dt_ioctl
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|val
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|dtrace_vector_t
modifier|*
name|v
init|=
name|dtp
operator|->
name|dt_vector
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
return|return
operator|(
name|v
operator|->
name|dtv_ioctl
argument_list|(
name|dtp
operator|->
name|dt_varg
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_fd
operator|>=
literal|0
condition|)
return|return
operator|(
name|ioctl
argument_list|(
name|dtp
operator|->
name|dt_fd
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
operator|)
return|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_status
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|processorid_t
name|cpu
parameter_list|)
block|{
specifier|const
name|dtrace_vector_t
modifier|*
name|v
init|=
name|dtp
operator|->
name|dt_vector
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
return|return
operator|(
name|p_online
argument_list|(
name|cpu
argument_list|,
name|P_STATUS
argument_list|)
operator|)
return|;
return|return
operator|(
name|v
operator|->
name|dtv_status
argument_list|(
name|dtp
operator|->
name|dt_varg
argument_list|,
name|cpu
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|long
name|dt_sysconf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|name
parameter_list|)
block|{
specifier|const
name|dtrace_vector_t
modifier|*
name|v
init|=
name|dtp
operator|->
name|dt_vector
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
return|return
operator|(
name|sysconf
argument_list|(
name|name
argument_list|)
operator|)
return|;
return|return
operator|(
name|v
operator|->
name|dtv_sysconf
argument_list|(
name|dtp
operator|->
name|dt_varg
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper around write(2) to handle partial writes.  For maximum safety of  * output files and proper error reporting, we continuing writing in the  * face of partial writes until write(2) fails or 'buf' is completely written.  * We also record any errno in the specified dtrace_hdl_t as well as 'errno'.  */
end_comment

begin_function
name|ssize_t
name|dt_write
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|ssize_t
name|resid
init|=
name|n
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|resid
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
name|resid
operator|-=
name|len
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|len
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|==
name|n
operator|&&
name|n
operator|!=
literal|0
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
return|return
operator|(
name|n
operator|-
name|resid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function handles all output from libdtrace, as well as the  * dtrace_sprintf() case.  If we're here due to dtrace_sprintf(), then  * dt_sprintf_buflen will be non-zero; in this case, we sprintf into the  * specified buffer and return.  Otherwise, if output is buffered (denoted by  * a NULL fp), we sprintf the desired output into the buffered buffer  * (expanding the buffer if required).  If we don't satisfy either of these  * conditions (that is, if we are to actually generate output), then we call  * fprintf with the specified fp.  In this case, we need to deal with one of  * the more annoying peculiarities of libc's printf routines:  any failed  * write persistently sets an error flag inside the FILE causing every  * subsequent write to fail, but only the caller that initiated the error gets  * the errno.  Since libdtrace clients often intercept SIGINT, this case is  * particularly frustrating since we don't want the EINTR on one attempt to  * write to the output file to preclude later attempts to write.  This  * function therefore does a clearerr() if any error occurred, and saves the  * errno for the caller inside the specified dtrace_hdl_t.  */
end_comment

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
name|int
name|dt_printf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|n
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_sprintf_buflen
operator|!=
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|&
name|dtp
operator|->
name|dt_sprintf_buf
index|[
name|len
operator|=
name|strlen
argument_list|(
name|dtp
operator|->
name|dt_sprintf_buf
argument_list|)
index|]
expr_stmt|;
name|len
operator|=
name|dtp
operator|->
name|dt_sprintf_buflen
operator|-
name|len
expr_stmt|;
name|assert
argument_list|(
name|len
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|n
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|int
name|needed
decl_stmt|,
name|rval
decl_stmt|;
name|size_t
name|avail
decl_stmt|;
comment|/* 		 * It's not legal to use buffered ouput if there is not a 		 * handler for buffered output. 		 */
if|if
condition|(
name|dtp
operator|->
name|dt_bufhdlr
operator|==
name|NULL
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOBUFFERED
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_buffered_buf
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|dtp
operator|->
name|dt_buffered_size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_size
operator|=
literal|1
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_buf
operator|=
name|malloc
argument_list|(
name|dtp
operator|->
name|dt_buffered_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_buffered_buf
operator|==
name|NULL
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|dtp
operator|->
name|dt_buffered_offs
operator|=
literal|0
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|needed
operator|=
name|vsnprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|needed
operator|==
literal|0
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|newbuf
decl_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_buffered_offs
operator|<
name|dtp
operator|->
name|dt_buffered_size
argument_list|)
expr_stmt|;
name|avail
operator|=
name|dtp
operator|->
name|dt_buffered_size
operator|-
name|dtp
operator|->
name|dt_buffered_offs
expr_stmt|;
if|if
condition|(
name|needed
operator|+
literal|1
operator|<
name|avail
condition|)
break|break;
if|if
condition|(
operator|(
name|newbuf
operator|=
name|realloc
argument_list|(
name|dtp
operator|->
name|dt_buffered_buf
argument_list|,
name|dtp
operator|->
name|dt_buffered_size
operator|<<
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
name|dtp
operator|->
name|dt_buffered_buf
operator|=
name|newbuf
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_size
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vsnprintf
argument_list|(
operator|&
name|dtp
operator|->
name|dt_buffered_buf
index|[
name|dtp
operator|->
name|dt_buffered_offs
index|]
argument_list|,
name|avail
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rval
operator|=
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
name|dtp
operator|->
name|dt_buffered_offs
operator|+=
name|needed
expr_stmt|;
name|assert
argument_list|(
name|dtp
operator|->
name|dt_buffered_buf
index|[
name|dtp
operator|->
name|dt_buffered_offs
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|=
name|vfprintf
argument_list|(
name|fp
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_buffered_flush
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_probedata_t
modifier|*
name|pdata
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
parameter_list|,
specifier|const
name|dtrace_aggdata_t
modifier|*
name|agg
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|dtrace_bufdata_t
name|data
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_buffered_offs
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|data
operator|.
name|dtbda_handle
operator|=
name|dtp
expr_stmt|;
name|data
operator|.
name|dtbda_buffered
operator|=
name|dtp
operator|->
name|dt_buffered_buf
expr_stmt|;
name|data
operator|.
name|dtbda_probe
operator|=
name|pdata
expr_stmt|;
name|data
operator|.
name|dtbda_recdesc
operator|=
name|rec
expr_stmt|;
name|data
operator|.
name|dtbda_aggdata
operator|=
name|agg
expr_stmt|;
name|data
operator|.
name|dtbda_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|dtp
operator|->
name|dt_bufhdlr
call|)
argument_list|(
operator|&
name|data
argument_list|,
name|dtp
operator|->
name|dt_bufarg
argument_list|)
operator|==
name|DTRACE_HANDLE_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DIRABORT
argument_list|)
operator|)
return|;
name|dtp
operator|->
name|dt_buffered_offs
operator|=
literal|0
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_buffered_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|free
argument_list|(
name|dtp
operator|->
name|dt_buffered_buf
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_buf
operator|=
name|NULL
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_offs
operator|=
literal|0
expr_stmt|;
name|dtp
operator|->
name|dt_buffered_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|dt_zalloc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dt_alloc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_NOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_free
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|assert
argument_list|(
name|dtp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* ensure sane use of this interface */
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_difo_free
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|)
block|{
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
comment|/* simplify caller code */
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|dtdo_buf
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|dtdo_inttab
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|dtdo_strtab
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|dtdo_vartab
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|dtdo_kreltab
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|dtdo_ureltab
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
operator|->
name|dtdo_xlmtab
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dt_gmatch() is similar to gmatch(3GEN) and dtrace(7D) globbing, but also  * implements the behavior that an empty pattern matches any string.  */
end_comment

begin_function
name|int
name|dt_gmatch
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|||
name|gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dt_basename
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|last
init|=
name|strrchr
argument_list|(
name|str
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
return|return
operator|(
name|str
operator|)
return|;
return|return
operator|(
name|last
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dt_popc() is a fast implementation of population count.  The algorithm is  * from "Hacker's Delight" by Henry Warren, Jr with a 64-bit equivalent added.  */
end_comment

begin_function
name|ulong_t
name|dt_popc
parameter_list|(
name|ulong_t
name|x
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_ILP32
name|x
operator|=
name|x
operator|-
operator|(
operator|(
name|x
operator|>>
literal|1
operator|)
operator|&
literal|0x55555555UL
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0x33333333UL
operator|)
operator|+
operator|(
operator|(
name|x
operator|>>
literal|2
operator|)
operator|&
literal|0x33333333UL
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|4
operator|)
operator|)
operator|&
literal|0x0F0F0F0FUL
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>
literal|16
operator|)
expr_stmt|;
return|return
operator|(
name|x
operator|&
literal|0x3F
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LP64
name|x
operator|=
name|x
operator|-
operator|(
operator|(
name|x
operator|>>
literal|1
operator|)
operator|&
literal|0x5555555555555555ULL
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0x3333333333333333ULL
operator|)
operator|+
operator|(
operator|(
name|x
operator|>>
literal|2
operator|)
operator|&
literal|0x3333333333333333ULL
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
operator|(
name|x
operator|>>
literal|4
operator|)
operator|)
operator|&
literal|0x0F0F0F0F0F0F0F0FULL
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>
literal|8
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>
literal|16
operator|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
operator|(
name|x
operator|>>
literal|32
operator|)
expr_stmt|;
return|return
operator|(
name|x
operator|&
literal|0x7F
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * dt_popcb() is a bitmap-based version of population count that returns the  * number of one bits in the specified bitmap 'bp' at bit positions below 'n'.  */
end_comment

begin_function
name|ulong_t
name|dt_popcb
parameter_list|(
specifier|const
name|ulong_t
modifier|*
name|bp
parameter_list|,
name|ulong_t
name|n
parameter_list|)
block|{
name|ulong_t
name|maxb
init|=
name|n
operator|&
name|BT_ULMASK
decl_stmt|;
name|ulong_t
name|maxw
init|=
name|n
operator|>>
name|BT_ULSHIFT
decl_stmt|;
name|ulong_t
name|w
decl_stmt|,
name|popc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|w
operator|=
literal|0
init|;
name|w
operator|<
name|maxw
condition|;
name|w
operator|++
control|)
name|popc
operator|+=
name|dt_popc
argument_list|(
name|bp
index|[
name|w
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|popc
operator|+
name|dt_popc
argument_list|(
name|bp
index|[
name|maxw
index|]
operator|&
operator|(
operator|(
literal|1UL
operator|<<
name|maxb
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct_decl
struct_decl|struct
name|_rwlock
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|_lwp_mutex
struct_decl|;
end_struct_decl

begin_function
name|int
name|dt_rw_read_held
parameter_list|(
name|pthread_rwlock_t
modifier|*
name|lock
parameter_list|)
block|{
specifier|extern
name|int
name|_rw_read_held
argument_list|(
expr|struct
name|_rwlock
operator|*
argument_list|)
decl_stmt|;
return|return
operator|(
name|_rw_read_held
argument_list|(
operator|(
expr|struct
name|_rwlock
operator|*
operator|)
name|lock
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_rw_write_held
parameter_list|(
name|pthread_rwlock_t
modifier|*
name|lock
parameter_list|)
block|{
specifier|extern
name|int
name|_rw_write_held
argument_list|(
expr|struct
name|_rwlock
operator|*
argument_list|)
decl_stmt|;
return|return
operator|(
name|_rw_write_held
argument_list|(
operator|(
expr|struct
name|_rwlock
operator|*
operator|)
name|lock
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_mutex_held
parameter_list|(
name|pthread_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
specifier|extern
name|int
name|_mutex_held
argument_list|(
expr|struct
name|_lwp_mutex
operator|*
argument_list|)
decl_stmt|;
return|return
operator|(
name|_mutex_held
argument_list|(
operator|(
expr|struct
name|_lwp_mutex
operator|*
operator|)
name|lock
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_string2str
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Like snprintf(3C), we don't check the value of str if the 		 * number of bytes is 0. 		 */
return|return
operator|(
name|len
operator|)
return|;
block|}
if|if
condition|(
name|nbytes
operator|<=
name|len
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|nbytes
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Like snprintf(3C) (and unlike strncpy(3C)), we guarantee 		 * that the string is null-terminated. 		 */
name|str
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_addr2str
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|dtrace_syminfo_t
name|dts
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|size_t
name|n
init|=
literal|20
decl_stmt|;
comment|/* for 0x%llx\0 */
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
name|addr
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|n
operator|+=
name|strlen
argument_list|(
name|dts
operator|.
name|dts_object
argument_list|)
operator|+
name|strlen
argument_list|(
name|dts
operator|.
name|dts_name
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* +` */
name|s
operator|=
name|alloca
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|addr
operator|!=
name|sym
operator|.
name|st_value
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"%s`%s+0x%llx"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|addr
operator|-
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"%s`%s"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We'll repeat the lookup, but this time we'll specify a NULL 		 * GElf_Sym -- indicating that we're only interested in the 		 * containing module. 		 */
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"%s`0x%llx"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dt_string2str
argument_list|(
name|s
argument_list|,
name|str
argument_list|,
name|nbytes
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_uaddr2str
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|char
name|name
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|objname
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|c
index|[
name|PATH_MAX
operator|*
literal|2
index|]
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|NULL
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|char
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_string2str
argument_list|(
name|c
argument_list|,
name|str
argument_list|,
name|nbytes
argument_list|)
operator|)
return|;
block|}
name|dt_proc_lock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|Plookup_by_addr
argument_list|(
name|P
argument_list|,
name|addr
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Pobjname
argument_list|(
name|P
argument_list|,
name|addr
argument_list|,
name|objname
argument_list|,
sizeof|sizeof
argument_list|(
name|objname
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|dt_basename
argument_list|(
name|objname
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|sym
operator|.
name|st_value
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`%s+0x%llx"
argument_list|,
name|obj
argument_list|,
name|name
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|addr
operator|-
name|sym
operator|.
name|st_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`%s"
argument_list|,
name|obj
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Pobjname
argument_list|(
name|P
argument_list|,
name|addr
argument_list|,
name|objname
argument_list|,
sizeof|sizeof
argument_list|(
name|objname
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`0x%llx"
argument_list|,
name|dt_basename
argument_list|(
name|objname
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_string2str
argument_list|(
name|c
argument_list|,
name|str
argument_list|,
name|nbytes
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

