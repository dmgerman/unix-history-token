begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * DTrace Process Control  *  * This file provides a set of routines that permit libdtrace and its clients  * to create and grab process handles using libproc, and to share these handles  * between library mechanisms that need libproc access, such as ustack(), and  * client mechanisms that need libproc access, such as dtrace(1M) -c and -p.  * The library provides several mechanisms in the libproc control layer:  *  * Reference Counting: The library code and client code can independently grab  * the same process handles without interfering with one another.  Only when  * the reference count drops to zero and the handle is not being cached (see  * below for more information on caching) will Prelease() be called on it.  *  * Handle Caching: If a handle is grabbed PGRAB_RDONLY (e.g. by ustack()) and  * the reference count drops to zero, the handle is not immediately released.  * Instead, libproc handles are maintained on dph_lrulist in order from most-  * recently accessed to least-recently accessed.  Idle handles are maintained  * until a pre-defined LRU cache limit is exceeded, permitting repeated calls  * to ustack() to avoid the overhead of releasing and re-grabbing processes.  *  * Process Control: For processes that are grabbed for control (~PGRAB_RDONLY)  * or created by dt_proc_create(), a control thread is created to provide  * callbacks on process exit and symbol table caching on dlopen()s.  *  * MT-Safety: Libproc is not MT-Safe, so dt_proc_lock() and dt_proc_unlock()  * are provided to synchronize access to the libproc handle between libdtrace  * code and client code and the control thread's use of the ps_prochandle.  *  * NOTE: MT-Safety is NOT provided for libdtrace itself, or for use of the  * dtrace_proc_grab/dtrace_proc_create mechanisms.  Like all exported libdtrace  * calls, these are assumed to be MT-Unsafe.  MT-Safety is ONLY provided for  * synchronization between libdtrace control threads and the client thread.  *  * The ps_prochandles themselves are maintained along with a dt_proc_t struct  * in a hash table indexed by PID.  This provides basic locking and reference  * counting.  The dt_proc_t is also maintained in LRU order on dph_lrulist.  * The dph_lrucnt and dph_lrulim count the number of cacheable processes and  * the current limit on the number of actively cached entries.  *  * The control thread for a process establishes breakpoints at the rtld_db  * locations of interest, updates mappings and symbol tables at these points,  * and handles exec and fork (by always following the parent).  The control  * thread automatically exits when the process dies or control is lost.  *  * A simple notification mechanism is provided for libdtrace clients using  * dtrace_handle_proc() for notification of PS_UNDEAD or PS_LOST events.  If  * such an event occurs, the dt_proc_t itself is enqueued on a notification  * list and the control thread broadcasts to dph_cv.  dtrace_sleep() will wake  * up using this condition and will then call the client handler as necessary.  */
end_comment

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/lwp.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<dt_proc.h>
end_include

begin_include
include|#
directive|include
file|<dt_pid.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_define
define|#
directive|define
name|IS_SYS_EXEC
parameter_list|(
name|w
parameter_list|)
value|(w == SYS_execve)
end_define

begin_define
define|#
directive|define
name|IS_SYS_FORK
parameter_list|(
name|w
parameter_list|)
value|(w == SYS_vfork || w == SYS_forksys)
end_define

begin_function
specifier|static
name|dt_bkpt_t
modifier|*
name|dt_proc_bpcreate
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|uintptr_t
name|addr
parameter_list|,
name|dt_bkpt_f
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|dpr
operator|->
name|dpr_proc
decl_stmt|;
name|dt_bkpt_t
modifier|*
name|dbp
decl_stmt|;
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbp
operator|=
name|dt_zalloc
argument_list|(
name|dpr
operator|->
name|dpr_hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_bkpt_t
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dbp
operator|->
name|dbp_func
operator|=
name|func
expr_stmt|;
name|dbp
operator|->
name|dbp_data
operator|=
name|data
expr_stmt|;
name|dbp
operator|->
name|dbp_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|Psetbkpt
argument_list|(
name|P
argument_list|,
name|dbp
operator|->
name|dbp_addr
argument_list|,
operator|&
name|dbp
operator|->
name|dbp_instr
argument_list|)
operator|==
literal|0
condition|)
name|dbp
operator|->
name|dbp_active
operator|=
name|B_TRUE
expr_stmt|;
name|dt_list_append
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_bps
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dbp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_bpdestroy
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|int
name|delbkpts
parameter_list|)
block|{
name|int
name|state
init|=
name|Pstate
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
decl_stmt|;
name|dt_bkpt_t
modifier|*
name|dbp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dbp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_bps
argument_list|)
init|;
name|dbp
operator|!=
name|NULL
condition|;
name|dbp
operator|=
name|nbp
control|)
block|{
if|if
condition|(
name|delbkpts
operator|&&
name|dbp
operator|->
name|dbp_active
operator|&&
name|state
operator|!=
name|PS_LOST
operator|&&
name|state
operator|!=
name|PS_UNDEAD
condition|)
block|{
operator|(
name|void
operator|)
name|Pdelbkpt
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|dbp
operator|->
name|dbp_addr
argument_list|,
name|dbp
operator|->
name|dbp_instr
argument_list|)
expr_stmt|;
block|}
name|nbp
operator|=
name|dt_list_next
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_bps
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dpr
operator|->
name|dpr_hdl
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_bpmatch
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
specifier|const
name|lwpstatus_t
modifier|*
name|psp
init|=
operator|&
name|Pstatus
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
operator|->
name|pr_lwp
decl_stmt|;
name|dt_bkpt_t
modifier|*
name|dbp
decl_stmt|;
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dbp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_bps
argument_list|)
init|;
name|dbp
operator|!=
name|NULL
condition|;
name|dbp
operator|=
name|dt_list_next
argument_list|(
name|dbp
argument_list|)
control|)
block|{
if|if
condition|(
name|psp
operator|->
name|pr_reg
index|[
name|R_PC
index|]
operator|==
name|dbp
operator|->
name|dbp_addr
condition|)
break|break;
block|}
if|if
condition|(
name|dbp
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: spurious breakpoint wakeup for %lx\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
operator|(
name|ulong_t
operator|)
name|psp
operator|->
name|pr_reg
index|[
name|R_PC
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|dt_dprintf
argument_list|(
literal|"pid %d: hit breakpoint at %lx (%lu)\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
operator|(
name|ulong_t
operator|)
name|dbp
operator|->
name|dbp_addr
argument_list|,
operator|++
name|dbp
operator|->
name|dbp_hits
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|dbp_func
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|,
name|dbp
operator|->
name|dbp_data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Pxecbkpt
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|dbp
operator|->
name|dbp_instr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_bpenable
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|dt_bkpt_t
modifier|*
name|dbp
decl_stmt|;
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dbp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_bps
argument_list|)
init|;
name|dbp
operator|!=
name|NULL
condition|;
name|dbp
operator|=
name|dt_list_next
argument_list|(
name|dbp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|dbp
operator|->
name|dbp_active
operator|&&
name|Psetbkpt
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|dbp
operator|->
name|dbp_addr
argument_list|,
operator|&
name|dbp
operator|->
name|dbp_instr
argument_list|)
operator|==
literal|0
condition|)
name|dbp
operator|->
name|dbp_active
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|dt_dprintf
argument_list|(
literal|"breakpoints enabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_bpdisable
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|dt_bkpt_t
modifier|*
name|dbp
decl_stmt|;
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dbp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_bps
argument_list|)
init|;
name|dbp
operator|!=
name|NULL
condition|;
name|dbp
operator|=
name|dt_list_next
argument_list|(
name|dbp
argument_list|)
control|)
block|{
if|if
condition|(
name|dbp
operator|->
name|dbp_active
operator|&&
name|Pdelbkpt
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|dbp
operator|->
name|dbp_addr
argument_list|,
name|dbp
operator|->
name|dbp_instr
argument_list|)
operator|==
literal|0
condition|)
name|dbp
operator|->
name|dbp_active
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|dt_dprintf
argument_list|(
literal|"breakpoints disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_notify
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_hash_t
modifier|*
name|dph
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|dt_proc_notify_t
modifier|*
name|dprn
init|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_proc_notify_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dprn
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to allocate notification for %d %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprn
operator|->
name|dprn_dpr
operator|=
name|dpr
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
name|dprn
operator|->
name|dprn_errmsg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dprn
operator|->
name|dprn_errmsg
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|dprn
operator|->
name|dprn_errmsg
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dph
operator|->
name|dph_lock
argument_list|)
expr_stmt|;
name|dprn
operator|->
name|dprn_next
operator|=
name|dph
operator|->
name|dph_notify
expr_stmt|;
name|dph
operator|->
name|dph_notify
operator|=
name|dprn
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|dph
operator|->
name|dph_cv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dph
operator|->
name|dph_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check to see if the control thread was requested to stop when the victim  * process reached a particular event (why) rather than continuing the victim.  * If 'why' is set in the stop mask, we wait on dpr_cv for dt_proc_continue().  * If 'why' is not set, this function returns immediately and does nothing.  */
end_comment

begin_function
specifier|static
name|void
name|dt_proc_stop
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|uint8_t
name|why
parameter_list|)
block|{
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|why
operator|!=
name|DT_PROC_STOP_IDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpr
operator|->
name|dpr_stop
operator|&
name|why
condition|)
block|{
name|dpr
operator|->
name|dpr_stop
operator||=
name|DT_PROC_STOP_IDLE
expr_stmt|;
name|dpr
operator|->
name|dpr_stop
operator|&=
operator|~
name|why
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|)
expr_stmt|;
comment|/* 		 * We disable breakpoints while stopped to preserve the 		 * integrity of the program text for both our own disassembly 		 * and that of the kernel. 		 */
name|dt_proc_bpdisable
argument_list|(
name|dpr
argument_list|)
expr_stmt|;
while|while
condition|(
name|dpr
operator|->
name|dpr_stop
operator|&
name|DT_PROC_STOP_IDLE
condition|)
operator|(
name|void
operator|)
name|pthread_cond_wait
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|,
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dt_proc_bpenable
argument_list|(
name|dpr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dt_proc_bpmain
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: breakpoint at %s()\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dt_proc_stop
argument_list|(
name|dpr
argument_list|,
name|DT_PROC_STOP_MAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_rdevent
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
specifier|const
name|char
modifier|*
name|evname
parameter_list|)
block|{
name|rd_event_msg_t
name|rdm
decl_stmt|;
name|rd_err_e
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|rd_event_getmsg
argument_list|(
name|dpr
operator|->
name|dpr_rtld
argument_list|,
operator|&
name|rdm
argument_list|)
operator|)
operator|!=
name|RD_OK
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: failed to get %s event message: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|evname
argument_list|,
name|rd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dt_dprintf
argument_list|(
literal|"pid %d: rtld event %s type=%d state %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|evname
argument_list|,
name|rdm
operator|.
name|type
argument_list|,
name|rdm
operator|.
name|u
operator|.
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rdm
operator|.
name|type
condition|)
block|{
case|case
name|RD_DLACTIVITY
case|:
if|if
condition|(
name|rdm
operator|.
name|u
operator|.
name|state
operator|!=
name|RD_CONSISTENT
condition|)
break|break;
name|Pupdate_syms
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_pid_create_probes_module
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|)
operator|!=
literal|0
condition|)
name|dt_proc_notify
argument_list|(
name|dtp
argument_list|,
name|dtp
operator|->
name|dt_procs
argument_list|,
name|dpr
argument_list|,
name|dpr
operator|->
name|dpr_errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|RD_PREINIT
case|:
name|Pupdate_syms
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
expr_stmt|;
name|dt_proc_stop
argument_list|(
name|dpr
argument_list|,
name|DT_PROC_STOP_PREINIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|RD_POSTINIT
case|:
name|Pupdate_syms
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
expr_stmt|;
name|dt_proc_stop
argument_list|(
name|dpr
argument_list|,
name|DT_PROC_STOP_POSTINIT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_rdwatch
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|rd_event_e
name|event
parameter_list|,
specifier|const
name|char
modifier|*
name|evname
parameter_list|)
block|{
name|rd_notify_t
name|rdn
decl_stmt|;
name|rd_err_e
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|rd_event_addr
argument_list|(
name|dpr
operator|->
name|dpr_rtld
argument_list|,
name|event
argument_list|,
operator|&
name|rdn
argument_list|)
operator|)
operator|!=
name|RD_OK
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: failed to get event address for %s: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|evname
argument_list|,
name|rd_errstr
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rdn
operator|.
name|type
operator|!=
name|RD_NOTIFY_BPT
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: event %s has unexpected type %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|evname
argument_list|,
name|rdn
operator|.
name|type
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|dt_proc_bpcreate
argument_list|(
name|dpr
argument_list|,
name|rdn
operator|.
name|u
operator|.
name|bptaddr
argument_list|,
operator|(
name|dt_bkpt_f
operator|*
operator|)
name|dt_proc_rdevent
argument_list|,
operator|(
name|void
operator|*
operator|)
name|evname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common code for enabling events associated with the run-time linker after  * attaching to a process or after a victim process completes an exec(2).  */
end_comment

begin_function
specifier|static
name|void
name|dt_proc_attach
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|int
name|exec
parameter_list|)
block|{
specifier|const
name|pstatus_t
modifier|*
name|psp
init|=
name|Pstatus
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
decl_stmt|;
name|rd_err_e
name|err
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec
condition|)
block|{
if|if
condition|(
name|psp
operator|->
name|pr_lwp
operator|.
name|pr_errno
operator|!=
literal|0
condition|)
return|return;
comment|/* exec failed: nothing needs to be done */
name|dt_proc_bpdestroy
argument_list|(
name|dpr
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|Preset_maps
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dpr
operator|->
name|dpr_rtld
operator|=
name|Prd_agent
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|err
operator|=
name|rd_event_enable
argument_list|(
name|dpr
operator|->
name|dpr_rtld
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|RD_OK
condition|)
block|{
name|dt_proc_rdwatch
argument_list|(
name|dpr
argument_list|,
name|RD_PREINIT
argument_list|,
literal|"RD_PREINIT"
argument_list|)
expr_stmt|;
name|dt_proc_rdwatch
argument_list|(
name|dpr
argument_list|,
name|RD_POSTINIT
argument_list|,
literal|"RD_POSTINIT"
argument_list|)
expr_stmt|;
name|dt_proc_rdwatch
argument_list|(
name|dpr
argument_list|,
name|RD_DLACTIVITY
argument_list|,
literal|"RD_DLACTIVITY"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: failed to enable rtld events: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|dpr
operator|->
name|dpr_rtld
condition|?
name|rd_errstr
argument_list|(
name|err
argument_list|)
else|:
literal|"rtld_db agent initialization failed"
argument_list|)
expr_stmt|;
block|}
name|Pupdate_maps
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|Pxlookup_by_name
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|LM_ID_BASE
argument_list|,
literal|"a.out"
argument_list|,
literal|"main"
argument_list|,
operator|&
name|sym
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dt_proc_bpcreate
argument_list|(
name|dpr
argument_list|,
operator|(
name|uintptr_t
operator|)
name|sym
operator|.
name|st_value
argument_list|,
operator|(
name|dt_bkpt_f
operator|*
operator|)
name|dt_proc_bpmain
argument_list|,
literal|"a.out`main"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: failed to find a.out`main: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wait for a stopped process to be set running again by some other debugger.  * This is typically not required by /proc-based debuggers, since the usual  * model is that one debugger controls one victim.  But DTrace, as usual, has  * its own needs: the stop() action assumes that prun(1) or some other tool  * will be applied to resume the victim process.  This could be solved by  * adding a PCWRUN directive to /proc, but that seems like overkill unless  * other debuggers end up needing this functionality, so we implement a cheap  * equivalent to PCWRUN using the set of existing kernel mechanisms.  *  * Our intent is really not just to wait for the victim to run, but rather to  * wait for it to run and then stop again for a reason other than the current  * PR_REQUESTED stop.  Since PCWSTOP/Pstopstatus() can be applied repeatedly  * to a stopped process and will return the same result without affecting the  * victim, we can just perform these operations repeatedly until Pstate()  * changes, the representative LWP ID changes, or the stop timestamp advances.  * dt_proc_control() will then rediscover the new state and continue as usual.  * When the process is still stopped in the same exact state, we sleep for a  * brief interval before waiting again so as not to spin consuming CPU cycles.  */
end_comment

begin_function
specifier|static
name|void
name|dt_proc_waitrun
parameter_list|(
name|dt_proc_t
modifier|*
name|dpr
parameter_list|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|dpr
operator|->
name|dpr_proc
decl_stmt|;
specifier|const
name|lwpstatus_t
modifier|*
name|psp
init|=
operator|&
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_lwp
decl_stmt|;
name|int
name|krflag
init|=
name|psp
operator|->
name|pr_flags
operator|&
operator|(
name|PR_KLC
operator||
name|PR_RLC
operator|)
decl_stmt|;
name|timestruc_t
name|tstamp
init|=
name|psp
operator|->
name|pr_tstamp
decl_stmt|;
name|lwpid_t
name|lwpid
init|=
name|psp
operator|->
name|pr_lwpid
decl_stmt|;
specifier|const
name|long
name|wstop
init|=
name|PCWSTOP
decl_stmt|;
name|int
name|pfd
init|=
name|Pctlfd
argument_list|(
name|P
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|psp
operator|->
name|pr_flags
operator|&
name|PR_STOPPED
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Pstate
argument_list|(
name|P
argument_list|)
operator|==
name|PS_STOP
argument_list|)
expr_stmt|;
comment|/* 	 * While we are waiting for the victim to run, clear PR_KLC and PR_RLC 	 * so that if the libdtrace client is killed, the victim stays stopped. 	 * dt_proc_destroy() will also observe this and perform PRELEASE_HANG. 	 */
operator|(
name|void
operator|)
name|Punsetflags
argument_list|(
name|P
argument_list|,
name|krflag
argument_list|)
expr_stmt|;
name|Psync
argument_list|(
name|P
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|dpr
operator|->
name|dpr_quit
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|pfd
argument_list|,
operator|&
name|wstop
argument_list|,
sizeof|sizeof
argument_list|(
name|wstop
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
comment|/* check dpr_quit and continue waiting */
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Pstopstatus
argument_list|(
name|P
argument_list|,
name|PCNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|psp
operator|=
operator|&
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_lwp
expr_stmt|;
comment|/* 		 * If we've reached a new state, found a new representative, or 		 * the stop timestamp has changed, restore PR_KLC/PR_RLC to its 		 * original setting and then return with dpr_lock held. 		 */
if|if
condition|(
name|Pstate
argument_list|(
name|P
argument_list|)
operator|!=
name|PS_STOP
operator|||
name|psp
operator|->
name|pr_lwpid
operator|!=
name|lwpid
operator|||
name|bcmp
argument_list|(
operator|&
name|psp
operator|->
name|pr_tstamp
argument_list|,
operator|&
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|tstamp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Psetflags
argument_list|(
name|P
argument_list|,
name|krflag
argument_list|)
expr_stmt|;
name|Psync
argument_list|(
name|P
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|poll
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|MILLISEC
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dt_proc_control_data
block|{
name|dtrace_hdl_t
modifier|*
name|dpcd_hdl
decl_stmt|;
comment|/* DTrace handle */
name|dt_proc_t
modifier|*
name|dpcd_proc
decl_stmt|;
comment|/* proccess to control */
block|}
name|dt_proc_control_data_t
typedef|;
end_typedef

begin_comment
comment|/*  * Main loop for all victim process control threads.  We initialize all the  * appropriate /proc control mechanisms, and then enter a loop waiting for  * the process to stop on an event or die.  We process any events by calling  * appropriate subroutines, and exit when the victim dies or we lose control.  *  * The control thread synchronizes the use of dpr_proc with other libdtrace  * threads using dpr_lock.  We hold the lock for all of our operations except  * waiting while the process is running: this is accomplished by writing a  * PCWSTOP directive directly to the underlying /proc/<pid>/ctl file.  If the  * libdtrace client wishes to exit or abort our wait, SIGCANCEL can be used.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|dt_proc_control
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_proc_control_data_t
modifier|*
name|datap
init|=
name|arg
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|datap
operator|->
name|dpcd_hdl
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
init|=
name|datap
operator|->
name|dpcd_proc
decl_stmt|;
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dpr
operator|->
name|dpr_hdl
operator|->
name|dt_procs
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|dpr
operator|->
name|dpr_proc
decl_stmt|;
name|int
name|pfd
init|=
name|Pctlfd
argument_list|(
name|P
argument_list|)
decl_stmt|;
name|int
name|pid
init|=
name|dpr
operator|->
name|dpr_pid
decl_stmt|;
specifier|const
name|long
name|wstop
init|=
name|PCWSTOP
decl_stmt|;
name|int
name|notify
init|=
name|B_FALSE
decl_stmt|;
comment|/* 	 * We disable the POSIX thread cancellation mechanism so that the 	 * client program using libdtrace can't accidentally cancel our thread. 	 * dt_proc_destroy() uses SIGCANCEL explicitly to simply poke us out 	 * of PCWSTOP with EINTR, at which point we will see dpr_quit and exit. 	 */
operator|(
name|void
operator|)
name|pthread_setcancelstate
argument_list|(
name|PTHREAD_CANCEL_DISABLE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the corresponding process for tracing by libdtrace.  We want 	 * to be able to catch breakpoints and efficiently single-step over 	 * them, and we need to enable librtld_db to watch libdl activity. 	 */
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Punsetflags
argument_list|(
name|P
argument_list|,
name|PR_ASYNC
argument_list|)
expr_stmt|;
comment|/* require synchronous mode */
operator|(
name|void
operator|)
name|Psetflags
argument_list|(
name|P
argument_list|,
name|PR_BPTADJ
argument_list|)
expr_stmt|;
comment|/* always adjust eip on x86 */
operator|(
name|void
operator|)
name|Punsetflags
argument_list|(
name|P
argument_list|,
name|PR_FORK
argument_list|)
expr_stmt|;
comment|/* do not inherit on fork */
operator|(
name|void
operator|)
name|Pfault
argument_list|(
name|P
argument_list|,
name|FLTBPT
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* always trace breakpoints */
operator|(
name|void
operator|)
name|Pfault
argument_list|(
name|P
argument_list|,
name|FLTTRACE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* always trace single-step */
comment|/* 	 * We must trace exit from exec() system calls so that if the exec is 	 * successful, we can reset our breakpoints and re-initialize libproc. 	 */
operator|(
name|void
operator|)
name|Psysexit
argument_list|(
name|P
argument_list|,
name|SYS_execve
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * We must trace entry and exit for fork() system calls in order to 	 * disable our breakpoints temporarily during the fork.  We do not set 	 * the PR_FORK flag, so if fork succeeds the child begins executing and 	 * does not inherit any other tracing behaviors or a control thread. 	 */
operator|(
name|void
operator|)
name|Psysentry
argument_list|(
name|P
argument_list|,
name|SYS_vfork
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Psysexit
argument_list|(
name|P
argument_list|,
name|SYS_vfork
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Psysentry
argument_list|(
name|P
argument_list|,
name|SYS_forksys
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Psysexit
argument_list|(
name|P
argument_list|,
name|SYS_forksys
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|Psync
argument_list|(
name|P
argument_list|)
expr_stmt|;
comment|/* enable all /proc changes */
name|dt_proc_attach
argument_list|(
name|dpr
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* enable rtld breakpoints */
comment|/* 	 * If PR_KLC is set, we created the process; otherwise we grabbed it. 	 * Check for an appropriate stop request and wait for dt_proc_continue. 	 */
if|if
condition|(
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_flags
operator|&
name|PR_KLC
condition|)
name|dt_proc_stop
argument_list|(
name|dpr
argument_list|,
name|DT_PROC_STOP_CREATE
argument_list|)
expr_stmt|;
else|else
name|dt_proc_stop
argument_list|(
name|dpr
argument_list|,
name|DT_PROC_STOP_GRAB
argument_list|)
expr_stmt|;
if|if
condition|(
name|Psetrun
argument_list|(
name|P
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: failed to set running: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the process corresponding to this control thread to stop, 	 * process the event, and then set it running again.  We want to sleep 	 * with dpr_lock *unheld* so that other parts of libdtrace can use the 	 * ps_prochandle in the meantime (e.g. ustack()).  To do this, we write 	 * a PCWSTOP directive directly to the underlying /proc/<pid>/ctl file. 	 * Once the process stops, we wake up, grab dpr_lock, and then call 	 * Pwait() (which will return immediately) and do our processing. 	 */
while|while
condition|(
operator|!
name|dpr
operator|->
name|dpr_quit
condition|)
block|{
specifier|const
name|lwpstatus_t
modifier|*
name|psp
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pfd
argument_list|,
operator|&
name|wstop
argument_list|,
sizeof|sizeof
argument_list|(
name|wstop
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
comment|/* check dpr_quit and continue waiting */
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|pwait_locked
label|:
if|if
condition|(
name|Pstopstatus
argument_list|(
name|P
argument_list|,
name|PCNULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
continue|continue;
comment|/* check dpr_quit and continue waiting */
block|}
switch|switch
condition|(
name|Pstate
argument_list|(
name|P
argument_list|)
condition|)
block|{
case|case
name|PS_STOP
case|:
name|psp
operator|=
operator|&
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_lwp
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"pid %d: proc stopped showing %d/%d\n"
argument_list|,
name|pid
argument_list|,
name|psp
operator|->
name|pr_why
argument_list|,
name|psp
operator|->
name|pr_what
argument_list|)
expr_stmt|;
comment|/* 			 * If the process stops showing PR_REQUESTED, then the 			 * DTrace stop() action was applied to it or another 			 * debugging utility (e.g. pstop(1)) asked it to stop. 			 * In either case, the user's intention is for the 			 * process to remain stopped until another external 			 * mechanism (e.g. prun(1)) is applied.  So instead of 			 * setting the process running ourself, we wait for 			 * someone else to do so.  Once that happens, we return 			 * to our normal loop waiting for an event of interest. 			 */
if|if
condition|(
name|psp
operator|->
name|pr_why
operator|==
name|PR_REQUESTED
condition|)
block|{
name|dt_proc_waitrun
argument_list|(
name|dpr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If the process stops showing one of the events that 			 * we are tracing, perform the appropriate response. 			 * Note that we ignore PR_SUSPENDED, PR_CHECKPOINT, and 			 * PR_JOBCONTROL by design: if one of these conditions 			 * occurs, we will fall through to Psetrun() but the 			 * process will remain stopped in the kernel by the 			 * corresponding mechanism (e.g. job control stop). 			 */
if|if
condition|(
name|psp
operator|->
name|pr_why
operator|==
name|PR_FAULTED
operator|&&
name|psp
operator|->
name|pr_what
operator|==
name|FLTBPT
condition|)
name|dt_proc_bpmatch
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psp
operator|->
name|pr_why
operator|==
name|PR_SYSENTRY
operator|&&
name|IS_SYS_FORK
argument_list|(
name|psp
operator|->
name|pr_what
argument_list|)
condition|)
name|dt_proc_bpdisable
argument_list|(
name|dpr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psp
operator|->
name|pr_why
operator|==
name|PR_SYSEXIT
operator|&&
name|IS_SYS_FORK
argument_list|(
name|psp
operator|->
name|pr_what
argument_list|)
condition|)
name|dt_proc_bpenable
argument_list|(
name|dpr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psp
operator|->
name|pr_why
operator|==
name|PR_SYSEXIT
operator|&&
name|IS_SYS_EXEC
argument_list|(
name|psp
operator|->
name|pr_what
argument_list|)
condition|)
name|dt_proc_attach
argument_list|(
name|dpr
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_LOST
case|:
if|if
condition|(
name|Preopen
argument_list|(
name|P
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|pwait_locked
goto|;
name|dt_dprintf
argument_list|(
literal|"pid %d: proc lost: %s\n"
argument_list|,
name|pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_quit
operator|=
name|B_TRUE
expr_stmt|;
name|notify
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|PS_UNDEAD
case|:
name|dt_dprintf
argument_list|(
literal|"pid %d: proc died\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_quit
operator|=
name|B_TRUE
expr_stmt|;
name|notify
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Pstate
argument_list|(
name|P
argument_list|)
operator|!=
name|PS_UNDEAD
operator|&&
name|Psetrun
argument_list|(
name|P
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"pid %d: failed to set running: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the control thread detected PS_UNDEAD or PS_LOST, then enqueue 	 * the dt_proc_t structure on the dt_proc_hash_t notification list. 	 */
if|if
condition|(
name|notify
condition|)
name|dt_proc_notify
argument_list|(
name|dtp
argument_list|,
name|dph
argument_list|,
name|dpr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy and remove any remaining breakpoints, set dpr_done and clear 	 * dpr_tid to indicate the control thread has exited, and notify any 	 * waiting thread in dt_proc_destroy() that we have succesfully exited. 	 */
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dt_proc_bpdestroy
argument_list|(
name|dpr
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_done
operator|=
name|B_TRUE
expr_stmt|;
name|dpr
operator|->
name|dpr_tid
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*PRINTFLIKE3*/
end_comment

begin_function
specifier|static
name|struct
name|ps_prochandle
modifier|*
name|dt_proc_error
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|dt_set_errmsg
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpr
operator|->
name|dpr_proc
operator|!=
name|NULL
condition|)
name|Prelease
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_COMPILER
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|dt_proc_t
modifier|*
name|dt_proc_lookup
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dtp
operator|->
name|dt_procs
decl_stmt|;
name|pid_t
name|pid
init|=
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_pid
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
decl_stmt|,
modifier|*
modifier|*
name|dpp
init|=
operator|&
name|dph
operator|->
name|dph_hash
index|[
name|pid
operator|&
operator|(
name|dph
operator|->
name|dph_hashlen
operator|-
literal|1
operator|)
index|]
decl_stmt|;
for|for
control|(
name|dpr
operator|=
operator|*
name|dpp
init|;
name|dpr
operator|!=
name|NULL
condition|;
name|dpr
operator|=
name|dpr
operator|->
name|dpr_hash
control|)
block|{
if|if
condition|(
name|dpr
operator|->
name|dpr_pid
operator|==
name|pid
condition|)
break|break;
else|else
name|dpp
operator|=
operator|&
name|dpr
operator|->
name|dpr_hash
expr_stmt|;
block|}
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dpr
operator|->
name|dpr_proc
operator|==
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
condition|)
operator|*
name|dpp
operator|=
name|dpr
operator|->
name|dpr_hash
expr_stmt|;
comment|/* remove from pid hash chain */
return|return
operator|(
name|dpr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_proc_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|dt_proc_t
modifier|*
name|dpr
init|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dtp
operator|->
name|dt_procs
decl_stmt|;
name|dt_proc_notify_t
modifier|*
name|npr
decl_stmt|,
modifier|*
modifier|*
name|npp
decl_stmt|;
name|int
name|rflag
decl_stmt|;
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If neither PR_KLC nor PR_RLC is set, then the process is stopped by 	 * an external debugger and we were waiting in dt_proc_waitrun(). 	 * Leave the process in this condition using PRELEASE_HANG. 	 */
if|if
condition|(
operator|!
operator|(
name|Pstatus
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
operator|->
name|pr_flags
operator|&
operator|(
name|PR_KLC
operator||
name|PR_RLC
operator|)
operator|)
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"abandoning pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|)
expr_stmt|;
name|rflag
operator|=
name|PRELEASE_HANG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Pstatus
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
operator|->
name|pr_flags
operator|&
name|PR_KLC
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"killing pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|)
expr_stmt|;
name|rflag
operator|=
name|PRELEASE_KILL
expr_stmt|;
comment|/* apply kill-on-last-close */
block|}
else|else
block|{
name|dt_dprintf
argument_list|(
literal|"releasing pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|)
expr_stmt|;
name|rflag
operator|=
literal|0
expr_stmt|;
comment|/* apply run-on-last-close */
block|}
if|if
condition|(
name|dpr
operator|->
name|dpr_tid
condition|)
block|{
comment|/* 		 * Set the dpr_quit flag to tell the daemon thread to exit.  We 		 * send it a SIGCANCEL to poke it out of PCWSTOP or any other 		 * long-term /proc system call.  Our daemon threads have POSIX 		 * cancellation disabled, so EINTR will be the only effect.  We 		 * then wait for dpr_done to indicate the thread has exited. 		 * 		 * We can't use pthread_kill() to send SIGCANCEL because the 		 * interface forbids it and we can't use pthread_cancel() 		 * because with cancellation disabled it won't actually 		 * send SIGCANCEL to the target thread, so we use _lwp_kill() 		 * to do the job.  This is all built on evil knowledge of 		 * the details of the cancellation mechanism in libc. 		 */
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_quit
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|_lwp_kill
argument_list|(
name|dpr
operator|->
name|dpr_tid
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
comment|/* 		 * If the process is currently idling in dt_proc_stop(), re- 		 * enable breakpoints and poke it into running again. 		 */
if|if
condition|(
name|dpr
operator|->
name|dpr_stop
operator|&
name|DT_PROC_STOP_IDLE
condition|)
block|{
name|dt_proc_bpenable
argument_list|(
name|dpr
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_stop
operator|&=
operator|~
name|DT_PROC_STOP_IDLE
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|dpr
operator|->
name|dpr_done
condition|)
operator|(
name|void
operator|)
name|pthread_cond_wait
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|,
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Before we free the process structure, remove this dt_proc_t from the 	 * lookup hash, and then walk the dt_proc_hash_t's notification list 	 * and remove this dt_proc_t if it is enqueued. 	 */
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dph
operator|->
name|dph_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|npp
operator|=
operator|&
name|dph
operator|->
name|dph_notify
expr_stmt|;
while|while
condition|(
operator|(
name|npr
operator|=
operator|*
name|npp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|npr
operator|->
name|dprn_dpr
operator|==
name|dpr
condition|)
block|{
operator|*
name|npp
operator|=
name|npr
operator|->
name|dprn_next
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|npr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|npp
operator|=
operator|&
name|npr
operator|->
name|dprn_next
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dph
operator|->
name|dph_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the dt_proc_list from the LRU list, release the underlying 	 * libproc handle, and free our dt_proc_t data structure. 	 */
if|if
condition|(
name|dpr
operator|->
name|dpr_cacheable
condition|)
block|{
name|assert
argument_list|(
name|dph
operator|->
name|dph_lrucnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dph
operator|->
name|dph_lrucnt
operator|--
expr_stmt|;
block|}
name|dt_list_delete
argument_list|(
operator|&
name|dph
operator|->
name|dph_lrulist
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
name|Prelease
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_proc_create_thread
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dt_proc_t
modifier|*
name|dpr
parameter_list|,
name|uint_t
name|stop
parameter_list|)
block|{
name|dt_proc_control_data_t
name|data
decl_stmt|;
name|sigset_t
name|nset
decl_stmt|,
name|oset
decl_stmt|;
name|pthread_attr_t
name|a
decl_stmt|;
name|int
name|err
decl_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_stop
operator||=
name|stop
expr_stmt|;
comment|/* set bit for initial rendezvous */
operator|(
name|void
operator|)
name|pthread_attr_init
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|a
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigfillset
argument_list|(
operator|&
name|nset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigdelset
argument_list|(
operator|&
name|nset
argument_list|,
name|SIGABRT
argument_list|)
expr_stmt|;
comment|/* unblocked for assert() */
operator|(
name|void
operator|)
name|sigdelset
argument_list|(
operator|&
name|nset
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
comment|/* see dt_proc_destroy() */
name|data
operator|.
name|dpcd_hdl
operator|=
name|dtp
expr_stmt|;
name|data
operator|.
name|dpcd_proc
operator|=
name|dpr
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|nset
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
name|err
operator|=
name|pthread_create
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_tid
argument_list|,
operator|&
name|a
argument_list|,
name|dt_proc_control
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If the control thread was created, then wait on dpr_cv for either 	 * dpr_done to be set (the victim died or the control thread failed) 	 * or DT_PROC_STOP_IDLE to be set, indicating that the victim is now 	 * stopped by /proc and the control thread is at the rendezvous event. 	 * On success, we return with the process and control thread stopped: 	 * the caller can then apply dt_proc_continue() to resume both. 	 */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|!
name|dpr
operator|->
name|dpr_done
operator|&&
operator|!
operator|(
name|dpr
operator|->
name|dpr_stop
operator|&
name|DT_PROC_STOP_IDLE
operator|)
condition|)
operator|(
name|void
operator|)
name|pthread_cond_wait
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|,
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If dpr_done is set, the control thread aborted before it 		 * reached the rendezvous event.  This is either due to PS_LOST 		 * or PS_UNDEAD (i.e. the process died).  We try to provide a 		 * small amount of useful information to help figure it out. 		 */
if|if
condition|(
name|dpr
operator|->
name|dpr_done
condition|)
block|{
specifier|const
name|psinfo_t
modifier|*
name|prp
init|=
name|Ppsinfo
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
decl_stmt|;
name|int
name|stat
init|=
name|prp
condition|?
name|prp
operator|->
name|pr_wstat
else|:
literal|0
decl_stmt|;
name|int
name|pid
init|=
name|dpr
operator|->
name|dpr_pid
decl_stmt|;
if|if
condition|(
name|Pstate
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
operator|==
name|PS_LOST
condition|)
block|{
operator|(
name|void
operator|)
name|dt_proc_error
argument_list|(
name|dpr
operator|->
name|dpr_hdl
argument_list|,
name|dpr
argument_list|,
literal|"failed to control pid %d: process exec'd "
literal|"set-id or unobservable program\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|stat
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|dt_proc_error
argument_list|(
name|dpr
operator|->
name|dpr_hdl
argument_list|,
name|dpr
argument_list|,
literal|"failed to control pid %d: process died "
literal|"from signal %d\n"
argument_list|,
name|pid
argument_list|,
name|WTERMSIG
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dt_proc_error
argument_list|(
name|dpr
operator|->
name|dpr_hdl
argument_list|,
name|dpr
argument_list|,
literal|"failed to control pid %d: process exited "
literal|"with status %d\n"
argument_list|,
name|pid
argument_list|,
name|WEXITSTATUS
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ESRCH
expr_stmt|;
comment|/* cause grab() or create() to fail */
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dt_proc_error
argument_list|(
name|dpr
operator|->
name|dpr_hdl
argument_list|,
name|dpr
argument_list|,
literal|"failed to create control thread for process-id %d: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_attr_destroy
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ps_prochandle
modifier|*
name|dt_proc_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dtp
operator|->
name|dt_procs
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|dpr
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_proc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno is set for us */
operator|(
name|void
operator|)
name|pthread_mutex_init
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_init
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dpr
operator|->
name|dpr_proc
operator|=
name|Pcreate
argument_list|(
name|file
argument_list|,
name|argv
argument_list|,
operator|&
name|err
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_proc_error
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|,
literal|"failed to execute %s: %s\n"
argument_list|,
name|file
argument_list|,
name|Pcreate_error
argument_list|(
name|err
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|dpr
operator|->
name|dpr_hdl
operator|=
name|dtp
expr_stmt|;
name|dpr
operator|->
name|dpr_pid
operator|=
name|Pstatus
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|)
operator|->
name|pr_pid
expr_stmt|;
operator|(
name|void
operator|)
name|Punsetflags
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|PR_RLC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Psetflags
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|PR_KLC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_proc_create_thread
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|,
name|dtp
operator|->
name|dt_prcmode
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_proc_error() has been called for us */
name|dpr
operator|->
name|dpr_hash
operator|=
name|dph
operator|->
name|dph_hash
index|[
name|dpr
operator|->
name|dpr_pid
operator|&
operator|(
name|dph
operator|->
name|dph_hashlen
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|dph
operator|->
name|dph_hash
index|[
name|dpr
operator|->
name|dpr_pid
operator|&
operator|(
name|dph
operator|->
name|dph_hashlen
operator|-
literal|1
operator|)
index|]
operator|=
name|dpr
expr_stmt|;
name|dt_list_prepend
argument_list|(
operator|&
name|dph
operator|->
name|dph_lrulist
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"created pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|dpr
operator|->
name|dpr_pid
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_refs
operator|++
expr_stmt|;
return|return
operator|(
name|dpr
operator|->
name|dpr_proc
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ps_prochandle
modifier|*
name|dt_proc_grab
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|nomonitor
parameter_list|)
block|{
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dtp
operator|->
name|dt_procs
decl_stmt|;
name|uint_t
name|h
init|=
name|pid
operator|&
operator|(
name|dph
operator|->
name|dph_hashlen
operator|-
literal|1
operator|)
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
decl_stmt|,
modifier|*
name|opr
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Search the hash table for the pid.  If it is already grabbed or 	 * created, move the handle to the front of the lrulist, increment 	 * the reference count, and return the existing ps_prochandle. 	 */
for|for
control|(
name|dpr
operator|=
name|dph
operator|->
name|dph_hash
index|[
name|h
index|]
init|;
name|dpr
operator|!=
name|NULL
condition|;
name|dpr
operator|=
name|dpr
operator|->
name|dpr_hash
control|)
block|{
if|if
condition|(
name|dpr
operator|->
name|dpr_pid
operator|==
name|pid
operator|&&
operator|!
name|dpr
operator|->
name|dpr_stale
condition|)
block|{
comment|/* 			 * If the cached handle was opened read-only and 			 * this request is for a writeable handle, mark 			 * the cached handle as stale and open a new handle. 			 * Since it's stale, unmark it as cacheable. 			 */
if|if
condition|(
name|dpr
operator|->
name|dpr_rdonly
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PGRAB_RDONLY
operator|)
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"upgrading pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_stale
operator|=
name|B_TRUE
expr_stmt|;
name|dpr
operator|->
name|dpr_cacheable
operator|=
name|B_FALSE
expr_stmt|;
name|dph
operator|->
name|dph_lrucnt
operator|--
expr_stmt|;
break|break;
block|}
name|dt_dprintf
argument_list|(
literal|"grabbed pid %d (cached)\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|dph
operator|->
name|dph_lrulist
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
name|dt_list_prepend
argument_list|(
operator|&
name|dph
operator|->
name|dph_lrulist
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_refs
operator|++
expr_stmt|;
return|return
operator|(
name|dpr
operator|->
name|dpr_proc
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|dpr
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_proc_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* errno is set for us */
operator|(
name|void
operator|)
name|pthread_mutex_init
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_init
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dpr
operator|->
name|dpr_proc
operator|=
name|Pgrab
argument_list|(
name|pid
argument_list|,
name|flags
argument_list|,
operator|&
name|err
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|dt_proc_error
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|,
literal|"failed to grab pid %d: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|,
name|Pgrab_error
argument_list|(
name|err
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|dpr
operator|->
name|dpr_hdl
operator|=
name|dtp
expr_stmt|;
name|dpr
operator|->
name|dpr_pid
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|Punsetflags
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|PR_KLC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Psetflags
argument_list|(
name|dpr
operator|->
name|dpr_proc
argument_list|,
name|PR_RLC
argument_list|)
expr_stmt|;
comment|/* 	 * If we are attempting to grab the process without a monitor 	 * thread, then mark the process cacheable only if it's being 	 * grabbed read-only.  If we're currently caching more process 	 * handles than dph_lrulim permits, attempt to find the 	 * least-recently-used handle that is currently unreferenced and 	 * release it from the cache.  Otherwise we are grabbing the process 	 * for control: create a control thread for this process and store 	 * its ID in dpr->dpr_tid. 	 */
if|if
condition|(
name|nomonitor
operator|||
operator|(
name|flags
operator|&
name|PGRAB_RDONLY
operator|)
condition|)
block|{
if|if
condition|(
name|dph
operator|->
name|dph_lrucnt
operator|>=
name|dph
operator|->
name|dph_lrulim
condition|)
block|{
for|for
control|(
name|opr
operator|=
name|dt_list_prev
argument_list|(
operator|&
name|dph
operator|->
name|dph_lrulist
argument_list|)
init|;
name|opr
operator|!=
name|NULL
condition|;
name|opr
operator|=
name|dt_list_prev
argument_list|(
name|opr
argument_list|)
control|)
block|{
if|if
condition|(
name|opr
operator|->
name|dpr_cacheable
operator|&&
name|opr
operator|->
name|dpr_refs
operator|==
literal|0
condition|)
block|{
name|dt_proc_destroy
argument_list|(
name|dtp
argument_list|,
name|opr
operator|->
name|dpr_proc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|PGRAB_RDONLY
condition|)
block|{
name|dpr
operator|->
name|dpr_cacheable
operator|=
name|B_TRUE
expr_stmt|;
name|dpr
operator|->
name|dpr_rdonly
operator|=
name|B_TRUE
expr_stmt|;
name|dph
operator|->
name|dph_lrucnt
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dt_proc_create_thread
argument_list|(
name|dtp
argument_list|,
name|dpr
argument_list|,
name|DT_PROC_STOP_GRAB
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* dt_proc_error() has been called for us */
name|dpr
operator|->
name|dpr_hash
operator|=
name|dph
operator|->
name|dph_hash
index|[
name|h
index|]
expr_stmt|;
name|dph
operator|->
name|dph_hash
index|[
name|h
index|]
operator|=
name|dpr
expr_stmt|;
name|dt_list_prepend
argument_list|(
operator|&
name|dph
operator|->
name|dph_lrulist
argument_list|,
name|dpr
argument_list|)
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"grabbed pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
name|dpr
operator|->
name|dpr_refs
operator|++
expr_stmt|;
return|return
operator|(
name|dpr
operator|->
name|dpr_proc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_proc_release
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|dt_proc_t
modifier|*
name|dpr
init|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dtp
operator|->
name|dt_procs
decl_stmt|;
name|assert
argument_list|(
name|dpr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dpr
operator|->
name|dpr_refs
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|dpr
operator|->
name|dpr_refs
operator|==
literal|0
operator|&&
operator|(
operator|!
name|dpr
operator|->
name|dpr_cacheable
operator|||
name|dph
operator|->
name|dph_lrucnt
operator|>
name|dph
operator|->
name|dph_lrulim
operator|)
condition|)
name|dt_proc_destroy
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_proc_continue
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|dt_proc_t
modifier|*
name|dpr
init|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpr
operator|->
name|dpr_stop
operator|&
name|DT_PROC_STOP_IDLE
condition|)
block|{
name|dpr
operator|->
name|dpr_stop
operator|&=
operator|~
name|DT_PROC_STOP_IDLE
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_broadcast
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_cv
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dt_proc_lock
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|dt_proc_t
modifier|*
name|dpr
init|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* check for recursion */
block|}
end_function

begin_function
name|void
name|dt_proc_unlock
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|dt_proc_t
modifier|*
name|dpr
init|=
name|dt_proc_lookup
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|,
name|B_FALSE
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dpr
operator|->
name|dpr_lock
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* check for unheld lock */
block|}
end_function

begin_function
name|void
name|dt_proc_hash_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dtp
operator|->
name|dt_procs
operator|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_proc_hash_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dt_proc_t
operator|*
argument_list|)
operator|*
name|_dtrace_pidbuckets
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_mutex_init
argument_list|(
operator|&
name|dtp
operator|->
name|dt_procs
operator|->
name|dph_lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_cond_init
argument_list|(
operator|&
name|dtp
operator|->
name|dt_procs
operator|->
name|dph_cv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_procs
operator|->
name|dph_hashlen
operator|=
name|_dtrace_pidbuckets
expr_stmt|;
name|dtp
operator|->
name|dt_procs
operator|->
name|dph_lrulim
operator|=
name|_dtrace_pidlrulim
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dt_proc_hash_destroy
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_proc_hash_t
modifier|*
name|dph
init|=
name|dtp
operator|->
name|dt_procs
decl_stmt|;
name|dt_proc_t
modifier|*
name|dpr
decl_stmt|;
while|while
condition|(
operator|(
name|dpr
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dph
operator|->
name|dph_lrulist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dt_proc_destroy
argument_list|(
name|dtp
argument_list|,
name|dpr
operator|->
name|dpr_proc
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_procs
operator|=
name|NULL
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dph
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ps_prochandle
modifier|*
name|dtrace_proc_create
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
init|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"target"
argument_list|)
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|dt_proc_create
argument_list|(
name|dtp
argument_list|,
name|file
argument_list|,
name|argv
argument_list|)
decl_stmt|;
if|if
condition|(
name|P
operator|!=
name|NULL
operator|&&
name|idp
operator|!=
name|NULL
operator|&&
name|idp
operator|->
name|di_id
operator|==
literal|0
condition|)
name|idp
operator|->
name|di_id
operator|=
name|Pstatus
argument_list|(
name|P
argument_list|)
operator|->
name|pr_pid
expr_stmt|;
comment|/* $target = created pid */
return|return
operator|(
name|P
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ps_prochandle
modifier|*
name|dtrace_proc_grab
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
init|=
name|dt_idhash_lookup
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
literal|"target"
argument_list|)
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
init|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|P
operator|!=
name|NULL
operator|&&
name|idp
operator|!=
name|NULL
operator|&&
name|idp
operator|->
name|di_id
operator|==
literal|0
condition|)
name|idp
operator|->
name|di_id
operator|=
name|pid
expr_stmt|;
comment|/* $target = grabbed pid */
return|return
operator|(
name|P
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dtrace_proc_release
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dtrace_proc_continue
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|struct
name|ps_prochandle
modifier|*
name|P
parameter_list|)
block|{
name|dt_proc_continue
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

