begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<libelf.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|_POSIX_PTHREAD_SEMANTICS
end_define

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_undef
undef|#
directive|undef
name|_POSIX_PTHREAD_SEMANTICS
end_undef

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_program.h>
end_include

begin_include
include|#
directive|include
file|<dt_module.h>
end_include

begin_include
include|#
directive|include
file|<dt_printf.h>
end_include

begin_include
include|#
directive|include
file|<dt_string.h>
end_include

begin_include
include|#
directive|include
file|<dt_provider.h>
end_include

begin_comment
comment|/*  * Stability and versioning definitions.  These #defines are used in the tables  * of identifiers below to fill in the attribute and version fields associated  * with each identifier.  The DT_ATTR_* macros are a convenience to permit more  * concise declarations of common attributes such as Stable/Stable/Common.  The  * DT_VERS_* macros declare the encoded integer values of all versions used so  * far.  DT_VERS_LATEST must correspond to the latest version value among all  * versions exported by the D compiler.  DT_VERS_STRING must be an ASCII string  * that contains DT_VERS_LATEST within it along with any suffixes (e.g. Beta).  * You must update DT_VERS_LATEST and DT_VERS_STRING when adding a new version,  * and then add the new version to the _dtrace_versions[] array declared below.  * Refer to the Solaris Dynamic Tracing Guide Stability and Versioning chapters  * respectively for an explanation of these DTrace features and their values.  *  * NOTE: Although the DTrace versioning scheme supports the labeling and  *       introduction of incompatible changes (e.g. dropping an interface in a  *       major release), the libdtrace code does not currently support this.  *       All versions are assumed to strictly inherit from one another.  If  *       we ever need to provide divergent interfaces, this will need work.  */
end_comment

begin_define
define|#
directive|define
name|DT_ATTR_STABCMN
value|{ DTRACE_STABILITY_STABLE, \ 	DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON }
end_define

begin_define
define|#
directive|define
name|DT_ATTR_EVOLCMN
value|{ DTRACE_STABILITY_EVOLVING, \ 	DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON \ }
end_define

begin_comment
comment|/*  * The version number should be increased for every customer visible release  * of Solaris. The major number should be incremented when a fundamental  * change has been made that would affect all consumers, and would reflect  * sweeping changes to DTrace or the D language. The minor number should be  * incremented when a change is introduced that could break scripts that had  * previously worked; for example, adding a new built-in variable could break  * a script which was already using that identifier. The micro number should  * be changed when introducing functionality changes or major bug fixes that  * do not affect backward compatibility -- this is merely to make capabilities  * easily determined from the version number. Minor bugs do not require any  * modification to the version number.  */
end_comment

begin_define
define|#
directive|define
name|DT_VERS_1_0
value|DT_VERSION_NUMBER(1, 0, 0)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_1
value|DT_VERSION_NUMBER(1, 1, 0)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_2
value|DT_VERSION_NUMBER(1, 2, 0)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_2_1
value|DT_VERSION_NUMBER(1, 2, 1)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_2_2
value|DT_VERSION_NUMBER(1, 2, 2)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_3
value|DT_VERSION_NUMBER(1, 3, 0)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_4
value|DT_VERSION_NUMBER(1, 4, 0)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_4_1
value|DT_VERSION_NUMBER(1, 4, 1)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_5
value|DT_VERSION_NUMBER(1, 5, 0)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_6
value|DT_VERSION_NUMBER(1, 6, 0)
end_define

begin_define
define|#
directive|define
name|DT_VERS_1_6_1
value|DT_VERSION_NUMBER(1, 6, 1)
end_define

begin_define
define|#
directive|define
name|DT_VERS_LATEST
value|DT_VERS_1_6_1
end_define

begin_define
define|#
directive|define
name|DT_VERS_STRING
value|"Sun D 1.6.1"
end_define

begin_decl_stmt
specifier|const
name|dt_version_t
name|_dtrace_versions
index|[]
init|=
block|{
name|DT_VERS_1_0
block|,
comment|/* D API 1.0.0 (PSARC 2001/466) Solaris 10 FCS */
name|DT_VERS_1_1
block|,
comment|/* D API 1.1.0 Solaris Express 6/05 */
name|DT_VERS_1_2
block|,
comment|/* D API 1.2.0 Solaris 10 Update 1 */
name|DT_VERS_1_2_1
block|,
comment|/* D API 1.2.1 Solaris Express 4/06 */
name|DT_VERS_1_2_2
block|,
comment|/* D API 1.2.2 Solaris Express 6/06 */
name|DT_VERS_1_3
block|,
comment|/* D API 1.3 Solaris Express 10/06 */
name|DT_VERS_1_4
block|,
comment|/* D API 1.4 Solaris Express 2/07 */
name|DT_VERS_1_4_1
block|,
comment|/* D API 1.4.1 Solaris Express 4/07 */
name|DT_VERS_1_5
block|,
comment|/* D API 1.5 Solaris Express 7/07 */
name|DT_VERS_1_6
block|,
comment|/* D API 1.6 */
name|DT_VERS_1_6_1
block|,
comment|/* D API 1.6.1 */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of global identifiers.  This is used to populate the global identifier  * hash when a new dtrace client open occurs.  For more info see dt_ident.h.  * The global identifiers that represent functions use the dt_idops_func ops  * and specify the private data pointer as a prototype string which is parsed  * when the identifier is first encountered.  These prototypes look like ANSI  * C function prototypes except that the special symbol "@" can be used as a  * wildcard to represent a single parameter of any type (i.e. any dt_node_t).  * The standard "..." notation can also be used to represent varargs.  An empty  * parameter list is taken to mean void (that is, no arguments are permitted).  * A parameter enclosed in square brackets (e.g. "[int]") denotes an optional  * argument.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_ident_t
name|_dtrace_globals
index|[]
init|=
block|{
block|{
literal|"alloca"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_ALLOCA
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void *(size_t)"
block|}
block|,
block|{
literal|"arg0"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg1"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG1
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg2"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG2
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg3"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG3
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg4"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG4
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg5"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG5
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg6"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG6
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg7"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG7
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg8"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG8
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"arg9"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ARG9
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"args"
block|,
name|DT_IDENT_ARRAY
block|,
literal|0
block|,
name|DIF_VAR_ARGS
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_args
block|,
name|NULL
block|}
block|,
block|{
literal|"avg"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_AVG
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@)"
block|}
block|,
block|{
literal|"basename"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_BASENAME
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *)"
block|}
block|,
block|{
literal|"bcopy"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_BCOPY
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(void *, void *, size_t)"
block|}
block|,
block|{
literal|"breakpoint"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_BREAKPOINT
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void()"
block|}
block|,
block|{
literal|"caller"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_CALLER
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uintptr_t"
block|}
block|,
block|{
literal|"chill"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_CHILL
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(int)"
block|}
block|,
block|{
literal|"cleanpath"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_CLEANPATH
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *)"
block|}
block|,
block|{
literal|"clear"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_CLEAR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(...)"
block|}
block|,
block|{
literal|"commit"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_COMMIT
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(int)"
block|}
block|,
block|{
literal|"copyin"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_COPYIN
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void *(uintptr_t, size_t)"
block|}
block|,
block|{
literal|"copyinstr"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_COPYINSTR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(uintptr_t, [size_t])"
block|}
block|,
block|{
literal|"copyinto"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_COPYINTO
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(uintptr_t, size_t, void *)"
block|}
block|,
block|{
literal|"copyout"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_COPYOUT
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(void *, uintptr_t, size_t)"
block|}
block|,
block|{
literal|"copyoutstr"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_COPYOUTSTR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(char *, uintptr_t, size_t)"
block|}
block|,
block|{
literal|"count"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_COUNT
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void()"
block|}
block|,
block|{
literal|"curthread"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_CURTHREAD
block|,
block|{
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"genunix`kthread_t *"
block|}
block|,
block|{
literal|"ddi_pathname"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_DDI_PATHNAME
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(void *, int64_t)"
block|}
block|,
block|{
literal|"denormalize"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_DENORMALIZE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(...)"
block|}
block|,
block|{
literal|"dirname"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_DIRNAME
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *)"
block|}
block|,
block|{
literal|"discard"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_DISCARD
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(int)"
block|}
block|,
block|{
literal|"epid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_EPID
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint_t"
block|}
block|,
block|{
literal|"errno"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ERRNO
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int"
block|}
block|,
block|{
literal|"execname"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_EXECNAME
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"string"
block|}
block|,
block|{
literal|"exit"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_EXIT
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(int)"
block|}
block|,
block|{
literal|"freopen"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_FREOPEN
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@, ...)"
block|}
block|,
block|{
literal|"ftruncate"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_FTRUNCATE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void()"
block|}
block|,
block|{
literal|"func"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_SYM
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"_symaddr(uintptr_t)"
block|}
block|,
block|{
literal|"getmajor"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_GETMAJOR
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"genunix`major_t(genunix`dev_t)"
block|}
block|,
block|{
literal|"getminor"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_GETMINOR
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"genunix`minor_t(genunix`dev_t)"
block|}
block|,
block|{
literal|"htonl"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_HTONL
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_3
block|,
operator|&
name|dt_idops_func
block|,
literal|"uint32_t(uint32_t)"
block|}
block|,
block|{
literal|"htonll"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_HTONLL
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_3
block|,
operator|&
name|dt_idops_func
block|,
literal|"uint64_t(uint64_t)"
block|}
block|,
block|{
literal|"htons"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_HTONS
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_3
block|,
operator|&
name|dt_idops_func
block|,
literal|"uint16_t(uint16_t)"
block|}
block|,
block|{
literal|"gid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_GID
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"gid_t"
block|}
block|,
block|{
literal|"id"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ID
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint_t"
block|}
block|,
block|{
literal|"index"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_INDEX
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(const char *, const char *, [int])"
block|}
block|,
block|{
literal|"inet_ntoa"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_INET_NTOA
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_5
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(ipaddr_t *)"
block|}
block|,
block|{
literal|"inet_ntoa6"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_INET_NTOA6
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_5
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(in6_addr_t *)"
block|}
block|,
block|{
literal|"inet_ntop"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_INET_NTOP
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_5
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(int, void *)"
block|}
block|,
block|{
literal|"ipl"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_IPL
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint_t"
block|}
block|,
block|{
literal|"jstack"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_JSTACK
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"stack(...)"
block|}
block|,
block|{
literal|"lltostr"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_LLTOSTR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(int64_t)"
block|}
block|,
block|{
literal|"lquantize"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_LQUANTIZE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@, int32_t, int32_t, ...)"
block|}
block|,
block|{
literal|"max"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_MAX
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@)"
block|}
block|,
block|{
literal|"min"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_MIN
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@)"
block|}
block|,
block|{
literal|"mod"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_MOD
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"_symaddr(uintptr_t)"
block|}
block|,
block|{
literal|"msgdsize"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_MSGDSIZE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"size_t(mblk_t *)"
block|}
block|,
block|{
literal|"msgsize"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_MSGSIZE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"size_t(mblk_t *)"
block|}
block|,
block|{
literal|"mutex_owned"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_MUTEX_OWNED
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(genunix`kmutex_t *)"
block|}
block|,
block|{
literal|"mutex_owner"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_MUTEX_OWNER
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"genunix`kthread_t *(genunix`kmutex_t *)"
block|}
block|,
block|{
literal|"mutex_type_adaptive"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_MUTEX_TYPE_ADAPTIVE
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(genunix`kmutex_t *)"
block|}
block|,
block|{
literal|"mutex_type_spin"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_MUTEX_TYPE_SPIN
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(genunix`kmutex_t *)"
block|}
block|,
block|{
literal|"ntohl"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_NTOHL
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_3
block|,
operator|&
name|dt_idops_func
block|,
literal|"uint32_t(uint32_t)"
block|}
block|,
block|{
literal|"ntohll"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_NTOHLL
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_3
block|,
operator|&
name|dt_idops_func
block|,
literal|"uint64_t(uint64_t)"
block|}
block|,
block|{
literal|"ntohs"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_NTOHS
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_3
block|,
operator|&
name|dt_idops_func
block|,
literal|"uint16_t(uint16_t)"
block|}
block|,
block|{
literal|"normalize"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_NORMALIZE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(...)"
block|}
block|,
block|{
literal|"panic"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_PANIC
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void()"
block|}
block|,
block|{
literal|"pid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_PID
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"pid_t"
block|}
block|,
block|{
literal|"ppid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_PPID
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"pid_t"
block|}
block|,
block|{
literal|"printa"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_PRINTA
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@, ...)"
block|}
block|,
block|{
literal|"printf"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_PRINTF
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@, ...)"
block|}
block|,
block|{
literal|"probefunc"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_PROBEFUNC
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"string"
block|}
block|,
block|{
literal|"probemod"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_PROBEMOD
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"string"
block|}
block|,
block|{
literal|"probename"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_PROBENAME
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"string"
block|}
block|,
block|{
literal|"probeprov"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_PROBEPROV
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"string"
block|}
block|,
block|{
literal|"progenyof"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_PROGENYOF
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(pid_t)"
block|}
block|,
block|{
literal|"quantize"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_QUANTIZE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@, ...)"
block|}
block|,
block|{
literal|"raise"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_RAISE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(int)"
block|}
block|,
block|{
literal|"rand"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_RAND
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int()"
block|}
block|,
block|{
literal|"rindex"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_RINDEX
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(const char *, const char *, [int])"
block|}
block|,
block|{
literal|"rw_iswriter"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_RW_ISWRITER
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(genunix`krwlock_t *)"
block|}
block|,
block|{
literal|"rw_read_held"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_RW_READ_HELD
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(genunix`krwlock_t *)"
block|}
block|,
block|{
literal|"rw_write_held"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_RW_WRITE_HELD
block|,
name|DT_ATTR_EVOLCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int(genunix`krwlock_t *)"
block|}
block|,
block|{
literal|"self"
block|,
name|DT_IDENT_PTR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"void"
block|}
block|,
block|{
literal|"setopt"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_SETOPT
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(const char *, [const char *])"
block|}
block|,
block|{
literal|"speculate"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_SPECULATE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(int)"
block|}
block|,
block|{
literal|"speculation"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_SPECULATION
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"int()"
block|}
block|,
block|{
literal|"stack"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_STACK
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"stack(...)"
block|}
block|,
block|{
literal|"stackdepth"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_STACKDEPTH
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint32_t"
block|}
block|,
block|{
literal|"stddev"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_STDDEV
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_6
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@)"
block|}
block|,
block|{
literal|"stop"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_STOP
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void()"
block|}
block|,
block|{
literal|"strchr"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_STRCHR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *, char)"
block|}
block|,
block|{
literal|"strlen"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_STRLEN
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"size_t(const char *)"
block|}
block|,
block|{
literal|"strjoin"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_STRJOIN
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *, const char *)"
block|}
block|,
block|{
literal|"strrchr"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_STRRCHR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *, char)"
block|}
block|,
block|{
literal|"strstr"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_STRSTR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *, const char *)"
block|}
block|,
block|{
literal|"strtok"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_STRTOK
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *, const char *)"
block|}
block|,
block|{
literal|"substr"
block|,
name|DT_IDENT_FUNC
block|,
literal|0
block|,
name|DIF_SUBR_SUBSTR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_1
block|,
operator|&
name|dt_idops_func
block|,
literal|"string(const char *, int, [int])"
block|}
block|,
block|{
literal|"sum"
block|,
name|DT_IDENT_AGGFUNC
block|,
literal|0
block|,
name|DTRACEAGG_SUM
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@)"
block|}
block|,
block|{
literal|"sym"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_SYM
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"_symaddr(uintptr_t)"
block|}
block|,
block|{
literal|"system"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_SYSTEM
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@, ...)"
block|}
block|,
block|{
literal|"this"
block|,
name|DT_IDENT_PTR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"void"
block|}
block|,
block|{
literal|"tid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_TID
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"id_t"
block|}
block|,
block|{
literal|"timestamp"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_TIMESTAMP
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint64_t"
block|}
block|,
block|{
literal|"trace"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_TRACE
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@)"
block|}
block|,
block|{
literal|"tracemem"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_TRACEMEM
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(@, size_t)"
block|}
block|,
block|{
literal|"trunc"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_TRUNC
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"void(...)"
block|}
block|,
block|{
literal|"uaddr"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_UADDR
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"_usymaddr(uintptr_t)"
block|}
block|,
block|{
literal|"ucaller"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_UCALLER
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint64_t"
block|}
block|,
block|{
literal|"ufunc"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_USYM
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"_usymaddr(uintptr_t)"
block|}
block|,
block|{
literal|"uid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_UID
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uid_t"
block|}
block|,
block|{
literal|"umod"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_UMOD
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"_usymaddr(uintptr_t)"
block|}
block|,
block|{
literal|"uregs"
block|,
name|DT_IDENT_ARRAY
block|,
literal|0
block|,
name|DIF_VAR_UREGS
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_regs
block|,
name|NULL
block|}
block|,
block|{
literal|"ustack"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_USTACK
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_func
block|,
literal|"stack(...)"
block|}
block|,
block|{
literal|"ustackdepth"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_USTACKDEPTH
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint32_t"
block|}
block|,
block|{
literal|"usym"
block|,
name|DT_IDENT_ACTFUNC
block|,
literal|0
block|,
name|DT_ACT_USYM
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_2
block|,
operator|&
name|dt_idops_func
block|,
literal|"_usymaddr(uintptr_t)"
block|}
block|,
block|{
literal|"vtimestamp"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_VTIMESTAMP
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"uint64_t"
block|}
block|,
block|{
literal|"walltimestamp"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_WALLTIMESTAMP
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"zonename"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
name|DIF_VAR_ZONENAME
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|,
operator|&
name|dt_idops_type
block|,
literal|"string"
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tables of ILP32 intrinsic integer and floating-point type templates to use  * to populate the dynamic "C" CTF type container.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_intrinsic_t
name|_dtrace_intrinsics_32
index|[]
init|=
block|{
block|{
literal|"void"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|0
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"char"
block|,
block|{
name|CTF_INT_SIGNED
operator||
name|CTF_INT_CHAR
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"short"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|16
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"int"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"long long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed char"
block|,
block|{
name|CTF_INT_SIGNED
operator||
name|CTF_INT_CHAR
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed short"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|16
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed int"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed long long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned char"
block|,
block|{
name|CTF_INT_CHAR
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned short"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|16
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned int"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned long"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned long long"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"_Bool"
block|,
block|{
name|CTF_INT_BOOL
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"float"
block|,
block|{
name|CTF_FP_SINGLE
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"double"
block|,
block|{
name|CTF_FP_DOUBLE
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"long double"
block|,
block|{
name|CTF_FP_LDOUBLE
block|,
literal|0
block|,
literal|128
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"float imaginary"
block|,
block|{
name|CTF_FP_IMAGRY
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"double imaginary"
block|,
block|{
name|CTF_FP_DIMAGRY
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"long double imaginary"
block|,
block|{
name|CTF_FP_LDIMAGRY
block|,
literal|0
block|,
literal|128
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"float complex"
block|,
block|{
name|CTF_FP_CPLX
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"double complex"
block|,
block|{
name|CTF_FP_DCPLX
block|,
literal|0
block|,
literal|128
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"long double complex"
block|,
block|{
name|CTF_FP_LDCPLX
block|,
literal|0
block|,
literal|256
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
name|NULL
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tables of LP64 intrinsic integer and floating-point type templates to use  * to populate the dynamic "C" CTF type container.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_intrinsic_t
name|_dtrace_intrinsics_64
index|[]
init|=
block|{
block|{
literal|"void"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|0
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"char"
block|,
block|{
name|CTF_INT_SIGNED
operator||
name|CTF_INT_CHAR
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"short"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|16
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"int"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"long long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed char"
block|,
block|{
name|CTF_INT_SIGNED
operator||
name|CTF_INT_CHAR
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed short"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|16
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed int"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"signed long long"
block|,
block|{
name|CTF_INT_SIGNED
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned char"
block|,
block|{
name|CTF_INT_CHAR
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned short"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|16
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned int"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned long"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"unsigned long long"
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"_Bool"
block|,
block|{
name|CTF_INT_BOOL
block|,
literal|0
block|,
literal|8
block|}
block|,
name|CTF_K_INTEGER
block|}
block|,
block|{
literal|"float"
block|,
block|{
name|CTF_FP_SINGLE
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"double"
block|,
block|{
name|CTF_FP_DOUBLE
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"long double"
block|,
block|{
name|CTF_FP_LDOUBLE
block|,
literal|0
block|,
literal|128
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"float imaginary"
block|,
block|{
name|CTF_FP_IMAGRY
block|,
literal|0
block|,
literal|32
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"double imaginary"
block|,
block|{
name|CTF_FP_DIMAGRY
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"long double imaginary"
block|,
block|{
name|CTF_FP_LDIMAGRY
block|,
literal|0
block|,
literal|128
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"float complex"
block|,
block|{
name|CTF_FP_CPLX
block|,
literal|0
block|,
literal|64
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"double complex"
block|,
block|{
name|CTF_FP_DCPLX
block|,
literal|0
block|,
literal|128
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
literal|"long double complex"
block|,
block|{
name|CTF_FP_LDCPLX
block|,
literal|0
block|,
literal|256
block|}
block|,
name|CTF_K_FLOAT
block|}
block|,
block|{
name|NULL
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tables of ILP32 typedefs to use to populate the dynamic "D" CTF container.  * These aliases ensure that D definitions can use typical<sys/types.h> names.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_typedef_t
name|_dtrace_typedefs_32
index|[]
init|=
block|{
block|{
literal|"char"
block|,
literal|"int8_t"
block|}
block|,
block|{
literal|"short"
block|,
literal|"int16_t"
block|}
block|,
block|{
literal|"int"
block|,
literal|"int32_t"
block|}
block|,
block|{
literal|"long long"
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"int"
block|,
literal|"intptr_t"
block|}
block|,
block|{
literal|"int"
block|,
literal|"ssize_t"
block|}
block|,
block|{
literal|"unsigned char"
block|,
literal|"uint8_t"
block|}
block|,
block|{
literal|"unsigned short"
block|,
literal|"uint16_t"
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|"uint32_t"
block|}
block|,
block|{
literal|"unsigned long long"
block|,
literal|"uint64_t"
block|}
block|,
block|{
literal|"unsigned char"
block|,
literal|"uchar_t"
block|}
block|,
block|{
literal|"unsigned short"
block|,
literal|"ushort_t"
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|"uint_t"
block|}
block|,
block|{
literal|"unsigned long"
block|,
literal|"ulong_t"
block|}
block|,
block|{
literal|"unsigned long long"
block|,
literal|"u_longlong_t"
block|}
block|,
block|{
literal|"int"
block|,
literal|"ptrdiff_t"
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|"uintptr_t"
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|"size_t"
block|}
block|,
block|{
literal|"long"
block|,
literal|"id_t"
block|}
block|,
block|{
literal|"long"
block|,
literal|"pid_t"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tables of LP64 typedefs to use to populate the dynamic "D" CTF container.  * These aliases ensure that D definitions can use typical<sys/types.h> names.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_typedef_t
name|_dtrace_typedefs_64
index|[]
init|=
block|{
block|{
literal|"char"
block|,
literal|"int8_t"
block|}
block|,
block|{
literal|"short"
block|,
literal|"int16_t"
block|}
block|,
block|{
literal|"int"
block|,
literal|"int32_t"
block|}
block|,
block|{
literal|"long"
block|,
literal|"int64_t"
block|}
block|,
block|{
literal|"long"
block|,
literal|"intptr_t"
block|}
block|,
block|{
literal|"long"
block|,
literal|"ssize_t"
block|}
block|,
block|{
literal|"unsigned char"
block|,
literal|"uint8_t"
block|}
block|,
block|{
literal|"unsigned short"
block|,
literal|"uint16_t"
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|"uint32_t"
block|}
block|,
block|{
literal|"unsigned long"
block|,
literal|"uint64_t"
block|}
block|,
block|{
literal|"unsigned char"
block|,
literal|"uchar_t"
block|}
block|,
block|{
literal|"unsigned short"
block|,
literal|"ushort_t"
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|"uint_t"
block|}
block|,
block|{
literal|"unsigned long"
block|,
literal|"ulong_t"
block|}
block|,
block|{
literal|"unsigned long long"
block|,
literal|"u_longlong_t"
block|}
block|,
block|{
literal|"long"
block|,
literal|"ptrdiff_t"
block|}
block|,
block|{
literal|"unsigned long"
block|,
literal|"uintptr_t"
block|}
block|,
block|{
literal|"unsigned long"
block|,
literal|"size_t"
block|}
block|,
block|{
literal|"int"
block|,
literal|"id_t"
block|}
block|,
block|{
literal|"int"
block|,
literal|"pid_t"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tables of ILP32 integer type templates used to populate the dtp->dt_ints[]  * cache when a new dtrace client open occurs.  Values are set by dtrace_open().  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_intdesc_t
name|_dtrace_ints_32
index|[]
init|=
block|{
block|{
literal|"int"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0x7fffffffULL
block|}
block|,
block|{
literal|"unsigned int"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0xffffffffULL
block|}
block|,
block|{
literal|"long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0x7fffffffULL
block|}
block|,
block|{
literal|"unsigned long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0xffffffffULL
block|}
block|,
block|{
literal|"long long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0x7fffffffffffffffULL
block|}
block|,
block|{
literal|"unsigned long long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0xffffffffffffffffULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tables of LP64 integer type templates used to populate the dtp->dt_ints[]  * cache when a new dtrace client open occurs.  Values are set by dtrace_open().  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_intdesc_t
name|_dtrace_ints_64
index|[]
init|=
block|{
block|{
literal|"int"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0x7fffffffULL
block|}
block|,
block|{
literal|"unsigned int"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0xffffffffULL
block|}
block|,
block|{
literal|"long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0x7fffffffffffffffULL
block|}
block|,
block|{
literal|"unsigned long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0xffffffffffffffffULL
block|}
block|,
block|{
literal|"long long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0x7fffffffffffffffULL
block|}
block|,
block|{
literal|"unsigned long long"
block|,
name|NULL
block|,
name|CTF_ERR
block|,
literal|0xffffffffffffffffULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of macro variable templates used to populate the macro identifier hash  * when a new dtrace client open occurs.  Values are set by dtrace_update().  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dt_ident_t
name|_dtrace_macros
index|[]
init|=
block|{
block|{
literal|"egid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"euid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"gid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"pid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"pgid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"ppid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"projid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"sid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"taskid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"target"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
literal|"uid"
block|,
name|DT_IDENT_SCALAR
block|,
literal|0
block|,
literal|0
block|,
name|DT_ATTR_STABCMN
block|,
name|DT_VERS_1_0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hard-wired definition string to be compiled and cached every time a new  * DTrace library handle is initialized.  This string should only be used to  * contain definitions that should be present regardless of DTRACE_O_NOLIBS.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|_dtrace_hardwire
index|[]
init|=
literal|"\ inline long NULL = 0; \n\ #pragma D binding \"1.0\" NULL\n\ "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default DTrace configuration to use when opening libdtrace DTRACE_O_NODEV.  * If DTRACE_O_NODEV is not set, we load the configuration from the kernel.  * The use of CTF_MODEL_NATIVE is more subtle than it might appear: we are  * relying on the fact that when running dtrace(1M), isaexec will invoke the  * binary with the same bitness as the kernel, which is what we want by default  * when generating our DIF.  The user can override the choice using oflags.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|dtrace_conf_t
name|_dtrace_conf
init|=
block|{
name|DIF_VERSION
block|,
comment|/* dtc_difversion */
name|DIF_DIR_NREGS
block|,
comment|/* dtc_difintregs */
name|DIF_DTR_NREGS
block|,
comment|/* dtc_diftupregs */
name|CTF_MODEL_NATIVE
comment|/* dtc_ctfmodel */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dtrace_attribute_t
name|_dtrace_maxattr
init|=
block|{
name|DTRACE_STABILITY_MAX
block|,
name|DTRACE_STABILITY_MAX
block|,
name|DTRACE_CLASS_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dtrace_attribute_t
name|_dtrace_defattr
init|=
block|{
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dtrace_attribute_t
name|_dtrace_symattr
init|=
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dtrace_attribute_t
name|_dtrace_typattr
init|=
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dtrace_attribute_t
name|_dtrace_prvattr
init|=
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dtrace_pattr_t
name|_dtrace_prvdesc
init|=
block|{
block|{
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_dtrace_defcpp
init|=
literal|"/usr/ccs/lib/cpp"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default cpp(1) to invoke */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_dtrace_defld
init|=
literal|"/usr/ccs/bin/ld"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default ld(1) to invoke */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_dtrace_libdir
init|=
literal|"/usr/lib/dtrace"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default library directory */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_dtrace_provdir
init|=
literal|"/dev/dtrace/provider"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* provider directory */
end_comment

begin_decl_stmt
name|int
name|_dtrace_strbuckets
init|=
literal|211
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default number of hash buckets (prime) */
end_comment

begin_decl_stmt
name|int
name|_dtrace_intbuckets
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default number of integer buckets (Pof2) */
end_comment

begin_decl_stmt
name|uint_t
name|_dtrace_strsize
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default size of string intrinsic type */
end_comment

begin_decl_stmt
name|uint_t
name|_dtrace_stkindent
init|=
literal|14
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default whitespace indent for stack/ustack */
end_comment

begin_decl_stmt
name|uint_t
name|_dtrace_pidbuckets
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default number of pid hash buckets */
end_comment

begin_decl_stmt
name|uint_t
name|_dtrace_pidlrulim
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default number of pid handles to cache */
end_comment

begin_decl_stmt
name|size_t
name|_dtrace_bufsize
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default dt_buf_create() size */
end_comment

begin_decl_stmt
name|int
name|_dtrace_argmax
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default maximum number of probe arguments */
end_comment

begin_decl_stmt
name|int
name|_dtrace_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug messages enabled (off) */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|_dtrace_version
init|=
name|DT_VERS_STRING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* API version string */
end_comment

begin_decl_stmt
name|int
name|_dtrace_rdvers
init|=
name|RD_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rtld_db feature version */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dt_fdlist
block|{
name|int
modifier|*
name|df_fds
decl_stmt|;
comment|/* array of provider driver file descriptors */
name|uint_t
name|df_ents
decl_stmt|;
comment|/* number of valid elements in df_fds[] */
name|uint_t
name|df_size
decl_stmt|;
comment|/* size of df_fds[] */
block|}
name|dt_fdlist_t
typedef|;
end_typedef

begin_pragma
pragma|#
directive|pragma
name|init
name|(
name|_dtrace_init
name|)
end_pragma

begin_function
name|void
name|_dtrace_init
parameter_list|(
name|void
parameter_list|)
block|{
name|_dtrace_debug
operator|=
name|getenv
argument_list|(
literal|"DTRACE_DEBUG"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|_dtrace_rdvers
operator|>
literal|0
condition|;
name|_dtrace_rdvers
operator|--
control|)
block|{
if|if
condition|(
name|rd_init
argument_list|(
name|_dtrace_rdvers
argument_list|)
operator|==
name|RD_OK
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|dtrace_hdl_t
modifier|*
name|set_open_errno
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|,
name|int
name|err
parameter_list|)
block|{
if|if
condition|(
name|dtp
operator|!=
name|NULL
condition|)
name|dtrace_close
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errp
operator|!=
name|NULL
condition|)
operator|*
name|errp
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_provmod_open
parameter_list|(
name|dt_provmod_t
modifier|*
modifier|*
name|provmod
parameter_list|,
name|dt_fdlist_t
modifier|*
name|dfp
parameter_list|)
block|{
name|dt_provmod_t
modifier|*
name|prov
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|_dtrace_provdir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* failed to open directory; just skip it */
name|ep
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
operator|+
name|PATH_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
operator|+
name|PATH_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|readdir_r
argument_list|(
name|dirp
argument_list|,
name|ep
argument_list|,
operator|&
name|dp
argument_list|)
operator|==
literal|0
operator|&&
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
comment|/* skip "." and ".." */
if|if
condition|(
name|dfp
operator|->
name|df_ents
operator|==
name|dfp
operator|->
name|df_size
condition|)
block|{
name|uint_t
name|size
init|=
name|dfp
operator|->
name|df_size
condition|?
name|dfp
operator|->
name|df_size
operator|*
literal|2
else|:
literal|16
decl_stmt|;
name|int
modifier|*
name|fds
init|=
name|realloc
argument_list|(
name|dfp
operator|->
name|df_fds
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
break|break;
comment|/* skip the rest of this directory */
name|dfp
operator|->
name|df_fds
operator|=
name|fds
expr_stmt|;
name|dfp
operator|->
name|df_size
operator|=
name|size
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|_dtrace_provdir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* failed to open driver; just skip it */
if|if
condition|(
operator|(
operator|(
name|prov
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dt_provmod_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|prov
operator|->
name|dp_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|prov
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prov
operator|->
name|dp_name
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|prov
operator|->
name|dp_next
operator|=
operator|*
name|provmod
expr_stmt|;
operator|*
name|provmod
operator|=
name|prov
expr_stmt|;
name|dt_dprintf
argument_list|(
literal|"opened provider %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|dfp
operator|->
name|df_fds
index|[
name|dfp
operator|->
name|df_ents
operator|++
index|]
operator|=
name|fd
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_provmod_destroy
parameter_list|(
name|dt_provmod_t
modifier|*
modifier|*
name|provmod
parameter_list|)
block|{
name|dt_provmod_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|current
decl_stmt|;
for|for
control|(
name|current
operator|=
operator|*
name|provmod
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|next
control|)
block|{
name|next
operator|=
name|current
operator|->
name|dp_next
expr_stmt|;
name|free
argument_list|(
name|current
operator|->
name|dp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
operator|*
name|provmod
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dt_get_sysinfo
parameter_list|(
name|int
name|cmd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|ssize_t
name|rv
init|=
name|sysinfo
argument_list|(
name|cmd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
operator|||
name|rv
operator|>
name|len
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s"
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dtrace_hdl_t
modifier|*
name|dt_vopen
parameter_list|(
name|int
name|version
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|,
specifier|const
name|dtrace_vector_t
modifier|*
name|vector
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|NULL
decl_stmt|;
name|int
name|dtfd
init|=
operator|-
literal|1
decl_stmt|,
name|ftfd
init|=
operator|-
literal|1
decl_stmt|,
name|fterr
init|=
literal|0
decl_stmt|;
name|dtrace_prog_t
modifier|*
name|pgp
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|dt_provmod_t
modifier|*
name|provmod
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|rlimit
name|rl
decl_stmt|;
specifier|const
name|dt_intrinsic_t
modifier|*
name|dinp
decl_stmt|;
specifier|const
name|dt_typedef_t
modifier|*
name|dtyp
decl_stmt|;
specifier|const
name|dt_ident_t
modifier|*
name|idp
decl_stmt|;
name|dtrace_typeinfo_t
name|dtt
decl_stmt|;
name|ctf_funcinfo_t
name|ctc
decl_stmt|;
name|ctf_arinfo_t
name|ctr
decl_stmt|;
name|dt_fdlist_t
name|df
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|char
name|isadef
index|[
literal|32
index|]
decl_stmt|,
name|utsdef
index|[
literal|32
index|]
decl_stmt|;
name|char
name|s1
index|[
literal|64
index|]
decl_stmt|,
name|s2
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|version
operator|<=
literal|0
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|version
operator|>
name|DTRACE_VERSION
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_VERSION
argument_list|)
operator|)
return|;
if|if
condition|(
name|version
operator|<
name|DTRACE_VERSION
condition|)
block|{
comment|/* 		 * Currently, increasing the library version number is used to 		 * denote a binary incompatible change.  That is, a consumer 		 * of the library cannot run on a version of the library with 		 * a higher DTRACE_VERSION number than the consumer compiled 		 * against.  Once the library API has been committed to, 		 * backwards binary compatibility will be required; at that 		 * time, this check should change to return EDT_OVERSION only 		 * if the specified version number is less than the version 		 * number at the time of interface commitment. 		 */
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_OVERSION
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
operator|~
name|DTRACE_O_MASK
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DTRACE_O_LP64
operator|)
operator|&&
operator|(
name|flags
operator|&
name|DTRACE_O_ILP32
operator|)
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|vector
operator|==
name|NULL
operator|&&
name|arg
operator|!=
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|==
name|EV_NONE
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_ELFVERSION
argument_list|)
operator|)
return|;
if|if
condition|(
name|vector
operator|!=
name|NULL
operator|||
operator|(
name|flags
operator|&
name|DTRACE_O_NODEV
operator|)
condition|)
goto|goto
name|alloc
goto|;
comment|/* do not attempt to open dtrace device */
comment|/* 	 * Before we get going, crank our limit on file descriptors up to the 	 * hard limit.  This is to allow for the fact that libproc keeps file 	 * descriptors to objects open for the lifetime of the proc handle; 	 * without raising our hard limit, we would have an acceptably small 	 * bound on the number of processes that we could concurrently 	 * instrument with the pid provider. 	 */
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rl
operator|.
name|rlim_cur
operator|=
name|rl
operator|.
name|rlim_max
expr_stmt|;
operator|(
name|void
operator|)
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|rl
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get the device path of each of the providers.  We hold them open 	 * in the df.df_fds list until we open the DTrace driver itself, 	 * allowing us to see all of the probes provided on this system.  Once 	 * we have the DTrace driver open, we can safely close all the providers 	 * now that they have registered with the framework. 	 */
name|dt_provmod_open
argument_list|(
operator|&
name|provmod
argument_list|,
operator|&
name|df
argument_list|)
expr_stmt|;
name|dtfd
operator|=
name|open
argument_list|(
literal|"/dev/dtrace/dtrace"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|err
operator|=
name|errno
expr_stmt|;
comment|/* save errno from opening dtfd */
name|ftfd
operator|=
name|open
argument_list|(
literal|"/dev/dtrace/provider/fasttrap"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|fterr
operator|=
name|ftfd
operator|==
operator|-
literal|1
condition|?
name|errno
else|:
literal|0
expr_stmt|;
comment|/* save errno from open ftfd */
while|while
condition|(
name|df
operator|.
name|df_ents
operator|--
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|df
operator|.
name|df_fds
index|[
name|df
operator|.
name|df_ents
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
operator|.
name|df_fds
argument_list|)
expr_stmt|;
comment|/* 	 * If we failed to open the dtrace device, fail dtrace_open(). 	 * We convert some kernel errnos to custom libdtrace errnos to 	 * improve the resulting message from the usual strerror(). 	 */
if|if
condition|(
name|dtfd
operator|==
operator|-
literal|1
condition|)
block|{
name|dt_provmod_destroy
argument_list|(
operator|&
name|provmod
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|ENOENT
case|:
name|err
operator|=
name|EDT_NOENT
expr_stmt|;
break|break;
case|case
name|EBUSY
case|:
name|err
operator|=
name|EDT_BUSY
expr_stmt|;
break|break;
case|case
name|EACCES
case|:
name|err
operator|=
name|EDT_ACCESS
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|err
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|dtfd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|ftfd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
name|alloc
label|:
if|if
condition|(
operator|(
name|dtp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_hdl_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_hdl_t
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_oflags
operator|=
name|flags
expr_stmt|;
name|dtp
operator|->
name|dt_prcmode
operator|=
name|DT_PROC_STOP_PREINIT
expr_stmt|;
name|dtp
operator|->
name|dt_linkmode
operator|=
name|DT_LINK_KERNEL
expr_stmt|;
name|dtp
operator|->
name|dt_linktype
operator|=
name|DT_LTYP_ELF
expr_stmt|;
name|dtp
operator|->
name|dt_xlatemode
operator|=
name|DT_XL_STATIC
expr_stmt|;
name|dtp
operator|->
name|dt_stdcmode
operator|=
name|DT_STDC_XA
expr_stmt|;
name|dtp
operator|->
name|dt_version
operator|=
name|version
expr_stmt|;
name|dtp
operator|->
name|dt_fd
operator|=
name|dtfd
expr_stmt|;
name|dtp
operator|->
name|dt_ftfd
operator|=
name|ftfd
expr_stmt|;
name|dtp
operator|->
name|dt_fterr
operator|=
name|fterr
expr_stmt|;
name|dtp
operator|->
name|dt_cdefs_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|dtp
operator|->
name|dt_ddefs_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|dtp
operator|->
name|dt_stdout_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|dtp
operator|->
name|dt_modbuckets
operator|=
name|_dtrace_strbuckets
expr_stmt|;
name|dtp
operator|->
name|dt_mods
operator|=
name|calloc
argument_list|(
name|dtp
operator|->
name|dt_modbuckets
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_module_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_provbuckets
operator|=
name|_dtrace_strbuckets
expr_stmt|;
name|dtp
operator|->
name|dt_provs
operator|=
name|calloc
argument_list|(
name|dtp
operator|->
name|dt_provbuckets
argument_list|,
sizeof|sizeof
argument_list|(
name|dt_provider_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dt_proc_hash_create
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_vmax
operator|=
name|DT_VERS_LATEST
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_path
operator|=
name|strdup
argument_list|(
name|_dtrace_defcpp
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_argv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_argc
operator|=
literal|1
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_args
operator|=
literal|1
expr_stmt|;
name|dtp
operator|->
name|dt_ld_path
operator|=
name|strdup
argument_list|(
name|_dtrace_defld
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_provmod
operator|=
name|provmod
expr_stmt|;
name|dtp
operator|->
name|dt_vector
operator|=
name|vector
expr_stmt|;
name|dtp
operator|->
name|dt_varg
operator|=
name|arg
expr_stmt|;
name|dt_dof_init
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|uname
argument_list|(
operator|&
name|dtp
operator|->
name|dt_uts
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_mods
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_provs
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_procs
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_ld_path
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_cpp_path
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_cpp_argv
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACEOPT_MAX
condition|;
name|i
operator|++
control|)
name|dtp
operator|->
name|dt_options
index|[
name|i
index|]
operator|=
name|DTRACEOPT_UNSET
expr_stmt|;
name|dtp
operator|->
name|dt_cpp_argv
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|strbasename
argument_list|(
name|dtp
operator|->
name|dt_cpp_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|isadef
argument_list|,
sizeof|sizeof
argument_list|(
name|isadef
argument_list|)
argument_list|,
literal|"-D__SUNW_D_%u"
argument_list|,
call|(
name|uint_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|NBBY
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|utsdef
argument_list|,
sizeof|sizeof
argument_list|(
name|utsdef
argument_list|)
argument_list|,
literal|"-D__%s_%s"
argument_list|,
name|dt_get_sysinfo
argument_list|(
name|SI_SYSNAME
argument_list|,
name|s1
argument_list|,
sizeof|sizeof
argument_list|(
name|s1
argument_list|)
argument_list|)
argument_list|,
name|dt_get_sysinfo
argument_list|(
name|SI_RELEASE
argument_list|,
name|s2
argument_list|,
sizeof|sizeof
argument_list|(
name|s2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__sun"
argument_list|)
operator|==
name|NULL
operator|||
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__unix"
argument_list|)
operator|==
name|NULL
operator|||
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__SVR4"
argument_list|)
operator|==
name|NULL
operator|||
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__SUNW_D=1"
argument_list|)
operator|==
name|NULL
operator|||
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
name|isadef
argument_list|)
operator|==
name|NULL
operator|||
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
name|utsdef
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|DTRACE_O_NODEV
condition|)
name|bcopy
argument_list|(
operator|&
name|_dtrace_conf
argument_list|,
operator|&
name|dtp
operator|->
name|dt_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|_dtrace_conf
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_CONF
argument_list|,
operator|&
name|dtp
operator|->
name|dt_conf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|DTRACE_O_LP64
condition|)
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|=
name|CTF_MODEL_LP64
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DTRACE_O_ILP32
condition|)
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|=
name|CTF_MODEL_ILP32
expr_stmt|;
ifdef|#
directive|ifdef
name|__sparc
comment|/* 	 * On SPARC systems, __sparc is always defined for<sys/isa_defs.h> 	 * and __sparcv9 is defined if we are doing a 64-bit compile. 	 */
if|if
condition|(
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__sparc"
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|==
name|CTF_MODEL_LP64
operator|&&
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__sparcv9"
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__x86
comment|/* 	 * On x86 systems, __i386 is defined for<sys/isa_defs.h> for 32-bit 	 * compiles and __amd64 is defined for 64-bit compiles.  Unlike SPARC, 	 * they are defined exclusive of one another (see PSARC 2004/619). 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|==
name|CTF_MODEL_LP64
condition|)
block|{
if|if
condition|(
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__amd64"
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|dt_cpp_add_arg
argument_list|(
name|dtp
argument_list|,
literal|"-D__i386"
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_difversion
operator|<
name|DIF_VERSION
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_DIFVERS
argument_list|)
operator|)
return|;
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|==
name|CTF_MODEL_ILP32
condition|)
name|bcopy
argument_list|(
name|_dtrace_ints_32
argument_list|,
name|dtp
operator|->
name|dt_ints
argument_list|,
sizeof|sizeof
argument_list|(
name|_dtrace_ints_32
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|_dtrace_ints_64
argument_list|,
name|dtp
operator|->
name|dt_ints
argument_list|,
sizeof|sizeof
argument_list|(
name|_dtrace_ints_64
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_macros
operator|=
name|dt_idhash_create
argument_list|(
literal|"macro"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|UINT_MAX
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_aggs
operator|=
name|dt_idhash_create
argument_list|(
literal|"aggregation"
argument_list|,
name|NULL
argument_list|,
name|DTRACE_AGGVARIDNONE
operator|+
literal|1
argument_list|,
name|UINT_MAX
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_globals
operator|=
name|dt_idhash_create
argument_list|(
literal|"global"
argument_list|,
name|_dtrace_globals
argument_list|,
name|DIF_VAR_OTHER_UBASE
argument_list|,
name|DIF_VAR_OTHER_MAX
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_tls
operator|=
name|dt_idhash_create
argument_list|(
literal|"thread local"
argument_list|,
name|NULL
argument_list|,
name|DIF_VAR_OTHER_UBASE
argument_list|,
name|DIF_VAR_OTHER_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_macros
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_aggs
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_globals
operator|==
name|NULL
operator|||
name|dtp
operator|->
name|dt_tls
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
comment|/* 	 * Populate the dt_macros identifier hash table by hand: we can't use 	 * the dt_idhash_populate() mechanism because we're not yet compiling 	 * and dtrace_update() needs to immediately reference these idents. 	 */
for|for
control|(
name|idp
operator|=
name|_dtrace_macros
init|;
name|idp
operator|->
name|di_name
operator|!=
name|NULL
condition|;
name|idp
operator|++
control|)
block|{
if|if
condition|(
name|dt_idhash_insert
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|,
name|idp
operator|->
name|di_name
argument_list|,
name|idp
operator|->
name|di_kind
argument_list|,
name|idp
operator|->
name|di_flags
argument_list|,
name|idp
operator|->
name|di_id
argument_list|,
name|idp
operator|->
name|di_attr
argument_list|,
name|idp
operator|->
name|di_vers
argument_list|,
name|idp
operator|->
name|di_ops
condition|?
name|idp
operator|->
name|di_ops
else|:
operator|&
name|dt_idops_thaw
argument_list|,
name|idp
operator|->
name|di_iarg
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Update the module list using /system/object and load the values for 	 * the macro variable definitions according to the current process. 	 */
name|dtrace_update
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
comment|/* 	 * Select the intrinsics and typedefs we want based on the data model. 	 * The intrinsics are under "C".  The typedefs are added under "D". 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
operator|==
name|CTF_MODEL_ILP32
condition|)
block|{
name|dinp
operator|=
name|_dtrace_intrinsics_32
expr_stmt|;
name|dtyp
operator|=
name|_dtrace_typedefs_32
expr_stmt|;
block|}
else|else
block|{
name|dinp
operator|=
name|_dtrace_intrinsics_64
expr_stmt|;
name|dtyp
operator|=
name|_dtrace_typedefs_64
expr_stmt|;
block|}
comment|/* 	 * Create a dynamic CTF container under the "C" scope for intrinsic 	 * types and types defined in ANSI-C header files that are included. 	 */
if|if
condition|(
operator|(
name|dmp
operator|=
name|dtp
operator|->
name|dt_cdefs
operator|=
name|dt_module_create
argument_list|(
name|dtp
argument_list|,
literal|"C"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|dmp
operator|->
name|dm_ctfp
operator|=
name|ctf_create
argument_list|(
operator|&
name|dtp
operator|->
name|dt_ctferr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
name|dt_dprintf
argument_list|(
literal|"created CTF container for %s (%p)\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_setmodel
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
argument_list|)
expr_stmt|;
name|ctf_setspecific
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_flags
operator|=
name|DT_DM_LOADED
expr_stmt|;
comment|/* fake up loaded bit */
name|dmp
operator|->
name|dm_modid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no module ID */
comment|/* 	 * Fill the dynamic "C" CTF container with all of the intrinsic 	 * integer and floating-point types appropriate for this data model. 	 */
for|for
control|(
init|;
name|dinp
operator|->
name|din_name
operator|!=
name|NULL
condition|;
name|dinp
operator|++
control|)
block|{
if|if
condition|(
name|dinp
operator|->
name|din_kind
operator|==
name|CTF_K_INTEGER
condition|)
block|{
name|err
operator|=
name|ctf_add_integer
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|dinp
operator|->
name|din_name
argument_list|,
operator|&
name|dinp
operator|->
name|din_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|ctf_add_float
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|dinp
operator|->
name|din_name
argument_list|,
operator|&
name|dinp
operator|->
name|din_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|CTF_ERR
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to add %s to C container: %s\n"
argument_list|,
name|dinp
operator|->
name|din_name
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ctf_update
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to update C container: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Add intrinsic pointer types that are needed to initialize printf 	 * format dictionary types (see table in dt_printf.c). 	 */
operator|(
name|void
operator|)
name|ctf_add_pointer
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"void"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_add_pointer
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"char"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_add_pointer
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"int"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctf_update
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to update C container: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Create a dynamic CTF container under the "D" scope for types that 	 * are defined by the D program itself or on-the-fly by the D compiler. 	 * The "D" CTF container is a child of the "C" CTF container. 	 */
if|if
condition|(
operator|(
name|dmp
operator|=
name|dtp
operator|->
name|dt_ddefs
operator|=
name|dt_module_create
argument_list|(
name|dtp
argument_list|,
literal|"D"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_NOMEM
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|dmp
operator|->
name|dm_ctfp
operator|=
name|ctf_create
argument_list|(
operator|&
name|dtp
operator|->
name|dt_ctferr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
name|dt_dprintf
argument_list|(
literal|"created CTF container for %s (%p)\n"
argument_list|,
name|dmp
operator|->
name|dm_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dmp
operator|->
name|dm_ctfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ctf_setmodel
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dtp
operator|->
name|dt_conf
operator|.
name|dtc_ctfmodel
argument_list|)
expr_stmt|;
name|ctf_setspecific
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
name|dmp
operator|->
name|dm_flags
operator|=
name|DT_DM_LOADED
expr_stmt|;
comment|/* fake up loaded bit */
name|dmp
operator|->
name|dm_modid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no module ID */
if|if
condition|(
name|ctf_import
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dtp
operator|->
name|dt_cdefs
operator|->
name|dm_ctfp
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to import D parent container: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Fill the dynamic "D" CTF container with all of the built-in typedefs 	 * that we need to use for our D variable and function definitions. 	 * This ensures that basic inttypes.h names are always available to us. 	 */
for|for
control|(
init|;
name|dtyp
operator|->
name|dty_src
operator|!=
name|NULL
condition|;
name|dtyp
operator|++
control|)
block|{
if|if
condition|(
name|ctf_add_typedef
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|dtyp
operator|->
name|dty_dst
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|dtyp
operator|->
name|dty_src
argument_list|)
argument_list|)
operator|==
name|CTF_ERR
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to add typedef %s %s to D "
literal|"container: %s"
argument_list|,
name|dtyp
operator|->
name|dty_src
argument_list|,
name|dtyp
operator|->
name|dty_dst
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * Insert a CTF ID corresponding to a pointer to a type of kind 	 * CTF_K_FUNCTION we can use in the compiler for function pointers. 	 * CTF treats all function pointers as "int (*)()" so we only need one. 	 */
name|ctc
operator|.
name|ctc_return
operator|=
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
name|ctc
operator|.
name|ctc_argc
operator|=
literal|0
expr_stmt|;
name|ctc
operator|.
name|ctc_flags
operator|=
literal|0
expr_stmt|;
name|dtp
operator|->
name|dt_type_func
operator|=
name|ctf_add_function
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
operator|&
name|ctc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_type_fptr
operator|=
name|ctf_add_pointer
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
name|dtp
operator|->
name|dt_type_func
argument_list|)
expr_stmt|;
comment|/* 	 * We also insert CTF definitions for the special D intrinsic types 	 * string and<DYN> into the D container.  The string type is added 	 * as a typedef of char[n].  The<DYN> type is an alias for void. 	 * We compare types to these special CTF ids throughout the compiler. 	 */
name|ctr
operator|.
name|ctr_contents
operator|=
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
name|ctr
operator|.
name|ctr_index
operator|=
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
name|ctr
operator|.
name|ctr_nelems
operator|=
name|_dtrace_strsize
expr_stmt|;
name|dtp
operator|->
name|dt_type_str
operator|=
name|ctf_add_typedef
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
literal|"string"
argument_list|,
name|ctf_add_array
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
operator|&
name|ctr
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_type_dyn
operator|=
name|ctf_add_typedef
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
literal|"<DYN>"
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"void"
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_type_stack
operator|=
name|ctf_add_typedef
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
literal|"stack"
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"void"
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_type_symaddr
operator|=
name|ctf_add_typedef
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
literal|"_symaddr"
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"void"
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_type_usymaddr
operator|=
name|ctf_add_typedef
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
name|CTF_ADD_ROOT
argument_list|,
literal|"_usymaddr"
argument_list|,
name|ctf_lookup_by_name
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|,
literal|"void"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_type_func
operator|==
name|CTF_ERR
operator|||
name|dtp
operator|->
name|dt_type_fptr
operator|==
name|CTF_ERR
operator|||
name|dtp
operator|->
name|dt_type_str
operator|==
name|CTF_ERR
operator|||
name|dtp
operator|->
name|dt_type_dyn
operator|==
name|CTF_ERR
operator|||
name|dtp
operator|->
name|dt_type_stack
operator|==
name|CTF_ERR
operator|||
name|dtp
operator|->
name|dt_type_symaddr
operator|==
name|CTF_ERR
operator|||
name|dtp
operator|->
name|dt_type_usymaddr
operator|==
name|CTF_ERR
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to add intrinsic to D container: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ctf_update
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed update D container: %s\n"
argument_list|,
name|ctf_errmsg
argument_list|(
name|ctf_errno
argument_list|(
name|dmp
operator|->
name|dm_ctfp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_CTF
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Initialize the integer description table used to convert integer 	 * constants to the appropriate types.  Refer to the comments above 	 * dt_node_int() for a complete description of how this table is used. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_ints
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_ints
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtrace_lookup_by_type
argument_list|(
name|dtp
argument_list|,
name|DTRACE_OBJ_EVERY
argument_list|,
name|dtp
operator|->
name|dt_ints
index|[
name|i
index|]
operator|.
name|did_name
argument_list|,
operator|&
name|dtt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to lookup integer type %s: %s\n"
argument_list|,
name|dtp
operator|->
name|dt_ints
index|[
name|i
index|]
operator|.
name|did_name
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|dtp
operator|->
name|dt_errno
argument_list|)
operator|)
return|;
block|}
name|dtp
operator|->
name|dt_ints
index|[
name|i
index|]
operator|.
name|did_ctfp
operator|=
name|dtt
operator|.
name|dtt_ctfp
expr_stmt|;
name|dtp
operator|->
name|dt_ints
index|[
name|i
index|]
operator|.
name|did_type
operator|=
name|dtt
operator|.
name|dtt_type
expr_stmt|;
block|}
comment|/* 	 * Now that we've created the "C" and "D" containers, move them to the 	 * start of the module list so that these types and symbols are found 	 * first (for stability) when iterating through the module list. 	 */
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dtp
operator|->
name|dt_ddefs
argument_list|)
expr_stmt|;
name|dt_list_prepend
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dtp
operator|->
name|dt_ddefs
argument_list|)
expr_stmt|;
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dtp
operator|->
name|dt_cdefs
argument_list|)
expr_stmt|;
name|dt_list_prepend
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|,
name|dtp
operator|->
name|dt_cdefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_pfdict_create
argument_list|(
name|dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|dtp
operator|->
name|dt_errno
argument_list|)
operator|)
return|;
comment|/* 	 * If we are opening libdtrace DTRACE_O_NODEV enable C_ZDEFS by default 	 * because without /dev/dtrace open, we will not be able to load the 	 * names and attributes of any providers or probes from the kernel. 	 */
if|if
condition|(
name|flags
operator|&
name|DTRACE_O_NODEV
condition|)
name|dtp
operator|->
name|dt_cflags
operator||=
name|DTRACE_C_ZDEFS
expr_stmt|;
comment|/* 	 * Load hard-wired inlines into the definition cache by calling the 	 * compiler on the raw definition string defined above. 	 */
if|if
condition|(
operator|(
name|pgp
operator|=
name|dtrace_program_strcompile
argument_list|(
name|dtp
argument_list|,
name|_dtrace_hardwire
argument_list|,
name|DTRACE_PROBESPEC_NONE
argument_list|,
name|DTRACE_C_EMPTY
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dt_dprintf
argument_list|(
literal|"failed to load hard-wired definitions: %s\n"
argument_list|,
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|EDT_HARDWIRE
argument_list|)
operator|)
return|;
block|}
name|dt_program_destroy
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the default DTrace library path.  Once set, the next call to 	 * dt_compile() will compile all the libraries.  We intentionally defer 	 * library processing to improve overhead for clients that don't ever 	 * compile, and to provide better error reporting (because the full 	 * reporting of compiler errors requires dtrace_open() to succeed). 	 */
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|dtp
argument_list|,
literal|"libdir"
argument_list|,
name|_dtrace_libdir
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|set_open_errno
argument_list|(
name|dtp
argument_list|,
name|errp
argument_list|,
name|dtp
operator|->
name|dt_errno
argument_list|)
operator|)
return|;
return|return
operator|(
name|dtp
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_hdl_t
modifier|*
name|dtrace_open
parameter_list|(
name|int
name|version
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
return|return
operator|(
name|dt_vopen
argument_list|(
name|version
argument_list|,
name|flags
argument_list|,
name|errp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dtrace_hdl_t
modifier|*
name|dtrace_vopen
parameter_list|(
name|int
name|version
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|,
specifier|const
name|dtrace_vector_t
modifier|*
name|vector
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|dt_vopen
argument_list|(
name|version
argument_list|,
name|flags
argument_list|,
name|errp
argument_list|,
name|vector
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dtrace_close
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
name|dt_ident_t
modifier|*
name|idp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|dt_module_t
modifier|*
name|dmp
decl_stmt|;
name|dt_provider_t
modifier|*
name|pvp
decl_stmt|;
name|dtrace_prog_t
modifier|*
name|pgp
decl_stmt|;
name|dt_xlator_t
modifier|*
name|dxp
decl_stmt|;
name|dt_dirpath_t
modifier|*
name|dirp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_procs
operator|!=
name|NULL
condition|)
name|dt_proc_hash_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pgp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_programs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dt_program_destroy
argument_list|(
name|dtp
argument_list|,
name|pgp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dxp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_xlators
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dt_xlator_destroy
argument_list|(
name|dtp
argument_list|,
name|dxp
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|dtp
operator|->
name|dt_xlatormap
argument_list|)
expr_stmt|;
for|for
control|(
name|idp
operator|=
name|dtp
operator|->
name|dt_externs
init|;
name|idp
operator|!=
name|NULL
condition|;
name|idp
operator|=
name|ndp
control|)
block|{
name|ndp
operator|=
name|idp
operator|->
name|di_next
expr_stmt|;
name|dt_ident_destroy
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_macros
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|dtp
operator|->
name|dt_macros
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_aggs
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|dtp
operator|->
name|dt_aggs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_globals
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|dtp
operator|->
name|dt_globals
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_tls
operator|!=
name|NULL
condition|)
name|dt_idhash_destroy
argument_list|(
name|dtp
operator|->
name|dt_tls
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dmp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_modlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dt_module_destroy
argument_list|(
name|dtp
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pvp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_provlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dt_provider_destroy
argument_list|(
name|dtp
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|dtp
operator|->
name|dt_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_ftfd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|dtp
operator|->
name|dt_ftfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_cdefs_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|dtp
operator|->
name|dt_cdefs_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_ddefs_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|dtp
operator|->
name|dt_ddefs_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_stdout_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|dtp
operator|->
name|dt_stdout_fd
argument_list|)
expr_stmt|;
name|dt_epid_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|dt_aggid_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|dt_format_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|dt_buffered_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|dt_aggregate_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_buf
operator|.
name|dtbd_data
argument_list|)
expr_stmt|;
name|dt_pfdict_destroy
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
name|dt_provmod_destroy
argument_list|(
operator|&
name|dtp
operator|->
name|dt_provmod
argument_list|)
expr_stmt|;
name|dt_dof_fini
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|dtp
operator|->
name|dt_cpp_argc
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|dtp
operator|->
name|dt_cpp_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dirp
operator|=
name|dt_list_next
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dt_list_delete
argument_list|(
operator|&
name|dtp
operator|->
name|dt_lib_path
argument_list|,
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirp
operator|->
name|dir_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dtp
operator|->
name|dt_cpp_argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_cpp_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_ld_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_mods
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
operator|->
name|dt_provs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dtrace_provider_modules
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|mods
parameter_list|,
name|int
name|nmods
parameter_list|)
block|{
name|dt_provmod_t
modifier|*
name|prov
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|prov
operator|=
name|dtp
operator|->
name|dt_provmod
init|;
name|prov
operator|!=
name|NULL
condition|;
name|prov
operator|=
name|prov
operator|->
name|dp_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|nmods
condition|)
name|mods
index|[
name|i
index|]
operator|=
name|prov
operator|->
name|dp_name
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_ctlfd
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
return|return
operator|(
name|dtp
operator|->
name|dt_fd
operator|)
return|;
block|}
end_function

end_unit

