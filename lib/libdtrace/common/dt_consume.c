begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_include
include|#
directive|include
file|<dt_pq.h>
end_include

begin_define
define|#
directive|define
name|DT_MASK_LO
value|0x00000000FFFFFFFFULL
end_define

begin_comment
comment|/*  * We declare this here because (1) we need it and (2) we want to avoid a  * dependency on libm in libdtrace.  */
end_comment

begin_function
specifier|static
name|long
name|double
name|dt_fabsl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|x
operator|)
return|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_ndigits
parameter_list|(
name|long
name|long
name|val
parameter_list|)
block|{
name|int
name|rval
init|=
literal|1
decl_stmt|;
name|long
name|long
name|cmp
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
name|val
operator|==
name|INT64_MIN
condition|?
name|INT64_MAX
else|:
operator|-
name|val
expr_stmt|;
name|rval
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|val
operator|>
name|cmp
operator|&&
name|cmp
operator|>
literal|0
condition|)
block|{
name|rval
operator|++
expr_stmt|;
name|cmp
operator|*=
literal|10
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|<
literal|4
condition|?
literal|4
else|:
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 128-bit arithmetic functions needed to support the stddev() aggregating  * action.  */
end_comment

begin_function
specifier|static
name|int
name|dt_gt_128
parameter_list|(
name|uint64_t
modifier|*
name|a
parameter_list|,
name|uint64_t
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
index|[
literal|1
index|]
operator|>
name|b
index|[
literal|1
index|]
operator|||
operator|(
name|a
index|[
literal|1
index|]
operator|==
name|b
index|[
literal|1
index|]
operator|&&
name|a
index|[
literal|0
index|]
operator|>
name|b
index|[
literal|0
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_ge_128
parameter_list|(
name|uint64_t
modifier|*
name|a
parameter_list|,
name|uint64_t
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
index|[
literal|1
index|]
operator|>
name|b
index|[
literal|1
index|]
operator|||
operator|(
name|a
index|[
literal|1
index|]
operator|==
name|b
index|[
literal|1
index|]
operator|&&
name|a
index|[
literal|0
index|]
operator|>=
name|b
index|[
literal|0
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_le_128
parameter_list|(
name|uint64_t
modifier|*
name|a
parameter_list|,
name|uint64_t
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
index|[
literal|1
index|]
operator|<
name|b
index|[
literal|1
index|]
operator|||
operator|(
name|a
index|[
literal|1
index|]
operator|==
name|b
index|[
literal|1
index|]
operator|&&
name|a
index|[
literal|0
index|]
operator|<=
name|b
index|[
literal|0
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shift the 128-bit value in a by b. If b is positive, shift left.  * If b is negative, shift right.  */
end_comment

begin_function
specifier|static
name|void
name|dt_shift_128
parameter_list|(
name|uint64_t
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|b
operator|=
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|64
condition|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|1
index|]
operator|>>
operator|(
name|b
operator|-
literal|64
operator|)
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a
index|[
literal|0
index|]
operator|>>=
name|b
expr_stmt|;
name|mask
operator|=
literal|1LL
operator|<<
operator|(
literal|64
operator|-
name|b
operator|)
expr_stmt|;
name|mask
operator|-=
literal|1
expr_stmt|;
name|a
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|a
index|[
literal|1
index|]
operator|&
name|mask
operator|)
operator|<<
operator|(
literal|64
operator|-
name|b
operator|)
operator|)
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|>>=
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|>=
literal|64
condition|)
block|{
name|a
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|0
index|]
operator|<<
operator|(
name|b
operator|-
literal|64
operator|)
expr_stmt|;
name|a
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a
index|[
literal|1
index|]
operator|<<=
name|b
expr_stmt|;
name|mask
operator|=
name|a
index|[
literal|0
index|]
operator|>>
operator|(
literal|64
operator|-
name|b
operator|)
expr_stmt|;
name|a
index|[
literal|1
index|]
operator||=
name|mask
expr_stmt|;
name|a
index|[
literal|0
index|]
operator|<<=
name|b
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dt_nbits_128
parameter_list|(
name|uint64_t
modifier|*
name|a
parameter_list|)
block|{
name|int
name|nbits
init|=
literal|0
decl_stmt|;
name|uint64_t
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|zero
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|0
index|]
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|1
index|]
expr_stmt|;
name|dt_shift_128
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|dt_gt_128
argument_list|(
name|tmp
argument_list|,
name|zero
argument_list|)
condition|)
block|{
name|dt_shift_128
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nbits
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|nbits
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_subtract_128
parameter_list|(
name|uint64_t
modifier|*
name|minuend
parameter_list|,
name|uint64_t
modifier|*
name|subtrahend
parameter_list|,
name|uint64_t
modifier|*
name|difference
parameter_list|)
block|{
name|uint64_t
name|result
index|[
literal|2
index|]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|minuend
index|[
literal|0
index|]
operator|-
name|subtrahend
index|[
literal|0
index|]
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|minuend
index|[
literal|1
index|]
operator|-
name|subtrahend
index|[
literal|1
index|]
operator|-
operator|(
name|minuend
index|[
literal|0
index|]
operator|<
name|subtrahend
index|[
literal|0
index|]
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|difference
index|[
literal|0
index|]
operator|=
name|result
index|[
literal|0
index|]
expr_stmt|;
name|difference
index|[
literal|1
index|]
operator|=
name|result
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_add_128
parameter_list|(
name|uint64_t
modifier|*
name|addend1
parameter_list|,
name|uint64_t
modifier|*
name|addend2
parameter_list|,
name|uint64_t
modifier|*
name|sum
parameter_list|)
block|{
name|uint64_t
name|result
index|[
literal|2
index|]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|addend1
index|[
literal|0
index|]
operator|+
name|addend2
index|[
literal|0
index|]
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|addend1
index|[
literal|1
index|]
operator|+
name|addend2
index|[
literal|1
index|]
operator|+
operator|(
name|result
index|[
literal|0
index|]
operator|<
name|addend1
index|[
literal|0
index|]
operator|||
name|result
index|[
literal|0
index|]
operator|<
name|addend2
index|[
literal|0
index|]
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|sum
index|[
literal|0
index|]
operator|=
name|result
index|[
literal|0
index|]
expr_stmt|;
name|sum
index|[
literal|1
index|]
operator|=
name|result
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The basic idea is to break the 2 64-bit values into 4 32-bit values,  * use native multiplication on those, and then re-combine into the  * resulting 128-bit value.  *  * (hi1<< 32 + lo1) * (hi2<< 32 + lo2) =  *     hi1 * hi2<< 64 +  *     hi1 * lo2<< 32 +  *     hi2 * lo1<< 32 +  *     lo1 * lo2  */
end_comment

begin_function
specifier|static
name|void
name|dt_multiply_128
parameter_list|(
name|uint64_t
name|factor1
parameter_list|,
name|uint64_t
name|factor2
parameter_list|,
name|uint64_t
modifier|*
name|product
parameter_list|)
block|{
name|uint64_t
name|hi1
decl_stmt|,
name|hi2
decl_stmt|,
name|lo1
decl_stmt|,
name|lo2
decl_stmt|;
name|uint64_t
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|hi1
operator|=
name|factor1
operator|>>
literal|32
expr_stmt|;
name|hi2
operator|=
name|factor2
operator|>>
literal|32
expr_stmt|;
name|lo1
operator|=
name|factor1
operator|&
name|DT_MASK_LO
expr_stmt|;
name|lo2
operator|=
name|factor2
operator|&
name|DT_MASK_LO
expr_stmt|;
name|product
index|[
literal|0
index|]
operator|=
name|lo1
operator|*
name|lo2
expr_stmt|;
name|product
index|[
literal|1
index|]
operator|=
name|hi1
operator|*
name|hi2
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|hi1
operator|*
name|lo2
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dt_shift_128
argument_list|(
name|tmp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|dt_add_128
argument_list|(
name|product
argument_list|,
name|tmp
argument_list|,
name|product
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|hi2
operator|*
name|lo1
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dt_shift_128
argument_list|(
name|tmp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|dt_add_128
argument_list|(
name|product
argument_list|,
name|tmp
argument_list|,
name|product
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is long-hand division.  *  * We initialize subtrahend by shifting divisor left as far as possible. We  * loop, comparing subtrahend to dividend:  if subtrahend is smaller, we  * subtract and set the appropriate bit in the result.  We then shift  * subtrahend right by one bit for the next comparison.  */
end_comment

begin_function
specifier|static
name|void
name|dt_divide_128
parameter_list|(
name|uint64_t
modifier|*
name|dividend
parameter_list|,
name|uint64_t
name|divisor
parameter_list|,
name|uint64_t
modifier|*
name|quotient
parameter_list|)
block|{
name|uint64_t
name|result
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|uint64_t
name|remainder
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|subtrahend
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|divisor_128
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|mask
index|[
literal|2
index|]
init|=
block|{
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|int
name|log
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|divisor
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|divisor_128
index|[
literal|0
index|]
operator|=
name|divisor
expr_stmt|;
name|divisor_128
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|remainder
index|[
literal|0
index|]
operator|=
name|dividend
index|[
literal|0
index|]
expr_stmt|;
name|remainder
index|[
literal|1
index|]
operator|=
name|dividend
index|[
literal|1
index|]
expr_stmt|;
name|subtrahend
index|[
literal|0
index|]
operator|=
name|divisor
expr_stmt|;
name|subtrahend
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|divisor
operator|>
literal|0
condition|)
block|{
name|log
operator|++
expr_stmt|;
name|divisor
operator|>>=
literal|1
expr_stmt|;
block|}
name|dt_shift_128
argument_list|(
name|subtrahend
argument_list|,
literal|128
operator|-
name|log
argument_list|)
expr_stmt|;
name|dt_shift_128
argument_list|(
name|mask
argument_list|,
literal|128
operator|-
name|log
argument_list|)
expr_stmt|;
while|while
condition|(
name|dt_ge_128
argument_list|(
name|remainder
argument_list|,
name|divisor_128
argument_list|)
condition|)
block|{
if|if
condition|(
name|dt_ge_128
argument_list|(
name|remainder
argument_list|,
name|subtrahend
argument_list|)
condition|)
block|{
name|dt_subtract_128
argument_list|(
name|remainder
argument_list|,
name|subtrahend
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator||=
name|mask
index|[
literal|0
index|]
expr_stmt|;
name|result
index|[
literal|1
index|]
operator||=
name|mask
index|[
literal|1
index|]
expr_stmt|;
block|}
name|dt_shift_128
argument_list|(
name|subtrahend
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dt_shift_128
argument_list|(
name|mask
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|quotient
index|[
literal|0
index|]
operator|=
name|result
index|[
literal|0
index|]
expr_stmt|;
name|quotient
index|[
literal|1
index|]
operator|=
name|result
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the long-hand method of calculating a square root.  * The algorithm is as follows:  *  * 1. Group the digits by 2 from the right.  * 2. Over the leftmost group, find the largest single-digit number  *    whose square is less than that group.  * 3. Subtract the result of the previous step (2 or 4, depending) and  *    bring down the next two-digit group.  * 4. For the result R we have so far, find the largest single-digit number  *    x such that 2 * R * 10 * x + x^2 is less than the result from step 3.  *    (Note that this is doubling R and performing a decimal left-shift by 1  *    and searching for the appropriate decimal to fill the one's place.)  *    The value x is the next digit in the square root.  * Repeat steps 3 and 4 until the desired precision is reached.  (We're  * dealing with integers, so the above is sufficient.)  *  * In decimal, the square root of 582,734 would be calculated as so:  *  *     __7__6__3  *    | 58 27 34  *     -49       (7^2 == 49 => 7 is the first digit in the square root)  *      --  *       9 27    (Subtract and bring down the next group.)  * 146   8 76    (2 * 7 * 10 * 6 + 6^2 == 876 => 6 is the next digit in  *      -----     the square root)  *         51 34 (Subtract and bring down the next group.)  * 1523    45 69 (2 * 76 * 10 * 3 + 3^2 == 4569 => 3 is the next digit in  *         -----  the square root)  *          5 65 (remainder)  *  * The above algorithm applies similarly in binary, but note that the  * only possible non-zero value for x in step 4 is 1, so step 4 becomes a  * simple decision: is 2 * R * 2 * 1 + 1^2 (aka R<< 2 + 1) less than the  * preceding difference?  *  * In binary, the square root of 11011011 would be calculated as so:  *  *     __1__1__1__0  *    | 11 01 10 11  *      01          (0<< 2 + 1 == 1< 11 => this bit is 1)  *      --  *      10 01 10 11  * 101   1 01       (1<< 2 + 1 == 101< 1001 => next bit is 1)  *      -----  *       1 00 10 11  * 1101    11 01    (11<< 2 + 1 == 1101< 10010 => next bit is 1)  *       -------  *          1 01 11  * 11101    1 11 01 (111<< 2 + 1 == 11101> 10111 => last bit is 0)  *  */
end_comment

begin_function
specifier|static
name|uint64_t
name|dt_sqrt_128
parameter_list|(
name|uint64_t
modifier|*
name|square
parameter_list|)
block|{
name|uint64_t
name|result
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|uint64_t
name|diff
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|uint64_t
name|one
index|[
literal|2
index|]
init|=
block|{
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|uint64_t
name|next_pair
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|next_try
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|bit_pairs
decl_stmt|,
name|pair_shift
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bit_pairs
operator|=
name|dt_nbits_128
argument_list|(
name|square
argument_list|)
operator|/
literal|2
expr_stmt|;
name|pair_shift
operator|=
name|bit_pairs
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|bit_pairs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Bring down the next pair of bits. 		 */
name|next_pair
index|[
literal|0
index|]
operator|=
name|square
index|[
literal|0
index|]
expr_stmt|;
name|next_pair
index|[
literal|1
index|]
operator|=
name|square
index|[
literal|1
index|]
expr_stmt|;
name|dt_shift_128
argument_list|(
name|next_pair
argument_list|,
operator|-
name|pair_shift
argument_list|)
expr_stmt|;
name|next_pair
index|[
literal|0
index|]
operator|&=
literal|0x3
expr_stmt|;
name|next_pair
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dt_shift_128
argument_list|(
name|diff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dt_add_128
argument_list|(
name|diff
argument_list|,
name|next_pair
argument_list|,
name|diff
argument_list|)
expr_stmt|;
comment|/* 		 * next_try = R<< 2 + 1 		 */
name|next_try
index|[
literal|0
index|]
operator|=
name|result
index|[
literal|0
index|]
expr_stmt|;
name|next_try
index|[
literal|1
index|]
operator|=
name|result
index|[
literal|1
index|]
expr_stmt|;
name|dt_shift_128
argument_list|(
name|next_try
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dt_add_128
argument_list|(
name|next_try
argument_list|,
name|one
argument_list|,
name|next_try
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_le_128
argument_list|(
name|next_try
argument_list|,
name|diff
argument_list|)
condition|)
block|{
name|dt_subtract_128
argument_list|(
name|diff
argument_list|,
name|next_try
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|dt_shift_128
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dt_add_128
argument_list|(
name|result
argument_list|,
name|one
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dt_shift_128
argument_list|(
name|result
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pair_shift
operator|-=
literal|2
expr_stmt|;
block|}
name|assert
argument_list|(
name|result
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dt_stddev
parameter_list|(
name|uint64_t
modifier|*
name|data
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|uint64_t
name|avg_of_squares
index|[
literal|2
index|]
decl_stmt|;
name|uint64_t
name|square_of_avg
index|[
literal|2
index|]
decl_stmt|;
name|int64_t
name|norm_avg
decl_stmt|;
name|uint64_t
name|diff
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * The standard approximation for standard deviation is 	 * sqrt(average(x**2) - average(x)**2), i.e. the square root 	 * of the average of the squares minus the square of the average. 	 * When normalizing, we should divide the sum of x**2 by normal**2. 	 */
name|dt_divide_128
argument_list|(
name|data
operator|+
literal|2
argument_list|,
name|normal
argument_list|,
name|avg_of_squares
argument_list|)
expr_stmt|;
name|dt_divide_128
argument_list|(
name|avg_of_squares
argument_list|,
name|normal
argument_list|,
name|avg_of_squares
argument_list|)
expr_stmt|;
name|dt_divide_128
argument_list|(
name|avg_of_squares
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|avg_of_squares
argument_list|)
expr_stmt|;
name|norm_avg
operator|=
operator|(
name|int64_t
operator|)
name|data
index|[
literal|1
index|]
operator|/
operator|(
name|int64_t
operator|)
name|normal
operator|/
operator|(
name|int64_t
operator|)
name|data
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|norm_avg
operator|<
literal|0
condition|)
name|norm_avg
operator|=
operator|-
name|norm_avg
expr_stmt|;
name|dt_multiply_128
argument_list|(
operator|(
name|uint64_t
operator|)
name|norm_avg
argument_list|,
operator|(
name|uint64_t
operator|)
name|norm_avg
argument_list|,
name|square_of_avg
argument_list|)
expr_stmt|;
name|dt_subtract_128
argument_list|(
name|avg_of_squares
argument_list|,
name|square_of_avg
argument_list|,
name|diff
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_sqrt_128
argument_list|(
name|diff
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_flowindent
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
name|dtrace_epid_t
name|last
parameter_list|,
name|dtrace_bufdesc_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|offs
parameter_list|)
block|{
name|dtrace_probedesc_t
modifier|*
name|pd
init|=
name|data
operator|->
name|dtpda_pdesc
decl_stmt|,
modifier|*
name|npd
decl_stmt|;
name|dtrace_eprobedesc_t
modifier|*
name|epd
init|=
name|data
operator|->
name|dtpda_edesc
decl_stmt|,
modifier|*
name|nepd
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|pd
operator|->
name|dtpd_provider
decl_stmt|,
modifier|*
name|n
init|=
name|pd
operator|->
name|dtpd_name
decl_stmt|,
modifier|*
name|sub
decl_stmt|;
name|dtrace_flowkind_t
name|flow
init|=
name|DTRACEFLOW_NONE
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|e_str
index|[
literal|2
index|]
init|=
block|{
literal|" -> "
block|,
literal|" => "
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|r_str
index|[
literal|2
index|]
init|=
block|{
literal|"<- "
block|,
literal|"<= "
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|ent
init|=
literal|"entry"
decl_stmt|,
modifier|*
name|ret
init|=
literal|"return"
decl_stmt|;
specifier|static
name|int
name|entlen
init|=
literal|0
decl_stmt|,
name|retlen
init|=
literal|0
decl_stmt|;
name|dtrace_epid_t
name|next
decl_stmt|,
name|id
init|=
name|epd
operator|->
name|dtepd_epid
decl_stmt|;
name|int
name|rval
decl_stmt|;
if|if
condition|(
name|entlen
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|retlen
operator|==
literal|0
argument_list|)
expr_stmt|;
name|entlen
operator|=
name|strlen
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|retlen
operator|=
name|strlen
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the name of the probe is "entry" or ends with "-entry", we 	 * treat it as an entry; if it is "return" or ends with "-return", 	 * we treat it as a return.  (This allows application-provided probes 	 * like "method-entry" or "function-entry" to participate in flow 	 * indentation -- without accidentally misinterpreting popular probe 	 * names like "carpentry", "gentry" or "Coventry".) 	 */
if|if
condition|(
operator|(
name|sub
operator|=
name|strstr
argument_list|(
name|n
argument_list|,
name|ent
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|sub
index|[
name|entlen
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|sub
operator|==
name|n
operator|||
name|sub
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
name|flow
operator|=
name|DTRACEFLOW_ENTRY
expr_stmt|;
name|str
operator|=
name|e_str
index|[
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"syscall"
argument_list|)
operator|==
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sub
operator|=
name|strstr
argument_list|(
name|n
argument_list|,
name|ret
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|sub
index|[
name|retlen
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|sub
operator|==
name|n
operator|||
name|sub
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
name|flow
operator|=
name|DTRACEFLOW_RETURN
expr_stmt|;
name|str
operator|=
name|r_str
index|[
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"syscall"
argument_list|)
operator|==
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * If we're going to indent this, we need to check the ID of our last 	 * call.  If we're looking at the same probe ID but a different EPID, 	 * we _don't_ want to indent.  (Yes, there are some minor holes in 	 * this scheme -- it's a heuristic.) 	 */
if|if
condition|(
name|flow
operator|==
name|DTRACEFLOW_ENTRY
condition|)
block|{
if|if
condition|(
operator|(
name|last
operator|!=
name|DTRACE_EPIDNONE
operator|&&
name|id
operator|!=
name|last
operator|&&
name|pd
operator|->
name|dtpd_id
operator|==
name|dtp
operator|->
name|dt_pdesc
index|[
name|last
index|]
operator|->
name|dtpd_id
operator|)
condition|)
name|flow
operator|=
name|DTRACEFLOW_NONE
expr_stmt|;
block|}
comment|/* 	 * If we're going to unindent this, it's more difficult to see if 	 * we don't actually want to unindent it -- we need to look at the 	 * _next_ EPID. 	 */
if|if
condition|(
name|flow
operator|==
name|DTRACEFLOW_RETURN
condition|)
block|{
name|offs
operator|+=
name|epd
operator|->
name|dtepd_size
expr_stmt|;
do|do
block|{
if|if
condition|(
name|offs
operator|>=
name|buf
operator|->
name|dtbd_size
condition|)
goto|goto
name|out
goto|;
name|next
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|DTRACE_EPIDNONE
condition|)
name|offs
operator|+=
sizeof|sizeof
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|==
name|DTRACE_EPIDNONE
condition|)
do|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_epid_lookup
argument_list|(
name|dtp
argument_list|,
name|next
argument_list|,
operator|&
name|nepd
argument_list|,
operator|&
name|npd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|next
operator|!=
name|id
operator|&&
name|npd
operator|->
name|dtpd_id
operator|==
name|pd
operator|->
name|dtpd_id
condition|)
name|flow
operator|=
name|DTRACEFLOW_NONE
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|flow
operator|==
name|DTRACEFLOW_ENTRY
operator|||
name|flow
operator|==
name|DTRACEFLOW_RETURN
condition|)
block|{
name|data
operator|->
name|dtpda_prefix
operator|=
name|str
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|dtpda_prefix
operator|=
literal|"| "
expr_stmt|;
block|}
if|if
condition|(
name|flow
operator|==
name|DTRACEFLOW_RETURN
operator|&&
name|data
operator|->
name|dtpda_indent
operator|>
literal|0
condition|)
name|data
operator|->
name|dtpda_indent
operator|-=
literal|2
expr_stmt|;
name|data
operator|->
name|dtpda_flow
operator|=
name|flow
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_nullprobe
parameter_list|()
block|{
return|return
operator|(
name|DTRACE_CONSUME_THIS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_nullrec
parameter_list|()
block|{
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_quantize_total
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int64_t
name|datum
parameter_list|,
name|long
name|double
modifier|*
name|total
parameter_list|)
block|{
name|long
name|double
name|val
init|=
name|dt_fabsl
argument_list|(
operator|(
name|long
name|double
operator|)
name|datum
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_AGGZOOM
index|]
operator|==
name|DTRACEOPT_UNSET
condition|)
block|{
operator|*
name|total
operator|+=
name|val
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're zooming in on an aggregation, we want the height of the 	 * highest value to be approximately 95% of total bar height -- so we 	 * adjust up by the reciprocal of DTRACE_AGGZOOM_MAX when comparing to 	 * our highest value. 	 */
name|val
operator|*=
literal|1
operator|/
name|DTRACE_AGGZOOM_MAX
expr_stmt|;
if|if
condition|(
operator|*
name|total
operator|<
name|val
condition|)
operator|*
name|total
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_print_quanthdr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|width
parameter_list|)
block|{
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n%*s %41s %-9s\n"
argument_list|,
name|width
condition|?
name|width
else|:
literal|16
argument_list|,
name|width
condition|?
literal|"key"
else|:
literal|"value"
argument_list|,
literal|"------------- Distribution -------------"
argument_list|,
literal|"count"
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_print_quanthdr_packed
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|width
parameter_list|,
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|,
name|dtrace_actkind_t
name|action
parameter_list|)
block|{
name|int
name|min
init|=
name|aggdata
operator|->
name|dtada_minbin
decl_stmt|,
name|max
init|=
name|aggdata
operator|->
name|dtada_maxbin
decl_stmt|;
name|int
name|minwidth
decl_stmt|,
name|maxwidth
decl_stmt|,
name|i
decl_stmt|;
name|assert
argument_list|(
name|action
operator|==
name|DTRACEAGG_QUANTIZE
operator|||
name|action
operator|==
name|DTRACEAGG_LQUANTIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|DTRACEAGG_QUANTIZE
condition|)
block|{
if|if
condition|(
name|min
operator|!=
literal|0
operator|&&
name|min
operator|!=
name|DTRACE_QUANTIZE_ZEROBUCKET
condition|)
name|min
operator|--
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|DTRACE_QUANTIZE_NBUCKETS
operator|-
literal|1
condition|)
name|max
operator|++
expr_stmt|;
name|minwidth
operator|=
name|dt_ndigits
argument_list|(
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|min
argument_list|)
argument_list|)
expr_stmt|;
name|maxwidth
operator|=
name|dt_ndigits
argument_list|(
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|max
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxwidth
operator|=
literal|8
expr_stmt|;
name|minwidth
operator|=
name|maxwidth
operator|-
literal|1
expr_stmt|;
name|max
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n%*s %*s ."
argument_list|,
name|width
argument_list|,
name|width
operator|>
literal|0
condition|?
literal|"key"
else|:
literal|""
argument_list|,
name|minwidth
argument_list|,
literal|"min"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"-"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|". %*s | count\n"
argument_list|,
operator|-
name|maxwidth
argument_list|,
literal|"max"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We use a subset of the Unicode Block Elements (U+2588 through U+258F,  * inclusive) to represent aggregations via UTF-8 -- which are expressed via  * 3-byte UTF-8 sequences.  */
end_comment

begin_define
define|#
directive|define
name|DTRACE_AGGUTF8_FULL
value|0x2588
end_define

begin_define
define|#
directive|define
name|DTRACE_AGGUTF8_BASE
value|0x258f
end_define

begin_define
define|#
directive|define
name|DTRACE_AGGUTF8_LEVELS
value|8
end_define

begin_define
define|#
directive|define
name|DTRACE_AGGUTF8_BYTE0
parameter_list|(
name|val
parameter_list|)
value|(0xe0 | ((val)>> 12))
end_define

begin_define
define|#
directive|define
name|DTRACE_AGGUTF8_BYTE1
parameter_list|(
name|val
parameter_list|)
value|(0x80 | (((val)>> 6)& 0x3f))
end_define

begin_define
define|#
directive|define
name|DTRACE_AGGUTF8_BYTE2
parameter_list|(
name|val
parameter_list|)
value|(0x80 | ((val)& 0x3f))
end_define

begin_function
specifier|static
name|int
name|dt_print_quantline_utf8
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int64_t
name|val
parameter_list|,
name|uint64_t
name|normal
parameter_list|,
name|long
name|double
name|total
parameter_list|)
block|{
name|uint_t
name|len
init|=
literal|40
decl_stmt|,
name|i
decl_stmt|,
name|whole
decl_stmt|,
name|partial
decl_stmt|;
name|long
name|double
name|f
init|=
operator|(
name|dt_fabsl
argument_list|(
operator|(
name|long
name|double
operator|)
name|val
argument_list|)
operator|*
name|len
operator|)
operator|/
name|total
decl_stmt|;
specifier|const
name|char
modifier|*
name|spaces
init|=
literal|"                                        "
decl_stmt|;
name|whole
operator|=
operator|(
name|uint_t
operator|)
name|f
expr_stmt|;
name|partial
operator|=
call|(
name|uint_t
call|)
argument_list|(
operator|(
name|f
operator|-
operator|(
name|long
name|double
operator|)
operator|(
name|uint_t
operator|)
name|f
operator|)
operator|*
operator|(
name|long
name|double
operator|)
name|DTRACE_AGGUTF8_LEVELS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"|"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|whole
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%c%c%c"
argument_list|,
name|DTRACE_AGGUTF8_BYTE0
argument_list|(
name|DTRACE_AGGUTF8_FULL
argument_list|)
argument_list|,
name|DTRACE_AGGUTF8_BYTE1
argument_list|(
name|DTRACE_AGGUTF8_FULL
argument_list|)
argument_list|,
name|DTRACE_AGGUTF8_BYTE2
argument_list|(
name|DTRACE_AGGUTF8_FULL
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|partial
operator|!=
literal|0
condition|)
block|{
name|partial
operator|=
name|DTRACE_AGGUTF8_BASE
operator|-
operator|(
name|partial
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%c%c%c"
argument_list|,
name|DTRACE_AGGUTF8_BYTE0
argument_list|(
name|partial
argument_list|)
argument_list|,
name|DTRACE_AGGUTF8_BYTE1
argument_list|(
name|partial
argument_list|)
argument_list|,
name|DTRACE_AGGUTF8_BYTE2
argument_list|(
name|partial
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%s %-9lld\n"
argument_list|,
name|spaces
operator|+
name|i
argument_list|,
operator|(
name|long
name|long
operator|)
name|val
operator|/
name|normal
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_print_quantline
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int64_t
name|val
parameter_list|,
name|uint64_t
name|normal
parameter_list|,
name|long
name|double
name|total
parameter_list|,
name|char
name|positives
parameter_list|,
name|char
name|negatives
parameter_list|)
block|{
name|long
name|double
name|f
decl_stmt|;
name|uint_t
name|depth
decl_stmt|,
name|len
init|=
literal|40
decl_stmt|;
specifier|const
name|char
modifier|*
name|ats
init|=
literal|"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
decl_stmt|;
specifier|const
name|char
modifier|*
name|spaces
init|=
literal|"                                        "
decl_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|ats
argument_list|)
operator|==
name|len
operator|&&
name|strlen
argument_list|(
name|spaces
argument_list|)
operator|==
name|len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|total
operator|==
literal|0
operator|&&
operator|(
name|positives
operator|||
name|negatives
operator|)
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|val
operator|<
literal|0
operator|&&
operator|!
name|negatives
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|val
operator|>
literal|0
operator|&&
operator|!
name|positives
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|val
operator|!=
literal|0
operator|&&
name|total
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|negatives
condition|)
block|{
if|if
condition|(
name|positives
condition|)
block|{
if|if
condition|(
name|dtp
operator|->
name|dt_encoding
operator|==
name|DT_ENCODING_UTF8
condition|)
block|{
return|return
operator|(
name|dt_print_quantline_utf8
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|val
argument_list|,
name|normal
argument_list|,
name|total
argument_list|)
operator|)
return|;
block|}
name|f
operator|=
operator|(
name|dt_fabsl
argument_list|(
operator|(
name|long
name|double
operator|)
name|val
argument_list|)
operator|*
name|len
operator|)
operator|/
name|total
expr_stmt|;
name|depth
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|f
operator|+
literal|0.5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|depth
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"|%s%s %-9lld\n"
argument_list|,
name|ats
operator|+
name|len
operator|-
name|depth
argument_list|,
name|spaces
operator|+
name|depth
argument_list|,
operator|(
name|long
name|long
operator|)
name|val
operator|/
name|normal
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|positives
condition|)
block|{
name|f
operator|=
operator|(
name|dt_fabsl
argument_list|(
operator|(
name|long
name|double
operator|)
name|val
argument_list|)
operator|*
name|len
operator|)
operator|/
name|total
expr_stmt|;
name|depth
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|f
operator|+
literal|0.5
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%s%s| %-9lld\n"
argument_list|,
name|spaces
operator|+
name|depth
argument_list|,
name|ats
operator|+
name|len
operator|-
name|depth
argument_list|,
operator|(
name|long
name|long
operator|)
name|val
operator|/
name|normal
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If we're here, we have both positive and negative bucket values. 	 * To express this graphically, we're going to generate both positive 	 * and negative bars separated by a centerline.  These bars are half 	 * the size of normal quantize()/lquantize() bars, so we divide the 	 * length in half before calculating the bar length. 	 */
name|len
operator|/=
literal|2
expr_stmt|;
name|ats
operator|=
operator|&
name|ats
index|[
name|len
index|]
expr_stmt|;
name|spaces
operator|=
operator|&
name|spaces
index|[
name|len
index|]
expr_stmt|;
name|f
operator|=
operator|(
name|dt_fabsl
argument_list|(
operator|(
name|long
name|double
operator|)
name|val
argument_list|)
operator|*
name|len
operator|)
operator|/
name|total
expr_stmt|;
name|depth
operator|=
call|(
name|uint_t
call|)
argument_list|(
name|f
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%s%s|%*s %-9lld\n"
argument_list|,
name|spaces
operator|+
name|depth
argument_list|,
name|ats
operator|+
name|len
operator|-
name|depth
argument_list|,
name|len
argument_list|,
literal|""
argument_list|,
operator|(
name|long
name|long
operator|)
name|val
operator|/
name|normal
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%20s|%s%s %-9lld\n"
argument_list|,
literal|""
argument_list|,
name|ats
operator|+
name|len
operator|-
name|depth
argument_list|,
name|spaces
operator|+
name|depth
argument_list|,
operator|(
name|long
name|long
operator|)
name|val
operator|/
name|normal
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * As with UTF-8 printing of aggregations, we use a subset of the Unicode  * Block Elements (U+2581 through U+2588, inclusive) to represent our packed  * aggregation.  */
end_comment

begin_define
define|#
directive|define
name|DTRACE_AGGPACK_BASE
value|0x2581
end_define

begin_define
define|#
directive|define
name|DTRACE_AGGPACK_LEVELS
value|8
end_define

begin_function
specifier|static
name|int
name|dt_print_packed
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|long
name|double
name|datum
parameter_list|,
name|long
name|double
name|total
parameter_list|)
block|{
specifier|static
name|boolean_t
name|utf8_checked
init|=
name|B_FALSE
decl_stmt|;
specifier|static
name|boolean_t
name|utf8
decl_stmt|;
name|char
modifier|*
name|ascii
init|=
literal|"__xxxxXX"
decl_stmt|;
name|char
modifier|*
name|neg
init|=
literal|"vvvvVV"
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|long
name|double
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|utf8_checked
condition|)
block|{
name|char
modifier|*
name|term
decl_stmt|;
comment|/* 		 * We want to determine if we can reasonably emit UTF-8 for our 		 * packed aggregation.  To do this, we will check for terminals 		 * that are known to be primitive to emit UTF-8 on these. 		 */
name|utf8_checked
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_encoding
operator|==
name|DT_ENCODING_ASCII
condition|)
block|{
name|utf8
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtp
operator|->
name|dt_encoding
operator|==
name|DT_ENCODING_UTF8
condition|)
block|{
name|utf8
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|term
argument_list|,
literal|"sun"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|term
argument_list|,
literal|"sun-color"
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|term
argument_list|,
literal|"dumb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|utf8
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
name|utf8
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|datum
operator|==
literal|0
condition|)
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" "
argument_list|)
operator|)
return|;
if|if
condition|(
name|datum
operator|<
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|neg
argument_list|)
expr_stmt|;
name|val
operator|=
name|dt_fabsl
argument_list|(
name|datum
operator|*
operator|(
name|len
operator|-
literal|1
operator|)
argument_list|)
operator|/
name|total
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%c"
argument_list|,
name|neg
index|[
call|(
name|uint_t
call|)
argument_list|(
name|val
operator|+
literal|0.5
argument_list|)
index|]
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|utf8
condition|)
block|{
name|int
name|block
init|=
name|DTRACE_AGGPACK_BASE
operator|+
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
operator|(
name|datum
operator|*
operator|(
name|DTRACE_AGGPACK_LEVELS
operator|-
literal|1
operator|)
operator|)
operator|/
name|total
operator|)
operator|+
literal|0.5
argument_list|)
decl_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%c%c%c"
argument_list|,
name|DTRACE_AGGUTF8_BYTE0
argument_list|(
name|block
argument_list|)
argument_list|,
name|DTRACE_AGGUTF8_BYTE1
argument_list|(
name|block
argument_list|)
argument_list|,
name|DTRACE_AGGUTF8_BYTE2
argument_list|(
name|block
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|ascii
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|datum
operator|*
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
operator|/
name|total
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%c"
argument_list|,
name|ascii
index|[
call|(
name|uint_t
call|)
argument_list|(
name|val
operator|+
literal|0.5
argument_list|)
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_quantize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
specifier|const
name|int64_t
modifier|*
name|data
init|=
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first_bin
init|=
literal|0
decl_stmt|,
name|last_bin
init|=
name|DTRACE_QUANTIZE_NBUCKETS
operator|-
literal|1
decl_stmt|;
name|long
name|double
name|total
init|=
literal|0
decl_stmt|;
name|char
name|positives
init|=
literal|0
decl_stmt|,
name|negatives
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|DTRACE_QUANTIZE_NBUCKETS
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
while|while
condition|(
name|first_bin
operator|<
name|DTRACE_QUANTIZE_NBUCKETS
operator|-
literal|1
operator|&&
name|data
index|[
name|first_bin
index|]
operator|==
literal|0
condition|)
name|first_bin
operator|++
expr_stmt|;
if|if
condition|(
name|first_bin
operator|==
name|DTRACE_QUANTIZE_NBUCKETS
operator|-
literal|1
condition|)
block|{
comment|/* 		 * There isn't any data.  This is possible if the aggregation 		 * has been clear()'d or if negative increment values have been 		 * used.  Regardless, we'll print the buckets around 0. 		 */
name|first_bin
operator|=
name|DTRACE_QUANTIZE_ZEROBUCKET
operator|-
literal|1
expr_stmt|;
name|last_bin
operator|=
name|DTRACE_QUANTIZE_ZEROBUCKET
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first_bin
operator|>
literal|0
condition|)
name|first_bin
operator|--
expr_stmt|;
while|while
condition|(
name|last_bin
operator|>
literal|0
operator|&&
name|data
index|[
name|last_bin
index|]
operator|==
literal|0
condition|)
name|last_bin
operator|--
expr_stmt|;
if|if
condition|(
name|last_bin
operator|<
name|DTRACE_QUANTIZE_NBUCKETS
operator|-
literal|1
condition|)
name|last_bin
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|first_bin
init|;
name|i
operator|<=
name|last_bin
condition|;
name|i
operator|++
control|)
block|{
name|positives
operator||=
operator|(
name|data
index|[
name|i
index|]
operator|>
literal|0
operator|)
expr_stmt|;
name|negatives
operator||=
operator|(
name|data
index|[
name|i
index|]
operator|<
literal|0
operator|)
expr_stmt|;
name|dt_quantize_total
argument_list|(
name|dtp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
operator|&
name|total
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_print_quanthdr
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|first_bin
init|;
name|i
operator|<=
name|last_bin
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%16lld "
argument_list|,
operator|(
name|long
name|long
operator|)
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|i
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dt_print_quantline
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
name|normal
argument_list|,
name|total
argument_list|,
name|positives
argument_list|,
name|negatives
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_quantize_packed
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|)
block|{
specifier|const
name|int64_t
modifier|*
name|data
init|=
name|addr
decl_stmt|;
name|long
name|double
name|total
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|int
name|min
init|=
name|aggdata
operator|->
name|dtada_minbin
decl_stmt|,
name|max
init|=
name|aggdata
operator|->
name|dtada_maxbin
decl_stmt|,
name|i
decl_stmt|;
name|int64_t
name|minval
decl_stmt|,
name|maxval
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|DTRACE_QUANTIZE_NBUCKETS
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
if|if
condition|(
name|min
operator|!=
literal|0
operator|&&
name|min
operator|!=
name|DTRACE_QUANTIZE_ZEROBUCKET
condition|)
name|min
operator|--
expr_stmt|;
if|if
condition|(
name|max
operator|<
name|DTRACE_QUANTIZE_NBUCKETS
operator|-
literal|1
condition|)
name|max
operator|++
expr_stmt|;
name|minval
operator|=
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|min
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %*lld :"
argument_list|,
name|dt_ndigits
argument_list|(
name|minval
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|minval
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|dt_quantize_total
argument_list|(
name|dtp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
operator|&
name|total
argument_list|)
expr_stmt|;
name|count
operator|+=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dt_print_packed
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
name|total
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|": %*lld | %lld\n"
argument_list|,
operator|-
name|dt_ndigits
argument_list|(
name|maxval
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|maxval
argument_list|,
operator|(
name|long
name|long
operator|)
name|count
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_lquantize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
specifier|const
name|int64_t
modifier|*
name|data
init|=
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first_bin
decl_stmt|,
name|last_bin
decl_stmt|,
name|base
decl_stmt|;
name|uint64_t
name|arg
decl_stmt|;
name|long
name|double
name|total
init|=
literal|0
decl_stmt|;
name|uint16_t
name|step
decl_stmt|,
name|levels
decl_stmt|;
name|char
name|positives
init|=
literal|0
decl_stmt|,
name|negatives
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|arg
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|base
operator|=
name|DTRACE_LQUANTIZE_BASE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|step
operator|=
name|DTRACE_LQUANTIZE_STEP
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|levels
operator|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|first_bin
operator|=
literal|0
expr_stmt|;
name|last_bin
operator|=
name|levels
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
operator|(
name|levels
operator|+
literal|2
operator|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
while|while
condition|(
name|first_bin
operator|<=
name|levels
operator|+
literal|1
operator|&&
name|data
index|[
name|first_bin
index|]
operator|==
literal|0
condition|)
name|first_bin
operator|++
expr_stmt|;
if|if
condition|(
name|first_bin
operator|>
name|levels
operator|+
literal|1
condition|)
block|{
name|first_bin
operator|=
literal|0
expr_stmt|;
name|last_bin
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first_bin
operator|>
literal|0
condition|)
name|first_bin
operator|--
expr_stmt|;
while|while
condition|(
name|last_bin
operator|>
literal|0
operator|&&
name|data
index|[
name|last_bin
index|]
operator|==
literal|0
condition|)
name|last_bin
operator|--
expr_stmt|;
if|if
condition|(
name|last_bin
operator|<
name|levels
operator|+
literal|1
condition|)
name|last_bin
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|first_bin
init|;
name|i
operator|<=
name|last_bin
condition|;
name|i
operator|++
control|)
block|{
name|positives
operator||=
operator|(
name|data
index|[
name|i
index|]
operator|>
literal|0
operator|)
expr_stmt|;
name|negatives
operator||=
operator|(
name|data
index|[
name|i
index|]
operator|<
literal|0
operator|)
expr_stmt|;
name|dt_quantize_total
argument_list|(
name|dtp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
operator|&
name|total
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n%16s %41s %-9s\n"
argument_list|,
literal|"value"
argument_list|,
literal|"------------- Distribution -------------"
argument_list|,
literal|"count"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|first_bin
init|;
name|i
operator|<=
name|last_bin
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
index|[
literal|32
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"< %d"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%16s "
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|levels
operator|+
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|">= %d"
argument_list|,
name|base
operator|+
operator|(
name|levels
operator|*
name|step
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%16s "
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%16d "
argument_list|,
name|base
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
name|step
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|<
literal|0
operator|||
name|dt_print_quantline
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
name|normal
argument_list|,
name|total
argument_list|,
name|positives
argument_list|,
name|negatives
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|dt_print_lquantize_packed
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|)
block|{
specifier|const
name|int64_t
modifier|*
name|data
init|=
name|addr
decl_stmt|;
name|long
name|double
name|total
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|,
name|base
decl_stmt|,
name|err
decl_stmt|;
name|uint64_t
name|arg
decl_stmt|;
name|uint16_t
name|step
decl_stmt|,
name|levels
decl_stmt|;
name|char
name|c
index|[
literal|32
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|arg
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|base
operator|=
name|DTRACE_LQUANTIZE_BASE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|step
operator|=
name|DTRACE_LQUANTIZE_STEP
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|levels
operator|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
operator|(
name|levels
operator|+
literal|2
operator|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
name|levels
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|min
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"< %d"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%8s :"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%8d :"
argument_list|,
name|base
operator|+
operator|(
name|min
operator|-
literal|1
operator|)
operator|*
name|step
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|dt_quantize_total
argument_list|(
name|dtp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
operator|&
name|total
argument_list|)
expr_stmt|;
name|count
operator|+=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dt_print_packed
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
name|total
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|">= %d"
argument_list|,
name|base
operator|+
operator|(
name|levels
operator|*
name|step
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|": %-8s | %lld\n"
argument_list|,
name|c
argument_list|,
operator|(
name|long
name|long
operator|)
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_llquantize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first_bin
decl_stmt|,
name|last_bin
decl_stmt|,
name|bin
init|=
literal|1
decl_stmt|,
name|order
decl_stmt|,
name|levels
decl_stmt|;
name|uint16_t
name|factor
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|,
name|nsteps
decl_stmt|;
specifier|const
name|int64_t
modifier|*
name|data
init|=
name|addr
decl_stmt|;
name|int64_t
name|value
init|=
literal|1
decl_stmt|,
name|next
decl_stmt|,
name|step
decl_stmt|;
name|char
name|positives
init|=
literal|0
decl_stmt|,
name|negatives
init|=
literal|0
decl_stmt|;
name|long
name|double
name|total
init|=
literal|0
decl_stmt|;
name|uint64_t
name|arg
decl_stmt|;
name|char
name|c
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|arg
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|factor
operator|=
name|DTRACE_LLQUANTIZE_FACTOR
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|low
operator|=
name|DTRACE_LLQUANTIZE_LOW
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|high
operator|=
name|DTRACE_LLQUANTIZE_HIGH
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|nsteps
operator|=
name|DTRACE_LLQUANTIZE_NSTEP
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* 	 * We don't expect to be handed invalid llquantize() parameters here, 	 * but sanity check them (to a degree) nonetheless. 	 */
if|if
condition|(
name|size
operator|>
name|INT32_MAX
operator|||
name|factor
operator|<
literal|2
operator|||
name|low
operator|>=
name|high
operator|||
name|nsteps
operator|==
literal|0
operator|||
name|factor
operator|>
name|nsteps
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DMISMATCH
argument_list|)
operator|)
return|;
name|levels
operator|=
operator|(
name|int
operator|)
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|first_bin
operator|=
literal|0
expr_stmt|;
name|last_bin
operator|=
name|levels
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|first_bin
operator|<
name|levels
operator|&&
name|data
index|[
name|first_bin
index|]
operator|==
literal|0
condition|)
name|first_bin
operator|++
expr_stmt|;
if|if
condition|(
name|first_bin
operator|==
name|levels
condition|)
block|{
name|first_bin
operator|=
literal|0
expr_stmt|;
name|last_bin
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first_bin
operator|>
literal|0
condition|)
name|first_bin
operator|--
expr_stmt|;
while|while
condition|(
name|last_bin
operator|>
literal|0
operator|&&
name|data
index|[
name|last_bin
index|]
operator|==
literal|0
condition|)
name|last_bin
operator|--
expr_stmt|;
if|if
condition|(
name|last_bin
operator|<
name|levels
operator|-
literal|1
condition|)
name|last_bin
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|first_bin
init|;
name|i
operator|<=
name|last_bin
condition|;
name|i
operator|++
control|)
block|{
name|positives
operator||=
operator|(
name|data
index|[
name|i
index|]
operator|>
literal|0
operator|)
expr_stmt|;
name|negatives
operator||=
operator|(
name|data
index|[
name|i
index|]
operator|<
literal|0
operator|)
expr_stmt|;
name|dt_quantize_total
argument_list|(
name|dtp
argument_list|,
name|data
index|[
name|i
index|]
argument_list|,
operator|&
name|total
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n%16s %41s %-9s\n"
argument_list|,
literal|"value"
argument_list|,
literal|"------------- Distribution -------------"
argument_list|,
literal|"count"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|order
operator|=
literal|0
init|;
name|order
operator|<
name|low
condition|;
name|order
operator|++
control|)
name|value
operator|*=
name|factor
expr_stmt|;
name|next
operator|=
name|value
operator|*
name|factor
expr_stmt|;
name|step
operator|=
name|next
operator|>
name|nsteps
condition|?
name|next
operator|/
name|nsteps
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|first_bin
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"< %lld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%16s "
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dt_print_quantline
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|normal
argument_list|,
name|total
argument_list|,
name|positives
argument_list|,
name|negatives
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|order
operator|<=
name|high
condition|)
block|{
if|if
condition|(
name|bin
operator|>=
name|first_bin
operator|&&
name|bin
operator|<=
name|last_bin
condition|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%16lld "
argument_list|,
operator|(
name|long
name|long
operator|)
name|value
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dt_print_quantline
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|data
index|[
name|bin
index|]
argument_list|,
name|normal
argument_list|,
name|total
argument_list|,
name|positives
argument_list|,
name|negatives
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|assert
argument_list|(
name|value
operator|<
name|next
argument_list|)
expr_stmt|;
name|bin
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|+=
name|step
operator|)
operator|!=
name|next
condition|)
continue|continue;
name|next
operator|=
name|value
operator|*
name|factor
expr_stmt|;
name|step
operator|=
name|next
operator|>
name|nsteps
condition|?
name|next
operator|/
name|nsteps
else|:
literal|1
expr_stmt|;
name|order
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last_bin
operator|<
name|bin
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|assert
argument_list|(
name|last_bin
operator|==
name|bin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|">= %lld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%16s "
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|dt_print_quantline
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|data
index|[
name|bin
index|]
argument_list|,
name|normal
argument_list|,
name|total
argument_list|,
name|positives
argument_list|,
name|negatives
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_print_average
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
comment|/* LINTED - alignment */
name|int64_t
modifier|*
name|data
init|=
operator|(
name|int64_t
operator|*
operator|)
name|addr
decl_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %16lld"
argument_list|,
name|data
index|[
literal|0
index|]
condition|?
call|(
name|long
name|long
call|)
argument_list|(
name|data
index|[
literal|1
index|]
operator|/
operator|(
name|int64_t
operator|)
name|normal
operator|/
name|data
index|[
literal|0
index|]
argument_list|)
else|:
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_print_stddev
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|normal
parameter_list|)
block|{
comment|/* LINTED - alignment */
name|uint64_t
modifier|*
name|data
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|addr
decl_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %16llu"
argument_list|,
name|data
index|[
literal|0
index|]
condition|?
operator|(
name|unsigned
name|long
name|long
operator|)
name|dt_stddev
argument_list|(
name|data
argument_list|,
name|normal
argument_list|)
else|:
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dt_print_bytes
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|quiet
parameter_list|,
name|int
name|forceraw
parameter_list|)
block|{
comment|/* 	 * If the byte stream is a series of printable characters, followed by 	 * a terminating byte, we print it out as a string.  Otherwise, we 	 * assume that it's something else and just print the bytes. 	 */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|margin
init|=
literal|5
decl_stmt|;
name|char
modifier|*
name|c
init|=
operator|(
name|char
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|forceraw
condition|)
goto|goto
name|raw
goto|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_RAWBYTES
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
goto|goto
name|raw
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * We define a "printable character" to be one for which 		 * isprint(3C) returns non-zero, isspace(3C) returns non-zero, 		 * or a character which is either backspace or the bell. 		 * Backspace and the bell are regrettably special because 		 * they fail the first two tests -- and yet they are entirely 		 * printable.  These are the only two control characters that 		 * have meaning for the terminal and for which isprint(3C) and 		 * isspace(3C) return 0. 		 */
if|if
condition|(
name|isprint
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
operator|||
name|isspace
argument_list|(
name|c
index|[
name|i
index|]
argument_list|)
operator|||
name|c
index|[
name|i
index|]
operator|==
literal|'\b'
operator|||
name|c
index|[
name|i
index|]
operator|==
literal|'\a'
condition|)
continue|continue;
if|if
condition|(
name|c
index|[
name|i
index|]
operator|==
literal|'\0'
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
comment|/* 			 * This looks like it might be a string.  Before we 			 * assume that it is indeed a string, check the 			 * remainder of the byte range; if it contains 			 * additional non-nul characters, we'll assume that 			 * it's a binary stream that just happens to look like 			 * a string, and we'll print out the individual bytes. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nbytes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|c
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|!=
name|nbytes
condition|)
break|break;
if|if
condition|(
name|quiet
condition|)
block|{
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %s%*s"
argument_list|,
name|width
operator|<
literal|0
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|width
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|nbytes
condition|)
block|{
comment|/* 		 * The byte range is all printable characters, but there is 		 * no trailing nul byte.  We'll assume that it's a string and 		 * print it as such. 		 */
name|char
modifier|*
name|s
init|=
name|alloca
argument_list|(
name|nbytes
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|c
argument_list|,
name|s
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|s
index|[
name|nbytes
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"  %-*s"
argument_list|,
name|width
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
name|raw
label|:
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n%*s      "
argument_list|,
name|margin
argument_list|,
literal|""
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"  %c"
argument_list|,
literal|"0123456789abcdef"
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"  0123456789abcdef\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|+=
literal|16
control|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%*s%5x:"
argument_list|,
name|margin
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|i
operator|+
literal|16
operator|&&
name|j
operator|<
name|nbytes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|uchar_t
operator|)
name|c
index|[
name|j
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|j
operator|++
operator|%
literal|16
condition|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"   "
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"  "
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|i
operator|+
literal|16
operator|&&
name|j
operator|<
name|nbytes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%c"
argument_list|,
name|c
index|[
name|j
index|]
operator|<
literal|' '
operator|||
name|c
index|[
name|j
index|]
operator|>
literal|'~'
condition|?
literal|'.'
else|:
name|c
index|[
name|j
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_stack
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|dtrace_syminfo_t
name|dts
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|,
name|indent
decl_stmt|;
name|char
name|c
index|[
name|PATH_MAX
operator|*
literal|2
index|]
decl_stmt|;
name|uint64_t
name|pc
decl_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|format
operator|==
name|NULL
condition|)
name|format
operator|=
literal|"%s"
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKINDENT
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|indent
operator|=
operator|(
name|int
operator|)
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKINDENT
index|]
expr_stmt|;
else|else
name|indent
operator|=
name|_dtrace_stkindent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|pc
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|pc
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSTACKPC
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pc
operator|==
name|NULL
condition|)
break|break;
name|addr
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%*s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
name|pc
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pc
operator|>
name|sym
operator|.
name|st_value
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`%s+0x%llx"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|,
name|pc
operator|-
name|sym
operator|.
name|st_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`%s"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We'll repeat the lookup, but this time we'll specify 			 * a NULL GElf_Sym -- indicating that we're only 			 * interested in the containing module. 			 */
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`0x%llx"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_ustack
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
comment|/* LINTED - alignment */
name|uint64_t
modifier|*
name|pc
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|addr
decl_stmt|;
name|uint32_t
name|depth
init|=
name|DTRACE_USTACK_NFRAMES
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint32_t
name|strsize
init|=
name|DTRACE_USTACK_STRSIZE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|strbase
init|=
name|addr
operator|+
operator|(
name|depth
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
init|=
name|strsize
condition|?
name|strbase
else|:
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|objname
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|c
index|[
name|PATH_MAX
operator|*
literal|2
index|]
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|,
name|indent
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pid
operator|=
operator|(
name|pid_t
operator|)
operator|*
name|pc
operator|++
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|format
operator|==
name|NULL
condition|)
name|format
operator|=
literal|"%s"
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKINDENT
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|indent
operator|=
operator|(
name|int
operator|)
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_STACKINDENT
index|]
expr_stmt|;
else|else
name|indent
operator|=
name|_dtrace_stkindent
expr_stmt|;
comment|/* 	 * Ultimately, we need to add an entry point in the library vector for 	 * determining<symbol, offset> from<pid, address>.  For now, if 	 * this is a vector open, we just print the raw address or string. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_vector
operator|==
name|NULL
condition|)
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|P
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|P
operator|!=
name|NULL
condition|)
name|dt_proc_lock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
comment|/* lock handle while we perform lookups */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
operator|&&
name|pc
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|prmap_t
modifier|*
name|map
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%*s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|P
operator|!=
name|NULL
operator|&&
name|Plookup_by_addr
argument_list|(
name|P
argument_list|,
name|pc
index|[
name|i
index|]
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Pobjname
argument_list|(
name|P
argument_list|,
name|pc
index|[
name|i
index|]
argument_list|,
name|objname
argument_list|,
sizeof|sizeof
argument_list|(
name|objname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
index|[
name|i
index|]
operator|>
name|sym
operator|.
name|st_value
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`%s+0x%llx"
argument_list|,
name|dt_basename
argument_list|(
name|objname
argument_list|)
argument_list|,
name|name
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|pc
index|[
name|i
index|]
operator|-
name|sym
operator|.
name|st_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`%s"
argument_list|,
name|dt_basename
argument_list|(
name|objname
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|str
operator|!=
name|NULL
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|str
index|[
literal|0
index|]
operator|!=
literal|'@'
operator|&&
operator|(
name|P
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|map
operator|=
name|Paddr_to_map
argument_list|(
name|P
argument_list|,
name|pc
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|map
operator|->
name|pr_mflags
operator|&
name|MA_WRITE
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 			 * If the current string pointer in the string table 			 * does not point to an empty string _and_ the program 			 * counter falls in a writable region, we'll use the 			 * string from the string table instead of the raw 			 * address.  This last condition is necessary because 			 * some (broken) ustack helpers will return a string 			 * even for a program counter that they can't 			 * identify.  If we have a string for a program 			 * counter that falls in a segment that isn't 			 * writable, we assume that we have fallen into this 			 * case and we refuse to use the string. 			 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|P
operator|!=
name|NULL
operator|&&
name|Pobjname
argument_list|(
name|P
argument_list|,
name|pc
index|[
name|i
index|]
argument_list|,
name|objname
argument_list|,
sizeof|sizeof
argument_list|(
name|objname
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`0x%llx"
argument_list|,
name|dt_basename
argument_list|(
name|objname
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|c
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|str
operator|!=
name|NULL
operator|&&
name|str
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* 			 * If the first character of the string is an "at" sign, 			 * then the string is inferred to be an annotation -- 			 * and it is printed out beneath the frame and offset 			 * with brackets. 			 */
if|if
condition|(
operator|(
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"%*s"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"  [ %s ]"
argument_list|,
operator|&
name|str
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|c
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|str
operator|-
name|strbase
operator|>=
name|strsize
condition|)
name|str
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|P
operator|!=
name|NULL
condition|)
block|{
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_print_usym
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|dtrace_actkind_t
name|act
parameter_list|)
block|{
comment|/* LINTED - alignment */
name|uint64_t
name|pid
init|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
index|[
literal|0
index|]
decl_stmt|;
comment|/* LINTED - alignment */
name|uint64_t
name|pc
init|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
init|=
literal|"  %-50s"
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
init|=
literal|256
decl_stmt|;
if|if
condition|(
name|act
operator|==
name|DTRACEACT_USYM
operator|&&
name|dtp
operator|->
name|dt_vector
operator|==
name|NULL
condition|)
block|{
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
if|if
condition|(
operator|(
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|GElf_Sym
name|sym
decl_stmt|;
name|dt_proc_lock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
if|if
condition|(
name|Plookup_by_addr
argument_list|(
name|P
argument_list|,
name|pc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
condition|)
name|pc
operator|=
name|sym
operator|.
name|st_value
expr_stmt|;
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
block|}
do|do
block|{
name|n
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|alloca
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|len
operator|=
name|dtrace_uaddr2str
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|pc
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
operator|)
operator|>
name|n
condition|)
do|;
return|return
operator|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_umod
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|caddr_t
name|addr
parameter_list|)
block|{
comment|/* LINTED - alignment */
name|uint64_t
name|pid
init|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
index|[
literal|0
index|]
decl_stmt|;
comment|/* LINTED - alignment */
name|uint64_t
name|pc
init|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
index|[
literal|1
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|objname
index|[
name|PATH_MAX
index|]
decl_stmt|,
name|c
index|[
name|PATH_MAX
operator|*
literal|2
index|]
decl_stmt|;
name|struct
name|ps_prochandle
modifier|*
name|P
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|NULL
condition|)
name|format
operator|=
literal|"  %-50s"
expr_stmt|;
comment|/* 	 * See the comment in dt_print_ustack() for the rationale for 	 * printing raw addresses in the vectored case. 	 */
if|if
condition|(
name|dtp
operator|->
name|dt_vector
operator|==
name|NULL
condition|)
name|P
operator|=
name|dt_proc_grab
argument_list|(
name|dtp
argument_list|,
name|pid
argument_list|,
name|PGRAB_RDONLY
operator||
name|PGRAB_FORCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|P
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|P
operator|!=
name|NULL
condition|)
name|dt_proc_lock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
comment|/* lock handle while we perform lookups */
if|if
condition|(
name|P
operator|!=
name|NULL
operator|&&
name|Pobjname
argument_list|(
name|P
argument_list|,
name|pc
argument_list|,
name|objname
argument_list|,
sizeof|sizeof
argument_list|(
name|objname
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|dt_basename
argument_list|(
name|objname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pc
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|P
operator|!=
name|NULL
condition|)
block|{
name|dt_proc_unlock
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
name|dt_proc_release
argument_list|(
name|dtp
argument_list|,
name|P
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_print_sym
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|caddr_t
name|addr
parameter_list|)
block|{
comment|/* LINTED - alignment */
name|uint64_t
name|pc
init|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
decl_stmt|;
name|dtrace_syminfo_t
name|dts
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|char
name|c
index|[
name|PATH_MAX
operator|*
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|NULL
condition|)
name|format
operator|=
literal|"  %-50s"
expr_stmt|;
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
name|pc
argument_list|,
operator|&
name|sym
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`%s"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
name|dts
operator|.
name|dts_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We'll repeat the lookup, but this time we'll specify a 		 * NULL GElf_Sym -- indicating that we're only interested in 		 * the containing module. 		 */
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s`0x%llx"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_mod
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|caddr_t
name|addr
parameter_list|)
block|{
comment|/* LINTED - alignment */
name|uint64_t
name|pc
init|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
decl_stmt|;
name|dtrace_syminfo_t
name|dts
decl_stmt|;
name|char
name|c
index|[
name|PATH_MAX
operator|*
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|NULL
condition|)
name|format
operator|=
literal|"  %-50s"
expr_stmt|;
if|if
condition|(
name|dtrace_lookup_by_addr
argument_list|(
name|dtp
argument_list|,
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|dts
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|dts
operator|.
name|dts_object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|format
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dt_normal
block|{
name|dtrace_aggvarid_t
name|dtnd_id
decl_stmt|;
name|uint64_t
name|dtnd_normal
decl_stmt|;
block|}
name|dt_normal_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|dt_normalize_agg
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_normal_t
modifier|*
name|normal
init|=
name|arg
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
name|dtrace_aggvarid_t
name|id
init|=
name|normal
operator|->
name|dtnd_id
decl_stmt|;
if|if
condition|(
name|agg
operator|->
name|dtagd_nrecs
operator|==
literal|0
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
if|if
condition|(
name|agg
operator|->
name|dtagd_varid
operator|!=
name|id
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
operator|(
operator|(
name|dtrace_aggdata_t
operator|*
operator|)
name|aggdata
operator|)
operator|->
name|dtada_normal
operator|=
name|normal
operator|->
name|dtnd_normal
expr_stmt|;
return|return
operator|(
name|DTRACE_AGGWALK_NORMALIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_normalize
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|caddr_t
name|base
parameter_list|,
name|dtrace_recdesc_t
modifier|*
name|rec
parameter_list|)
block|{
name|dt_normal_t
name|normal
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
comment|/* 	 * We (should) have two records:  the aggregation ID followed by the 	 * normalization value. 	 */
name|addr
operator|=
name|base
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_size
operator|!=
sizeof|sizeof
argument_list|(
name|dtrace_aggvarid_t
argument_list|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADNORMAL
argument_list|)
operator|)
return|;
comment|/* LINTED - alignment */
name|normal
operator|.
name|dtnd_id
operator|=
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
name|rec
operator|++
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_action
operator|!=
name|DTRACEACT_LIBACT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADNORMAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|rec
operator|->
name|dtrd_arg
operator|!=
name|DT_ACT_NORMALIZE
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADNORMAL
argument_list|)
operator|)
return|;
name|addr
operator|=
name|base
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|dtrd_size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|normal
operator|.
name|dtnd_normal
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|normal
operator|.
name|dtnd_normal
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|normal
operator|.
name|dtnd_normal
operator|=
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
name|normal
operator|.
name|dtnd_normal
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADNORMAL
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|dtrace_aggregate_walk
argument_list|(
name|dtp
argument_list|,
name|dt_normalize_agg
argument_list|,
operator|&
name|normal
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_denormalize_agg
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
name|dtrace_aggvarid_t
name|id
init|=
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
if|if
condition|(
name|agg
operator|->
name|dtagd_nrecs
operator|==
literal|0
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
if|if
condition|(
name|agg
operator|->
name|dtagd_varid
operator|!=
name|id
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
return|return
operator|(
name|DTRACE_AGGWALK_DENORMALIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_clear_agg
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
name|dtrace_aggvarid_t
name|id
init|=
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
if|if
condition|(
name|agg
operator|->
name|dtagd_nrecs
operator|==
literal|0
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
if|if
condition|(
name|agg
operator|->
name|dtagd_varid
operator|!=
name|id
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
return|return
operator|(
name|DTRACE_AGGWALK_CLEAR
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dt_trunc
block|{
name|dtrace_aggvarid_t
name|dttd_id
decl_stmt|;
name|uint64_t
name|dttd_remaining
decl_stmt|;
block|}
name|dt_trunc_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|dt_trunc_agg
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_trunc_t
modifier|*
name|trunc
init|=
name|arg
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
name|dtrace_aggvarid_t
name|id
init|=
name|trunc
operator|->
name|dttd_id
decl_stmt|;
if|if
condition|(
name|agg
operator|->
name|dtagd_nrecs
operator|==
literal|0
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
if|if
condition|(
name|agg
operator|->
name|dtagd_varid
operator|!=
name|id
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
if|if
condition|(
name|trunc
operator|->
name|dttd_remaining
operator|==
literal|0
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_REMOVE
operator|)
return|;
name|trunc
operator|->
name|dttd_remaining
operator|--
expr_stmt|;
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_trunc
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|caddr_t
name|base
parameter_list|,
name|dtrace_recdesc_t
modifier|*
name|rec
parameter_list|)
block|{
name|dt_trunc_t
name|trunc
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int64_t
name|remaining
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|dtrace_aggregate_f
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* 	 * We (should) have two records:  the aggregation ID followed by the 	 * number of aggregation entries after which the aggregation is to be 	 * truncated. 	 */
name|addr
operator|=
name|base
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_size
operator|!=
sizeof|sizeof
argument_list|(
name|dtrace_aggvarid_t
argument_list|)
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADTRUNC
argument_list|)
operator|)
return|;
comment|/* LINTED - alignment */
name|trunc
operator|.
name|dttd_id
operator|=
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
name|rec
operator|++
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_action
operator|!=
name|DTRACEACT_LIBACT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADTRUNC
argument_list|)
operator|)
return|;
if|if
condition|(
name|rec
operator|->
name|dtrd_arg
operator|!=
name|DT_ACT_TRUNC
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADTRUNC
argument_list|)
operator|)
return|;
name|addr
operator|=
name|base
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|dtrd_size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|remaining
operator|=
operator|*
operator|(
operator|(
name|int64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|remaining
operator|=
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|remaining
operator|=
operator|*
operator|(
operator|(
name|int16_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
name|remaining
operator|=
operator|*
operator|(
operator|(
name|int8_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADNORMAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|remaining
operator|<
literal|0
condition|)
block|{
name|func
operator|=
name|dtrace_aggregate_walk_valsorted
expr_stmt|;
name|remaining
operator|=
operator|-
name|remaining
expr_stmt|;
block|}
else|else
block|{
name|func
operator|=
name|dtrace_aggregate_walk_valrevsorted
expr_stmt|;
block|}
name|assert
argument_list|(
name|remaining
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|trunc
operator|.
name|dttd_remaining
operator|=
name|remaining
expr_stmt|;
operator|(
name|void
operator|)
name|func
argument_list|(
name|dtp
argument_list|,
name|dt_trunc_agg
argument_list|,
operator|&
name|trunc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_print_datum
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|dtrace_recdesc_t
modifier|*
name|rec
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|,
name|uint64_t
name|normal
parameter_list|,
name|dt_print_aggdata_t
modifier|*
name|pd
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|width
decl_stmt|;
name|dtrace_actkind_t
name|act
init|=
name|rec
operator|->
name|dtrd_action
decl_stmt|;
name|boolean_t
name|packed
init|=
name|pd
operator|->
name|dtpa_agghist
operator|||
name|pd
operator|->
name|dtpa_aggpack
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
specifier|static
struct|struct
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|packedwidth
decl_stmt|;
block|}
modifier|*
name|fmt
struct|,
name|fmttab
index|[]
init|=
block|{
block|{
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
block|,
literal|5
block|,
literal|5
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
block|,
literal|8
block|,
literal|8
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
literal|16
block|,
literal|16
block|}
block|,
block|{
literal|0
block|,
operator|-
literal|50
block|,
literal|16
block|}
block|}
struct|;
if|if
condition|(
name|packed
operator|&&
name|pd
operator|->
name|dtpa_agghisthdr
operator|!=
name|agg
operator|->
name|dtagd_varid
condition|)
block|{
name|dtrace_recdesc_t
modifier|*
name|r
decl_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
comment|/* 		 * To print our quantization header for either an agghist or 		 * aggpack aggregation, we need to iterate through all of our 		 * of our records to determine their width. 		 */
for|for
control|(
name|r
operator|=
name|rec
init|;
operator|!
name|DTRACEACT_ISAGG
argument_list|(
name|r
operator|->
name|dtrd_action
argument_list|)
condition|;
name|r
operator|++
control|)
block|{
for|for
control|(
name|fmt
operator|=
name|fmttab
init|;
name|fmt
operator|->
name|size
operator|&&
name|fmt
operator|->
name|size
operator|!=
name|r
operator|->
name|dtrd_size
condition|;
name|fmt
operator|++
control|)
continue|continue;
name|width
operator|+=
name|fmt
operator|->
name|packedwidth
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pd
operator|->
name|dtpa_agghist
condition|)
block|{
if|if
condition|(
name|dt_print_quanthdr
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|width
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|dt_print_quanthdr_packed
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|width
argument_list|,
name|aggdata
argument_list|,
name|r
operator|->
name|dtrd_action
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pd
operator|->
name|dtpa_agghisthdr
operator|=
name|agg
operator|->
name|dtagd_varid
expr_stmt|;
block|}
if|if
condition|(
name|pd
operator|->
name|dtpa_agghist
operator|&&
name|DTRACEACT_ISAGG
argument_list|(
name|act
argument_list|)
condition|)
block|{
name|char
name|positives
init|=
name|aggdata
operator|->
name|dtada_flags
operator|&
name|DTRACE_A_HASPOSITIVES
decl_stmt|;
name|char
name|negatives
init|=
name|aggdata
operator|->
name|dtada_flags
operator|&
name|DTRACE_A_HASNEGATIVES
decl_stmt|;
name|int64_t
name|val
decl_stmt|;
name|assert
argument_list|(
name|act
operator|==
name|DTRACEAGG_SUM
operator|||
name|act
operator|==
name|DTRACEAGG_COUNT
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|long
name|long
operator|)
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" "
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|dt_print_quantline
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|val
argument_list|,
name|normal
argument_list|,
name|aggdata
operator|->
name|dtada_total
argument_list|,
name|positives
argument_list|,
name|negatives
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pd
operator|->
name|dtpa_aggpack
operator|&&
name|DTRACEACT_ISAGG
argument_list|(
name|act
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DTRACEAGG_QUANTIZE
case|:
return|return
operator|(
name|dt_print_quantize_packed
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|aggdata
argument_list|)
operator|)
return|;
case|case
name|DTRACEAGG_LQUANTIZE
case|:
return|return
operator|(
name|dt_print_lquantize_packed
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|aggdata
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DTRACEACT_STACK
case|:
return|return
operator|(
name|dt_print_stack
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_arg
argument_list|,
name|rec
operator|->
name|dtrd_size
operator|/
name|rec
operator|->
name|dtrd_arg
argument_list|)
operator|)
return|;
case|case
name|DTRACEACT_USTACK
case|:
case|case
name|DTRACEACT_JSTACK
case|:
return|return
operator|(
name|dt_print_ustack
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_arg
argument_list|)
operator|)
return|;
case|case
name|DTRACEACT_USYM
case|:
case|case
name|DTRACEACT_UADDR
case|:
return|return
operator|(
name|dt_print_usym
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|act
argument_list|)
operator|)
return|;
case|case
name|DTRACEACT_UMOD
case|:
return|return
operator|(
name|dt_print_umod
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|)
operator|)
return|;
case|case
name|DTRACEACT_SYM
case|:
return|return
operator|(
name|dt_print_sym
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|)
operator|)
return|;
case|case
name|DTRACEACT_MOD
case|:
return|return
operator|(
name|dt_print_mod
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|)
operator|)
return|;
case|case
name|DTRACEAGG_QUANTIZE
case|:
return|return
operator|(
name|dt_print_quantize
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
case|case
name|DTRACEAGG_LQUANTIZE
case|:
return|return
operator|(
name|dt_print_lquantize
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
case|case
name|DTRACEAGG_LLQUANTIZE
case|:
return|return
operator|(
name|dt_print_llquantize
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
case|case
name|DTRACEAGG_AVG
case|:
return|return
operator|(
name|dt_print_average
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
case|case
name|DTRACEAGG_STDDEV
case|:
return|return
operator|(
name|dt_print_stddev
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|normal
argument_list|)
operator|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|fmt
operator|=
name|fmttab
init|;
name|fmt
operator|->
name|size
operator|&&
name|fmt
operator|->
name|size
operator|!=
name|size
condition|;
name|fmt
operator|++
control|)
continue|continue;
name|width
operator|=
name|packed
condition|?
name|fmt
operator|->
name|packedwidth
else|:
name|fmt
operator|->
name|width
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %*lld"
argument_list|,
name|width
argument_list|,
comment|/* LINTED - alignment */
operator|(
name|long
name|long
operator|)
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
operator|/
name|normal
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %*d"
argument_list|,
name|width
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
operator|/
operator|(
name|uint32_t
operator|)
name|normal
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
comment|/* LINTED - alignment */
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %*d"
argument_list|,
name|width
argument_list|,
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|)
operator|/
operator|(
name|uint32_t
operator|)
name|normal
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
name|err
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|" %*d"
argument_list|,
name|width
argument_list|,
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|addr
operator|)
operator|/
operator|(
name|uint32_t
operator|)
name|normal
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|dt_print_bytes
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|width
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_aggs
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
modifier|*
name|aggsdata
parameter_list|,
name|int
name|naggvars
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|aggact
init|=
literal|0
decl_stmt|;
name|dt_print_aggdata_t
modifier|*
name|pd
init|=
name|arg
decl_stmt|;
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
init|=
name|aggsdata
index|[
literal|0
index|]
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|pd
operator|->
name|dtpa_fp
decl_stmt|;
name|dtrace_hdl_t
modifier|*
name|dtp
init|=
name|pd
operator|->
name|dtpa_dtp
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|dtrace_actkind_t
name|act
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|pd
operator|->
name|dtpa_agghist
operator|=
operator|(
name|aggdata
operator|->
name|dtada_flags
operator|&
name|DTRACE_A_TOTAL
operator|)
expr_stmt|;
name|pd
operator|->
name|dtpa_aggpack
operator|=
operator|(
name|aggdata
operator|->
name|dtada_flags
operator|&
name|DTRACE_A_MINMAXBIN
operator|)
expr_stmt|;
comment|/* 	 * Iterate over each record description in the key, printing the traced 	 * data, skipping the first datum (the tuple member created by the 	 * compiler). 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|agg
operator|->
name|dtagd_nrecs
condition|;
name|i
operator|++
control|)
block|{
name|rec
operator|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
name|i
index|]
expr_stmt|;
name|act
operator|=
name|rec
operator|->
name|dtrd_action
expr_stmt|;
name|addr
operator|=
name|aggdata
operator|->
name|dtada_data
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
name|size
operator|=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
argument_list|)
condition|)
block|{
name|aggact
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dt_print_datum
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|rec
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|aggdata
argument_list|,
literal|1
argument_list|,
name|pd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dt_buffered_flush
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|rec
argument_list|,
name|aggdata
argument_list|,
name|DTRACE_BUFDATA_AGGKEY
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|assert
argument_list|(
name|aggact
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|naggvars
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
init|;
name|i
operator|<
name|naggvars
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|normal
decl_stmt|;
name|aggdata
operator|=
name|aggsdata
index|[
name|i
index|]
expr_stmt|;
name|agg
operator|=
name|aggdata
operator|->
name|dtada_desc
expr_stmt|;
name|rec
operator|=
operator|&
name|agg
operator|->
name|dtagd_rec
index|[
name|aggact
index|]
expr_stmt|;
name|act
operator|=
name|rec
operator|->
name|dtrd_action
expr_stmt|;
name|addr
operator|=
name|aggdata
operator|->
name|dtada_data
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
name|size
operator|=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
name|assert
argument_list|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
argument_list|)
argument_list|)
expr_stmt|;
name|normal
operator|=
name|aggdata
operator|->
name|dtada_normal
expr_stmt|;
if|if
condition|(
name|dt_print_datum
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|rec
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|aggdata
argument_list|,
name|normal
argument_list|,
name|pd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dt_buffered_flush
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|rec
argument_list|,
name|aggdata
argument_list|,
name|DTRACE_BUFDATA_AGGVAL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|pd
operator|->
name|dtpa_allunprint
condition|)
name|agg
operator|->
name|dtagd_flags
operator||=
name|DTRACE_AGD_PRINTED
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pd
operator|->
name|dtpa_agghist
operator|&&
operator|!
name|pd
operator|->
name|dtpa_aggpack
condition|)
block|{
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dt_buffered_flush
argument_list|(
name|dtp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|aggdata
argument_list|,
name|DTRACE_BUFDATA_AGGFORMAT
operator||
name|DTRACE_BUFDATA_AGGLAST
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_print_agg
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|aggdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_print_aggdata_t
modifier|*
name|pd
init|=
name|arg
decl_stmt|;
name|dtrace_aggdesc_t
modifier|*
name|agg
init|=
name|aggdata
operator|->
name|dtada_desc
decl_stmt|;
name|dtrace_aggvarid_t
name|aggvarid
init|=
name|pd
operator|->
name|dtpa_id
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|dtpa_allunprint
condition|)
block|{
if|if
condition|(
name|agg
operator|->
name|dtagd_flags
operator|&
name|DTRACE_AGD_PRINTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * If we're not printing all unprinted aggregations, then the 		 * aggregation variable ID denotes a specific aggregation 		 * variable that we should print -- skip any other aggregations 		 * that we encounter. 		 */
if|if
condition|(
name|agg
operator|->
name|dtagd_nrecs
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|aggvarid
operator|!=
name|agg
operator|->
name|dtagd_varid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dt_print_aggs
argument_list|(
operator|&
name|aggdata
argument_list|,
literal|1
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_setopt
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|char
modifier|*
name|option
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|dtrace_setoptdata_t
name|optdata
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|optdata
argument_list|,
sizeof|sizeof
argument_list|(
name|optdata
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|dtp
argument_list|,
name|option
argument_list|,
operator|&
name|optdata
operator|.
name|dtsda_oldval
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|dtp
argument_list|,
name|option
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|dtp
argument_list|,
name|option
argument_list|,
operator|&
name|optdata
operator|.
name|dtsda_newval
argument_list|)
expr_stmt|;
name|optdata
operator|.
name|dtsda_probe
operator|=
name|data
expr_stmt|;
name|optdata
operator|.
name|dtsda_option
operator|=
name|option
expr_stmt|;
name|optdata
operator|.
name|dtsda_handle
operator|=
name|dtp
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_handle_setopt
argument_list|(
name|dtp
argument_list|,
operator|&
name|optdata
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|errstr
operator|=
name|dtrace_errmsg
argument_list|(
name|dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|dtp
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|option
argument_list|)
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
name|strlen
argument_list|(
name|errstr
argument_list|)
operator|+
literal|80
expr_stmt|;
name|msg
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|msg
argument_list|,
name|len
argument_list|,
literal|"couldn't set option \"%s\" to \"%s\": %s\n"
argument_list|,
name|option
argument_list|,
name|value
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_handle_liberr
argument_list|(
name|dtp
argument_list|,
name|data
argument_list|,
name|msg
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_consume_cpu
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|cpu
parameter_list|,
name|dtrace_bufdesc_t
modifier|*
name|buf
parameter_list|,
name|boolean_t
name|just_one
parameter_list|,
name|dtrace_consume_probe_f
modifier|*
name|efunc
parameter_list|,
name|dtrace_consume_rec_f
modifier|*
name|rfunc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_epid_t
name|id
decl_stmt|;
name|size_t
name|offs
decl_stmt|;
name|int
name|flow
init|=
operator|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_FLOWINDENT
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|)
decl_stmt|;
name|int
name|quiet
init|=
operator|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_QUIET
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|)
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|uint64_t
name|tracememsize
init|=
literal|0
decl_stmt|;
name|dtrace_probedata_t
name|data
decl_stmt|;
name|uint64_t
name|drops
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|dtpda_handle
operator|=
name|dtp
expr_stmt|;
name|data
operator|.
name|dtpda_cpu
operator|=
name|cpu
expr_stmt|;
name|data
operator|.
name|dtpda_flow
operator|=
name|dtp
operator|->
name|dt_flow
expr_stmt|;
name|data
operator|.
name|dtpda_indent
operator|=
name|dtp
operator|->
name|dt_indent
expr_stmt|;
name|data
operator|.
name|dtpda_prefix
operator|=
name|dtp
operator|->
name|dt_prefix
expr_stmt|;
for|for
control|(
name|offs
operator|=
name|buf
operator|->
name|dtbd_oldest
init|;
name|offs
operator|<
name|buf
operator|->
name|dtbd_size
condition|;
control|)
block|{
name|dtrace_eprobedesc_t
modifier|*
name|epd
decl_stmt|;
comment|/* 		 * We're guaranteed to have an ID. 		 */
name|id
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|DTRACE_EPIDNONE
condition|)
block|{
comment|/* 			 * This is filler to assure proper alignment of the 			 * next record; we simply ignore it. 			 */
name|offs
operator|+=
sizeof|sizeof
argument_list|(
name|id
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_epid_lookup
argument_list|(
name|dtp
argument_list|,
name|id
argument_list|,
operator|&
name|data
operator|.
name|dtpda_edesc
argument_list|,
operator|&
name|data
operator|.
name|dtpda_pdesc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|epd
operator|=
name|data
operator|.
name|dtpda_edesc
expr_stmt|;
name|data
operator|.
name|dtpda_data
operator|=
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|dtpda_edesc
operator|->
name|dtepd_uarg
operator|!=
name|DT_ECB_DEFAULT
condition|)
block|{
name|rval
operator|=
name|dt_handle
argument_list|(
name|dtp
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|DTRACE_CONSUME_NEXT
condition|)
goto|goto
name|nextepid
goto|;
if|if
condition|(
name|rval
operator|==
name|DTRACE_CONSUME_ERROR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|flow
condition|)
operator|(
name|void
operator|)
name|dt_flowindent
argument_list|(
name|dtp
argument_list|,
operator|&
name|data
argument_list|,
name|dtp
operator|->
name|dt_last_epid
argument_list|,
name|buf
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|rval
operator|=
call|(
modifier|*
name|efunc
call|)
argument_list|(
operator|&
name|data
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|dtpda_flow
operator|==
name|DTRACEFLOW_ENTRY
condition|)
name|data
operator|.
name|dtpda_indent
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|==
name|DTRACE_CONSUME_NEXT
condition|)
goto|goto
name|nextepid
goto|;
if|if
condition|(
name|rval
operator|==
name|DTRACE_CONSUME_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DIRABORT
argument_list|)
operator|)
return|;
if|if
condition|(
name|rval
operator|!=
name|DTRACE_CONSUME_THIS
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADRVAL
argument_list|)
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|epd
operator|->
name|dtepd_nrecs
condition|;
name|i
operator|++
control|)
block|{
name|caddr_t
name|addr
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
operator|&
name|epd
operator|->
name|dtepd_rec
index|[
name|i
index|]
decl_stmt|;
name|dtrace_actkind_t
name|act
init|=
name|rec
operator|->
name|dtrd_action
decl_stmt|;
name|data
operator|.
name|dtpda_data
operator|=
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
name|addr
operator|=
name|data
operator|.
name|dtpda_data
expr_stmt|;
if|if
condition|(
name|act
operator|==
name|DTRACEACT_LIBACT
condition|)
block|{
name|uint64_t
name|arg
init|=
name|rec
operator|->
name|dtrd_arg
decl_stmt|;
name|dtrace_aggvarid_t
name|id
decl_stmt|;
switch|switch
condition|(
name|arg
condition|)
block|{
case|case
name|DT_ACT_CLEAR
case|:
comment|/* LINTED - alignment */
name|id
operator|=
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_aggregate_walk
argument_list|(
name|dtp
argument_list|,
name|dt_clear_agg
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_DENORMALIZE
case|:
comment|/* LINTED - alignment */
name|id
operator|=
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_aggregate_walk
argument_list|(
name|dtp
argument_list|,
name|dt_denormalize_agg
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_FTRUNCATE
case|:
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseeko
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_NORMALIZE
case|:
if|if
condition|(
name|i
operator|==
name|epd
operator|->
name|dtepd_nrecs
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADNORMAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|dt_normalize
argument_list|(
name|dtp
argument_list|,
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
argument_list|,
name|rec
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|++
expr_stmt|;
continue|continue;
case|case
name|DT_ACT_SETOPT
case|:
block|{
name|uint64_t
modifier|*
name|opts
init|=
name|dtp
operator|->
name|dt_options
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|valrec
decl_stmt|;
name|uint32_t
name|valsize
decl_stmt|;
name|caddr_t
name|val
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|epd
operator|->
name|dtepd_nrecs
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSETOPT
argument_list|)
operator|)
return|;
block|}
name|valrec
operator|=
operator|&
name|epd
operator|->
name|dtepd_rec
index|[
operator|++
name|i
index|]
expr_stmt|;
name|valsize
operator|=
name|valrec
operator|->
name|dtrd_size
expr_stmt|;
if|if
condition|(
name|valrec
operator|->
name|dtrd_action
operator|!=
name|act
operator|||
name|valrec
operator|->
name|dtrd_arg
operator|!=
name|arg
condition|)
block|{
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADSETOPT
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|valsize
operator|>
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|val
operator|=
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
operator|+
name|valrec
operator|->
name|dtrd_offset
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
literal|"1"
expr_stmt|;
block|}
name|rv
operator|=
name|dt_setopt
argument_list|(
name|dtp
argument_list|,
operator|&
name|data
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|flow
operator|=
operator|(
name|opts
index|[
name|DTRACEOPT_FLOWINDENT
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|)
expr_stmt|;
name|quiet
operator|=
operator|(
name|opts
index|[
name|DTRACEOPT_QUIET
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|)
expr_stmt|;
continue|continue;
block|}
case|case
name|DT_ACT_TRUNC
case|:
if|if
condition|(
name|i
operator|==
name|epd
operator|->
name|dtepd_nrecs
operator|-
literal|1
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADTRUNC
argument_list|)
operator|)
return|;
if|if
condition|(
name|dt_trunc
argument_list|(
name|dtp
argument_list|,
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
argument_list|,
name|rec
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|++
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
block|}
if|if
condition|(
name|act
operator|==
name|DTRACEACT_TRACEMEM_DYNSIZE
operator|&&
name|rec
operator|->
name|dtrd_size
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
comment|/* LINTED - alignment */
name|tracememsize
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
continue|continue;
block|}
name|rval
operator|=
call|(
modifier|*
name|rfunc
call|)
argument_list|(
operator|&
name|data
argument_list|,
name|rec
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|DTRACE_CONSUME_NEXT
condition|)
continue|continue;
if|if
condition|(
name|rval
operator|==
name|DTRACE_CONSUME_ABORT
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_DIRABORT
argument_list|)
operator|)
return|;
if|if
condition|(
name|rval
operator|!=
name|DTRACE_CONSUME_THIS
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADRVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|act
operator|==
name|DTRACEACT_STACK
condition|)
block|{
name|int
name|depth
init|=
name|rec
operator|->
name|dtrd_arg
decl_stmt|;
if|if
condition|(
name|dt_print_stack
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|,
name|depth
argument_list|,
name|rec
operator|->
name|dtrd_size
operator|/
name|depth
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|act
operator|==
name|DTRACEACT_USTACK
operator|||
name|act
operator|==
name|DTRACEACT_JSTACK
condition|)
block|{
if|if
condition|(
name|dt_print_ustack
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_arg
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|act
operator|==
name|DTRACEACT_SYM
condition|)
block|{
if|if
condition|(
name|dt_print_sym
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|act
operator|==
name|DTRACEACT_MOD
condition|)
block|{
if|if
condition|(
name|dt_print_mod
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|act
operator|==
name|DTRACEACT_USYM
operator|||
name|act
operator|==
name|DTRACEACT_UADDR
condition|)
block|{
if|if
condition|(
name|dt_print_usym
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|act
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|act
operator|==
name|DTRACEACT_UMOD
condition|)
block|{
if|if
condition|(
name|dt_print_umod
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|DTRACEACT_ISPRINTFLIKE
argument_list|(
name|act
argument_list|)
condition|)
block|{
name|void
modifier|*
name|fmtdata
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|dtrace_hdl_t
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|dtrace_probedata_t
modifier|*
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
if|if
condition|(
operator|(
name|fmtdata
operator|=
name|dt_format_lookup
argument_list|(
name|dtp
argument_list|,
name|rec
operator|->
name|dtrd_format
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|nofmt
goto|;
switch|switch
condition|(
name|act
condition|)
block|{
case|case
name|DTRACEACT_PRINTF
case|:
name|func
operator|=
name|dtrace_fprintf
expr_stmt|;
break|break;
case|case
name|DTRACEACT_PRINTA
case|:
name|func
operator|=
name|dtrace_fprinta
expr_stmt|;
break|break;
case|case
name|DTRACEACT_SYSTEM
case|:
name|func
operator|=
name|dtrace_system
expr_stmt|;
break|break;
case|case
name|DTRACEACT_FREOPEN
case|:
name|func
operator|=
name|dtrace_freopen
expr_stmt|;
break|break;
block|}
name|n
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|fmtdata
argument_list|,
operator|&
name|data
argument_list|,
name|rec
argument_list|,
name|epd
operator|->
name|dtepd_nrecs
operator|-
name|i
argument_list|,
operator|(
name|uchar_t
operator|*
operator|)
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
argument_list|,
name|buf
operator|->
name|dtbd_size
operator|-
name|offs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|i
operator|+=
name|n
operator|-
literal|1
expr_stmt|;
goto|goto
name|nextrec
goto|;
block|}
comment|/* 			 * If this is a DIF expression, and the record has a 			 * format set, this indicates we have a CTF type name 			 * associated with the data and we should try to print 			 * it out by type. 			 */
if|if
condition|(
name|act
operator|==
name|DTRACEACT_DIFEXPR
condition|)
block|{
specifier|const
name|char
modifier|*
name|strdata
init|=
name|dt_strdata_lookup
argument_list|(
name|dtp
argument_list|,
name|rec
operator|->
name|dtrd_format
argument_list|)
decl_stmt|;
if|if
condition|(
name|strdata
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|dtrace_print
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|strdata
argument_list|,
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|)
expr_stmt|;
comment|/* 					 * dtrace_print() will return -1 on 					 * error, or return the number of bytes 					 * consumed.  It will return 0 if the 					 * type couldn't be determined, and we 					 * should fall through to the normal 					 * trace method. 					 */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
goto|goto
name|nextrec
goto|;
block|}
block|}
name|nofmt
label|:
if|if
condition|(
name|act
operator|==
name|DTRACEACT_PRINTA
condition|)
block|{
name|dt_print_aggdata_t
name|pd
decl_stmt|;
name|dtrace_aggvarid_t
modifier|*
name|aggvars
decl_stmt|;
name|int
name|j
decl_stmt|,
name|naggvars
init|=
literal|0
decl_stmt|;
name|size_t
name|size
init|=
operator|(
operator|(
name|epd
operator|->
name|dtepd_nrecs
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_aggvarid_t
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|aggvars
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 				 * This might be a printa() with multiple 				 * aggregation variables.  We need to scan 				 * forward through the records until we find 				 * a record from a different statement. 				 */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|epd
operator|->
name|dtepd_nrecs
condition|;
name|j
operator|++
control|)
block|{
name|dtrace_recdesc_t
modifier|*
name|nrec
decl_stmt|;
name|caddr_t
name|naddr
decl_stmt|;
name|nrec
operator|=
operator|&
name|epd
operator|->
name|dtepd_rec
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|nrec
operator|->
name|dtrd_uarg
operator|!=
name|rec
operator|->
name|dtrd_uarg
condition|)
break|break;
if|if
condition|(
name|nrec
operator|->
name|dtrd_action
operator|!=
name|act
condition|)
block|{
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EDT_BADAGG
argument_list|)
operator|)
return|;
block|}
name|naddr
operator|=
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
operator|+
name|nrec
operator|->
name|dtrd_offset
expr_stmt|;
name|aggvars
index|[
name|naggvars
operator|++
index|]
operator|=
comment|/* LINTED - alignment */
operator|*
operator|(
operator|(
name|dtrace_aggvarid_t
operator|*
operator|)
name|naddr
operator|)
expr_stmt|;
block|}
name|i
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pd
argument_list|,
sizeof|sizeof
argument_list|(
name|pd
argument_list|)
argument_list|)
expr_stmt|;
name|pd
operator|.
name|dtpa_dtp
operator|=
name|dtp
expr_stmt|;
name|pd
operator|.
name|dtpa_fp
operator|=
name|fp
expr_stmt|;
name|assert
argument_list|(
name|naggvars
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|naggvars
operator|==
literal|1
condition|)
block|{
name|pd
operator|.
name|dtpa_id
operator|=
name|aggvars
index|[
literal|0
index|]
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|aggvars
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
operator|||
name|dtrace_aggregate_walk_sorted
argument_list|(
name|dtp
argument_list|,
name|dt_print_agg
argument_list|,
operator|&
name|pd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
operator|||
name|dtrace_aggregate_walk_joined
argument_list|(
name|dtp
argument_list|,
name|aggvars
argument_list|,
name|naggvars
argument_list|,
name|dt_print_aggs
argument_list|,
operator|&
name|pd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|aggvars
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|aggvars
argument_list|)
expr_stmt|;
goto|goto
name|nextrec
goto|;
block|}
if|if
condition|(
name|act
operator|==
name|DTRACEACT_TRACEMEM
condition|)
block|{
if|if
condition|(
name|tracememsize
operator|==
literal|0
operator|||
name|tracememsize
operator|>
name|rec
operator|->
name|dtrd_size
condition|)
block|{
name|tracememsize
operator|=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
block|}
name|n
operator|=
name|dt_print_bytes
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|tracememsize
argument_list|,
operator|-
literal|33
argument_list|,
name|quiet
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tracememsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|nextrec
goto|;
block|}
switch|switch
condition|(
name|rec
operator|->
name|dtrd_size
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
name|n
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|quiet
condition|?
literal|"%lld"
else|:
literal|" %16lld"
argument_list|,
comment|/* LINTED - alignment */
operator|*
operator|(
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
name|n
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|quiet
condition|?
literal|"%d"
else|:
literal|" %8d"
argument_list|,
comment|/* LINTED - alignment */
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
name|n
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|quiet
condition|?
literal|"%d"
else|:
literal|" %5d"
argument_list|,
comment|/* LINTED - alignment */
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
name|n
operator|=
name|dt_printf
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|quiet
condition|?
literal|"%d"
else|:
literal|" %3d"
argument_list|,
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|addr
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|n
operator|=
name|dt_print_bytes
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|addr
argument_list|,
name|rec
operator|->
name|dtrd_size
argument_list|,
operator|-
literal|33
argument_list|,
name|quiet
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
name|nextrec
label|:
if|if
condition|(
name|dt_buffered_flush
argument_list|(
name|dtp
argument_list|,
operator|&
name|data
argument_list|,
name|rec
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* errno is set for us */
block|}
comment|/* 		 * Call the record callback with a NULL record to indicate 		 * that we're done processing this EPID. 		 */
name|rval
operator|=
call|(
modifier|*
name|rfunc
call|)
argument_list|(
operator|&
name|data
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|nextepid
label|:
name|offs
operator|+=
name|epd
operator|->
name|dtepd_size
expr_stmt|;
name|dtp
operator|->
name|dt_last_epid
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|just_one
condition|)
block|{
name|buf
operator|->
name|dtbd_oldest
operator|=
name|offs
expr_stmt|;
break|break;
block|}
block|}
name|dtp
operator|->
name|dt_flow
operator|=
name|data
operator|.
name|dtpda_flow
expr_stmt|;
name|dtp
operator|->
name|dt_indent
operator|=
name|data
operator|.
name|dtpda_indent
expr_stmt|;
name|dtp
operator|->
name|dt_prefix
operator|=
name|data
operator|.
name|dtpda_prefix
expr_stmt|;
if|if
condition|(
operator|(
name|drops
operator|=
name|buf
operator|->
name|dtbd_drops
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Explicitly zero the drops to prevent us from processing them again. 	 */
name|buf
operator|->
name|dtbd_drops
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dt_handle_cpudrop
argument_list|(
name|dtp
argument_list|,
name|cpu
argument_list|,
name|DTRACEDROP_PRINCIPAL
argument_list|,
name|drops
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reduce memory usage by shrinking the buffer if it's no more than half full.  * Note, we need to preserve the alignment of the data at dtbd_oldest, which is  * only 4-byte aligned.  */
end_comment

begin_function
specifier|static
name|void
name|dt_realloc_buf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_bufdesc_t
modifier|*
name|buf
parameter_list|,
name|int
name|cursize
parameter_list|)
block|{
name|uint64_t
name|used
init|=
name|buf
operator|->
name|dtbd_size
operator|-
name|buf
operator|->
name|dtbd_oldest
decl_stmt|;
if|if
condition|(
name|used
operator|<
name|cursize
operator|/
literal|2
condition|)
block|{
name|int
name|misalign
init|=
name|buf
operator|->
name|dtbd_oldest
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
name|char
modifier|*
name|newdata
init|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|used
operator|+
name|misalign
argument_list|)
decl_stmt|;
if|if
condition|(
name|newdata
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
name|newdata
argument_list|,
name|misalign
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
operator|->
name|dtbd_data
operator|+
name|buf
operator|->
name|dtbd_oldest
argument_list|,
name|newdata
operator|+
name|misalign
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|buf
operator|->
name|dtbd_data
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dtbd_oldest
operator|=
name|misalign
expr_stmt|;
name|buf
operator|->
name|dtbd_size
operator|=
name|used
operator|+
name|misalign
expr_stmt|;
name|buf
operator|->
name|dtbd_data
operator|=
name|newdata
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If the ring buffer has wrapped, the data is not in order.  Rearrange it  * so that it is.  Note, we need to preserve the alignment of the data at  * dtbd_oldest, which is only 4-byte aligned.  */
end_comment

begin_function
specifier|static
name|int
name|dt_unring_buf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_bufdesc_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|misalign
decl_stmt|;
name|char
modifier|*
name|newdata
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtbd_oldest
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|misalign
operator|=
name|buf
operator|->
name|dtbd_oldest
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|newdata
operator|=
name|ndp
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|buf
operator|->
name|dtbd_size
operator|+
name|misalign
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdata
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|assert
argument_list|(
literal|0
operator|==
operator|(
name|buf
operator|->
name|dtbd_size
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ndp
argument_list|,
name|misalign
argument_list|)
expr_stmt|;
name|ndp
operator|+=
name|misalign
expr_stmt|;
name|bcopy
argument_list|(
name|buf
operator|->
name|dtbd_data
operator|+
name|buf
operator|->
name|dtbd_oldest
argument_list|,
name|ndp
argument_list|,
name|buf
operator|->
name|dtbd_size
operator|-
name|buf
operator|->
name|dtbd_oldest
argument_list|)
expr_stmt|;
name|ndp
operator|+=
name|buf
operator|->
name|dtbd_size
operator|-
name|buf
operator|->
name|dtbd_oldest
expr_stmt|;
name|bcopy
argument_list|(
name|buf
operator|->
name|dtbd_data
argument_list|,
name|ndp
argument_list|,
name|buf
operator|->
name|dtbd_oldest
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|buf
operator|->
name|dtbd_data
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dtbd_oldest
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtbd_data
operator|=
name|newdata
expr_stmt|;
name|buf
operator|->
name|dtbd_size
operator|+=
name|misalign
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dt_put_buf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|dtrace_bufdesc_t
modifier|*
name|buf
parameter_list|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|buf
operator|->
name|dtbd_data
argument_list|)
expr_stmt|;
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 on success, in which case *cbp will be filled in if we retrieved  * data, or NULL if there is no data for this CPU.  * Returns -1 on failure and sets dt_errno.  */
end_comment

begin_function
specifier|static
name|int
name|dt_get_buf
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|cpu
parameter_list|,
name|dtrace_bufdesc_t
modifier|*
modifier|*
name|bufp
parameter_list|)
block|{
name|dtrace_optval_t
name|size
decl_stmt|;
name|dtrace_bufdesc_t
modifier|*
name|buf
init|=
name|dt_zalloc
argument_list|(
name|dtp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|dtp
argument_list|,
literal|"bufsize"
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dtbd_data
operator|=
name|dt_alloc
argument_list|(
name|dtp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtbd_data
operator|==
name|NULL
condition|)
block|{
name|dt_free
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|buf
operator|->
name|dtbd_size
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|dtbd_cpu
operator|=
name|cpu
expr_stmt|;
if|if
condition|(
name|dt_ioctl
argument_list|(
name|dtp
argument_list|,
name|DTRACEIOC_BUFSNAP
argument_list|,
name|buf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 		 * If we failed with ENOENT, it may be because the 		 * CPU was unconfigured -- this is okay.  Any other 		 * error, however, is unexpected. 		 */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
operator|*
name|bufp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|errno
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dt_unring_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dt_realloc_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dt_begin
block|{
name|dtrace_consume_probe_f
modifier|*
name|dtbgn_probefunc
decl_stmt|;
name|dtrace_consume_rec_f
modifier|*
name|dtbgn_recfunc
decl_stmt|;
name|void
modifier|*
name|dtbgn_arg
decl_stmt|;
name|dtrace_handle_err_f
modifier|*
name|dtbgn_errhdlr
decl_stmt|;
name|void
modifier|*
name|dtbgn_errarg
decl_stmt|;
name|int
name|dtbgn_beginonly
decl_stmt|;
block|}
name|dt_begin_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|dt_consume_begin_probe
parameter_list|(
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_begin_t
modifier|*
name|begin
init|=
name|arg
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|pd
init|=
name|data
operator|->
name|dtpda_pdesc
decl_stmt|;
name|int
name|r1
init|=
operator|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_provider
argument_list|,
literal|"dtrace"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|r2
init|=
operator|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_name
argument_list|,
literal|"BEGIN"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|begin
operator|->
name|dtbgn_beginonly
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|r1
operator|&&
name|r2
operator|)
condition|)
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|r1
operator|&&
name|r2
condition|)
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
block|}
comment|/* 	 * We have a record that we're interested in.  Now call the underlying 	 * probe function... 	 */
return|return
operator|(
name|begin
operator|->
name|dtbgn_probefunc
argument_list|(
name|data
argument_list|,
name|begin
operator|->
name|dtbgn_arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_consume_begin_record
parameter_list|(
specifier|const
name|dtrace_probedata_t
modifier|*
name|data
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_begin_t
modifier|*
name|begin
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|begin
operator|->
name|dtbgn_recfunc
argument_list|(
name|data
argument_list|,
name|rec
argument_list|,
name|begin
operator|->
name|dtbgn_arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_consume_begin_error
parameter_list|(
specifier|const
name|dtrace_errdata_t
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dt_begin_t
modifier|*
name|begin
init|=
operator|(
name|dt_begin_t
operator|*
operator|)
name|arg
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|pd
init|=
name|data
operator|->
name|dteda_pdesc
decl_stmt|;
name|int
name|r1
init|=
operator|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_provider
argument_list|,
literal|"dtrace"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|r2
init|=
operator|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_name
argument_list|,
literal|"BEGIN"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|begin
operator|->
name|dtbgn_beginonly
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|r1
operator|&&
name|r2
operator|)
condition|)
return|return
operator|(
name|DTRACE_HANDLE_OK
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|r1
operator|&&
name|r2
condition|)
return|return
operator|(
name|DTRACE_HANDLE_OK
operator|)
return|;
block|}
return|return
operator|(
name|begin
operator|->
name|dtbgn_errhdlr
argument_list|(
name|data
argument_list|,
name|begin
operator|->
name|dtbgn_errarg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dt_consume_begin
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|dtrace_consume_probe_f
modifier|*
name|pf
parameter_list|,
name|dtrace_consume_rec_f
modifier|*
name|rf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * There's this idea that the BEGIN probe should be processed before 	 * everything else, and that the END probe should be processed after 	 * anything else.  In the common case, this is pretty easy to deal 	 * with.  However, a situation may arise where the BEGIN enabling and 	 * END enabling are on the same CPU, and some enabling in the middle 	 * occurred on a different CPU.  To deal with this (blech!) we need to 	 * consume the BEGIN buffer up until the end of the BEGIN probe, and 	 * then set it aside.  We will then process every other CPU, and then 	 * we'll return to the BEGIN CPU and process the rest of the data 	 * (which will inevitably include the END probe, if any).  Making this 	 * even more complicated (!) is the library's ERROR enabling.  Because 	 * this enabling is processed before we even get into the consume call 	 * back, any ERROR firing would result in the library's ERROR enabling 	 * being processed twice -- once in our first pass (for BEGIN probes), 	 * and again in our second pass (for everything but BEGIN probes).  To 	 * deal with this, we interpose on the ERROR handler to assure that we 	 * only process ERROR enablings induced by BEGIN enablings in the 	 * first pass, and that we only process ERROR enablings _not_ induced 	 * by BEGIN enablings in the second pass. 	 */
name|dt_begin_t
name|begin
decl_stmt|;
name|processorid_t
name|cpu
init|=
name|dtp
operator|->
name|dt_beganon
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|int
name|max_ncpus
decl_stmt|;
name|dtrace_bufdesc_t
modifier|*
name|buf
decl_stmt|;
name|dtp
operator|->
name|dt_beganon
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dt_get_buf
argument_list|(
name|dtp
argument_list|,
name|cpu
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_stopped
operator|||
name|buf
operator|->
name|dtbd_cpu
operator|!=
name|dtp
operator|->
name|dt_endedon
condition|)
block|{
comment|/* 		 * This is the simple case.  We're either not stopped, or if 		 * we are, we actually processed any END probes on another 		 * CPU.  We can simply consume this buffer and return. 		 */
name|rval
operator|=
name|dt_consume_cpu
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|cpu
argument_list|,
name|buf
argument_list|,
name|B_FALSE
argument_list|,
name|pf
argument_list|,
name|rf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
name|begin
operator|.
name|dtbgn_probefunc
operator|=
name|pf
expr_stmt|;
name|begin
operator|.
name|dtbgn_recfunc
operator|=
name|rf
expr_stmt|;
name|begin
operator|.
name|dtbgn_arg
operator|=
name|arg
expr_stmt|;
name|begin
operator|.
name|dtbgn_beginonly
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We need to interpose on the ERROR handler to be sure that we 	 * only process ERRORs induced by BEGIN. 	 */
name|begin
operator|.
name|dtbgn_errhdlr
operator|=
name|dtp
operator|->
name|dt_errhdlr
expr_stmt|;
name|begin
operator|.
name|dtbgn_errarg
operator|=
name|dtp
operator|->
name|dt_errarg
expr_stmt|;
name|dtp
operator|->
name|dt_errhdlr
operator|=
name|dt_consume_begin_error
expr_stmt|;
name|dtp
operator|->
name|dt_errarg
operator|=
operator|&
name|begin
expr_stmt|;
name|rval
operator|=
name|dt_consume_cpu
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|cpu
argument_list|,
name|buf
argument_list|,
name|B_FALSE
argument_list|,
name|dt_consume_begin_probe
argument_list|,
name|dt_consume_begin_record
argument_list|,
operator|&
name|begin
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_errhdlr
operator|=
name|begin
operator|.
name|dtbgn_errhdlr
expr_stmt|;
name|dtp
operator|->
name|dt_errarg
operator|=
name|begin
operator|.
name|dtbgn_errarg
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
block|{
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|max_ncpus
operator|==
literal|0
condition|)
name|max_ncpus
operator|=
name|dt_sysconf
argument_list|(
name|dtp
argument_list|,
name|_SC_CPUID_MAX
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_bufdesc_t
modifier|*
name|nbuf
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|cpu
condition|)
continue|continue;
if|if
condition|(
name|dt_get_buf
argument_list|(
name|dtp
argument_list|,
name|i
argument_list|,
operator|&
name|nbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nbuf
operator|==
name|NULL
condition|)
continue|continue;
name|rval
operator|=
name|dt_consume_cpu
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|i
argument_list|,
name|nbuf
argument_list|,
name|B_FALSE
argument_list|,
name|pf
argument_list|,
name|rf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
block|{
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
block|}
comment|/* 	 * Okay -- we're done with the other buffers.  Now we want to 	 * reconsume the first buffer -- but this time we're looking for 	 * everything _but_ BEGIN.  And of course, in order to only consume 	 * those ERRORs _not_ associated with BEGIN, we need to reinstall our 	 * ERROR interposition function... 	 */
name|begin
operator|.
name|dtbgn_beginonly
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|begin
operator|.
name|dtbgn_errhdlr
operator|==
name|dtp
operator|->
name|dt_errhdlr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|begin
operator|.
name|dtbgn_errarg
operator|==
name|dtp
operator|->
name|dt_errarg
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_errhdlr
operator|=
name|dt_consume_begin_error
expr_stmt|;
name|dtp
operator|->
name|dt_errarg
operator|=
operator|&
name|begin
expr_stmt|;
name|rval
operator|=
name|dt_consume_cpu
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|cpu
argument_list|,
name|buf
argument_list|,
name|B_FALSE
argument_list|,
name|dt_consume_begin_probe
argument_list|,
name|dt_consume_begin_record
argument_list|,
operator|&
name|begin
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_errhdlr
operator|=
name|begin
operator|.
name|dtbgn_errhdlr
expr_stmt|;
name|dtp
operator|->
name|dt_errarg
operator|=
name|begin
operator|.
name|dtbgn_errarg
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|uint64_t
name|dt_buf_oldest
parameter_list|(
name|void
modifier|*
name|elem
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_bufdesc_t
modifier|*
name|buf
init|=
name|elem
decl_stmt|;
name|size_t
name|offs
init|=
name|buf
operator|->
name|dtbd_oldest
decl_stmt|;
while|while
condition|(
name|offs
operator|<
name|buf
operator|->
name|dtbd_size
condition|)
block|{
name|dtrace_rechdr_t
modifier|*
name|dtrh
init|=
comment|/* LINTED - alignment */
operator|(
name|dtrace_rechdr_t
operator|*
operator|)
operator|(
name|buf
operator|->
name|dtbd_data
operator|+
name|offs
operator|)
decl_stmt|;
if|if
condition|(
name|dtrh
operator|->
name|dtrh_epid
operator|==
name|DTRACE_EPIDNONE
condition|)
block|{
name|offs
operator|+=
sizeof|sizeof
argument_list|(
name|dtrace_epid_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|DTRACE_RECORD_LOAD_TIMESTAMP
argument_list|(
name|dtrh
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* There are no records left; use the time the buffer was retrieved. */
return|return
operator|(
name|buf
operator|->
name|dtbd_timestamp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_consume
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|dtrace_consume_probe_f
modifier|*
name|pf
parameter_list|,
name|dtrace_consume_rec_f
modifier|*
name|rf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_optval_t
name|size
decl_stmt|;
specifier|static
name|int
name|max_ncpus
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|;
name|dtrace_optval_t
name|interval
init|=
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_SWITCHRATE
index|]
decl_stmt|;
name|hrtime_t
name|now
init|=
name|gethrtime
argument_list|()
decl_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_lastswitch
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|now
operator|-
name|dtp
operator|->
name|dt_lastswitch
operator|<
name|interval
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dtp
operator|->
name|dt_lastswitch
operator|+=
name|interval
expr_stmt|;
block|}
else|else
block|{
name|dtp
operator|->
name|dt_lastswitch
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dtp
operator|->
name|dt_active
condition|)
return|return
operator|(
name|dt_set_errno
argument_list|(
name|dtp
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|max_ncpus
operator|==
literal|0
condition|)
name|max_ncpus
operator|=
name|dt_sysconf
argument_list|(
name|dtp
argument_list|,
name|_SC_CPUID_MAX
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
name|pf
operator|=
operator|(
name|dtrace_consume_probe_f
operator|*
operator|)
name|dt_nullprobe
expr_stmt|;
if|if
condition|(
name|rf
operator|==
name|NULL
condition|)
name|rf
operator|=
operator|(
name|dtrace_consume_rec_f
operator|*
operator|)
name|dt_nullrec
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_options
index|[
name|DTRACEOPT_TEMPORAL
index|]
operator|==
name|DTRACEOPT_UNSET
condition|)
block|{
comment|/* 		 * The output will not be in the order it was traced.  Rather, 		 * we will consume all of the data from each CPU's buffer in 		 * turn.  We apply special handling for the records from BEGIN 		 * and END probes so that they are consumed first and last, 		 * respectively. 		 * 		 * If we have just begun, we want to first process the CPU that 		 * executed the BEGIN probe (if any). 		 */
if|if
condition|(
name|dtp
operator|->
name|dt_active
operator|&&
name|dtp
operator|->
name|dt_beganon
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|rval
operator|=
name|dt_consume_begin
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|pf
argument_list|,
name|rf
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_bufdesc_t
modifier|*
name|buf
decl_stmt|;
comment|/* 			 * If we have stopped, we want to process the CPU on 			 * which the END probe was processed only _after_ we 			 * have processed everything else. 			 */
if|if
condition|(
name|dtp
operator|->
name|dt_stopped
operator|&&
operator|(
name|i
operator|==
name|dtp
operator|->
name|dt_endedon
operator|)
condition|)
continue|continue;
if|if
condition|(
name|dt_get_buf
argument_list|(
name|dtp
argument_list|,
name|i
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
continue|continue;
name|dtp
operator|->
name|dt_flow
operator|=
literal|0
expr_stmt|;
name|dtp
operator|->
name|dt_indent
operator|=
literal|0
expr_stmt|;
name|dtp
operator|->
name|dt_prefix
operator|=
name|NULL
expr_stmt|;
name|rval
operator|=
name|dt_consume_cpu
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|i
argument_list|,
name|buf
argument_list|,
name|B_FALSE
argument_list|,
name|pf
argument_list|,
name|rf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|dtp
operator|->
name|dt_stopped
condition|)
block|{
name|dtrace_bufdesc_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|dt_get_buf
argument_list|(
name|dtp
argument_list|,
name|dtp
operator|->
name|dt_endedon
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rval
operator|=
name|dt_consume_cpu
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|dtp
operator|->
name|dt_endedon
argument_list|,
name|buf
argument_list|,
name|B_FALSE
argument_list|,
name|pf
argument_list|,
name|rf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * The output will be in the order it was traced (or for 		 * speculations, when it was committed).  We retrieve a buffer 		 * from each CPU and put it into a priority queue, which sorts 		 * based on the first entry in the buffer.  This is sufficient 		 * because entries within a buffer are already sorted. 		 * 		 * We then consume records one at a time, always consuming the 		 * oldest record, as determined by the priority queue.  When 		 * we reach the end of the time covered by these buffers, 		 * we need to stop and retrieve more records on the next pass. 		 * The kernel tells us the time covered by each buffer, in 		 * dtbd_timestamp.  The first buffer's timestamp tells us the 		 * time covered by all buffers, as subsequently retrieved 		 * buffers will cover to a more recent time. 		 */
name|uint64_t
modifier|*
name|drops
init|=
name|alloca
argument_list|(
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
decl_stmt|;
name|uint64_t
name|first_timestamp
init|=
literal|0
decl_stmt|;
name|uint_t
name|cookie
init|=
literal|0
decl_stmt|;
name|dtrace_bufdesc_t
modifier|*
name|buf
decl_stmt|;
name|bzero
argument_list|(
name|drops
argument_list|,
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_bufq
operator|==
name|NULL
condition|)
block|{
name|dtp
operator|->
name|dt_bufq
operator|=
name|dt_pq_init
argument_list|(
name|dtp
argument_list|,
name|max_ncpus
operator|*
literal|2
argument_list|,
name|dt_buf_oldest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtp
operator|->
name|dt_bufq
operator|==
name|NULL
condition|)
comment|/* ENOMEM */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Retrieve data from each CPU. */
operator|(
name|void
operator|)
name|dtrace_getopt
argument_list|(
name|dtp
argument_list|,
literal|"bufsize"
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_bufdesc_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|dt_get_buf
argument_list|(
name|dtp
argument_list|,
name|i
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first_timestamp
operator|==
literal|0
condition|)
name|first_timestamp
operator|=
name|buf
operator|->
name|dtbd_timestamp
expr_stmt|;
name|assert
argument_list|(
name|buf
operator|->
name|dtbd_timestamp
operator|>=
name|first_timestamp
argument_list|)
expr_stmt|;
name|dt_pq_insert
argument_list|(
name|dtp
operator|->
name|dt_bufq
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|drops
index|[
name|i
index|]
operator|=
name|buf
operator|->
name|dtbd_drops
expr_stmt|;
name|buf
operator|->
name|dtbd_drops
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Consume records. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dtrace_bufdesc_t
modifier|*
name|buf
init|=
name|dt_pq_pop
argument_list|(
name|dtp
operator|->
name|dt_bufq
argument_list|)
decl_stmt|;
name|uint64_t
name|timestamp
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
break|break;
name|timestamp
operator|=
name|dt_buf_oldest
argument_list|(
name|buf
argument_list|,
name|dtp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|timestamp
operator|>=
name|dtp
operator|->
name|dt_last_timestamp
argument_list|)
expr_stmt|;
name|dtp
operator|->
name|dt_last_timestamp
operator|=
name|timestamp
expr_stmt|;
if|if
condition|(
name|timestamp
operator|==
name|buf
operator|->
name|dtbd_timestamp
condition|)
block|{
comment|/* 				 * We've reached the end of the time covered 				 * by this buffer.  If this is the oldest 				 * buffer, we must do another pass 				 * to retrieve more data. 				 */
name|dt_put_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp
operator|==
name|first_timestamp
operator|&&
operator|!
name|dtp
operator|->
name|dt_stopped
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|dt_consume_cpu
argument_list|(
name|dtp
argument_list|,
name|fp
argument_list|,
name|buf
operator|->
name|dtbd_cpu
argument_list|,
name|buf
argument_list|,
name|B_TRUE
argument_list|,
name|pf
argument_list|,
name|rf
argument_list|,
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|dt_pq_insert
argument_list|(
name|dtp
operator|->
name|dt_bufq
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Consume drops. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ncpus
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|drops
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|int
name|error
init|=
name|dt_handle_cpudrop
argument_list|(
name|dtp
argument_list|,
name|i
argument_list|,
name|DTRACEDROP_PRINCIPAL
argument_list|,
name|drops
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 		 * Reduce memory usage by re-allocating smaller buffers 		 * for the "remnants". 		 */
while|while
condition|(
name|buf
operator|=
name|dt_pq_walk
argument_list|(
name|dtp
operator|->
name|dt_bufq
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
name|dt_realloc_buf
argument_list|(
name|dtp
argument_list|,
name|buf
argument_list|,
name|buf
operator|->
name|dtbd_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

