begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<dt_impl.h>
end_include

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|}
name|_dt_errlist
index|[]
init|=
block|{
block|{
name|EDT_VERSION
block|,
literal|"Client requested version newer than library"
block|}
block|,
block|{
name|EDT_VERSINVAL
block|,
literal|"Version is not properly formatted or is too large"
block|}
block|,
block|{
name|EDT_VERSUNDEF
block|,
literal|"Requested version is not supported by compiler"
block|}
block|,
block|{
name|EDT_VERSREDUCED
block|,
literal|"Requested version conflicts with earlier setting"
block|}
block|,
block|{
name|EDT_CTF
block|,
literal|"Unexpected libctf error"
block|}
block|,
block|{
name|EDT_COMPILER
block|,
literal|"Error in D program compilation"
block|}
block|,
block|{
name|EDT_NOTUPREG
block|,
literal|"Insufficient tuple registers to generate code"
block|}
block|,
block|{
name|EDT_NOMEM
block|,
literal|"Memory allocation failure"
block|}
block|,
block|{
name|EDT_INT2BIG
block|,
literal|"Integer constant table limit exceeded"
block|}
block|,
block|{
name|EDT_STR2BIG
block|,
literal|"String constant table limit exceeded"
block|}
block|,
block|{
name|EDT_NOMOD
block|,
literal|"Unknown module name"
block|}
block|,
block|{
name|EDT_NOPROV
block|,
literal|"Unknown provider name"
block|}
block|,
block|{
name|EDT_NOPROBE
block|,
literal|"No probe matches description"
block|}
block|,
block|{
name|EDT_NOSYM
block|,
literal|"Unknown symbol name"
block|}
block|,
block|{
name|EDT_NOSYMADDR
block|,
literal|"No symbol corresponds to address"
block|}
block|,
block|{
name|EDT_NOTYPE
block|,
literal|"Unknown type name"
block|}
block|,
block|{
name|EDT_NOVAR
block|,
literal|"Unknown variable name"
block|}
block|,
block|{
name|EDT_NOAGG
block|,
literal|"Unknown aggregation name"
block|}
block|,
block|{
name|EDT_BADSCOPE
block|,
literal|"Improper use of scoping operator in type name"
block|}
block|,
block|{
name|EDT_BADSPEC
block|,
literal|"Overspecified probe description"
block|}
block|,
block|{
name|EDT_BADSPCV
block|,
literal|"Undefined macro variable in probe description"
block|}
block|,
block|{
name|EDT_BADID
block|,
literal|"Unknown probe identifier"
block|}
block|,
block|{
name|EDT_NOTLOADED
block|,
literal|"Module is no longer loaded"
block|}
block|,
block|{
name|EDT_NOCTF
block|,
literal|"Module does not contain any CTF data"
block|}
block|,
block|{
name|EDT_DATAMODEL
block|,
literal|"Module and program data models do not match"
block|}
block|,
block|{
name|EDT_DIFVERS
block|,
literal|"Library uses newer DIF version than kernel"
block|}
block|,
block|{
name|EDT_BADAGG
block|,
literal|"Unknown aggregating action"
block|}
block|,
block|{
name|EDT_FIO
block|,
literal|"Error occurred while reading from input stream"
block|}
block|,
block|{
name|EDT_DIFINVAL
block|,
literal|"DIF program content is invalid"
block|}
block|,
block|{
name|EDT_DIFSIZE
block|,
literal|"DIF program exceeds maximum program size"
block|}
block|,
block|{
name|EDT_DIFFAULT
block|,
literal|"DIF program contains invalid pointer"
block|}
block|,
block|{
name|EDT_BADPROBE
block|,
literal|"Invalid probe specification"
block|}
block|,
block|{
name|EDT_BADPGLOB
block|,
literal|"Probe description has too many globbing characters"
block|}
block|,
block|{
name|EDT_NOSCOPE
block|,
literal|"Declaration scope stack underflow"
block|}
block|,
block|{
name|EDT_NODECL
block|,
literal|"Declaration stack underflow"
block|}
block|,
block|{
name|EDT_DMISMATCH
block|,
literal|"Data record list does not match statement"
block|}
block|,
block|{
name|EDT_DOFFSET
block|,
literal|"Data record offset exceeds buffer boundary"
block|}
block|,
block|{
name|EDT_DALIGN
block|,
literal|"Data record has inappropriate alignment"
block|}
block|,
block|{
name|EDT_BADOPTNAME
block|,
literal|"Invalid option name"
block|}
block|,
block|{
name|EDT_BADOPTVAL
block|,
literal|"Invalid value for specified option"
block|}
block|,
block|{
name|EDT_BADOPTCTX
block|,
literal|"Option cannot be used from within a D program"
block|}
block|,
block|{
name|EDT_CPPFORK
block|,
literal|"Failed to fork preprocessor"
block|}
block|,
block|{
name|EDT_CPPEXEC
block|,
literal|"Failed to exec preprocessor"
block|}
block|,
block|{
name|EDT_CPPENT
block|,
literal|"Preprocessor not found"
block|}
block|,
block|{
name|EDT_CPPERR
block|,
literal|"Preprocessor failed to process input program"
block|}
block|,
block|{
name|EDT_SYMOFLOW
block|,
literal|"Symbol table identifier space exhausted"
block|}
block|,
block|{
name|EDT_ACTIVE
block|,
literal|"Operation illegal when tracing is active"
block|}
block|,
block|{
name|EDT_DESTRUCTIVE
block|,
literal|"Destructive actions not allowed"
block|}
block|,
block|{
name|EDT_NOANON
block|,
literal|"No anonymous tracing state"
block|}
block|,
block|{
name|EDT_ISANON
block|,
literal|"Can't claim anonymous state and enable probes"
block|}
block|,
block|{
name|EDT_ENDTOOBIG
block|,
literal|"END enablings exceed size of principal buffer"
block|}
block|,
block|{
name|EDT_NOCONV
block|,
literal|"Failed to load type for printf conversion"
block|}
block|,
block|{
name|EDT_BADCONV
block|,
literal|"Incomplete printf conversion"
block|}
block|,
block|{
name|EDT_BADERROR
block|,
literal|"Invalid library ERROR action"
block|}
block|,
block|{
name|EDT_ERRABORT
block|,
literal|"Abort due to error"
block|}
block|,
block|{
name|EDT_DROPABORT
block|,
literal|"Abort due to drop"
block|}
block|,
block|{
name|EDT_DIRABORT
block|,
literal|"Abort explicitly directed"
block|}
block|,
block|{
name|EDT_BADRVAL
block|,
literal|"Invalid return value from callback"
block|}
block|,
block|{
name|EDT_BADNORMAL
block|,
literal|"Invalid normalization"
block|}
block|,
block|{
name|EDT_BUFTOOSMALL
block|,
literal|"Enabling exceeds size of buffer"
block|}
block|,
block|{
name|EDT_BADTRUNC
block|,
literal|"Invalid truncation"
block|}
block|,
block|{
name|EDT_BUSY
block|,
literal|"DTrace cannot be used when kernel debugger is active"
block|}
block|,
block|{
name|EDT_ACCESS
block|,
literal|"DTrace requires additional privileges"
block|}
block|,
block|{
name|EDT_NOENT
block|,
literal|"DTrace device not available on system"
block|}
block|,
block|{
name|EDT_BRICKED
block|,
literal|"Abort due to systemic unresponsiveness"
block|}
block|,
block|{
name|EDT_HARDWIRE
block|,
literal|"Failed to load language definitions"
block|}
block|,
block|{
name|EDT_ELFVERSION
block|,
literal|"libelf is out-of-date with respect to libdtrace"
block|}
block|,
block|{
name|EDT_NOBUFFERED
block|,
literal|"Attempt to buffer output without handler"
block|}
block|,
block|{
name|EDT_UNSTABLE
block|,
literal|"Description matched an unstable set of probes"
block|}
block|,
block|{
name|EDT_BADSETOPT
block|,
literal|"Invalid setopt() library action"
block|}
block|,
block|{
name|EDT_BADSTACKPC
block|,
literal|"Invalid stack program counter size"
block|}
block|,
block|{
name|EDT_BADAGGVAR
block|,
literal|"Invalid aggregation variable identifier"
block|}
block|,
block|{
name|EDT_OVERSION
block|,
literal|"Client requested deprecated version of library"
block|}
block|,
block|{
name|EDT_ENABLING_ERR
block|,
literal|"Failed to enable probe"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|int
name|_dt_nerr
init|=
sizeof|sizeof
argument_list|(
name|_dt_errlist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|_dt_errlist
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|dtrace_errmsg
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|error
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|error
operator|==
name|EDT_COMPILER
operator|&&
name|dtp
operator|!=
name|NULL
operator|&&
name|dtp
operator|->
name|dt_errmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|str
operator|=
name|dtp
operator|->
name|dt_errmsg
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EDT_CTF
operator|&&
name|dtp
operator|!=
name|NULL
operator|&&
name|dtp
operator|->
name|dt_ctferr
operator|!=
literal|0
condition|)
name|str
operator|=
name|ctf_errmsg
argument_list|(
name|dtp
operator|->
name|dt_ctferr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|>=
name|EDT_BASE
operator|&&
operator|(
name|error
operator|-
name|EDT_BASE
operator|)
operator|<
name|_dt_nerr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_dt_nerr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_dt_errlist
index|[
name|i
index|]
operator|.
name|err
operator|==
name|error
condition|)
return|return
operator|(
name|_dt_errlist
index|[
name|i
index|]
operator|.
name|msg
operator|)
return|;
block|}
name|str
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|str
operator|=
name|strerror
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
condition|?
name|str
else|:
literal|"Unknown error"
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dtrace_errno
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|)
block|{
return|return
operator|(
name|dtp
operator|->
name|dt_errno
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dt_set_errno
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|dtp
operator|->
name|dt_errno
operator|=
name|err
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dt_set_errmsg
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
specifier|const
name|char
modifier|*
name|errtag
parameter_list|,
specifier|const
name|char
modifier|*
name|region
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|dtp
operator|->
name|dt_errmsg
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtag
operator|!=
name|NULL
operator|&&
operator|(
name|yypcb
operator|->
name|pcb_cflags
operator|&
name|DTRACE_C_ETAGS
operator|)
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"[%s] "
argument_list|,
name|errtag
argument_list|)
expr_stmt|;
else|else
name|s
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|)
expr_stmt|;
name|s
operator|=
name|dtp
operator|->
name|dt_errmsg
operator|+
name|len
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|)
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|filename
operator|=
name|dtp
operator|->
name|dt_filetag
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"\"%s\", line %d: "
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"line %d: "
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|region
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"in %s: "
argument_list|,
name|region
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|)
expr_stmt|;
name|s
operator|=
name|dtp
operator|->
name|dt_errmsg
operator|+
name|len
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|)
operator|-
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|dtp
operator|->
name|dt_errmsg
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove trailing \n from message buffer */
name|dtp
operator|->
name|dt_errtag
operator|=
name|errtag
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|const
name|char
modifier|*
name|dtrace_faultstr
parameter_list|(
name|dtrace_hdl_t
modifier|*
name|dtp
parameter_list|,
name|int
name|fault
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
name|int
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|faults
index|[]
init|=
block|{
block|{
name|DTRACEFLT_BADADDR
block|,
literal|"invalid address"
block|}
block|,
block|{
name|DTRACEFLT_BADALIGN
block|,
literal|"invalid alignment"
block|}
block|,
block|{
name|DTRACEFLT_ILLOP
block|,
literal|"illegal operation"
block|}
block|,
block|{
name|DTRACEFLT_DIVZERO
block|,
literal|"divide-by-zero"
block|}
block|,
block|{
name|DTRACEFLT_NOSCRATCH
block|,
literal|"out of scratch space"
block|}
block|,
block|{
name|DTRACEFLT_KPRIV
block|,
literal|"invalid kernel access"
block|}
block|,
block|{
name|DTRACEFLT_UPRIV
block|,
literal|"invalid user access"
block|}
block|,
block|{
name|DTRACEFLT_TUPOFLOW
block|,
literal|"tuple stack overflow"
block|}
block|,
block|{
name|DTRACEFLT_BADSTACK
block|,
literal|"bad stack"
block|}
block|,
block|{
name|DTRACEFLT_LIBRARY
block|,
literal|"library-level fault"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|faults
index|[
name|i
index|]
operator|.
name|str
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|faults
index|[
name|i
index|]
operator|.
name|code
operator|==
name|fault
condition|)
return|return
operator|(
name|faults
index|[
name|i
index|]
operator|.
name|str
operator|)
return|;
block|}
return|return
operator|(
literal|"unknown fault"
operator|)
return|;
block|}
end_function

end_unit

