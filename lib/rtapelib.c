begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for communicating with a remote tape drive.     Copyright (C) 1988, 1992, 1994, 1996, 1997, 1999, 2000, 2001, 2004,    2005, 2006 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* The man page rmt(8) for /etc/rmt documents the remote mag tape protocol    which rdump and rrestore use.  Unfortunately, the man page is *WRONG*.    The author of the routines I'm including originally wrote his code just    based on the man page, and it didn't work, so he went to the rdump source    to figure out why.  The only thing he had to change was to check for the    'F' return code in addition to the 'E', and to separate the various    arguments with \n instead of a space.  I personally don't think that this    is much of a problem, but I wanted to point it out. -- Arnold Robbins     Originally written by Jeff Lee, modified some by Arnold Robbins.  Redone    as a library that can replace open, read, write, etc., by Fred Fish, with    some additional work by Arnold Robbins.  Modified to make all rmt* calls    into macros for speed by Jay Fenlason.  Use -DWITH_REXEC for rexec    code, courtesy of Dan Kegel.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"system-ioctl.h"
end_include

begin_include
include|#
directive|include
file|<safe-read.h>
end_include

begin_include
include|#
directive|include
file|<full-write.h>
end_include

begin_comment
comment|/* Try hard to get EOPNOTSUPP defined.  486/ISC has it in net/errno.h,    3B2/SVR3 has it in sys/inet.h.  Otherwise, like on MSDOS, use EINVAL.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EOPNOTSUPP
end_ifndef

begin_if
if|#
directive|if
name|HAVE_NET_ERRNO_H
end_if

begin_include
include|#
directive|include
file|<net/errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_INET_H
end_if

begin_include
include|#
directive|include
file|<sys/inet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EOPNOTSUPP
end_ifndef

begin_define
define|#
directive|define
name|EOPNOTSUPP
value|EINVAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
name|HAVE_NETDB_H
end_if

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<rmt.h>
end_include

begin_include
include|#
directive|include
file|<rmt-command.h>
end_include

begin_comment
comment|/* Exit status if exec errors.  */
end_comment

begin_define
define|#
directive|define
name|EXIT_ON_EXEC_ERROR
value|128
end_define

begin_comment
comment|/* FIXME: Size of buffers for reading and writing commands to rmt.  */
end_comment

begin_define
define|#
directive|define
name|COMMAND_BUFFER_SIZE
value|64
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|RETSIGTYPE
end_ifndef

begin_define
define|#
directive|define
name|RETSIGTYPE
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIXME: Maximum number of simultaneous remote tape connections.  */
end_comment

begin_define
define|#
directive|define
name|MAXUNIT
value|4
end_define

begin_define
define|#
directive|define
name|PREAD
value|0
end_define

begin_comment
comment|/* read  file descriptor from pipe() */
end_comment

begin_define
define|#
directive|define
name|PWRITE
value|1
end_define

begin_comment
comment|/* write file descriptor from pipe() */
end_comment

begin_comment
comment|/* Return the parent's read side of remote tape connection Fd.  */
end_comment

begin_define
define|#
directive|define
name|READ_SIDE
parameter_list|(
name|Fd
parameter_list|)
value|(from_remote[Fd][PREAD])
end_define

begin_comment
comment|/* Return the parent's write side of remote tape connection Fd.  */
end_comment

begin_define
define|#
directive|define
name|WRITE_SIDE
parameter_list|(
name|Fd
parameter_list|)
value|(to_remote[Fd][PWRITE])
end_define

begin_comment
comment|/* The pipes for receiving data from remote tape drives.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|from_remote
index|[
name|MAXUNIT
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The pipes for sending data to remote tape drives.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|to_remote
index|[
name|MAXUNIT
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rmt_command
init|=
name|DEFAULT_RMT_COMMAND
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary variable used by macros in rmt.h.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rmt_dev_name__
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If true, always consider file names to be local, even if they contain    colons */
end_comment

begin_decl_stmt
name|bool
name|force_local_option
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Close remote tape connection HANDLE, and reset errno to ERRNO_VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|_rmt_shutdown
parameter_list|(
name|int
name|handle
parameter_list|,
name|int
name|errno_value
parameter_list|)
block|{
name|close
argument_list|(
name|READ_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|WRITE_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|)
expr_stmt|;
name|READ_SIDE
argument_list|(
name|handle
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|WRITE_SIDE
argument_list|(
name|handle
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|errno_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to perform the remote tape command specified in BUFFER on    remote tape connection HANDLE.  Return 0 if successful, -1 on    error.  */
end_comment

begin_function
specifier|static
name|int
name|do_command
parameter_list|(
name|int
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
block|{
comment|/* Save the current pipe handler and try to make the request.  */
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|RETSIGTYPE
function_decl|(
modifier|*
name|pipe_handler
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
name|ssize_t
name|written
init|=
name|full_write
argument_list|(
name|WRITE_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
name|length
condition|)
return|return
literal|0
return|;
comment|/* Something went wrong.  Close down and go home.  */
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_status_string
parameter_list|(
name|int
name|handle
parameter_list|,
name|char
modifier|*
name|command_buffer
parameter_list|)
block|{
name|char
modifier|*
name|cursor
decl_stmt|;
name|int
name|counter
decl_stmt|;
comment|/* Read the reply command line.  */
for|for
control|(
name|counter
operator|=
literal|0
operator|,
name|cursor
operator|=
name|command_buffer
init|;
name|counter
operator|<
name|COMMAND_BUFFER_SIZE
condition|;
name|counter
operator|++
operator|,
name|cursor
operator|++
control|)
block|{
if|if
condition|(
name|safe_read
argument_list|(
name|READ_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|,
name|cursor
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|*
name|cursor
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|counter
operator|==
name|COMMAND_BUFFER_SIZE
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check the return status.  */
for|for
control|(
name|cursor
operator|=
name|command_buffer
init|;
operator|*
name|cursor
condition|;
name|cursor
operator|++
control|)
if|if
condition|(
operator|*
name|cursor
operator|!=
literal|' '
condition|)
break|break;
if|if
condition|(
operator|*
name|cursor
operator|==
literal|'E'
operator|||
operator|*
name|cursor
operator|==
literal|'F'
condition|)
block|{
comment|/* Skip the error message line.  */
comment|/* FIXME: there is better to do than merely ignoring error messages 	 coming from the remote end.  Translate them, too...  */
block|{
name|char
name|character
decl_stmt|;
while|while
condition|(
name|safe_read
argument_list|(
name|READ_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|,
operator|&
name|character
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|errno
operator|=
name|atoi
argument_list|(
name|cursor
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cursor
operator|==
literal|'F'
condition|)
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for mis-synced pipes.  */
if|if
condition|(
operator|*
name|cursor
operator|!=
literal|'A'
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Got an `A' (success) response.  */
return|return
name|cursor
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read and return the status from remote tape connection HANDLE.  If    an error occurred, return -1 and set errno.  */
end_comment

begin_function
specifier|static
name|long
name|int
name|get_status
parameter_list|(
name|int
name|handle
parameter_list|)
block|{
name|char
name|command_buffer
index|[
name|COMMAND_BUFFER_SIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|status
init|=
name|get_status_string
argument_list|(
name|handle
argument_list|,
name|command_buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|long
name|int
name|result
init|=
name|atol
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|result
condition|)
return|return
name|result
return|;
name|errno
operator|=
name|EIO
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|get_status_off
parameter_list|(
name|int
name|handle
parameter_list|)
block|{
name|char
name|command_buffer
index|[
name|COMMAND_BUFFER_SIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|status
init|=
name|get_status_string
argument_list|(
name|handle
argument_list|,
name|command_buffer
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
comment|/* Parse status, taking care to check for overflow. 	 We can't use standard functions, 	 since off_t might be longer than long.  */
name|off_t
name|count
init|=
literal|0
decl_stmt|;
name|int
name|negative
decl_stmt|;
for|for
control|(
init|;
operator|*
name|status
operator|==
literal|' '
operator|||
operator|*
name|status
operator|==
literal|'\t'
condition|;
name|status
operator|++
control|)
continue|continue;
name|negative
operator|=
operator|*
name|status
operator|==
literal|'-'
expr_stmt|;
name|status
operator|+=
name|negative
operator|||
operator|*
name|status
operator|==
literal|'+'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|digit
init|=
operator|*
name|status
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
literal|9
operator|<
operator|(
name|unsigned
operator|)
name|digit
condition|)
break|break;
else|else
block|{
name|off_t
name|c10
init|=
literal|10
operator|*
name|count
decl_stmt|;
name|off_t
name|nc
init|=
name|negative
condition|?
name|c10
operator|-
name|digit
else|:
name|c10
operator|+
name|digit
decl_stmt|;
if|if
condition|(
name|c10
operator|/
literal|10
operator|!=
name|count
operator|||
operator|(
name|negative
condition|?
name|c10
operator|<
name|nc
else|:
name|nc
operator|<
name|c10
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|count
operator|=
name|nc
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|WITH_REXEC
end_if

begin_comment
comment|/* Execute /etc/rmt as user USER on remote system HOST using rexec.    Return a file descriptor of a bidirectional socket for stdin and    stdout.  If USER is zero, use the current username.     By default, this code is not used, since it requires that the user    have a .netrc file in his/her home directory, or that the    application designer be willing to have rexec prompt for login and    password info.  This may be unacceptable, and .rhosts files for use    with rsh are much more common on BSD systems.  */
end_comment

begin_function
specifier|static
name|int
name|_rmt_rexec
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|char
modifier|*
name|user
parameter_list|)
block|{
name|int
name|saved_stdin
init|=
name|dup
argument_list|(
name|STDIN_FILENO
argument_list|)
decl_stmt|;
name|int
name|saved_stdout
init|=
name|dup
argument_list|(
name|STDOUT_FILENO
argument_list|)
decl_stmt|;
name|struct
name|servent
modifier|*
name|rexecserv
decl_stmt|;
name|int
name|result
decl_stmt|;
comment|/* When using cpio -o< filename, stdin is no longer the tty.  But the      rexec subroutine reads the login and the passwd on stdin, to allow      remote execution of the command.  So, reopen stdin and stdout on      /dev/tty before the rexec and give them back their original value      after.  */
if|if
condition|(
operator|!
name|freopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
condition|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|freopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rexecserv
operator|=
name|getservbyname
argument_list|(
literal|"exec"
argument_list|,
literal|"tcp"
argument_list|)
operator|,
operator|!
name|rexecserv
condition|)
name|error
argument_list|(
name|EXIT_ON_EXEC_ERROR
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"exec/tcp: Service not available"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|rexec
argument_list|(
operator|&
name|host
argument_list|,
name|rexecserv
operator|->
name|s_port
argument_list|,
name|user
argument_list|,
literal|0
argument_list|,
name|rmt_command
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"stdin"
argument_list|)
argument_list|)
expr_stmt|;
name|fdopen
argument_list|(
name|saved_stdin
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"stdout"
argument_list|)
argument_list|)
expr_stmt|;
name|fdopen
argument_list|(
name|saved_stdout
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WITH_REXEC */
end_comment

begin_comment
comment|/* Place into BUF a string representing OFLAG, which must be suitable    as argument 2 of `open'.  BUF must be large enough to hold the    result.  This function should generate a string that decode_oflag    can parse.  */
end_comment

begin_function
specifier|static
name|void
name|encode_oflag
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|oflag
parameter_list|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|oflag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|oflag
operator|&
name|O_ACCMODE
condition|)
block|{
case|case
name|O_RDONLY
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"O_RDONLY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"O_RDWR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"O_WRONLY"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|O_APPEND
if|if
condition|(
name|oflag
operator|&
name|O_APPEND
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_APPEND"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|oflag
operator|&
name|O_CREAT
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_CREAT"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|O_DSYNC
if|if
condition|(
name|oflag
operator|&
name|O_DSYNC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_DSYNC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|oflag
operator|&
name|O_EXCL
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_EXCL"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|O_LARGEFILE
if|if
condition|(
name|oflag
operator|&
name|O_LARGEFILE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_LARGEFILE"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_NOCTTY
if|if
condition|(
name|oflag
operator|&
name|O_NOCTTY
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_NOCTTY"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|oflag
operator|&
name|O_NONBLOCK
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_NONBLOCK"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|O_RSYNC
if|if
condition|(
name|oflag
operator|&
name|O_RSYNC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_RSYNC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|O_SYNC
if|if
condition|(
name|oflag
operator|&
name|O_SYNC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_SYNC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|oflag
operator|&
name|O_TRUNC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"|O_TRUNC"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a file (a magnetic tape device?) on the system specified in    FILE_NAME, as the given user. FILE_NAME has the form `[USER@]HOST:FILE'.    OPEN_MODE is O_RDONLY, O_WRONLY, etc.  If successful, return the    remote pipe number plus BIAS.  REMOTE_SHELL may be overridden.  On    error, return -1.  */
end_comment

begin_function
name|int
name|rmt_open__
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|int
name|open_mode
parameter_list|,
name|int
name|bias
parameter_list|,
specifier|const
name|char
modifier|*
name|remote_shell
parameter_list|)
block|{
name|int
name|remote_pipe_number
decl_stmt|;
comment|/* pseudo, biased file descriptor */
name|char
modifier|*
name|file_name_copy
decl_stmt|;
comment|/* copy of file_name string */
name|char
modifier|*
name|remote_host
decl_stmt|;
comment|/* remote host name */
name|char
modifier|*
name|remote_file
decl_stmt|;
comment|/* remote file name (often a device) */
name|char
modifier|*
name|remote_user
decl_stmt|;
comment|/* remote user name */
comment|/* Find an unused pair of file descriptors.  */
for|for
control|(
name|remote_pipe_number
operator|=
literal|0
init|;
name|remote_pipe_number
operator|<
name|MAXUNIT
condition|;
name|remote_pipe_number
operator|++
control|)
if|if
condition|(
name|READ_SIDE
argument_list|(
name|remote_pipe_number
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|WRITE_SIDE
argument_list|(
name|remote_pipe_number
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|remote_pipe_number
operator|==
name|MAXUNIT
condition|)
block|{
name|errno
operator|=
name|EMFILE
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Pull apart the system and device, and optional user.  */
block|{
name|char
modifier|*
name|cursor
decl_stmt|;
name|file_name_copy
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|remote_host
operator|=
name|file_name_copy
expr_stmt|;
name|remote_user
operator|=
literal|0
expr_stmt|;
name|remote_file
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cursor
operator|=
name|file_name_copy
init|;
operator|*
name|cursor
condition|;
name|cursor
operator|++
control|)
switch|switch
condition|(
operator|*
name|cursor
condition|)
block|{
default|default:
break|break;
case|case
literal|'\n'
case|:
comment|/* Do not allow newlines in the file_name, since the protocol 	     uses newline delimiters.  */
name|free
argument_list|(
name|file_name_copy
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'@'
case|:
if|if
condition|(
operator|!
name|remote_user
condition|)
block|{
name|remote_user
operator|=
name|remote_host
expr_stmt|;
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
name|remote_host
operator|=
name|cursor
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
if|if
condition|(
operator|!
name|remote_file
condition|)
block|{
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
name|remote_file
operator|=
name|cursor
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* FIXME: Should somewhat validate the decoding, here.  */
if|if
condition|(
name|remote_user
operator|&&
operator|*
name|remote_user
operator|==
literal|'\0'
condition|)
name|remote_user
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|WITH_REXEC
comment|/* Execute the remote command using rexec.  */
name|READ_SIDE
argument_list|(
name|remote_pipe_number
argument_list|)
operator|=
name|_rmt_rexec
argument_list|(
name|remote_host
argument_list|,
name|remote_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|READ_SIDE
argument_list|(
name|remote_pipe_number
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|file_name_copy
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|WRITE_SIDE
argument_list|(
name|remote_pipe_number
argument_list|)
operator|=
name|READ_SIDE
argument_list|(
name|remote_pipe_number
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not WITH_REXEC */
block|{
specifier|const
name|char
modifier|*
name|remote_shell_basename
decl_stmt|;
name|pid_t
name|status
decl_stmt|;
comment|/* Identify the remote command to be executed.  */
if|if
condition|(
operator|!
name|remote_shell
condition|)
block|{
ifdef|#
directive|ifdef
name|REMOTE_SHELL
name|remote_shell
operator|=
name|REMOTE_SHELL
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|file_name_copy
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
name|remote_shell_basename
operator|=
name|base_name
argument_list|(
name|remote_shell
argument_list|)
expr_stmt|;
comment|/* Set up the pipes for the `rsh' command, and fork.  */
if|if
condition|(
name|pipe
argument_list|(
name|to_remote
index|[
name|remote_pipe_number
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|pipe
argument_list|(
name|from_remote
index|[
name|remote_pipe_number
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|file_name_copy
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|status
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|file_name_copy
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* Child.  */
name|close
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|to_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|to_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|to_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|from_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|from_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|from_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
name|sys_reset_uid_gid
argument_list|()
expr_stmt|;
if|if
condition|(
name|remote_user
condition|)
name|execl
argument_list|(
name|remote_shell
argument_list|,
name|remote_shell_basename
argument_list|,
name|remote_host
argument_list|,
literal|"-l"
argument_list|,
name|remote_user
argument_list|,
name|rmt_command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|execl
argument_list|(
name|remote_shell
argument_list|,
name|remote_shell_basename
argument_list|,
name|remote_host
argument_list|,
name|rmt_command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Bad problems if we get here.  */
comment|/* In a previous version, _exit was used here instead of exit.  */
name|error
argument_list|(
name|EXIT_ON_EXEC_ERROR
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"Cannot execute remote shell"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Parent.  */
name|close
argument_list|(
name|from_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PWRITE
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|to_remote
index|[
name|remote_pipe_number
index|]
index|[
name|PREAD
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not WITH_REXEC */
comment|/* Attempt to open the tape device.  */
block|{
name|size_t
name|remote_file_len
init|=
name|strlen
argument_list|(
name|remote_file
argument_list|)
decl_stmt|;
name|char
modifier|*
name|command_buffer
init|=
name|xmalloc
argument_list|(
name|remote_file_len
operator|+
literal|1000
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|command_buffer
argument_list|,
literal|"O%s\n"
argument_list|,
name|remote_file
argument_list|)
expr_stmt|;
name|encode_oflag
argument_list|(
name|command_buffer
operator|+
name|remote_file_len
operator|+
literal|2
argument_list|,
name|open_mode
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|command_buffer
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_command
argument_list|(
name|remote_pipe_number
argument_list|,
name|command_buffer
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|get_status
argument_list|(
name|remote_pipe_number
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|free
argument_list|(
name|command_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_name_copy
argument_list|)
expr_stmt|;
name|_rmt_shutdown
argument_list|(
name|remote_pipe_number
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|free
argument_list|(
name|command_buffer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|file_name_copy
argument_list|)
expr_stmt|;
return|return
name|remote_pipe_number
operator|+
name|bias
return|;
block|}
end_function

begin_comment
comment|/* Close remote tape connection HANDLE and shut down.  Return 0 if    successful, -1 on error.  */
end_comment

begin_function
name|int
name|rmt_close__
parameter_list|(
name|int
name|handle
parameter_list|)
block|{
name|long
name|int
name|status
decl_stmt|;
if|if
condition|(
name|do_command
argument_list|(
name|handle
argument_list|,
literal|"C\n"
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|status
operator|=
name|get_status
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Read up to LENGTH bytes into BUFFER from remote tape connection HANDLE.    Return the number of bytes read on success, SAFE_READ_ERROR on error.  */
end_comment

begin_function
name|size_t
name|rmt_read__
parameter_list|(
name|int
name|handle
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|char
name|command_buffer
index|[
name|COMMAND_BUFFER_SIZE
index|]
decl_stmt|;
name|size_t
name|status
decl_stmt|;
name|size_t
name|rlen
decl_stmt|;
name|size_t
name|counter
decl_stmt|;
name|sprintf
argument_list|(
name|command_buffer
argument_list|,
literal|"R%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_command
argument_list|(
name|handle
argument_list|,
name|command_buffer
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|status
operator|=
name|get_status
argument_list|(
name|handle
argument_list|)
operator|)
operator|==
name|SAFE_READ_ERROR
condition|)
return|return
name|SAFE_READ_ERROR
return|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|status
condition|;
name|counter
operator|+=
name|rlen
operator|,
name|buffer
operator|+=
name|rlen
control|)
block|{
name|rlen
operator|=
name|safe_read
argument_list|(
name|READ_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|status
operator|-
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|==
name|SAFE_READ_ERROR
operator|||
name|rlen
operator|==
literal|0
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
name|SAFE_READ_ERROR
return|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Write LENGTH bytes from BUFFER to remote tape connection HANDLE.    Return the number of bytes written.  */
end_comment

begin_function
name|size_t
name|rmt_write__
parameter_list|(
name|int
name|handle
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|char
name|command_buffer
index|[
name|COMMAND_BUFFER_SIZE
index|]
decl_stmt|;
name|RETSIGTYPE
function_decl|(
modifier|*
name|pipe_handler
function_decl|)
parameter_list|()
function_decl|;
name|size_t
name|written
decl_stmt|;
name|sprintf
argument_list|(
name|command_buffer
argument_list|,
literal|"W%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_command
argument_list|(
name|handle
argument_list|,
name|command_buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|pipe_handler
operator|=
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|written
operator|=
name|full_write
argument_list|(
name|WRITE_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
name|length
condition|)
block|{
name|long
name|int
name|r
init|=
name|get_status
argument_list|(
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|r
operator|==
name|length
condition|)
return|return
name|length
return|;
name|written
operator|=
name|r
expr_stmt|;
block|}
comment|/* Write error.  */
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
name|written
return|;
block|}
end_function

begin_comment
comment|/* Perform an imitation lseek operation on remote tape connection    HANDLE.  Return the new file offset if successful, -1 if on error.  */
end_comment

begin_function
name|off_t
name|rmt_lseek__
parameter_list|(
name|int
name|handle
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|char
name|command_buffer
index|[
name|COMMAND_BUFFER_SIZE
index|]
decl_stmt|;
name|char
name|operand_buffer
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|uintmax_t
name|u
init|=
name|offset
operator|<
literal|0
condition|?
operator|-
operator|(
name|uintmax_t
operator|)
name|offset
else|:
operator|(
name|uintmax_t
operator|)
name|offset
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|operand_buffer
operator|+
sizeof|sizeof
name|operand_buffer
decl_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
do|do
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
call|(
name|int
call|)
argument_list|(
name|u
operator|%
literal|10
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|u
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|whence
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|whence
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|whence
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|command_buffer
argument_list|,
literal|"L%s\n%d\n"
argument_list|,
name|p
argument_list|,
name|whence
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_command
argument_list|(
name|handle
argument_list|,
name|command_buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|get_status_off
argument_list|(
name|handle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform a raw tape operation on remote tape connection HANDLE.    Return the results of the ioctl, or -1 on error.  */
end_comment

begin_function
name|int
name|rmt_ioctl__
parameter_list|(
name|int
name|handle
parameter_list|,
name|int
name|operation
parameter_list|,
name|char
modifier|*
name|argument
parameter_list|)
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
default|default:
name|errno
operator|=
name|EOPNOTSUPP
expr_stmt|;
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|MTIOCTOP
case|case
name|MTIOCTOP
case|:
block|{
name|char
name|command_buffer
index|[
name|COMMAND_BUFFER_SIZE
index|]
decl_stmt|;
name|char
name|operand_buffer
index|[
name|UINTMAX_STRSIZE_BOUND
index|]
decl_stmt|;
name|uintmax_t
name|u
init|=
operator|(
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|argument
operator|)
operator|->
name|mt_count
operator|<
literal|0
condition|?
operator|-
call|(
name|uintmax_t
call|)
argument_list|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|argument
argument_list|)
operator|->
name|mt_count
else|:
call|(
name|uintmax_t
call|)
argument_list|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|argument
argument_list|)
operator|->
name|mt_count
operator|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|operand_buffer
operator|+
sizeof|sizeof
name|operand_buffer
decl_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
do|do
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
call|(
name|int
call|)
argument_list|(
name|u
operator|%
literal|10
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|u
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|argument
operator|)
operator|->
name|mt_count
operator|<
literal|0
condition|)
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
comment|/* MTIOCTOP is the easy one.  Nothing is transferred in binary.  */
name|sprintf
argument_list|(
name|command_buffer
argument_list|,
literal|"I%d\n%s\n"
argument_list|,
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|argument
operator|)
operator|->
name|mt_op
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_command
argument_list|(
name|handle
argument_list|,
name|command_buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|get_status
argument_list|(
name|handle
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* MTIOCTOP */
ifdef|#
directive|ifdef
name|MTIOCGET
case|case
name|MTIOCGET
case|:
block|{
name|ssize_t
name|status
decl_stmt|;
name|size_t
name|counter
decl_stmt|;
comment|/* Grab the status and read it directly into the structure.  This 	   assumes that the status buffer is not padded and that 2 shorts 	   fit in a long without any word alignment problems; i.e., the 	   whole struct is contiguous.  NOTE - this is probably NOT a good 	   assumption.  */
if|if
condition|(
name|do_command
argument_list|(
name|handle
argument_list|,
literal|"S"
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|status
operator|=
name|get_status
argument_list|(
name|handle
argument_list|)
operator|,
name|status
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
name|status
operator|>
literal|0
condition|;
name|status
operator|-=
name|counter
operator|,
name|argument
operator|+=
name|counter
control|)
block|{
name|counter
operator|=
name|safe_read
argument_list|(
name|READ_SIDE
argument_list|(
name|handle
argument_list|)
argument_list|,
name|argument
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|==
name|SAFE_READ_ERROR
operator|||
name|counter
operator|==
literal|0
condition|)
block|{
name|_rmt_shutdown
argument_list|(
name|handle
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Check for byte position.  mt_type (or mt_model) is a small integer 	   field (normally) so we will check its magnitude.  If it is larger 	   than 256, we will assume that the bytes are swapped and go through 	   and reverse all the bytes.  */
if|if
condition|(
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|argument
operator|)
operator|->
name|MTIO_CHECK_FIELD
operator|<
literal|256
condition|)
return|return
literal|0
return|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|status
condition|;
name|counter
operator|+=
literal|2
control|)
block|{
name|char
name|copy
init|=
name|argument
index|[
name|counter
index|]
decl_stmt|;
name|argument
index|[
name|counter
index|]
operator|=
name|argument
index|[
name|counter
operator|+
literal|1
index|]
expr_stmt|;
name|argument
index|[
name|counter
operator|+
literal|1
index|]
operator|=
name|copy
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* MTIOCGET */
block|}
block|}
end_function

end_unit

