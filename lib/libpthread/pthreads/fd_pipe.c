begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ==== fd_pipe.c ============================================================  * Copyright (c) 1993 by Chris Provenzano, proven@athena.mit.edu  *  * Description : The new fast ITC pipe routines.  *  *  1.00 93/08/14 proven  *      -Started coding this file.  *  *	1.01 93/11/13 proven  *		-The functions readv() and writev() added.  */
end_comment

begin_include
include|#
directive|include
file|<pthread/copyright.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<pthread/fd_pipe.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pthread/posix.h>
end_include

begin_comment
comment|/* ==========================================================================  * The pipe lock is never unlocked until all pthreads waiting are done with it  * read()  */
end_comment

begin_function
name|ssize_t
name|__pipe_read
parameter_list|(
name|struct
name|__pipe
modifier|*
name|fd
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|semaphore
modifier|*
name|lock
decl_stmt|,
modifier|*
name|plock
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_ACCMODE
condition|)
block|{
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|lock
operator|=
operator|&
operator|(
name|fd
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
comment|/* If there is nothing to read, go to sleep */
if|if
condition|(
name|fd
operator|->
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|WR_CLOSED
condition|)
block|{
name|SEMAPHORE_RESET
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Lock pthread */
name|plock
operator|=
operator|&
operator|(
name|pthread_run
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|plock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
comment|/* queue pthread for a FDR_WAIT */
name|pthread_run
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|fd
operator|->
name|wait
operator|=
name|pthread_run
expr_stmt|;
name|SEMAPHORE_RESET
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|reschedule
argument_list|(
name|PS_FDR_WAIT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fd
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|MIN
argument_list|(
name|nbytes
argument_list|,
name|fd
operator|->
name|count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|fd
operator|->
name|buf
operator|+
name|fd
operator|->
name|offset
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|count
operator|-=
name|ret
operator|)
condition|)
block|{
name|fd
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Should try to read more from the waiting writer */
if|if
condition|(
name|fd
operator|->
name|wait
condition|)
block|{
name|plock
operator|=
operator|&
operator|(
name|fd
operator|->
name|wait
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|plock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
name|fd
operator|->
name|wait
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
name|SEMAPHORE_RESET
argument_list|(
name|plock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SEMAPHORE_RESET
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * __pipe_write()  *  * First check to see if the read side is still open, then  * check to see if there is a thread in a read wait for this pipe, if so  * copy as much data as possible directly into the read waiting threads  * buffer. The write thread(whether or not there was a read thread)  * copies as much data as it can into the pipe buffer and it there  * is still data it goes to sleep.  */
end_comment

begin_function
name|ssize_t
name|__pipe_write
parameter_list|(
name|struct
name|__pipe
modifier|*
name|fd
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|semaphore
modifier|*
name|lock
decl_stmt|,
modifier|*
name|plock
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|O_ACCMODE
operator|)
condition|)
block|{
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|lock
operator|=
operator|&
operator|(
name|fd
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|fd
operator|->
name|flags
operator|!=
name|RD_CLOSED
condition|)
block|{
if|if
condition|(
name|fd
operator|->
name|wait
condition|)
block|{
comment|/* Lock pthread */
name|plock
operator|=
operator|&
operator|(
name|fd
operator|->
name|wait
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|plock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
comment|/* Copy data directly into waiting pthreads buf */
name|fd
operator|->
name|wait_size
operator|=
name|MIN
argument_list|(
name|nbytes
argument_list|,
name|fd
operator|->
name|wait_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fd
operator|->
name|wait_buf
argument_list|,
name|buf
argument_list|,
name|fd
operator|->
name|wait_size
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|+
name|fd
operator|->
name|wait_size
expr_stmt|;
name|nbytes
operator|-=
name|fd
operator|->
name|wait_size
expr_stmt|;
name|ret
operator|=
name|fd
operator|->
name|wait_size
expr_stmt|;
comment|/* Wake up waiting pthread */
name|fd
operator|->
name|wait
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
name|SEMAPHORE_RESET
argument_list|(
name|plock
argument_list|)
expr_stmt|;
name|fd
operator|->
name|wait
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|=
name|MIN
argument_list|(
name|nbytes
argument_list|,
name|fd
operator|->
name|size
operator|-
operator|(
name|fd
operator|->
name|offset
operator|+
name|fd
operator|->
name|count
operator|)
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|fd
operator|->
name|buf
operator|+
operator|(
name|fd
operator|->
name|offset
operator|+
name|fd
operator|->
name|count
operator|)
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|+
name|count
expr_stmt|;
name|nbytes
operator|-=
name|count
expr_stmt|;
name|ret
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
condition|)
block|{
comment|/* Lock pthread */
name|plock
operator|=
operator|&
operator|(
name|fd
operator|->
name|wait
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|plock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
name|fd
operator|->
name|wait
operator|=
name|pthread_run
expr_stmt|;
name|SEMAPHORE_RESET
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|reschedule
argument_list|(
name|PS_FDW_WAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * __pipe_close()  *  * The whole close procedure is a bit odd and needs a bit of a rethink.  * For now close() locks the fd, calls fd_free() which checks to see if  * there are any other fd values poinging to the same real fd. If so  * It breaks the wait queue into two sections those that are waiting on fd  * and those waiting on other fd's. Those that are waiting on fd are connected  * to the fd_table[fd] queue, and the count is set to zero, (BUT THE LOCK IS NOT  * RELEASED). close() then calls fd_unlock which give the fd to the next queued  * element which determins that the fd is closed and then calls fd_unlock etc...  */
end_comment

begin_function
name|int
name|__pipe_close
parameter_list|(
name|struct
name|__pipe
modifier|*
name|fd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|semaphore
modifier|*
name|lock
decl_stmt|,
modifier|*
name|plock
decl_stmt|;
name|lock
operator|=
operator|&
operator|(
name|fd
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|)
condition|)
block|{
if|if
condition|(
name|fd
operator|->
name|wait
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|O_ACCMODE
condition|)
block|{
name|fd
operator|->
name|flags
operator||=
name|WR_CLOSED
expr_stmt|;
comment|/* Lock pthread */
comment|/* Write side closed, wake read side and return EOF */
name|plock
operator|=
operator|&
operator|(
operator|(
name|fd
operator|->
name|wait
operator|)
operator|->
name|lock
operator|)
expr_stmt|;
while|while
condition|(
name|SEMAPHORE_TEST_AND_SET
argument_list|(
name|plock
argument_list|)
condition|)
block|{
name|pthread_yield
argument_list|()
expr_stmt|;
block|}
name|fd
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Wake up waiting pthread */
name|fd
operator|->
name|wait
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
name|SEMAPHORE_RESET
argument_list|(
name|plock
argument_list|)
expr_stmt|;
name|fd
operator|->
name|wait
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Should send a signal */
name|fd
operator|->
name|flags
operator||=
name|RD_CLOSED
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
name|SEMAPHORE_RESET
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ==========================================================================  * For those function that aren't implemented yet  * __pipe_enosys()  */
end_comment

begin_function
specifier|static
name|int
name|__pipe_enosys
parameter_list|()
block|{
name|pthread_run
operator|->
name|error
operator|=
name|ENOSYS
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * File descriptor operations  */
end_comment

begin_decl_stmt
name|struct
name|fd_ops
name|fd_ops
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|, }
block|,
comment|/* Non operations */
block|{
name|__pipe_write
block|,
name|__pipe_read
block|,
name|__pipe_close
block|,
name|__pipe_enosys
block|,
name|__pipe_enosys
block|,
name|__pipe_enosys
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==========================================================================  * open()  */
end_comment

begin_comment
comment|/* int __pipe_open(const char *path, int flags, ...) */
end_comment

begin_function
name|int
name|newpipe
parameter_list|(
name|int
name|fd
index|[
literal|2
index|]
parameter_list|)
block|{
name|struct
name|__pipe
modifier|*
name|fd_data
decl_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
operator|(
name|fd
index|[
literal|0
index|]
operator|=
name|fd_allocate
argument_list|()
operator|)
operator|<
name|OK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|fd
index|[
literal|1
index|]
operator|=
name|fd_allocate
argument_list|()
operator|)
operator|<
name|OK
operator|)
operator|)
condition|)
block|{
name|fd_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|__pipe
argument_list|)
argument_list|)
expr_stmt|;
name|fd_data
operator|->
name|buf
operator|=
name|malloc
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
name|fd_data
operator|->
name|size
operator|=
literal|4096
expr_stmt|;
name|fd_data
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|fd_data
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|fd_data
operator|->
name|wait
operator|=
name|NULL
expr_stmt|;
name|fd_data
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|fd_table
index|[
name|fd
index|[
literal|0
index|]
index|]
operator|->
name|fd
operator|.
name|ptr
operator|=
name|fd_data
expr_stmt|;
name|fd_table
index|[
name|fd
index|[
literal|0
index|]
index|]
operator|->
name|flags
operator|=
name|O_RDONLY
expr_stmt|;
name|fd_table
index|[
name|fd
index|[
literal|1
index|]
index|]
operator|->
name|fd
operator|.
name|ptr
operator|=
name|fd_data
expr_stmt|;
name|fd_table
index|[
name|fd
index|[
literal|1
index|]
index|]
operator|->
name|flags
operator|=
name|O_WRONLY
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
end_function

end_unit

