begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 John Birrell<jb@cimlogic.com.au>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"thr_private.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_PTHREADS_INVARIANTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MUTEX_INIT_LINK
parameter_list|(
name|m
parameter_list|)
value|do {		\ 	(m)->m_qe.tqe_prev = NULL;			\ 	(m)->m_qe.tqe_next = NULL;			\ } while (0)
end_define

begin_define
define|#
directive|define
name|MUTEX_ASSERT_IS_OWNED
parameter_list|(
name|m
parameter_list|)
value|do {		\ 	if ((m)->m_qe.tqe_prev == NULL)			\ 		PANIC("mutex is not on list");		\ } while (0)
end_define

begin_define
define|#
directive|define
name|MUTEX_ASSERT_NOT_OWNED
parameter_list|(
name|m
parameter_list|)
value|do {		\ 	if (((m)->m_qe.tqe_prev != NULL) ||		\ 	    ((m)->m_qe.tqe_next != NULL))		\ 		PANIC("mutex is on list");		\ } while (0)
end_define

begin_define
define|#
directive|define
name|THR_ASSERT_NOT_IN_SYNCQ
parameter_list|(
name|thr
parameter_list|)
value|do {		\ 	THR_ASSERT(((thr)->sflags& THR_FLAGS_IN_SYNCQ) == 0, \ 	    "thread in syncq when it shouldn't be.");	\ } while (0);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MUTEX_INIT_LINK
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|MUTEX_ASSERT_IS_OWNED
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|MUTEX_ASSERT_NOT_OWNED
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|THR_ASSERT_NOT_IN_SYNCQ
parameter_list|(
name|thr
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|THR_IN_MUTEXQ
parameter_list|(
name|thr
parameter_list|)
value|(((thr)->sflags& THR_FLAGS_IN_SYNCQ) != 0)
end_define

begin_define
define|#
directive|define
name|MUTEX_DESTROY
parameter_list|(
name|m
parameter_list|)
value|do {		\ 	_lock_destroy(&(m)->m_lock);	\ 	free(m);			\ } while (0)
end_define

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_function_decl
specifier|static
name|struct
name|kse_mailbox
modifier|*
name|mutex_handoff
parameter_list|(
name|struct
name|pthread
modifier|*
parameter_list|,
name|struct
name|pthread_mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|mutex_self_trylock
parameter_list|(
name|struct
name|pthread
modifier|*
parameter_list|,
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|mutex_self_lock
parameter_list|(
name|struct
name|pthread
modifier|*
parameter_list|,
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mutex_unlock_common
parameter_list|(
name|pthread_mutex_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mutex_priority_adjust
parameter_list|(
name|struct
name|pthread
modifier|*
parameter_list|,
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mutex_rescan_owned
parameter_list|(
name|struct
name|pthread
modifier|*
parameter_list|,
name|struct
name|pthread
modifier|*
parameter_list|,
name|struct
name|pthread_mutex
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|pthread_t
name|mutex_queue_deq
parameter_list|(
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mutex_queue_remove
parameter_list|(
name|pthread_mutex_t
parameter_list|,
name|pthread_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mutex_queue_enq
parameter_list|(
name|pthread_mutex_t
parameter_list|,
name|pthread_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mutex_lock_backout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|pthread_mutex_attr
name|static_mutex_attr
init|=
name|PTHREAD_MUTEXATTR_STATIC_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutexattr_t
name|static_mattr
init|=
operator|&
name|static_mutex_attr
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|__pthread_mutex_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|_pthread_mutex_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_DEFAULT
argument_list|(
name|pthread_mutex_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|__pthread_mutex_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|_pthread_mutex_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_DEFAULT
argument_list|(
name|pthread_mutex_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|__pthread_mutex_timedlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|_pthread_mutex_timedlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_DEFAULT
argument_list|(
name|pthread_mutex_timedlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|__pthread_mutex_trylock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|_pthread_mutex_trylock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_DEFAULT
argument_list|(
name|pthread_mutex_trylock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|_pthread_mutex_destroy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_DEFAULT
argument_list|(
name|pthread_mutex_destroy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_PRIVATE
argument_list|(
name|_pthread_mutex_unlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LT10_COMPAT_DEFAULT
argument_list|(
name|pthread_mutex_unlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Single underscore versions provided for libc internal usage: */
end_comment

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__pthread_mutex_init
argument_list|,
name|pthread_mutex_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__pthread_mutex_lock
argument_list|,
name|pthread_mutex_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__pthread_mutex_timedlock
argument_list|,
name|pthread_mutex_timedlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__pthread_mutex_trylock
argument_list|,
name|pthread_mutex_trylock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* No difference between libc and application usage of these: */
end_comment

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_pthread_mutex_destroy
argument_list|,
name|pthread_mutex_destroy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_pthread_mutex_unlock
argument_list|,
name|pthread_mutex_unlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|__pthread_mutex_init
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
specifier|const
name|pthread_mutexattr_t
modifier|*
name|mutex_attr
parameter_list|)
block|{
name|struct
name|pthread_mutex
modifier|*
name|pmutex
decl_stmt|;
name|enum
name|pthread_mutextype
name|type
decl_stmt|;
name|int
name|protocol
decl_stmt|;
name|int
name|ceiling
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* Check if default mutex attributes: */
elseif|else
if|if
condition|(
name|mutex_attr
operator|==
name|NULL
operator|||
operator|*
name|mutex_attr
operator|==
name|NULL
condition|)
block|{
comment|/* Default to a (error checking) POSIX mutex: */
name|type
operator|=
name|PTHREAD_MUTEX_ERRORCHECK
expr_stmt|;
name|protocol
operator|=
name|PTHREAD_PRIO_NONE
expr_stmt|;
name|ceiling
operator|=
name|THR_MAX_PRIORITY
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check mutex type: */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_type
operator|<
name|PTHREAD_MUTEX_ERRORCHECK
operator|)
operator|||
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_type
operator|>=
name|PTHREAD_MUTEX_TYPE_MAX
operator|)
condition|)
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* Check mutex protocol: */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_protocol
operator|<
name|PTHREAD_PRIO_NONE
operator|)
operator|||
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_protocol
operator|>
name|PTHREAD_MUTEX_RECURSIVE
operator|)
condition|)
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* Use the requested mutex type and protocol: */
name|type
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_type
expr_stmt|;
name|protocol
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_protocol
expr_stmt|;
name|ceiling
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_ceiling
expr_stmt|;
name|flags
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_flags
expr_stmt|;
block|}
comment|/* Check no errors so far: */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pmutex
operator|=
operator|(
name|pthread_mutex_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pthread_mutex
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ret
operator|=
name|ENOMEM
expr_stmt|;
elseif|else
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|pmutex
operator|->
name|m_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_thr_lock_wait
argument_list|,
name|_thr_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pmutex
argument_list|)
expr_stmt|;
operator|*
name|mutex
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the mutex flags: */
name|pmutex
operator|->
name|m_flags
operator|=
name|flags
expr_stmt|;
comment|/* Process according to mutex type: */
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* case PTHREAD_MUTEX_DEFAULT: */
case|case
name|PTHREAD_MUTEX_ERRORCHECK
case|:
case|case
name|PTHREAD_MUTEX_NORMAL
case|:
comment|/* Nothing to do here. */
break|break;
comment|/* Single UNIX Spec 2 recursive mutex: */
case|case
name|PTHREAD_MUTEX_RECURSIVE
case|:
comment|/* Reset the mutex count: */
name|pmutex
operator|->
name|m_count
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Trap invalid mutex types: */
default|default:
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Initialise the rest of the mutex: */
name|TAILQ_INIT
argument_list|(
operator|&
name|pmutex
operator|->
name|m_queue
argument_list|)
expr_stmt|;
name|pmutex
operator|->
name|m_flags
operator||=
name|MUTEX_FLAGS_INITED
expr_stmt|;
name|pmutex
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
name|pmutex
operator|->
name|m_type
operator|=
name|type
expr_stmt|;
name|pmutex
operator|->
name|m_protocol
operator|=
name|protocol
expr_stmt|;
name|pmutex
operator|->
name|m_refcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PTHREAD_PRIO_PROTECT
condition|)
name|pmutex
operator|->
name|m_prio
operator|=
name|ceiling
expr_stmt|;
else|else
name|pmutex
operator|->
name|m_prio
operator|=
operator|-
literal|1
expr_stmt|;
name|pmutex
operator|->
name|m_saved_prio
operator|=
literal|0
expr_stmt|;
name|MUTEX_INIT_LINK
argument_list|(
name|pmutex
argument_list|)
expr_stmt|;
operator|*
name|mutex
operator|=
name|pmutex
expr_stmt|;
block|}
else|else
block|{
comment|/* Free the mutex lock structure: */
name|MUTEX_DESTROY
argument_list|(
name|pmutex
argument_list|)
expr_stmt|;
operator|*
name|mutex
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_init
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
specifier|const
name|pthread_mutexattr_t
modifier|*
name|mutex_attr
parameter_list|)
block|{
name|struct
name|pthread_mutex_attr
name|mattr
decl_stmt|,
modifier|*
name|mattrp
decl_stmt|;
if|if
condition|(
operator|(
name|mutex_attr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|mutex_attr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|__pthread_mutex_init
argument_list|(
name|mutex
argument_list|,
operator|&
name|static_mattr
argument_list|)
operator|)
return|;
else|else
block|{
name|mattr
operator|=
operator|*
operator|*
name|mutex_attr
expr_stmt|;
name|mattr
operator|.
name|m_flags
operator||=
name|MUTEX_FLAGS_PRIVATE
expr_stmt|;
name|mattrp
operator|=
operator|&
name|mattr
expr_stmt|;
return|return
operator|(
name|__pthread_mutex_init
argument_list|(
name|mutex
argument_list|,
operator|&
name|mattrp
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|_thr_mutex_reinit
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|_lock_reinit
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_thr_lock_wait
argument_list|,
name|_thr_lock_wakeup
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_queue
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_refcount
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_destroy
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|pthread_mutex_t
name|m
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
operator|||
operator|*
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* Lock the mutex structure: */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if this mutex is in use: 		 */
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_queue
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_refcount
operator|!=
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Save a pointer to the mutex so it can be free'd 			 * and set the caller's pointer to NULL: 			 */
name|m
operator|=
operator|*
name|mutex
expr_stmt|;
operator|*
name|mutex
operator|=
name|NULL
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* 			 * Free the memory allocated for the mutex 			 * structure: 			 */
name|MUTEX_ASSERT_NOT_OWNED
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|MUTEX_DESTROY
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_static
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|THR_LOCK_ACQUIRE
argument_list|(
name|thread
argument_list|,
operator|&
name|_mutex_static_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|pthread_mutex_init
argument_list|(
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|thread
argument_list|,
operator|&
name|_mutex_static_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_static_private
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|THR_LOCK_ACQUIRE
argument_list|(
name|thread
argument_list|,
operator|&
name|_mutex_static_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|pthread_mutex_init
argument_list|(
name|mutex
argument_list|,
operator|&
name|static_mattr
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|thread
argument_list|,
operator|&
name|_mutex_static_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mutex_trylock_common
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|private
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|THR_ASSERT
argument_list|(
operator|(
name|mutex
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
argument_list|,
literal|"Uninitialized mutex in pthread_mutex_trylock_basic"
argument_list|)
expr_stmt|;
comment|/* Lock the mutex structure: */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
name|private
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_PRIVATE
expr_stmt|;
comment|/* 	 * If the mutex was statically allocated, properly 	 * initialize the tail queue. 	 */
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_queue
argument_list|)
expr_stmt|;
name|MUTEX_INIT_LINK
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_flags
operator||=
name|MUTEX_FLAGS_INITED
expr_stmt|;
block|}
comment|/* Process according to mutex type: */
switch|switch
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_protocol
condition|)
block|{
comment|/* Default POSIX mutex: */
case|case
name|PTHREAD_PRIO_NONE
case|:
comment|/* Check if this mutex is not locked: */
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|)
block|{
comment|/* Lock the mutex for the running thread: */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
comment|/* Add to the list of owned mutexes: */
name|MUTEX_ASSERT_NOT_OWNED
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|curthread
condition|)
name|ret
operator|=
name|mutex_self_trylock
argument_list|(
name|curthread
argument_list|,
operator|*
name|mutex
argument_list|)
expr_stmt|;
else|else
comment|/* Return a busy error: */
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
comment|/* POSIX priority inheritence mutex: */
case|case
name|PTHREAD_PRIO_INHERIT
case|:
comment|/* Check if this mutex is not locked: */
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|)
block|{
comment|/* Lock the mutex for the running thread: */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Track number of priority mutexes owned: */
name|curthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 			 * The mutex takes on the attributes of the 			 * running thread when there are no waiters. 			 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
operator|=
name|curthread
operator|->
name|active_priority
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
name|curthread
operator|->
name|inherited_priority
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Add to the list of owned mutexes: */
name|MUTEX_ASSERT_NOT_OWNED
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|curthread
condition|)
name|ret
operator|=
name|mutex_self_trylock
argument_list|(
name|curthread
argument_list|,
operator|*
name|mutex
argument_list|)
expr_stmt|;
else|else
comment|/* Return a busy error: */
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
comment|/* POSIX priority protection mutex: */
case|case
name|PTHREAD_PRIO_PROTECT
case|:
comment|/* Check for a priority ceiling violation: */
if|if
condition|(
name|curthread
operator|->
name|active_priority
operator|>
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* Check if this mutex is not locked: */
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|)
block|{
comment|/* Lock the mutex for the running thread: */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Track number of priority mutexes owned: */
name|curthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 			 * The running thread inherits the ceiling 			 * priority of the mutex and executes at that 			 * priority. 			 */
name|curthread
operator|->
name|active_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
name|curthread
operator|->
name|inherited_priority
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Add to the list of owned mutexes: */
name|MUTEX_ASSERT_NOT_OWNED
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|curthread
condition|)
name|ret
operator|=
name|mutex_self_trylock
argument_list|(
name|curthread
argument_list|,
operator|*
name|mutex
argument_list|)
expr_stmt|;
else|else
comment|/* Return a busy error: */
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
comment|/* Trap invalid mutex types: */
default|default:
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|private
condition|)
name|THR_CRITICAL_ENTER
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__pthread_mutex_trylock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization: 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static
argument_list|(
name|curthread
argument_list|,
name|mutex
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_trylock_common
argument_list|(
name|curthread
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_trylock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization marking the mutex private (delete safe): 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static_private
argument_list|(
name|curthread
argument_list|,
name|mutex
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_trylock_common
argument_list|(
name|curthread
argument_list|,
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mutex_lock_common
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|pthread_mutex_t
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|abstime
parameter_list|)
block|{
name|int
name|private
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|THR_ASSERT
argument_list|(
operator|(
name|m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|m
operator|!=
name|NULL
operator|)
argument_list|,
literal|"Uninitialized mutex in pthread_mutex_trylock_basic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|abstime
operator|!=
name|NULL
operator|&&
operator|(
name|abstime
operator|->
name|tv_sec
operator|<
literal|0
operator|||
name|abstime
operator|->
name|tv_nsec
operator|<
literal|0
operator|||
name|abstime
operator|->
name|tv_nsec
operator|>=
literal|1000000000
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Reset the interrupted flag: */
name|curthread
operator|->
name|interrupted
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|private
operator|=
operator|(
operator|*
name|m
operator|)
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_PRIVATE
expr_stmt|;
comment|/* 	 * Enter a loop waiting to become the mutex owner.  We need a 	 * loop in case the waiting thread is interrupted by a signal 	 * to execute a signal handler.  It is not (currently) possible 	 * to remain in the waiting queue while running a handler. 	 * Instead, the thread is interrupted and backed out of the 	 * waiting queue prior to executing the signal handler. 	 */
do|do
block|{
comment|/* Lock the mutex structure: */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If the mutex was statically allocated, properly 		 * initialize the tail queue. 		 */
if|if
condition|(
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_queue
argument_list|)
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_flags
operator||=
name|MUTEX_FLAGS_INITED
expr_stmt|;
name|MUTEX_INIT_LINK
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Process according to mutex type: */
switch|switch
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_protocol
condition|)
block|{
comment|/* Default POSIX mutex: */
case|case
name|PTHREAD_PRIO_NONE
case|:
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|)
block|{
comment|/* Lock the mutex for this thread: */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
comment|/* Add to the list of owned mutexes: */
name|MUTEX_ASSERT_NOT_OWNED
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|m
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
condition|)
name|THR_CRITICAL_ENTER
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|==
name|curthread
condition|)
block|{
name|ret
operator|=
name|mutex_self_lock
argument_list|(
name|curthread
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Join the queue of threads waiting to lock 				 * the mutex and save a pointer to the mutex. 				 */
name|mutex_queue_enq
argument_list|(
operator|*
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
operator|*
name|m
expr_stmt|;
name|curthread
operator|->
name|sigbackout
operator|=
name|mutex_lock_backout
expr_stmt|;
comment|/* 				 * This thread is active and is in a critical 				 * region (holding the mutex lock); we should 				 * be able to safely set the state. 				 */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Set the wakeup time: */
if|if
condition|(
name|abstime
condition|)
block|{
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
name|abstime
operator|->
name|tv_sec
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
name|abstime
operator|->
name|tv_nsec
expr_stmt|;
block|}
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_MUTEX_WAIT
argument_list|)
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Schedule the next thread: */
name|_thr_sched_switch
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|THR_IN_MUTEXQ
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
name|mutex_queue_remove
argument_list|(
operator|*
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Only clear these after assuring the 				 * thread is dequeued. 				 */
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|sigbackout
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
comment|/* POSIX priority inheritence mutex: */
case|case
name|PTHREAD_PRIO_INHERIT
case|:
comment|/* Check if this mutex is not locked: */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|)
block|{
comment|/* Lock the mutex for this thread: */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Track number of priority mutexes owned: */
name|curthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 				 * The mutex takes on attributes of the 				 * running thread when there are no waiters. 				 * Make sure the thread's scheduling lock is 				 * held while priorities are adjusted. 				 */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_prio
operator|=
name|curthread
operator|->
name|active_priority
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_saved_prio
operator|=
name|curthread
operator|->
name|inherited_priority
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|m
operator|)
operator|->
name|m_prio
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Add to the list of owned mutexes: */
name|MUTEX_ASSERT_NOT_OWNED
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|m
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
condition|)
name|THR_CRITICAL_ENTER
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|==
name|curthread
condition|)
block|{
name|ret
operator|=
name|mutex_self_lock
argument_list|(
name|curthread
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Join the queue of threads waiting to lock 				 * the mutex and save a pointer to the mutex. 				 */
name|mutex_queue_enq
argument_list|(
operator|*
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
operator|*
name|m
expr_stmt|;
name|curthread
operator|->
name|sigbackout
operator|=
name|mutex_lock_backout
expr_stmt|;
comment|/* 				 * This thread is active and is in a critical 				 * region (holding the mutex lock); we should 				 * be able to safely set the state. 				 */
if|if
condition|(
name|curthread
operator|->
name|active_priority
operator|>
operator|(
operator|*
name|m
operator|)
operator|->
name|m_prio
condition|)
comment|/* Adjust priorities: */
name|mutex_priority_adjust
argument_list|(
name|curthread
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Set the wakeup time: */
if|if
condition|(
name|abstime
condition|)
block|{
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
name|abstime
operator|->
name|tv_sec
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
name|abstime
operator|->
name|tv_nsec
expr_stmt|;
block|}
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_MUTEX_WAIT
argument_list|)
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Schedule the next thread: */
name|_thr_sched_switch
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|THR_IN_MUTEXQ
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
name|mutex_queue_remove
argument_list|(
operator|*
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Only clear these after assuring the 				 * thread is dequeued. 				 */
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|sigbackout
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
comment|/* POSIX priority protection mutex: */
case|case
name|PTHREAD_PRIO_PROTECT
case|:
comment|/* Check for a priority ceiling violation: */
if|if
condition|(
name|curthread
operator|->
name|active_priority
operator|>
operator|(
operator|*
name|m
operator|)
operator|->
name|m_prio
condition|)
block|{
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* Check if this mutex is not locked: */
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Lock the mutex for the running 				 * thread: 				 */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Track number of priority mutexes owned: */
name|curthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 				 * The running thread inherits the ceiling 				 * priority of the mutex and executes at that 				 * priority.  Make sure the thread's 				 * scheduling lock is held while priorities 				 * are adjusted. 				 */
name|curthread
operator|->
name|active_priority
operator|=
operator|(
operator|*
name|m
operator|)
operator|->
name|m_prio
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_saved_prio
operator|=
name|curthread
operator|->
name|inherited_priority
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|m
operator|)
operator|->
name|m_prio
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Add to the list of owned mutexes: */
name|MUTEX_ASSERT_NOT_OWNED
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|m
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
condition|)
name|THR_CRITICAL_ENTER
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|==
name|curthread
condition|)
block|{
name|ret
operator|=
name|mutex_self_lock
argument_list|(
name|curthread
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Join the queue of threads waiting to lock 				 * the mutex and save a pointer to the mutex. 				 */
name|mutex_queue_enq
argument_list|(
operator|*
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
operator|*
name|m
expr_stmt|;
name|curthread
operator|->
name|sigbackout
operator|=
name|mutex_lock_backout
expr_stmt|;
comment|/* Clear any previous error: */
name|curthread
operator|->
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 				 * This thread is active and is in a critical 				 * region (holding the mutex lock); we should 				 * be able to safely set the state. 				 */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Set the wakeup time: */
if|if
condition|(
name|abstime
condition|)
block|{
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
name|abstime
operator|->
name|tv_sec
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
name|abstime
operator|->
name|tv_nsec
expr_stmt|;
block|}
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_MUTEX_WAIT
argument_list|)
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Schedule the next thread: */
name|_thr_sched_switch
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|THR_IN_MUTEXQ
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
name|mutex_queue_remove
argument_list|(
operator|*
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Only clear these after assuring the 				 * thread is dequeued. 				 */
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|sigbackout
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * The threads priority may have changed while 				 * waiting for the mutex causing a ceiling 				 * violation. 				 */
name|ret
operator|=
name|curthread
operator|->
name|error
expr_stmt|;
name|curthread
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
comment|/* Trap invalid mutex types: */
default|default:
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
operator|)
operator|&&
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|curthread
operator|->
name|interrupted
operator|==
literal|0
operator|)
operator|&&
operator|(
name|curthread
operator|->
name|timeout
operator|==
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
operator|&&
name|curthread
operator|->
name|timeout
condition|)
name|ret
operator|=
name|ETIMEDOUT
expr_stmt|;
comment|/* 	 * Check to see if this thread was interrupted and 	 * is still in the mutex queue of waiting threads: 	 */
if|if
condition|(
name|curthread
operator|->
name|interrupted
operator|!=
literal|0
condition|)
block|{
comment|/* Remove this thread from the mutex queue. */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|THR_IN_SYNCQ
argument_list|(
name|curthread
argument_list|)
condition|)
name|mutex_queue_remove
argument_list|(
operator|*
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Check for asynchronous cancellation. */
if|if
condition|(
name|curthread
operator|->
name|continuation
operator|!=
name|NULL
condition|)
name|curthread
operator|->
name|continuation
argument_list|(
operator|(
name|void
operator|*
operator|)
name|curthread
argument_list|)
expr_stmt|;
block|}
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__pthread_mutex_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|_thr_initial
operator|==
name|NULL
condition|)
name|_libpthread_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization: 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__strong_reference
argument_list|(
name|__pthread_mutex_lock
argument_list|,
name|_thr_mutex_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_pthread_mutex_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|_thr_initial
operator|==
name|NULL
condition|)
name|_libpthread_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization marking it private (delete safe): 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static_private
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__pthread_mutex_timedlock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|abs_timeout
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|_thr_initial
operator|==
name|NULL
condition|)
name|_libpthread_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization: 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|,
name|abs_timeout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_timedlock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|abs_timeout
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|_thr_initial
operator|==
name|NULL
condition|)
name|_libpthread_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization marking it private (delete safe): 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|m
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static_private
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|,
name|abs_timeout
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_unlock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|mutex_unlock_common
argument_list|(
name|m
argument_list|,
comment|/* add reference */
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__strong_reference
argument_list|(
name|_pthread_mutex_unlock
argument_list|,
name|_thr_mutex_unlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_mutex_cv_unlock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|mutex_unlock_common
argument_list|(
name|m
argument_list|,
comment|/* add reference */
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_mutex_cv_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|_pthread_mutex_lock
argument_list|(
name|m
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
operator|(
operator|*
name|m
operator|)
operator|->
name|m_refcount
operator|--
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mutex_self_trylock
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|pthread_mutex_t
name|m
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|m
operator|->
name|m_type
condition|)
block|{
comment|/* case PTHREAD_MUTEX_DEFAULT: */
case|case
name|PTHREAD_MUTEX_ERRORCHECK
case|:
case|case
name|PTHREAD_MUTEX_NORMAL
case|:
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
case|case
name|PTHREAD_MUTEX_RECURSIVE
case|:
comment|/* Increment the lock count: */
name|m
operator|->
name|m_count
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Trap invalid mutex types; */
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mutex_self_lock
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|pthread_mutex_t
name|m
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * Don't allow evil recursive mutexes for private use 	 * in libc and libpthread. 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_PRIVATE
condition|)
name|PANIC
argument_list|(
literal|"Recurse on a private mutex."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m
operator|->
name|m_type
condition|)
block|{
comment|/* case PTHREAD_MUTEX_DEFAULT: */
case|case
name|PTHREAD_MUTEX_ERRORCHECK
case|:
comment|/* 		 * POSIX specifies that mutexes should return EDEADLK if a 		 * recursive lock is detected. 		 */
name|ret
operator|=
name|EDEADLK
expr_stmt|;
break|break;
case|case
name|PTHREAD_MUTEX_NORMAL
case|:
comment|/* 		 * What SS2 define as a 'normal' mutex.  Intentionally 		 * deadlock on attempts to get a lock you already own. 		 */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_DEADLOCK
argument_list|)
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Schedule the next thread: */
name|_thr_sched_switch
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTHREAD_MUTEX_RECURSIVE
case|:
comment|/* Increment the lock count: */
name|m
operator|->
name|m_count
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Trap invalid mutex types; */
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mutex_unlock_common
parameter_list|(
name|pthread_mutex_t
modifier|*
name|m
parameter_list|,
name|int
name|add_reference
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|struct
name|kse_mailbox
modifier|*
name|kmbx
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|*
name|m
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* Lock the mutex structure: */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Process according to mutex type: */
switch|switch
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_protocol
condition|)
block|{
comment|/* Default POSIX mutex: */
case|case
name|PTHREAD_PRIO_NONE
case|:
comment|/* 			 * Check if the running thread is not the owner of the 			 * mutex: 			 */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
condition|)
name|ret
operator|=
name|EPERM
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_type
operator|==
name|PTHREAD_MUTEX_RECURSIVE
operator|)
operator|&&
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|>
literal|0
operator|)
condition|)
comment|/* Decrement the count: */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|--
expr_stmt|;
else|else
block|{
comment|/* 				 * Clear the count in case this is a recursive 				 * mutex. 				 */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|=
literal|0
expr_stmt|;
comment|/* Remove the mutex from the threads queue. */
name|MUTEX_ASSERT_IS_OWNED
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|m
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
name|MUTEX_INIT_LINK
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * Hand off the mutex to the next waiting 				 * thread: 				 */
name|kmbx
operator|=
name|mutex_handoff
argument_list|(
name|curthread
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* POSIX priority inheritence mutex: */
case|case
name|PTHREAD_PRIO_INHERIT
case|:
comment|/* 			 * Check if the running thread is not the owner of the 			 * mutex: 			 */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
condition|)
name|ret
operator|=
name|EPERM
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_type
operator|==
name|PTHREAD_MUTEX_RECURSIVE
operator|)
operator|&&
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|>
literal|0
operator|)
condition|)
comment|/* Decrement the count: */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|--
expr_stmt|;
else|else
block|{
comment|/* 				 * Clear the count in case this is recursive 				 * mutex. 				 */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Restore the threads inherited priority and 				 * recompute the active priority (being careful 				 * not to override changes in the threads base 				 * priority subsequent to locking the mutex). 				 */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|m
operator|)
operator|->
name|m_saved_prio
expr_stmt|;
name|curthread
operator|->
name|active_priority
operator|=
name|MAX
argument_list|(
name|curthread
operator|->
name|inherited_priority
argument_list|,
name|curthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
comment|/* 				 * This thread now owns one less priority mutex. 				 */
name|curthread
operator|->
name|priority_mutex_count
operator|--
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Remove the mutex from the threads queue. */
name|MUTEX_ASSERT_IS_OWNED
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|m
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
name|MUTEX_INIT_LINK
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * Hand off the mutex to the next waiting 				 * thread: 				 */
name|kmbx
operator|=
name|mutex_handoff
argument_list|(
name|curthread
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* POSIX priority ceiling mutex: */
case|case
name|PTHREAD_PRIO_PROTECT
case|:
comment|/* 			 * Check if the running thread is not the owner of the 			 * mutex: 			 */
if|if
condition|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
condition|)
name|ret
operator|=
name|EPERM
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_type
operator|==
name|PTHREAD_MUTEX_RECURSIVE
operator|)
operator|&&
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|>
literal|0
operator|)
condition|)
comment|/* Decrement the count: */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|--
expr_stmt|;
else|else
block|{
comment|/* 				 * Clear the count in case this is a recursive 				 * mutex. 				 */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_count
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Restore the threads inherited priority and 				 * recompute the active priority (being careful 				 * not to override changes in the threads base 				 * priority subsequent to locking the mutex). 				 */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|m
operator|)
operator|->
name|m_saved_prio
expr_stmt|;
name|curthread
operator|->
name|active_priority
operator|=
name|MAX
argument_list|(
name|curthread
operator|->
name|inherited_priority
argument_list|,
name|curthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
comment|/* 				 * This thread now owns one less priority mutex. 				 */
name|curthread
operator|->
name|priority_mutex_count
operator|--
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* Remove the mutex from the threads queue. */
name|MUTEX_ASSERT_IS_OWNED
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|m
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
name|MUTEX_INIT_LINK
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * Hand off the mutex to the next waiting 				 * thread: 				 */
name|kmbx
operator|=
name|mutex_handoff
argument_list|(
name|curthread
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Trap invalid mutex types: */
default|default:
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|add_reference
operator|!=
literal|0
operator|)
condition|)
comment|/* Increment the reference count: */
operator|(
operator|*
name|m
operator|)
operator|->
name|m_refcount
operator|++
expr_stmt|;
comment|/* Leave the critical region if this is a private mutex. */
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_PRIVATE
operator|)
condition|)
name|THR_CRITICAL_LEAVE
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
operator|*
name|m
operator|)
operator|->
name|m_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmbx
operator|!=
name|NULL
condition|)
name|kse_wakeup
argument_list|(
name|kmbx
argument_list|)
expr_stmt|;
block|}
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called when a change in base priority occurs for  * a thread that is holding or waiting for a priority protection or  * inheritence mutex.  A change in a threads base priority can effect  * changes to active priorities of other threads and to the ordering  * of mutex locking by waiting threads.  *  * This must be called without the target thread's scheduling lock held.  */
end_comment

begin_function
name|void
name|_mutex_notify_priochange
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|pthread
parameter_list|,
name|int
name|propagate_prio
parameter_list|)
block|{
name|struct
name|pthread_mutex
modifier|*
name|m
decl_stmt|;
comment|/* Adjust the priorites of any owned priority mutexes: */
if|if
condition|(
name|pthread
operator|->
name|priority_mutex_count
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Rescan the mutexes owned by this thread and correct 		 * their priorities to account for this threads change 		 * in priority.  This has the side effect of changing 		 * the threads active priority. 		 * 		 * Be sure to lock the first mutex in the list of owned 		 * mutexes.  This acts as a barrier against another 		 * simultaneous call to change the threads priority 		 * and from the owning thread releasing the mutex. 		 */
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure the thread still owns the lock. 			 */
if|if
condition|(
name|m
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|)
condition|)
name|mutex_rescan_owned
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|,
comment|/* rescan all owned */
name|NULL
argument_list|)
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If this thread is waiting on a priority inheritence mutex, 	 * check for priority adjustments.  A change in priority can 	 * also cause a ceiling violation(*) for a thread waiting on 	 * a priority protection mutex; we don't perform the check here 	 * as it is done in pthread_mutex_unlock. 	 * 	 * (*) It should be noted that a priority change to a thread 	 *     _after_ taking and owning a priority ceiling mutex 	 *     does not affect ownership of that mutex; the ceiling 	 *     priority is only checked before mutex ownership occurs. 	 */
if|if
condition|(
name|propagate_prio
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Lock the thread's scheduling queue.  This is a bit 		 * convoluted; the "in synchronization queue flag" can 		 * only be cleared with both the thread's scheduling and 		 * mutex locks held.  The thread's pointer to the wanted 		 * mutex is guaranteed to be valid during this time. 		 */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|pthread
operator|->
name|sflags
operator|&
name|THR_FLAGS_IN_SYNCQ
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|m
operator|=
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|)
operator|==
name|NULL
operator|)
condition|)
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * This thread is currently waiting on a mutex; unlock 			 * the scheduling queue lock and lock the mutex.  We 			 * can't hold both at the same time because the locking 			 * order could cause a deadlock. 			 */
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* 			 * Check to make sure this thread is still in the 			 * same state (the lock above can yield the CPU to 			 * another thread or the thread may be running on 			 * another CPU). 			 */
if|if
condition|(
operator|(
operator|(
name|pthread
operator|->
name|sflags
operator|&
name|THR_FLAGS_IN_SYNCQ
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|==
name|m
operator|)
condition|)
block|{
comment|/* 				 * Remove and reinsert this thread into 				 * the list of waiting threads to preserve 				 * decreasing priority order. 				 */
name|mutex_queue_remove
argument_list|(
name|m
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
name|mutex_queue_enq
argument_list|(
name|m
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_protocol
operator|==
name|PTHREAD_PRIO_INHERIT
condition|)
comment|/* Adjust priorities: */
name|mutex_priority_adjust
argument_list|(
name|curthread
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Unlock the mutex structure: */
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Called when a new thread is added to the mutex waiting queue or  * when a threads priority changes that is already in the mutex  * waiting queue.  *  * This must be called with the mutex locked by the current thread.  */
end_comment

begin_function
specifier|static
name|void
name|mutex_priority_adjust
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|pthread_mutex_t
name|mutex
parameter_list|)
block|{
name|pthread_mutex_t
name|m
init|=
name|mutex
decl_stmt|;
name|struct
name|pthread
modifier|*
name|pthread_next
decl_stmt|,
modifier|*
name|pthread
init|=
name|mutex
operator|->
name|m_owner
decl_stmt|;
name|int
name|done
decl_stmt|,
name|temp_prio
decl_stmt|;
comment|/* 	 * Calculate the mutex priority as the maximum of the highest 	 * active priority of any waiting threads and the owning threads 	 * active priority(*). 	 * 	 * (*) Because the owning threads current active priority may 	 *     reflect priority inherited from this mutex (and the mutex 	 *     priority may have changed) we must recalculate the active 	 *     priority based on the threads saved inherited priority 	 *     and its base priority. 	 */
name|pthread_next
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|m_queue
argument_list|)
expr_stmt|;
comment|/* should never be NULL */
name|temp_prio
operator|=
name|MAX
argument_list|(
name|pthread_next
operator|->
name|active_priority
argument_list|,
name|MAX
argument_list|(
name|m
operator|->
name|m_saved_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this mutex really needs adjusting: */
if|if
condition|(
name|temp_prio
operator|==
name|m
operator|->
name|m_prio
condition|)
comment|/* No need to propagate the priority: */
return|return;
comment|/* Set new priority of the mutex: */
name|m
operator|->
name|m_prio
operator|=
name|temp_prio
expr_stmt|;
comment|/* 	 * Don't unlock the mutex passed in as an argument.  It is 	 * expected to be locked and unlocked by the caller. 	 */
name|done
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|/* 		 * Save the threads priority before rescanning the 		 * owned mutexes: 		 */
name|temp_prio
operator|=
name|pthread
operator|->
name|active_priority
expr_stmt|;
comment|/* 		 * Fix the priorities for all mutexes held by the owning 		 * thread since taking this mutex.  This also has a 		 * potential side-effect of changing the threads priority. 		 * 		 * At this point the mutex is locked by the current thread. 		 * The owning thread can't release the mutex until it is 		 * unlocked, so we should be able to safely walk its list 		 * of owned mutexes. 		 */
name|mutex_rescan_owned
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * If this isn't the first time through the loop, 		 * the current mutex needs to be unlocked. 		 */
if|if
condition|(
name|done
operator|==
literal|0
condition|)
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* Assume we're done unless told otherwise: */
name|done
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If the thread is currently waiting on a mutex, check 		 * to see if the threads new priority has affected the 		 * priority of the mutex. 		 */
if|if
condition|(
operator|(
name|temp_prio
operator|!=
name|pthread
operator|->
name|active_priority
operator|)
operator|&&
operator|(
operator|(
name|pthread
operator|->
name|sflags
operator|&
name|THR_FLAGS_IN_SYNCQ
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|m
operator|=
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_protocol
operator|==
name|PTHREAD_PRIO_INHERIT
operator|)
condition|)
block|{
comment|/* Lock the mutex structure: */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure the thread is still waiting on the 			 * mutex: 			 */
if|if
condition|(
operator|(
operator|(
name|pthread
operator|->
name|sflags
operator|&
name|THR_FLAGS_IN_SYNCQ
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|m
operator|==
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|)
condition|)
block|{
comment|/* 				 * The priority for this thread has changed. 				 * Remove and reinsert this thread into the 				 * list of waiting threads to preserve 				 * decreasing priority order. 				 */
name|mutex_queue_remove
argument_list|(
name|m
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
name|mutex_queue_enq
argument_list|(
name|m
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
comment|/* 				 * Grab the waiting thread with highest 				 * priority: 				 */
name|pthread_next
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|m_queue
argument_list|)
expr_stmt|;
comment|/* 				 * Calculate the mutex priority as the maximum 				 * of the highest active priority of any 				 * waiting threads and the owning threads 				 * active priority. 				 */
name|temp_prio
operator|=
name|MAX
argument_list|(
name|pthread_next
operator|->
name|active_priority
argument_list|,
name|MAX
argument_list|(
name|m
operator|->
name|m_saved_prio
argument_list|,
name|m
operator|->
name|m_owner
operator|->
name|base_priority
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_prio
operator|!=
name|m
operator|->
name|m_prio
condition|)
block|{
comment|/* 					 * The priority needs to be propagated 					 * to the mutex this thread is waiting 					 * on and up to the owner of that mutex. 					 */
name|m
operator|->
name|m_prio
operator|=
name|temp_prio
expr_stmt|;
name|pthread
operator|=
name|m
operator|->
name|m_owner
expr_stmt|;
comment|/* We're not done yet: */
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Only release the mutex if we're done: */
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|done
operator|==
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_rescan_owned
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|pthread
parameter_list|,
name|struct
name|pthread_mutex
modifier|*
name|mutex
parameter_list|)
block|{
name|struct
name|pthread_mutex
modifier|*
name|m
decl_stmt|;
name|struct
name|pthread
modifier|*
name|pthread_next
decl_stmt|;
name|int
name|active_prio
decl_stmt|,
name|inherited_prio
decl_stmt|;
comment|/* 	 * Start walking the mutexes the thread has taken since 	 * taking this mutex. 	 */
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * A null mutex means start at the beginning of the owned 		 * mutex list. 		 */
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|)
expr_stmt|;
comment|/* There is no inherited priority yet. */
name|inherited_prio
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The caller wants to start after a specific mutex.  It 		 * is assumed that this mutex is a priority inheritence 		 * mutex and that its priority has been correctly 		 * calculated. 		 */
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|mutex
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
comment|/* Start inheriting priority from the specified mutex. */
name|inherited_prio
operator|=
name|mutex
operator|->
name|m_prio
expr_stmt|;
block|}
name|active_prio
operator|=
name|MAX
argument_list|(
name|inherited_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|m_qe
argument_list|)
control|)
block|{
comment|/* 		 * We only want to deal with priority inheritence 		 * mutexes.  This might be optimized by only placing 		 * priority inheritence mutexes into the owned mutex 		 * list, but it may prove to be useful having all 		 * owned mutexes in this list.  Consider a thread 		 * exiting while holding mutexes... 		 */
if|if
condition|(
name|m
operator|->
name|m_protocol
operator|==
name|PTHREAD_PRIO_INHERIT
condition|)
block|{
comment|/* 			 * Fix the owners saved (inherited) priority to 			 * reflect the priority of the previous mutex. 			 */
name|m
operator|->
name|m_saved_prio
operator|=
name|inherited_prio
expr_stmt|;
if|if
condition|(
operator|(
name|pthread_next
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|m_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* Recalculate the priority of the mutex: */
name|m
operator|->
name|m_prio
operator|=
name|MAX
argument_list|(
name|active_prio
argument_list|,
name|pthread_next
operator|->
name|active_priority
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|m_prio
operator|=
name|active_prio
expr_stmt|;
comment|/* Recalculate new inherited and active priorities: */
name|inherited_prio
operator|=
name|m
operator|->
name|m_prio
expr_stmt|;
name|active_prio
operator|=
name|MAX
argument_list|(
name|m
operator|->
name|m_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Fix the threads inherited priority and recalculate its 	 * active priority. 	 */
name|pthread
operator|->
name|inherited_priority
operator|=
name|inherited_prio
expr_stmt|;
name|active_prio
operator|=
name|MAX
argument_list|(
name|inherited_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_prio
operator|!=
name|pthread
operator|->
name|active_priority
condition|)
block|{
comment|/* Lock the thread's scheduling queue: */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pthread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This thread is not in a run queue.  Just set 			 * its active priority. 			 */
name|pthread
operator|->
name|active_priority
operator|=
name|active_prio
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This thread is in a run queue.  Remove it from 			 * the queue before changing its priority: 			 */
name|THR_RUNQ_REMOVE
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
comment|/* 			 * POSIX states that if the priority is being 			 * lowered, the thread must be inserted at the 			 * head of the queue for its priority if it owns 			 * any priority protection or inheritence mutexes. 			 */
if|if
condition|(
operator|(
name|active_prio
operator|<
name|pthread
operator|->
name|active_priority
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|priority_mutex_count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Set the new active priority. */
name|pthread
operator|->
name|active_priority
operator|=
name|active_prio
expr_stmt|;
name|THR_RUNQ_INSERT_HEAD
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the new active priority. */
name|pthread
operator|->
name|active_priority
operator|=
name|active_prio
expr_stmt|;
name|THR_RUNQ_INSERT_TAIL
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
block|}
block|}
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_mutex_unlock_private
parameter_list|(
name|pthread_t
name|pthread
parameter_list|)
block|{
name|struct
name|pthread_mutex
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_next
decl_stmt|;
for|for
control|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m_next
control|)
block|{
name|m_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_PRIVATE
operator|)
operator|!=
literal|0
condition|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called by the current thread when it wants to back out of a  * mutex_lock in order to run a signal handler.  */
end_comment

begin_function
specifier|static
name|void
name|mutex_lock_backout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
operator|(
expr|struct
name|pthread
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|pthread_mutex
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|->
name|sflags
operator|&
name|THR_FLAGS_IN_SYNCQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Any other thread may clear the "in sync queue flag", 		 * but only the current thread can clear the pointer 		 * to the mutex.  So if the flag is set, we can 		 * guarantee that the pointer to the mutex is valid. 		 * The only problem may be if the mutex is destroyed 		 * out from under us, but that should be considered 		 * an application bug. 		 */
name|m
operator|=
name|curthread
operator|->
name|data
operator|.
name|mutex
expr_stmt|;
comment|/* Lock the mutex structure: */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Check to make sure this thread doesn't already own 		 * the mutex.  Since mutexes are unlocked with direct 		 * handoffs, it is possible the previous owner gave it 		 * to us after we checked the sync queue flag and before 		 * we locked the mutex structure. 		 */
if|if
condition|(
name|m
operator|->
name|m_owner
operator|==
name|curthread
condition|)
block|{
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
name|mutex_unlock_common
argument_list|(
operator|&
name|m
argument_list|,
comment|/* add_reference */
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Remove ourselves from the mutex queue and 			 * clear the pointer to the mutex.  We may no 			 * longer be in the mutex queue, but the removal 			 * function will DTRT. 			 */
name|mutex_queue_remove
argument_list|(
name|m
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|m
operator|->
name|m_lock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No need to call this again. */
name|curthread
operator|->
name|sigbackout
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dequeue a waiting thread from the head of a mutex queue in descending  * priority order.  *  * In order to properly dequeue a thread from the mutex queue and  * make it runnable without the possibility of errant wakeups, it  * is necessary to lock the thread's scheduling queue while also  * holding the mutex lock.  */
end_comment

begin_function
specifier|static
name|struct
name|kse_mailbox
modifier|*
name|mutex_handoff
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread_mutex
modifier|*
name|mutex
parameter_list|)
block|{
name|struct
name|kse_mailbox
modifier|*
name|kmbx
init|=
name|NULL
decl_stmt|;
name|struct
name|pthread
modifier|*
name|pthread
decl_stmt|;
comment|/* Keep dequeueing until we find a valid thread: */
name|mutex
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
name|pthread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|pthread
operator|!=
name|NULL
condition|)
block|{
comment|/* Take the thread's scheduling lock: */
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
comment|/* Remove the thread from the mutex queue: */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|sflags
operator|&=
operator|~
name|THR_FLAGS_IN_SYNCQ
expr_stmt|;
comment|/* 		 * Only exit the loop if the thread hasn't been 		 * cancelled. 		 */
switch|switch
condition|(
name|mutex
operator|->
name|m_protocol
condition|)
block|{
case|case
name|PTHREAD_PRIO_NONE
case|:
comment|/* 			 * Assign the new owner and add the mutex to the 			 * thread's list of owned mutexes. 			 */
name|mutex
operator|->
name|m_owner
operator|=
name|pthread
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|,
name|mutex
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTHREAD_PRIO_INHERIT
case|:
comment|/* 			 * Assign the new owner and add the mutex to the 			 * thread's list of owned mutexes. 			 */
name|mutex
operator|->
name|m_owner
operator|=
name|pthread
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|,
name|mutex
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
comment|/* Track number of priority mutexes owned: */
name|pthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 			 * Set the priority of the mutex.  Since our waiting 			 * threads are in descending priority order, the 			 * priority of the mutex becomes the active priority 			 * of the thread we just dequeued. 			 */
name|mutex
operator|->
name|m_prio
operator|=
name|pthread
operator|->
name|active_priority
expr_stmt|;
comment|/* Save the owning threads inherited priority: */
name|mutex
operator|->
name|m_saved_prio
operator|=
name|pthread
operator|->
name|inherited_priority
expr_stmt|;
comment|/* 			 * The owning threads inherited priority now becomes 			 * his active priority (the priority of the mutex). 			 */
name|pthread
operator|->
name|inherited_priority
operator|=
name|mutex
operator|->
name|m_prio
expr_stmt|;
break|break;
case|case
name|PTHREAD_PRIO_PROTECT
case|:
if|if
condition|(
name|pthread
operator|->
name|active_priority
operator|>
name|mutex
operator|->
name|m_prio
condition|)
block|{
comment|/* 				 * Either the mutex ceiling priority has 				 * been lowered and/or this threads priority 			 	 * has been raised subsequent to the thread 				 * being queued on the waiting list. 				 */
name|pthread
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Assign the new owner and add the mutex 				 * to the thread's list of owned mutexes. 				 */
name|mutex
operator|->
name|m_owner
operator|=
name|pthread
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|,
name|mutex
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
comment|/* Track number of priority mutexes owned: */
name|pthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 				 * Save the owning threads inherited 				 * priority: 				 */
name|mutex
operator|->
name|m_saved_prio
operator|=
name|pthread
operator|->
name|inherited_priority
expr_stmt|;
comment|/* 				 * The owning thread inherits the ceiling 				 * priority of the mutex and executes at 				 * that priority: 				 */
name|pthread
operator|->
name|inherited_priority
operator|=
name|mutex
operator|->
name|m_prio
expr_stmt|;
name|pthread
operator|->
name|active_priority
operator|=
name|mutex
operator|->
name|m_prio
expr_stmt|;
block|}
break|break;
block|}
comment|/* Make the thread runnable and unlock the scheduling queue: */
name|kmbx
operator|=
name|_thr_setrunnable_unlocked
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
comment|/* Add a preemption point. */
if|if
condition|(
operator|(
name|curthread
operator|->
name|kseg
operator|==
name|pthread
operator|->
name|kseg
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|active_priority
operator|>
name|curthread
operator|->
name|active_priority
operator|)
condition|)
name|curthread
operator|->
name|critical_yield
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mutex
operator|->
name|m_owner
operator|==
name|pthread
condition|)
block|{
comment|/* We're done; a valid owner was found. */
if|if
condition|(
name|mutex
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_PRIVATE
condition|)
name|THR_CRITICAL_ENTER
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
break|break;
block|}
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
comment|/* Get the next thread from the waiting queue: */
name|pthread
operator|=
name|TAILQ_NEXT
argument_list|(
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pthread
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|mutex
operator|->
name|m_protocol
operator|==
name|PTHREAD_PRIO_INHERIT
operator|)
condition|)
comment|/* This mutex has no priority: */
name|mutex
operator|->
name|m_prio
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|kmbx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dequeue a waiting thread from the head of a mutex queue in descending  * priority order.  */
end_comment

begin_function
specifier|static
specifier|inline
name|pthread_t
name|mutex_queue_deq
parameter_list|(
name|struct
name|pthread_mutex
modifier|*
name|mutex
parameter_list|)
block|{
name|pthread_t
name|pthread
decl_stmt|;
while|while
condition|(
operator|(
name|pthread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|sflags
operator|&=
operator|~
name|THR_FLAGS_IN_SYNCQ
expr_stmt|;
comment|/* 		 * Only exit the loop if the thread hasn't been 		 * cancelled. 		 */
if|if
condition|(
name|pthread
operator|->
name|interrupted
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|pthread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a waiting thread from a mutex queue in descending priority order.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mutex_queue_remove
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|,
name|pthread_t
name|pthread
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pthread
operator|->
name|sflags
operator|&
name|THR_FLAGS_IN_SYNCQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|sflags
operator|&=
operator|~
name|THR_FLAGS_IN_SYNCQ
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enqueue a waiting thread to a queue in descending priority order.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mutex_queue_enq
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|,
name|pthread_t
name|pthread
parameter_list|)
block|{
name|pthread_t
name|tid
init|=
name|TAILQ_LAST
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|mutex_head
argument_list|)
decl_stmt|;
name|THR_ASSERT_NOT_IN_SYNCQ
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
comment|/* 	 * For the common case of all threads having equal priority, 	 * we perform a quick check against the priority of the thread 	 * at the tail of the queue. 	 */
if|if
condition|(
operator|(
name|tid
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pthread
operator|->
name|active_priority
operator|<=
name|tid
operator|->
name|active_priority
operator|)
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
else|else
block|{
name|tid
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|pthread
operator|->
name|active_priority
operator|<=
name|tid
operator|->
name|active_priority
condition|)
name|tid
operator|=
name|TAILQ_NEXT
argument_list|(
name|tid
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tid
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
block|}
name|pthread
operator|->
name|sflags
operator||=
name|THR_FLAGS_IN_SYNCQ
expr_stmt|;
block|}
end_function

end_unit

