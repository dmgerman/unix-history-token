begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2003 Daniel M. Eischen<deischen@freebsd.org>  * Copyright (C) 2002 Jonathon Mini<mini@freebsd.org>  * Copyright (c) 1995-1998 John Birrell<jb@cimlogic.com.au>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by John Birrell.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kse.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ucontext.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"atomic_ops.h"
end_include

begin_include
include|#
directive|include
file|"thr_private.h"
end_include

begin_include
include|#
directive|include
file|"pthread_md.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_comment
comment|/*#define DEBUG_THREAD_KERN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_THREAD_KERN
end_ifdef

begin_define
define|#
directive|define
name|DBG_MSG
value|stdout_debug
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG_MSG
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define a high water mark for the maximum number of threads that  * will be cached.  Once this level is reached, any extra threads  * will be free()'d.  *  * XXX - It doesn't make sense to worry about the maximum number of  *       KSEs that we can cache because the system will limit us to  *       something *much* less than the maximum number of threads  *       that we can have.  Disregarding KSEs in their own group,  *       the maximum number of KSEs is the number of processors in  *       the system.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CACHED_THREADS
value|100
end_define

begin_define
define|#
directive|define
name|KSE_STACKSIZE
value|16384
end_define

begin_define
define|#
directive|define
name|KSE_SET_MBOX
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|(kse)->k_mbx.km_curthread =&(thrd)->tmbx
end_define

begin_define
define|#
directive|define
name|KSE_SET_EXITED
parameter_list|(
name|kse
parameter_list|)
value|(kse)->k_flags |= KF_EXITED
end_define

begin_comment
comment|/*  * Macros for manipulating the run queues.  The priority queue  * routines use the thread's pqe link and also handle the setting  * and clearing of the thread's THR_FLAGS_IN_RUNQ flag.  */
end_comment

begin_define
define|#
directive|define
name|KSE_RUNQ_INSERT_HEAD
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|_pq_insert_head(&(kse)->k_schedq->sq_runq, thrd)
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_INSERT_TAIL
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|_pq_insert_tail(&(kse)->k_schedq->sq_runq, thrd)
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_REMOVE
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|_pq_remove(&(kse)->k_schedq->sq_runq, thrd)
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_FIRST
parameter_list|(
name|kse
parameter_list|)
value|_pq_first(&(kse)->k_schedq->sq_runq)
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_THREADS
parameter_list|(
name|kse
parameter_list|)
value|((kse)->k_schedq->sq_runq.pq_threads)
end_define

begin_comment
comment|/*  * We've got to keep track of everything that is allocated, not only  * to have a speedy free list, but also so they can be deallocated  * after a fork().  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse
argument_list|)
name|active_kseq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse
argument_list|)
name|free_kseq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_group
argument_list|)
name|free_kse_groupq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_group
argument_list|)
name|active_kse_groupq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_group
argument_list|)
name|gc_ksegq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|lock
name|kse_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also used for kseg queue */
end_comment

begin_decl_stmt
specifier|static
name|int
name|free_kse_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_kseg_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|free_threadq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|lock
name|thread_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_thread_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|active_kse_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|active_kseg_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|kse_check_completed
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_check_waitq
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_check_signals
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_fini
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_reinit
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_sched_multi
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_YET
end_ifdef

begin_function_decl
specifier|static
name|void
name|kse_sched_single
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|kse_switchout_thread
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_wait
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|td_wait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_free_unlocked
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_free_unlocked
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_init
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_reinit
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_waitq_insert
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_wakeup_multi
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_wakeup_one
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_cleanup
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_resume_wrapper
parameter_list|(
name|int
name|unused_1
parameter_list|,
name|siginfo_t
modifier|*
name|unused_2
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_resume_check
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|,
name|struct
name|pthread_sigframe
modifier|*
name|psf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|thr_timedout
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|struct
name|timespec
modifier|*
name|curtime
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is called after a fork().  * No locks need to be taken here since we are guaranteed to be  * single threaded.  */
end_comment

begin_function
name|void
name|_kse_single_thread
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|kse
decl_stmt|,
modifier|*
name|kse_next
decl_stmt|;
name|struct
name|kse_group
modifier|*
name|kseg
decl_stmt|,
modifier|*
name|kseg_next
decl_stmt|;
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|,
modifier|*
name|thread_next
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Disable upcalls and clear the threaded flag. 	 * XXX - I don't think we need to disable upcalls after a fork(). 	 *       but it doesn't hurt. 	 */
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|__isthreaded
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Enter a loop to remove and free all threads other than 	 * the running thread from the active thread list: 	 */
for|for
control|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_thread_list
argument_list|)
init|;
name|thread
operator|!=
name|NULL
condition|;
name|thread
operator|=
name|thread_next
control|)
block|{
comment|/* 		 * Advance to the next thread before the destroying 		 * the current thread. 		*/
name|thread_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
comment|/* 		 * Remove this thread from the list (the current 		 * thread will be removed but re-added by libpthread 		 * initialization. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|_thread_list
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
comment|/* Make sure this isn't the running thread: */
if|if
condition|(
name|thread
operator|!=
name|curthread
condition|)
block|{
name|_thr_stack_free
argument_list|(
operator|&
name|thread
operator|->
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|specific
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|thread
operator|->
name|specific
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_THR_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|_lock_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|)
expr_stmt|;
comment|/* initialize mutex queue */
name|curthread
operator|->
name|joiner
operator|=
name|NULL
expr_stmt|;
comment|/* no joining threads yet */
name|sigemptyset
argument_list|(
operator|&
name|curthread
operator|->
name|sigpend
argument_list|)
expr_stmt|;
comment|/* clear pending signals */
if|if
condition|(
name|curthread
operator|->
name|specific
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|curthread
operator|->
name|specific
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|specific
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|specific_data_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Free the free KSEs: */
while|while
condition|(
operator|(
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kseq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|_ksd_destroy
argument_list|(
operator|&
name|kse
operator|->
name|k_ksd
argument_list|)
expr_stmt|;
if|if
condition|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
name|free_kse_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the active KSEs: */
for|for
control|(
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|active_kseq
argument_list|)
init|;
name|kse
operator|!=
name|NULL
condition|;
name|kse
operator|=
name|kse_next
control|)
block|{
name|kse_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_KSE_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_destroy
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|kse
operator|->
name|k_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
name|active_kse_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the free KSEGs: */
while|while
condition|(
operator|(
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kse_groupq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|kseg
operator|->
name|kg_lock
argument_list|)
expr_stmt|;
name|_pq_free
argument_list|(
operator|&
name|kseg
operator|->
name|kg_schedq
operator|.
name|sq_runq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
name|free_kseg_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the active KSEGs: */
for|for
control|(
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|active_kse_groupq
argument_list|)
init|;
name|kseg
operator|!=
name|NULL
condition|;
name|kseg
operator|=
name|kseg_next
control|)
block|{
name|kseg_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|kseg
operator|->
name|kg_lock
argument_list|)
expr_stmt|;
name|_pq_free
argument_list|(
operator|&
name|kseg
operator|->
name|kg_schedq
operator|.
name|sq_runq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
name|active_kseg_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the free threads. */
while|while
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_threadq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|specific
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|thread
operator|->
name|specific
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_THR_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|_lock_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
name|free_thread_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the to-be-gc'd threads. */
while|while
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_thread_gc_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|_thread_gc_list
argument_list|,
name|thread
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_THR_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|_lock_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|gc_ksegq
argument_list|)
expr_stmt|;
name|_gc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inited
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Destroy these locks; they'll be recreated to assure they 		 * are in the unlocked state. 		 */
name|_lock_destroy
argument_list|(
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|inited
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * After a fork(), the leftover thread goes back to being 	 * scope process. 	 */
name|curthread
operator|->
name|attr
operator|.
name|flags
operator|&=
operator|~
name|PTHREAD_SCOPE_SYSTEM
expr_stmt|;
name|curthread
operator|->
name|attr
operator|.
name|flags
operator||=
name|PTHREAD_SCOPE_PROCESS
expr_stmt|;
comment|/* 	 * After a fork, we are still operating on the thread's original 	 * stack.  Don't clear the THR_FLAGS_USER from the thread's 	 * attribute flags. 	 */
comment|/* Initialize the threads library. */
name|curthread
operator|->
name|kse
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|kseg
operator|=
name|NULL
expr_stmt|;
name|_kse_initial
operator|=
name|NULL
expr_stmt|;
name|_libpthread_init
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is used to initialize housekeeping and to initialize the  * KSD for the KSE.  */
end_comment

begin_function
name|void
name|_kse_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inited
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|active_kseq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|active_kse_groupq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|free_kseq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|free_kse_groupq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|free_threadq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|gc_ksegq
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|kse_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Unable to initialize free KSE queue lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|thread_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Unable to initialize free thread queue lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|_thread_list_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Unable to initialize thread list lock"
argument_list|)
expr_stmt|;
name|active_kse_count
operator|=
literal|0
expr_stmt|;
name|active_kseg_count
operator|=
literal|0
expr_stmt|;
name|_gc_count
operator|=
literal|0
expr_stmt|;
name|inited
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|_kse_isthreaded
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|__isthreaded
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called when the first thread (other than the initial  * thread) is created.  */
end_comment

begin_function
name|int
name|_kse_setthreaded
parameter_list|(
name|int
name|threaded
parameter_list|)
block|{
if|if
condition|(
operator|(
name|threaded
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|__isthreaded
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Locking functions in libc are required when there are 		 * threads other than the initial thread. 		 */
name|__isthreaded
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Tell the kernel to create a KSE for the initial thread 		 * and enable upcalls in it. 		 */
name|_kse_initial
operator|->
name|k_flags
operator||=
name|KF_STARTED
expr_stmt|;
if|if
condition|(
name|kse_create
argument_list|(
operator|&
name|_kse_initial
operator|->
name|k_mbx
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_kse_initial
operator|->
name|k_flags
operator|&=
operator|~
name|KF_STARTED
expr_stmt|;
name|__isthreaded
operator|=
literal|0
expr_stmt|;
comment|/* may abort() */
name|DBG_MSG
argument_list|(
literal|"kse_create failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|KSE_SET_MBOX
argument_list|(
name|_kse_initial
argument_list|,
name|_thr_initial
argument_list|)
expr_stmt|;
name|_thr_setmaxconcurrency
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock wait and wakeup handlers for KSE locks.  These are only used by  * KSEs, and should never be used by threads.  KSE locks include the  * KSE group lock (used for locking the scheduling queue) and the  * kse_lock defined above.  *  * When a KSE lock attempt blocks, the entire KSE blocks allowing another  * KSE to run.  For the most part, it doesn't make much sense to try and  * schedule another thread because you need to lock the scheduling queue  * in order to do that.  And since the KSE lock is used to lock the scheduling  * queue, you would just end up blocking again.  */
end_comment

begin_function
name|void
name|_kse_lock_wait
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
init|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|_LCK_GET_PRIVATE
argument_list|(
name|lu
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|saved_flags
decl_stmt|;
if|if
condition|(
name|curkse
operator|->
name|k_mbx
operator|.
name|km_curthread
operator|!=
name|NULL
condition|)
name|PANIC
argument_list|(
literal|"kse_lock_wait does not disable upcall.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Enter a loop to wait until we get the lock. 	 */
name|ts
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|1000000
expr_stmt|;
comment|/* 1 sec */
name|KSE_SET_WAIT
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
while|while
condition|(
name|_LCK_BUSY
argument_list|(
name|lu
argument_list|)
condition|)
block|{
comment|/* 		 * Yield the kse and wait to be notified when the lock 		 * is granted. 		 */
name|saved_flags
operator|=
name|curkse
operator|->
name|k_mbx
operator|.
name|km_flags
expr_stmt|;
name|curkse
operator|->
name|k_mbx
operator|.
name|km_flags
operator||=
name|KMF_NOUPCALL
operator||
name|KMF_NOCOMPLETED
expr_stmt|;
name|kse_release
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|curkse
operator|->
name|k_mbx
operator|.
name|km_flags
operator|=
name|saved_flags
expr_stmt|;
comment|/* 		 * Make sure that the wait flag is set again in case 		 * we wokeup without the lock being granted. 		 */
name|KSE_SET_WAIT
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
block|}
name|KSE_CLEAR_WAIT
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_kse_lock_wakeup
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|struct
name|kse
modifier|*
name|kse
decl_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|kse
operator|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|_LCK_GET_PRIVATE
argument_list|(
name|lu
argument_list|)
expr_stmt|;
if|if
condition|(
name|kse
operator|==
name|curkse
condition|)
name|PANIC
argument_list|(
literal|"KSE trying to wake itself up in lock"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|KSE_WAITING
argument_list|(
name|kse
argument_list|)
condition|)
block|{
comment|/* 		 * Notify the owning kse that it has the lock. 		 */
name|KSE_WAKEUP
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Thread wait and wakeup handlers for thread locks.  These are only used  * by threads, never by KSEs.  Thread locks include the per-thread lock  * (defined in its structure), and condition variable and mutex locks.  */
end_comment

begin_function
name|void
name|_thr_lock_wait
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
operator|(
expr|struct
name|pthread
operator|*
operator|)
name|lu
operator|->
name|lu_private
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 	 * Spin for a bit. 	 * 	 * XXX - We probably want to make this a bit smarter.  It 	 *       doesn't make sense to spin unless there is more 	 *       than 1 CPU.  A thread that is holding one of these 	 *       locks is prevented from being swapped out for another 	 *       thread within the same scheduling entity. 	 */
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|_LCK_BUSY
argument_list|(
name|lu
argument_list|)
operator|&&
name|count
operator|<
literal|300
condition|)
name|count
operator|++
expr_stmt|;
while|while
condition|(
name|_LCK_BUSY
argument_list|(
name|lu
argument_list|)
condition|)
block|{
name|THR_LOCK_SWITCH
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|_LCK_BUSY
argument_list|(
name|lu
argument_list|)
condition|)
block|{
comment|/* Wait for the lock: */
name|atomic_store_rel_int
argument_list|(
operator|&
name|curthread
operator|->
name|need_wakeup
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_LOCKWAIT
argument_list|)
expr_stmt|;
name|_thr_sched_switch
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
name|THR_UNLOCK_SWITCH
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_thr_lock_wakeup
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|;
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|int
name|unlock
decl_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
name|thread
operator|=
operator|(
expr|struct
name|pthread
operator|*
operator|)
name|_LCK_GET_PRIVATE
argument_list|(
name|lu
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|kseg
operator|==
name|thread
operator|->
name|kseg
condition|)
block|{
comment|/* Not already locked */
if|if
condition|(
name|curthread
operator|->
name|lock_switch
operator|==
literal|0
condition|)
block|{
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|1
expr_stmt|;
block|}
name|_thr_setrunnable_unlocked
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|thread
operator|->
name|need_wakeup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlock
condition|)
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|kse_critical_t
name|_kse_critical_enter
parameter_list|(
name|void
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|crit
operator|=
name|_ksd_readandclear_tmbx
expr_stmt|;
return|return
operator|(
name|crit
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_kse_critical_leave
parameter_list|(
name|kse_critical_t
name|crit
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|_ksd_set_tmbx
argument_list|(
name|crit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crit
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|=
name|_get_curthread
argument_list|()
operator|)
operator|!=
name|NULL
operator|)
condition|)
name|THR_YIELD_CHECK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_kse_in_critical
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_ksd_get_tmbx
argument_list|()
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_thr_critical_enter
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|thread
operator|->
name|critical_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_critical_leave
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|thread
operator|->
name|critical_count
operator|--
expr_stmt|;
name|THR_YIELD_CHECK
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX - We may need to take the scheduling lock before calling  *       this, or perhaps take the lock within here before  *       doing anything else.  */
end_comment

begin_function
name|void
name|_thr_sched_switch
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|pthread_sigframe
name|psf
decl_stmt|;
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
specifier|volatile
name|int
name|once
init|=
literal|0
decl_stmt|;
comment|/* We're in the scheduler, 5 by 5: */
name|THR_ASSERT
argument_list|(
name|curthread
operator|->
name|lock_switch
argument_list|,
literal|"lock_switch"
argument_list|)
expr_stmt|;
name|THR_ASSERT
argument_list|(
name|_kse_in_critical
argument_list|()
argument_list|,
literal|"not in critical region"
argument_list|)
expr_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|curthread
operator|->
name|need_switchout
operator|=
literal|1
expr_stmt|;
comment|/* The thread yielded on its own. */
name|curthread
operator|->
name|critical_yield
operator|=
literal|0
expr_stmt|;
comment|/* No need to yield anymore. */
name|curthread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Restart the time slice. */
comment|/* 	 * The signal frame is allocated off the stack because 	 * a thread can be interrupted by other signals while 	 * it is running down pending signals. 	 */
name|sigemptyset
argument_list|(
operator|&
name|psf
operator|.
name|psf_sigset
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|curframe
operator|=
operator|&
name|psf
expr_stmt|;
name|_thread_enter_uts
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
argument_list|,
operator|&
name|curkse
operator|->
name|k_mbx
argument_list|)
expr_stmt|;
comment|/* 	 * This thread is being resumed; check for cancellations. 	 */
if|if
condition|(
operator|(
name|once
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
operator|)
condition|)
block|{
name|once
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|critical_count
operator|++
expr_stmt|;
name|THR_UNLOCK_SWITCH
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|critical_count
operator|--
expr_stmt|;
name|thr_resume_check
argument_list|(
name|curthread
argument_list|,
operator|&
name|curthread
operator|->
name|tmbx
operator|.
name|tm_context
argument_list|,
operator|&
name|psf
argument_list|)
expr_stmt|;
name|THR_LOCK_SWITCH
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the scheduler for a KSE which runs a scope system thread.  * The multi-thread KSE scheduler should also work for a single threaded  * KSE, but we use a separate scheduler so that it can be fine-tuned  * to be more efficient (and perhaps not need a separate stack for  * the KSE, allowing it to use the thread's stack).  *  * XXX - This probably needs some work.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_YET
end_ifdef

begin_function
specifier|static
name|void
name|kse_sched_single
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|curkse
operator|->
name|k_curthread
decl_stmt|;
name|struct
name|pthread
modifier|*
name|td_wait
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|level
decl_stmt|;
if|if
condition|(
name|curthread
operator|->
name|active
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
comment|/* Check to see if the thread has timed out. */
name|KSE_GET_TOD
argument_list|(
name|curkse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr_timedout
argument_list|(
name|curthread
argument_list|,
operator|&
name|ts
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|curthread
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
block|}
block|}
block|}
comment|/* This thread no longer needs to yield the CPU: */
name|curthread
operator|->
name|critical_yield
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Lock the scheduling queue. 	 * 	 * There is no scheduling queue for single threaded KSEs, 	 * but we need a lock for protection regardless. 	 */
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* 	 * This has to do the job of kse_switchout_thread(), only 	 * for a single threaded KSE/KSEG. 	 */
switch|switch
condition|(
name|curthread
operator|->
name|state
condition|)
block|{
case|case
name|PS_DEAD
case|:
comment|/* Unlock the scheduling queue and exit the KSE. */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|kse_fini
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* does not return */
break|break;
case|case
name|PS_COND_WAIT
case|:
case|case
name|PS_SLEEP_WAIT
case|:
comment|/* Only insert threads that can timeout: */
if|if
condition|(
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Insert into the waiting queue: */
name|KSE_WAITQ_INSERT
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PS_LOCKWAIT
case|:
name|level
operator|=
name|curthread
operator|->
name|locklevel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|_LCK_BUSY
argument_list|(
operator|&
name|curthread
operator|->
name|lockusers
index|[
name|level
index|]
argument_list|)
condition|)
name|KSE_WAITQ_INSERT
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
else|else
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_JOIN
case|:
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_RUNNING
case|:
case|case
name|PS_SIGSUSPEND
case|:
case|case
name|PS_SIGWAIT
case|:
case|case
name|PS_SUSPENDED
case|:
case|case
name|PS_DEADLOCK
case|:
default|default:
comment|/* 		 * These states don't timeout and don't need 		 * to be in the waiting queue. 		 */
break|break;
block|}
while|while
condition|(
name|curthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
name|curthread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|td_wait
operator|=
name|KSE_WAITQ_FIRST
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|kse_wait
argument_list|(
name|curkse
argument_list|,
name|td_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_wait
operator|!=
name|NULL
condition|)
block|{
name|KSE_GET_TOD
argument_list|(
name|curkse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr_timedout
argument_list|(
name|curthread
argument_list|,
operator|&
name|ts
argument_list|)
condition|)
block|{
comment|/* Indicate the thread timedout: */
name|td_wait
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* Make the thread runnable. */
name|THR_SET_STATE
argument_list|(
name|td_wait
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|KSE_WAITQ_REMOVE
argument_list|(
name|curkse
argument_list|,
name|td_wait
argument_list|)
expr_stmt|;
block|}
block|}
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|kse_check_signals
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the frame reference. */
name|curthread
operator|->
name|curframe
operator|=
name|NULL
expr_stmt|;
comment|/* Unlock the scheduling queue. */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* 	 * Continue the thread at its current frame: 	 */
name|DBG_MSG
argument_list|(
literal|"Continuing bound thread %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|_thread_switch
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
argument_list|,
operator|&
name|curkse
operator|->
name|k_mbx
operator|.
name|km_curthread
argument_list|)
expr_stmt|;
name|PANIC
argument_list|(
literal|"Thread has returned from _thread_switch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dump_queues
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|;
name|DBG_MSG
argument_list|(
literal|"Threads in waiting queue:\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&curkse->k_kseg->kg_schedq.sq_waitq
argument_list|,
argument|pqe
argument_list|)
block|{
name|DBG_MSG
argument_list|(
literal|"  thread %p, state %d, blocked %d\n"
argument_list|,
name|thread
argument_list|,
name|thread
operator|->
name|state
argument_list|,
name|thread
operator|->
name|blocked
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the scheduler for a KSE which runs multiple threads.  */
end_comment

begin_function
specifier|static
name|void
name|kse_sched_multi
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|,
modifier|*
name|td_wait
decl_stmt|;
name|struct
name|pthread_sigframe
modifier|*
name|curframe
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|THR_ASSERT
argument_list|(
name|curkse
operator|->
name|k_mbx
operator|.
name|km_curthread
operator|==
name|NULL
argument_list|,
literal|"Mailbox not null in kse_sched_multi"
argument_list|)
expr_stmt|;
comment|/* Check for first time initialization: */
if|if
condition|(
operator|(
name|curkse
operator|->
name|k_flags
operator|&
name|KF_INITIALIZED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Setup this KSEs specific data. */
name|_ksd_setprivate
argument_list|(
operator|&
name|curkse
operator|->
name|k_ksd
argument_list|)
expr_stmt|;
name|_set_curkse
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* Set this before grabbing the context. */
name|curkse
operator|->
name|k_flags
operator||=
name|KF_INITIALIZED
expr_stmt|;
block|}
comment|/* This may have returned from a kse_release(). */
if|if
condition|(
name|KSE_WAITING
argument_list|(
name|curkse
argument_list|)
condition|)
block|{
name|DBG_MSG
argument_list|(
literal|"Entered upcall when KSE is waiting."
argument_list|)
expr_stmt|;
name|KSE_CLEAR_WAIT
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
block|}
name|curthread
operator|=
name|curkse
operator|->
name|k_curthread
expr_stmt|;
if|if
condition|(
name|curthread
operator|==
name|NULL
operator|||
name|curthread
operator|->
name|lock_switch
operator|==
literal|0
condition|)
block|{
comment|/* 		 * curthread was preempted by upcall, it is not a volunteer 		 * context switch. Lock the scheduling lock. 		 */
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the current thread was completed in another KSE, then 	 * it will be in the run queue.  Don't mark it as being blocked. 	 */
if|if
condition|(
operator|(
name|curthread
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|curthread
operator|->
name|need_switchout
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Assume the current thread is blocked; when the 		 * completed threads are checked and if the current 		 * thread is among the completed, the blocked flag 		 * will be cleared. 		 */
name|curthread
operator|->
name|blocked
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for any unblocked threads in the kernel. */
name|kse_check_completed
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* 	 * Check for threads that have timed-out. 	 */
name|kse_check_waitq
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* 	 * Switchout the current thread, if necessary, as the last step 	 * so that it is inserted into the run queue (if it's runnable) 	 * _after_ any other threads that were added to it above. 	 */
if|if
condition|(
name|curthread
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* Nothing to do here. */
elseif|else
if|if
condition|(
operator|(
name|curthread
operator|->
name|need_switchout
operator|==
literal|0
operator|)
operator|&&
operator|(
name|curthread
operator|->
name|blocked
operator|==
literal|0
operator|)
operator|&&
operator|(
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Resume the thread and tell it to yield when 		 * it leaves the critical region. 		 */
name|curthread
operator|->
name|critical_yield
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|!=
literal|0
condition|)
name|KSE_RUNQ_REMOVE
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curkse
operator|->
name|k_curthread
operator|=
name|curthread
expr_stmt|;
name|curthread
operator|->
name|kse
operator|=
name|curkse
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Continuing thread %p in critical region\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|kse_wakeup_multi
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|lock_switch
condition|)
block|{
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_thread_switch
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_thread_switch
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
argument_list|,
operator|&
name|curkse
operator|->
name|k_mbx
operator|.
name|km_curthread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Can't resume thread in critical region\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|==
literal|0
condition|)
name|kse_switchout_thread
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curkse
operator|->
name|k_curthread
operator|=
name|NULL
expr_stmt|;
name|kse_wakeup_multi
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* This has to be done without the scheduling lock held. */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|kse_check_signals
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|dump_queues
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* Check if there are no threads ready to run: */
while|while
condition|(
operator|(
operator|(
name|curthread
operator|=
name|KSE_RUNQ_FIRST
argument_list|(
name|curkse
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|curkse
operator|->
name|k_kseg
operator|->
name|kg_threadcount
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Wait for a thread to become active or until there are 		 * no more threads. 		 */
name|td_wait
operator|=
name|KSE_WAITQ_FIRST
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|kse_wait
argument_list|(
name|curkse
argument_list|,
name|td_wait
argument_list|)
expr_stmt|;
name|kse_check_completed
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|kse_check_waitq
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|kse_check_signals
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
comment|/* Check for no more threads: */
if|if
condition|(
name|curkse
operator|->
name|k_kseg
operator|->
name|kg_threadcount
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Normally this shouldn't return, but it will if there 		 * are other KSEs running that create new threads that 		 * are assigned to this KSE[G].  For instance, if a scope 		 * system thread were to create a scope process thread 		 * and this kse[g] is the initial kse[g], then that newly 		 * created thread would be assigned to us (the initial 		 * kse[g]). 		 */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|kse_fini
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|curthread
operator|=
name|KSE_RUNQ_FIRST
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
block|}
name|THR_ASSERT
argument_list|(
name|curthread
operator|!=
name|NULL
argument_list|,
literal|"Return from kse_wait/fini without thread."
argument_list|)
expr_stmt|;
name|THR_ASSERT
argument_list|(
name|curthread
operator|->
name|state
operator|!=
name|PS_DEAD
argument_list|,
literal|"Trying to resume dead thread!"
argument_list|)
expr_stmt|;
name|KSE_RUNQ_REMOVE
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* 	 * Make the selected thread the current thread. 	 */
name|curkse
operator|->
name|k_curthread
operator|=
name|curthread
expr_stmt|;
comment|/* 	 * Make sure the current thread's kse points to this kse. 	 */
name|curthread
operator|->
name|kse
operator|=
name|curkse
expr_stmt|;
comment|/* 	 * Reset accounting. 	 */
name|curthread
operator|->
name|tmbx
operator|.
name|tm_uticks
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|tmbx
operator|.
name|tm_sticks
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Reset the time slice if this thread is running for the first 	 * time or running again after using its full time slice allocation. 	 */
if|if
condition|(
name|curthread
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
name|curthread
operator|->
name|slice_usec
operator|=
literal|0
expr_stmt|;
comment|/* Mark the thread active. */
name|curthread
operator|->
name|active
operator|=
literal|1
expr_stmt|;
comment|/* Remove the frame reference. */
name|curframe
operator|=
name|curthread
operator|->
name|curframe
expr_stmt|;
name|curthread
operator|->
name|curframe
operator|=
name|NULL
expr_stmt|;
name|kse_wakeup_multi
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* Unlock the scheduling queue: */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* 	 * The thread's current signal frame will only be NULL if it 	 * is being resumed after being blocked in the kernel.  In 	 * this case, and if the thread needs to run down pending 	 * signals or needs a cancellation check, we need to add a 	 * signal frame to the thread's context. 	 */
ifdef|#
directive|ifdef
name|NOT_YET
if|if
condition|(
operator|(
name|curframe
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|->
name|check_pending
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|THR_AT_CANCEL_POINT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_CANCEL_ASYNCHRONOUS
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
name|signalcontext
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
operator|.
name|tm_context
argument_list|,
literal|0
argument_list|,
operator|(
name|__sighandler_t
operator|*
operator|)
name|thr_resume_wrapper
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|curframe
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|curthread
operator|->
name|check_pending
operator|!=
literal|0
operator|)
condition|)
name|signalcontext
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
operator|.
name|tm_context
argument_list|,
literal|0
argument_list|,
operator|(
name|__sighandler_t
operator|*
operator|)
name|thr_resume_wrapper
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GS_HACK
comment|/* XXX - The kernel sometimes forgets to restore %gs properly. */
name|_ksd_setprivate
argument_list|(
operator|&
name|curkse
operator|->
name|k_ksd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Continue the thread at its current frame: 	 */
if|if
condition|(
name|curthread
operator|->
name|lock_switch
condition|)
block|{
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_thread_switch
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|_thread_switch
argument_list|(
operator|&
name|curthread
operator|->
name|tmbx
argument_list|,
operator|&
name|curkse
operator|->
name|k_mbx
operator|.
name|km_curthread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Thread has returned from _thread_switch"
argument_list|)
expr_stmt|;
comment|/* This point should not be reached. */
name|PANIC
argument_list|(
literal|"Thread has returned from _thread_switch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kse_check_signals
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
block|{
name|sigset_t
name|sigset
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Deliver posted signals. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_SIG_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|atomic_swap_int
argument_list|(
operator|&
name|curkse
operator|->
name|k_mbx
operator|.
name|km_sigscaught
operator|.
name|__bits
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|sigset
operator|.
name|__bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SIGNOTEMPTY
argument_list|(
name|sigset
argument_list|)
condition|)
block|{
comment|/* 		 * Dispatch each signal. 		 * 		 * XXX - There is no siginfo for any of these. 		 *       I think there should be, especially for 		 *       signals from other processes (si_pid, si_uid). 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sigismember
argument_list|(
operator|&
name|sigset
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DBG_MSG
argument_list|(
literal|"Dispatching signal %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|_thr_sig_dispatch
argument_list|(
name|curkse
argument_list|,
name|i
argument_list|,
name|NULL
comment|/* no siginfo */
argument_list|)
expr_stmt|;
block|}
block|}
name|sigemptyset
argument_list|(
operator|&
name|sigset
argument_list|)
expr_stmt|;
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thr_resume_wrapper
parameter_list|(
name|int
name|unused_1
parameter_list|,
name|siginfo_t
modifier|*
name|unused_2
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|thr_resume_check
argument_list|(
name|curthread
argument_list|,
name|ucp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thr_resume_check
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|,
name|struct
name|pthread_sigframe
modifier|*
name|psf
parameter_list|)
block|{
comment|/* Check signals before cancellations. */
while|while
condition|(
name|curthread
operator|->
name|check_pending
operator|!=
literal|0
condition|)
block|{
comment|/* Clear the pending flag. */
name|curthread
operator|->
name|check_pending
operator|=
literal|0
expr_stmt|;
comment|/* 		 * It's perfectly valid, though not portable, for 		 * signal handlers to munge their interrupted context 		 * and expect to return to it.  Ensure we use the 		 * correct context when running down signals. 		 */
name|_thr_sig_rundown
argument_list|(
name|curthread
argument_list|,
name|ucp
argument_list|,
name|psf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOT_YET
if|if
condition|(
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|THR_AT_CANCEL_POINT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_CANCEL_ASYNCHRONOUS
operator|)
operator|!=
literal|0
operator|)
condition|)
name|pthread_testcancel
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Clean up a thread.  This must be called with the thread's KSE  * scheduling lock held.  The thread must be a thread from the  * KSE's group.  */
end_comment

begin_function
specifier|static
name|void
name|thr_cleanup
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|joiner
decl_stmt|;
if|if
condition|(
operator|(
name|joiner
operator|=
name|thread
operator|->
name|joiner
operator|)
operator|!=
name|NULL
condition|)
block|{
name|thread
operator|->
name|joiner
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|joiner
operator|->
name|state
operator|==
name|PS_JOIN
operator|)
operator|&&
operator|(
name|joiner
operator|->
name|join_status
operator|.
name|thread
operator|==
name|thread
operator|)
condition|)
block|{
name|joiner
operator|->
name|join_status
operator|.
name|thread
operator|=
name|NULL
expr_stmt|;
comment|/* Set the return status for the joining thread: */
name|joiner
operator|->
name|join_status
operator|.
name|ret
operator|=
name|thread
operator|->
name|ret
expr_stmt|;
comment|/* Make the thread runnable. */
if|if
condition|(
name|joiner
operator|->
name|kseg
operator|==
name|curkse
operator|->
name|k_kseg
condition|)
name|_thr_setrunnable_unlocked
argument_list|(
name|joiner
argument_list|)
expr_stmt|;
else|else
block|{
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|joiner
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|_thr_setrunnable_unlocked
argument_list|(
name|joiner
argument_list|)
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|joiner
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
block|}
name|thread
operator|->
name|attr
operator|.
name|flags
operator||=
name|PTHREAD_DETACHED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|thread
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_PROCESS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Remove the thread from the KSEG's list of threads. 	 	 */
name|KSEG_THRQ_REMOVE
argument_list|(
name|thread
operator|->
name|kseg
argument_list|,
name|thread
argument_list|)
expr_stmt|;
comment|/* 		 * Migrate the thread to the main KSE so that this 		 * KSE and KSEG can be cleaned when their last thread 		 * exits. 		 */
name|thread
operator|->
name|kseg
operator|=
name|_kse_initial
operator|->
name|k_kseg
expr_stmt|;
name|thread
operator|->
name|kse
operator|=
name|_kse_initial
expr_stmt|;
block|}
name|thread
operator|->
name|flags
operator||=
name|THR_FLAGS_GC_SAFE
expr_stmt|;
comment|/* 	 * We can't hold the thread list lock while holding the 	 * scheduler lock. 	 */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Adding thread %p to GC list\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|THR_GCLIST_ADD
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td_next
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|worklist
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|worklist
argument_list|)
expr_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
comment|/* Check the threads waiting for GC. */
for|for
control|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_thread_gc_list
argument_list|)
init|;
name|td
operator|!=
name|NULL
condition|;
name|td
operator|=
name|td_next
control|)
block|{
name|td_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|flags
operator|&
name|THR_FLAGS_GC_SAFE
operator|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NOT_YET
elseif|else
if|if
condition|(
operator|(
operator|(
name|td
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_PROCESS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|td
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_flags
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * The thread and KSE are operating on the same 			 * stack.  Wait for the KSE to exit before freeing 			 * the thread's stack as well as everything else. 			 */
continue|continue;
block|}
endif|#
directive|endif
comment|/* 		 * Remove the thread from the GC list.  If the thread 		 * isn't yet detached, it will get added back to the 		 * GC list at a later time. 		 */
name|THR_GCLIST_REMOVE
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Freeing thread %p stack\n"
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 		 * We can free the thread stack since it's no longer 		 * in use. 		 */
name|_thr_stack_free
argument_list|(
operator|&
name|td
operator|->
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|td
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_DETACHED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|td
operator|->
name|refcount
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * The thread has detached and is no longer 			 * referenced.  It is safe to remove all 			 * remnants of the thread. 			 */
name|THR_LIST_REMOVE
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|worklist
argument_list|,
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
block|}
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|worklist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|worklist
argument_list|,
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_PROCESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kse_free_unlocked
argument_list|(
name|td
operator|->
name|kse
argument_list|)
expr_stmt|;
name|kseg_free_unlocked
argument_list|(
name|td
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
name|DBG_MSG
argument_list|(
literal|"Freeing thread %p\n"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|_thr_free
argument_list|(
name|curthread
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Only new threads that are running or suspended may be scheduled.  */
end_comment

begin_function
name|int
name|_thr_schedule_add
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|newthread
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|int
name|need_start
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * If this is the first time creating a thread, make sure 	 * the mailbox is set for the current thread. 	 */
if|if
condition|(
operator|(
name|newthread
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NOT_YET
comment|/* We use the thread's stack as the KSE's stack. */
name|new_thread
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_sp
operator|=
name|new_thread
operator|->
name|attr
operator|.
name|stackaddr_attr
expr_stmt|;
name|new_thread
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_size
operator|=
name|new_thread
operator|->
name|attr
operator|.
name|stacksize_attr
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * No need to lock the scheduling queue since the 		 * KSE/KSEG pair have not yet been started. 		 */
name|KSEG_THRQ_ADD
argument_list|(
name|newthread
operator|->
name|kseg
argument_list|,
name|newthread
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newthread
operator|->
name|kseg
operator|->
name|kg_kseq
argument_list|,
name|newthread
operator|->
name|kse
argument_list|,
name|k_kgqe
argument_list|)
expr_stmt|;
name|newthread
operator|->
name|kseg
operator|->
name|kg_ksecount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|newthread
operator|->
name|state
operator|==
name|PS_RUNNING
condition|)
name|THR_RUNQ_INSERT_TAIL
argument_list|(
name|newthread
argument_list|)
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_curthread
operator|=
name|NULL
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_flags
operator|=
literal|0
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_multi
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_quantum
operator|=
literal|0
expr_stmt|;
comment|/* 		 * This thread needs a new KSE and KSEG. 		 */
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|_ksd_setprivate
argument_list|(
operator|&
name|newthread
operator|->
name|kse
operator|->
name|k_ksd
argument_list|)
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_flags
operator||=
name|KF_INITIALIZED
expr_stmt|;
name|ret
operator|=
name|kse_create
argument_list|(
operator|&
name|newthread
operator|->
name|kse
operator|->
name|k_mbx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
name|_ksd_setprivate
argument_list|(
operator|&
name|curkse
operator|->
name|k_ksd
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Lock the KSE and add the new thread to its list of 		 * assigned threads.  If the new thread is runnable, also 		 * add it to the KSE's run queue. 		 */
name|need_start
operator|=
literal|0
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|newthread
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|KSEG_THRQ_ADD
argument_list|(
name|newthread
operator|->
name|kseg
argument_list|,
name|newthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|newthread
operator|->
name|state
operator|==
name|PS_RUNNING
condition|)
name|THR_RUNQ_INSERT_TAIL
argument_list|(
name|newthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newthread
operator|->
name|kse
operator|->
name|k_flags
operator|&
name|KF_STARTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This KSE hasn't been started yet.  Start it 			 * outside of holding the lock. 			 */
name|newthread
operator|->
name|kse
operator|->
name|k_flags
operator||=
name|KF_STARTED
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_multi
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_mbx
operator|.
name|km_flags
operator|=
literal|0
expr_stmt|;
name|need_start
operator|=
literal|1
expr_stmt|;
block|}
name|KSE_SCHED_UNLOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|newthread
operator|->
name|kseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_start
operator|!=
literal|0
condition|)
name|kse_create
argument_list|(
operator|&
name|newthread
operator|->
name|kse
operator|->
name|k_mbx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|newthread
operator|->
name|state
operator|==
name|PS_RUNNING
operator|)
operator|&&
name|KSE_IS_IDLE
argument_list|(
name|newthread
operator|->
name|kse
argument_list|)
condition|)
block|{
comment|/* 			 * The thread is being scheduled on another KSEG. 			 */
name|kse_wakeup_one
argument_list|(
name|newthread
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kse_waitq_insert
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|td
decl_stmt|;
if|if
condition|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thread
operator|->
name|kse
operator|->
name|k_schedq
operator|->
name|sq_waitq
argument_list|,
name|thread
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
else|else
block|{
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|thread
operator|->
name|kse
operator|->
name|k_schedq
operator|->
name|sq_waitq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|td
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|<
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|<=
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|)
operator|)
operator|)
condition|)
name|td
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thread
operator|->
name|kse
operator|->
name|k_schedq
operator|->
name|sq_waitq
argument_list|,
name|thread
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td
argument_list|,
name|thread
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
block|}
name|thread
operator|->
name|flags
operator||=
name|THR_FLAGS_IN_WAITQ
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This must be called with the scheduling lock held.  */
end_comment

begin_function
specifier|static
name|void
name|kse_check_completed
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|;
name|struct
name|kse_thr_mailbox
modifier|*
name|completed
decl_stmt|;
if|if
condition|(
operator|(
name|completed
operator|=
name|kse
operator|->
name|k_mbx
operator|.
name|km_completed
operator|)
operator|!=
name|NULL
condition|)
block|{
name|kse
operator|->
name|k_mbx
operator|.
name|km_completed
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|completed
operator|!=
name|NULL
condition|)
block|{
name|thread
operator|=
name|completed
operator|->
name|tm_udata
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Found completed thread %p, name %s\n"
argument_list|,
name|thread
argument_list|,
operator|(
name|thread
operator|->
name|name
operator|==
name|NULL
operator|)
condition|?
literal|"none"
else|:
name|thread
operator|->
name|name
argument_list|)
expr_stmt|;
name|thread
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|thread
operator|!=
name|kse
operator|->
name|k_curthread
condition|)
name|KSE_RUNQ_INSERT_TAIL
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|completed
operator|=
name|completed
operator|->
name|tm_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This must be called with the scheduling lock held.  */
end_comment

begin_function
specifier|static
name|void
name|kse_check_waitq
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|pthread
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|KSE_GET_TOD
argument_list|(
name|kse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* 	 * Wake up threads that have timedout.  This has to be 	 * done before adding the current thread to the run queue 	 * so that a CPU intensive thread doesn't get preference 	 * over waiting threads. 	 */
while|while
condition|(
operator|(
operator|(
name|pthread
operator|=
name|KSE_WAITQ_FIRST
argument_list|(
name|kse
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|thr_timedout
argument_list|(
name|pthread
argument_list|,
operator|&
name|ts
argument_list|)
condition|)
block|{
comment|/* Remove the thread from the wait queue: */
name|KSE_WAITQ_REMOVE
argument_list|(
name|kse
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Found timedout thread %p in waitq\n"
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
comment|/* Indicate the thread timedout: */
name|pthread
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* Add the thread to the priority queue: */
name|THR_SET_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|KSE_RUNQ_INSERT_TAIL
argument_list|(
name|kse
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|thr_timedout
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|struct
name|timespec
modifier|*
name|curtime
parameter_list|)
block|{
if|if
condition|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|>
name|curtime
operator|->
name|tv_sec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
name|curtime
operator|->
name|tv_sec
operator|)
operator|&&
operator|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|>
name|curtime
operator|->
name|tv_nsec
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This must be called with the scheduling lock held.  *  * Each thread has a time slice, a wakeup time (used when it wants  * to wait for a specified amount of time), a run state, and an  * active flag.  *  * When a thread gets run by the scheduler, the active flag is  * set to non-zero (1).  When a thread performs an explicit yield  * or schedules a state change, it enters the scheduler and the  * active flag is cleared.  When the active flag is still seen  * set in the scheduler, that means that the thread is blocked in  * the kernel (because it is cleared before entering the scheduler  * in all other instances).  *  * The wakeup time is only set for those states that can timeout.  * It is set to (-1, -1) for all other instances.  *  * The thread's run state, aside from being useful when debugging,  * is used to place the thread in an appropriate queue.  There  * are 2 basic queues:  *  *   o run queue - queue ordered by priority for all threads  *                 that are runnable  *   o waiting queue - queue sorted by wakeup time for all threads  *                     that are not otherwise runnable (not blocked  *                     in kernel, not waiting for locks)  *  * The thread's time slice is used for round-robin scheduling  * (the default scheduling policy).  While a SCHED_RR thread  * is runnable it's time slice accumulates.  When it reaches  * the time slice interval, it gets reset and added to the end  * of the queue of threads at its priority.  When a thread no  * longer becomes runnable (blocks in kernel, waits, etc), its  * time slice is reset.  *  * The job of kse_switchout_thread() is to handle all of the above.  */
end_comment

begin_function
specifier|static
name|void
name|kse_switchout_thread
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|int
name|level
decl_stmt|;
comment|/* 	 * Place the currently running thread into the 	 * appropriate queue(s). 	 */
name|DBG_MSG
argument_list|(
literal|"Switching out thread %p, state %d\n"
argument_list|,
name|thread
argument_list|,
name|thread
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|blocked
operator|!=
literal|0
condition|)
block|{
name|thread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
comment|/* This thread must have blocked in the kernel. */
comment|/* thread->slice_usec = -1;*/
comment|/* restart timeslice */
comment|/* 		 * XXX - Check for pending signals for this thread to 		 *       see if we need to interrupt it in the kernel. 		 */
comment|/* if (thread->check_pending != 0) */
if|if
condition|(
operator|(
name|thread
operator|->
name|slice_usec
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|thread
operator|->
name|attr
operator|.
name|sched_policy
operator|!=
name|SCHED_FIFO
operator|)
condition|)
name|thread
operator|->
name|slice_usec
operator|+=
operator|(
name|thread
operator|->
name|tmbx
operator|.
name|tm_uticks
operator|+
name|thread
operator|->
name|tmbx
operator|.
name|tm_sticks
operator|)
operator|*
name|_clock_res_usec
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|thread
operator|->
name|state
condition|)
block|{
case|case
name|PS_DEAD
case|:
comment|/* 			 * The scheduler is operating on a different 			 * stack.  It is safe to do garbage collecting 			 * here. 			 */
name|thread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
name|thr_cleanup
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
name|PS_RUNNING
case|:
comment|/* Nothing to do here. */
break|break;
case|case
name|PS_COND_WAIT
case|:
case|case
name|PS_SLEEP_WAIT
case|:
comment|/* Insert into the waiting queue: */
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_LOCKWAIT
case|:
comment|/* 			 * This state doesn't timeout. 			 */
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
name|level
operator|=
name|thread
operator|->
name|locklevel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|_LCK_BUSY
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|level
index|]
argument_list|)
condition|)
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
else|else
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_JOIN
case|:
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_SIGSUSPEND
case|:
case|case
name|PS_SIGWAIT
case|:
case|case
name|PS_SUSPENDED
case|:
case|case
name|PS_DEADLOCK
case|:
default|default:
comment|/* 			 * These states don't timeout. 			 */
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Insert into the waiting queue: */
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|thread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
comment|/* Restart the time slice: */
name|thread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|thread
operator|->
name|need_switchout
operator|!=
literal|0
condition|)
comment|/* 				 * The thread yielded on its own; 				 * restart the timeslice. 				 */
name|thread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|thread
operator|->
name|slice_usec
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|thread
operator|->
name|attr
operator|.
name|sched_policy
operator|!=
name|SCHED_FIFO
operator|)
condition|)
block|{
name|thread
operator|->
name|slice_usec
operator|+=
operator|(
name|thread
operator|->
name|tmbx
operator|.
name|tm_uticks
operator|+
name|thread
operator|->
name|tmbx
operator|.
name|tm_sticks
operator|)
operator|*
name|_clock_res_usec
expr_stmt|;
comment|/* Check for time quantum exceeded: */
if|if
condition|(
name|thread
operator|->
name|slice_usec
operator|>
name|TIMESLICE_USEC
condition|)
name|thread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|thread
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * The thread exceeded its time quantum or 				 * it yielded the CPU; place it at the tail 				 * of the queue for its priority. 				 */
name|KSE_RUNQ_INSERT_TAIL
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The thread hasn't exceeded its interval 				 * Place it at the head of the queue for its 				 * priority. 				 */
name|KSE_RUNQ_INSERT_HEAD
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|thread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function waits for the smallest timeout value of any waiting  * thread, or until it receives a message from another KSE.  *  * This must be called with the scheduling lock held.  */
end_comment

begin_function
specifier|static
name|void
name|kse_wait
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|td_wait
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts_sleep
decl_stmt|;
name|int
name|saved_flags
decl_stmt|;
name|KSE_GET_TOD
argument_list|(
name|kse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td_wait
operator|==
name|NULL
operator|)
operator|||
operator|(
name|td_wait
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* Limit sleep to no more than 1 minute. */
name|ts_sleep
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|ts_sleep
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|TIMESPEC_SUB
argument_list|(
operator|&
name|ts_sleep
argument_list|,
operator|&
name|td_wait
operator|->
name|wakeup_time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts_sleep
operator|.
name|tv_sec
operator|>
literal|60
condition|)
block|{
name|ts_sleep
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|ts_sleep
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Don't sleep for negative times. */
if|if
condition|(
operator|(
name|ts_sleep
operator|.
name|tv_sec
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ts_sleep
operator|.
name|tv_nsec
operator|>=
literal|0
operator|)
condition|)
block|{
name|KSE_SET_IDLE
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|++
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|saved_flags
operator|=
name|kse
operator|->
name|k_mbx
operator|.
name|km_flags
expr_stmt|;
name|kse
operator|->
name|k_mbx
operator|.
name|km_flags
operator||=
name|KMF_NOUPCALL
expr_stmt|;
name|kse_release
argument_list|(
operator|&
name|ts_sleep
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_mbx
operator|.
name|km_flags
operator|=
name|saved_flags
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|kse
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Avoid calling this kse_exit() so as not to confuse it with the  * system call of the same name.  */
end_comment

begin_function
specifier|static
name|void
name|kse_fini
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|kse_group
modifier|*
name|free_kseg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|kse
operator|->
name|k_kseg
operator|->
name|kg_flags
operator|&
name|KGF_SINGLE_THREAD
operator|)
operator|!=
literal|0
condition|)
name|kse_exit
argument_list|()
expr_stmt|;
comment|/* 	 * Check to see if this is one of the main kses. 	 */
elseif|else
if|if
condition|(
name|kse
operator|->
name|k_kseg
operator|!=
name|_kse_initial
operator|->
name|k_kseg
condition|)
block|{
comment|/* Remove this KSE from the KSEG's list of KSEs. */
name|KSE_SCHED_LOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kse
operator|->
name|k_kseg
operator|->
name|kg_kseq
argument_list|,
name|kse
argument_list|,
name|k_kgqe
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_ksecount
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|kse
operator|->
name|k_kseg
operator|->
name|kg_kseq
argument_list|)
condition|)
name|free_kseg
operator|=
name|kse
operator|->
name|k_kseg
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* 		 * Add this KSE to the list of free KSEs along with 		 * the KSEG if is now orphaned. 		 */
ifdef|#
directive|ifdef
name|NOT_YET
name|KSE_LOCK_ACQUIRE
argument_list|(
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_kseg
operator|!=
name|NULL
condition|)
name|kseg_free_unlocked
argument_list|(
name|free_kseg
argument_list|)
expr_stmt|;
name|kse_free_unlocked
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kse_exit
argument_list|()
expr_stmt|;
comment|/* Never returns. */
block|}
else|else
block|{
comment|/* 		 * Wait for the last KSE/thread to exit, or for more 		 * threads to be created (it is possible for additional 		 * scope process threads to be created after the main 		 * thread exits). 		 */
name|ts
operator|.
name|tv_sec
operator|=
literal|120
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|KSE_SET_WAIT
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|active_kse_count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|kse
operator|->
name|k_kseg
operator|->
name|kg_threadcount
operator|==
literal|0
operator|)
condition|)
block|{
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|kse_release
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* The above never returns. */
block|}
else|else
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* There are no more threads; exit this process: */
if|if
condition|(
name|kse
operator|->
name|k_kseg
operator|->
name|kg_threadcount
operator|==
literal|0
condition|)
block|{
comment|/* kse_exit(); */
name|__isthreaded
operator|=
literal|0
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|_thr_sig_add
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|int
name|sig
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|thread
operator|->
name|kseg
argument_list|)
expr_stmt|;
comment|/* 	 * A threads assigned KSE can't change out from under us 	 * when we hold the scheduler lock. 	 */
if|if
condition|(
name|THR_IS_ACTIVE
argument_list|(
name|thread
argument_list|)
condition|)
block|{
comment|/* Thread is active.  Can't install the signal for it. */
comment|/* Make a note in the thread that it has a signal. */
name|sigaddset
argument_list|(
operator|&
name|thread
operator|->
name|sigpend
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|thread
operator|->
name|check_pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Make a note in the thread that it has a signal. */
name|sigaddset
argument_list|(
operator|&
name|thread
operator|->
name|sigpend
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|thread
operator|->
name|check_pending
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|blocked
operator|!=
literal|0
condition|)
block|{
comment|/* Tell the kernel to interrupt the thread. */
name|kse_thr_interrupt
argument_list|(
operator|&
name|thread
operator|->
name|tmbx
argument_list|)
expr_stmt|;
block|}
block|}
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|thread
operator|->
name|kseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_set_timeout
parameter_list|(
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* Reset the timeout flag for the running thread: */
name|curthread
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Check if the thread is to wait forever: */
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Set the wakeup time to something that can be recognised as 		 * different to an actual time of day: 		 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Check if no waiting is required: */
elseif|else
if|if
condition|(
operator|(
name|timeout
operator|->
name|tv_sec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|timeout
operator|->
name|tv_nsec
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Set the wake up time to 'immediately': */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculate the time for the current thread to wakeup: */
name|KSE_GET_TOD
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|TIMESPEC_ADD
argument_list|(
operator|&
name|curthread
operator|->
name|wakeup_time
argument_list|,
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_thr_panic_exit
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"(%s:%d) %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|__sys_write
argument_list|(
literal|2
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_setrunnable
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|thread
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|_thr_setrunnable_unlocked
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|thread
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_setrunnable_unlocked
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
if|if
condition|(
operator|(
name|thread
operator|->
name|kseg
operator|->
name|kg_flags
operator|&
name|KGF_SINGLE_THREAD
operator|)
operator|!=
literal|0
condition|)
comment|/* No silly queues for these threads. */
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|thread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_WAITQ
operator|)
operator|!=
literal|0
condition|)
name|KSE_WAITQ_REMOVE
argument_list|(
name|thread
operator|->
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|->
name|blocked
operator|==
literal|0
operator|)
operator|&&
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|==
literal|0
condition|)
name|THR_RUNQ_INSERT_TAIL
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
comment|/*          * XXX - Threads are not yet assigned to specific KSEs; they are          *       assigned to the KSEG.  So the fact that a thread's KSE is          *       waiting doesn't necessarily mean that it will be the KSE          *       that runs the thread after the lock is granted.  But we          *       don't know if the other KSEs within the same KSEG are          *       also in a waiting state or not so we err on the side of          *       caution and wakeup the thread's last known KSE.  We          *       ensure that the threads KSE doesn't change while it's          *       scheduling lock is held so it is safe to reference it          *       (the KSE).  If the KSE wakes up and doesn't find any more          *       work it will again go back to waiting so no harm is done.          */
name|kse_wakeup_one
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kse_wakeup_one
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|thread
operator|->
name|kse
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|thread
operator|->
name|kse
argument_list|)
expr_stmt|;
name|thread
operator|->
name|kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|KSE_WAKEUP
argument_list|(
name|thread
operator|->
name|kse
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ke
argument_list|,
argument|&thread->kseg->kg_kseq
argument_list|,
argument|k_kgqe
argument_list|)
block|{
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|KSE_WAKEUP
argument_list|(
name|ke
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kse_wakeup_multi
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|KSE_RUNQ_THREADS
argument_list|(
name|curkse
argument_list|)
operator|)
operator|&&
name|curkse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ke
argument_list|,
argument|&curkse->k_kseg->kg_kseq
argument_list|,
argument|k_kgqe
argument_list|)
block|{
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|KSE_WAKEUP
argument_list|(
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|tmp
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|struct
name|pthread
modifier|*
name|_get_curthread
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_ksd_curthread
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This assumes the caller has disabled upcalls. */
end_comment

begin_function
name|struct
name|kse
modifier|*
name|_get_curkse
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_ksd_curkse
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_set_curkse
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|_ksd_setprivate
argument_list|(
operator|&
name|kse
operator|->
name|k_ksd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new KSEG.  *  * We allow the current thread to be NULL in the case that this  * is the first time a KSEG is being created (library initialization).  * In this case, we don't need to (and can't) take any locks.  */
end_comment

begin_function
name|struct
name|kse_group
modifier|*
name|_kseg_alloc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|kse_group
modifier|*
name|kseg
init|=
name|NULL
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|free_kseg_count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Use the kse lock for the kseg queue. */
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kse_groupq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|free_kseg_count
operator|--
expr_stmt|;
name|active_kseg_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
if|if
condition|(
name|kseg
condition|)
name|kseg_reinit
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If requested, attempt to allocate a new KSE group only if the 	 * KSE allocation was successful and a KSE group wasn't found in 	 * the free list. 	 */
if|if
condition|(
operator|(
name|kseg
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|kseg
operator|=
operator|(
expr|struct
name|kse_group
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kseg
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|_pq_alloc
argument_list|(
operator|&
name|kseg
operator|->
name|kg_schedq
operator|.
name|sq_runq
argument_list|,
name|THR_MIN_PRIORITY
argument_list|,
name|THR_LAST_PRIORITY
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
name|kseg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|kseg_init
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
comment|/* Add the KSEG to the list of active KSEGs. */
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|active_kseg_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|active_kseg_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|kseg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This must be called with the kse lock held and when there are  * no more threads that reference it.  */
end_comment

begin_function
specifier|static
name|void
name|kseg_free_unlocked
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|free_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|free_kseg_count
operator|++
expr_stmt|;
name|active_kseg_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_kseg_free
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curkse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kseg_free_unlocked
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curkse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new KSE.  *  * We allow the current thread to be NULL in the case that this  * is the first time a KSE is being created (library initialization).  * In this case, we don't need to (and can't) take any locks.  */
end_comment

begin_function
name|struct
name|kse
modifier|*
name|_kse_alloc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|kse
init|=
name|NULL
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|int
name|need_ksd
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|free_kse_count
operator|>
literal|0
operator|)
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
comment|/* Search for a finished KSE. */
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kseq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_YET
define|#
directive|define
name|KEMBX_DONE
value|0x04
while|while
condition|(
operator|(
name|kse
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|kse
operator|->
name|k_mbx
operator|.
name|km_flags
operator|&
name|KEMBX_DONE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|kse
operator|=
name|TAILQ_NEXT
argument_list|(
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|KEMBX_DONE
endif|#
directive|endif
if|if
condition|(
name|kse
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|free_kse_count
operator|--
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|active_kse_count
operator|++
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
if|if
condition|(
name|kse
operator|!=
name|NULL
condition|)
name|kse_reinit
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kse
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|kse
operator|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kse
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|bzero
argument_list|(
name|kse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kse
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the lockusers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_KSE_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_init
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|kse
argument_list|)
expr_stmt|;
name|_LCK_SET_PRIVATE2
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* _lock_init(kse->k_lock, ...) */
comment|/* We had to malloc a kse; mark it as needing a new ID.*/
name|need_ksd
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Create the KSE context. 		 * 		 * XXX - For now this is done here in the allocation. 		 *       In the future, we may want to have it done 		 *       outside the allocation so that scope system 		 *       threads (one thread per KSE) are not required 		 *       to have a stack for an unneeded kse upcall. 		 */
name|kse
operator|->
name|k_mbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_multi
expr_stmt|;
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_sp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|KSE_STACKSIZE
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_size
operator|=
name|KSE_STACKSIZE
expr_stmt|;
name|kse
operator|->
name|k_mbx
operator|.
name|km_udata
operator|=
operator|(
name|void
operator|*
operator|)
name|kse
expr_stmt|;
name|kse
operator|->
name|k_mbx
operator|.
name|km_quantum
operator|=
literal|20000
expr_stmt|;
comment|/* 		 * We need to keep a copy of the stack in case it 		 * doesn't get used; a KSE running a scope system 		 * thread will use that thread's stack. 		 */
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|=
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_sp
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_size
operator|=
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_size
expr_stmt|;
if|if
condition|(
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_sp
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_KSE_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_destroy
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* _lock_destroy(&kse->k_lock); */
name|free
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|kse
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|kse
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|need_ksd
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* This KSE needs initialization. */
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize KSD inside of the lock. */
if|if
condition|(
name|_ksd_create
argument_list|(
operator|&
name|kse
operator|->
name|k_ksd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|kse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kse
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|kse
operator|->
name|k_mbx
operator|.
name|km_stack
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_KSE_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_destroy
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|kse
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|kse
operator|->
name|k_flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|active_kse_count
operator|++
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|kse
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kse_reinit
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|kse
operator|->
name|k_mbx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kse_mailbox
argument_list|)
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_curthread
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_schedq
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_locklevel
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|kse
operator|->
name|k_sigmask
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|kse
operator|->
name|k_sigq
argument_list|,
sizeof|sizeof
argument_list|(
name|kse
operator|->
name|k_sigq
argument_list|)
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_check_sigq
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_flags
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_waiting
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_error
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_cpu
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kse_free_unlocked
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|active_kse_count
operator|--
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|=
name|NULL
expr_stmt|;
name|kse
operator|->
name|k_mbx
operator|.
name|km_quantum
operator|=
literal|20000
expr_stmt|;
name|kse
operator|->
name|k_flags
operator|&=
operator|~
name|KF_INITIALIZED
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|free_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|free_kse_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_kse_free
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
if|if
condition|(
name|curthread
operator|==
name|NULL
condition|)
name|kse_free_unlocked
argument_list|(
name|kse
argument_list|)
expr_stmt|;
else|else
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kse_free_unlocked
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kseg_init
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|kseg_reinit
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
name|_lock_init
argument_list|(
operator|&
name|kseg
operator|->
name|kg_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseg_reinit
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|kseg
operator|->
name|kg_kseq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kseg
operator|->
name|kg_threadq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kseg
operator|->
name|kg_schedq
operator|.
name|sq_waitq
argument_list|)
expr_stmt|;
name|kseg
operator|->
name|kg_threadcount
operator|=
literal|0
expr_stmt|;
name|kseg
operator|->
name|kg_ksecount
operator|=
literal|0
expr_stmt|;
name|kseg
operator|->
name|kg_idle_kses
operator|=
literal|0
expr_stmt|;
name|kseg
operator|->
name|kg_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pthread
modifier|*
name|_thr_alloc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|struct
name|pthread
modifier|*
name|thread
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|GC_NEEDED
argument_list|()
condition|)
name|_thr_gc
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_thread_count
operator|>
literal|0
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_threadq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|free_thread_count
operator|--
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|thread
operator|==
name|NULL
condition|)
name|thread
operator|=
operator|(
expr|struct
name|pthread
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pthread
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|thread
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_thr_free
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBG_MSG
argument_list|(
literal|"Freeing thread %p\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|==
name|NULL
operator|)
operator|||
operator|(
name|free_thread_count
operator|>=
name|MAX_CACHED_THREADS
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_THR_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|_lock_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|free_thread_count
operator|++
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

