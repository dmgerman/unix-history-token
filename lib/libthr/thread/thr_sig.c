begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2005, David Xu<davidxu@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_include
include|#
directive|include
file|"thr_private.h"
end_include

begin_comment
comment|/* #define DEBUG_SIGNAL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SIGNAL
end_ifdef

begin_define
define|#
directive|define
name|DBG_MSG
value|stdout_debug
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG_MSG
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|usigaction
block|{
name|struct
name|sigaction
name|sigact
decl_stmt|;
name|struct
name|urwlock
name|lock
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|usigaction
name|_thr_sigact
index|[
name|_SIG_MAXSIG
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|thr_sighandler
parameter_list|(
name|int
parameter_list|,
name|siginfo_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_signal
parameter_list|(
name|struct
name|sigaction
modifier|*
parameter_list|,
name|int
parameter_list|,
name|siginfo_t
modifier|*
parameter_list|,
name|ucontext_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_deferred_signal
parameter_list|(
name|struct
name|pthread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_suspend
parameter_list|(
name|struct
name|pthread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_cancel
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|___pause
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_raise
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__sigtimedwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_sigtimedwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__sigwaitinfo
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_sigwaitinfo
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|___sigwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|int
modifier|*
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_sigwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|int
modifier|*
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__sigsuspend
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|sigmask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_sigaction
parameter_list|(
name|int
parameter_list|,
specifier|const
name|struct
name|sigaction
modifier|*
parameter_list|,
name|struct
name|sigaction
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_setcontext
parameter_list|(
specifier|const
name|ucontext_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|_swapcontext
parameter_list|(
name|ucontext_t
modifier|*
parameter_list|,
specifier|const
name|ucontext_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|sigset_t
name|_thr_deferset
init|=
block|{
block|{
literal|0xffffffff
operator|&
operator|~
operator|(
name|_SIG_BIT
argument_list|(
name|SIGBUS
argument_list|)
operator||
name|_SIG_BIT
argument_list|(
name|SIGILL
argument_list|)
operator||
name|_SIG_BIT
argument_list|(
name|SIGFPE
argument_list|)
operator||
name|_SIG_BIT
argument_list|(
name|SIGSEGV
argument_list|)
operator||
name|_SIG_BIT
argument_list|(
name|SIGTRAP
argument_list|)
operator||
name|_SIG_BIT
argument_list|(
name|SIGSYS
argument_list|)
operator|)
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|sigset_t
name|_thr_maskset
init|=
block|{
block|{
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_thr_signal_block
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
if|if
condition|(
name|curthread
operator|->
name|sigblock
operator|>
literal|0
condition|)
block|{
name|curthread
operator|->
name|sigblock
operator|++
expr_stmt|;
return|return;
block|}
name|__sys_sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|_thr_maskset
argument_list|,
operator|&
name|curthread
operator|->
name|sigmask
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|sigblock
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_signal_unblock
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
if|if
condition|(
operator|--
name|curthread
operator|->
name|sigblock
operator|==
literal|0
condition|)
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|curthread
operator|->
name|sigmask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_thr_send_sig
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
return|return
name|thr_kill
argument_list|(
name|thread
operator|->
name|tid
argument_list|,
name|sig
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|remove_thr_signals
parameter_list|(
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
operator|*
name|set
argument_list|,
name|SIGCANCEL
argument_list|)
condition|)
name|SIGDELSET
argument_list|(
operator|*
name|set
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|sigset_t
modifier|*
name|thr_remove_thr_signals
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|sigset_t
modifier|*
name|newset
parameter_list|)
block|{
operator|*
name|newset
operator|=
operator|*
name|set
expr_stmt|;
name|remove_thr_signals
argument_list|(
name|newset
argument_list|)
expr_stmt|;
return|return
operator|(
name|newset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sigcancel_handler
parameter_list|(
name|int
name|sig
name|__unused
parameter_list|,
name|siginfo_t
modifier|*
name|info
name|__unused
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
condition|)
return|return;
name|err
operator|=
name|errno
expr_stmt|;
name|check_suspend
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|check_cancel
argument_list|(
name|curthread
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ohandler
function_decl|)
parameter_list|(
name|int
name|sig
parameter_list|,
name|int
name|code
parameter_list|,
name|struct
name|sigcontext
modifier|*
name|scp
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|__sighandler_t
modifier|*
name|catcher
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * The signal handler wrapper is entered with all signal masked.  */
end_comment

begin_function
specifier|static
name|void
name|thr_sighandler
parameter_list|(
name|int
name|sig
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
name|void
modifier|*
name|_ucp
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|ucontext_t
modifier|*
name|ucp
init|=
name|_ucp
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|errno
expr_stmt|;
name|_thr_rwl_rdlock
argument_list|(
operator|&
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|act
operator|=
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sigact
expr_stmt|;
name|_thr_rwl_unlock
argument_list|(
operator|&
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
comment|/* 	 * if a thread is in critical region, for example it holds low level locks, 	 * try to defer the signal processing, however if the signal is synchronous 	 * signal, it means a bad thing has happened, this is a programming error, 	 * resuming fault point can not help anything (normally causes deadloop), 	 * so here we let user code handle it immediately. 	 */
if|if
condition|(
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
operator|&&
name|SIGISMEMBER
argument_list|(
name|_thr_deferset
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|curthread
operator|->
name|deferred_sigact
argument_list|,
operator|&
name|act
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|curthread
operator|->
name|deferred_siginfo
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|siginfo_t
argument_list|)
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|deferred_sigmask
operator|=
name|ucp
operator|->
name|uc_sigmask
expr_stmt|;
comment|/* mask all signals, we will restore it later. */
name|ucp
operator|->
name|uc_sigmask
operator|=
name|_thr_deferset
expr_stmt|;
return|return;
block|}
name|handle_signal
argument_list|(
operator|&
name|act
argument_list|,
name|sig
argument_list|,
name|info
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_signal
parameter_list|(
name|struct
name|sigaction
modifier|*
name|actp
parameter_list|,
name|int
name|sig
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|ucontext_t
name|uc2
decl_stmt|;
name|__siginfohandler_t
modifier|*
name|sigfunc
decl_stmt|;
name|int
name|cancel_point
decl_stmt|;
name|int
name|cancel_async
decl_stmt|;
name|int
name|cancel_enable
decl_stmt|;
name|int
name|in_sigsuspend
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* add previous level mask */
name|SIGSETOR
argument_list|(
name|actp
operator|->
name|sa_mask
argument_list|,
name|ucp
operator|->
name|uc_sigmask
argument_list|)
expr_stmt|;
comment|/* add this signal's mask */
if|if
condition|(
operator|!
operator|(
name|actp
operator|->
name|sa_flags
operator|&
name|SA_NODEFER
operator|)
condition|)
name|SIGADDSET
argument_list|(
name|actp
operator|->
name|sa_mask
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|in_sigsuspend
operator|=
name|curthread
operator|->
name|in_sigsuspend
expr_stmt|;
name|curthread
operator|->
name|in_sigsuspend
operator|=
literal|0
expr_stmt|;
comment|/* 	 * if thread is in deferred cancellation mode, disable cancellation 	 * in signal handler. 	 * if user signal handler calls a cancellation point function, e.g, 	 * it calls write() to write data to file, because write() is a 	 * cancellation point, the thread is immediately cancelled if  	 * cancellation is pending, to avoid this problem while thread is in 	 * deferring mode, cancellation is temporarily disabled. 	 */
name|cancel_point
operator|=
name|curthread
operator|->
name|cancel_point
expr_stmt|;
name|cancel_async
operator|=
name|curthread
operator|->
name|cancel_async
expr_stmt|;
name|cancel_enable
operator|=
name|curthread
operator|->
name|cancel_enable
expr_stmt|;
name|curthread
operator|->
name|cancel_point
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|cancel_async
condition|)
name|curthread
operator|->
name|cancel_enable
operator|=
literal|0
expr_stmt|;
comment|/* restore correct mask before calling user handler */
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|actp
operator|->
name|sa_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigfunc
operator|=
name|actp
operator|->
name|sa_sigaction
expr_stmt|;
comment|/* 	 * We have already reset cancellation point flags, so if user's code 	 * longjmp()s out of its signal handler, wish its jmpbuf was set 	 * outside of a cancellation point, in most cases, this would be 	 * true. however, ther is no way to save cancel_enable in jmpbuf, 	 * so after setjmps() returns once more, the user code may need to 	 * re-set cancel_enable flag by calling pthread_setcancelstate(). 	 */
if|if
condition|(
operator|(
name|actp
operator|->
name|sa_flags
operator|&
name|SA_SIGINFO
operator|)
operator|!=
literal|0
condition|)
operator|(
operator|*
operator|(
name|sigfunc
operator|)
operator|)
operator|(
name|sig
operator|,
name|info
operator|,
name|ucp
operator|)
expr_stmt|;
else|else
block|{
operator|(
call|(
name|ohandler
call|)
argument_list|(
operator|*
name|sigfunc
argument_list|)
operator|)
operator|(
name|sig
operator|,
name|info
operator|->
name|si_code
operator|,
operator|(
expr|struct
name|sigcontext
operator|*
operator|)
name|ucp
operator|,
name|info
operator|->
name|si_addr
operator|,
operator|(
name|__sighandler_t
operator|*
operator|)
name|sigfunc
operator|)
expr_stmt|;
block|}
name|err
operator|=
name|errno
expr_stmt|;
name|curthread
operator|->
name|in_sigsuspend
operator|=
name|in_sigsuspend
expr_stmt|;
name|curthread
operator|->
name|cancel_point
operator|=
name|cancel_point
expr_stmt|;
name|curthread
operator|->
name|cancel_enable
operator|=
name|cancel_enable
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|uc2
argument_list|,
name|ucp
argument_list|,
sizeof|sizeof
argument_list|(
name|uc2
argument_list|)
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|uc2
operator|.
name|uc_sigmask
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
comment|/* reschedule cancellation */
name|check_cancel
argument_list|(
name|curthread
argument_list|,
operator|&
name|uc2
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
name|__sys_sigreturn
argument_list|(
operator|&
name|uc2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_ast
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
if|if
condition|(
operator|!
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|check_deferred_signal
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|check_suspend
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|check_cancel
argument_list|(
name|curthread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* reschedule cancellation */
end_comment

begin_function
specifier|static
name|void
name|check_cancel
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
name|curthread
operator|->
name|cancel_pending
operator|||
operator|!
name|curthread
operator|->
name|cancel_enable
operator|||
name|curthread
operator|->
name|no_cancel
argument_list|)
condition|)
return|return;
comment|/*  	 * Otherwise, we are in defer mode, and we are at 	 * cancel point, tell kernel to not block the current 	 * thread on next cancelable system call. 	 *  	 * There are three cases we should call thr_wake() to 	 * turn on TDP_WAKEUP or send SIGCANCEL in kernel: 	 * 1) we are going to call a cancelable system call, 	 *    non-zero cancel_point means we are already in 	 *    cancelable state, next system call is cancelable. 	 * 2) because _thr_ast() may be called by 	 *    THR_CRITICAL_LEAVE() which is used by rtld rwlock 	 *    and any libthr internal locks, when rtld rwlock 	 *    is used, it is mostly caused my an unresolved PLT. 	 *    those routines may clear the TDP_WAKEUP flag by 	 *    invoking some system calls, in those cases, we 	 *    also should reenable the flag. 	 * 3) thread is in sigsuspend(), and the syscall insists 	 *    on getting a signal before it agrees to return.  	 */
if|if
condition|(
name|curthread
operator|->
name|cancel_point
condition|)
block|{
if|if
condition|(
name|curthread
operator|->
name|in_sigsuspend
operator|&&
name|ucp
condition|)
block|{
name|SIGADDSET
argument_list|(
name|ucp
operator|->
name|uc_sigmask
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|unblock_sigcancel
operator|=
literal|1
expr_stmt|;
name|_thr_send_sig
argument_list|(
name|curthread
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
block|}
else|else
name|thr_wake
argument_list|(
name|curthread
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curthread
operator|->
name|cancel_async
condition|)
block|{
comment|/* 		 * asynchronous cancellation mode, act upon 		 * immediately. 		 */
name|_pthread_exit_mask
argument_list|(
name|PTHREAD_CANCELED
argument_list|,
name|ucp
condition|?
operator|&
name|ucp
operator|->
name|uc_sigmask
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_deferred_signal
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|ucontext_t
modifier|*
name|uc
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|siginfo_t
name|info
decl_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|curthread
operator|->
name|deferred_siginfo
operator|.
name|si_signo
operator|==
literal|0
argument_list|)
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
name|uc
operator|=
name|alloca
argument_list|(
name|__getcontextx_size
argument_list|()
argument_list|)
expr_stmt|;
name|__fillcontextx
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uc
argument_list|)
expr_stmt|;
else|#
directive|else
name|ucontext_t
name|ucv
decl_stmt|;
name|uc
operator|=
operator|&
name|ucv
expr_stmt|;
name|getcontext
argument_list|(
name|uc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curthread
operator|->
name|deferred_siginfo
operator|.
name|si_signo
operator|!=
literal|0
condition|)
block|{
name|act
operator|=
name|curthread
operator|->
name|deferred_sigact
expr_stmt|;
name|uc
operator|->
name|uc_sigmask
operator|=
name|curthread
operator|->
name|deferred_sigmask
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|curthread
operator|->
name|deferred_siginfo
argument_list|,
sizeof|sizeof
argument_list|(
name|siginfo_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove signal */
name|curthread
operator|->
name|deferred_siginfo
operator|.
name|si_signo
operator|=
literal|0
expr_stmt|;
name|handle_signal
argument_list|(
operator|&
name|act
argument_list|,
name|info
operator|.
name|si_signo
argument_list|,
operator|&
name|info
argument_list|,
name|uc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_suspend
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|uint32_t
name|cycle
decl_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|curthread
operator|->
name|flags
operator|&
operator|(
name|THR_FLAGS_NEED_SUSPEND
operator||
name|THR_FLAGS_SUSPENDED
operator|)
operator|)
operator|!=
name|THR_FLAGS_NEED_SUSPEND
argument_list|)
condition|)
return|return;
if|if
condition|(
name|curthread
operator|==
name|_single_thread
condition|)
return|return;
if|if
condition|(
name|curthread
operator|->
name|force_exit
condition|)
return|return;
comment|/*  	 * Blocks SIGCANCEL which other threads must send. 	 */
name|_thr_signal_block
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* 	 * Increase critical_count, here we don't use THR_LOCK/UNLOCK 	 * because we are leaf code, we don't want to recursively call 	 * ourself. 	 */
name|curthread
operator|->
name|critical_count
operator|++
expr_stmt|;
name|THR_UMUTEX_LOCK
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
name|curthread
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
operator|(
name|THR_FLAGS_NEED_SUSPEND
operator||
name|THR_FLAGS_SUSPENDED
operator|)
operator|)
operator|==
name|THR_FLAGS_NEED_SUSPEND
condition|)
block|{
name|curthread
operator|->
name|cycle
operator|++
expr_stmt|;
name|cycle
operator|=
name|curthread
operator|->
name|cycle
expr_stmt|;
comment|/* Wake the thread suspending us. */
name|_thr_umtx_wake
argument_list|(
operator|&
name|curthread
operator|->
name|cycle
argument_list|,
name|INT_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * if we are from pthread_exit, we don't want to 		 * suspend, just go and die. 		 */
if|if
condition|(
name|curthread
operator|->
name|state
operator|==
name|PS_DEAD
condition|)
break|break;
name|curthread
operator|->
name|flags
operator||=
name|THR_FLAGS_SUSPENDED
expr_stmt|;
name|THR_UMUTEX_UNLOCK
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
name|curthread
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
name|_thr_umtx_wait_uint
argument_list|(
operator|&
name|curthread
operator|->
name|cycle
argument_list|,
name|cycle
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|THR_UMUTEX_LOCK
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
name|curthread
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|flags
operator|&=
operator|~
name|THR_FLAGS_SUSPENDED
expr_stmt|;
block|}
name|THR_UMUTEX_UNLOCK
argument_list|(
name|curthread
argument_list|,
operator|&
operator|(
name|curthread
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|critical_count
operator|--
expr_stmt|;
name|_thr_signal_unblock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_signal_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
comment|/* Install SIGCANCEL handler. */
name|SIGFILLSET
argument_list|(
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_SIGINFO
expr_stmt|;
name|act
operator|.
name|sa_sigaction
operator|=
operator|(
name|__siginfohandler_t
operator|*
operator|)
operator|&
name|sigcancel_handler
expr_stmt|;
name|__sys_sigaction
argument_list|(
name|SIGCANCEL
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Unblock SIGCANCEL */
name|SIGEMPTYSET
argument_list|(
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|act
operator|.
name|sa_mask
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
name|__sys_sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|act
operator|.
name|sa_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_sigact_unload
parameter_list|(
name|struct
name|dl_phdr_info
modifier|*
name|phdr_info
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct pthread *curthread = _get_curthread(); 	struct urwlock *rwlp; 	struct sigaction *actp; 	struct sigaction kact; 	void (*handler)(int); 	int sig;   	_thr_signal_block(curthread); 	for (sig = 1; sig<= _SIG_MAXSIG; sig++) { 		actp =&_thr_sigact[sig-1].sigact; retry: 		handler = actp->sa_handler; 		if (handler != SIG_DFL&& handler != SIG_IGN&& 		    __elf_phdr_match_addr(phdr_info, handler)) { 			rwlp =&_thr_sigact[sig-1].lock; 			_thr_rwl_wrlock(rwlp); 			if (handler != actp->sa_handler) { 				_thr_rwl_unlock(rwlp); 				goto retry; 			} 			actp->sa_handler = SIG_DFL; 			actp->sa_flags = SA_SIGINFO; 			SIGEMPTYSET(actp->sa_mask); 			if (__sys_sigaction(sig, NULL,&kact) == 0&& 				kact.sa_handler != SIG_DFL&& 				kact.sa_handler != SIG_IGN) 				__sys_sigaction(sig, actp, NULL); 			_thr_rwl_unlock(rwlp); 		} 	} 	_thr_signal_unblock(curthread);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_thr_signal_prefork
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|_SIG_MAXSIG
condition|;
operator|++
name|i
control|)
name|_thr_rwl_rdlock
argument_list|(
operator|&
name|_thr_sigact
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_signal_postfork
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|_SIG_MAXSIG
condition|;
operator|++
name|i
control|)
name|_thr_rwl_unlock
argument_list|(
operator|&
name|_thr_sigact
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_signal_postfork_child
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|_SIG_MAXSIG
condition|;
operator|++
name|i
control|)
name|bzero
argument_list|(
operator|&
name|_thr_sigact
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|lock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|urwlock
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_signal_deinit
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|___pause
argument_list|,
name|pause
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|___pause
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|oset
decl_stmt|;
if|if
condition|(
name|_sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
name|NULL
argument_list|,
operator|&
name|oset
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|__sigsuspend
argument_list|(
operator|&
name|oset
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_raise
argument_list|,
name|raise
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_raise
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
return|return
name|_thr_send_sig
argument_list|(
name|_get_curthread
argument_list|()
argument_list|,
name|sig
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_sigaction
argument_list|,
name|sigaction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_sigaction
parameter_list|(
name|int
name|sig
parameter_list|,
specifier|const
name|struct
name|sigaction
modifier|*
name|act
parameter_list|,
name|struct
name|sigaction
modifier|*
name|oact
parameter_list|)
block|{
name|struct
name|sigaction
name|newact
decl_stmt|,
name|oldact
decl_stmt|,
name|oldact2
decl_stmt|;
name|sigset_t
name|oldset
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|_SIG_VALID
argument_list|(
name|sig
argument_list|)
operator|||
name|sig
operator|==
name|SIGCANCEL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|act
condition|)
name|newact
operator|=
operator|*
name|act
expr_stmt|;
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|_thr_maskset
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|_thr_rwl_wrlock
argument_list|(
operator|&
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|!=
name|NULL
condition|)
block|{
name|oldact2
operator|=
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sigact
expr_stmt|;
comment|/* 		 * if a new sig handler is SIG_DFL or SIG_IGN, 		 * don't remove old handler from _thr_sigact[], 		 * so deferred signals still can use the handlers, 		 * multiple threads invoking sigaction itself is 		 * a race condition, so it is not a problem. 		 */
if|if
condition|(
name|newact
operator|.
name|sa_handler
operator|!=
name|SIG_DFL
operator|&&
name|newact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
block|{
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sigact
operator|=
name|newact
expr_stmt|;
name|remove_thr_signals
argument_list|(
operator|&
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sigact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|newact
operator|.
name|sa_flags
operator|&=
operator|~
name|SA_NODEFER
expr_stmt|;
name|newact
operator|.
name|sa_flags
operator||=
name|SA_SIGINFO
expr_stmt|;
name|newact
operator|.
name|sa_sigaction
operator|=
name|thr_sighandler
expr_stmt|;
name|newact
operator|.
name|sa_mask
operator|=
name|_thr_maskset
expr_stmt|;
comment|/* mask all signals */
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|__sys_sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|newact
argument_list|,
operator|&
name|oldact
argument_list|)
operator|)
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sigact
operator|=
name|oldact2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|oact
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|__sys_sigaction
argument_list|(
name|sig
argument_list|,
name|NULL
argument_list|,
operator|&
name|oldact
argument_list|)
expr_stmt|;
name|err
operator|=
name|errno
expr_stmt|;
block|}
if|if
condition|(
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_DFL
operator|&&
name|oldact
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
block|{
if|if
condition|(
name|act
operator|!=
name|NULL
condition|)
name|oldact
operator|=
name|oldact2
expr_stmt|;
elseif|else
if|if
condition|(
name|oact
operator|!=
name|NULL
condition|)
name|oldact
operator|=
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sigact
expr_stmt|;
block|}
name|_thr_rwl_unlock
argument_list|(
operator|&
name|_thr_sigact
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oldset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|oact
operator|!=
name|NULL
condition|)
operator|*
name|oact
operator|=
name|oldact
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|err
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_sigprocmask
argument_list|,
name|sigprocmask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_sigprocmask
parameter_list|(
name|int
name|how
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|sigset_t
modifier|*
name|oset
parameter_list|)
block|{
specifier|const
name|sigset_t
modifier|*
name|p
init|=
name|set
decl_stmt|;
name|sigset_t
name|newset
decl_stmt|;
if|if
condition|(
name|how
operator|!=
name|SIG_UNBLOCK
condition|)
block|{
if|if
condition|(
name|set
operator|!=
name|NULL
condition|)
block|{
name|newset
operator|=
operator|*
name|set
expr_stmt|;
name|SIGDELSET
argument_list|(
name|newset
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|newset
expr_stmt|;
block|}
block|}
return|return
operator|(
name|__sys_sigprocmask
argument_list|(
name|how
argument_list|,
name|p
argument_list|,
name|oset
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_pthread_sigmask
argument_list|,
name|pthread_sigmask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_pthread_sigmask
parameter_list|(
name|int
name|how
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|sigset_t
modifier|*
name|oset
parameter_list|)
block|{
if|if
condition|(
name|_sigprocmask
argument_list|(
name|how
argument_list|,
name|set
argument_list|,
name|oset
argument_list|)
condition|)
return|return
operator|(
name|errno
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__sigsuspend
argument_list|,
name|sigsuspend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_sigsuspend
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
return|return
operator|(
name|__sys_sigsuspend
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__sigsuspend
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|sigset_t
name|newset
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|old
decl_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
name|old
operator|=
name|curthread
operator|->
name|in_sigsuspend
expr_stmt|;
name|curthread
operator|->
name|in_sigsuspend
operator|=
literal|1
expr_stmt|;
name|_thr_cancel_enter
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__sys_sigsuspend
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|)
expr_stmt|;
name|_thr_cancel_leave
argument_list|(
name|curthread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|in_sigsuspend
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|unblock_sigcancel
condition|)
block|{
name|curthread
operator|->
name|unblock_sigcancel
operator|=
literal|0
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|newset
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|newset
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
name|__sys_sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|newset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|___sigwait
argument_list|,
name|sigwait
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__sigtimedwait
argument_list|,
name|sigtimedwait
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__sigwaitinfo
argument_list|,
name|sigwaitinfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_sigtimedwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
return|return
operator|(
name|__sys_sigtimedwait
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|,
name|info
argument_list|,
name|timeout
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cancellation behavior:  *   Thread may be canceled at start, if thread got signal,  *   it is not canceled.  */
end_comment

begin_function
name|int
name|__sigtimedwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|sigset_t
name|newset
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|_thr_cancel_enter
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__sys_sigtimedwait
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|,
name|info
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|_thr_cancel_leave
argument_list|(
name|curthread
argument_list|,
operator|(
name|ret
operator|==
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_sigwaitinfo
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
return|return
operator|(
name|__sys_sigwaitinfo
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|,
name|info
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cancellation behavior:  *   Thread may be canceled at start, if thread got signal,  *   it is not canceled.  */
end_comment

begin_function
name|int
name|__sigwaitinfo
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|siginfo_t
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|sigset_t
name|newset
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|_thr_cancel_enter
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__sys_sigwaitinfo
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|_thr_cancel_leave
argument_list|(
name|curthread
argument_list|,
name|ret
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_sigwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|int
modifier|*
name|sig
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
return|return
operator|(
name|__sys_sigwait
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|,
name|sig
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cancellation behavior:  *   Thread may be canceled at start, if thread got signal,  *   it is not canceled.  */
end_comment

begin_function
name|int
name|___sigwait
parameter_list|(
specifier|const
name|sigset_t
modifier|*
name|set
parameter_list|,
name|int
modifier|*
name|sig
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|sigset_t
name|newset
decl_stmt|;
name|int
name|ret
decl_stmt|;
do|do
block|{
name|_thr_cancel_enter
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__sys_sigwait
argument_list|(
name|thr_remove_thr_signals
argument_list|(
name|set
argument_list|,
operator|&
name|newset
argument_list|)
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|_thr_cancel_leave
argument_list|(
name|curthread
argument_list|,
operator|(
name|ret
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|EINTR
condition|)
do|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_setcontext
argument_list|,
name|setcontext
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_setcontext
parameter_list|(
specifier|const
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|ucontext_t
name|uc
decl_stmt|;
if|if
condition|(
name|ucp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|SIGISMEMBER
argument_list|(
name|uc
operator|.
name|uc_sigmask
argument_list|,
name|SIGCANCEL
argument_list|)
condition|)
return|return
name|__sys_setcontext
argument_list|(
name|ucp
argument_list|)
return|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|uc
argument_list|,
name|ucp
argument_list|,
sizeof|sizeof
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|uc
operator|.
name|uc_sigmask
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
return|return
name|__sys_setcontext
argument_list|(
operator|&
name|uc
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_swapcontext
argument_list|,
name|swapcontext
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_swapcontext
parameter_list|(
name|ucontext_t
modifier|*
name|oucp
parameter_list|,
specifier|const
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|ucontext_t
name|uc
decl_stmt|;
if|if
condition|(
name|oucp
operator|==
name|NULL
operator|||
name|ucp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|ucp
operator|->
name|uc_sigmask
argument_list|,
name|SIGCANCEL
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|uc
argument_list|,
name|ucp
argument_list|,
sizeof|sizeof
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|uc
operator|.
name|uc_sigmask
argument_list|,
name|SIGCANCEL
argument_list|)
expr_stmt|;
name|ucp
operator|=
operator|&
name|uc
expr_stmt|;
block|}
return|return
name|__sys_swapcontext
argument_list|(
name|oucp
argument_list|,
name|ucp
argument_list|)
return|;
block|}
end_function

end_unit

