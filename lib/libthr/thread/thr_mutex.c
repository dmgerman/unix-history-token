begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 John Birrell<jb@cimlogic.com.au>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by John Birrell.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"thr_private.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_PTHREADS_INVARIANTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|_MUTEX_INIT_LINK
parameter_list|(
name|m
parameter_list|)
value|do {		\ 	(m)->m_qe.tqe_prev = NULL;			\ 	(m)->m_qe.tqe_next = NULL;			\ } while (0)
end_define

begin_define
define|#
directive|define
name|_MUTEX_ASSERT_IS_OWNED
parameter_list|(
name|m
parameter_list|)
value|do {		\ 	if ((m)->m_qe.tqe_prev == NULL)			\ 		PANIC("mutex is not on list");		\ } while (0)
end_define

begin_define
define|#
directive|define
name|_MUTEX_ASSERT_NOT_OWNED
parameter_list|(
name|m
parameter_list|)
value|do {		\ 	if (((m)->m_qe.tqe_prev != NULL) ||		\ 	    ((m)->m_qe.tqe_next != NULL))		\ 		PANIC("mutex is on list");		\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_MUTEX_INIT_LINK
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|_MUTEX_ASSERT_IS_OWNED
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|_MUTEX_ASSERT_NOT_OWNED
parameter_list|(
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|get_muncontested
parameter_list|(
name|pthread_mutex_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_mcontested
parameter_list|(
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mutex_lock_common
parameter_list|(
name|pthread_mutex_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|mutex_self_trylock
parameter_list|(
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|mutex_self_lock
parameter_list|(
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|mutex_unlock_common
parameter_list|(
name|pthread_mutex_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mutex_priority_adjust
parameter_list|(
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mutex_rescan_owned
parameter_list|(
name|pthread_t
parameter_list|,
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|pthread_t
name|mutex_queue_deq
parameter_list|(
name|pthread_mutex_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mutex_queue_remove
parameter_list|(
name|pthread_mutex_t
parameter_list|,
name|pthread_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mutex_queue_enq
parameter_list|(
name|pthread_mutex_t
parameter_list|,
name|pthread_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|spinlock_t
name|static_init_lock
init|=
name|_SPINLOCK_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pthread_mutex_attr
name|static_mutex_attr
init|=
name|PTHREAD_MUTEXATTR_STATIC_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutexattr_t
name|static_mattr
init|=
operator|&
name|static_mutex_attr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Single underscore versions provided for libc internal usage: */
end_comment

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__pthread_mutex_trylock
argument_list|,
name|pthread_mutex_trylock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|__pthread_mutex_lock
argument_list|,
name|pthread_mutex_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* No difference between libc and application usage of these: */
end_comment

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_pthread_mutex_init
argument_list|,
name|pthread_mutex_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_pthread_mutex_destroy
argument_list|,
name|pthread_mutex_destroy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_pthread_mutex_unlock
argument_list|,
name|pthread_mutex_unlock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Reinitialize a private mutex; this is only used for internal mutexes.  */
end_comment

begin_function
name|int
name|_mutex_reinit
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|_pthread_mutex_init
argument_list|(
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Initialize the mutex structure: 		 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_type
operator|=
name|PTHREAD_MUTEX_DEFAULT
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_protocol
operator|=
name|PTHREAD_PRIO_NONE
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_queue
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_flags
operator||=
name|MUTEX_FLAGS_INITED
operator||
name|MUTEX_FLAGS_PRIVATE
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_refcount
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
literal|0
expr_stmt|;
name|_MUTEX_INIT_LINK
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_init
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
specifier|const
name|pthread_mutexattr_t
modifier|*
name|mutex_attr
parameter_list|)
block|{
name|enum
name|pthread_mutextype
name|type
decl_stmt|;
name|int
name|protocol
decl_stmt|;
name|int
name|ceiling
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|pthread_mutex_t
name|pmutex
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* Check if default mutex attributes: */
if|if
condition|(
name|mutex_attr
operator|==
name|NULL
operator|||
operator|*
name|mutex_attr
operator|==
name|NULL
condition|)
block|{
comment|/* Default to a (error checking) POSIX mutex: */
name|type
operator|=
name|PTHREAD_MUTEX_ERRORCHECK
expr_stmt|;
name|protocol
operator|=
name|PTHREAD_PRIO_NONE
expr_stmt|;
name|ceiling
operator|=
name|PTHREAD_MAX_PRIORITY
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check mutex type: */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_type
operator|<
name|PTHREAD_MUTEX_ERRORCHECK
operator|)
operator|||
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_type
operator|>=
name|MUTEX_TYPE_MAX
operator|)
condition|)
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* Check mutex protocol: */
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_protocol
operator|<
name|PTHREAD_PRIO_NONE
operator|)
operator|||
operator|(
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_protocol
operator|>
name|PTHREAD_MUTEX_RECURSIVE
operator|)
condition|)
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* Use the requested mutex type and protocol: */
name|type
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_type
expr_stmt|;
name|protocol
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_protocol
expr_stmt|;
name|ceiling
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_ceiling
expr_stmt|;
name|flags
operator|=
operator|(
operator|*
name|mutex_attr
operator|)
operator|->
name|m_flags
expr_stmt|;
block|}
comment|/* Check no errors so far: */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pmutex
operator|=
operator|(
name|pthread_mutex_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pthread_mutex
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ret
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
comment|/* Set the mutex flags: */
name|pmutex
operator|->
name|m_flags
operator|=
name|flags
expr_stmt|;
comment|/* Process according to mutex type: */
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* case PTHREAD_MUTEX_DEFAULT: */
case|case
name|PTHREAD_MUTEX_ERRORCHECK
case|:
case|case
name|PTHREAD_MUTEX_NORMAL
case|:
comment|/* Nothing to do here. */
break|break;
comment|/* Single UNIX Spec 2 recursive mutex: */
case|case
name|PTHREAD_MUTEX_RECURSIVE
case|:
comment|/* Reset the mutex count: */
name|pmutex
operator|->
name|m_data
operator|.
name|m_count
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* Trap invalid mutex types: */
default|default:
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Initialise the rest of the mutex: */
name|TAILQ_INIT
argument_list|(
operator|&
name|pmutex
operator|->
name|m_queue
argument_list|)
expr_stmt|;
name|pmutex
operator|->
name|m_flags
operator||=
name|MUTEX_FLAGS_INITED
expr_stmt|;
name|pmutex
operator|->
name|m_owner
operator|=
name|NULL
expr_stmt|;
name|pmutex
operator|->
name|m_type
operator|=
name|type
expr_stmt|;
name|pmutex
operator|->
name|m_protocol
operator|=
name|protocol
expr_stmt|;
name|pmutex
operator|->
name|m_refcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|protocol
operator|==
name|PTHREAD_PRIO_PROTECT
condition|)
name|pmutex
operator|->
name|m_prio
operator|=
name|ceiling
expr_stmt|;
else|else
name|pmutex
operator|->
name|m_prio
operator|=
literal|0
expr_stmt|;
name|pmutex
operator|->
name|m_saved_prio
operator|=
literal|0
expr_stmt|;
name|_MUTEX_INIT_LINK
argument_list|(
name|pmutex
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pmutex
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pmutex
operator|->
name|lock
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mutex
operator|=
name|pmutex
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|pmutex
argument_list|)
expr_stmt|;
operator|*
name|mutex
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_destroy
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
operator|||
operator|*
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
comment|/* Lock the mutex structure: */
name|_SPINLOCK
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if this mutex is in use: 		 */
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_queue
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_refcount
operator|!=
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|_SPINUNLOCK
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Free the memory allocated for the mutex 			 * structure: 			 */
name|_MUTEX_ASSERT_NOT_OWNED
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex structure: */
name|_SPINUNLOCK
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
comment|/* 			 * Leave the caller's pointer NULL now that 			 * the mutex has been destroyed: 			 */
operator|*
name|mutex
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_static
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|_SPINLOCK
argument_list|(
operator|&
name|static_init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|_pthread_mutex_init
argument_list|(
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|_SPINUNLOCK
argument_list|(
operator|&
name|static_init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_static_private
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|_SPINLOCK
argument_list|(
operator|&
name|static_init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|_pthread_mutex_init
argument_list|(
name|mutex
argument_list|,
operator|&
name|static_mattr
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|_SPINUNLOCK
argument_list|(
operator|&
name|static_init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__pthread_mutex_trylock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization: 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ret
operator|=
name|init_static
argument_list|(
name|mutex
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|mutex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_trylock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization marking the mutex private (delete safe): 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ret
operator|=
name|init_static_private
argument_list|(
name|mutex
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|mutex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mutex_lock_common
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|error
decl_stmt|,
name|inCancel
decl_stmt|;
name|ret
operator|=
name|error
operator|=
name|inCancel
operator|=
literal|0
expr_stmt|;
name|PTHREAD_ASSERT
argument_list|(
operator|(
name|mutex
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
argument_list|,
literal|"Uninitialized mutex in mutex_lock_common"
argument_list|)
expr_stmt|;
comment|/* 	 * Enter a loop waiting to become the mutex owner.  We need a 	 * loop in case the waiting thread is interrupted by a signal 	 * to execute a signal handler.  It is not (currently) possible 	 * to remain in the waiting queue while running a handler. 	 * Instead, the thread is interrupted and backed out of the 	 * waiting queue prior to executing the signal handler. 	 */
do|do
block|{
comment|/* 		 * Defer signals to protect the scheduling queues from 		 * access by the signal handler: 		 */
comment|/* _thread_kern_sig_defer(); */
comment|/* Lock the mutex structure: */
name|_SPINLOCK
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * If the mutex was statically allocated, properly 		 * initialize the tail queue. 		 */
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_queue
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_flags
operator||=
name|MUTEX_FLAGS_INITED
expr_stmt|;
name|_MUTEX_INIT_LINK
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
block|}
comment|/* Process according to mutex type: */
switch|switch
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_protocol
condition|)
block|{
comment|/* Default POSIX mutex: */
case|case
name|PTHREAD_PRIO_NONE
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|get_muncontested
argument_list|(
operator|*
name|mutex
argument_list|,
name|nonblock
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|nonblock
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
else|else
block|{
name|get_mcontested
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|error
expr_stmt|;
break|break;
comment|/* POSIX priority inheritence mutex: */
case|case
name|PTHREAD_PRIO_INHERIT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|get_muncontested
argument_list|(
operator|*
name|mutex
argument_list|,
name|nonblock
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Track number of priority mutexes owned: */
name|curthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 				 * The mutex takes on attributes of the 				 * running thread when there are no waiters. 				 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
operator|=
name|curthread
operator|->
name|active_priority
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
name|curthread
operator|->
name|inherited_priority
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|nonblock
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
else|else
block|{
name|get_mcontested
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curthread
operator|->
name|active_priority
operator|>
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
condition|)
comment|/* Adjust priorities: */
name|mutex_priority_adjust
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|error
expr_stmt|;
block|}
break|break;
comment|/* POSIX priority protection mutex: */
case|case
name|PTHREAD_PRIO_PROTECT
case|:
comment|/* Check for a priority ceiling violation: */
if|if
condition|(
name|curthread
operator|->
name|active_priority
operator|>
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|get_muncontested
argument_list|(
operator|*
name|mutex
argument_list|,
name|nonblock
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Track number of priority mutexes owned: */
name|curthread
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 				 * The running thread inherits the ceiling 				 * priority of the mutex and executes at that 				 * priority: 				 */
name|curthread
operator|->
name|active_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
name|curthread
operator|->
name|inherited_priority
expr_stmt|;
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|nonblock
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* Clear any previous error: */
name|curthread
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|get_mcontested
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
comment|/* 				 * The threads priority may have changed while 				 * waiting for the mutex causing a ceiling 				 * violation. 				 */
name|ret
operator|=
name|curthread
operator|->
name|error
expr_stmt|;
name|curthread
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|error
expr_stmt|;
block|}
break|break;
comment|/* Trap invalid mutex types: */
default|default:
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Check to see if this thread was interrupted and 		 * is still in the mutex queue of waiting threads: 		 */
if|if
condition|(
name|curthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_CANCELLING
condition|)
block|{
if|if
condition|(
operator|!
name|nonblock
condition|)
name|mutex_queue_remove
argument_list|(
operator|*
name|mutex
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|inCancel
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Unlock the mutex structure: */
name|_SPINUNLOCK
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * Undefer and handle pending signals, yielding if 		 * necessary: 		 */
comment|/* _thread_kern_sig_undefer(); */
if|if
condition|(
name|inCancel
condition|)
block|{
name|pthread_testcancel
argument_list|()
expr_stmt|;
name|PANIC
argument_list|(
literal|"Canceled thread came back.\n"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
operator|&&
name|ret
operator|==
literal|0
condition|)
do|;
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__pthread_mutex_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|_thread_initial
operator|==
name|NULL
condition|)
name|_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization: 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static
argument_list|(
name|mutex
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|mutex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|_thread_initial
operator|==
name|NULL
condition|)
name|_thread_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
name|ret
operator|=
name|EINVAL
expr_stmt|;
comment|/* 	 * If the mutex is statically initialized, perform the dynamic 	 * initialization marking it private (delete safe): 	 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|mutex
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ret
operator|=
name|init_static_private
argument_list|(
name|mutex
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|ret
operator|=
name|mutex_lock_common
argument_list|(
name|mutex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_pthread_mutex_unlock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
return|return
operator|(
name|mutex_unlock_common
argument_list|(
name|mutex
argument_list|,
comment|/* add reference */
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_mutex_cv_unlock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
return|return
operator|(
name|mutex_unlock_common
argument_list|(
name|mutex
argument_list|,
comment|/* add reference */
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_mutex_cv_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|_pthread_mutex_lock
argument_list|(
name|mutex
argument_list|)
operator|)
operator|==
literal|0
condition|)
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_refcount
operator|--
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mutex_self_trylock
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mutex
operator|->
name|m_type
condition|)
block|{
comment|/* case PTHREAD_MUTEX_DEFAULT: */
case|case
name|PTHREAD_MUTEX_ERRORCHECK
case|:
case|case
name|PTHREAD_MUTEX_NORMAL
case|:
comment|/* 		 * POSIX specifies that mutexes should return EDEADLK if a 		 * recursive lock is detected. 		 */
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
case|case
name|PTHREAD_MUTEX_RECURSIVE
case|:
comment|/* Increment the lock count: */
name|mutex
operator|->
name|m_data
operator|.
name|m_count
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Trap invalid mutex types; */
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mutex_self_lock
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mutex
operator|->
name|m_type
condition|)
block|{
comment|/* case PTHREAD_MUTEX_DEFAULT: */
case|case
name|PTHREAD_MUTEX_ERRORCHECK
case|:
comment|/* 		 * POSIX specifies that mutexes should return EDEADLK if a 		 * recursive lock is detected. 		 */
name|ret
operator|=
name|EDEADLK
expr_stmt|;
break|break;
case|case
name|PTHREAD_MUTEX_NORMAL
case|:
comment|/* 		 * What SS2 define as a 'normal' mutex.  Intentionally 		 * deadlock on attempts to get a lock you already own. 		 */
comment|/* XXX Sched lock. */
name|PTHREAD_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_DEADLOCK
argument_list|)
expr_stmt|;
name|_SPINUNLOCK
argument_list|(
operator|&
operator|(
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
name|_thread_suspend
argument_list|(
name|curthread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|PANIC
argument_list|(
literal|"Shouldn't resume here?\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTHREAD_MUTEX_RECURSIVE
case|:
comment|/* Increment the lock count: */
name|mutex
operator|->
name|m_data
operator|.
name|m_count
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Trap invalid mutex types; */
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mutex_unlock_common
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
name|int
name|add_reference
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mutex
operator|==
name|NULL
operator|||
operator|*
name|mutex
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Defer signals to protect the scheduling queues from 		 * access by the signal handler: 		 */
comment|/* _thread_kern_sig_defer(); */
comment|/* Lock the mutex structure: */
name|_SPINLOCK
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Process according to mutex type: */
switch|switch
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_protocol
condition|)
block|{
comment|/* Default POSIX mutex: */
case|case
name|PTHREAD_PRIO_NONE
case|:
comment|/* 			 * Check if the running thread is not the owner of the 			 * mutex: 			 */
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
condition|)
block|{
comment|/* 				 * Return an invalid argument error for no 				 * owner and a permission error otherwise: 				 */
name|ret
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|?
name|EINVAL
else|:
name|EPERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_type
operator|==
name|PTHREAD_MUTEX_RECURSIVE
operator|)
operator|&&
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Decrement the count: */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Clear the count in case this is recursive 				 * mutex. 				 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|=
literal|0
expr_stmt|;
comment|/* Remove the mutex from the threads queue. */
name|_MUTEX_ASSERT_IS_OWNED
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
name|_MUTEX_INIT_LINK
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
comment|/* 				 * Get the next thread from the queue of 				 * threads waiting on the mutex. The deq 				 * function will have already locked it 				 * for us. 				 */
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|mutex_queue_deq
argument_list|(
operator|*
name|mutex
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Make the new owner runnable: */
comment|/* XXXTHR sched lock. */
name|PTHREAD_NEW_STATE
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
comment|/* 					 * Add the mutex to the threads list of 					 * owned mutexes: 					 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
comment|/* 					 * The owner is no longer waiting for 					 * this mutex: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
name|_thread_critical_exit
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* POSIX priority inheritence mutex: */
case|case
name|PTHREAD_PRIO_INHERIT
case|:
comment|/* 			 * Check if the running thread is not the owner of the 			 * mutex: 			 */
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
condition|)
block|{
comment|/* 				 * Return an invalid argument error for no 				 * owner and a permission error otherwise: 				 */
name|ret
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|?
name|EINVAL
else|:
name|EPERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_type
operator|==
name|PTHREAD_MUTEX_RECURSIVE
operator|)
operator|&&
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Decrement the count: */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Clear the count in case this is recursive 				 * mutex. 				 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Restore the threads inherited priority and 				 * recompute the active priority (being careful 				 * not to override changes in the threads base 				 * priority subsequent to locking the mutex). 				 */
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
expr_stmt|;
name|curthread
operator|->
name|active_priority
operator|=
name|MAX
argument_list|(
name|curthread
operator|->
name|inherited_priority
argument_list|,
name|curthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
comment|/* 				 * This thread now owns one less priority mutex. 				 */
name|curthread
operator|->
name|priority_mutex_count
operator|--
expr_stmt|;
comment|/* Remove the mutex from the threads queue. */
name|_MUTEX_ASSERT_IS_OWNED
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
name|_MUTEX_INIT_LINK
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
comment|/* 				 * Get the next thread from the queue of threads 				 * waiting on the mutex. It will already be 				 * locked for us.  				 */
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|mutex_queue_deq
argument_list|(
operator|*
name|mutex
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* This mutex has no priority. */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 					 * Track number of priority mutexes owned: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 					 * Add the mutex to the threads list 					 * of owned mutexes: 					 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
comment|/* 					 * The owner is no longer waiting for 					 * this mutex: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
comment|/* 					 * Set the priority of the mutex.  Since 					 * our waiting threads are in descending 					 * priority order, the priority of the 					 * mutex becomes the active priority of 					 * the thread we just dequeued. 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|active_priority
expr_stmt|;
comment|/* 					 * Save the owning threads inherited 					 * priority: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|inherited_priority
expr_stmt|;
comment|/* 					 * The owning threads inherited priority 					 * now becomes his active priority (the 					 * priority of the mutex). 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
comment|/* 					 * Make the new owner runnable: 					 */
comment|/* XXXTHR sched lock. */
name|PTHREAD_NEW_STATE
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|_thread_critical_exit
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* POSIX priority ceiling mutex: */
case|case
name|PTHREAD_PRIO_PROTECT
case|:
comment|/* 			 * Check if the running thread is not the owner of the 			 * mutex: 			 */
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|!=
name|curthread
condition|)
block|{
comment|/* 				 * Return an invalid argument error for no 				 * owner and a permission error otherwise: 				 */
name|ret
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|==
name|NULL
condition|?
name|EINVAL
else|:
name|EPERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_type
operator|==
name|PTHREAD_MUTEX_RECURSIVE
operator|)
operator|&&
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Decrement the count: */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Clear the count in case this is recursive 				 * mutex. 				 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_data
operator|.
name|m_count
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Restore the threads inherited priority and 				 * recompute the active priority (being careful 				 * not to override changes in the threads base 				 * priority subsequent to locking the mutex). 				 */
name|curthread
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
expr_stmt|;
name|curthread
operator|->
name|active_priority
operator|=
name|MAX
argument_list|(
name|curthread
operator|->
name|inherited_priority
argument_list|,
name|curthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
comment|/* 				 * This thread now owns one less priority mutex. 				 */
name|curthread
operator|->
name|priority_mutex_count
operator|--
expr_stmt|;
comment|/* Remove the mutex from the threads queue. */
name|_MUTEX_ASSERT_IS_OWNED
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
name|_MUTEX_INIT_LINK
argument_list|(
operator|*
name|mutex
argument_list|)
expr_stmt|;
comment|/* 				 * Enter a loop to find a waiting thread whose 				 * active priority will not cause a ceiling 				 * violation. It will already be locked for us. 				 */
while|while
condition|(
operator|(
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|=
name|mutex_queue_deq
argument_list|(
operator|*
name|mutex
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|active_priority
operator|>
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
operator|)
condition|)
block|{
comment|/* 					 * Either the mutex ceiling priority 					 * been lowered and/or this threads 					 * priority has been raised subsequent 					 * to this thread being queued on the 					 * waiting list. 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
comment|/* 					 * The thread is no longer waiting for 					 * this mutex: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
name|_thread_critical_exit
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|)
expr_stmt|;
block|}
comment|/* Check for a new owner: */
if|if
condition|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Track number of priority mutexes owned: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|priority_mutex_count
operator|++
expr_stmt|;
comment|/* 					 * Add the mutex to the threads list 					 * of owned mutexes: 					 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|mutexq
argument_list|,
operator|(
operator|*
name|mutex
operator|)
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
comment|/* 					 * The owner is no longer waiting for 					 * this mutex: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
comment|/* 					 * Save the owning threads inherited 					 * priority: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_saved_prio
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|inherited_priority
expr_stmt|;
comment|/* 					 * The owning thread inherits the 					 * ceiling priority of the mutex and 					 * executes at that priority: 					 */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|inherited_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
operator|->
name|active_priority
operator|=
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_prio
expr_stmt|;
comment|/* 					 * Make the new owner runnable: 					 */
comment|/* XXXTHR sched lock. */
name|PTHREAD_NEW_STATE
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|_thread_critical_exit
argument_list|(
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_owner
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Trap invalid mutex types: */
default|default:
comment|/* Return an invalid argument error: */
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|&&
operator|(
name|add_reference
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Increment the reference count: */
operator|(
operator|*
name|mutex
operator|)
operator|->
name|m_refcount
operator|++
expr_stmt|;
block|}
comment|/* Unlock the mutex structure: */
name|_SPINUNLOCK
argument_list|(
operator|&
operator|(
operator|*
name|mutex
operator|)
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * Undefer and handle pending signals, yielding if 		 * necessary: 		 */
comment|/* _thread_kern_sig_undefer(); */
block|}
comment|/* Return the completion status: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called when a change in base priority occurs for  * a thread that is holding or waiting for a priority protection or  * inheritence mutex.  A change in a threads base priority can effect  * changes to active priorities of other threads and to the ordering  * of mutex locking by waiting threads.  *  * This must be called while thread scheduling is deferred.  */
end_comment

begin_function
name|void
name|_mutex_notify_priochange
parameter_list|(
name|pthread_t
name|pthread
parameter_list|)
block|{
comment|/* Adjust the priorites of any owned priority mutexes: */
if|if
condition|(
name|pthread
operator|->
name|priority_mutex_count
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Rescan the mutexes owned by this thread and correct 		 * their priorities to account for this threads change 		 * in priority.  This has the side effect of changing 		 * the threads active priority. 		 */
name|mutex_rescan_owned
argument_list|(
name|pthread
argument_list|,
comment|/* rescan all owned */
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this thread is waiting on a priority inheritence mutex, 	 * check for priority adjustments.  A change in priority can 	 * also effect a ceiling violation(*) for a thread waiting on 	 * a priority protection mutex; we don't perform the check here 	 * as it is done in pthread_mutex_unlock. 	 * 	 * (*) It should be noted that a priority change to a thread 	 *     _after_ taking and owning a priority ceiling mutex 	 *     does not affect ownership of that mutex; the ceiling 	 *     priority is only checked before mutex ownership occurs. 	 */
if|if
condition|(
name|pthread
operator|->
name|state
operator|==
name|PS_MUTEX_WAIT
condition|)
block|{
comment|/* Lock the mutex structure: */
name|_SPINLOCK
argument_list|(
operator|&
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * Check to make sure this thread is still in the same state 		 * (the spinlock above can yield the CPU to another thread): 		 */
if|if
condition|(
name|pthread
operator|->
name|state
operator|==
name|PS_MUTEX_WAIT
condition|)
block|{
comment|/* 			 * Remove and reinsert this thread into the list of 			 * waiting threads to preserve decreasing priority 			 * order. 			 */
name|mutex_queue_remove
argument_list|(
name|pthread
operator|->
name|data
operator|.
name|mutex
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
name|mutex_queue_enq
argument_list|(
name|pthread
operator|->
name|data
operator|.
name|mutex
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|->
name|m_protocol
operator|==
name|PTHREAD_PRIO_INHERIT
condition|)
block|{
comment|/* Adjust priorities: */
name|mutex_priority_adjust
argument_list|(
name|pthread
operator|->
name|data
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Unlock the mutex structure: */
name|_SPINUNLOCK
argument_list|(
operator|&
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called when a new thread is added to the mutex waiting queue or  * when a threads priority changes that is already in the mutex  * waiting queue.  */
end_comment

begin_function
specifier|static
name|void
name|mutex_priority_adjust
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|)
block|{
name|pthread_t
name|pthread_next
decl_stmt|,
name|pthread
init|=
name|mutex
operator|->
name|m_owner
decl_stmt|;
name|int
name|temp_prio
decl_stmt|;
name|pthread_mutex_t
name|m
init|=
name|mutex
decl_stmt|;
comment|/* 	 * Calculate the mutex priority as the maximum of the highest 	 * active priority of any waiting threads and the owning threads 	 * active priority(*). 	 * 	 * (*) Because the owning threads current active priority may 	 *     reflect priority inherited from this mutex (and the mutex 	 *     priority may have changed) we must recalculate the active 	 *     priority based on the threads saved inherited priority 	 *     and its base priority. 	 */
name|pthread_next
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|m_queue
argument_list|)
expr_stmt|;
comment|/* should never be NULL */
name|temp_prio
operator|=
name|MAX
argument_list|(
name|pthread_next
operator|->
name|active_priority
argument_list|,
name|MAX
argument_list|(
name|m
operator|->
name|m_saved_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if this mutex really needs adjusting: */
if|if
condition|(
name|temp_prio
operator|==
name|m
operator|->
name|m_prio
condition|)
comment|/* No need to propagate the priority: */
return|return;
comment|/* Set new priority of the mutex: */
name|m
operator|->
name|m_prio
operator|=
name|temp_prio
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Save the threads priority before rescanning the 		 * owned mutexes: 		 */
name|temp_prio
operator|=
name|pthread
operator|->
name|active_priority
expr_stmt|;
comment|/* 		 * Fix the priorities for all the mutexes this thread has 		 * locked since taking this mutex.  This also has a 		 * potential side-effect of changing the threads priority. 		 */
name|mutex_rescan_owned
argument_list|(
name|pthread
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * If the thread is currently waiting on a mutex, check 		 * to see if the threads new priority has affected the 		 * priority of the mutex. 		 */
if|if
condition|(
operator|(
name|temp_prio
operator|!=
name|pthread
operator|->
name|active_priority
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|state
operator|==
name|PS_MUTEX_WAIT
operator|)
operator|&&
operator|(
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|->
name|m_protocol
operator|==
name|PTHREAD_PRIO_INHERIT
operator|)
condition|)
block|{
comment|/* Grab the mutex this thread is waiting on: */
name|m
operator|=
name|pthread
operator|->
name|data
operator|.
name|mutex
expr_stmt|;
comment|/* 			 * The priority for this thread has changed.  Remove 			 * and reinsert this thread into the list of waiting 			 * threads to preserve decreasing priority order. 			 */
name|mutex_queue_remove
argument_list|(
name|m
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
name|mutex_queue_enq
argument_list|(
name|m
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
comment|/* Grab the waiting thread with highest priority: */
name|pthread_next
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|m_queue
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate the mutex priority as the maximum of the 			 * highest active priority of any waiting threads and 			 * the owning threads active priority. 			 */
name|temp_prio
operator|=
name|MAX
argument_list|(
name|pthread_next
operator|->
name|active_priority
argument_list|,
name|MAX
argument_list|(
name|m
operator|->
name|m_saved_prio
argument_list|,
name|m
operator|->
name|m_owner
operator|->
name|base_priority
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_prio
operator|!=
name|m
operator|->
name|m_prio
condition|)
block|{
comment|/* 				 * The priority needs to be propagated to the 				 * mutex this thread is waiting on and up to 				 * the owner of that mutex. 				 */
name|m
operator|->
name|m_prio
operator|=
name|temp_prio
expr_stmt|;
name|pthread
operator|=
name|m
operator|->
name|m_owner
expr_stmt|;
block|}
else|else
comment|/* We're done: */
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* We're done: */
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_rescan_owned
parameter_list|(
name|pthread_t
name|pthread
parameter_list|,
name|pthread_mutex_t
name|mutex
parameter_list|)
block|{
name|int
name|active_prio
decl_stmt|,
name|inherited_prio
decl_stmt|;
name|pthread_mutex_t
name|m
decl_stmt|;
name|pthread_t
name|pthread_next
decl_stmt|;
comment|/* 	 * Start walking the mutexes the thread has taken since 	 * taking this mutex. 	 */
if|if
condition|(
name|mutex
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * A null mutex means start at the beginning of the owned 		 * mutex list. 		 */
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|)
expr_stmt|;
comment|/* There is no inherited priority yet. */
name|inherited_prio
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The caller wants to start after a specific mutex.  It 		 * is assumed that this mutex is a priority inheritence 		 * mutex and that its priority has been correctly 		 * calculated. 		 */
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|mutex
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
comment|/* Start inheriting priority from the specified mutex. */
name|inherited_prio
operator|=
name|mutex
operator|->
name|m_prio
expr_stmt|;
block|}
name|active_prio
operator|=
name|MAX
argument_list|(
name|inherited_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We only want to deal with priority inheritence 		 * mutexes.  This might be optimized by only placing 		 * priority inheritence mutexes into the owned mutex 		 * list, but it may prove to be useful having all 		 * owned mutexes in this list.  Consider a thread 		 * exiting while holding mutexes... 		 */
if|if
condition|(
name|m
operator|->
name|m_protocol
operator|==
name|PTHREAD_PRIO_INHERIT
condition|)
block|{
comment|/* 			 * Fix the owners saved (inherited) priority to 			 * reflect the priority of the previous mutex. 			 */
name|m
operator|->
name|m_saved_prio
operator|=
name|inherited_prio
expr_stmt|;
if|if
condition|(
operator|(
name|pthread_next
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|m_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* Recalculate the priority of the mutex: */
name|m
operator|->
name|m_prio
operator|=
name|MAX
argument_list|(
name|active_prio
argument_list|,
name|pthread_next
operator|->
name|active_priority
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|m_prio
operator|=
name|active_prio
expr_stmt|;
comment|/* Recalculate new inherited and active priorities: */
name|inherited_prio
operator|=
name|m
operator|->
name|m_prio
expr_stmt|;
name|active_prio
operator|=
name|MAX
argument_list|(
name|m
operator|->
name|m_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
block|}
comment|/* Advance to the next mutex owned by this thread: */
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fix the threads inherited priority and recalculate its 	 * active priority. 	 */
name|pthread
operator|->
name|inherited_priority
operator|=
name|inherited_prio
expr_stmt|;
name|active_prio
operator|=
name|MAX
argument_list|(
name|inherited_prio
argument_list|,
name|pthread
operator|->
name|base_priority
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_prio
operator|!=
name|pthread
operator|->
name|active_priority
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 		 * If this thread is in the priority queue, it must be 		 * removed and reinserted for its new priority. 	 	 */
block|if (pthread->flags& PTHREAD_FLAGS_IN_PRIOQ) {
comment|/* 			 * Remove the thread from the priority queue 			 * before changing its priority: 			 */
block|PTHREAD_PRIOQ_REMOVE(pthread);
comment|/* 			 * POSIX states that if the priority is being 			 * lowered, the thread must be inserted at the 			 * head of the queue for its priority if it owns 			 * any priority protection or inheritence mutexes. 			 */
block|if ((active_prio< pthread->active_priority)&& 			    (pthread->priority_mutex_count> 0)) {
comment|/* Set the new active priority. */
block|pthread->active_priority = active_prio;  				PTHREAD_PRIOQ_INSERT_HEAD(pthread); 			} 			else {
comment|/* Set the new active priority. */
block|pthread->active_priority = active_prio;  				PTHREAD_PRIOQ_INSERT_TAIL(pthread); 			} 		} 		else {
comment|/* Set the new active priority. */
block|pthread->active_priority = active_prio; 		}
endif|#
directive|endif
name|pthread
operator|->
name|active_priority
operator|=
name|active_prio
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_mutex_unlock_private
parameter_list|(
name|pthread_t
name|pthread
parameter_list|)
block|{
name|struct
name|pthread_mutex
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_next
decl_stmt|;
for|for
control|(
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pthread
operator|->
name|mutexq
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m_next
control|)
block|{
name|m_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|MUTEX_FLAGS_PRIVATE
operator|)
operator|!=
literal|0
condition|)
name|_pthread_mutex_unlock
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_mutex_lock_backout
parameter_list|(
name|pthread_t
name|pthread
parameter_list|)
block|{
name|struct
name|pthread_mutex
modifier|*
name|mutex
decl_stmt|;
comment|/* 	 * Defer signals to protect the scheduling queues from 	 * access by the signal handler: 	 */
comment|/* _thread_kern_sig_defer();*/
comment|/* XXX - Necessary to obey lock order */
name|_SPINLOCK
argument_list|(
operator|&
name|pthread
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mutex
operator|=
name|pthread
operator|->
name|data
operator|.
name|mutex
expr_stmt|;
name|_SPINUNLOCK
argument_list|(
operator|&
name|pthread
operator|->
name|lock
argument_list|)
expr_stmt|;
name|_SPINLOCK
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
name|_thread_critical_enter
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pthread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_IN_MUTEXQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_queue_remove
argument_list|(
name|mutex
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
comment|/* This thread is no longer waiting for the mutex: */
name|pthread
operator|->
name|data
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Undefer and handle pending signals, yielding if 	 * necessary: 	 */
comment|/* _thread_kern_sig_undefer(); */
name|_thread_critical_exit
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|_SPINUNLOCK
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dequeue a waiting thread from the head of a mutex queue in descending  * priority order. This funtion will return with the thread locked.  */
end_comment

begin_function
specifier|static
specifier|inline
name|pthread_t
name|mutex_queue_deq
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|)
block|{
name|pthread_t
name|pthread
decl_stmt|;
while|while
condition|(
operator|(
name|pthread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|_thread_critical_enter
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|flags
operator|&=
operator|~
name|PTHREAD_FLAGS_IN_MUTEXQ
expr_stmt|;
comment|/* 		 * Only exit the loop if the thread hasn't been 		 * cancelled. 		 */
if|if
condition|(
operator|(
name|pthread
operator|->
name|cancelflags
operator|&
name|PTHREAD_CANCELLING
operator|)
operator|==
literal|0
operator|&&
name|pthread
operator|->
name|state
operator|==
name|PS_MUTEX_WAIT
condition|)
break|break;
else|else
name|_thread_critical_exit
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pthread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a waiting thread from a mutex queue in descending priority order.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mutex_queue_remove
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|,
name|pthread_t
name|pthread
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pthread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_IN_MUTEXQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|flags
operator|&=
operator|~
name|PTHREAD_FLAGS_IN_MUTEXQ
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enqueue a waiting thread to a queue in descending priority order.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mutex_queue_enq
parameter_list|(
name|pthread_mutex_t
name|mutex
parameter_list|,
name|pthread_t
name|pthread
parameter_list|)
block|{
name|pthread_t
name|tid
init|=
name|TAILQ_LAST
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|mutex_head
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|pthread
operator|->
name|name
condition|?
name|pthread
operator|->
name|name
else|:
literal|"unknown"
expr_stmt|;
if|if
condition|(
operator|(
name|pthread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_IN_CONDQ
operator|)
operator|!=
literal|0
condition|)
name|_thread_printf
argument_list|(
literal|2
argument_list|,
literal|"Thread (%s:%u) already on condq\n"
argument_list|,
name|pthread
operator|->
name|name
argument_list|,
name|pthread
operator|->
name|uniqueid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pthread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_IN_MUTEXQ
operator|)
operator|!=
literal|0
condition|)
name|_thread_printf
argument_list|(
literal|2
argument_list|,
literal|"Thread (%s:%u) already on mutexq\n"
argument_list|,
name|pthread
operator|->
name|name
argument_list|,
name|pthread
operator|->
name|uniqueid
argument_list|)
expr_stmt|;
name|PTHREAD_ASSERT_NOT_IN_SYNCQ
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
comment|/* 	 * For the common case of all threads having equal priority, 	 * we perform a quick check against the priority of the thread 	 * at the tail of the queue. 	 */
if|if
condition|(
operator|(
name|tid
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pthread
operator|->
name|active_priority
operator|<=
name|tid
operator|->
name|active_priority
operator|)
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
else|else
block|{
name|tid
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mutex
operator|->
name|m_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|pthread
operator|->
name|active_priority
operator|<=
name|tid
operator|->
name|active_priority
condition|)
name|tid
operator|=
name|TAILQ_NEXT
argument_list|(
name|tid
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tid
argument_list|,
name|pthread
argument_list|,
name|sqe
argument_list|)
expr_stmt|;
block|}
name|pthread
operator|->
name|flags
operator||=
name|PTHREAD_FLAGS_IN_MUTEXQ
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns with the lock owned and on the threads mutexq if  * it is currently unowned. Returns 1, otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_muncontested
parameter_list|(
name|pthread_mutex_t
name|mutexp
parameter_list|,
name|int
name|nonblock
parameter_list|)
block|{
if|if
condition|(
name|mutexp
operator|->
name|m_owner
operator|!=
name|NULL
operator|&&
name|mutexp
operator|->
name|m_owner
operator|!=
name|curthread
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|mutexp
operator|->
name|m_owner
operator|==
name|curthread
condition|)
block|{
if|if
condition|(
name|nonblock
condition|)
return|return
operator|(
name|mutex_self_trylock
argument_list|(
name|mutexp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|mutex_self_lock
argument_list|(
name|mutexp
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * The mutex belongs to this thread now. Mark it as 	 * such. Add it to the list of mutexes owned by this 	 * thread. 	 */
name|mutexp
operator|->
name|m_owner
operator|=
name|curthread
expr_stmt|;
name|_MUTEX_ASSERT_NOT_OWNED
argument_list|(
name|mutexp
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|,
name|mutexp
argument_list|,
name|m_qe
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns with the lock owned and on the thread's mutexq. If  * the mutex is currently owned by another thread it will sleep  * until it is available.  */
end_comment

begin_function
specifier|static
name|void
name|get_mcontested
parameter_list|(
name|pthread_mutex_t
name|mutexp
parameter_list|)
block|{
name|_thread_critical_enter
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* 	 * Put this thread on the mutex's list of waiting threads. 	 * The lock on the thread ensures atomic (as far as other 	 * threads are concerned) setting of the thread state with 	 * it's status on the mutex queue. 	 */
do|do
block|{
name|mutex_queue_enq
argument_list|(
name|mutexp
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|PTHREAD_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_MUTEX_WAIT
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|data
operator|.
name|mutex
operator|=
name|mutexp
expr_stmt|;
name|_thread_critical_exit
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|_SPINUNLOCK
argument_list|(
operator|&
name|mutexp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|_thread_suspend
argument_list|(
name|curthread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_SPINLOCK
argument_list|(
operator|&
name|mutexp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|_thread_critical_enter
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_IN_MUTEXQ
operator|)
operator|!=
literal|0
condition|)
do|;
name|_thread_critical_exit
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

