begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2005 David Xu<davidxu@freebsd.org>  * Copyright (C) 2003 Daniel M. Eischen<deischen@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"thr_private.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_comment
comment|/*#define DEBUG_THREAD_LIST */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_THREAD_LIST
end_ifdef

begin_define
define|#
directive|define
name|DBG_MSG
value|stdout_debug
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG_MSG
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_THREADS
value|100000
end_define

begin_comment
comment|/*  * Define a high water mark for the maximum number of threads that  * will be cached.  Once this level is reached, any extra threads  * will be free()'d.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CACHED_THREADS
value|100
end_define

begin_comment
comment|/*  * We've got to keep track of everything that is allocated, not only  * to have a speedy free list, but also so they can be deallocated  * after a fork().  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|free_threadq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|umutex
name|free_thread_lock
init|=
name|DEFAULT_UMUTEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|umutex
name|tcb_lock
init|=
name|DEFAULT_UMUTEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_thread_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_threads
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|thread_hash_head
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HASH_QUEUES
value|128
end_define

begin_decl_stmt
specifier|static
name|struct
name|thread_hash_head
name|thr_hashtable
index|[
name|HASH_QUEUES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THREAD_HASH
parameter_list|(
name|thrd
parameter_list|)
value|(((unsigned long)thrd>> 8) % HASH_QUEUES)
end_define

begin_function_decl
specifier|static
name|void
name|thr_destroy
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_thr_list_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|_gc_count
operator|=
literal|0
expr_stmt|;
name|total_threads
operator|=
literal|1
expr_stmt|;
name|_thr_umutex_init
argument_list|(
operator|&
name|_thr_list_lock
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|_thread_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|free_threadq
argument_list|)
expr_stmt|;
name|_thr_umutex_init
argument_list|(
operator|&
name|free_thread_lock
argument_list|)
expr_stmt|;
name|_thr_umutex_init
argument_list|(
operator|&
name|tcb_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|inited
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_QUEUES
condition|;
operator|++
name|i
control|)
name|LIST_INIT
argument_list|(
operator|&
name|thr_hashtable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|inited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td_next
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|worklist
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|worklist
argument_list|)
expr_stmt|;
name|THREAD_LIST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Check the threads waiting for GC. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|td
argument_list|,
argument|&_thread_gc_list
argument_list|,
argument|gcle
argument_list|,
argument|td_next
argument_list|)
block|{
if|if
condition|(
name|td
operator|->
name|tid
operator|!=
name|TID_TERMINATED
condition|)
block|{
comment|/* make sure we are not still in userland */
continue|continue;
block|}
name|_thr_stack_free
argument_list|(
operator|&
name|td
operator|->
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|td
operator|->
name|tlflags
operator|&
name|TLFLAGS_DETACHED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|td
operator|->
name|refcount
operator|==
literal|0
operator|)
condition|)
block|{
name|THR_GCLIST_REMOVE
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 			 * The thread has detached and is no longer 			 * referenced.  It is safe to remove all 			 * remnants of the thread. 			 */
name|THR_LIST_REMOVE
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|worklist
argument_list|,
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
block|}
block|}
name|THREAD_LIST_UNLOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|worklist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|worklist
argument_list|,
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
comment|/* 		 * XXX we don't free initial thread, because there might 		 * have some code referencing initial thread. 		 */
if|if
condition|(
name|td
operator|==
name|_thr_initial
condition|)
block|{
name|DBG_MSG
argument_list|(
literal|"Initial thread won't be freed\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|_thr_free
argument_list|(
name|curthread
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|pthread
modifier|*
name|_thr_alloc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|thread
init|=
name|NULL
decl_stmt|;
name|struct
name|tcb
modifier|*
name|tcb
decl_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|GC_NEEDED
argument_list|()
condition|)
name|_thr_gc
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_thread_count
operator|>
literal|0
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|free_thread_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_threadq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|free_thread_count
operator|--
expr_stmt|;
block|}
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|free_thread_lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|thread
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|total_threads
operator|>
name|MAX_THREADS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|atomic_fetchadd_int
argument_list|(
operator|&
name|total_threads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thread
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pthread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|==
name|NULL
condition|)
block|{
name|atomic_fetchadd_int
argument_list|(
operator|&
name|total_threads
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|tcb_lock
argument_list|)
expr_stmt|;
name|tcb
operator|=
name|_tcb_ctor
argument_list|(
name|thread
argument_list|,
literal|0
comment|/* not initial tls */
argument_list|)
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|tcb_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcb
operator|=
name|_tcb_ctor
argument_list|(
name|thread
argument_list|,
literal|1
comment|/* initial tls */
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcb
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|thread
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|tcb
operator|=
name|tcb
expr_stmt|;
block|}
else|else
block|{
name|thr_destroy
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|atomic_fetchadd_int
argument_list|(
operator|&
name|total_threads
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|thread
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|thread
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_thr_free
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|DBG_MSG
argument_list|(
literal|"Freeing thread %p\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
comment|/* 	 * Always free tcb, as we only know it is part of RTLD TLS 	 * block, but don't know its detail and can not assume how 	 * it works, so better to avoid caching it here. 	 */
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|tcb_lock
argument_list|)
expr_stmt|;
name|_tcb_dtor
argument_list|(
name|thread
operator|->
name|tcb
argument_list|)
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|tcb_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_tcb_dtor
argument_list|(
name|thread
operator|->
name|tcb
argument_list|)
expr_stmt|;
block|}
name|thread
operator|->
name|tcb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|==
name|NULL
operator|)
operator|||
operator|(
name|free_thread_count
operator|>=
name|MAX_CACHED_THREADS
operator|)
condition|)
block|{
name|thr_destroy
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|atomic_fetchadd_int
argument_list|(
operator|&
name|total_threads
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Add the thread to the free thread list, this also avoids 		 * pthread id is reused too quickly, may help some buggy apps. 		 */
name|THR_LOCK_ACQUIRE
argument_list|(
name|curthread
argument_list|,
operator|&
name|free_thread_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|free_thread_count
operator|++
expr_stmt|;
name|THR_LOCK_RELEASE
argument_list|(
name|curthread
argument_list|,
operator|&
name|free_thread_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thr_destroy
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
name|__unused
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the thread to the list of all threads and increment  * number of active threads.  */
end_comment

begin_function
name|void
name|_thr_link
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|THREAD_LIST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|THR_LIST_ADD
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|_thread_active_threads
operator|++
expr_stmt|;
name|THREAD_LIST_UNLOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an active thread.  */
end_comment

begin_function
name|void
name|_thr_unlink
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|THREAD_LIST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|THR_LIST_REMOVE
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|_thread_active_threads
operator|--
expr_stmt|;
name|THREAD_LIST_UNLOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_hash_add
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|thread_hash_head
modifier|*
name|head
decl_stmt|;
name|head
operator|=
operator|&
name|thr_hashtable
index|[
name|THREAD_HASH
argument_list|(
name|thread
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|thread
argument_list|,
name|hle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_hash_remove
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|thread
argument_list|,
name|hle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pthread
modifier|*
name|_thr_hash_find
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|td
decl_stmt|;
name|struct
name|thread_hash_head
modifier|*
name|head
decl_stmt|;
name|head
operator|=
operator|&
name|thr_hashtable
index|[
name|THREAD_HASH
argument_list|(
name|thread
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|td
argument_list|,
argument|head
argument_list|,
argument|hle
argument_list|)
block|{
if|if
condition|(
name|td
operator|==
name|thread
condition|)
return|return
operator|(
name|thread
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a thread in the linked list of active threads and add a reference  * to it.  Threads with positive reference counts will not be deallocated  * until all references are released.  */
end_comment

begin_function
name|int
name|_thr_ref_add
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|int
name|include_dead
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|thread
operator|==
name|NULL
condition|)
comment|/* Invalid thread: */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|THREAD_LIST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|_thr_find_thread
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|,
name|include_dead
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|thread
operator|->
name|refcount
operator|++
expr_stmt|;
name|THR_CRITICAL_ENTER
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
name|THREAD_LIST_UNLOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Return zero if the thread exists: */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_thr_ref_delete
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|THREAD_LIST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|_thr_ref_delete_unlocked
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|THREAD_LIST_UNLOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_ref_delete_unlocked
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
if|if
condition|(
name|thread
operator|!=
name|NULL
condition|)
block|{
name|thread
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|->
name|refcount
operator|==
literal|0
operator|)
operator|&&
name|thread
operator|->
name|state
operator|==
name|PS_DEAD
operator|&&
operator|(
name|thread
operator|->
name|tlflags
operator|&
name|TLFLAGS_DETACHED
operator|)
operator|!=
literal|0
condition|)
name|THR_GCLIST_ADD
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|THR_CRITICAL_LEAVE
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|_thr_find_thread
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
name|__unused
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|int
name|include_dead
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|pthread
decl_stmt|;
if|if
condition|(
name|thread
operator|==
name|NULL
condition|)
comment|/* Invalid thread: */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pthread
operator|=
name|_thr_hash_find
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread
condition|)
block|{
if|if
condition|(
name|include_dead
operator|==
literal|0
operator|&&
name|pthread
operator|->
name|state
operator|==
name|PS_DEAD
condition|)
block|{
name|pthread
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Return zero if the thread exists: */
return|return
operator|(
operator|(
name|pthread
operator|!=
name|NULL
operator|)
condition|?
literal|0
else|:
name|ESRCH
operator|)
return|;
block|}
end_function

end_unit

