begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright (c) 2012 DEY Storage Systems, Inc.  All rights reserved.  * Copyright (c) 2011-2012 Pawel Jakub Dawidek. All rights reserved.  * Copyright (c) 2013 Martin Matuska. All rights reserved.  * Copyright (c) 2013 Steven Hartland. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2016 Nexenta Systems, Inc.  * Copyright 2016 Igor Kozhukhov<ikozhukhov@gmail.com>  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<zone.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<priv.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<ucred.h>
end_include

begin_include
include|#
directive|include
file|<idmap.h>
end_include

begin_include
include|#
directive|include
file|<aclutils.h>
end_include

begin_include
include|#
directive|include
file|<directory.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|"zfs_deleg.h"
end_include

begin_function_decl
specifier|static
name|int
name|userquota_propname_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|boolean_t
name|zoned
parameter_list|,
name|zfs_userquota_prop_t
modifier|*
name|typep
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|int
name|domainlen
parameter_list|,
name|uint64_t
modifier|*
name|ridp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Given a single type (not a mask of types), return the type in a human  * readable form.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_type_to_name
parameter_list|(
name|zfs_type_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_TYPE_FILESYSTEM
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"filesystem"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_VOLUME
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_POOL
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool"
argument_list|)
operator|)
return|;
case|case
name|ZFS_TYPE_BOOKMARK
case|:
return|return
operator|(
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"bookmark"
argument_list|)
operator|)
return|;
default|default:
name|assert
argument_list|(
operator|!
literal|"unhandled zfs_type_t"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate a ZFS path.  This is used even before trying to open the dataset, to  * provide a more meaningful error message.  We call zfs_error_aux() to  * explain exactly why the name was not valid.  */
end_comment

begin_function
name|int
name|zfs_validate_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|type
parameter_list|,
name|boolean_t
name|modifying
parameter_list|)
block|{
name|namecheck_err_t
name|why
decl_stmt|;
name|char
name|what
decl_stmt|;
operator|(
name|void
operator|)
name|zfs_prop_get_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataset_namecheck
argument_list|(
name|path
argument_list|,
operator|&
name|why
argument_list|,
operator|&
name|what
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is too long"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"leading slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_EMPTY_COMPONENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"empty component in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TRAILING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"trailing slash in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_INVALCHAR
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character "
literal|"'%c' in name"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_MULTIPLE_AT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"multiple '@' delimiters in name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_NOLETTER
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool doesn't begin with a letter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_RESERVED
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"name is reserved"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_DISKLIKE
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"reserved disk name"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"(%d) not defined"
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|type
operator|&
name|ZFS_TYPE_SNAPSHOT
operator|)
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot delimiter '@' in filesystem name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing '@' delimiter in snapshot name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|modifying
operator|&&
name|strchr
argument_list|(
name|path
argument_list|,
literal|'%'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|!=
name|NULL
condition|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid character %c in name"
argument_list|)
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_name_valid
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|zfs_type_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_POOL
condition|)
return|return
operator|(
name|zpool_name_valid
argument_list|(
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|name
argument_list|)
operator|)
return|;
return|return
operator|(
name|zfs_validate_name
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function takes the raw DSL properties, and filters out the user-defined  * properties into a separate nvlist.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|process_user_props
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
continue|continue;
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|nvl
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|nvl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zpool_handle_t
modifier|*
name|zpool_add_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|pool_name
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zph
decl_stmt|;
if|if
condition|(
operator|(
name|zph
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|pool_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hdl
operator|->
name|libzfs_pool_handles
operator|!=
name|NULL
condition|)
name|zph
operator|->
name|zpool_next
operator|=
name|hdl
operator|->
name|libzfs_pool_handles
expr_stmt|;
name|hdl
operator|->
name|libzfs_pool_handles
operator|=
name|zph
expr_stmt|;
block|}
return|return
operator|(
name|zph
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zpool_handle_t
modifier|*
name|zpool_find_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|pool_name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zph
init|=
name|hdl
operator|->
name|libzfs_pool_handles
decl_stmt|;
while|while
condition|(
operator|(
name|zph
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|pool_name
argument_list|,
name|zpool_get_name
argument_list|(
name|zph
argument_list|)
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|zph
operator|=
name|zph
operator|->
name|zpool_next
expr_stmt|;
return|return
operator|(
name|zph
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a handle to the pool that contains the provided dataset.  * If a handle to that pool already exists then that handle is returned.  * Otherwise, a new handle is created and added to the list of handles.  */
end_comment

begin_function
specifier|static
name|zpool_handle_t
modifier|*
name|zpool_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|char
modifier|*
name|pool_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zph
decl_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|"/@#"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|pool_name
operator|=
name|zfs_alloc
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|zph
operator|=
name|zpool_find_handle
argument_list|(
name|zhp
argument_list|,
name|pool_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|zph
operator|==
name|NULL
condition|)
name|zph
operator|=
name|zpool_add_handle
argument_list|(
name|zhp
argument_list|,
name|pool_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pool_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zph
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zpool_free_handles
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|zph
init|=
name|hdl
operator|->
name|libzfs_pool_handles
decl_stmt|;
while|while
condition|(
name|zph
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|zph
operator|->
name|zpool_next
expr_stmt|;
name|zpool_close
argument_list|(
name|zph
argument_list|)
expr_stmt|;
name|zph
operator|=
name|next
expr_stmt|;
block|}
name|hdl
operator|->
name|libzfs_pool_handles
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utility function to gather stats (objset and zpl) for the given object.  */
end_comment

begin_function
specifier|static
name|int
name|get_stats_ioctl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|->
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|->
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to get the received properties of the given object.  */
end_comment

begin_function
specifier|static
name|int
name|get_recvd_props_ioctl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|recvdprops
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_RECVD_PROPS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|err
operator|=
name|zcmd_read_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|recvdprops
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_recvd_props
argument_list|)
expr_stmt|;
name|zhp
operator|->
name|zfs_recvd_props
operator|=
name|recvdprops
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|put_stats_zhdl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|allprops
decl_stmt|,
modifier|*
name|userprops
decl_stmt|;
name|zhp
operator|->
name|zfs_dmustats
operator|=
name|zc
operator|->
name|zc_objset_stats
expr_stmt|;
comment|/* structure assignment */
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zc
argument_list|,
operator|&
name|allprops
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * XXX Why do we store the user props separately, in addition to 	 * storing them in zfs_props? 	 */
if|if
condition|(
operator|(
name|userprops
operator|=
name|process_user_props
argument_list|(
name|zhp
argument_list|,
name|allprops
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|allprops
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_user_props
argument_list|)
expr_stmt|;
name|zhp
operator|->
name|zfs_props
operator|=
name|allprops
expr_stmt|;
name|zhp
operator|->
name|zfs_user_props
operator|=
name|userprops
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_stats
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|get_stats_ioctl
argument_list|(
name|zhp
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|put_stats_zhdl
argument_list|(
name|zhp
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Refresh the properties currently stored in the handle.  */
end_comment

begin_function
name|void
name|zfs_refresh_properties
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Makes a handle from the given dataset name.  Used by zfs_open() and  * zfs_iter_* to create child handles on the fly.  */
end_comment

begin_function
specifier|static
name|int
name|make_dataset_handle_common
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
if|if
condition|(
name|put_stats_zhdl
argument_list|(
name|zhp
argument_list|,
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * We've managed to open the dataset and gather statistics.  Determine 	 * the high-level type. 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
name|zhp
operator|->
name|zfs_head_type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZFS
condition|)
name|zhp
operator|->
name|zfs_head_type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_is_snapshot
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZVOL
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_type
operator|==
name|DMU_OST_ZFS
condition|)
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* we should never see any other types */
if|if
condition|(
operator|(
name|zhp
operator|->
name|zpool_hdl
operator|=
name|zpool_handle
argument_list|(
name|zhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|zfs_handle_t
modifier|*
name|make_dataset_handle
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zfs_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|get_stats_ioctl
argument_list|(
name|zhp
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|make_dataset_handle_common
argument_list|(
name|zhp
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zhp
operator|=
name|NULL
expr_stmt|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_function
name|zfs_handle_t
modifier|*
name|make_dataset_handle_zc
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zfs_hdl
operator|=
name|hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|zc
operator|->
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_dataset_handle_common
argument_list|(
name|zhp
argument_list|,
name|zc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_function
name|zfs_handle_t
modifier|*
name|make_dataset_simple_handle_zc
parameter_list|(
name|zfs_handle_t
modifier|*
name|pzhp
parameter_list|,
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zfs_hdl
operator|=
name|pzhp
operator|->
name|zfs_hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|zc
operator|->
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
name|zhp
operator|->
name|zfs_head_type
operator|=
name|pzhp
operator|->
name|zfs_type
expr_stmt|;
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|zpool_handle
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_function
name|zfs_handle_t
modifier|*
name|zfs_handle_dup
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp_orig
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zhp
operator|->
name|zfs_hdl
operator|=
name|zhp_orig
operator|->
name|zfs_hdl
expr_stmt|;
name|zhp
operator|->
name|zpool_hdl
operator|=
name|zhp_orig
operator|->
name|zpool_hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|zhp_orig
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
name|zhp
operator|->
name|zfs_type
operator|=
name|zhp_orig
operator|->
name|zfs_type
expr_stmt|;
name|zhp
operator|->
name|zfs_head_type
operator|=
name|zhp_orig
operator|->
name|zfs_head_type
expr_stmt|;
name|zhp
operator|->
name|zfs_dmustats
operator|=
name|zhp_orig
operator|->
name|zfs_dmustats
expr_stmt|;
if|if
condition|(
name|zhp_orig
operator|->
name|zfs_props
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_dup
argument_list|(
name|zhp_orig
operator|->
name|zfs_props
argument_list|,
operator|&
name|zhp
operator|->
name|zfs_props
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zhp_orig
operator|->
name|zfs_user_props
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_dup
argument_list|(
name|zhp_orig
operator|->
name|zfs_user_props
argument_list|,
operator|&
name|zhp
operator|->
name|zfs_user_props
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zhp_orig
operator|->
name|zfs_recvd_props
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_dup
argument_list|(
name|zhp_orig
operator|->
name|zfs_recvd_props
argument_list|,
operator|&
name|zhp
operator|->
name|zfs_recvd_props
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|zhp
operator|->
name|zfs_mntcheck
operator|=
name|zhp_orig
operator|->
name|zfs_mntcheck
expr_stmt|;
if|if
condition|(
name|zhp_orig
operator|->
name|zfs_mntopts
operator|!=
name|NULL
condition|)
block|{
name|zhp
operator|->
name|zfs_mntopts
operator|=
name|zfs_strdup
argument_list|(
name|zhp_orig
operator|->
name|zfs_hdl
argument_list|,
name|zhp_orig
operator|->
name|zfs_mntopts
argument_list|)
expr_stmt|;
block|}
name|zhp
operator|->
name|zfs_props_table
operator|=
name|zhp_orig
operator|->
name|zfs_props_table
expr_stmt|;
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|zfs_bookmark_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|bmarks
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|char
name|fsname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|bmark_name
decl_stmt|;
name|char
modifier|*
name|pound
decl_stmt|;
name|int
name|err
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fsname
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
name|pound
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pound
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
operator|*
name|pound
operator|=
literal|'\0'
expr_stmt|;
name|bmark_name
operator|=
name|pound
operator|+
literal|1
expr_stmt|;
name|props
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|err
operator|=
name|lzc_get_bookmarks
argument_list|(
name|fsname
argument_list|,
name|props
argument_list|,
operator|&
name|bmarks
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|bmarks
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
name|rv
operator|=
name|nvlist_exists
argument_list|(
name|bmarks
argument_list|,
name|bmark_name
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|bmarks
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|zfs_handle_t
modifier|*
name|make_bookmark_handle
parameter_list|(
name|zfs_handle_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|nvlist_t
modifier|*
name|bmark_props
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_handle_t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Fill in the name. */
name|zhp
operator|->
name|zfs_hdl
operator|=
name|parent
operator|->
name|zfs_hdl
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the property lists. */
if|if
condition|(
name|nvlist_dup
argument_list|(
name|bmark_props
argument_list|,
operator|&
name|zhp
operator|->
name|zfs_props
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Set the types. */
name|zhp
operator|->
name|zfs_head_type
operator|=
name|parent
operator|->
name|zfs_head_type
expr_stmt|;
name|zhp
operator|->
name|zfs_type
operator|=
name|ZFS_TYPE_BOOKMARK
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|->
name|zpool_hdl
operator|=
name|zpool_handle
argument_list|(
name|zhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Opens the given snapshot, filesystem, or volume.   The 'types'  * argument is a mask of acceptable types.  The function will print an  * appropriate error message and return NULL if it can't be opened.  */
end_comment

begin_function
name|zfs_handle_t
modifier|*
name|zfs_open
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|types
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the name before we even try to open it. 	 */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid dataset name"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Try to get stats for the dataset, which will tell us if it exists. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|types
operator|&
name|zhp
operator|->
name|zfs_type
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|zhp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a ZFS handle.  Nothing to do but free the associated memory.  */
end_comment

begin_function
name|void
name|zfs_close
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
condition|)
name|free
argument_list|(
name|zhp
operator|->
name|zfs_mntopts
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_user_props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|zhp
operator|->
name|zfs_recvd_props
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|mnttab_node
block|{
name|struct
name|mnttab
name|mtn_mt
decl_stmt|;
name|avl_node_t
name|mtn_node
decl_stmt|;
block|}
name|mnttab_node_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|libzfs_mnttab_cache_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|mnttab_node_t
modifier|*
name|mtn1
init|=
name|arg1
decl_stmt|;
specifier|const
name|mnttab_node_t
modifier|*
name|mtn2
init|=
name|arg2
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|strcmp
argument_list|(
name|mtn1
operator|->
name|mtn_mt
operator|.
name|mnt_special
argument_list|,
name|mtn2
operator|->
name|mtn_mt
operator|.
name|mnt_special
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|rv
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|libzfs_mnttab_init
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|assert
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|,
name|libzfs_mnttab_cache_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|mnttab_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|mnttab_node_t
argument_list|,
name|mtn_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libzfs_mnttab_update
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|struct
name|mnttab
name|entry
decl_stmt|;
name|rewind
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|)
expr_stmt|;
while|while
condition|(
name|getmntent
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|,
operator|&
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mnttab_node_t
modifier|*
name|mtn
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|.
name|mnt_fstype
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|mtn
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|mnttab_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_special
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|entry
operator|.
name|mnt_special
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_mountp
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|entry
operator|.
name|mnt_mountp
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_fstype
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|entry
operator|.
name|mnt_fstype
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_mntopts
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|entry
operator|.
name|mnt_mntopts
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|,
name|mtn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|libzfs_mnttab_fini
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|mnttab_node_t
modifier|*
name|mtn
decl_stmt|;
while|while
condition|(
operator|(
name|mtn
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_special
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_fstype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_mntopts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mtn
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libzfs_mnttab_cache
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|enable
parameter_list|)
block|{
name|hdl
operator|->
name|libzfs_mnttab_enable
operator|=
name|enable
expr_stmt|;
block|}
end_function

begin_function
name|int
name|libzfs_mnttab_find
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
name|struct
name|mnttab
modifier|*
name|entry
parameter_list|)
block|{
name|mnttab_node_t
name|find
decl_stmt|;
name|mnttab_node_t
modifier|*
name|mtn
decl_stmt|;
if|if
condition|(
operator|!
name|hdl
operator|->
name|libzfs_mnttab_enable
condition|)
block|{
name|struct
name|mnttab
name|srch
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|)
condition|)
name|libzfs_mnttab_fini
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|)
expr_stmt|;
name|srch
operator|.
name|mnt_special
operator|=
operator|(
name|char
operator|*
operator|)
name|fsname
expr_stmt|;
name|srch
operator|.
name|mnt_fstype
operator|=
name|MNTTYPE_ZFS
expr_stmt|;
if|if
condition|(
name|getmntany
argument_list|(
name|hdl
operator|->
name|libzfs_mnttab
argument_list|,
name|entry
argument_list|,
operator|&
name|srch
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|)
operator|==
literal|0
condition|)
name|libzfs_mnttab_update
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|find
operator|.
name|mtn_mt
operator|.
name|mnt_special
operator|=
operator|(
name|char
operator|*
operator|)
name|fsname
expr_stmt|;
name|mtn
operator|=
name|avl_find
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|,
operator|&
name|find
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtn
condition|)
block|{
operator|*
name|entry
operator|=
name|mtn
operator|->
name|mtn_mt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|libzfs_mnttab_add
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|special
parameter_list|,
specifier|const
name|char
modifier|*
name|mountp
parameter_list|,
specifier|const
name|char
modifier|*
name|mntopts
parameter_list|)
block|{
name|mnttab_node_t
modifier|*
name|mtn
decl_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|mtn
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|mnttab_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_special
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|special
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_mountp
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|mountp
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_fstype
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|MNTTYPE_ZFS
argument_list|)
expr_stmt|;
name|mtn
operator|->
name|mtn_mt
operator|.
name|mnt_mntopts
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|mntopts
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|,
name|mtn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libzfs_mnttab_remove
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fsname
parameter_list|)
block|{
name|mnttab_node_t
name|find
decl_stmt|;
name|mnttab_node_t
modifier|*
name|ret
decl_stmt|;
name|find
operator|.
name|mtn_mt
operator|.
name|mnt_special
operator|=
operator|(
name|char
operator|*
operator|)
name|fsname
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|avl_find
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|find
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|avl_remove
argument_list|(
operator|&
name|hdl
operator|->
name|libzfs_mnttab_cache
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
operator|->
name|mtn_mt
operator|.
name|mnt_special
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
operator|->
name|mtn_mt
operator|.
name|mnt_mountp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
operator|->
name|mtn_mt
operator|.
name|mnt_fstype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
operator|->
name|mtn_mt
operator|.
name|mnt_mntopts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|zfs_spa_version
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
modifier|*
name|spa_version
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zpool_handle
init|=
name|zhp
operator|->
name|zpool_hdl
decl_stmt|;
if|if
condition|(
name|zpool_handle
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|spa_version
operator|=
name|zpool_get_prop_int
argument_list|(
name|zpool_handle
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The choice of reservation property depends on the SPA version.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_which_resv_prop
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
modifier|*
name|resv_prop
parameter_list|)
block|{
name|int
name|spa_version
decl_stmt|;
if|if
condition|(
name|zfs_spa_version
argument_list|(
name|zhp
argument_list|,
operator|&
name|spa_version
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|spa_version
operator|>=
name|SPA_VERSION_REFRESERVATION
condition|)
operator|*
name|resv_prop
operator|=
name|ZFS_PROP_REFRESERVATION
expr_stmt|;
else|else
operator|*
name|resv_prop
operator|=
name|ZFS_PROP_RESERVATION
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an nvlist of properties to set, validates that they are correct, and  * parses any numeric properties (index, boolean, etc) if they are specified as  * strings.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|zfs_valid_proplist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_type_t
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|uint64_t
name|zoned
parameter_list|,
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zpool_handle_t
modifier|*
name|zpool_hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
decl_stmt|;
name|int
name|chosen_normal
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|chosen_utf
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|ret
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Make sure this property is valid and applies to this type. 	 */
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
operator|&&
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
comment|/* 			 * This is a user property: make sure it's a 			 * string, and that it's less than ZAP_MAXNAMELEN. 			 */
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|!=
name|DATA_TYPE_STRING
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a string"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|>=
name|ZAP_MAXNAMELEN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property name '%s' is too long"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|ret
argument_list|,
name|propname
argument_list|,
name|strval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
continue|continue;
block|}
comment|/* 		 * Currently, only user properties can be modified on 		 * snapshots. 		 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"this property can not be modified for snapshots"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
operator|&&
name|zfs_prop_userquota
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|zfs_userquota_prop_t
name|uqtype
decl_stmt|;
name|char
name|newpropname
index|[
literal|128
index|]
decl_stmt|;
name|char
name|domain
index|[
literal|128
index|]
decl_stmt|;
name|uint64_t
name|rid
decl_stmt|;
name|uint64_t
name|valary
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|userquota_propname_decode
argument_list|(
name|propname
argument_list|,
name|zoned
argument_list|,
operator|&
name|uqtype
argument_list|,
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|,
operator|&
name|rid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' has an invalid user/group name"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|uqtype
operator|!=
name|ZFS_PROP_USERQUOTA
operator|&&
name|uqtype
operator|!=
name|ZFS_PROP_GROUPQUOTA
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is readonly"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|==
name|DATA_TYPE_STRING
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|intval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_nicestrtonum
argument_list|(
name|hdl
argument_list|,
name|strval
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|intval
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"use 'none' to disable "
literal|"userquota/groupquota"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a number"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			 * Encode the prop name as 			 * userquota@<hex-rid>-domain, to make it easy 			 * for the kernel to decode. 			 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|newpropname
argument_list|,
sizeof|sizeof
argument_list|(
name|newpropname
argument_list|)
argument_list|,
literal|"%s%llx-%s"
argument_list|,
name|zfs_userquota_prop_prefixes
index|[
name|uqtype
index|]
argument_list|,
operator|(
name|longlong_t
operator|)
name|rid
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|valary
index|[
literal|0
index|]
operator|=
name|uqtype
expr_stmt|;
name|valary
index|[
literal|1
index|]
operator|=
name|rid
expr_stmt|;
name|valary
index|[
literal|2
index|]
operator|=
name|intval
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint64_array
argument_list|(
name|ret
argument_list|,
name|newpropname
argument_list|,
name|valary
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
operator|&&
name|zfs_prop_written
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is readonly"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' does not "
literal|"apply to datasets of this type"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
operator|&&
operator|(
operator|!
name|zfs_prop_setonce
argument_list|(
name|prop
argument_list|)
operator|||
name|zhp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is readonly"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zprop_parse_value
argument_list|(
name|hdl
argument_list|,
name|elem
argument_list|,
name|prop
argument_list|,
name|type
argument_list|,
name|ret
argument_list|,
operator|&
name|strval
argument_list|,
operator|&
name|intval
argument_list|,
name|errbuf
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Perform some additional checks for specific properties. 		 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_VERSION
case|:
block|{
name|int
name|version
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
break|break;
name|version
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|intval
operator|<
name|version
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Can not downgrade; already at version %u"
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
case|case
name|ZFS_PROP_VOLBLOCKSIZE
case|:
case|case
name|ZFS_PROP_RECORDSIZE
case|:
block|{
name|int
name|maxbs
init|=
name|SPA_MAXBLOCKSIZE
decl_stmt|;
if|if
condition|(
name|zpool_hdl
operator|!=
name|NULL
condition|)
block|{
name|maxbs
operator|=
name|zpool_get_prop_int
argument_list|(
name|zpool_hdl
argument_list|,
name|ZPOOL_PROP_MAXBLOCKSIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Volumes are limited to a volblocksize of 128KB, 			 * because they typically service workloads with 			 * small random writes, which incur a large performance 			 * penalty with large blocks. 			 */
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VOLBLOCKSIZE
condition|)
name|maxbs
operator|=
name|SPA_OLD_MAXBLOCKSIZE
expr_stmt|;
comment|/* 			 * The value must be a power of two between 			 * SPA_MINBLOCKSIZE and maxbs. 			 */
if|if
condition|(
name|intval
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|intval
operator|>
name|maxbs
operator|||
operator|!
name|ISP2
argument_list|(
name|intval
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be power of 2 from 512B "
literal|"to %uKB"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|maxbs
operator|>>
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
case|case
name|ZFS_PROP_MLSLABEL
case|:
block|{
comment|/* 			 * Verify the mlslabel string and convert to 			 * internal hex label string. 			 */
name|m_label_t
modifier|*
name|new_sl
decl_stmt|;
name|char
modifier|*
name|hex
init|=
name|NULL
decl_stmt|;
comment|/* internal label string */
comment|/* Default value is already OK. */
if|if
condition|(
name|strcasecmp
argument_list|(
name|strval
argument_list|,
name|ZFS_MLSLABEL_DEFAULT
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Verify the label can be converted to binary form */
if|if
condition|(
operator|(
operator|(
name|new_sl
operator|=
name|m_label_alloc
argument_list|(
name|MAC_LABEL
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|str_to_label
argument_list|(
name|strval
argument_list|,
operator|&
name|new_sl
argument_list|,
name|MAC_LABEL
argument_list|,
name|L_NO_CORRECTION
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
goto|goto
name|badlabel
goto|;
block|}
comment|/* Now translate to hex internal label string */
if|if
condition|(
name|label_to_str
argument_list|(
name|new_sl
argument_list|,
operator|&
name|hex
argument_list|,
name|M_INTERNAL
argument_list|,
name|DEF_NAMES
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hex
condition|)
name|free
argument_list|(
name|hex
argument_list|)
expr_stmt|;
goto|goto
name|badlabel
goto|;
block|}
name|m_label_free
argument_list|(
name|new_sl
argument_list|)
expr_stmt|;
comment|/* If string is already in internal form, we're done. */
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
name|hex
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|hex
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Replace the label string with the internal form. */
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|DATA_TYPE_STRING
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|hex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hex
argument_list|)
expr_stmt|;
break|break;
name|badlabel
label|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid mlslabel '%s'"
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|m_label_free
argument_list|(
name|new_sl
argument_list|)
expr_stmt|;
comment|/* OK if null */
goto|goto
name|error
goto|;
block|}
case|case
name|ZFS_PROP_MOUNTPOINT
case|:
block|{
name|namecheck_err_t
name|why
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
name|ZFS_MOUNTPOINT_NONE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|strval
argument_list|,
name|ZFS_MOUNTPOINT_LEGACY
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mountpoint_namecheck
argument_list|(
name|strval
argument_list|,
operator|&
name|why
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|NAME_ERR_LEADING_SLASH
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be an absolute path, "
literal|"'none', or 'legacy'"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME_ERR_TOOLONG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"component of '%s' is too long"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"(%d) not defined"
argument_list|)
argument_list|,
name|why
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/*FALLTHRU*/
case|case
name|ZFS_PROP_SHARESMB
case|:
case|case
name|ZFS_PROP_SHARENFS
case|:
comment|/* 			 * For the mountpoint and sharenfs or sharesmb 			 * properties, check if it can be set in a 			 * global/non-global zone based on 			 * the zoned property value: 			 * 			 *		global zone	    non-global zone 			 * -------------------------------------------------- 			 * zoned=on	mountpoint (no)	    mountpoint (yes) 			 *		sharenfs (no)	    sharenfs (no) 			 *		sharesmb (no)	    sharesmb (no) 			 * 			 * zoned=off	mountpoint (yes)	N/A 			 *		sharenfs (yes) 			 *		sharesmb (yes) 			 */
if|if
condition|(
name|zoned
condition|)
block|{
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set on "
literal|"dataset in a non-global zone"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_SHARENFS
operator|||
name|prop
operator|==
name|ZFS_PROP_SHARESMB
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set in "
literal|"a non-global zone"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
condition|)
block|{
comment|/* 				 * If zoned property is 'off', this must be in 				 * a global zone. If not, something is wrong. 				 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set while dataset "
literal|"'zoned' property is set"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 			 * At this point, it is legitimate to set the 			 * property. Now we want to make sure that the 			 * property value is valid if it is sharenfs. 			 */
if|if
condition|(
operator|(
name|prop
operator|==
name|ZFS_PROP_SHARENFS
operator|||
name|prop
operator|==
name|ZFS_PROP_SHARESMB
operator|)
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"on"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"off"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_share_proto_t
name|proto
decl_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_SHARESMB
condition|)
name|proto
operator|=
name|PROTO_SMB
expr_stmt|;
else|else
name|proto
operator|=
name|PROTO_NFS
expr_stmt|;
comment|/* 				 * Must be an valid sharing protocol 				 * option string so init the libshare 				 * in order to enable the parser and 				 * then parse the options. We use the 				 * control API since we don't care about 				 * the current configuration and don't 				 * want the overhead of loading it 				 * until we actually do something. 				 */
if|if
condition|(
name|zfs_init_libshare
argument_list|(
name|hdl
argument_list|,
name|SA_INIT_CONTROL_API
argument_list|)
operator|!=
name|SA_OK
condition|)
block|{
comment|/* 					 * An error occurred so we can't do 					 * anything 					 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set: problem "
literal|"in share initialization"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|zfs_parse_options
argument_list|(
name|strval
argument_list|,
name|proto
argument_list|)
operator|!=
name|SA_OK
condition|)
block|{
comment|/* 					 * There was an error in parsing so 					 * deal with it by issuing an error 					 * message and leaving after 					 * uninitializing the the libshare 					 * interface. 					 */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be set to invalid "
literal|"options"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_uninit_libshare
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|zfs_uninit_libshare
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_UTF8ONLY
case|:
name|chosen_utf
operator|=
operator|(
name|int
operator|)
name|intval
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NORMALIZE
case|:
name|chosen_normal
operator|=
operator|(
name|int
operator|)
name|intval
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 		 * For changes to existing volumes, we have some additional 		 * checks to enforce. 		 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
operator|&&
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|volsize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
if|if
condition|(
name|intval
operator|>
name|volsize
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is greater than current "
literal|"volume size"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|ZFS_PROP_VOLSIZE
case|:
if|if
condition|(
name|intval
operator|%
name|blocksize
operator|!=
literal|0
condition|)
block|{
name|zfs_nicenum
argument_list|(
name|blocksize
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be a multiple of "
literal|"volume block size (%s)"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|intval
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' cannot be zero"
argument_list|)
argument_list|,
name|propname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
comment|/* 	 * If normalization was chosen, but no UTF8 choice was made, 	 * enforce rejection of non-UTF8 names. 	 * 	 * If normalization was chosen, but rejecting non-UTF8 names 	 * was explicitly not chosen, it is an error. 	 */
if|if
condition|(
name|chosen_normal
operator|>
literal|0
operator|&&
name|chosen_utf
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|ret
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_UTF8ONLY
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|chosen_normal
operator|>
literal|0
operator|&&
name|chosen_utf
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' must be set 'on' if normalization chosen"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_UTF8ONLY
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|error
label|:
name|nvlist_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_add_synthetic_resv
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|uint64_t
name|old_volsize
decl_stmt|;
name|uint64_t
name|new_volsize
decl_stmt|;
name|uint64_t
name|old_reservation
decl_stmt|;
name|uint64_t
name|new_reservation
decl_stmt|;
name|zfs_prop_t
name|resv_prop
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
comment|/* 	 * If this is an existing volume, and someone is setting the volsize, 	 * make sure that it matches the reservation, or add it if necessary. 	 */
name|old_volsize
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_which_resv_prop
argument_list|(
name|zhp
argument_list|,
operator|&
name|resv_prop
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|old_reservation
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|resv_prop
argument_list|)
expr_stmt|;
name|props
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zvol_volsize_to_reservation
argument_list|(
name|old_volsize
argument_list|,
name|props
argument_list|)
operator|!=
name|old_reservation
operator|)
operator|||
name|nvlist_exists
argument_list|(
name|nvl
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|)
condition|)
block|{
name|fnvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nvl
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|new_volsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fnvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|new_reservation
operator|=
name|zvol_volsize_to_reservation
argument_list|(
name|new_volsize
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nvl
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|resv_prop
argument_list|)
argument_list|,
name|new_reservation
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_setprop_error
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|int
name|err
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|ENOSPC
case|:
comment|/* 		 * For quotas and reservations, ENOSPC indicates 		 * something different; setting a quota or reservation 		 * doesn't use any disk space. 		 */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_REFQUOTA
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"size is less than current used or "
literal|"reserved space"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPSPACE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"size is greater than available space"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPSPACE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|err
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EBUSY
case|:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|EBUSY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_DSREADONLY
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|E2BIG
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property value too long"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool and or dataset must be upgraded to set this "
literal|"property or value"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ERANGE
case|:
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_COMPRESSION
operator|||
name|prop
operator|==
name|ZFS_PROP_RECORDSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property setting is not allowed on "
literal|"bootable datasets"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOTSUP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_CHECKSUM
operator|||
name|prop
operator|==
name|ZFS_PROP_DEDUP
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"property setting is not allowed on "
literal|"root pools"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOTSUP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|err
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EINVAL
case|:
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|err
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EOVERFLOW
case|:
comment|/* 		 * This platform can't address a volume this big. 		 */
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VOLSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLTOOBIG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* FALLTHROUGH */
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|err
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a property name and value, set the property for the given dataset.  */
end_comment

begin_function
name|int
name|zfs_prop_set
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|propval
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set property for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|zfs_prop_set_list
argument_list|(
name|zhp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
name|error
label|:
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an nvlist of property names and values, set the properties for the  * given dataset.  */
end_comment

begin_function
name|int
name|zfs_prop_set_list
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|prop_changelist_t
modifier|*
modifier|*
name|cls
init|=
name|NULL
decl_stmt|;
name|int
name|cl_idx
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|int
name|nvl_len
decl_stmt|;
name|int
name|added_resv
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set property for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nvl
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|,
name|props
argument_list|,
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
name|zhp
argument_list|,
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
comment|/* 	 * We have to check for any extra properties which need to be added 	 * before computing the length of the nvlist. 	 */
for|for
control|(
name|nvpair_t
modifier|*
name|elem
init|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
control|)
block|{
if|if
condition|(
name|zfs_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|==
name|ZFS_PROP_VOLSIZE
operator|&&
operator|(
name|added_resv
operator|=
name|zfs_add_synthetic_resv
argument_list|(
name|zhp
argument_list|,
name|nvl
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
comment|/* 	 * Check how many properties we're setting and allocate an array to 	 * store changelist pointers for postfix(). 	 */
name|nvl_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nvpair_t
modifier|*
name|elem
init|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
control|)
name|nvl_len
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cls
operator|=
name|calloc
argument_list|(
name|nvl_len
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_changelist_t
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|cl_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nvpair_t
modifier|*
name|elem
init|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
control|)
block|{
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|cl_idx
operator|<
name|nvl_len
argument_list|)
expr_stmt|;
comment|/* 		 * We don't want to unmount& remount the dataset when changing 		 * its canmount property to 'on' or 'noauto'.  We only use 		 * the changelist logic to unmount when setting canmount=off. 		 */
if|if
condition|(
operator|!
operator|(
name|prop
operator|==
name|ZFS_PROP_CANMOUNT
operator|&&
name|fnvpair_value_uint64
argument_list|(
name|elem
argument_list|)
operator|!=
name|ZFS_CANMOUNT_OFF
operator|)
condition|)
block|{
name|cls
index|[
name|cl_idx
index|]
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cls
index|[
name|cl_idx
index|]
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|changelist_haszonedchild
argument_list|(
name|cls
index|[
name|cl_idx
index|]
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|cls
index|[
name|cl_idx
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cls
index|[
name|cl_idx
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
name|cl_idx
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|cl_idx
operator|==
name|nvl_len
argument_list|)
expr_stmt|;
comment|/* 	 * Execute the corresponding ioctl() to set this list of properties. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvl
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ret
operator|=
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* Get the list of unset properties back and report them. */
name|nvlist_t
modifier|*
name|errorprops
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|errorprops
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|nvpair_t
modifier|*
name|elem
init|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
control|)
block|{
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
decl_stmt|;
name|zfs_setprop_error
argument_list|(
name|hdl
argument_list|,
name|prop
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|errorprops
argument_list|)
expr_stmt|;
if|if
condition|(
name|added_resv
operator|&&
name|errno
operator|==
name|ENOSPC
condition|)
block|{
comment|/* clean up the volsize property we tried to set */
name|uint64_t
name|old_volsize
init|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
decl_stmt|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|NULL
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|nvl
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
name|old_volsize
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
operator|(
name|void
operator|)
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|cl_idx
operator|=
literal|0
init|;
name|cl_idx
operator|<
name|nvl_len
condition|;
name|cl_idx
operator|++
control|)
block|{
if|if
condition|(
name|cls
index|[
name|cl_idx
index|]
operator|!=
name|NULL
condition|)
block|{
name|int
name|clp_err
init|=
name|changelist_postfix
argument_list|(
name|cls
index|[
name|cl_idx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|clp_err
operator|!=
literal|0
condition|)
name|ret
operator|=
name|clp_err
expr_stmt|;
block|}
block|}
comment|/* 		 * Refresh the statistics so the new property value 		 * is reflected. 		 */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cls
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|cl_idx
operator|=
literal|0
init|;
name|cl_idx
operator|<
name|nvl_len
condition|;
name|cl_idx
operator|++
control|)
block|{
if|if
condition|(
name|cls
index|[
name|cl_idx
index|]
operator|!=
name|NULL
condition|)
name|changelist_free
argument_list|(
name|cls
index|[
name|cl_idx
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cls
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a property, inherit the value from the parent dataset, or if received  * is TRUE, revert to the received value, if any.  */
end_comment

begin_function
name|int
name|zfs_prop_inherit
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|boolean_t
name|received
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot inherit %s for '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|received
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
block|{
comment|/* 		 * For user properties, the amount of work we have to do is very 		 * small, so just do it here. 		 */
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid property"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_INHERIT_PROP
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Verify that this property is inheritable. 	 */
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPREADONLY
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
operator|&&
operator|!
name|received
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPNONINHERIT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* 	 * Check to see if the value applies to this type 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* 	 * Normalize the name, to get rid of shorthand abbreviations. 	 */
name|propname
operator|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|propname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is used in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Determine datasets which will be affected by this change, if any. 	 */
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_MOUNTPOINT
operator|&&
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_INHERIT_PROP
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* 		 * Refresh the statistics so the new property is reflected. 		 */
operator|(
name|void
operator|)
name|get_stats
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|error
label|:
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * True DSL properties are stored in an nvlist.  The following two functions  * extract them appropriately.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|getprop_uint64
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
operator|!
name|zhp
operator|->
name|zfs_props_table
operator|||
name|zhp
operator|->
name|zfs_props_table
index|[
name|prop
index|]
operator|==
name|B_TRUE
argument_list|)
expr_stmt|;
name|value
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|prop
argument_list|)
expr_stmt|;
operator|*
name|source
operator|=
literal|""
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getprop_string
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|fnvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|verify
argument_list|(
operator|!
name|zhp
operator|->
name|zfs_props_table
operator|||
name|zhp
operator|->
name|zfs_props_table
index|[
name|prop
index|]
operator|==
name|B_TRUE
argument_list|)
expr_stmt|;
name|value
operator|=
name|zfs_prop_default_string
argument_list|(
name|prop
argument_list|)
expr_stmt|;
operator|*
name|source
operator|=
literal|""
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zfs_is_recvd_props_mode
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_props
operator|==
name|zhp
operator|->
name|zfs_recvd_props
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_set_recvd_props_mode
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
modifier|*
name|cookie
parameter_list|)
block|{
operator|*
name|cookie
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|zhp
operator|->
name|zfs_props
expr_stmt|;
name|zhp
operator|->
name|zfs_props
operator|=
name|zhp
operator|->
name|zfs_recvd_props
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_unset_recvd_props_mode
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
modifier|*
name|cookie
parameter_list|)
block|{
name|zhp
operator|->
name|zfs_props
operator|=
operator|(
name|nvlist_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|*
name|cookie
expr_stmt|;
operator|*
name|cookie
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Internal function for getting a numeric property.  Both zfs_prop_get() and  * zfs_prop_get_int() are built using this interface.  *  * Certain properties can be overridden using 'mount -o'.  In this case, scan  * the contents of the /etc/mnttab entry, searching for the appropriate options.  * If they differ from the on-disk values, report the current values and mark  * the source "temporary".  */
end_comment

begin_function
specifier|static
name|int
name|get_numeric_property
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
modifier|*
name|source
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|zplprops
init|=
name|NULL
decl_stmt|;
name|struct
name|mnttab
name|mnt
decl_stmt|;
name|char
modifier|*
name|mntopt_on
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mntopt_off
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|received
init|=
name|zfs_is_recvd_props_mode
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
name|mntopt_on
operator|=
name|MNTOPT_ATIME
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOATIME
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_DEVICES
case|:
name|mntopt_on
operator|=
name|MNTOPT_DEVICES
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NODEVICES
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_EXEC
case|:
name|mntopt_on
operator|=
name|MNTOPT_EXEC
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOEXEC
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_READONLY
case|:
name|mntopt_on
operator|=
name|MNTOPT_RO
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_RW
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_SETUID
case|:
name|mntopt_on
operator|=
name|MNTOPT_SETUID
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOSETUID
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_XATTR
case|:
name|mntopt_on
operator|=
name|MNTOPT_XATTR
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NOXATTR
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NBMAND
case|:
name|mntopt_on
operator|=
name|MNTOPT_NBMAND
expr_stmt|;
name|mntopt_off
operator|=
name|MNTOPT_NONBMAND
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Because looking up the mount options is potentially expensive 	 * (iterating over all of /etc/mnttab), we defer its calculation until 	 * we're looking up a property which requires its presence. 	 */
if|if
condition|(
operator|!
name|zhp
operator|->
name|zfs_mntcheck
operator|&&
operator|(
name|mntopt_on
operator|!=
name|NULL
operator|||
name|prop
operator|==
name|ZFS_PROP_MOUNTED
operator|)
condition|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|struct
name|mnttab
name|entry
decl_stmt|;
if|if
condition|(
name|libzfs_mnttab_find
argument_list|(
name|hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
operator|&
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zhp
operator|->
name|zfs_mntopts
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|entry
operator|.
name|mnt_mntopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zhp
operator|->
name|zfs_mntcheck
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_mntopts
operator|==
name|NULL
condition|)
name|mnt
operator|.
name|mnt_mntopts
operator|=
literal|""
expr_stmt|;
else|else
name|mnt
operator|.
name|mnt_mntopts
operator|=
name|zhp
operator|->
name|zfs_mntopts
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
case|case
name|ZFS_PROP_DEVICES
case|:
case|case
name|ZFS_PROP_EXEC
case|:
case|case
name|ZFS_PROP_READONLY
case|:
case|case
name|ZFS_PROP_SETUID
case|:
case|case
name|ZFS_PROP_XATTR
case|:
case|case
name|ZFS_PROP_NBMAND
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|received
condition|)
break|break;
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|mntopt_on
argument_list|)
operator|&&
operator|!
operator|*
name|val
condition|)
block|{
operator|*
name|val
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_TEMPORARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hasmntopt
argument_list|(
operator|&
name|mnt
argument_list|,
name|mntopt_off
argument_list|)
operator|&&
operator|*
name|val
condition|)
block|{
operator|*
name|val
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_TEMPORARY
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_CANMOUNT
case|:
case|case
name|ZFS_PROP_VOLSIZE
case|:
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_REFQUOTA
case|:
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
case|case
name|ZFS_PROP_FILESYSTEM_LIMIT
case|:
case|case
name|ZFS_PROP_SNAPSHOT_LIMIT
case|:
case|case
name|ZFS_PROP_FILESYSTEM_COUNT
case|:
case|case
name|ZFS_PROP_SNAPSHOT_COUNT
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|source
operator|==
name|NULL
condition|)
block|{
comment|/* not default, must be local */
operator|*
name|source
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_MOUNTED
case|:
operator|*
name|val
operator|=
operator|(
name|zhp
operator|->
name|zfs_mntopts
operator|!=
name|NULL
operator|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NUMCLONES
case|:
operator|*
name|val
operator|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_num_clones
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_VERSION
case|:
case|case
name|ZFS_PROP_NORMALIZE
case|:
case|case
name|ZFS_PROP_UTF8ONLY
case|:
case|case
name|ZFS_PROP_CASE
case|:
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_head_type
argument_list|)
operator|||
name|zcmd_alloc_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_OBJSET_ZPLPROPS
argument_list|,
operator|&
name|zc
argument_list|)
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|zplprops
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|zplprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|val
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|zplprops
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_INCONSISTENT
case|:
operator|*
name|val
operator|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_inconsistent
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
condition|)
block|{
case|case
name|PROP_TYPE_NUMBER
case|:
case|case
name|PROP_TYPE_INDEX
case|:
operator|*
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|/* 			 * If we tried to use a default value for a 			 * readonly property, it means that it was not 			 * present. 			 */
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
operator|&&
operator|*
name|source
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|source
operator|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|source
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|PROP_TYPE_STRING
case|:
default|default:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get non-numeric property"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"internal error"
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the source type, given the raw source string.  */
end_comment

begin_function
specifier|static
name|void
name|get_source
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zprop_source_t
modifier|*
name|srctype
parameter_list|,
name|char
modifier|*
name|source
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|)
block|{
if|if
condition|(
name|statbuf
operator|==
name|NULL
operator|||
operator|*
name|srctype
operator|==
name|ZPROP_SRC_TEMPORARY
condition|)
return|return;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|source
argument_list|,
name|ZPROP_SOURCE_VAL_RECVD
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZPROP_SRC_RECEIVED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|srctype
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|statbuf
argument_list|,
name|source
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
operator|*
name|srctype
operator|=
name|ZPROP_SRC_INHERITED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|zfs_prop_get_recvd
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|size_t
name|proplen
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|zfs_prop_t
name|prop
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_recvd_props
operator|==
name|NULL
condition|)
if|if
condition|(
name|get_recvd_props_ioctl
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
name|uint64_t
name|cookie
decl_stmt|;
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|zhp
operator|->
name|zfs_recvd_props
argument_list|,
name|propname
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zfs_set_recvd_props_mode
argument_list|(
name|zhp
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|literal
argument_list|)
expr_stmt|;
name|zfs_unset_recvd_props_mode
argument_list|(
name|zhp
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|char
modifier|*
name|recvdval
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_recvd_props
argument_list|,
name|propname
argument_list|,
operator|&
name|propval
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|recvdval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|recvdval
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_clones_string
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|size_t
name|proplen
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|value
decl_stmt|;
name|nvpair_t
modifier|*
name|pair
decl_stmt|;
name|value
operator|=
name|zfs_get_clones_nvl
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|propbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|value
argument_list|,
name|pair
argument_list|)
control|)
block|{
if|if
condition|(
name|propbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|propbuf
argument_list|,
literal|","
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|propbuf
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|get_clones_arg
block|{
name|uint64_t
name|numclones
decl_stmt|;
name|nvlist_t
modifier|*
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|origin
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|get_clones_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|get_clones_arg
modifier|*
name|gca
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|gca
operator|->
name|numclones
operator|==
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ORIGIN
argument_list|,
name|gca
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|gca
operator|->
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|gca
operator|->
name|buf
argument_list|,
name|gca
operator|->
name|origin
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnvlist_add_boolean
argument_list|(
name|gca
operator|->
name|value
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|)
expr_stmt|;
name|gca
operator|->
name|numclones
operator|--
expr_stmt|;
block|}
name|out
label|:
operator|(
name|void
operator|)
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|get_clones_cb
argument_list|,
name|gca
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zfs_get_clones_nvl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
decl_stmt|,
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CLONES
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|get_clones_arg
name|gca
decl_stmt|;
comment|/* 		 * if this is a snapshot, then the kernel wasn't able 		 * to get the clones.  Do it by slowly iterating. 		 */
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|!=
name|ZFS_TYPE_SNAPSHOT
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|value
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gca
operator|.
name|numclones
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NUMCLONES
argument_list|)
expr_stmt|;
name|gca
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|gca
operator|.
name|origin
operator|=
name|zhp
operator|->
name|zfs_name
expr_stmt|;
if|if
condition|(
name|gca
operator|.
name|numclones
operator|!=
literal|0
condition|)
block|{
name|zfs_handle_t
modifier|*
name|root
decl_stmt|;
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|pool
decl_stmt|;
comment|/* get the pool name */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strsep
argument_list|(
operator|&
name|cp
argument_list|,
literal|"/@"
argument_list|)
expr_stmt|;
name|root
operator|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|pool
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_clones_cb
argument_list|(
name|root
argument_list|,
operator|&
name|gca
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gca
operator|.
name|numclones
operator|!=
literal|0
operator|||
name|nvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CLONES
argument_list|)
argument_list|,
name|nv
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|verify
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CLONES
argument_list|)
argument_list|,
operator|&
name|nv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|nv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a property from the given object.  If 'literal' is specified, then  * numbers are left as exact values.  Otherwise, numbers are converted to a  * human-readable form.  *  * Returns 0 on success, or -1 on error.  */
end_comment

begin_function
name|int
name|zfs_prop_get
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|size_t
name|proplen
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|char
modifier|*
name|source
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|strval
decl_stmt|;
name|boolean_t
name|received
init|=
name|zfs_is_recvd_props_mode
argument_list|(
name|zhp
argument_list|)
decl_stmt|;
comment|/* 	 * Check to see if this property applies to our object 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|received
operator|&&
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_CREATION
case|:
comment|/* 		 * 'creation' is a time_t stored in the statistics.  We convert 		 * this into a string unless 'literal' is specified. 		 */
block|{
name|val
operator|=
name|getprop_uint64
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
name|time_t
name|time
init|=
operator|(
name|time_t
operator|)
name|val
decl_stmt|;
name|struct
name|tm
name|t
decl_stmt|;
if|if
condition|(
name|literal
operator|||
name|localtime_r
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|t
argument_list|)
operator|==
name|NULL
operator|||
name|strftime
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%a %b %e %k:%M %Y"
argument_list|,
operator|&
name|t
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_MOUNTPOINT
case|:
comment|/* 		 * Getting the precise mountpoint can be tricky. 		 * 		 *  - for 'none' or 'legacy', return those values. 		 *  - for inherited mountpoints, we want to take everything 		 *    after our ancestor and append it to the inherited value. 		 * 		 * If the pool has an alternate root, we want to prepend that 		 * root to any values we return. 		 */
name|str
operator|=
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|root
init|=
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
comment|/* 			 * If we inherit the mountpoint, even from a dataset 			 * with a received value, the source will be the path of 			 * the dataset we inherit from. If source is 			 * ZPROP_SOURCE_VAL_RECVD, the received value is not 			 * inherited. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|ZPROP_SOURCE_VAL_RECVD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|relpath
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|relpath
operator|=
name|zhp
operator|->
name|zfs_name
operator|+
name|strlen
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|relpath
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zpool_get_prop
argument_list|(
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|ZPOOL_PROP_ALTROOT
argument_list|,
name|buf
argument_list|,
name|MAXPATHLEN
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|root
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|root
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Special case an alternate root of '/'. This will 			 * avoid having multiple leading slashes in the 			 * mountpoint path. 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|root
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|root
operator|++
expr_stmt|;
comment|/* 			 * If the mountpoint is '/' then skip over this 			 * if we are obtaining either an alternate root or 			 * an inherited mountpoint. 			 */
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|root
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s%s"
argument_list|,
name|root
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|root
argument_list|,
name|str
argument_list|,
name|relpath
index|[
literal|0
index|]
operator|==
literal|'@'
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 'legacy' or 'none' */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|str
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_ORIGIN
case|:
name|str
operator|=
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|str
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_CLONES
case|:
if|if
condition|(
name|get_clones_string
argument_list|(
name|zhp
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_REFQUOTA
case|:
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If quota or reservation is 0, we translate this into 'none' 		 * (unless literal is set), and indicate that it's the default 		 * value.  Otherwise, we print the number nicely and indicate 		 * that its set locally. 		 */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"0"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"none"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_FILESYSTEM_LIMIT
case|:
case|case
name|ZFS_PROP_SNAPSHOT_LIMIT
case|:
case|case
name|ZFS_PROP_FILESYSTEM_COUNT
case|:
case|case
name|ZFS_PROP_SNAPSHOT_COUNT
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If limit is UINT64_MAX, we translate this into 'none' (unless 		 * literal is set), and indicate that it's the default value. 		 * Otherwise, we print the number nicely and indicate that it's 		 * set locally. 		 */
if|if
condition|(
name|literal
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|UINT64_MAX
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"none"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_REFRATIO
case|:
case|case
name|ZFS_PROP_COMPRESSRATIO
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu.%02llux"
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|val
operator|/
literal|100
argument_list|)
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|val
operator|%
literal|100
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_TYPE
case|:
switch|switch
condition|(
name|zhp
operator|->
name|zfs_type
condition|)
block|{
case|case
name|ZFS_TYPE_FILESYSTEM
case|:
name|str
operator|=
literal|"filesystem"
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_VOLUME
case|:
name|str
operator|=
literal|"volume"
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
name|str
operator|=
literal|"snapshot"
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_BOOKMARK
case|:
name|str
operator|=
literal|"bookmark"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_MOUNTED
case|:
comment|/* 		 * The 'mounted' property is a pseudo-property that described 		 * whether the filesystem is currently mounted.  Even though 		 * it's a boolean value, the typical values of "on" and "off" 		 * don't make sense, so we translate to "yes" and "no". 		 */
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTED
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|val
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"yes"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"no"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NAME
case|:
comment|/* 		 * The 'name' property is a pseudo-property derived from the 		 * dataset name.  It is presented as a real property to simplify 		 * consumers. 		 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_MLSLABEL
case|:
block|{
name|m_label_t
modifier|*
name|new_sl
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ascii
init|=
name|NULL
decl_stmt|;
comment|/* human readable label */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|literal
operator|||
operator|(
name|strcasecmp
argument_list|(
name|propbuf
argument_list|,
name|ZFS_MLSLABEL_DEFAULT
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/* 			 * Try to translate the internal hex string to 			 * human-readable output.  If there are any 			 * problems just use the hex string. 			 */
if|if
condition|(
name|str_to_label
argument_list|(
name|propbuf
argument_list|,
operator|&
name|new_sl
argument_list|,
name|MAC_LABEL
argument_list|,
name|L_NO_CORRECTION
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|m_label_free
argument_list|(
name|new_sl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|label_to_str
argument_list|(
name|new_sl
argument_list|,
operator|&
name|ascii
argument_list|,
name|M_LABEL
argument_list|,
name|DEF_NAMES
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ascii
condition|)
name|free
argument_list|(
name|ascii
argument_list|)
expr_stmt|;
name|m_label_free
argument_list|(
name|new_sl
argument_list|)
expr_stmt|;
break|break;
block|}
name|m_label_free
argument_list|(
name|new_sl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|ascii
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ascii
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_GUID
case|:
comment|/* 		 * GUIDs are stored as numbers, but they are identifiers. 		 * We don't want them to be pretty printed, because pretty 		 * printing mangles the ID into a truncated and useless value. 		 */
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
condition|)
block|{
case|case
name|PROP_TYPE_NUMBER
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|literal
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|zfs_nicenum
argument_list|(
name|val
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TYPE_STRING
case|:
name|str
operator|=
name|getprop_string
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|str
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROP_TYPE_INDEX
case|:
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zfs_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|val
argument_list|,
operator|&
name|strval
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
name|strval
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|get_source
argument_list|(
name|zhp
argument_list|,
name|src
argument_list|,
name|source
argument_list|,
name|statbuf
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to get the given numeric property.  Does no validation that  * the given property is the appropriate type; should only be used with  * hard-coded property types.  */
end_comment

begin_function
name|uint64_t
name|zfs_prop_get_int
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|)
block|{
name|char
modifier|*
name|source
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
operator|(
name|void
operator|)
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|NULL
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_prop_set_int
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%llu"
argument_list|,
operator|(
name|longlong_t
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_prop_set
argument_list|(
name|zhp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to zfs_prop_get(), but returns the value as an integer.  */
end_comment

begin_function
name|int
name|zfs_prop_get_numeric
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|,
name|zprop_source_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|statbuf
parameter_list|,
name|size_t
name|statlen
parameter_list|)
block|{
name|char
modifier|*
name|source
decl_stmt|;
comment|/* 	 * Check to see if this property applies to our object 	 */
if|if
condition|(
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|)
condition|)
block|{
return|return
operator|(
name|zfs_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_PROPTYPE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get property '%s'"
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|src
condition|)
operator|*
name|src
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
if|if
condition|(
name|get_numeric_property
argument_list|(
name|zhp
argument_list|,
name|prop
argument_list|,
name|src
argument_list|,
operator|&
name|source
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|get_source
argument_list|(
name|zhp
argument_list|,
name|src
argument_list|,
name|source
argument_list|,
name|statbuf
argument_list|,
name|statlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idmap_id_to_numeric_domain_rid
parameter_list|(
name|uid_t
name|id
parameter_list|,
name|boolean_t
name|isuser
parameter_list|,
name|char
modifier|*
modifier|*
name|domainp
parameter_list|,
name|idmap_rid_t
modifier|*
name|ridp
parameter_list|)
block|{
name|idmap_get_handle_t
modifier|*
name|get_hdl
init|=
name|NULL
decl_stmt|;
name|idmap_stat
name|status
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|idmap_get_create
argument_list|(
operator|&
name|get_hdl
argument_list|)
operator|!=
name|IDMAP_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|isuser
condition|)
block|{
name|err
operator|=
name|idmap_get_sidbyuid
argument_list|(
name|get_hdl
argument_list|,
name|id
argument_list|,
name|IDMAP_REQ_FLG_USE_CACHE
argument_list|,
name|domainp
argument_list|,
name|ridp
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|idmap_get_sidbygid
argument_list|(
name|get_hdl
argument_list|,
name|id
argument_list|,
name|IDMAP_REQ_FLG_USE_CACHE
argument_list|,
name|domainp
argument_list|,
name|ridp
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|IDMAP_SUCCESS
operator|&&
name|idmap_get_mappings
argument_list|(
name|get_hdl
argument_list|)
operator|==
name|IDMAP_SUCCESS
operator|&&
name|status
operator|==
name|IDMAP_SUCCESS
condition|)
name|err
operator|=
literal|0
expr_stmt|;
else|else
name|err
operator|=
name|EINVAL
expr_stmt|;
name|out
label|:
if|if
condition|(
name|get_hdl
condition|)
name|idmap_get_destroy
argument_list|(
name|get_hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * convert the propname into parameters needed by kernel  * Eg: userquota@ahrens -> ZFS_PROP_USERQUOTA, "", 126829  * Eg: userused@matt@domain -> ZFS_PROP_USERUSED, "S-1-123-456", 789  */
end_comment

begin_function
specifier|static
name|int
name|userquota_propname_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|boolean_t
name|zoned
parameter_list|,
name|zfs_userquota_prop_t
modifier|*
name|typep
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|int
name|domainlen
parameter_list|,
name|uint64_t
modifier|*
name|ridp
parameter_list|)
block|{
name|zfs_userquota_prop_t
name|type
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|numericsid
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|isuser
decl_stmt|;
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ridp
operator|=
literal|0
expr_stmt|;
comment|/* Figure out the property type ({user|group}{quota|space}) */
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|ZFS_NUM_USERQUOTA_PROPS
condition|;
name|type
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|propname
argument_list|,
name|zfs_userquota_prop_prefixes
index|[
name|type
index|]
argument_list|,
name|strlen
argument_list|(
name|zfs_userquota_prop_prefixes
index|[
name|type
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_NUM_USERQUOTA_PROPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|typep
operator|=
name|type
expr_stmt|;
name|isuser
operator|=
operator|(
name|type
operator|==
name|ZFS_PROP_USERQUOTA
operator|||
name|type
operator|==
name|ZFS_PROP_USERUSED
operator|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
comment|/* 		 * It's a SID name (eg "user@domain") that needs to be 		 * turned into S-1-domainID-RID. 		 */
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|idmap_stat
name|stat
decl_stmt|,
name|map_stat
decl_stmt|;
name|uid_t
name|pid
decl_stmt|;
name|idmap_rid_t
name|rid
decl_stmt|;
name|idmap_get_handle_t
modifier|*
name|gh
init|=
name|NULL
decl_stmt|;
name|stat
operator|=
name|idmap_get_create
argument_list|(
operator|&
name|gh
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|IDMAP_SUCCESS
condition|)
block|{
name|idmap_get_destroy
argument_list|(
name|gh
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|isuser
condition|)
block|{
name|stat
operator|=
name|idmap_getuidbywinname
argument_list|(
name|cp
argument_list|,
name|NULL
argument_list|,
name|flag
argument_list|,
operator|&
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|stat
operator|=
name|idmap_get_sidbyuid
argument_list|(
name|gh
argument_list|,
name|pid
argument_list|,
name|flag
argument_list|,
operator|&
name|numericsid
argument_list|,
operator|&
name|rid
argument_list|,
operator|&
name|map_stat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stat
operator|=
name|idmap_getgidbywinname
argument_list|(
name|cp
argument_list|,
name|NULL
argument_list|,
name|flag
argument_list|,
operator|&
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|stat
operator|=
name|idmap_get_sidbygid
argument_list|(
name|gh
argument_list|,
name|pid
argument_list|,
name|flag
argument_list|,
operator|&
name|numericsid
argument_list|,
operator|&
name|rid
argument_list|,
operator|&
name|map_stat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|<
literal|0
condition|)
block|{
name|idmap_get_destroy
argument_list|(
name|gh
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|stat
operator|=
name|idmap_get_mappings
argument_list|(
name|gh
argument_list|)
expr_stmt|;
name|idmap_get_destroy
argument_list|(
name|gh
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|numericsid
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|cp
operator|=
name|numericsid
expr_stmt|;
operator|*
name|ridp
operator|=
name|rid
expr_stmt|;
comment|/* will be further decoded below */
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"S-1-"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It's a numeric SID (eg "S-1-234-567-89") */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|domain
argument_list|,
name|cp
argument_list|,
name|domainlen
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|ridp
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|domain
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|++
expr_stmt|;
operator|*
name|ridp
operator|=
name|strtoull
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|numericsid
condition|)
block|{
name|free
argument_list|(
name|numericsid
argument_list|)
expr_stmt|;
name|numericsid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
comment|/* 		 * It's a user/group name (eg "user") that needs to be 		 * turned into a uid/gid 		 */
if|if
condition|(
name|zoned
operator|&&
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|isuser
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|ridp
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|*
name|ridp
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's a user/group ID (eg "12345"). */
name|uid_t
name|id
init|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|idmap_rid_t
name|rid
decl_stmt|;
name|char
modifier|*
name|mapdomain
decl_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|id
operator|>
name|MAXUID
condition|)
block|{
comment|/* It's an ephemeral ID. */
if|if
condition|(
name|idmap_id_to_numeric_domain_rid
argument_list|(
name|id
argument_list|,
name|isuser
argument_list|,
operator|&
name|mapdomain
argument_list|,
operator|&
name|rid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|domain
argument_list|,
name|mapdomain
argument_list|,
name|domainlen
argument_list|)
expr_stmt|;
operator|*
name|ridp
operator|=
name|rid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ridp
operator|=
name|id
expr_stmt|;
block|}
block|}
name|ASSERT3P
argument_list|(
name|numericsid
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_prop_get_userquota_common
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
modifier|*
name|propvalue
parameter_list|,
name|zfs_userquota_prop_t
modifier|*
name|typep
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|userquota_propname_decode
argument_list|(
name|propname
argument_list|,
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
name|typep
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|,
operator|&
name|zc
operator|.
name|zc_guid
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_objset_type
operator|=
operator|*
name|typep
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_USERSPACE_ONE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
operator|*
name|propvalue
operator|=
name|zc
operator|.
name|zc_cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_prop_get_userquota_int
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
modifier|*
name|propvalue
parameter_list|)
block|{
name|zfs_userquota_prop_t
name|type
decl_stmt|;
return|return
operator|(
name|zfs_prop_get_userquota_common
argument_list|(
name|zhp
argument_list|,
name|propname
argument_list|,
name|propvalue
argument_list|,
operator|&
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_prop_get_userquota
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|int
name|proplen
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|propvalue
decl_stmt|;
name|zfs_userquota_prop_t
name|type
decl_stmt|;
name|err
operator|=
name|zfs_prop_get_userquota_common
argument_list|(
name|zhp
argument_list|,
name|propname
argument_list|,
operator|&
name|propvalue
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|literal
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
name|propvalue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|propvalue
operator|==
literal|0
operator|&&
operator|(
name|type
operator|==
name|ZFS_PROP_USERQUOTA
operator|||
name|type
operator|==
name|ZFS_PROP_GROUPQUOTA
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|propbuf
argument_list|,
literal|"none"
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_nicenum
argument_list|(
name|propvalue
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_prop_get_written_int
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
modifier|*
name|propvalue
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|snapname
operator|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|snapname
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* snapname is the short name, append it to zhp's fsname */
name|char
modifier|*
name|cp
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|"@"
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SPACE_WRITTEN
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
operator|*
name|propvalue
operator|=
name|zc
operator|.
name|zc_cookie
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_prop_get_written
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|char
modifier|*
name|propbuf
parameter_list|,
name|int
name|proplen
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|propvalue
decl_stmt|;
name|err
operator|=
name|zfs_prop_get_written_int
argument_list|(
name|zhp
argument_list|,
name|propname
argument_list|,
operator|&
name|propvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|literal
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|propbuf
argument_list|,
name|proplen
argument_list|,
literal|"%llu"
argument_list|,
name|propvalue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_nicenum
argument_list|(
name|propvalue
argument_list|,
name|propbuf
argument_list|,
name|proplen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the name of the given zfs handle.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_get_name
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the name of the parent pool for the given zfs handle.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_get_pool_name
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zpool_hdl
operator|->
name|zpool_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the type of the given zfs handle.  */
end_comment

begin_function
name|zfs_type_t
name|zfs_get_type
parameter_list|(
specifier|const
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is one dataset name a child dataset of another?  *  * Needs to handle these cases:  * Dataset 1	"a/foo"		"a/foo"		"a/foo"		"a/foo"  * Dataset 2	"a/fo"		"a/foobar"	"a/bar/baz"	"a/foo/bar"  * Descendant?	No.		No.		No.		Yes.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|is_descendant
parameter_list|(
specifier|const
name|char
modifier|*
name|ds1
parameter_list|,
specifier|const
name|char
modifier|*
name|ds2
parameter_list|)
block|{
name|size_t
name|d1len
init|=
name|strlen
argument_list|(
name|ds1
argument_list|)
decl_stmt|;
comment|/* ds2 can't be a descendant if it's smaller */
if|if
condition|(
name|strlen
argument_list|(
name|ds2
argument_list|)
operator|<
name|d1len
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* otherwise, compare strings and verify that there's a '/' char */
return|return
operator|(
name|ds2
index|[
name|d1len
index|]
operator|==
literal|'/'
operator|&&
operator|(
name|strncmp
argument_list|(
name|ds1
argument_list|,
name|ds2
argument_list|,
name|d1len
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a complete name, return just the portion that refers to the parent.  * Will return -1 if there is no parent (path is just the name of the  * pool).  */
end_comment

begin_function
specifier|static
name|int
name|parent_name
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|slashp
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|path
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slashp
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|slashp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If accept_ancestor is false, then check to make sure that the given path has  * a parent, and that it exists.  If accept_ancestor is true, then find the  * closest existing ancestor for the given path.  In prefixlen return the  * length of already existing prefix of the given path.  We also fetch the  * 'zoned' property, which is used to validate property settings when creating  * new datasets.  */
end_comment

begin_function
specifier|static
name|int
name|check_parents
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|uint64_t
modifier|*
name|zoned
parameter_list|,
name|boolean_t
name|accept_ancestor
parameter_list|,
name|int
modifier|*
name|prefixlen
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|uint64_t
name|is_zoned
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* get parent, and check to see if this is just a pool */
if|if
condition|(
name|parent_name
argument_list|(
name|path
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing dataset name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* check to see if the pool exists */
if|if
condition|(
operator|(
name|slash
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|slash
operator|=
name|parent
operator|+
name|strlen
argument_list|(
name|parent
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|parent
argument_list|,
name|slash
operator|-
name|parent
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_name
index|[
name|slash
operator|-
name|parent
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* check to see if the parent dataset exists */
while|while
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|parent
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
name|accept_ancestor
condition|)
block|{
comment|/* 			 * Go deeper to find an ancestor, give up on top level. 			 */
if|if
condition|(
name|parent_name
argument_list|(
name|parent
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such pool '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent does not exist"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|is_zoned
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
expr_stmt|;
if|if
condition|(
name|zoned
operator|!=
name|NULL
condition|)
operator|*
name|zoned
operator|=
name|is_zoned
expr_stmt|;
comment|/* we are in a non-global zone, but parent is in the global zone */
if|if
condition|(
name|getzoneid
argument_list|()
operator|!=
name|GLOBAL_ZONEID
operator|&&
operator|!
name|is_zoned
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|EPERM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure parent is a filesystem */
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|!=
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent is not a filesystem"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixlen
operator|!=
name|NULL
condition|)
operator|*
name|prefixlen
operator|=
name|strlen
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds whether the dataset of the given type(s) exists.  */
end_comment

begin_function
name|boolean_t
name|zfs_dataset_exists
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|zfs_type_t
name|types
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|types
argument_list|,
name|B_FALSE
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* 	 * Try to get stats for the dataset, which will tell us if it exists. 	 */
if|if
condition|(
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|ds_type
init|=
name|zhp
operator|->
name|zfs_type
decl_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|types
operator|&
name|ds_type
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a path to 'target', create all the ancestors between  * the prefixlen portion of the path, and the target itself.  * Fail if the initial prefixlen-ancestor does not already exist.  */
end_comment

begin_function
name|int
name|create_parents
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|int
name|prefixlen
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
comment|/* make sure prefix exists */
name|cp
operator|=
name|target
operator|+
name|prefixlen
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
name|assert
argument_list|(
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to create, mount, and share any ancestor filesystems, 	 * up to the prefixlen-long one. 	 */
for|for
control|(
name|cp
operator|=
name|target
operator|+
name|prefixlen
operator|+
literal|1
init|;
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
operator|*
name|cp
operator|=
literal|'/'
operator|,
name|cp
operator|++
control|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
comment|/* it already exists, nothing to do here */
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zfs_create
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
if|if
condition|(
name|zfs_mount
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"mount"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
if|if
condition|(
name|zfs_share
argument_list|(
name|h
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|opname
operator|=
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"share"
argument_list|)
expr_stmt|;
goto|goto
name|ancestorerr
goto|;
block|}
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|ancestorerr
label|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to %s ancestor '%s'"
argument_list|)
argument_list|,
name|opname
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Creates non-existing ancestors of the given path.  */
end_comment

begin_function
name|int
name|zfs_create_ancestors
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|prefix
decl_stmt|;
name|char
modifier|*
name|path_copy
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|prefix
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|path_copy
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rc
operator|=
name|create_parents
argument_list|(
name|hdl
argument_list|,
name|path_copy
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_copy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path_copy
operator|==
name|NULL
operator|||
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new filesystem or volume.  */
end_comment

begin_function
name|int
name|zfs_create
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|zfs_type_t
name|type
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint64_t
name|size
init|=
literal|0
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|;
name|enum
name|lzc_dataset_type
name|ost
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* validate the path, taking care to note the extended error message */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|type
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* validate parents exist */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
operator|&
name|zoned
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * The failure modes when creating a dataset of a different type over 	 * one that already exists is a little strange.  In particular, if you 	 * try to create a dataset on top of an existing dataset, the ioctl() 	 * will return ENOENT, not EEXIST.  To prevent this from happening, we 	 * first try to see if the dataset exists. 	 */
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset already exists"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
name|ost
operator|=
name|LZC_DATSET_TYPE_ZVOL
expr_stmt|;
else|else
name|ost
operator|=
name|LZC_DATSET_TYPE_ZFS
expr_stmt|;
comment|/* open zpool handle for prop validation */
name|char
name|pool_path
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool_path
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|pool_path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* truncate pool_path at first slash */
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|pool_path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|zpool_handle_t
modifier|*
name|zpool_handle
init|=
name|zpool_open
argument_list|(
name|hdl
argument_list|,
name|pool_path
argument_list|)
decl_stmt|;
if|if
condition|(
name|props
operator|&&
operator|(
name|props
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|type
argument_list|,
name|props
argument_list|,
name|zoned
argument_list|,
name|NULL
argument_list|,
name|zpool_handle
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|zpool_close
argument_list|(
name|zpool_handle
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zpool_close
argument_list|(
name|zpool_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
comment|/* 		 * If we are creating a volume, the size and block size must 		 * satisfy a few restraints.  First, the blocksize must be a 		 * valid block size between SPA_{MIN,MAX}BLOCKSIZE.  Second, the 		 * volsize must be a multiple of the block size, and cannot be 		 * zero. 		 */
if|if
condition|(
name|props
operator|==
name|NULL
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing volume size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|blocksize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|ENOENT
condition|)
block|{
name|blocksize
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"missing volume block size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size cannot be zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|%
name|blocksize
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"volume size must be a multiple of volume block "
literal|"size"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPROP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* create the dataset */
name|ret
operator|=
name|lzc_create
argument_list|(
name|path
argument_list|,
name|ost
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
comment|/* check for failure */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|char
name|parent
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|path
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EINVAL
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"parent '%s' is not a filesystem"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to set this "
literal|"property or value"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|_ILP32
case|case
name|EOVERFLOW
case|:
comment|/* 			 * This platform can't address a volume this big. 			 */
if|if
condition|(
name|type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_VOLTOOBIG
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys the given dataset.  The caller must make sure that the filesystem  * isn't mounted, and that there are no active dependents. If the file system  * does not exist this function does nothing.  */
end_comment

begin_function
name|int
name|zfs_destroy
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|defer
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_BOOKMARK
condition|)
block|{
name|nvlist_t
modifier|*
name|nv
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|nv
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|int
name|error
init|=
name|lzc_destroy_bookmarks
argument_list|(
name|nv
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|fnvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
block|}
else|else
block|{
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
block|}
name|zc
operator|.
name|zc_defer_destroy
operator|=
name|defer
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|)
return|;
block|}
name|remove_mountpoint
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|destroydata
block|{
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|zfs_check_snap_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|destroydata
modifier|*
name|dd
init|=
name|arg
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|dd
operator|->
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|lzc_exists
argument_list|(
name|name
argument_list|)
condition|)
name|verify
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|dd
operator|->
name|nvl
argument_list|,
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_check_snap_cb
argument_list|,
name|dd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys all snapshots with the given name in zhp& descendants.  */
end_comment

begin_function
name|int
name|zfs_destroy_snaps
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|,
name|boolean_t
name|defer
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|destroydata
name|dd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dd
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|dd
operator|.
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_check_snap_cb
argument_list|(
name|zfs_handle_dup
argument_list|(
name|zhp
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_empty
argument_list|(
name|dd
operator|.
name|nvl
argument_list|)
condition|)
block|{
name|ret
operator|=
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ENOENT
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy '%s@%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|zfs_destroy_snaps_nvl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dd
operator|.
name|nvl
argument_list|,
name|defer
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|dd
operator|.
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroys all the snapshots named in the nvlist.  */
end_comment

begin_function
name|int
name|zfs_destroy_snaps_nvl
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|boolean_t
name|defer
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|nvlist_t
modifier|*
name|errlist
init|=
name|NULL
decl_stmt|;
name|ret
operator|=
name|lzc_destroy_snaps
argument_list|(
name|snaps
argument_list|,
name|defer
argument_list|,
operator|&
name|errlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|errlist
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_empty
argument_list|(
name|errlist
argument_list|)
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy snapshots"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|ret
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|nvpair_t
modifier|*
name|pair
init|=
name|nvlist_next_nvpair
argument_list|(
name|errlist
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errlist
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot destroy snapshot %s"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fnvpair_value_int32
argument_list|(
name|pair
argument_list|)
condition|)
block|{
case|case
name|EEXIST
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshot is cloned"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nvlist_free
argument_list|(
name|errlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clones the given dataset.  The target must be of the same type as the source.  */
end_comment

begin_function
name|int
name|zfs_clone
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|char
name|parent
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|uint64_t
name|zoned
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create '%s'"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* validate the target/clone name */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* validate parents exist */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
operator|&
name|zoned
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|parent_name
argument_list|(
name|target
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do the clone */
if|if
condition|(
name|props
condition|)
block|{
name|zfs_type_t
name|type
decl_stmt|;
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
block|{
name|type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|props
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|type
argument_list|,
name|props
argument_list|,
name|zoned
argument_list|,
name|zhp
argument_list|,
name|zhp
operator|->
name|zpool_hdl
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|lzc_clone
argument_list|(
name|target
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
comment|/* 			 * The parent doesn't exist.  We should have caught this 			 * above, but there may a race condition that has since 			 * destroyed the parent. 			 * 			 * At this point, we don't know whether it's the source 			 * that doesn't exist anymore, or whether the target 			 * dataset doesn't exist. 			 */
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"no such parent '%s'"
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"source and target pools differ"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Promotes the given clone fs to be the clone parent.  */
end_comment

begin_function
name|int
name|zfs_promote
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|parent
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot promote '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots can not be promoted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not a cloned filesystem"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_PROMOTE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
switch|switch
condition|(
name|save_errno
condition|)
block|{
case|case
name|EEXIST
case|:
comment|/* There is a conflicting snapshot name. */
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"conflicting snapshot '%s' from parent '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_string
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|save_errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|snapdata
block|{
name|nvlist_t
modifier|*
name|sd_nvl
decl_stmt|;
specifier|const
name|char
modifier|*
name|sd_snapname
decl_stmt|;
block|}
name|snapdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|zfs_snapshot_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|snapdata_t
modifier|*
name|sd
init|=
name|arg
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_INCONSISTENT
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|sd
operator|->
name|sd_snapname
argument_list|)
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|sd
operator|->
name|sd_nvl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_snapshot_cb
argument_list|,
name|sd
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Creates snapshots.  The keys in the snaps nvlist are the snapshots to be  * created.  */
end_comment

begin_function
name|int
name|zfs_snapshot_nvl
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|nvlist_t
modifier|*
name|errors
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create snapshots "
argument_list|)
argument_list|)
expr_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|snapname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
comment|/* validate the target name */
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|snapname
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|,
name|B_TRUE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create snapshot '%s'"
argument_list|)
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * get pool handle for prop validation. assumes all snaps are in the 	 * same pool, as does lzc_snapshot (below). 	 */
name|char
name|pool
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pool
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pool
index|[
name|strcspn
argument_list|(
name|pool
argument_list|,
literal|"/@"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|zpool_handle_t
modifier|*
name|zpool_hdl
init|=
name|zpool_open
argument_list|(
name|hdl
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
operator|&&
operator|(
name|props
operator|=
name|zfs_valid_proplist
argument_list|(
name|hdl
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|,
name|zpool_hdl
argument_list|,
name|errbuf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zpool_close
argument_list|(
name|zpool_hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zpool_close
argument_list|(
name|zpool_hdl
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lzc_snapshot
argument_list|(
name|snaps
argument_list|,
name|props
argument_list|,
operator|&
name|errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|boolean_t
name|printed
init|=
name|B_FALSE
decl_stmt|;
for|for
control|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errors
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errors
argument_list|,
name|elem
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot create snapshot '%s'"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|fnvpair_value_int32
argument_list|(
name|elem
argument_list|)
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|printed
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|printed
condition|)
block|{
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"multiple snapshots of same "
literal|"fs not allowed"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|ret
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_snapshot
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|boolean_t
name|recursive
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|snapdata_t
name|sd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
name|fsname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot snapshot %s"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fsname
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|sd
operator|.
name|sd_snapname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|fsname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|.
name|sd_nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_snapshot_cb
argument_list|(
name|zfs_handle_dup
argument_list|(
name|zhp
argument_list|)
argument_list|,
operator|&
name|sd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fnvlist_add_boolean
argument_list|(
name|sd
operator|.
name|sd_nvl
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|zfs_snapshot_nvl
argument_list|(
name|hdl
argument_list|,
name|sd
operator|.
name|sd_nvl
argument_list|,
name|props
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sd
operator|.
name|sd_nvl
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy any more recent snapshots.  We invoke this callback on any dependents  * of the snapshot first.  If the 'cb_dependent' member is non-zero, then this  * is a dependent and we should just destroy it without checking the transaction  * group.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rollback_data
block|{
specifier|const
name|char
modifier|*
name|cb_target
decl_stmt|;
comment|/* the snapshot */
name|uint64_t
name|cb_create
decl_stmt|;
comment|/* creation time reference */
name|boolean_t
name|cb_error
decl_stmt|;
name|boolean_t
name|cb_force
decl_stmt|;
block|}
name|rollback_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|rollback_destroy_dependent
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_data_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
comment|/* We must destroy this clone; first unmount it */
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
name|cbp
operator|->
name|cb_force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
operator|||
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cbp
operator|->
name|cb_error
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfs_destroy
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
name|cbp
operator|->
name|cb_error
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|changelist_remove
argument_list|(
name|clp
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rollback_destroy
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rollback_data_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
operator|>
name|cbp
operator|->
name|cb_create
condition|)
block|{
name|cbp
operator|->
name|cb_error
operator||=
name|zfs_iter_dependents
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|rollback_destroy_dependent
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|cb_error
operator||=
name|zfs_destroy
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a dataset, rollback to a specific snapshot, discarding any  * data changes since then and making it the active dataset.  *  * Any snapshots and bookmarks more recent than the target are  * destroyed, along with their dependents (i.e. clones).  */
end_comment

begin_function
name|int
name|zfs_rollback
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_handle_t
modifier|*
name|snap
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|rollback_data_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|boolean_t
name|restore_resv
init|=
literal|0
decl_stmt|;
name|uint64_t
name|old_volsize
init|=
literal|0
decl_stmt|,
name|new_volsize
decl_stmt|;
name|zfs_prop_t
name|resv_prop
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|||
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy all recent snapshots and their dependents. 	 */
name|cb
operator|.
name|cb_force
operator|=
name|force
expr_stmt|;
name|cb
operator|.
name|cb_target
operator|=
name|snap
operator|->
name|zfs_name
expr_stmt|;
name|cb
operator|.
name|cb_create
operator|=
name|zfs_prop_get_int
argument_list|(
name|snap
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|rollback_destroy
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_bookmarks
argument_list|(
name|zhp
argument_list|,
name|rollback_destroy
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|cb_error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Now that we have verified that the snapshot is the latest, 	 * rollback to the given snapshot. 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
if|if
condition|(
name|zfs_which_resv_prop
argument_list|(
name|zhp
argument_list|,
operator|&
name|resv_prop
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|old_volsize
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
expr_stmt|;
name|restore_resv
operator|=
operator|(
name|old_volsize
operator|==
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|resv_prop
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* 	 * We rely on zfs_iter_children() to verify that there are no 	 * newer snapshots for the given dataset.  Therefore, we can 	 * simply pass the name on to the ioctl() call.  There is still 	 * an unlikely race condition where the user has taken a 	 * snapshot since we verified that this was the most recent. 	 */
name|err
operator|=
name|lzc_rollback
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_standard_error_fmt
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rollback '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * For volumes, if the pre-rollback volsize matched the pre- 	 * rollback reservation and the volsize has changed then set 	 * the reservation property to the post-rollback volsize. 	 * Make a new handle since the rollback closed the dataset. 	 */
if|if
condition|(
operator|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
operator|)
operator|&&
operator|(
name|zhp
operator|=
name|make_dataset_handle
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|restore_resv
condition|)
block|{
name|new_volsize
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_volsize
operator|!=
name|new_volsize
condition|)
name|err
operator|=
name|zfs_prop_set_int
argument_list|(
name|zhp
argument_list|,
name|resv_prop
argument_list|,
name|new_volsize
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Renames the given dataset.  */
end_comment

begin_function
name|int
name|zfs_rename
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|boolean_t
name|recursive
parameter_list|,
name|boolean_t
name|force_unmount
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
name|prop_changelist_t
modifier|*
name|cl
init|=
name|NULL
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhrp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|parentname
init|=
name|NULL
decl_stmt|;
name|char
name|parent
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
comment|/* if we have the same exact name, just return success */
if|if
condition|(
name|strcmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename to '%s'"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the target name is valid 	 */
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
if|if
condition|(
operator|(
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|*
name|target
operator|==
literal|'@'
condition|)
block|{
comment|/* 			 * Snapshot target name is abbreviated, 			 * reconstruct full dataset name 			 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|parent
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|delim
operator|=
name|strchr
argument_list|(
name|parent
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
operator|*
operator|(
operator|++
name|delim
operator|)
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|parent
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Make sure we're renaming within the same dataset. 			 */
name|delim
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|,
name|delim
operator|-
name|target
argument_list|)
operator|!=
literal|0
operator|||
name|zhp
operator|->
name|zfs_name
index|[
name|delim
operator|-
name|target
index|]
operator|!=
literal|'@'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"snapshots must be part of same "
literal|"dataset"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|recursive
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"recursive rename must be a snapshot"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_validate_name
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|zhp
operator|->
name|zfs_type
argument_list|,
name|B_TRUE
argument_list|)
condition|)
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
comment|/* validate parents */
if|if
condition|(
name|check_parents
argument_list|(
name|hdl
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* make sure we're in the same pool */
name|verify
argument_list|(
operator|(
name|delim
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|,
name|delim
operator|-
name|target
argument_list|)
operator|!=
literal|0
operator|||
name|zhp
operator|->
name|zfs_name
index|[
name|delim
operator|-
name|target
index|]
operator|!=
literal|'/'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"datasets must be within same pool"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* new name cannot be a child of the current dataset name */
if|if
condition|(
name|is_descendant
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|target
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"New dataset name cannot be a descendant of "
literal|"current dataset name"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|getzoneid
argument_list|()
operator|==
name|GLOBAL_ZONEID
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_ZONED
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"dataset is used in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|recursive
condition|)
block|{
name|parentname
operator|=
name|zfs_strdup
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentname
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|delim
operator|=
name|strchr
argument_list|(
name|parentname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|delim
operator|=
literal|'\0'
expr_stmt|;
name|zhrp
operator|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|parentname
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhrp
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|!=
name|ZFS_TYPE_SNAPSHOT
condition|)
block|{
if|if
condition|(
operator|(
name|cl
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
name|force_unmount
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|changelist_haszonedchild
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"child dataset with inherited mountpoint is used "
literal|"in a non-global zone"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_ZONED
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|changelist_prefix
argument_list|(
name|cl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ZFS_IS_VOLUME
argument_list|(
name|zhp
argument_list|)
condition|)
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZVOL
expr_stmt|;
else|else
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|recursive
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_RENAME
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * if it was recursive, the one that actually failed will 		 * be in zc.zc_name 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot rename '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|&&
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"a child dataset already has a snapshot "
literal|"with the new name"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * On failure, we still want to remount any filesystems that 		 * were previously mounted, so we don't alter the system state. 		 */
if|if
condition|(
name|cl
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cl
operator|!=
name|NULL
condition|)
block|{
name|changelist_rename
argument_list|(
name|cl
argument_list|,
name|zfs_get_name
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ret
operator|=
name|changelist_postfix
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
name|error
label|:
if|if
condition|(
name|parentname
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|parentname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zhrp
operator|!=
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|zhrp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cl
operator|!=
name|NULL
condition|)
block|{
name|changelist_free
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zfs_get_user_props
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
return|return
operator|(
name|zhp
operator|->
name|zfs_user_props
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zfs_get_recvd_props
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|)
block|{
if|if
condition|(
name|zhp
operator|->
name|zfs_recvd_props
operator|==
name|NULL
condition|)
if|if
condition|(
name|get_recvd_props_ioctl
argument_list|(
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|zhp
operator|->
name|zfs_recvd_props
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is used by 'zfs list' to determine the exact set of columns to  * display, and their maximum widths.  This does two main things:  *  *      - If this is a list of all properties, then expand the list to include  *        all native properties, and set a flag so that for each dataset we look  *        for new unique user properties and add them to the list.  *  *      - For non fixed-width properties, keep track of the maximum width seen  *        so that we can size the column appropriately. If the user has  *        requested received property values, we also need to compute the width  *        of the RECEIVED column.  */
end_comment

begin_function
name|int
name|zfs_expand_proplist
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zprop_list_t
modifier|*
modifier|*
name|plp
parameter_list|,
name|boolean_t
name|received
parameter_list|,
name|boolean_t
name|literal
parameter_list|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|zprop_list_t
modifier|*
name|entry
decl_stmt|;
name|zprop_list_t
modifier|*
modifier|*
name|last
decl_stmt|,
modifier|*
modifier|*
name|start
decl_stmt|;
name|nvlist_t
modifier|*
name|userprops
decl_stmt|,
modifier|*
name|propval
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
if|if
condition|(
name|zprop_expand_list
argument_list|(
name|hdl
argument_list|,
name|plp
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|userprops
operator|=
name|zfs_get_user_props
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|plp
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|pl_all
operator|&&
name|nvlist_next_nvpair
argument_list|(
name|userprops
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Go through and add any user properties as necessary.  We 		 * start by incrementing our list pointer to the first 		 * non-native property. 		 */
name|start
operator|=
name|plp
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|start
operator|)
operator|->
name|pl_prop
operator|==
name|ZPROP_INVAL
condition|)
break|break;
name|start
operator|=
operator|&
operator|(
operator|*
name|start
operator|)
operator|->
name|pl_next
expr_stmt|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|userprops
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * See if we've already found this property in our list. 			 */
for|for
control|(
name|last
operator|=
name|start
init|;
operator|*
name|last
operator|!=
name|NULL
condition|;
name|last
operator|=
operator|&
operator|(
operator|*
name|last
operator|)
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|last
operator|)
operator|->
name|pl_user_prop
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|last
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|zprop_list_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|(
name|entry
operator|->
name|pl_user_prop
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|entry
operator|->
name|pl_prop
operator|=
name|ZPROP_INVAL
expr_stmt|;
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|pl_all
operator|=
name|B_TRUE
expr_stmt|;
operator|*
name|last
operator|=
name|entry
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now go through and check the width of any non-fixed columns 	 */
for|for
control|(
name|entry
operator|=
operator|*
name|plp
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry
operator|->
name|pl_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|pl_fixed
operator|&&
operator|!
name|literal
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|pl_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
if|if
condition|(
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|entry
operator|->
name|pl_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|literal
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|received
operator|&&
name|zfs_prop_get_recvd
argument_list|(
name|zhp
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|entry
operator|->
name|pl_prop
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|literal
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_recvd_width
condition|)
name|entry
operator|->
name|pl_recvd_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|userprops
argument_list|,
name|entry
operator|->
name|pl_user_prop
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|strval
argument_list|)
operator|>
name|entry
operator|->
name|pl_width
condition|)
name|entry
operator|->
name|pl_width
operator|=
name|strlen
argument_list|(
name|strval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|received
operator|&&
name|zfs_prop_get_recvd
argument_list|(
name|zhp
argument_list|,
name|entry
operator|->
name|pl_user_prop
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|literal
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|entry
operator|->
name|pl_recvd_width
condition|)
name|entry
operator|->
name|pl_recvd_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_deleg_share_nfs
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|resource
parameter_list|,
name|void
modifier|*
name|export
parameter_list|,
name|void
modifier|*
name|sharetab
parameter_list|,
name|int
name|sharemax
parameter_list|,
name|zfs_share_op_t
name|operation
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|,
name|resource
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_sharedata
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|sharetab
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_exportdata
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|export
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_sharetype
operator|=
name|operation
expr_stmt|;
name|zc
operator|.
name|zc_share
operator|.
name|z_sharemax
operator|=
name|sharemax
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SHARE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_prune_proplist
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint8_t
modifier|*
name|props
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|curr
decl_stmt|;
comment|/* 	 * Keep a reference to the props-table against which we prune the 	 * properties. 	 */
name|zhp
operator|->
name|zfs_props_table
operator|=
name|props
expr_stmt|;
name|curr
operator|=
name|nvlist_next_nvpair
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|curr
condition|)
block|{
name|zfs_prop_t
name|zfs_prop
init|=
name|zfs_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|curr
argument_list|)
argument_list|)
decl_stmt|;
name|nvpair_t
modifier|*
name|next
init|=
name|nvlist_next_nvpair
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|curr
argument_list|)
decl_stmt|;
comment|/* 		 * User properties will result in ZPROP_INVAL, and since we 		 * only know how to prune standard ZFS properties, we always 		 * leave these in the list.  This can also happen if we 		 * encounter an unknown DSL property (when running older 		 * software, for example). 		 */
if|if
condition|(
name|zfs_prop
operator|!=
name|ZPROP_INVAL
operator|&&
name|props
index|[
name|zfs_prop
index|]
operator|==
name|B_FALSE
condition|)
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|nvpair_name
argument_list|(
name|curr
argument_list|)
argument_list|,
name|nvpair_type
argument_list|(
name|curr
argument_list|)
argument_list|)
expr_stmt|;
name|curr
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_smb_acl_mgmt
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|zfs_smb_acl_op_t
name|cmd
parameter_list|,
name|char
modifier|*
name|resource1
parameter_list|,
name|char
modifier|*
name|resource2
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|nvlist
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|dataset
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
operator|(
name|uint64_t
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|ZFS_SMB_ACL_RENAME
condition|)
block|{
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvlist
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ZFS_SMB_ACL_ADD
case|:
case|case
name|ZFS_SMB_ACL_REMOVE
case|:
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|,
name|resource1
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_SMB_ACL_RENAME
case|:
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nvlist
argument_list|,
name|ZFS_SMB_ACL_SRC
argument_list|,
name|resource1
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nvlist
argument_list|,
name|ZFS_SMB_ACL_TARGET
argument_list|,
name|resource2
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|nvlist
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvlist
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|ZFS_SMB_ACL_PURGE
case|:
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SMB_ACL
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_smb_acl_add
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|resource
parameter_list|)
block|{
return|return
operator|(
name|zfs_smb_acl_mgmt
argument_list|(
name|hdl
argument_list|,
name|dataset
argument_list|,
name|path
argument_list|,
name|ZFS_SMB_ACL_ADD
argument_list|,
name|resource
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_smb_acl_remove
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|resource
parameter_list|)
block|{
return|return
operator|(
name|zfs_smb_acl_mgmt
argument_list|(
name|hdl
argument_list|,
name|dataset
argument_list|,
name|path
argument_list|,
name|ZFS_SMB_ACL_REMOVE
argument_list|,
name|resource
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_smb_acl_purge
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
operator|(
name|zfs_smb_acl_mgmt
argument_list|(
name|hdl
argument_list|,
name|dataset
argument_list|,
name|path
argument_list|,
name|ZFS_SMB_ACL_PURGE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_smb_acl_rename
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|char
modifier|*
name|dataset
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|oldname
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|)
block|{
return|return
operator|(
name|zfs_smb_acl_mgmt
argument_list|(
name|hdl
argument_list|,
name|dataset
argument_list|,
name|path
argument_list|,
name|ZFS_SMB_ACL_RENAME
argument_list|,
name|oldname
argument_list|,
name|newname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_userspace
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|zfs_userquota_prop_t
name|type
parameter_list|,
name|zfs_userspace_cb_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_useracct_t
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|type
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|zfs_useracct_t
modifier|*
name|zua
init|=
name|buf
decl_stmt|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_USERSPACE_MANY
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get used/quota for %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zc
operator|.
name|zc_nvlist_dst_size
operator|==
literal|0
condition|)
break|break;
while|while
condition|(
name|zc
operator|.
name|zc_nvlist_dst_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
name|arg
argument_list|,
name|zua
operator|->
name|zu_domain
argument_list|,
name|zua
operator|->
name|zu_rid
argument_list|,
name|zua
operator|->
name|zu_space
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|zua
operator|++
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|-=
sizeof|sizeof
argument_list|(
name|zfs_useracct_t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|holdarg
block|{
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|boolean_t
name|recursive
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|zfs_hold_one
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|holdarg
modifier|*
name|ha
init|=
name|arg
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|ha
operator|->
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|lzc_exists
argument_list|(
name|name
argument_list|)
condition|)
name|fnvlist_add_string
argument_list|(
name|ha
operator|->
name|nvl
argument_list|,
name|name
argument_list|,
name|ha
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ha
operator|->
name|recursive
condition|)
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_hold_one
argument_list|,
name|ha
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_hold
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|boolean_t
name|recursive
parameter_list|,
name|int
name|cleanup_fd
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|holdarg
name|ha
decl_stmt|;
name|ha
operator|.
name|nvl
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|ha
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
name|ha
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|ha
operator|.
name|recursive
operator|=
name|recursive
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_hold_one
argument_list|(
name|zfs_handle_dup
argument_list|(
name|zhp
argument_list|)
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_empty
argument_list|(
name|ha
operator|.
name|nvl
argument_list|)
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|fnvlist_free
argument_list|(
name|ha
operator|.
name|nvl
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ENOENT
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot hold snapshot '%s@%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ret
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|zfs_hold_nvl
argument_list|(
name|zhp
argument_list|,
name|cleanup_fd
argument_list|,
name|ha
operator|.
name|nvl
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|ha
operator|.
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_hold_nvl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|int
name|cleanup_fd
parameter_list|,
name|nvlist_t
modifier|*
name|holds
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|nvlist_t
modifier|*
name|errors
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|errors
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|lzc_hold
argument_list|(
name|holds
argument_list|,
name|cleanup_fd
argument_list|,
operator|&
name|errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* There may be errors even in the success case. */
name|fnvlist_free
argument_list|(
name|errors
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_empty
argument_list|(
name|errors
argument_list|)
condition|)
block|{
comment|/* no hold-specific errors */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot hold"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|ret
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errors
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errors
argument_list|,
name|elem
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot hold snapshot '%s'"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fnvpair_value_int32
argument_list|(
name|elem
argument_list|)
condition|)
block|{
case|case
name|E2BIG
case|:
comment|/* 			 * Temporary tags wind up having the ds object id 			 * prepended. So even if we passed the length check 			 * above, it's still possible for the tag to wind 			 * up being slightly too long. 			 */
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_TAGTOOLONG
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_REFTAG_HOLD
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|fnvpair_value_int32
argument_list|(
name|elem
argument_list|)
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|fnvlist_free
argument_list|(
name|errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_release_one
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|holdarg
modifier|*
name|ha
init|=
name|arg
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|existing_holds
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|ha
operator|->
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|lzc_get_holds
argument_list|(
name|name
argument_list|,
operator|&
name|existing_holds
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ha
operator|->
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|existing_holds
argument_list|,
name|ha
operator|->
name|tag
argument_list|)
condition|)
block|{
name|ha
operator|->
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
else|else
block|{
name|nvlist_t
modifier|*
name|torelease
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|torelease
argument_list|,
name|ha
operator|->
name|tag
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|ha
operator|->
name|nvl
argument_list|,
name|name
argument_list|,
name|torelease
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|torelease
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ha
operator|->
name|recursive
condition|)
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|zfs_release_one
argument_list|,
name|ha
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_release
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|holdarg
name|ha
decl_stmt|;
name|nvlist_t
modifier|*
name|errors
init|=
name|NULL
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|ha
operator|.
name|nvl
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|ha
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
name|ha
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|ha
operator|.
name|recursive
operator|=
name|recursive
expr_stmt|;
name|ha
operator|.
name|error
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_release_one
argument_list|(
name|zfs_handle_dup
argument_list|(
name|zhp
argument_list|)
argument_list|,
operator|&
name|ha
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_empty
argument_list|(
name|ha
operator|.
name|nvl
argument_list|)
condition|)
block|{
name|fnvlist_free
argument_list|(
name|ha
operator|.
name|nvl
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ha
operator|.
name|error
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot release hold from snapshot '%s@%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ESRCH
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_REFTAG_RELE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|ret
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|lzc_release
argument_list|(
name|ha
operator|.
name|nvl
argument_list|,
operator|&
name|errors
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|ha
operator|.
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* There may be errors even in the success case. */
name|fnvlist_free
argument_list|(
name|errors
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_empty
argument_list|(
name|errors
argument_list|)
condition|)
block|{
comment|/* no hold-specific errors */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot release"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errors
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errors
argument_list|,
name|elem
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot release hold from snapshot '%s'"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fnvpair_value_int32
argument_list|(
name|elem
argument_list|)
condition|)
block|{
case|case
name|ESRCH
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_REFTAG_RELE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|fnvpair_value_int32
argument_list|(
name|elem
argument_list|)
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|fnvlist_free
argument_list|(
name|errors
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_get_fsacl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvl
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|int
name|nvsz
init|=
literal|2048
decl_stmt|;
name|void
modifier|*
name|nvbuf
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
operator|||
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
name|tryagain
label|:
name|nvbuf
operator|=
name|malloc
argument_list|(
name|nvsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvbuf
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
operator|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
name|nvsz
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uintptr_t
operator|)
name|nvbuf
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_GET_FSACL
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get permissions on '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOMEM
case|:
name|free
argument_list|(
name|nvbuf
argument_list|)
expr_stmt|;
name|nvsz
operator|=
name|zc
operator|.
name|zc_nvlist_dst_size
expr_stmt|;
goto|goto
name|tryagain
goto|;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* success */
name|int
name|rc
init|=
name|nvlist_unpack
argument_list|(
name|nvbuf
argument_list|,
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|,
name|nvl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get permissions on '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|rc
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|nvbuf
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_set_fsacl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|boolean_t
name|un
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
modifier|*
name|nvbuf
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|nvsz
decl_stmt|;
name|int
name|err
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
operator|||
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
name|err
operator|=
name|nvlist_size
argument_list|(
name|nvl
argument_list|,
operator|&
name|nvsz
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvbuf
operator|=
name|malloc
argument_list|(
name|nvsz
argument_list|)
expr_stmt|;
name|err
operator|=
name|nvlist_pack
argument_list|(
name|nvl
argument_list|,
operator|&
name|nvbuf
argument_list|,
operator|&
name|nvsz
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src_size
operator|=
name|nvsz
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_src
operator|=
operator|(
name|uintptr_t
operator|)
name|nvbuf
expr_stmt|;
name|zc
operator|.
name|zc_perm_action
operator|=
name|un
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_FSACL
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot set permissions on '%s'"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|nvbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_get_holds
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvl
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|err
operator|=
name|lzc_get_holds
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot get holds for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADTYPE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
name|err
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|zfs_standard_error_fmt
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert the zvol's volume size to an appropriate reservation.  * Note: If this routine is updated, it is necessary to update the ZFS test  * suite's shell version in reservation.kshlib.  */
end_comment

begin_function
name|uint64_t
name|zvol_volsize_to_reservation
parameter_list|(
name|uint64_t
name|volsize
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|uint64_t
name|numdb
decl_stmt|;
name|uint64_t
name|nblocks
decl_stmt|,
name|volblocksize
decl_stmt|;
name|int
name|ncopies
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COPIES
argument_list|)
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
condition|)
name|ncopies
operator|=
name|atoi
argument_list|(
name|strval
argument_list|)
expr_stmt|;
else|else
name|ncopies
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|volblocksize
argument_list|)
operator|!=
literal|0
condition|)
name|volblocksize
operator|=
name|ZVOL_DEFAULT_BLOCKSIZE
expr_stmt|;
name|nblocks
operator|=
name|volsize
operator|/
name|volblocksize
expr_stmt|;
comment|/* start with metadnode L0-L6 */
name|numdb
operator|=
literal|7
expr_stmt|;
comment|/* calculate number of indirects */
while|while
condition|(
name|nblocks
operator|>
literal|1
condition|)
block|{
name|nblocks
operator|+=
name|DNODES_PER_LEVEL
operator|-
literal|1
expr_stmt|;
name|nblocks
operator|/=
name|DNODES_PER_LEVEL
expr_stmt|;
name|numdb
operator|+=
name|nblocks
expr_stmt|;
block|}
name|numdb
operator|*=
name|MIN
argument_list|(
name|SPA_DVAS_PER_BP
argument_list|,
name|ncopies
operator|+
literal|1
argument_list|)
expr_stmt|;
name|volsize
operator|*=
name|ncopies
expr_stmt|;
comment|/* 	 * this is exactly DN_MAX_INDBLKSHIFT when metadata isn't 	 * compressed, but in practice they compress down to about 	 * 1100 bytes 	 */
name|numdb
operator|*=
literal|1ULL
operator|<<
name|DN_MAX_INDBLKSHIFT
expr_stmt|;
name|volsize
operator|+=
name|numdb
expr_stmt|;
return|return
operator|(
name|volsize
operator|)
return|;
block|}
end_function

end_unit

