begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  * Copyright 2015 RackTop Systems.  * Copyright 2016 Nexenta Systems, Inc.  */
end_comment

begin_comment
comment|/*  * Pool import support functions.  *  * To import a pool, we rely on reading the configuration information from the  * ZFS label of each device.  If we successfully read the label, then we  * organize the configuration information in the following hierarchy:  *  * 	pool guid -> toplevel vdev guid -> label txg  *  * Duplicate entries matching this same tuple will be discarded.  Once we have  * examined every device, we pick the best label txg config for each toplevel  * vdev.  We then arrange these toplevel vdevs into a complete pool config, and  * update any paths that have changed.  Finally, we attempt to import the pool  * using our derived config, and record the results.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<devid.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vtoc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dktp/fdisk.h>
end_include

begin_include
include|#
directive|include
file|<sys/efi_partition.h>
end_include

begin_include
include|#
directive|include
file|<thread_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|"libzfs.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_comment
comment|/*  * Intermediate structures used to gather configuration information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|config_entry
block|{
name|uint64_t
name|ce_txg
decl_stmt|;
name|nvlist_t
modifier|*
name|ce_config
decl_stmt|;
name|struct
name|config_entry
modifier|*
name|ce_next
decl_stmt|;
block|}
name|config_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|vdev_entry
block|{
name|uint64_t
name|ve_guid
decl_stmt|;
name|config_entry_t
modifier|*
name|ve_configs
decl_stmt|;
name|struct
name|vdev_entry
modifier|*
name|ve_next
decl_stmt|;
block|}
name|vdev_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|pool_entry
block|{
name|uint64_t
name|pe_guid
decl_stmt|;
name|vdev_entry_t
modifier|*
name|pe_vdevs
decl_stmt|;
name|struct
name|pool_entry
modifier|*
name|pe_next
decl_stmt|;
block|}
name|pool_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|name_entry
block|{
name|char
modifier|*
name|ne_name
decl_stmt|;
name|uint64_t
name|ne_guid
decl_stmt|;
name|struct
name|name_entry
modifier|*
name|ne_next
decl_stmt|;
block|}
name|name_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|pool_list
block|{
name|pool_entry_t
modifier|*
name|pools
decl_stmt|;
name|name_entry_t
modifier|*
name|names
decl_stmt|;
block|}
name|pool_list_t
typedef|;
end_typedef

begin_function
specifier|static
name|char
modifier|*
name|get_devid
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|minor
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|devid_get
argument_list|(
name|fd
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|devid_get_minor_name
argument_list|(
name|fd
argument_list|,
operator|&
name|minor
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|devid_str_encode
argument_list|(
name|devid
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|!=
name|NULL
condition|)
name|devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through and fix up any path and/or devid information for the given vdev  * configuration.  */
end_comment

begin_function
specifier|static
name|int
name|fix_paths
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|name_entry_t
modifier|*
name|names
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|name_entry_t
modifier|*
name|ne
decl_stmt|,
modifier|*
name|best
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|devid
decl_stmt|;
name|int
name|matched
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|fix_paths
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|names
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * This is a leaf (file or disk) vdev.  In either case, go through 	 * the name list and see if we find a matching guid.  If so, replace 	 * the path and see if we can calculate a new devid. 	 * 	 * There may be multiple names associated with a particular guid, in 	 * which case we have overlapping slices or multiple paths to the same 	 * disk.  If this is the case, then we want to pick the path that is 	 * the most similar to the original, where "most similar" is the number 	 * of matching characters starting from the end of the path.  This will 	 * preserve slice numbers even if the disks have been reorganized, and 	 * will also catch preferred disk names if multiple paths exist. 	 */
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|path
argument_list|)
operator|!=
literal|0
condition|)
name|path
operator|=
name|NULL
expr_stmt|;
name|matched
operator|=
literal|0
expr_stmt|;
name|best
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ne
operator|=
name|names
init|;
name|ne
operator|!=
name|NULL
condition|;
name|ne
operator|=
name|ne
operator|->
name|ne_next
control|)
block|{
if|if
condition|(
name|ne
operator|->
name|ne_guid
operator|==
name|guid
condition|)
block|{
specifier|const
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|best
operator|=
name|ne
expr_stmt|;
break|break;
block|}
name|src
operator|=
name|ne
operator|->
name|ne_name
operator|+
name|strlen
argument_list|(
name|ne
operator|->
name|ne_name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|dst
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|src
operator|>=
name|ne
operator|->
name|ne_name
operator|&&
name|dst
operator|>=
name|path
condition|;
name|src
operator|--
operator|,
name|dst
operator|--
operator|,
name|count
operator|++
control|)
if|if
condition|(
operator|*
name|src
operator|!=
operator|*
name|dst
condition|)
break|break;
comment|/* 			 * At this point, 'count' is the number of characters 			 * matched from the end. 			 */
if|if
condition|(
name|count
operator|>
name|matched
operator|||
name|best
operator|==
name|NULL
condition|)
block|{
name|best
operator|=
name|ne
expr_stmt|;
name|matched
operator|=
name|count
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|best
operator|->
name|ne_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|devid
operator|=
name|get_devid
argument_list|(
name|best
operator|->
name|ne_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
name|devid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|devid_str_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|devid_str_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the given configuration to the list of known devices.  */
end_comment

begin_function
specifier|static
name|int
name|add_config
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|pool_list_t
modifier|*
name|pl
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|uint64_t
name|pool_guid
decl_stmt|,
name|vdev_guid
decl_stmt|,
name|top_guid
decl_stmt|,
name|txg
decl_stmt|,
name|state
decl_stmt|;
name|pool_entry_t
modifier|*
name|pe
decl_stmt|;
name|vdev_entry_t
modifier|*
name|ve
decl_stmt|;
name|config_entry_t
modifier|*
name|ce
decl_stmt|;
name|name_entry_t
modifier|*
name|ne
decl_stmt|;
comment|/* 	 * If this is a hot spare not currently in use or level 2 cache 	 * device, add it to the list of names to translate, but don't do 	 * anything else. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|state
operator|==
name|POOL_STATE_SPARE
operator|||
name|state
operator|==
name|POOL_STATE_L2CACHE
operator|)
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|vdev_guid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ne
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|name_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ne
operator|->
name|ne_name
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ne
operator|->
name|ne_guid
operator|=
name|vdev_guid
expr_stmt|;
name|ne
operator|->
name|ne_next
operator|=
name|pl
operator|->
name|names
expr_stmt|;
name|pl
operator|->
name|names
operator|=
name|ne
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we have a valid config but cannot read any of these fields, then 	 * it means we have a half-initialized label.  In vdev_label_init() 	 * we write a label with txg == 0 so that we can identify the device 	 * in case the user refers to the same disk later on.  If we fail to 	 * create the pool, we'll be left with a label in this state 	 * which should not be considered part of a valid pool. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|vdev_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TOP_GUID
argument_list|,
operator|&
name|top_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|!=
literal|0
operator|||
name|txg
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * First, see if we know about this pool.  If not, then add it to the 	 * list of known pools. 	 */
for|for
control|(
name|pe
operator|=
name|pl
operator|->
name|pools
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|pe
operator|->
name|pe_next
control|)
block|{
if|if
condition|(
name|pe
operator|->
name|pe_guid
operator|==
name|pool_guid
condition|)
break|break;
block|}
if|if
condition|(
name|pe
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pe
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|pool_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pe
operator|->
name|pe_guid
operator|=
name|pool_guid
expr_stmt|;
name|pe
operator|->
name|pe_next
operator|=
name|pl
operator|->
name|pools
expr_stmt|;
name|pl
operator|->
name|pools
operator|=
name|pe
expr_stmt|;
block|}
comment|/* 	 * Second, see if we know about this toplevel vdev.  Add it if its 	 * missing. 	 */
for|for
control|(
name|ve
operator|=
name|pe
operator|->
name|pe_vdevs
init|;
name|ve
operator|!=
name|NULL
condition|;
name|ve
operator|=
name|ve
operator|->
name|ve_next
control|)
block|{
if|if
condition|(
name|ve
operator|->
name|ve_guid
operator|==
name|top_guid
condition|)
break|break;
block|}
if|if
condition|(
name|ve
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ve
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ve
operator|->
name|ve_guid
operator|=
name|top_guid
expr_stmt|;
name|ve
operator|->
name|ve_next
operator|=
name|pe
operator|->
name|pe_vdevs
expr_stmt|;
name|pe
operator|->
name|pe_vdevs
operator|=
name|ve
expr_stmt|;
block|}
comment|/* 	 * Third, see if we have a config with a matching transaction group.  If 	 * so, then we do nothing.  Otherwise, add it to the list of known 	 * configs. 	 */
for|for
control|(
name|ce
operator|=
name|ve
operator|->
name|ve_configs
init|;
name|ce
operator|!=
name|NULL
condition|;
name|ce
operator|=
name|ce
operator|->
name|ce_next
control|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_txg
operator|==
name|txg
condition|)
break|break;
block|}
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ce
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|config_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ce
operator|->
name|ce_txg
operator|=
name|txg
expr_stmt|;
name|ce
operator|->
name|ce_config
operator|=
name|config
expr_stmt|;
name|ce
operator|->
name|ce_next
operator|=
name|ve
operator|->
name|ve_configs
expr_stmt|;
name|ve
operator|->
name|ve_configs
operator|=
name|ce
expr_stmt|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * At this point we've successfully added our config to the list of 	 * known configs.  The last thing to do is add the vdev guid -> path 	 * mappings so that we can fix up the configuration as necessary before 	 * doing the import. 	 */
if|if
condition|(
operator|(
name|ne
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|name_entry_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|ne
operator|->
name|ne_name
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ne
operator|->
name|ne_guid
operator|=
name|vdev_guid
expr_stmt|;
name|ne
operator|->
name|ne_next
operator|=
name|pl
operator|->
name|names
expr_stmt|;
name|pl
operator|->
name|names
operator|=
name|ne
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the named pool matches the given GUID.  */
end_comment

begin_function
specifier|static
name|int
name|pool_active
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
modifier|*
name|isactive
parameter_list|)
block|{
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|uint64_t
name|theguid
decl_stmt|;
if|if
condition|(
name|zpool_open_silent
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
operator|&
name|zhp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
block|{
operator|*
name|isactive
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|theguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
operator|*
name|isactive
operator|=
operator|(
name|theguid
operator|==
name|guid
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|refresh_config
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|,
name|dstbuf_size
decl_stmt|;
if|if
condition|(
name|zcmd_write_conf_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|config
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dstbuf_size
operator|=
name|MAX
argument_list|(
name|CONFIG_BUF_MINSIZE
argument_list|,
name|zc
operator|.
name|zc_nvlist_conf_size
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_alloc_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|dstbuf_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_POOL_TRYIMPORT
argument_list|,
operator|&
name|zc
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOMEM
condition|)
block|{
if|if
condition|(
name|zcmd_expand_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|zcmd_read_dst_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
operator|&
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if the vdev id is a hole in the namespace.  */
end_comment

begin_function
name|boolean_t
name|vdev_is_hole
parameter_list|(
name|uint64_t
modifier|*
name|hole_array
parameter_list|,
name|uint_t
name|holes
parameter_list|,
name|uint_t
name|id
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|holes
condition|;
name|c
operator|++
control|)
block|{
comment|/* Top-level is a hole */
if|if
condition|(
name|hole_array
index|[
name|c
index|]
operator|==
name|id
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert our list of pools into the definitive set of configurations.  We  * start by picking the best config for each toplevel vdev.  Once that's done,  * we assemble the toplevel vdevs into a full config for the pool.  We make a  * pass to fix up any incorrect paths, and then add it to the main list to  * return to the user.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|get_configs
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|pool_list_t
modifier|*
name|pl
parameter_list|,
name|boolean_t
name|active_ok
parameter_list|)
block|{
name|pool_entry_t
modifier|*
name|pe
decl_stmt|;
name|vdev_entry_t
modifier|*
name|ve
decl_stmt|;
name|config_entry_t
modifier|*
name|ce
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|,
modifier|*
name|config
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|nvtop
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|boolean_t
name|config_seen
decl_stmt|;
name|uint64_t
name|best_txg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|hostname
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|uint_t
name|children
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
init|=
name|NULL
decl_stmt|;
name|uint_t
name|holes
decl_stmt|;
name|uint64_t
modifier|*
name|hole_array
decl_stmt|,
name|max_id
decl_stmt|;
name|uint_t
name|c
decl_stmt|;
name|boolean_t
name|isactive
decl_stmt|;
name|uint64_t
name|hostid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|boolean_t
name|found_one
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|valid_top_config
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|pe
operator|=
name|pl
operator|->
name|pools
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|pe
operator|->
name|pe_next
control|)
block|{
name|uint64_t
name|id
decl_stmt|,
name|max_txg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|config_seen
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 		 * Iterate over all toplevel vdevs.  Grab the pool configuration 		 * from the first one we find, and then go through the rest and 		 * add them as necessary to the 'vdevs' member of the config. 		 */
for|for
control|(
name|ve
operator|=
name|pe
operator|->
name|pe_vdevs
init|;
name|ve
operator|!=
name|NULL
condition|;
name|ve
operator|=
name|ve
operator|->
name|ve_next
control|)
block|{
comment|/* 			 * Determine the best configuration for this vdev by 			 * selecting the config with the latest transaction 			 * group. 			 */
name|best_txg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ce
operator|=
name|ve
operator|->
name|ve_configs
init|;
name|ce
operator|!=
name|NULL
condition|;
name|ce
operator|=
name|ce
operator|->
name|ce_next
control|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_txg
operator|>
name|best_txg
condition|)
block|{
name|tmp
operator|=
name|ce
operator|->
name|ce_config
expr_stmt|;
name|best_txg
operator|=
name|ce
operator|->
name|ce_txg
expr_stmt|;
block|}
block|}
comment|/* 			 * We rely on the fact that the max txg for the 			 * pool will contain the most up-to-date information 			 * about the valid top-levels in the vdev namespace. 			 */
if|if
condition|(
name|best_txg
operator|>
name|max_txg
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_CHILDREN
argument_list|,
name|DATA_TYPE_UINT64
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOLE_ARRAY
argument_list|,
name|DATA_TYPE_UINT64_ARRAY
argument_list|)
expr_stmt|;
name|max_txg
operator|=
name|best_txg
expr_stmt|;
name|hole_array
operator|=
name|NULL
expr_stmt|;
name|holes
operator|=
literal|0
expr_stmt|;
name|max_id
operator|=
literal|0
expr_stmt|;
name|valid_top_config
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_VDEV_CHILDREN
argument_list|,
operator|&
name|max_id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_CHILDREN
argument_list|,
name|max_id
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|valid_top_config
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64_array
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_HOLE_ARRAY
argument_list|,
operator|&
name|hole_array
argument_list|,
operator|&
name|holes
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOLE_ARRAY
argument_list|,
name|hole_array
argument_list|,
name|holes
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|config_seen
condition|)
block|{
comment|/* 				 * Copy the relevant pieces of data to the pool 				 * configuration: 				 * 				 *	version 				 *	pool guid 				 *	name 				 *	comment (if available) 				 *	pool state 				 *	hostid (if available) 				 *	hostname (if available) 				 */
name|uint64_t
name|state
decl_stmt|,
name|version
decl_stmt|;
name|char
modifier|*
name|comment
init|=
name|NULL
decl_stmt|;
name|version
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|guid
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
name|guid
argument_list|)
expr_stmt|;
name|name
operator|=
name|fnvlist_lookup_string
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|)
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_COMMENT
argument_list|,
operator|&
name|comment
argument_list|)
operator|==
literal|0
condition|)
name|fnvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_COMMENT
argument_list|,
name|comment
argument_list|)
expr_stmt|;
name|state
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|hostid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|hostid
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|fnvlist_lookup_string
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|)
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
name|config_seen
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 			 * Add this top-level vdev to the child array. 			 */
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|tmp
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvtop
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvtop
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
operator|&
name|id
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>=
name|children
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|newchild
decl_stmt|;
name|newchild
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
operator|(
name|id
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newchild
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|newchild
index|[
name|c
index|]
operator|=
name|child
index|[
name|c
index|]
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
name|newchild
expr_stmt|;
name|children
operator|=
name|id
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_dup
argument_list|(
name|nvtop
argument_list|,
operator|&
name|child
index|[
name|id
index|]
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
block|}
comment|/* 		 * If we have information about all the top-levels then 		 * clean up the nvlist which we've constructed. This 		 * means removing any extraneous devices that are 		 * beyond the valid range or adding devices to the end 		 * of our array which appear to be missing. 		 */
if|if
condition|(
name|valid_top_config
condition|)
block|{
if|if
condition|(
name|max_id
operator|<
name|children
condition|)
block|{
for|for
control|(
name|c
operator|=
name|max_id
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|children
operator|=
name|max_id
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max_id
operator|>
name|children
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|newchild
decl_stmt|;
name|newchild
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
operator|(
name|max_id
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newchild
operator|==
name|NULL
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|newchild
index|[
name|c
index|]
operator|=
name|child
index|[
name|c
index|]
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
name|newchild
expr_stmt|;
name|children
operator|=
name|max_id
expr_stmt|;
block|}
block|}
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * The vdev namespace may contain holes as a result of 		 * device removal. We must add them back into the vdev 		 * tree before we process any missing devices. 		 */
if|if
condition|(
name|holes
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|valid_top_config
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|nvlist_t
modifier|*
name|holey
decl_stmt|;
if|if
condition|(
name|child
index|[
name|c
index|]
operator|!=
name|NULL
operator|||
operator|!
name|vdev_is_hole
argument_list|(
name|hole_array
argument_list|,
name|holes
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|holey
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
comment|/* 				 * Holes in the namespace are treated as 				 * "hole" top-level vdevs and have a 				 * special flag set on them. 				 */
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|holey
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_HOLE
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|holey
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|holey
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
literal|0ULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|holey
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|child
index|[
name|c
index|]
operator|=
name|holey
expr_stmt|;
block|}
block|}
comment|/* 		 * Look for any missing top-level vdevs.  If this is the case, 		 * create a faked up 'missing' vdev as a placeholder.  We cannot 		 * simply compress the child array, because the kernel performs 		 * certain checks to make sure the vdev IDs match their location 		 * in the configuration. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|child
index|[
name|c
index|]
operator|==
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|missing
decl_stmt|;
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|missing
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|missing
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_MISSING
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|missing
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|missing
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
literal|0ULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|missing
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|child
index|[
name|c
index|]
operator|=
name|missing
expr_stmt|;
block|}
block|}
comment|/* 		 * Put all of this pool's top-level vdevs into a root vdev. 		 */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
literal|0ULL
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|children
operator|=
literal|0
expr_stmt|;
name|child
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Go through and fix up any paths and/or devids based on our 		 * known list of vdev GUID -> path mappings. 		 */
if|if
condition|(
name|fix_paths
argument_list|(
name|nvroot
argument_list|,
name|pl
operator|->
name|names
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
comment|/* 		 * Add the root vdev to this pool's configuration. 		 */
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|nvroot
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
goto|goto
name|nomem
goto|;
block|}
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
comment|/* 		 * zdb uses this path to report on active pools that were 		 * imported or created using -R. 		 */
if|if
condition|(
name|active_ok
condition|)
goto|goto
name|add_pool
goto|;
comment|/* 		 * Determine if this pool is currently active, in which case we 		 * can't actually import it. 		 */
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_active
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|guid
argument_list|,
operator|&
name|isactive
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|isactive
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|nvl
operator|=
name|refresh_config
argument_list|(
name|hdl
argument_list|,
name|config
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|nvl
expr_stmt|;
comment|/* 		 * Go through and update the paths for spares, now that we have 		 * them. 		 */
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fix_paths
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|pl
operator|->
name|names
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
block|}
block|}
comment|/* 		 * Update the paths for l2cache devices. 		 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2cache
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fix_paths
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|,
name|pl
operator|->
name|names
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
block|}
block|}
comment|/* 		 * Restore the original information read from the actual label. 		 */
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|DATA_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostid
operator|!=
literal|0
condition|)
block|{
name|verify
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|hostid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|add_pool
label|:
comment|/* 		 * Add this pool to the list of configs. 		 */
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|ret
argument_list|,
name|name
argument_list|,
name|config
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|found_one
operator|=
name|B_TRUE
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_one
condition|)
block|{
name|nvlist_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|nomem
label|:
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|error
label|:
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the offset of the given label.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|label_offset
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|P2PHASE_TYPED
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|+
operator|(
name|l
operator|<
name|VDEV_LABELS
operator|/
literal|2
condition|?
literal|0
else|:
name|size
operator|-
name|VDEV_LABELS
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file descriptor, read the label information and return an nvlist  * describing the configuration, if there is one.  */
end_comment

begin_function
name|int
name|zpool_read_label
parameter_list|(
name|int
name|fd
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|int
name|l
decl_stmt|;
name|vdev_label_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|state
decl_stmt|,
name|txg
decl_stmt|,
name|size
decl_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|statbuf
operator|.
name|st_size
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|pread64
argument_list|(
name|fd
argument_list|,
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|label_offset
argument_list|(
name|size
argument_list|,
name|l
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|label
operator|->
name|vl_vdev_phys
operator|.
name|vp_nvlist
argument_list|,
sizeof|sizeof
argument_list|(
name|label
operator|->
name|vl_vdev_phys
operator|.
name|vp_nvlist
argument_list|)
argument_list|,
name|config
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
operator|||
name|state
operator|>
name|POOL_STATE_L2CACHE
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|config
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
name|state
operator|!=
name|POOL_STATE_L2CACHE
operator|&&
operator|(
name|nvlist_lookup_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|!=
literal|0
operator|||
name|txg
operator|==
literal|0
operator|)
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|config
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|label
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|rdsk_node
block|{
name|char
modifier|*
name|rn_name
decl_stmt|;
name|int
name|rn_dfd
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|rn_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|rn_config
decl_stmt|;
name|avl_tree_t
modifier|*
name|rn_avl
decl_stmt|;
name|avl_node_t
name|rn_node
decl_stmt|;
name|boolean_t
name|rn_nozpool
decl_stmt|;
block|}
name|rdsk_node_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|slice_cache_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|nm1
init|=
operator|(
operator|(
name|rdsk_node_t
operator|*
operator|)
name|arg1
operator|)
operator|->
name|rn_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm2
init|=
operator|(
operator|(
name|rdsk_node_t
operator|*
operator|)
name|arg2
operator|)
operator|->
name|rn_name
decl_stmt|;
name|char
modifier|*
name|nm1slice
decl_stmt|,
modifier|*
name|nm2slice
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 	 * slices zero and two are the most likely to provide results, 	 * so put those first 	 */
name|nm1slice
operator|=
name|strstr
argument_list|(
name|nm1
argument_list|,
literal|"s0"
argument_list|)
expr_stmt|;
name|nm2slice
operator|=
name|strstr
argument_list|(
name|nm2
argument_list|,
literal|"s0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm1slice
operator|&&
operator|!
name|nm2slice
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|nm1slice
operator|&&
name|nm2slice
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nm1slice
operator|=
name|strstr
argument_list|(
name|nm1
argument_list|,
literal|"s2"
argument_list|)
expr_stmt|;
name|nm2slice
operator|=
name|strstr
argument_list|(
name|nm2
argument_list|,
literal|"s2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm1slice
operator|&&
operator|!
name|nm2slice
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|nm1slice
operator|&&
name|nm2slice
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rv
operator|=
name|strcmp
argument_list|(
name|nm1
argument_list|,
name|nm2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|rv
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_one_slice
parameter_list|(
name|avl_tree_t
modifier|*
name|r
parameter_list|,
name|char
modifier|*
name|diskname
parameter_list|,
name|uint_t
name|partno
parameter_list|,
name|diskaddr_t
name|size
parameter_list|,
name|uint_t
name|blksz
parameter_list|)
block|{
name|rdsk_node_t
name|tmpnode
decl_stmt|;
name|rdsk_node_t
modifier|*
name|node
decl_stmt|;
name|char
name|sname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|tmpnode
operator|.
name|rn_name
operator|=
operator|&
name|sname
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tmpnode
operator|.
name|rn_name
argument_list|,
name|MAXNAMELEN
argument_list|,
literal|"%s%u"
argument_list|,
name|diskname
argument_list|,
name|partno
argument_list|)
expr_stmt|;
comment|/* 	 * protect against division by zero for disk labels that 	 * contain a bogus sector size 	 */
if|if
condition|(
name|blksz
operator|==
literal|0
condition|)
name|blksz
operator|=
name|DEV_BSIZE
expr_stmt|;
comment|/* too small to contain a zpool? */
if|if
condition|(
operator|(
name|size
operator|<
operator|(
name|SPA_MINDEVSIZE
operator|/
name|blksz
operator|)
operator|)
operator|&&
operator|(
name|node
operator|=
name|avl_find
argument_list|(
name|r
argument_list|,
operator|&
name|tmpnode
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|node
operator|->
name|rn_nozpool
operator|=
name|B_TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nozpool_all_slices
parameter_list|(
name|avl_tree_t
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|char
name|diskname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|diskname
argument_list|,
name|sname
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|diskname
argument_list|,
literal|'s'
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|diskname
argument_list|,
literal|'p'
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return;
name|ptr
index|[
literal|0
index|]
operator|=
literal|'s'
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDKMAP
condition|;
name|i
operator|++
control|)
name|check_one_slice
argument_list|(
name|r
argument_list|,
name|diskname
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
literal|'p'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|FD_NUMPART
condition|;
name|i
operator|++
control|)
name|check_one_slice
argument_list|(
name|r
argument_list|,
name|diskname
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_slices
parameter_list|(
name|avl_tree_t
modifier|*
name|r
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|struct
name|extvtoc
name|vtoc
decl_stmt|;
name|struct
name|dk_gpt
modifier|*
name|gpt
decl_stmt|;
name|char
name|diskname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|diskname
argument_list|,
name|sname
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|diskname
argument_list|,
literal|'s'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|isdigit
argument_list|(
name|ptr
index|[
literal|1
index|]
argument_list|)
condition|)
return|return;
name|ptr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|read_extvtoc
argument_list|(
name|fd
argument_list|,
operator|&
name|vtoc
argument_list|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDKMAP
condition|;
name|i
operator|++
control|)
name|check_one_slice
argument_list|(
name|r
argument_list|,
name|diskname
argument_list|,
name|i
argument_list|,
name|vtoc
operator|.
name|v_part
index|[
name|i
index|]
operator|.
name|p_size
argument_list|,
name|vtoc
operator|.
name|v_sectorsz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|efi_alloc_and_read
argument_list|(
name|fd
argument_list|,
operator|&
name|gpt
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * on x86 we'll still have leftover links that point 		 * to slices s[9-15], so use NDKMAP instead 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDKMAP
condition|;
name|i
operator|++
control|)
name|check_one_slice
argument_list|(
name|r
argument_list|,
name|diskname
argument_list|,
name|i
argument_list|,
name|gpt
operator|->
name|efi_parts
index|[
name|i
index|]
operator|.
name|p_size
argument_list|,
name|gpt
operator|->
name|efi_lbasize
argument_list|)
expr_stmt|;
comment|/* nodes p[1-4] are never used with EFI labels */
name|ptr
index|[
literal|0
index|]
operator|=
literal|'p'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|FD_NUMPART
condition|;
name|i
operator|++
control|)
name|check_one_slice
argument_list|(
name|r
argument_list|,
name|diskname
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|efi_free
argument_list|(
name|gpt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zpool_open_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rdsk_node_t
modifier|*
name|rn
init|=
name|arg
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|rn
operator|->
name|rn_nozpool
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|openat64
argument_list|(
name|rn
operator|->
name|rn_dfd
argument_list|,
name|rn
operator|->
name|rn_name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* symlink to a device that's no longer there */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|nozpool_all_slices
argument_list|(
name|rn
operator|->
name|rn_avl
argument_list|,
name|rn
operator|->
name|rn_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Ignore failed stats.  We only want regular 	 * files, character devs and block devs. 	 */
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISCHR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISBLK
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* this file is too small to hold a zpool */
if|if
condition|(
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|statbuf
operator|.
name|st_size
operator|<
name|SPA_MINDEVSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		 * Try to read the disk label first so we don't have to 		 * open a bunch of minor nodes that can't have a zpool. 		 */
name|check_slices
argument_list|(
name|rn
operator|->
name|rn_avl
argument_list|,
name|fd
argument_list|,
name|rn
operator|->
name|rn_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zpool_read_label
argument_list|(
name|fd
argument_list|,
operator|&
name|config
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|rn
operator|->
name|rn_hdl
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|rn
operator|->
name|rn_config
operator|=
name|config
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a file descriptor, clear (zero) the label information.  */
end_comment

begin_function
name|int
name|zpool_clear_label
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|int
name|l
decl_stmt|;
name|vdev_label_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|statbuf
operator|.
name|st_size
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|label
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|pwrite64
argument_list|(
name|fd
argument_list|,
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|label_offset
argument_list|(
name|size
argument_list|,
name|l
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a list of directories to search, find all pools stored on disk.  This  * includes partial pools which are not available to import.  If no args are  * given (argc is 0), then the default directory (/dev/dsk) is searched.  * poolname or guid (but not both) are provided by the caller when trying  * to import a specific pool.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|zpool_find_import_impl
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|importargs_t
modifier|*
name|iarg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|dirs
init|=
name|iarg
operator|->
name|paths
decl_stmt|;
name|struct
name|dirent64
modifier|*
name|dp
decl_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
modifier|*
name|dir
init|=
name|iarg
operator|->
name|path
decl_stmt|;
name|size_t
name|pathleft
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|default_dir
init|=
name|ZFS_DISK_ROOT
decl_stmt|;
name|pool_list_t
name|pools
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pool_entry_t
modifier|*
name|pe
decl_stmt|,
modifier|*
name|penext
decl_stmt|;
name|vdev_entry_t
modifier|*
name|ve
decl_stmt|,
modifier|*
name|venext
decl_stmt|;
name|config_entry_t
modifier|*
name|ce
decl_stmt|,
modifier|*
name|cenext
decl_stmt|;
name|name_entry_t
modifier|*
name|ne
decl_stmt|,
modifier|*
name|nenext
decl_stmt|;
name|avl_tree_t
name|slice_cache
decl_stmt|;
name|rdsk_node_t
modifier|*
name|slice
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
if|if
condition|(
name|dirs
operator|==
literal|0
condition|)
block|{
name|dirs
operator|=
literal|1
expr_stmt|;
name|dir
operator|=
operator|&
name|default_dir
expr_stmt|;
block|}
comment|/* 	 * Go through and read the label configuration information from every 	 * possible device, organizing the information according to pool GUID 	 * and toplevel GUID. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dirs
condition|;
name|i
operator|++
control|)
block|{
name|tpool_t
modifier|*
name|t
decl_stmt|;
name|char
name|rdsk
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|dfd
decl_stmt|;
name|boolean_t
name|config_failed
init|=
name|B_FALSE
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* use realpath to normalize the path */
if|if
condition|(
name|realpath
argument_list|(
name|dir
index|[
name|i
index|]
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|dir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|end
operator|=
operator|&
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
index|]
expr_stmt|;
operator|*
name|end
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|pathleft
operator|=
operator|&
name|path
index|[
sizeof|sizeof
argument_list|(
name|path
argument_list|)
index|]
operator|-
name|end
expr_stmt|;
comment|/* 		 * Using raw devices instead of block devices when we're 		 * reading the labels skips a bunch of slow operations during 		 * close(2) processing, so we replace /dev/dsk with /dev/rdsk. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
name|ZFS_DISK_ROOTD
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|rdsk
argument_list|,
name|ZFS_RDISK_ROOTD
argument_list|,
sizeof|sizeof
argument_list|(
name|rdsk
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|rdsk
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|rdsk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dfd
operator|=
name|open64
argument_list|(
name|rdsk
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|dirp
operator|=
name|fdopendir
argument_list|(
name|dfd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dfd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot open '%s'"
argument_list|)
argument_list|,
name|rdsk
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|avl_create
argument_list|(
operator|&
name|slice_cache
argument_list|,
name|slice_cache_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|rdsk_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|rdsk_node_t
argument_list|,
name|rn_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * This is not MT-safe, but we have no MT consumers of libzfs 		 */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir64
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|dp
operator|->
name|d_name
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|0
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
continue|continue;
name|slice
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
sizeof|sizeof
argument_list|(
name|rdsk_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|slice
operator|->
name|rn_name
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|slice
operator|->
name|rn_avl
operator|=
operator|&
name|slice_cache
expr_stmt|;
name|slice
operator|->
name|rn_dfd
operator|=
name|dfd
expr_stmt|;
name|slice
operator|->
name|rn_hdl
operator|=
name|hdl
expr_stmt|;
name|slice
operator|->
name|rn_nozpool
operator|=
name|B_FALSE
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|slice_cache
argument_list|,
name|slice
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * create a thread pool to do all of this in parallel; 		 * rn_nozpool is not protected, so this is racy in that 		 * multiple tasks could decide that the same slice can 		 * not hold a zpool, which is benign.  Also choose 		 * double the number of processors; we hold a lot of 		 * locks in the kernel, so going beyond this doesn't 		 * buy us much. 		 */
name|t
operator|=
name|tpool_create
argument_list|(
literal|1
argument_list|,
literal|2
operator|*
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|slice
operator|=
name|avl_first
argument_list|(
operator|&
name|slice_cache
argument_list|)
init|;
name|slice
condition|;
operator|(
name|slice
operator|=
name|avl_walk
argument_list|(
operator|&
name|slice_cache
argument_list|,
name|slice
argument_list|,
name|AVL_AFTER
argument_list|)
operator|)
control|)
operator|(
name|void
operator|)
name|tpool_dispatch
argument_list|(
name|t
argument_list|,
name|zpool_open_func
argument_list|,
name|slice
argument_list|)
expr_stmt|;
name|tpool_wait
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tpool_destroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|slice
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|slice_cache
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|slice
operator|->
name|rn_config
operator|!=
name|NULL
operator|&&
operator|!
name|config_failed
condition|)
block|{
name|nvlist_t
modifier|*
name|config
init|=
name|slice
operator|->
name|rn_config
decl_stmt|;
name|boolean_t
name|matched
init|=
name|B_TRUE
decl_stmt|;
if|if
condition|(
name|iarg
operator|->
name|poolname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|pname
decl_stmt|;
name|matched
operator|=
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|pname
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|iarg
operator|->
name|poolname
argument_list|,
name|pname
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iarg
operator|->
name|guid
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|this_guid
decl_stmt|;
name|matched
operator|=
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|this_guid
argument_list|)
operator|==
literal|0
operator|&&
name|iarg
operator|->
name|guid
operator|==
name|this_guid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matched
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * use the non-raw path for the config 					 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|end
argument_list|,
name|slice
operator|->
name|rn_name
argument_list|,
name|pathleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_config
argument_list|(
name|hdl
argument_list|,
operator|&
name|pools
argument_list|,
name|path
argument_list|,
name|config
argument_list|)
operator|!=
literal|0
condition|)
name|config_failed
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|slice
operator|->
name|rn_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
operator|&
name|slice_cache
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_failed
condition|)
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|get_configs
argument_list|(
name|hdl
argument_list|,
operator|&
name|pools
argument_list|,
name|iarg
operator|->
name|can_be_active
argument_list|)
expr_stmt|;
name|error
label|:
for|for
control|(
name|pe
operator|=
name|pools
operator|.
name|pools
init|;
name|pe
operator|!=
name|NULL
condition|;
name|pe
operator|=
name|penext
control|)
block|{
name|penext
operator|=
name|pe
operator|->
name|pe_next
expr_stmt|;
for|for
control|(
name|ve
operator|=
name|pe
operator|->
name|pe_vdevs
init|;
name|ve
operator|!=
name|NULL
condition|;
name|ve
operator|=
name|venext
control|)
block|{
name|venext
operator|=
name|ve
operator|->
name|ve_next
expr_stmt|;
for|for
control|(
name|ce
operator|=
name|ve
operator|->
name|ve_configs
init|;
name|ce
operator|!=
name|NULL
condition|;
name|ce
operator|=
name|cenext
control|)
block|{
name|cenext
operator|=
name|ce
operator|->
name|ce_next
expr_stmt|;
name|nvlist_free
argument_list|(
name|ce
operator|->
name|ce_config
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pe
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ne
operator|=
name|pools
operator|.
name|names
init|;
name|ne
operator|!=
name|NULL
condition|;
name|ne
operator|=
name|nenext
control|)
block|{
name|nenext
operator|=
name|ne
operator|->
name|ne_next
expr_stmt|;
name|free
argument_list|(
name|ne
operator|->
name|ne_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ne
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zpool_find_import
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|importargs_t
name|iarg
init|=
block|{
literal|0
block|}
decl_stmt|;
name|iarg
operator|.
name|paths
operator|=
name|argc
expr_stmt|;
name|iarg
operator|.
name|path
operator|=
name|argv
expr_stmt|;
return|return
operator|(
name|zpool_find_import_impl
argument_list|(
name|hdl
argument_list|,
operator|&
name|iarg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a cache file, return the contents as a list of importable pools.  * poolname or guid (but not both) are provided by the caller when trying  * to import a specific pool.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|zpool_find_import_cached
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|cachefile
parameter_list|,
name|char
modifier|*
name|poolname
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|stat64
name|statbuf
decl_stmt|;
name|nvlist_t
modifier|*
name|raw
decl_stmt|,
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|nvlist_t
modifier|*
name|pools
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|this_guid
decl_stmt|;
name|boolean_t
name|active
decl_stmt|;
name|verify
argument_list|(
name|poolname
operator|==
name|NULL
operator|||
name|guid
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|cachefile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADCACHE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to open cache file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fstat64
argument_list|(
name|fd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADCACHE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to get size of cache file"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|buf
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|statbuf
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|statbuf
operator|.
name|st_size
argument_list|)
operator|!=
name|statbuf
operator|.
name|st_size
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADCACHE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to read cache file contents"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|buf
argument_list|,
name|statbuf
operator|.
name|st_size
argument_list|,
operator|&
name|raw
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADCACHE
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid or corrupt cache file contents"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * Go through and get the current state of the pools and refresh their 	 * state. 	 */
if|if
condition|(
name|nvlist_alloc
argument_list|(
operator|&
name|pools
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|raw
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|src
operator|=
name|fnvpair_value_nvlist
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|name
operator|=
name|fnvlist_lookup_string
argument_list|(
name|src
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|poolname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|poolname
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|this_guid
operator|=
name|fnvlist_lookup_uint64
argument_list|(
name|src
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|!=
literal|0
operator|&&
name|guid
operator|!=
name|this_guid
condition|)
continue|continue;
if|if
condition|(
name|pool_active
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|this_guid
argument_list|,
operator|&
name|active
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|pools
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|active
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dst
operator|=
name|refresh_config
argument_list|(
name|hdl
argument_list|,
name|src
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|pools
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|pools
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|dst
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|pools
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
name|pools
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|name_or_guid_exists
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|importargs_t
modifier|*
name|import
init|=
name|data
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|import
operator|->
name|poolname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|pool_name
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|pool_name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pool_name
argument_list|,
name|import
operator|->
name|poolname
argument_list|)
operator|==
literal|0
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|pool_guid
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool_guid
operator|==
name|import
operator|->
name|guid
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zpool_search_import
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|importargs_t
modifier|*
name|import
parameter_list|)
block|{
name|verify
argument_list|(
name|import
operator|->
name|poolname
operator|==
name|NULL
operator|||
name|import
operator|->
name|guid
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|import
operator|->
name|unique
condition|)
name|import
operator|->
name|exists
operator|=
name|zpool_iter
argument_list|(
name|hdl
argument_list|,
name|name_or_guid_exists
argument_list|,
name|import
argument_list|)
expr_stmt|;
if|if
condition|(
name|import
operator|->
name|cachefile
operator|!=
name|NULL
condition|)
return|return
operator|(
name|zpool_find_import_cached
argument_list|(
name|hdl
argument_list|,
name|import
operator|->
name|cachefile
argument_list|,
name|import
operator|->
name|poolname
argument_list|,
name|import
operator|->
name|guid
argument_list|)
operator|)
return|;
return|return
operator|(
name|zpool_find_import_impl
argument_list|(
name|hdl
argument_list|,
name|import
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|find_guid
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|uint64_t
name|tmp
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|find_guid
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|guid
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|aux_cbdata
block|{
specifier|const
name|char
modifier|*
name|cb_type
decl_stmt|;
name|uint64_t
name|cb_guid
decl_stmt|;
name|zpool_handle_t
modifier|*
name|cb_zhp
decl_stmt|;
block|}
name|aux_cbdata_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|find_aux
parameter_list|(
name|zpool_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|aux_cbdata_t
modifier|*
name|cbp
init|=
name|data
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|list
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|count
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|zhp
operator|->
name|zpool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|cbp
operator|->
name|cb_type
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|list
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|cbp
operator|->
name|cb_guid
condition|)
block|{
name|cbp
operator|->
name|cb_zhp
operator|=
name|zhp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determines if the pool is in use.  If so, it returns true and the state of  * the pool as well as the name of the pool.  Both strings are allocated and  * must be freed by the caller.  */
end_comment

begin_function
name|int
name|zpool_in_use
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|pool_state_t
modifier|*
name|state
parameter_list|,
name|char
modifier|*
modifier|*
name|namestr
parameter_list|,
name|boolean_t
modifier|*
name|inuse
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|boolean_t
name|ret
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|vdev_guid
decl_stmt|;
name|zpool_handle_t
modifier|*
name|zhp
decl_stmt|;
name|nvlist_t
modifier|*
name|pool_config
decl_stmt|;
name|uint64_t
name|stateval
decl_stmt|,
name|isspare
decl_stmt|;
name|aux_cbdata_t
name|cb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|boolean_t
name|isactive
decl_stmt|;
operator|*
name|inuse
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|zpool_read_label
argument_list|(
name|fd
argument_list|,
operator|&
name|config
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|no_memory
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|stateval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateval
operator|!=
name|POOL_STATE_SPARE
operator|&&
name|stateval
operator|!=
name|POOL_STATE_L2CACHE
condition|)
block|{
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|stateval
condition|)
block|{
case|case
name|POOL_STATE_EXPORTED
case|:
comment|/* 		 * A pool with an exported state may in fact be imported 		 * read-only, so check the in-core state to see if it's 		 * active and imported read-only.  If it is, set 		 * its state to active. 		 */
if|if
condition|(
name|pool_active
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|guid
argument_list|,
operator|&
name|isactive
argument_list|)
operator|==
literal|0
operator|&&
name|isactive
operator|&&
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zpool_get_prop_int
argument_list|(
name|zhp
argument_list|,
name|ZPOOL_PROP_READONLY
argument_list|,
name|NULL
argument_list|)
condition|)
name|stateval
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
comment|/* 			 * All we needed the zpool handle for is the 			 * readonly prop check. 			 */
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|POOL_STATE_ACTIVE
case|:
comment|/* 		 * For an active pool, we have to determine if it's really part 		 * of a currently active pool (in which case the pool will exist 		 * and the guid will be the same), or whether it's part of an 		 * active pool that was disconnected without being explicitly 		 * exported. 		 */
if|if
condition|(
name|pool_active
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|guid
argument_list|,
operator|&
name|isactive
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isactive
condition|)
block|{
comment|/* 			 * Because the device may have been removed while 			 * offlined, we only report it as active if the vdev is 			 * still present in the config.  Otherwise, pretend like 			 * it's not in use. 			 */
if|if
condition|(
operator|(
name|zhp
operator|=
name|zpool_open_canfail
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|pool_config
operator|=
name|zpool_get_config
argument_list|(
name|zhp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|pool_config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|find_guid
argument_list|(
name|nvroot
argument_list|,
name|vdev_guid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 			 * If this is an active spare within another pool, we 			 * treat it like an unused hot spare.  This allows the 			 * user to create a pool with a hot spare that currently 			 * in use within another pool.  Since we return B_TRUE, 			 * libdiskmgt will continue to prevent generic consumers 			 * from using the device. 			 */
if|if
condition|(
name|ret
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
operator|&
name|isspare
argument_list|)
operator|==
literal|0
operator|&&
name|isspare
condition|)
name|stateval
operator|=
name|POOL_STATE_SPARE
expr_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
name|zpool_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stateval
operator|=
name|POOL_STATE_POTENTIALLY_ACTIVE
expr_stmt|;
name|ret
operator|=
name|B_TRUE
expr_stmt|;
block|}
break|break;
case|case
name|POOL_STATE_SPARE
case|:
comment|/* 		 * For a hot spare, it can be either definitively in use, or 		 * potentially active.  To determine if it's in use, we iterate 		 * over all pools in the system and search for one with a spare 		 * with a matching guid. 		 * 		 * Due to the shared nature of spares, we don't actually report 		 * the potentially active case as in use.  This means the user 		 * can freely create pools on the hot spares of exported pools, 		 * but to do otherwise makes the resulting code complicated, and 		 * we end up having to deal with this case anyway. 		 */
name|cb
operator|.
name|cb_zhp
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|cb_guid
operator|=
name|vdev_guid
expr_stmt|;
name|cb
operator|.
name|cb_type
operator|=
name|ZPOOL_CONFIG_SPARES
expr_stmt|;
if|if
condition|(
name|zpool_iter
argument_list|(
name|hdl
argument_list|,
name|find_aux
argument_list|,
operator|&
name|cb
argument_list|)
operator|==
literal|1
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|zpool_get_name
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|B_FALSE
expr_stmt|;
block|}
break|break;
case|case
name|POOL_STATE_L2CACHE
case|:
comment|/* 		 * Check if any pool is currently using this l2cache device. 		 */
name|cb
operator|.
name|cb_zhp
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|cb_guid
operator|=
name|vdev_guid
expr_stmt|;
name|cb
operator|.
name|cb_type
operator|=
name|ZPOOL_CONFIG_L2CACHE
expr_stmt|;
if|if
condition|(
name|zpool_iter
argument_list|(
name|hdl
argument_list|,
name|find_aux
argument_list|,
operator|&
name|cb
argument_list|)
operator|==
literal|1
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|zpool_get_name
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|B_FALSE
expr_stmt|;
block|}
break|break;
default|default:
name|ret
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|namestr
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cb
operator|.
name|cb_zhp
condition|)
name|zpool_close
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|state
operator|=
operator|(
name|pool_state_t
operator|)
name|stateval
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|cb_zhp
condition|)
name|zpool_close
argument_list|(
name|cb
operator|.
name|cb_zhp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
operator|*
name|inuse
operator|=
name|ret
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

