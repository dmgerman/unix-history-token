begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright (c) 2012, Joyent, Inc. All rights reserved.  * Copyright (c) 2012 Pawel Jakub Dawidek. All rights reserved.  * Copyright (c) 2013 Steven Hartland. All rights reserved.  * Copyright 2015, OmniTI Computer Consulting, Inc. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2016 Igor Kozhukhov<ikozhukhov@gmail.com>  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<umem.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<libzfs.h>
end_include

begin_include
include|#
directive|include
file|<libzfs_core.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"zfs_fletcher.h"
end_include

begin_include
include|#
directive|include
file|"libzfs_impl.h"
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_include
include|#
directive|include
file|<sha2.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddt.h>
end_include

begin_comment
comment|/* in libzfs_dataset.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|zfs_setprop_error
parameter_list|(
name|libzfs_handle_t
modifier|*
parameter_list|,
name|zfs_prop_t
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_receive_impl
parameter_list|(
name|libzfs_handle_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|recvflags_t
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|avl_tree_t
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|guid_to_name
parameter_list|(
name|libzfs_handle_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|boolean_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|zio_cksum_t
name|zero_cksum
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|dedup_arg
block|{
name|int
name|inputfd
decl_stmt|;
name|int
name|outputfd
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|dedup_hdl
decl_stmt|;
block|}
name|dedup_arg_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|progress_arg
block|{
name|zfs_handle_t
modifier|*
name|pa_zhp
decl_stmt|;
name|int
name|pa_fd
decl_stmt|;
name|boolean_t
name|pa_parsable
decl_stmt|;
block|}
name|progress_arg_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dataref
block|{
name|uint64_t
name|ref_guid
decl_stmt|;
name|uint64_t
name|ref_object
decl_stmt|;
name|uint64_t
name|ref_offset
decl_stmt|;
block|}
name|dataref_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dedup_entry
block|{
name|struct
name|dedup_entry
modifier|*
name|dde_next
decl_stmt|;
name|zio_cksum_t
name|dde_chksum
decl_stmt|;
name|uint64_t
name|dde_prop
decl_stmt|;
name|dataref_t
name|dde_ref
decl_stmt|;
block|}
name|dedup_entry_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAX_DDT_PHYSMEM_PERCENT
value|20
end_define

begin_define
define|#
directive|define
name|SMALLEST_POSSIBLE_MAX_DDT_MB
value|128
end_define

begin_typedef
typedef|typedef
struct|struct
name|dedup_table
block|{
name|dedup_entry_t
modifier|*
modifier|*
name|dedup_hash_array
decl_stmt|;
name|umem_cache_t
modifier|*
name|ddecache
decl_stmt|;
name|uint64_t
name|max_ddt_size
decl_stmt|;
comment|/* max dedup table size in bytes */
name|uint64_t
name|cur_ddt_size
decl_stmt|;
comment|/* current dedup table size in bytes */
name|uint64_t
name|ddt_count
decl_stmt|;
name|int
name|numhashbits
decl_stmt|;
name|boolean_t
name|ddt_full
decl_stmt|;
block|}
name|dedup_table_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|high_order_bit
parameter_list|(
name|uint64_t
name|n
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|n
operator|!=
literal|0
condition|;
name|count
operator|++
control|)
name|n
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ssread
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|size_t
name|outlen
decl_stmt|;
if|if
condition|(
operator|(
name|outlen
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|outlen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_hash_append
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|dedup_table_t
modifier|*
name|ddt
parameter_list|,
name|dedup_entry_t
modifier|*
modifier|*
name|ddepp
parameter_list|,
name|zio_cksum_t
modifier|*
name|cs
parameter_list|,
name|uint64_t
name|prop
parameter_list|,
name|dataref_t
modifier|*
name|dr
parameter_list|)
block|{
name|dedup_entry_t
modifier|*
name|dde
decl_stmt|;
if|if
condition|(
name|ddt
operator|->
name|cur_ddt_size
operator|>=
name|ddt
operator|->
name|max_ddt_size
condition|)
block|{
if|if
condition|(
name|ddt
operator|->
name|ddt_full
operator|==
name|B_FALSE
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Dedup table full.  Deduplication will continue "
literal|"with existing table entries"
argument_list|)
argument_list|)
expr_stmt|;
name|ddt
operator|->
name|ddt_full
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|dde
operator|=
name|umem_cache_alloc
argument_list|(
name|ddt
operator|->
name|ddecache
argument_list|,
name|UMEM_DEFAULT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
operator|*
name|ddepp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dde
operator|->
name|dde_next
operator|=
name|NULL
expr_stmt|;
name|dde
operator|->
name|dde_chksum
operator|=
operator|*
name|cs
expr_stmt|;
name|dde
operator|->
name|dde_prop
operator|=
name|prop
expr_stmt|;
name|dde
operator|->
name|dde_ref
operator|=
operator|*
name|dr
expr_stmt|;
operator|*
name|ddepp
operator|=
name|dde
expr_stmt|;
name|ddt
operator|->
name|cur_ddt_size
operator|+=
sizeof|sizeof
argument_list|(
name|dedup_entry_t
argument_list|)
expr_stmt|;
name|ddt
operator|->
name|ddt_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Using the specified dedup table, do a lookup for an entry with  * the checksum cs.  If found, return the block's reference info  * in *dr. Otherwise, insert a new entry in the dedup table, using  * the reference information specified by *dr.  *  * return value:  true - entry was found  *		  false - entry was not found  */
end_comment

begin_function
specifier|static
name|boolean_t
name|ddt_update
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|dedup_table_t
modifier|*
name|ddt
parameter_list|,
name|zio_cksum_t
modifier|*
name|cs
parameter_list|,
name|uint64_t
name|prop
parameter_list|,
name|dataref_t
modifier|*
name|dr
parameter_list|)
block|{
name|uint32_t
name|hashcode
decl_stmt|;
name|dedup_entry_t
modifier|*
modifier|*
name|ddepp
decl_stmt|;
name|hashcode
operator|=
name|BF64_GET
argument_list|(
name|cs
operator|->
name|zc_word
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|ddt
operator|->
name|numhashbits
argument_list|)
expr_stmt|;
for|for
control|(
name|ddepp
operator|=
operator|&
operator|(
name|ddt
operator|->
name|dedup_hash_array
index|[
name|hashcode
index|]
operator|)
init|;
operator|*
name|ddepp
operator|!=
name|NULL
condition|;
name|ddepp
operator|=
operator|&
operator|(
operator|(
operator|*
name|ddepp
operator|)
operator|->
name|dde_next
operator|)
control|)
block|{
if|if
condition|(
name|ZIO_CHECKSUM_EQUAL
argument_list|(
operator|(
operator|(
operator|*
name|ddepp
operator|)
operator|->
name|dde_chksum
operator|)
argument_list|,
operator|*
name|cs
argument_list|)
operator|&&
operator|(
operator|*
name|ddepp
operator|)
operator|->
name|dde_prop
operator|==
name|prop
condition|)
block|{
operator|*
name|dr
operator|=
operator|(
operator|*
name|ddepp
operator|)
operator|->
name|dde_ref
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
name|ddt_hash_append
argument_list|(
name|hdl
argument_list|,
name|ddt
argument_list|,
name|ddepp
argument_list|,
name|cs
argument_list|,
name|prop
argument_list|,
name|dr
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_record
parameter_list|(
name|dmu_replay_record_t
modifier|*
name|drr
parameter_list|,
name|void
modifier|*
name|payload
parameter_list|,
name|int
name|payload_len
parameter_list|,
name|zio_cksum_t
modifier|*
name|zc
parameter_list|,
name|int
name|outfd
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|offsetof
argument_list|(
name|dmu_replay_record_t
argument_list|,
name|drr_u
operator|.
name|drr_checksum
operator|.
name|drr_checksum
argument_list|)
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_replay_record_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|fletcher_4_incremental_native
argument_list|(
name|drr
argument_list|,
name|offsetof
argument_list|(
name|dmu_replay_record_t
argument_list|,
name|drr_u
operator|.
name|drr_checksum
operator|.
name|drr_checksum
argument_list|)
argument_list|,
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|drr
operator|->
name|drr_type
operator|!=
name|DRR_BEGIN
condition|)
block|{
name|ASSERT
argument_list|(
name|ZIO_CHECKSUM_IS_ZERO
argument_list|(
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_checksum
operator|.
name|drr_checksum
argument_list|)
argument_list|)
expr_stmt|;
name|drr
operator|->
name|drr_u
operator|.
name|drr_checksum
operator|.
name|drr_checksum
operator|=
operator|*
name|zc
expr_stmt|;
block|}
name|fletcher_4_incremental_native
argument_list|(
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_checksum
operator|.
name|drr_checksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|,
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outfd
argument_list|,
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|payload_len
operator|!=
literal|0
condition|)
block|{
name|fletcher_4_incremental_native
argument_list|(
name|payload
argument_list|,
name|payload_len
argument_list|,
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outfd
argument_list|,
name|payload
argument_list|,
name|payload_len
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is started in a separate thread when the dedup option  * has been requested.  The main send thread determines the list of  * snapshots to be included in the send stream and makes the ioctl calls  * for each one.  But instead of having the ioctl send the output to the  * the output fd specified by the caller of zfs_send()), the  * ioctl is told to direct the output to a pipe, which is read by the  * alternate thread running THIS function.  This function does the  * dedup'ing by:  *  1. building a dedup table (the DDT)  *  2. doing checksums on each data block and inserting a record in the DDT  *  3. looking for matching checksums, and  *  4.  sending a DRR_WRITE_BYREF record instead of a write record whenever  *      a duplicate block is found.  * The output of this function then goes to the output fd requested  * by the caller of zfs_send().  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|cksummer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dedup_arg_t
modifier|*
name|dda
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|zfs_alloc
argument_list|(
name|dda
operator|->
name|dedup_hdl
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
decl_stmt|;
name|dmu_replay_record_t
name|thedrr
decl_stmt|;
name|dmu_replay_record_t
modifier|*
name|drr
init|=
operator|&
name|thedrr
decl_stmt|;
name|FILE
modifier|*
name|ofp
decl_stmt|;
name|int
name|outfd
decl_stmt|;
name|dedup_table_t
name|ddt
decl_stmt|;
name|zio_cksum_t
name|stream_cksum
decl_stmt|;
name|uint64_t
name|physmem
init|=
name|sysconf
argument_list|(
name|_SC_PHYS_PAGES
argument_list|)
operator|*
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
decl_stmt|;
name|uint64_t
name|numbuckets
decl_stmt|;
name|ddt
operator|.
name|max_ddt_size
operator|=
name|MAX
argument_list|(
operator|(
name|physmem
operator|*
name|MAX_DDT_PHYSMEM_PERCENT
operator|)
operator|/
literal|100
argument_list|,
name|SMALLEST_POSSIBLE_MAX_DDT_MB
operator|<<
literal|20
argument_list|)
expr_stmt|;
name|numbuckets
operator|=
name|ddt
operator|.
name|max_ddt_size
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|dedup_entry_t
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * numbuckets must be a power of 2.  Increase number to 	 * a power of 2 if necessary. 	 */
if|if
condition|(
operator|!
name|ISP2
argument_list|(
name|numbuckets
argument_list|)
condition|)
name|numbuckets
operator|=
literal|1
operator|<<
name|high_order_bit
argument_list|(
name|numbuckets
argument_list|)
expr_stmt|;
name|ddt
operator|.
name|dedup_hash_array
operator|=
name|calloc
argument_list|(
name|numbuckets
argument_list|,
sizeof|sizeof
argument_list|(
name|dedup_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ddt
operator|.
name|ddecache
operator|=
name|umem_cache_create
argument_list|(
literal|"dde"
argument_list|,
sizeof|sizeof
argument_list|(
name|dedup_entry_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ddt
operator|.
name|cur_ddt_size
operator|=
name|numbuckets
operator|*
sizeof|sizeof
argument_list|(
name|dedup_entry_t
operator|*
argument_list|)
expr_stmt|;
name|ddt
operator|.
name|numhashbits
operator|=
name|high_order_bit
argument_list|(
name|numbuckets
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ddt
operator|.
name|ddt_full
operator|=
name|B_FALSE
expr_stmt|;
name|outfd
operator|=
name|dda
operator|->
name|outputfd
expr_stmt|;
name|ofp
operator|=
name|fdopen
argument_list|(
name|dda
operator|->
name|inputfd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ssread
argument_list|(
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drr
argument_list|)
argument_list|,
name|ofp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * kernel filled in checksum, we are going to write same 		 * record, but need to regenerate checksum. 		 */
if|if
condition|(
name|drr
operator|->
name|drr_type
operator|!=
name|DRR_BEGIN
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_checksum
operator|.
name|drr_checksum
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_checksum
operator|.
name|drr_checksum
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|drr
operator|->
name|drr_type
condition|)
block|{
case|case
name|DRR_BEGIN
case|:
block|{
name|struct
name|drr_begin
modifier|*
name|drrb
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|int
name|sz
init|=
literal|0
decl_stmt|;
name|ZIO_SET_CHECKSUM
argument_list|(
operator|&
name|stream_cksum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|drrb
operator|->
name|drr_magic
argument_list|,
operator|==
argument_list|,
name|DMU_BACKUP_MAGIC
argument_list|)
expr_stmt|;
comment|/* set the DEDUP feature flag for this stream */
name|fflags
operator|=
name|DMU_GET_FEATUREFLAGS
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|)
expr_stmt|;
name|fflags
operator||=
operator|(
name|DMU_BACKUP_FEATURE_DEDUP
operator||
name|DMU_BACKUP_FEATURE_DEDUPPROPS
operator|)
expr_stmt|;
name|DMU_SET_FEATUREFLAGS
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|,
name|fflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
condition|)
block|{
name|sz
operator|=
name|drr
operator|->
name|drr_payloadlen
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|SPA_MAXBLOCKSIZE
condition|)
block|{
name|buf
operator|=
name|zfs_realloc
argument_list|(
name|dda
operator|->
name|dedup_hdl
argument_list|,
name|buf
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ssread
argument_list|(
name|buf
argument_list|,
name|sz
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|perror
argument_list|(
literal|"fread"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|buf
argument_list|,
name|sz
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
case|case
name|DRR_END
case|:
block|{
name|struct
name|drr_end
modifier|*
name|drre
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_end
decl_stmt|;
comment|/* use the recalculated checksum */
name|drre
operator|->
name|drr_checksum
operator|=
name|stream_cksum
expr_stmt|;
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
case|case
name|DRR_OBJECT
case|:
block|{
name|struct
name|drr_object
modifier|*
name|drro
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_object
decl_stmt|;
if|if
condition|(
name|drro
operator|->
name|drr_bonuslen
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ssread
argument_list|(
name|buf
argument_list|,
name|P2ROUNDUP
argument_list|(
operator|(
name|uint64_t
operator|)
name|drro
operator|->
name|drr_bonuslen
argument_list|,
literal|8
argument_list|)
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|buf
argument_list|,
name|P2ROUNDUP
argument_list|(
operator|(
name|uint64_t
operator|)
name|drro
operator|->
name|drr_bonuslen
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
case|case
name|DRR_SPILL
case|:
block|{
name|struct
name|drr_spill
modifier|*
name|drrs
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_spill
decl_stmt|;
operator|(
name|void
operator|)
name|ssread
argument_list|(
name|buf
argument_list|,
name|drrs
operator|->
name|drr_length
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|buf
argument_list|,
name|drrs
operator|->
name|drr_length
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
case|case
name|DRR_FREEOBJECTS
case|:
block|{
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
case|case
name|DRR_WRITE
case|:
block|{
name|struct
name|drr_write
modifier|*
name|drrw
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
decl_stmt|;
name|dataref_t
name|dataref
decl_stmt|;
name|uint64_t
name|payload_size
decl_stmt|;
name|payload_size
operator|=
name|DRR_WRITE_PAYLOAD_SIZE
argument_list|(
name|drrw
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ssread
argument_list|(
name|buf
argument_list|,
name|payload_size
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
comment|/* 			 * Use the existing checksum if it's dedup-capable, 			 * else calculate a SHA256 checksum for it. 			 */
if|if
condition|(
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_cksum
argument_list|,
name|zero_cksum
argument_list|)
operator|||
operator|!
name|DRR_IS_DEDUP_CAPABLE
argument_list|(
name|drrw
operator|->
name|drr_checksumflags
argument_list|)
condition|)
block|{
name|SHA256_CTX
name|ctx
decl_stmt|;
name|zio_cksum_t
name|tmpsha256
decl_stmt|;
name|SHA256Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|SHA256Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
name|payload_size
argument_list|)
expr_stmt|;
name|SHA256Final
argument_list|(
operator|&
name|tmpsha256
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
operator|=
name|BE_64
argument_list|(
name|tmpsha256
operator|.
name|zc_word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_cksum
operator|.
name|zc_word
index|[
literal|1
index|]
operator|=
name|BE_64
argument_list|(
name|tmpsha256
operator|.
name|zc_word
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_cksum
operator|.
name|zc_word
index|[
literal|2
index|]
operator|=
name|BE_64
argument_list|(
name|tmpsha256
operator|.
name|zc_word
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_cksum
operator|.
name|zc_word
index|[
literal|3
index|]
operator|=
name|BE_64
argument_list|(
name|tmpsha256
operator|.
name|zc_word
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|drrw
operator|->
name|drr_checksumtype
operator|=
name|ZIO_CHECKSUM_SHA256
expr_stmt|;
name|drrw
operator|->
name|drr_checksumflags
operator|=
name|DRR_CHECKSUM_DEDUP
expr_stmt|;
block|}
name|dataref
operator|.
name|ref_guid
operator|=
name|drrw
operator|->
name|drr_toguid
expr_stmt|;
name|dataref
operator|.
name|ref_object
operator|=
name|drrw
operator|->
name|drr_object
expr_stmt|;
name|dataref
operator|.
name|ref_offset
operator|=
name|drrw
operator|->
name|drr_offset
expr_stmt|;
if|if
condition|(
name|ddt_update
argument_list|(
name|dda
operator|->
name|dedup_hdl
argument_list|,
operator|&
name|ddt
argument_list|,
operator|&
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_cksum
argument_list|,
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_prop
argument_list|,
operator|&
name|dataref
argument_list|)
condition|)
block|{
name|dmu_replay_record_t
name|wbr_drr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|drr_write_byref
modifier|*
name|wbr_drrr
init|=
operator|&
name|wbr_drr
operator|.
name|drr_u
operator|.
name|drr_write_byref
decl_stmt|;
comment|/* block already present in stream */
name|wbr_drr
operator|.
name|drr_type
operator|=
name|DRR_WRITE_BYREF
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_object
operator|=
name|drrw
operator|->
name|drr_object
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_offset
operator|=
name|drrw
operator|->
name|drr_offset
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_length
operator|=
name|drrw
operator|->
name|drr_logical_size
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_toguid
operator|=
name|drrw
operator|->
name|drr_toguid
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_refguid
operator|=
name|dataref
operator|.
name|ref_guid
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_refobject
operator|=
name|dataref
operator|.
name|ref_object
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_refoffset
operator|=
name|dataref
operator|.
name|ref_offset
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_checksumtype
operator|=
name|drrw
operator|->
name|drr_checksumtype
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_checksumflags
operator|=
name|drrw
operator|->
name|drr_checksumtype
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_key
operator|.
name|ddk_cksum
operator|=
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_cksum
expr_stmt|;
name|wbr_drrr
operator|->
name|drr_key
operator|.
name|ddk_prop
operator|=
name|drrw
operator|->
name|drr_key
operator|.
name|ddk_prop
expr_stmt|;
if|if
condition|(
name|dump_record
argument_list|(
operator|&
name|wbr_drr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* block not previously seen */
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|buf
argument_list|,
name|payload_size
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
break|break;
block|}
case|case
name|DRR_WRITE_EMBEDDED
case|:
block|{
name|struct
name|drr_write_embedded
modifier|*
name|drrwe
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_write_embedded
decl_stmt|;
operator|(
name|void
operator|)
name|ssread
argument_list|(
name|buf
argument_list|,
name|P2ROUNDUP
argument_list|(
operator|(
name|uint64_t
operator|)
name|drrwe
operator|->
name|drr_psize
argument_list|,
literal|8
argument_list|)
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|buf
argument_list|,
name|P2ROUNDUP
argument_list|(
operator|(
name|uint64_t
operator|)
name|drrwe
operator|->
name|drr_psize
argument_list|,
literal|8
argument_list|)
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
case|case
name|DRR_FREE
case|:
block|{
if|if
condition|(
name|dump_record
argument_list|(
name|drr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|stream_cksum
argument_list|,
name|outfd
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"INVALID record type 0x%x\n"
argument_list|,
name|drr
operator|->
name|drr_type
argument_list|)
expr_stmt|;
comment|/* should never happen, so assert */
name|assert
argument_list|(
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|umem_cache_destroy
argument_list|(
name|ddt
operator|.
name|ddecache
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ddt
operator|.
name|dedup_hash_array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for dealing with the AVL tree of fs-nvlists  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fsavl_node
block|{
name|avl_node_t
name|fn_node
decl_stmt|;
name|nvlist_t
modifier|*
name|fn_nvfs
decl_stmt|;
name|char
modifier|*
name|fn_snapname
decl_stmt|;
name|uint64_t
name|fn_guid
decl_stmt|;
block|}
name|fsavl_node_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|fsavl_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|fsavl_node_t
modifier|*
name|fn1
init|=
name|arg1
decl_stmt|;
specifier|const
name|fsavl_node_t
modifier|*
name|fn2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|fn1
operator|->
name|fn_guid
operator|>
name|fn2
operator|->
name|fn_guid
condition|)
return|return
operator|(
operator|+
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|fn1
operator|->
name|fn_guid
operator|<
name|fn2
operator|->
name|fn_guid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given the GUID of a snapshot, find its containing filesystem and  * (optionally) name.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|fsavl_find
parameter_list|(
name|avl_tree_t
modifier|*
name|avl
parameter_list|,
name|uint64_t
name|snapguid
parameter_list|,
name|char
modifier|*
modifier|*
name|snapname
parameter_list|)
block|{
name|fsavl_node_t
name|fn_find
decl_stmt|;
name|fsavl_node_t
modifier|*
name|fn
decl_stmt|;
name|fn_find
operator|.
name|fn_guid
operator|=
name|snapguid
expr_stmt|;
name|fn
operator|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|fn_find
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
block|{
if|if
condition|(
name|snapname
condition|)
operator|*
name|snapname
operator|=
name|fn
operator|->
name|fn_snapname
expr_stmt|;
return|return
operator|(
name|fn
operator|->
name|fn_nvfs
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsavl_destroy
parameter_list|(
name|avl_tree_t
modifier|*
name|avl
parameter_list|)
block|{
name|fsavl_node_t
modifier|*
name|fn
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
if|if
condition|(
name|avl
operator|==
name|NULL
condition|)
return|return;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|fn
operator|=
name|avl_destroy_nodes
argument_list|(
name|avl
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|avl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given an nvlist, produce an avl tree of snapshots, ordered by guid  */
end_comment

begin_function
specifier|static
name|avl_tree_t
modifier|*
name|fsavl_create
parameter_list|(
name|nvlist_t
modifier|*
name|fss
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|fsavl
decl_stmt|;
name|nvpair_t
modifier|*
name|fselem
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|fsavl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|avl_create
argument_list|(
name|fsavl
argument_list|,
name|fsavl_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|fsavl_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|fsavl_node_t
argument_list|,
name|fn_node
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fselem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|fss
argument_list|,
name|fselem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|,
modifier|*
name|snaps
decl_stmt|;
name|nvpair_t
modifier|*
name|snapelem
init|=
name|NULL
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_nvlist
argument_list|(
name|fselem
argument_list|,
operator|&
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snaps"
argument_list|,
operator|&
name|snaps
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|snapelem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fsavl_node_t
modifier|*
name|fn
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_uint64
argument_list|(
name|snapelem
argument_list|,
operator|&
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fsavl_node_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fn
operator|->
name|fn_nvfs
operator|=
name|nvfs
expr_stmt|;
name|fn
operator|->
name|fn_snapname
operator|=
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
expr_stmt|;
name|fn
operator|->
name|fn_guid
operator|=
name|guid
expr_stmt|;
comment|/* 			 * Note: if there are multiple snaps with the 			 * same GUID, we ignore all but one. 			 */
if|if
condition|(
name|avl_find
argument_list|(
name|fsavl
argument_list|,
name|fn
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|avl_add
argument_list|(
name|fsavl
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fsavl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for dealing with the giant nvlist of fs-nvlists, etc.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|send_data
block|{
comment|/* 	 * assigned inside every recursive call, 	 * restored from *_save on return: 	 * 	 * guid of fromsnap snapshot in parent dataset 	 * txg of fromsnap snapshot in current dataset 	 * txg of tosnap snapshot in current dataset 	 */
name|uint64_t
name|parent_fromsnap_guid
decl_stmt|;
name|uint64_t
name|fromsnap_txg
decl_stmt|;
name|uint64_t
name|tosnap_txg
decl_stmt|;
comment|/* the nvlists get accumulated during depth-first traversal */
name|nvlist_t
modifier|*
name|parent_snaps
decl_stmt|;
name|nvlist_t
modifier|*
name|fss
decl_stmt|;
name|nvlist_t
modifier|*
name|snapprops
decl_stmt|;
comment|/* send-receive configuration, does not change during traversal */
specifier|const
name|char
modifier|*
name|fsname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fromsnap
decl_stmt|;
specifier|const
name|char
modifier|*
name|tosnap
decl_stmt|;
name|boolean_t
name|recursive
decl_stmt|;
name|boolean_t
name|verbose
decl_stmt|;
comment|/* 	 * The header nvlist is of the following format: 	 * { 	 *   "tosnap" -> string 	 *   "fromsnap" -> string (if incremental) 	 *   "fss" -> { 	 *	id -> { 	 * 	 *	 "name" -> string (full name; for debugging) 	 *	 "parentfromsnap" -> number (guid of fromsnap in parent) 	 * 	 *	 "props" -> { name -> value (only if set here) } 	 *	 "snaps" -> { name (lastname) -> number (guid) } 	 *	 "snapprops" -> { name (lastname) -> { name -> value } } 	 * 	 *	 "origin" -> number (guid) (if clone) 	 *	 "sent" -> boolean (not on-disk) 	 *	} 	 *   } 	 * } 	 * 	 */
block|}
name|send_data_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|send_iterate_prop
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|send_iterate_snap
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_data_t
modifier|*
name|sd
init|=
name|arg
decl_stmt|;
name|uint64_t
name|guid
init|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
decl_stmt|;
name|uint64_t
name|txg
init|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_creation_txg
decl_stmt|;
name|char
modifier|*
name|snapname
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|snapname
operator|=
name|strrchr
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|tosnap_txg
operator|!=
literal|0
operator|&&
name|txg
operator|>
name|sd
operator|->
name|tosnap_txg
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"skipping snapshot %s because it was created "
literal|"after the destination snapshot (%s)\n"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|sd
operator|->
name|parent_snaps
argument_list|,
name|snapname
argument_list|,
name|guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: if there is no fromsnap here (it's a newly created fs in 	 * an incremental replication), we will substitute the tosnap. 	 */
if|if
condition|(
operator|(
name|sd
operator|->
name|fromsnap
operator|&&
name|strcmp
argument_list|(
name|snapname
argument_list|,
name|sd
operator|->
name|fromsnap
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|sd
operator|->
name|parent_fromsnap_guid
operator|==
literal|0
operator|&&
name|sd
operator|->
name|tosnap
operator|&&
name|strcmp
argument_list|(
name|snapname
argument_list|,
name|sd
operator|->
name|tosnap
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sd
operator|->
name|parent_fromsnap_guid
operator|=
name|guid
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|send_iterate_prop
argument_list|(
name|zhp
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|sd
operator|->
name|snapprops
argument_list|,
name|snapname
argument_list|,
name|nv
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_iterate_prop
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|zhp
operator|->
name|zfs_props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|propnv
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
condition|)
block|{
comment|/* 			 * Realistically, this should never happen.  However, 			 * we want the ability to add DSL properties without 			 * needing to make incompatible version changes.  We 			 * need to ignore unknown properties to allow older 			 * software to still send datasets containing these 			 * properties, with the unknown properties elided. 			 */
if|if
condition|(
name|prop
operator|==
name|ZPROP_INVAL
condition|)
continue|continue;
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
continue|continue;
block|}
name|verify
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|propnv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_QUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_RESERVATION
operator|||
name|prop
operator|==
name|ZFS_PROP_REFQUOTA
operator|||
name|prop
operator|==
name|ZFS_PROP_REFRESERVATION
condition|)
block|{
name|char
modifier|*
name|source
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|propnv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
condition|)
continue|continue;
comment|/* 			 * May have no source before SPA_VERSION_RECVD_PROPS, 			 * but is still modifiable. 			 */
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|propnv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|source
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|ZPROP_SOURCE_VAL_RECVD
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|source
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|propnv
argument_list|,
name|ZPROP_SOURCE
argument_list|,
operator|&
name|source
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|source
argument_list|,
name|ZPROP_SOURCE_VAL_RECVD
argument_list|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|zfs_prop_user
argument_list|(
name|propname
argument_list|)
operator|||
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
operator|==
name|PROP_TYPE_STRING
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|propnv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|value
decl_stmt|;
name|verify
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|propnv
argument_list|,
name|ZPROP_VALUE
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * returns snapshot creation txg  * and returns 0 if the snapshot does not exist  */
end_comment

begin_function
specifier|static
name|uint64_t
name|get_snap_txg
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|snap
parameter_list|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fs
operator|==
name|NULL
operator|||
name|fs
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|snap
operator|==
name|NULL
operator|||
name|snap
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|txg
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fs
argument_list|,
name|snap
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|txg
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|txg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * recursively generate nvlists describing datasets.  See comment  * for the data structure send_data_t above for description of contents  * of the nvlist.  */
end_comment

begin_function
specifier|static
name|int
name|send_iterate_fs
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_data_t
modifier|*
name|sd
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|,
modifier|*
name|nv
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|uint64_t
name|parent_fromsnap_guid_save
init|=
name|sd
operator|->
name|parent_fromsnap_guid
decl_stmt|;
name|uint64_t
name|fromsnap_txg_save
init|=
name|sd
operator|->
name|fromsnap_txg
decl_stmt|;
name|uint64_t
name|tosnap_txg_save
init|=
name|sd
operator|->
name|tosnap_txg
decl_stmt|;
name|uint64_t
name|txg
init|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_creation_txg
decl_stmt|;
name|uint64_t
name|guid
init|=
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
decl_stmt|;
name|uint64_t
name|fromsnap_txg
decl_stmt|,
name|tosnap_txg
decl_stmt|;
name|char
name|guidstring
index|[
literal|64
index|]
decl_stmt|;
name|fromsnap_txg
operator|=
name|get_snap_txg
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sd
operator|->
name|fromsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap_txg
operator|!=
literal|0
condition|)
name|sd
operator|->
name|fromsnap_txg
operator|=
name|fromsnap_txg
expr_stmt|;
name|tosnap_txg
operator|=
name|get_snap_txg
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tosnap_txg
operator|!=
literal|0
condition|)
name|sd
operator|->
name|tosnap_txg
operator|=
name|tosnap_txg
expr_stmt|;
comment|/* 	 * on the send side, if the current dataset does not have tosnap, 	 * perform two additional checks: 	 * 	 * - skip sending the current dataset if it was created later than 	 *   the parent tosnap 	 * - return error if the current dataset was created earlier than 	 *   the parent tosnap 	 */
if|if
condition|(
name|sd
operator|->
name|tosnap
operator|!=
name|NULL
operator|&&
name|tosnap_txg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|tosnap_txg
operator|!=
literal|0
operator|&&
name|txg
operator|>
name|sd
operator|->
name|tosnap_txg
condition|)
block|{
if|if
condition|(
name|sd
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"skipping dataset %s: snapshot %s does "
literal|"not exist\n"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot send %s@%s%s: snapshot %s@%s does not "
literal|"exist\n"
argument_list|)
argument_list|,
name|sd
operator|->
name|fsname
argument_list|,
name|sd
operator|->
name|tosnap
argument_list|,
name|sd
operator|->
name|recursive
condition|?
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|" recursively"
argument_list|)
else|:
literal|""
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|nvfs
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"parentfromsnap"
argument_list|,
name|sd
operator|->
name|parent_fromsnap_guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
index|[
literal|0
index|]
condition|)
block|{
name|zfs_handle_t
modifier|*
name|origin
init|=
name|zfs_open
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
block|{
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"origin"
argument_list|,
name|origin
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* iterate over props */
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|send_iterate_prop
argument_list|(
name|zhp
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"props"
argument_list|,
name|nv
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
comment|/* iterate over snaps, and set sd->parent_fromsnap_guid */
name|sd
operator|->
name|parent_fromsnap_guid
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|->
name|parent_snaps
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|->
name|snapprops
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_iter_snapshots
argument_list|(
name|zhp
argument_list|,
name|B_FALSE
argument_list|,
name|send_iterate_snap
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snaps"
argument_list|,
name|sd
operator|->
name|parent_snaps
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snapprops"
argument_list|,
name|sd
operator|->
name|snapprops
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sd
operator|->
name|parent_snaps
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sd
operator|->
name|snapprops
argument_list|)
expr_stmt|;
comment|/* add this fs to nvlist */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|guidstring
argument_list|,
sizeof|sizeof
argument_list|(
name|guidstring
argument_list|)
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|longlong_t
operator|)
name|guid
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|sd
operator|->
name|fss
argument_list|,
name|guidstring
argument_list|,
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvfs
argument_list|)
expr_stmt|;
comment|/* iterate over children */
if|if
condition|(
name|sd
operator|->
name|recursive
condition|)
name|rv
operator|=
name|zfs_iter_filesystems
argument_list|(
name|zhp
argument_list|,
name|send_iterate_fs
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|out
label|:
name|sd
operator|->
name|parent_fromsnap_guid
operator|=
name|parent_fromsnap_guid_save
expr_stmt|;
name|sd
operator|->
name|fromsnap_txg
operator|=
name|fromsnap_txg_save
expr_stmt|;
name|sd
operator|->
name|tosnap_txg
operator|=
name|tosnap_txg_save
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gather_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|boolean_t
name|recursive
parameter_list|,
name|boolean_t
name|verbose
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|avl_tree_t
modifier|*
modifier|*
name|avlp
parameter_list|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|send_data_t
name|sd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|fsname
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EZFS_BADTYPE
operator|)
return|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|sd
operator|.
name|fss
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|.
name|fsname
operator|=
name|fsname
expr_stmt|;
name|sd
operator|.
name|fromsnap
operator|=
name|fromsnap
expr_stmt|;
name|sd
operator|.
name|tosnap
operator|=
name|tosnap
expr_stmt|;
name|sd
operator|.
name|recursive
operator|=
name|recursive
expr_stmt|;
name|sd
operator|.
name|verbose
operator|=
name|verbose
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|send_iterate_fs
argument_list|(
name|zhp
argument_list|,
operator|&
name|sd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|sd
operator|.
name|fss
argument_list|)
expr_stmt|;
if|if
condition|(
name|avlp
operator|!=
name|NULL
condition|)
operator|*
name|avlp
operator|=
name|NULL
expr_stmt|;
operator|*
name|nvlp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|avlp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|avlp
operator|=
name|fsavl_create
argument_list|(
name|sd
operator|.
name|fss
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|sd
operator|.
name|fss
argument_list|)
expr_stmt|;
operator|*
name|nvlp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EZFS_NOMEM
operator|)
return|;
block|}
operator|*
name|nvlp
operator|=
name|sd
operator|.
name|fss
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines specific to "zfs send"  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|send_dump_data
block|{
comment|/* these are all just the short snapname (the part after the @) */
specifier|const
name|char
modifier|*
name|fromsnap
decl_stmt|;
specifier|const
name|char
modifier|*
name|tosnap
decl_stmt|;
name|char
name|prevsnap
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|uint64_t
name|prevsnap_obj
decl_stmt|;
name|boolean_t
name|seenfrom
decl_stmt|,
name|seento
decl_stmt|,
name|replicate
decl_stmt|,
name|doall
decl_stmt|,
name|fromorigin
decl_stmt|;
name|boolean_t
name|verbose
decl_stmt|,
name|dryrun
decl_stmt|,
name|parsable
decl_stmt|,
name|progress
decl_stmt|,
name|embed_data
decl_stmt|,
name|std_out
decl_stmt|;
name|boolean_t
name|large_block
decl_stmt|,
name|compress
decl_stmt|;
name|int
name|outfd
decl_stmt|;
name|boolean_t
name|err
decl_stmt|;
name|nvlist_t
modifier|*
name|fss
decl_stmt|;
name|nvlist_t
modifier|*
name|snapholds
decl_stmt|;
name|avl_tree_t
modifier|*
name|fsavl
decl_stmt|;
name|snapfilter_cb_t
modifier|*
name|filter_cb
decl_stmt|;
name|void
modifier|*
name|filter_cb_arg
decl_stmt|;
name|nvlist_t
modifier|*
name|debugnv
decl_stmt|;
name|char
name|holdtag
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|cleanup_fd
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
block|}
name|send_dump_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|estimate_ioctl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|uint64_t
name|fromsnap_obj
parameter_list|,
name|boolean_t
name|fromorigin
parameter_list|,
name|enum
name|lzc_send_flags
name|flags
parameter_list|,
name|uint64_t
modifier|*
name|sizep
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fromsnap_obj
operator|==
literal|0
operator|||
operator|!
name|fromorigin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|fromorigin
expr_stmt|;
name|zc
operator|.
name|zc_sendobj
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_OBJSETID
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_fromobj
operator|=
name|fromsnap_obj
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
literal|1
expr_stmt|;
comment|/* estimate flag */
name|zc
operator|.
name|zc_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_SEND
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"warning: cannot estimate space for '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not an earlier snapshot from the same fs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ENOENT
case|:
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"incremental source (@%s) does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EDQUOT
case|:
case|case
name|EFBIG
case|:
case|case
name|EIO
case|:
case|case
name|ENOLINK
case|:
case|case
name|ENOSPC
case|:
case|case
name|ENOSTR
case|:
case|case
name|ENXIO
case|:
case|case
name|EPIPE
case|:
case|case
name|ERANGE
case|:
case|case
name|EFAULT
case|:
case|case
name|EROFS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADBACKUP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
operator|*
name|sizep
operator|=
name|zc
operator|.
name|zc_objset_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dumps a backup of the given snapshot (incremental from fromsnap if it's not  * NULL) to the file descriptor specified by outfd.  */
end_comment

begin_function
specifier|static
name|int
name|dump_ioctl
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
name|uint64_t
name|fromsnap_obj
parameter_list|,
name|boolean_t
name|fromorigin
parameter_list|,
name|int
name|outfd
parameter_list|,
name|enum
name|lzc_send_flags
name|flags
parameter_list|,
name|nvlist_t
modifier|*
name|debugnv
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|nvlist_t
modifier|*
name|thisdbg
decl_stmt|;
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fromsnap_obj
operator|==
literal|0
operator|||
operator|!
name|fromorigin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|outfd
expr_stmt|;
name|zc
operator|.
name|zc_obj
operator|=
name|fromorigin
expr_stmt|;
name|zc
operator|.
name|zc_sendobj
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_OBJSETID
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_fromobj
operator|=
name|fromsnap_obj
expr_stmt|;
name|zc
operator|.
name|zc_flags
operator|=
name|flags
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|thisdbg
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
operator|&&
name|fromsnap
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|thisdbg
argument_list|,
literal|"fromsnap"
argument_list|,
name|fromsnap
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|ZFS_IOC_SEND
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"warning: cannot send '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|thisdbg
argument_list|,
literal|"error"
argument_list|,
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugnv
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|debugnv
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|thisdbg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|thisdbg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not an earlier snapshot from the same fs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ENOENT
case|:
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"incremental source (@%s) does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EDQUOT
case|:
case|case
name|EFBIG
case|:
case|case
name|EIO
case|:
case|case
name|ENOLINK
case|:
case|case
name|ENOSPC
case|:
case|case
name|ENOSTR
case|:
case|case
name|ENXIO
case|:
case|case
name|EPIPE
case|:
case|case
name|ERANGE
case|:
case|case
name|EFAULT
case|:
case|case
name|EROFS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADBACKUP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|debugnv
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|debugnv
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|thisdbg
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|thisdbg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gather_holds
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|send_dump_data_t
modifier|*
name|sdd
parameter_list|)
block|{
name|assert
argument_list|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
comment|/* 	 * zfs_send() only sets snapholds for sends that need them, 	 * e.g. replication and doall. 	 */
if|if
condition|(
name|sdd
operator|->
name|snapholds
operator|==
name|NULL
condition|)
return|return;
name|fnvlist_add_string
argument_list|(
name|sdd
operator|->
name|snapholds
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|holdtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|send_progress_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|progress_arg_t
modifier|*
name|pa
init|=
name|arg
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|pa
operator|->
name|pa_zhp
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|unsigned
name|long
name|long
name|bytes
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pa
operator|->
name|pa_parsable
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TIME        SENT   SNAPSHOT\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Print the progress from ZFS_IOC_SEND_PROGRESS every second. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|pa
operator|->
name|pa_fd
expr_stmt|;
if|if
condition|(
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SEND_PROGRESS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|zc
operator|.
name|zc_cookie
expr_stmt|;
if|if
condition|(
name|pa
operator|->
name|pa_parsable
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02d:%02d:%02d\t%llu\t%s\n"
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|,
name|bytes
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_nicenum
argument_list|(
name|bytes
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02d:%02d:%02d   %5s   %s\n"
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|,
name|buf
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|send_print_verbose
parameter_list|(
name|FILE
modifier|*
name|fout
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|boolean_t
name|parsable
parameter_list|)
block|{
if|if
condition|(
name|parsable
condition|)
block|{
if|if
condition|(
name|fromsnap
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"incremental\t%s\t%s"
argument_list|,
name|fromsnap
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"full\t%s"
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fromsnap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|fromsnap
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|&&
name|strchr
argument_list|(
name|fromsnap
argument_list|,
literal|'#'
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"send from @%s to %s"
argument_list|)
argument_list|,
name|fromsnap
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"send from %s to %s"
argument_list|)
argument_list|,
name|fromsnap
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"full send of %s"
argument_list|)
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|parsable
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"\t%llu"
argument_list|,
operator|(
name|longlong_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|size
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|" estimated size is %s"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_snapshot
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_dump_data_t
modifier|*
name|sdd
init|=
name|arg
decl_stmt|;
name|progress_arg_t
name|pa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pthread_t
name|tid
decl_stmt|;
name|char
modifier|*
name|thissnap
decl_stmt|;
name|enum
name|lzc_send_flags
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|boolean_t
name|isfromsnap
decl_stmt|,
name|istosnap
decl_stmt|,
name|fromorigin
decl_stmt|;
name|boolean_t
name|exclude
init|=
name|B_FALSE
decl_stmt|;
name|FILE
modifier|*
name|fout
init|=
name|sdd
operator|->
name|std_out
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|thissnap
operator|=
name|strchr
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|isfromsnap
operator|=
operator|(
name|sdd
operator|->
name|fromsnap
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|sdd
operator|->
name|fromsnap
argument_list|,
name|thissnap
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdd
operator|->
name|seenfrom
operator|&&
name|isfromsnap
condition|)
block|{
name|gather_holds
argument_list|(
name|zhp
argument_list|,
name|sdd
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|seenfrom
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sdd
operator|->
name|prevsnap
argument_list|,
name|thissnap
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|prevsnap_obj
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_OBJSETID
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sdd
operator|->
name|seento
operator|||
operator|!
name|sdd
operator|->
name|seenfrom
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|istosnap
operator|=
operator|(
name|strcmp
argument_list|(
name|sdd
operator|->
name|tosnap
argument_list|,
name|thissnap
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|istosnap
condition|)
name|sdd
operator|->
name|seento
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|large_block
condition|)
name|flags
operator||=
name|LZC_SEND_FLAG_LARGE_BLOCK
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|embed_data
condition|)
name|flags
operator||=
name|LZC_SEND_FLAG_EMBED_DATA
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|compress
condition|)
name|flags
operator||=
name|LZC_SEND_FLAG_COMPRESS
expr_stmt|;
if|if
condition|(
operator|!
name|sdd
operator|->
name|doall
operator|&&
operator|!
name|isfromsnap
operator|&&
operator|!
name|istosnap
condition|)
block|{
if|if
condition|(
name|sdd
operator|->
name|replicate
condition|)
block|{
name|char
modifier|*
name|snapname
decl_stmt|;
name|nvlist_t
modifier|*
name|snapprops
decl_stmt|;
comment|/* 			 * Filter out all intermediate snapshots except origin 			 * snapshots needed to replicate clones. 			 */
name|nvlist_t
modifier|*
name|nvfs
init|=
name|fsavl_find
argument_list|(
name|sdd
operator|->
name|fsavl
argument_list|,
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_guid
argument_list|,
operator|&
name|snapname
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snapprops"
argument_list|,
operator|&
name|snapprops
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|snapprops
argument_list|,
name|thissnap
argument_list|,
operator|&
name|snapprops
argument_list|)
argument_list|)
expr_stmt|;
name|exclude
operator|=
operator|!
name|nvlist_exists
argument_list|(
name|snapprops
argument_list|,
literal|"is_clone_origin"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exclude
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
comment|/* 	 * If a filter function exists, call it to determine whether 	 * this snapshot will be sent. 	 */
if|if
condition|(
name|exclude
operator|||
operator|(
name|sdd
operator|->
name|filter_cb
operator|!=
name|NULL
operator|&&
name|sdd
operator|->
name|filter_cb
argument_list|(
name|zhp
argument_list|,
name|sdd
operator|->
name|filter_cb_arg
argument_list|)
operator|==
name|B_FALSE
operator|)
condition|)
block|{
comment|/* 		 * This snapshot is filtered out.  Don't send it, and don't 		 * set prevsnap_obj, so it will be as if this snapshot didn't 		 * exist, and the next accepted snapshot will be sent as 		 * an incremental from the last accepted one, or as the 		 * first (and full) snapshot in the case of a replication, 		 * non-incremental send. 		 */
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gather_holds
argument_list|(
name|zhp
argument_list|,
name|sdd
argument_list|)
expr_stmt|;
name|fromorigin
operator|=
name|sdd
operator|->
name|prevsnap
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|sdd
operator|->
name|fromorigin
operator|||
name|sdd
operator|->
name|replicate
operator|)
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|verbose
condition|)
block|{
name|uint64_t
name|size
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|estimate_ioctl
argument_list|(
name|zhp
argument_list|,
name|sdd
operator|->
name|prevsnap_obj
argument_list|,
name|fromorigin
argument_list|,
name|flags
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|send_print_verbose
argument_list|(
name|fout
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|prevsnap
index|[
literal|0
index|]
condition|?
name|sdd
operator|->
name|prevsnap
else|:
name|NULL
argument_list|,
name|size
argument_list|,
name|sdd
operator|->
name|parsable
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sdd
operator|->
name|dryrun
condition|)
block|{
comment|/* 		 * If progress reporting is requested, spawn a new thread to 		 * poll ZFS_IOC_SEND_PROGRESS at a regular interval. 		 */
if|if
condition|(
name|sdd
operator|->
name|progress
condition|)
block|{
name|pa
operator|.
name|pa_zhp
operator|=
name|zhp
expr_stmt|;
name|pa
operator|.
name|pa_fd
operator|=
name|sdd
operator|->
name|outfd
expr_stmt|;
name|pa
operator|.
name|pa_parsable
operator|=
name|sdd
operator|->
name|parsable
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|pthread_create
argument_list|(
operator|&
name|tid
argument_list|,
name|NULL
argument_list|,
name|send_progress_thread
argument_list|,
operator|&
name|pa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
name|err
operator|=
name|dump_ioctl
argument_list|(
name|zhp
argument_list|,
name|sdd
operator|->
name|prevsnap
argument_list|,
name|sdd
operator|->
name|prevsnap_obj
argument_list|,
name|fromorigin
argument_list|,
name|sdd
operator|->
name|outfd
argument_list|,
name|flags
argument_list|,
name|sdd
operator|->
name|debugnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|progress
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_cancel
argument_list|(
name|tid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_join
argument_list|(
name|tid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sdd
operator|->
name|prevsnap
argument_list|,
name|thissnap
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|prevsnap_obj
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_OBJSETID
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_filesystem
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|send_dump_data_t
modifier|*
name|sdd
init|=
name|arg
decl_stmt|;
name|boolean_t
name|missingfrom
init|=
name|B_FALSE
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"WARNING: could not send %s@%s: does not exist\n"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|err
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sdd
operator|->
name|replicate
operator|&&
name|sdd
operator|->
name|fromsnap
condition|)
block|{
comment|/* 		 * If this fs does not have fromsnap, and we're doing 		 * recursive, we need to send a full stream from the 		 * beginning (or an incremental from the origin if this 		 * is a clone).  If we're doing non-recursive, then let 		 * them get the error. 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|fromsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|zhp
operator|->
name|zfs_hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_OBJSET_STATS
argument_list|,
operator|&
name|zc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|missingfrom
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
name|sdd
operator|->
name|seenfrom
operator|=
name|sdd
operator|->
name|seento
operator|=
name|sdd
operator|->
name|prevsnap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sdd
operator|->
name|prevsnap_obj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sdd
operator|->
name|fromsnap
operator|==
name|NULL
operator|||
name|missingfrom
condition|)
name|sdd
operator|->
name|seenfrom
operator|=
name|B_TRUE
expr_stmt|;
name|rv
operator|=
name|zfs_iter_snapshots_sorted
argument_list|(
name|zhp
argument_list|,
name|dump_snapshot
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdd
operator|->
name|seenfrom
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"WARNING: could not send %s@%s:\n"
literal|"incremental source (%s@%s) does not exist\n"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|fromsnap
argument_list|)
expr_stmt|;
name|sdd
operator|->
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sdd
operator|->
name|seento
condition|)
block|{
if|if
condition|(
name|sdd
operator|->
name|fromsnap
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"WARNING: could not send %s@%s:\n"
literal|"incremental source (%s@%s) "
literal|"is not earlier than it\n"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|fromsnap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"WARNING: "
literal|"could not send %s@%s: does not exist\n"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|sdd
operator|->
name|tosnap
argument_list|)
expr_stmt|;
block|}
name|sdd
operator|->
name|err
operator|=
name|B_TRUE
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_filesystems
parameter_list|(
name|zfs_handle_t
modifier|*
name|rzhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|send_dump_data_t
modifier|*
name|sdd
init|=
name|arg
decl_stmt|;
name|nvpair_t
modifier|*
name|fspair
decl_stmt|;
name|boolean_t
name|needagain
decl_stmt|,
name|progress
decl_stmt|;
if|if
condition|(
operator|!
name|sdd
operator|->
name|replicate
condition|)
return|return
operator|(
name|dump_filesystem
argument_list|(
name|rzhp
argument_list|,
name|sdd
argument_list|)
operator|)
return|;
comment|/* Mark the clone origin snapshots. */
for|for
control|(
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|NULL
argument_list|)
init|;
name|fspair
condition|;
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|fspair
argument_list|)
control|)
block|{
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|;
name|uint64_t
name|origin_guid
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_nvlist
argument_list|(
name|fspair
argument_list|,
operator|&
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|origin_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin_guid
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|snapname
decl_stmt|;
name|nvlist_t
modifier|*
name|origin_nv
init|=
name|fsavl_find
argument_list|(
name|sdd
operator|->
name|fsavl
argument_list|,
name|origin_guid
argument_list|,
operator|&
name|snapname
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin_nv
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|snapprops
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|origin_nv
argument_list|,
literal|"snapprops"
argument_list|,
operator|&
name|snapprops
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|snapprops
argument_list|,
name|snapname
argument_list|,
operator|&
name|snapprops
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_boolean
argument_list|(
name|snapprops
argument_list|,
literal|"is_clone_origin"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|again
label|:
name|needagain
operator|=
name|progress
operator|=
name|B_FALSE
expr_stmt|;
for|for
control|(
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|NULL
argument_list|)
init|;
name|fspair
condition|;
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|fspair
argument_list|)
control|)
block|{
name|nvlist_t
modifier|*
name|fslist
decl_stmt|,
modifier|*
name|parent_nv
decl_stmt|;
name|char
modifier|*
name|fsname
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|origin_guid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|parent_guid
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|fspair
argument_list|,
operator|&
name|fslist
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_boolean
argument_list|(
name|fslist
argument_list|,
literal|"sent"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|fslist
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|fslist
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|origin_guid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|fslist
argument_list|,
literal|"parentfromsnap"
argument_list|,
operator|&
name|parent_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_guid
operator|!=
literal|0
condition|)
block|{
name|parent_nv
operator|=
name|fsavl_find
argument_list|(
name|sdd
operator|->
name|fsavl
argument_list|,
name|parent_guid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|parent_nv
argument_list|,
literal|"sent"
argument_list|)
condition|)
block|{
comment|/* parent has not been sent; skip this one */
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|origin_guid
operator|!=
literal|0
condition|)
block|{
name|nvlist_t
modifier|*
name|origin_nv
init|=
name|fsavl_find
argument_list|(
name|sdd
operator|->
name|fsavl
argument_list|,
name|origin_guid
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin_nv
operator|!=
name|NULL
operator|&&
operator|!
name|nvlist_exists
argument_list|(
name|origin_nv
argument_list|,
literal|"sent"
argument_list|)
condition|)
block|{
comment|/* 				 * origin has not been sent yet; 				 * skip this clone. 				 */
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|rzhp
operator|->
name|zfs_hdl
argument_list|,
name|fsname
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|dump_filesystem
argument_list|(
name|zhp
argument_list|,
name|sdd
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|fslist
argument_list|,
literal|"sent"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|progress
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|needagain
condition|)
block|{
name|assert
argument_list|(
name|progress
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* clean out the sent flags in case we reuse this fss */
for|for
control|(
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|NULL
argument_list|)
init|;
name|fspair
condition|;
name|fspair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|sdd
operator|->
name|fss
argument_list|,
name|fspair
argument_list|)
control|)
block|{
name|nvlist_t
modifier|*
name|fslist
decl_stmt|;
name|VERIFY
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|fspair
argument_list|,
operator|&
name|fslist
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|fslist
argument_list|,
literal|"sent"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|zfs_send_resume_token_to_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
name|unsigned
name|int
name|version
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|unsigned
name|long
name|long
name|checksum
decl_stmt|,
name|packed_len
decl_stmt|;
comment|/* 	 * Decode token header, which is: 	 *<token version>-<checksum of payload>-<uncompressed payload length> 	 * Note that the only supported token version is 1. 	 */
name|nread
operator|=
name|sscanf
argument_list|(
name|token
argument_list|,
literal|"%u-%llx-%llx-"
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|checksum
argument_list|,
operator|&
name|packed_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
literal|3
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token is corrupt (invalid format)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|version
operator|!=
name|ZFS_SEND_RESUME_TOKEN_VERSION
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token is corrupt (invalid version %u)"
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* convert hexadecimal representation to binary */
name|token
operator|=
name|strrchr
argument_list|(
name|token
argument_list|,
literal|'-'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|token
argument_list|)
operator|/
literal|2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|compressed
init|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|len
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|nread
operator|=
name|sscanf
argument_list|(
name|token
operator|+
name|i
operator|*
literal|2
argument_list|,
literal|"%2hhx"
argument_list|,
name|compressed
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token is corrupt "
literal|"(payload is not hex-encoded)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* verify checksum */
name|zio_cksum_t
name|cksum
decl_stmt|;
name|fletcher_4_native
argument_list|(
name|compressed
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
operator|&
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|cksum
operator|.
name|zc_word
index|[
literal|0
index|]
operator|!=
name|checksum
condition|)
block|{
name|free
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token is corrupt (incorrect checksum)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* uncompress */
name|void
modifier|*
name|packed
init|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|packed_len
argument_list|)
decl_stmt|;
name|uLongf
name|packed_len_long
init|=
name|packed_len
decl_stmt|;
if|if
condition|(
name|uncompress
argument_list|(
name|packed
argument_list|,
operator|&
name|packed_len_long
argument_list|,
name|compressed
argument_list|,
name|len
argument_list|)
operator|!=
name|Z_OK
operator|||
name|packed_len_long
operator|!=
name|packed_len
condition|)
block|{
name|free
argument_list|(
name|packed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token is corrupt (decompression failed)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* unpack nvlist */
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|int
name|error
init|=
name|nvlist_unpack
argument_list|(
name|packed
argument_list|,
name|packed_len
argument_list|,
operator|&
name|nv
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|packed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token is corrupt (nvlist_unpack failed)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_send_resume
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|sendflags_t
modifier|*
name|flags
parameter_list|,
name|int
name|outfd
parameter_list|,
specifier|const
name|char
modifier|*
name|resume_token
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|toname
decl_stmt|;
name|char
modifier|*
name|fromname
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|resumeobj
decl_stmt|,
name|resumeoff
decl_stmt|,
name|toguid
decl_stmt|,
name|fromguid
decl_stmt|,
name|bytes
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|enum
name|lzc_send_flags
name|lzc_flags
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot resume send"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_t
modifier|*
name|resume_nvl
init|=
name|zfs_send_resume_token_to_nvlist
argument_list|(
name|hdl
argument_list|,
name|resume_token
argument_list|)
decl_stmt|;
if|if
condition|(
name|resume_nvl
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * zfs_error_aux has already been set by 		 * zfs_send_resume_token_to_nvlist 		 */
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_FAULT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token contents:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_print
argument_list|(
name|stderr
argument_list|,
name|resume_nvl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|resume_nvl
argument_list|,
literal|"toname"
argument_list|,
operator|&
name|toname
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|resume_nvl
argument_list|,
literal|"object"
argument_list|,
operator|&
name|resumeobj
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|resume_nvl
argument_list|,
literal|"offset"
argument_list|,
operator|&
name|resumeoff
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|resume_nvl
argument_list|,
literal|"bytes"
argument_list|,
operator|&
name|bytes
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|resume_nvl
argument_list|,
literal|"toguid"
argument_list|,
operator|&
name|toguid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"resume token is corrupt"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_FAULT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|fromguid
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|resume_nvl
argument_list|,
literal|"fromguid"
argument_list|,
operator|&
name|fromguid
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|largeblock
operator|||
name|nvlist_exists
argument_list|(
name|resume_nvl
argument_list|,
literal|"largeblockok"
argument_list|)
condition|)
name|lzc_flags
operator||=
name|LZC_SEND_FLAG_LARGE_BLOCK
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|embed_data
operator|||
name|nvlist_exists
argument_list|(
name|resume_nvl
argument_list|,
literal|"embedok"
argument_list|)
condition|)
name|lzc_flags
operator||=
name|LZC_SEND_FLAG_EMBED_DATA
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|compress
operator|||
name|nvlist_exists
argument_list|(
name|resume_nvl
argument_list|,
literal|"compressok"
argument_list|)
condition|)
name|lzc_flags
operator||=
name|LZC_SEND_FLAG_COMPRESS
expr_stmt|;
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|toname
argument_list|,
name|toguid
argument_list|,
name|B_FALSE
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|toname
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' is no longer the same snapshot used in "
literal|"the initial send"
argument_list|)
argument_list|,
name|toname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"'%s' used in the initial send no longer exists"
argument_list|)
argument_list|,
name|toname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"unable to access '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|fromguid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|toname
argument_list|,
name|fromguid
argument_list|,
name|B_TRUE
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"incremental source %#llx no longer exists"
argument_list|)
argument_list|,
operator|(
name|longlong_t
operator|)
name|fromguid
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADPATH
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|fromname
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
name|uint64_t
name|size
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|lzc_send_space
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|fromname
argument_list|,
name|lzc_flags
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|size
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|size
operator|-
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
name|send_print_verbose
argument_list|(
name|stderr
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|fromname
argument_list|,
name|size
argument_list|,
name|flags
operator|->
name|parsable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flags
operator|->
name|dryrun
condition|)
block|{
name|progress_arg_t
name|pa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pthread_t
name|tid
decl_stmt|;
comment|/* 		 * If progress reporting is requested, spawn a new thread to 		 * poll ZFS_IOC_SEND_PROGRESS at a regular interval. 		 */
if|if
condition|(
name|flags
operator|->
name|progress
condition|)
block|{
name|pa
operator|.
name|pa_zhp
operator|=
name|zhp
expr_stmt|;
name|pa
operator|.
name|pa_fd
operator|=
name|outfd
expr_stmt|;
name|pa
operator|.
name|pa_parsable
operator|=
name|flags
operator|->
name|parsable
expr_stmt|;
name|error
operator|=
name|pthread_create
argument_list|(
operator|&
name|tid
argument_list|,
name|NULL
argument_list|,
name|send_progress_thread
argument_list|,
operator|&
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|lzc_send_resume
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|fromname
argument_list|,
name|outfd
argument_list|,
name|lzc_flags
argument_list|,
name|resumeobj
argument_list|,
name|resumeoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|progress
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_cancel
argument_list|(
name|tid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_join
argument_list|(
name|tid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"warning: cannot send '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EXDEV
case|:
case|case
name|ENOENT
case|:
case|case
name|EDQUOT
case|:
case|case
name|EFBIG
case|:
case|case
name|EIO
case|:
case|case
name|ENOLINK
case|:
case|case
name|ENOSPC
case|:
case|case
name|ENOSTR
case|:
case|case
name|ENXIO
case|:
case|case
name|EPIPE
case|:
case|case
name|ERANGE
case|:
case|case
name|EFAULT
case|:
case|case
name|EROFS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADBACKUP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a send stream for the dataset identified by the argument zhp.  *  * The content of the send stream is the snapshot identified by  * 'tosnap'.  Incremental streams are requested in two ways:  *     - from the snapshot identified by "fromsnap" (if non-null) or  *     - from the origin of the dataset identified by zhp, which must  *	 be a clone.  In this case, "fromsnap" is null and "fromorigin"  *	 is TRUE.  *  * The send stream is recursive (i.e. dumps a hierarchy of snapshots) and  * uses a special header (with a hdrtype field of DMU_COMPOUNDSTREAM)  * if "replicate" is set.  If "doall" is set, dump all the intermediate  * snapshots. The DMU_COMPOUNDSTREAM header is used in the "doall"  * case too. If "props" is set, send properties.  */
end_comment

begin_function
name|int
name|zfs_send
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|sendflags_t
modifier|*
name|flags
parameter_list|,
name|int
name|outfd
parameter_list|,
name|snapfilter_cb_t
name|filter_func
parameter_list|,
name|void
modifier|*
name|cb_arg
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|debugnvp
parameter_list|)
block|{
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|send_dump_data_t
name|sdd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|fss
init|=
name|NULL
decl_stmt|;
name|avl_tree_t
modifier|*
name|fsavl
init|=
name|NULL
decl_stmt|;
specifier|static
name|uint64_t
name|holdseq
decl_stmt|;
name|int
name|spa_version
decl_stmt|;
name|pthread_t
name|tid
init|=
literal|0
decl_stmt|;
name|int
name|pipefd
index|[
literal|2
index|]
decl_stmt|;
name|dedup_arg_t
name|dda
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|featureflags
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fout
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot send '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
operator|&&
name|fromsnap
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"zero-length incremental source"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
condition|)
block|{
name|uint64_t
name|version
decl_stmt|;
name|version
operator|=
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|ZPL_VERSION_SA
condition|)
block|{
name|featureflags
operator||=
name|DMU_BACKUP_FEATURE_SA_SPILL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|->
name|dedup
operator|&&
operator|!
name|flags
operator|->
name|dryrun
condition|)
block|{
name|featureflags
operator||=
operator|(
name|DMU_BACKUP_FEATURE_DEDUP
operator||
name|DMU_BACKUP_FEATURE_DEDUPPROPS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|pipe
argument_list|(
name|pipefd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_PIPEFAILED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|dda
operator|.
name|outputfd
operator|=
name|outfd
expr_stmt|;
name|dda
operator|.
name|inputfd
operator|=
name|pipefd
index|[
literal|1
index|]
expr_stmt|;
name|dda
operator|.
name|dedup_hdl
operator|=
name|zhp
operator|->
name|zfs_hdl
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|pthread_create
argument_list|(
operator|&
name|tid
argument_list|,
name|NULL
argument_list|,
name|cksummer
argument_list|,
operator|&
name|dda
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|EZFS_THREADCREATEFAILED
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|->
name|replicate
operator|||
name|flags
operator|->
name|doall
operator|||
name|flags
operator|->
name|props
condition|)
block|{
name|dmu_replay_record_t
name|drr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|packbuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|buflen
init|=
literal|0
decl_stmt|;
name|zio_cksum_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|replicate
operator|||
name|flags
operator|->
name|props
condition|)
block|{
name|nvlist_t
modifier|*
name|hdrnv
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|hdrnv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromsnap
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|hdrnv
argument_list|,
literal|"fromsnap"
argument_list|,
name|fromsnap
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_string
argument_list|(
name|hdrnv
argument_list|,
literal|"tosnap"
argument_list|,
name|tosnap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flags
operator|->
name|replicate
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_boolean
argument_list|(
name|hdrnv
argument_list|,
literal|"not_recursive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|gather_nvlist
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|fromsnap
argument_list|,
name|tosnap
argument_list|,
name|flags
operator|->
name|replicate
argument_list|,
name|flags
operator|->
name|verbose
argument_list|,
operator|&
name|fss
argument_list|,
operator|&
name|fsavl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_out
goto|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_nvlist
argument_list|(
name|hdrnv
argument_list|,
literal|"fss"
argument_list|,
name|fss
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|nvlist_pack
argument_list|(
name|hdrnv
argument_list|,
operator|&
name|packbuf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugnvp
condition|)
operator|*
name|debugnvp
operator|=
name|hdrnv
expr_stmt|;
else|else
name|nvlist_free
argument_list|(
name|hdrnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|stderr_out
goto|;
block|}
if|if
condition|(
operator|!
name|flags
operator|->
name|dryrun
condition|)
block|{
comment|/* write first begin record */
name|drr
operator|.
name|drr_type
operator|=
name|DRR_BEGIN
expr_stmt|;
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_magic
operator|=
name|DMU_BACKUP_MAGIC
expr_stmt|;
name|DMU_SET_STREAM_HDRTYPE
argument_list|(
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_versioninfo
argument_list|,
name|DMU_COMPOUNDSTREAM
argument_list|)
expr_stmt|;
name|DMU_SET_FEATUREFLAGS
argument_list|(
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_versioninfo
argument_list|,
name|featureflags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
name|drr
operator|.
name|drr_payloadlen
operator|=
name|buflen
expr_stmt|;
name|err
operator|=
name|dump_record
argument_list|(
operator|&
name|drr
argument_list|,
name|packbuf
argument_list|,
name|buflen
argument_list|,
operator|&
name|zc
argument_list|,
name|outfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|packbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|stderr_out
goto|;
comment|/* write end record */
name|bzero
argument_list|(
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
expr_stmt|;
name|drr
operator|.
name|drr_type
operator|=
name|DRR_END
expr_stmt|;
name|drr
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|=
name|zc
expr_stmt|;
name|err
operator|=
name|write
argument_list|(
name|outfd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
goto|goto
name|stderr_out
goto|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* dump each stream */
name|sdd
operator|.
name|fromsnap
operator|=
name|fromsnap
expr_stmt|;
name|sdd
operator|.
name|tosnap
operator|=
name|tosnap
expr_stmt|;
if|if
condition|(
name|tid
operator|!=
literal|0
condition|)
name|sdd
operator|.
name|outfd
operator|=
name|pipefd
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sdd
operator|.
name|outfd
operator|=
name|outfd
expr_stmt|;
name|sdd
operator|.
name|replicate
operator|=
name|flags
operator|->
name|replicate
expr_stmt|;
name|sdd
operator|.
name|doall
operator|=
name|flags
operator|->
name|doall
expr_stmt|;
name|sdd
operator|.
name|fromorigin
operator|=
name|flags
operator|->
name|fromorigin
expr_stmt|;
name|sdd
operator|.
name|fss
operator|=
name|fss
expr_stmt|;
name|sdd
operator|.
name|fsavl
operator|=
name|fsavl
expr_stmt|;
name|sdd
operator|.
name|verbose
operator|=
name|flags
operator|->
name|verbose
expr_stmt|;
name|sdd
operator|.
name|parsable
operator|=
name|flags
operator|->
name|parsable
expr_stmt|;
name|sdd
operator|.
name|progress
operator|=
name|flags
operator|->
name|progress
expr_stmt|;
name|sdd
operator|.
name|dryrun
operator|=
name|flags
operator|->
name|dryrun
expr_stmt|;
name|sdd
operator|.
name|large_block
operator|=
name|flags
operator|->
name|largeblock
expr_stmt|;
name|sdd
operator|.
name|embed_data
operator|=
name|flags
operator|->
name|embed_data
expr_stmt|;
name|sdd
operator|.
name|compress
operator|=
name|flags
operator|->
name|compress
expr_stmt|;
name|sdd
operator|.
name|filter_cb
operator|=
name|filter_func
expr_stmt|;
name|sdd
operator|.
name|filter_cb_arg
operator|=
name|cb_arg
expr_stmt|;
if|if
condition|(
name|debugnvp
condition|)
name|sdd
operator|.
name|debugnv
operator|=
operator|*
name|debugnvp
expr_stmt|;
if|if
condition|(
name|sdd
operator|.
name|verbose
operator|&&
name|sdd
operator|.
name|dryrun
condition|)
name|sdd
operator|.
name|std_out
operator|=
name|B_TRUE
expr_stmt|;
name|fout
operator|=
name|sdd
operator|.
name|std_out
condition|?
name|stdout
else|:
name|stderr
expr_stmt|;
comment|/* 	 * Some flags require that we place user holds on the datasets that are 	 * being sent so they don't get destroyed during the send. We can skip 	 * this step if the pool is imported read-only since the datasets cannot 	 * be destroyed. 	 */
if|if
condition|(
operator|!
name|flags
operator|->
name|dryrun
operator|&&
operator|!
name|zpool_get_prop_int
argument_list|(
name|zfs_get_pool_handle
argument_list|(
name|zhp
argument_list|)
argument_list|,
name|ZPOOL_PROP_READONLY
argument_list|,
name|NULL
argument_list|)
operator|&&
name|zfs_spa_version
argument_list|(
name|zhp
argument_list|,
operator|&
name|spa_version
argument_list|)
operator|==
literal|0
operator|&&
name|spa_version
operator|>=
name|SPA_VERSION_USERREFS
operator|&&
operator|(
name|flags
operator|->
name|doall
operator|||
name|flags
operator|->
name|replicate
operator|)
condition|)
block|{
operator|++
name|holdseq
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sdd
operator|.
name|holdtag
argument_list|,
sizeof|sizeof
argument_list|(
name|sdd
operator|.
name|holdtag
argument_list|)
argument_list|,
literal|".send-%d-%llu"
argument_list|,
name|getpid
argument_list|()
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|holdseq
argument_list|)
expr_stmt|;
name|sdd
operator|.
name|cleanup_fd
operator|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
operator||
name|O_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdd
operator|.
name|cleanup_fd
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
goto|goto
name|stderr_out
goto|;
block|}
name|sdd
operator|.
name|snapholds
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sdd
operator|.
name|cleanup_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|sdd
operator|.
name|snapholds
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|->
name|verbose
operator|||
name|sdd
operator|.
name|snapholds
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Do a verbose no-op dry run to get all the verbose output 		 * or to gather snapshot hold's before generating any data, 		 * then do a non-verbose real run to generate the streams. 		 */
name|sdd
operator|.
name|dryrun
operator|=
name|B_TRUE
expr_stmt|;
name|err
operator|=
name|dump_filesystems
argument_list|(
name|zhp
argument_list|,
operator|&
name|sdd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|stderr_out
goto|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
if|if
condition|(
name|flags
operator|->
name|parsable
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"size\t%llu\n"
argument_list|,
operator|(
name|longlong_t
operator|)
name|sdd
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|zfs_nicenum
argument_list|(
name|sdd
operator|.
name|size
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fout
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"total estimated size is %s\n"
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ensure no snaps found is treated as an error. */
if|if
condition|(
operator|!
name|sdd
operator|.
name|seento
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
comment|/* Skip the second run if dryrun was requested. */
if|if
condition|(
name|flags
operator|->
name|dryrun
condition|)
goto|goto
name|err_out
goto|;
if|if
condition|(
name|sdd
operator|.
name|snapholds
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|zfs_hold_nvl
argument_list|(
name|zhp
argument_list|,
name|sdd
operator|.
name|cleanup_fd
argument_list|,
name|sdd
operator|.
name|snapholds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|stderr_out
goto|;
name|fnvlist_free
argument_list|(
name|sdd
operator|.
name|snapholds
argument_list|)
expr_stmt|;
name|sdd
operator|.
name|snapholds
operator|=
name|NULL
expr_stmt|;
block|}
name|sdd
operator|.
name|dryrun
operator|=
name|B_FALSE
expr_stmt|;
name|sdd
operator|.
name|verbose
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|err
operator|=
name|dump_filesystems
argument_list|(
name|zhp
argument_list|,
operator|&
name|sdd
argument_list|)
expr_stmt|;
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|fss
argument_list|)
expr_stmt|;
comment|/* Ensure no snaps found is treated as an error. */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|sdd
operator|.
name|seento
condition|)
name|err
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|tid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|pthread_cancel
argument_list|(
name|tid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_join
argument_list|(
name|tid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sdd
operator|.
name|cleanup_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|close
argument_list|(
name|sdd
operator|.
name|cleanup_fd
argument_list|)
argument_list|)
expr_stmt|;
name|sdd
operator|.
name|cleanup_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flags
operator|->
name|dryrun
operator|&&
operator|(
name|flags
operator|->
name|replicate
operator|||
name|flags
operator|->
name|doall
operator|||
name|flags
operator|->
name|props
operator|)
condition|)
block|{
comment|/* 		 * write final end record.  NB: want to do this even if 		 * there was some error, because it might not be totally 		 * failed. 		 */
name|dmu_replay_record_t
name|drr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|drr
operator|.
name|drr_type
operator|=
name|DRR_END
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outfd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|err
operator|||
name|sdd
operator|.
name|err
operator|)
return|;
name|stderr_out
label|:
name|err
operator|=
name|zfs_standard_error
argument_list|(
name|zhp
operator|->
name|zfs_hdl
argument_list|,
name|err
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
name|err_out
label|:
name|fsavl_destroy
argument_list|(
name|fsavl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|fss
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|sdd
operator|.
name|snapholds
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdd
operator|.
name|cleanup_fd
operator|!=
operator|-
literal|1
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|close
argument_list|(
name|sdd
operator|.
name|cleanup_fd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|pthread_cancel
argument_list|(
name|tid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pthread_join
argument_list|(
name|tid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_send_one
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|int
name|fd
parameter_list|,
name|enum
name|lzc_send_flags
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|libzfs_handle_t
modifier|*
name|hdl
init|=
name|zhp
operator|->
name|zfs_hdl
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"warning: cannot send '%s'"
argument_list|)
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|lzc_send
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
name|from
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EXDEV
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"not an earlier snapshot from the same fs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_CROSSTARGET
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|ENOENT
case|:
case|case
name|ESRCH
case|:
if|if
condition|(
name|lzc_exists
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"incremental source (%s) does not exist"
argument_list|)
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EBUSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"target is busy; if a filesystem, "
literal|"it must not be mounted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BUSY
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
case|case
name|EDQUOT
case|:
case|case
name|EFBIG
case|:
case|case
name|EIO
case|:
case|case
name|ENOLINK
case|:
case|case
name|ENOSPC
case|:
case|case
name|ENOSTR
case|:
case|case
name|ENXIO
case|:
case|case
name|EPIPE
case|:
case|case
name|ERANGE
case|:
case|case
name|EFAULT
case|:
case|case
name|EROFS
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADBACKUP
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|errno
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines specific to "zfs recv"  */
end_comment

begin_function
specifier|static
name|int
name|recv_read
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|ilen
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|,
name|zio_cksum_t
modifier|*
name|zc
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|len
init|=
name|ilen
decl_stmt|;
name|assert
argument_list|(
name|ilen
operator|<=
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rv
expr_stmt|;
name|len
operator|-=
name|rv
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|rv
operator|<
literal|0
operator|||
name|len
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"failed to read from stream"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zc
condition|)
block|{
if|if
condition|(
name|byteswap
condition|)
name|fletcher_4_incremental_byteswap
argument_list|(
name|buf
argument_list|,
name|ilen
argument_list|,
name|zc
argument_list|)
expr_stmt|;
else|else
name|fletcher_4_incremental_native
argument_list|(
name|buf
argument_list|,
name|ilen
argument_list|,
name|zc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_read_nvlist
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|len
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|,
name|zio_cksum_t
modifier|*
name|zc
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|buf
operator|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|err
operator|=
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|byteswap
argument_list|,
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|nvlist_unpack
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|nvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (malformed nvlist)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_rename
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|tryname
parameter_list|,
name|int
name|baselen
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|recvflags_t
modifier|*
name|flags
parameter_list|)
block|{
specifier|static
name|int
name|seq
decl_stmt|;
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
name|flags
operator|->
name|force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryname
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newname
argument_list|,
name|tryname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|tryname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"attempting rename %s to %s\n"
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_RENAME
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|changelist_rename
argument_list|(
name|clp
argument_list|,
name|name
argument_list|,
name|tryname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
operator|+
name|baselen
argument_list|,
literal|"recv-"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|seq
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|newname
argument_list|,
name|ZFS_MAX_DATASET_NAME_LEN
argument_list|,
literal|"%.*srecv-%u-%u"
argument_list|,
name|baselen
argument_list|,
name|name
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|seq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"failed - trying rename %s to %s\n"
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_RENAME
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|changelist_rename
argument_list|(
name|clp
argument_list|,
name|name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"failed (%u) - "
literal|"will try again on next pass\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|EAGAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"success\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"failed (%u)\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_destroy
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|baselen
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|recvflags_t
modifier|*
name|flags
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|boolean_t
name|defer
init|=
name|B_FALSE
decl_stmt|;
name|int
name|spa_version
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
name|flags
operator|->
name|force
condition|?
name|MS_FORCE
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_get_type
argument_list|(
name|zhp
argument_list|)
operator|==
name|ZFS_TYPE_SNAPSHOT
operator|&&
name|zfs_spa_version
argument_list|(
name|zhp
argument_list|,
operator|&
name|spa_version
argument_list|)
operator|==
literal|0
operator|&&
name|spa_version
operator|>=
name|SPA_VERSION_USERREFS
condition|)
name|defer
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|err
operator|=
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|zc
operator|.
name|zc_objset_type
operator|=
name|DMU_OST_ZFS
expr_stmt|;
name|zc
operator|.
name|zc_defer_destroy
operator|=
name|defer
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"attempting destroy %s\n"
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
name|err
operator|=
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_DESTROY
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"success\n"
argument_list|)
expr_stmt|;
name|changelist_remove
argument_list|(
name|clp
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
comment|/* 	 * Deferred destroy might destroy the snapshot or only mark it to be 	 * destroyed later, and it returns success in either case. 	 */
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
operator|(
name|defer
operator|&&
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
operator|)
condition|)
block|{
name|err
operator|=
name|recv_rename
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|baselen
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|guid_to_name_data
block|{
name|uint64_t
name|guid
decl_stmt|;
name|boolean_t
name|bookmark_ok
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|skip
decl_stmt|;
block|}
name|guid_to_name_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|guid_to_name_cb
parameter_list|(
name|zfs_handle_t
modifier|*
name|zhp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|guid_to_name_data_t
modifier|*
name|gtnd
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|gtnd
operator|->
name|skip
operator|!=
name|NULL
operator|&&
operator|(
name|slash
operator|=
name|strrchr
argument_list|(
name|zhp
operator|->
name|zfs_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|slash
operator|+
literal|1
argument_list|,
name|gtnd
operator|->
name|skip
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_GUID
argument_list|)
operator|==
name|gtnd
operator|->
name|guid
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|gtnd
operator|->
name|name
argument_list|,
name|zhp
operator|->
name|zfs_name
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|err
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|guid_to_name_cb
argument_list|,
name|gtnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EEXIST
operator|&&
name|gtnd
operator|->
name|bookmark_ok
condition|)
name|err
operator|=
name|zfs_iter_bookmarks
argument_list|(
name|zhp
argument_list|,
name|guid_to_name_cb
argument_list|,
name|gtnd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to find the local dataset associated with this guid.  In the case of  * multiple matches, we attempt to find the "best" match by searching  * progressively larger portions of the hierarchy.  This allows one to send a  * tree of datasets individually and guarantee that we will find the source  * guid within that hierarchy, even if there are multiple matches elsewhere.  */
end_comment

begin_function
specifier|static
name|int
name|guid_to_name
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|bookmark_ok
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|pname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|guid_to_name_data_t
name|gtnd
decl_stmt|;
name|gtnd
operator|.
name|guid
operator|=
name|guid
expr_stmt|;
name|gtnd
operator|.
name|bookmark_ok
operator|=
name|bookmark_ok
expr_stmt|;
name|gtnd
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|gtnd
operator|.
name|skip
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Search progressively larger portions of the hierarchy, starting 	 * with the filesystem specified by 'parent'.  This will 	 * select the "most local" version of the origin snapshot in the case 	 * that there are multiple matching snapshots in the system. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pname
argument_list|,
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|pname
argument_list|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|cp
init|=
name|strrchr
argument_list|(
name|pname
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|pname
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|strrchr
argument_list|(
name|pname
argument_list|,
literal|'/'
argument_list|)
control|)
block|{
comment|/* Chop off the last component and open the parent */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|make_dataset_handle
argument_list|(
name|hdl
argument_list|,
name|pname
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
continue|continue;
name|int
name|err
init|=
name|guid_to_name_cb
argument_list|(
name|zfs_handle_dup
argument_list|(
name|zhp
argument_list|)
argument_list|,
operator|&
name|gtnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|EEXIST
condition|)
name|err
operator|=
name|zfs_iter_children
argument_list|(
name|zhp
argument_list|,
name|guid_to_name_cb
argument_list|,
operator|&
name|gtnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EEXIST
operator|&&
name|bookmark_ok
condition|)
name|err
operator|=
name|zfs_iter_bookmarks
argument_list|(
name|zhp
argument_list|,
name|guid_to_name_cb
argument_list|,
operator|&
name|gtnd
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EEXIST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Remember the last portion of the dataset so we skip it next 		 * time through (as we've already searched that portion of the 		 * hierarchy). 		 */
name|gtnd
operator|.
name|skip
operator|=
name|strrchr
argument_list|(
name|pname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return +1 if guid1 is before guid2, 0 if they are the same, and -1 if  * guid1 is after guid2.  */
end_comment

begin_function
specifier|static
name|int
name|created_before
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|,
name|uint64_t
name|guid1
parameter_list|,
name|uint64_t
name|guid2
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|;
name|char
modifier|*
name|fsname
decl_stmt|,
modifier|*
name|snapname
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|zfs_handle_t
modifier|*
name|guid1hdl
decl_stmt|,
modifier|*
name|guid2hdl
decl_stmt|;
name|uint64_t
name|create1
decl_stmt|,
name|create2
decl_stmt|;
if|if
condition|(
name|guid2
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|guid1
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|nvfs
operator|=
name|fsavl_find
argument_list|(
name|avl
argument_list|,
name|guid1
argument_list|,
operator|&
name|snapname
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|guid1hdl
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|buf
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid1hdl
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nvfs
operator|=
name|fsavl_find
argument_list|(
name|avl
argument_list|,
name|guid2
argument_list|,
operator|&
name|snapname
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|guid2hdl
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|buf
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid2hdl
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|guid1hdl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|create1
operator|=
name|zfs_prop_get_int
argument_list|(
name|guid1hdl
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
name|create2
operator|=
name|zfs_prop_get_int
argument_list|(
name|guid2hdl
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|)
expr_stmt|;
if|if
condition|(
name|create1
operator|<
name|create2
condition|)
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|create1
operator|>
name|create2
condition|)
name|rv
operator|=
operator|+
literal|1
expr_stmt|;
else|else
name|rv
operator|=
literal|0
expr_stmt|;
name|zfs_close
argument_list|(
name|guid1hdl
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|guid2hdl
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_incremental_replication
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|tofs
parameter_list|,
name|recvflags_t
modifier|*
name|flags
parameter_list|,
name|nvlist_t
modifier|*
name|stream_nv
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|,
name|nvlist_t
modifier|*
name|renamed
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|local_nv
decl_stmt|;
name|avl_tree_t
modifier|*
name|local_avl
decl_stmt|;
name|nvpair_t
modifier|*
name|fselem
decl_stmt|,
modifier|*
name|nextfselem
decl_stmt|;
name|char
modifier|*
name|fromsnap
decl_stmt|;
name|char
name|newname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|needagain
decl_stmt|,
name|progress
decl_stmt|,
name|recursive
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|stream_nv
argument_list|,
literal|"fromsnap"
argument_list|,
operator|&
name|fromsnap
argument_list|)
argument_list|)
expr_stmt|;
name|recursive
operator|=
operator|(
name|nvlist_lookup_boolean
argument_list|(
name|stream_nv
argument_list|,
literal|"not_recursive"
argument_list|)
operator|==
name|ENOENT
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|dryrun
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|again
label|:
name|needagain
operator|=
name|progress
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gather_nvlist
argument_list|(
name|hdl
argument_list|,
name|tofs
argument_list|,
name|fromsnap
argument_list|,
name|NULL
argument_list|,
name|recursive
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|local_nv
argument_list|,
operator|&
name|local_avl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Process deletes and renames 	 */
for|for
control|(
name|fselem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|local_nv
argument_list|,
name|NULL
argument_list|)
init|;
name|fselem
condition|;
name|fselem
operator|=
name|nextfselem
control|)
block|{
name|nvlist_t
modifier|*
name|nvfs
decl_stmt|,
modifier|*
name|snaps
decl_stmt|;
name|nvlist_t
modifier|*
name|stream_nvfs
init|=
name|NULL
decl_stmt|;
name|nvpair_t
modifier|*
name|snapelem
decl_stmt|,
modifier|*
name|nextsnapelem
decl_stmt|;
name|uint64_t
name|fromguid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|originguid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|stream_originguid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|parent_fromsnap_guid
decl_stmt|,
name|stream_parent_fromsnap_guid
decl_stmt|;
name|char
modifier|*
name|fsname
decl_stmt|,
modifier|*
name|stream_fsname
decl_stmt|;
name|nextfselem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|local_nv
argument_list|,
name|fselem
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_nvlist
argument_list|(
name|fselem
argument_list|,
operator|&
name|nvfs
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|nvfs
argument_list|,
literal|"snaps"
argument_list|,
operator|&
name|snaps
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"parentfromsnap"
argument_list|,
operator|&
name|parent_fromsnap_guid
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nvfs
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|originguid
argument_list|)
expr_stmt|;
comment|/* 		 * First find the stream's fs, so we can check for 		 * a different origin (due to "zfs promote") 		 */
for|for
control|(
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|snapelem
condition|;
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|snapelem
argument_list|)
control|)
block|{
name|uint64_t
name|thisguid
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_uint64
argument_list|(
name|snapelem
argument_list|,
operator|&
name|thisguid
argument_list|)
argument_list|)
expr_stmt|;
name|stream_nvfs
operator|=
name|fsavl_find
argument_list|(
name|stream_avl
argument_list|,
name|thisguid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream_nvfs
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* check for promote */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|stream_nvfs
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|stream_originguid
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream_nvfs
operator|&&
name|originguid
operator|!=
name|stream_originguid
condition|)
block|{
switch|switch
condition|(
name|created_before
argument_list|(
name|hdl
argument_list|,
name|local_avl
argument_list|,
name|stream_originguid
argument_list|,
name|originguid
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
block|{
comment|/* promote it! */
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|nvlist_t
modifier|*
name|origin_nvfs
decl_stmt|;
name|char
modifier|*
name|origin_fsname
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"promoting %s\n"
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
name|origin_nvfs
operator|=
name|fsavl_find
argument_list|(
name|local_avl
argument_list|,
name|originguid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|origin_nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|origin_fsname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|origin_fsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|fsname
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_PROMOTE
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|progress
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
default|default:
break|break;
case|case
operator|-
literal|1
case|:
name|fsavl_destroy
argument_list|(
name|local_avl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|local_nv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * We had/have the wrong origin, therefore our 			 * list of snapshots is wrong.  Need to handle 			 * them on the next pass. 			 */
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|snapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|snapelem
condition|;
name|snapelem
operator|=
name|nextsnapelem
control|)
block|{
name|uint64_t
name|thisguid
decl_stmt|;
name|char
modifier|*
name|stream_snapname
decl_stmt|;
name|nvlist_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|props
decl_stmt|;
name|nextsnapelem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|snapelem
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvpair_value_uint64
argument_list|(
name|snapelem
argument_list|,
operator|&
name|thisguid
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|fsavl_find
argument_list|(
name|stream_avl
argument_list|,
name|thisguid
argument_list|,
operator|&
name|stream_snapname
argument_list|)
expr_stmt|;
comment|/* check for delete */
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|flags
operator|->
name|force
condition|)
continue|continue;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|recv_destroy
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|fsname
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
name|stream_nvfs
operator|=
name|found
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|stream_nvfs
argument_list|,
literal|"snapprops"
argument_list|,
operator|&
name|props
argument_list|)
operator|&&
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|props
argument_list|,
name|stream_snapname
argument_list|,
operator|&
name|props
argument_list|)
condition|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|B_TRUE
expr_stmt|;
comment|/* received */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check for different snapname */
if|if
condition|(
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|,
name|stream_snapname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|tryname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|nvpair_name
argument_list|(
name|snapelem
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tryname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|stream_snapname
argument_list|)
expr_stmt|;
name|error
operator|=
name|recv_rename
argument_list|(
name|hdl
argument_list|,
name|name
argument_list|,
name|tryname
argument_list|,
name|strlen
argument_list|(
name|fsname
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|stream_snapname
argument_list|,
name|fromsnap
argument_list|)
operator|==
literal|0
condition|)
name|fromguid
operator|=
name|thisguid
expr_stmt|;
block|}
comment|/* check for delete */
if|if
condition|(
name|stream_nvfs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|->
name|force
condition|)
continue|continue;
name|error
operator|=
name|recv_destroy
argument_list|(
name|hdl
argument_list|,
name|fsname
argument_list|,
name|strlen
argument_list|(
name|tofs
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fromguid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"local fs %s does not have "
literal|"fromsnap (%s in stream); must have "
literal|"been deleted locally; ignoring\n"
argument_list|,
name|fsname
argument_list|,
name|fromsnap
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|stream_nvfs
argument_list|,
literal|"name"
argument_list|,
operator|&
name|stream_fsname
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_uint64
argument_list|(
name|stream_nvfs
argument_list|,
literal|"parentfromsnap"
argument_list|,
operator|&
name|stream_parent_fromsnap_guid
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
name|strrchr
argument_list|(
name|fsname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|s2
operator|=
name|strrchr
argument_list|(
name|stream_fsname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* 		 * Check for rename. If the exact receive path is specified, it 		 * does not count as a rename, but we still need to check the 		 * datasets beneath it. 		 */
if|if
condition|(
operator|(
name|stream_parent_fromsnap_guid
operator|!=
literal|0
operator|&&
name|parent_fromsnap_guid
operator|!=
literal|0
operator|&&
name|stream_parent_fromsnap_guid
operator|!=
name|parent_fromsnap_guid
operator|)
operator|||
operator|(
operator|(
name|flags
operator|->
name|isprefix
operator|||
name|strcmp
argument_list|(
name|tofs
argument_list|,
name|fsname
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|s1
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|s2
operator|!=
name|NULL
operator|)
operator|&&
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|nvlist_t
modifier|*
name|parent
decl_stmt|;
name|char
name|tryname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|parent
operator|=
name|fsavl_find
argument_list|(
name|local_avl
argument_list|,
name|stream_parent_fromsnap_guid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * NB: parent might not be found if we used the 			 * tosnap for stream_parent_fromsnap_guid, 			 * because the parent is a newly-created fs; 			 * we'll be able to rename it after we recv the 			 * new fs. 			 */
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|pname
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_string
argument_list|(
name|parent
argument_list|,
literal|"name"
argument_list|,
operator|&
name|pname
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tryname
argument_list|,
sizeof|sizeof
argument_list|(
name|tryname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|pname
argument_list|,
name|strrchr
argument_list|(
name|stream_fsname
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tryname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"local fs %s new parent "
literal|"not found\n"
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
block|}
block|}
name|newname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|recv_rename
argument_list|(
name|hdl
argument_list|,
name|fsname
argument_list|,
name|tryname
argument_list|,
name|strlen
argument_list|(
name|tofs
argument_list|)
operator|+
literal|1
argument_list|,
name|newname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|renamed
operator|!=
name|NULL
operator|&&
name|newname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_boolean
argument_list|(
name|renamed
argument_list|,
name|newname
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|needagain
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|progress
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
name|fsavl_destroy
argument_list|(
name|local_avl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|local_nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|needagain
operator|&&
name|progress
condition|)
block|{
comment|/* do another pass to fix up temporary names */
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"another pass:\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|needagain
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_receive_package
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|destname
parameter_list|,
name|recvflags_t
modifier|*
name|flags
parameter_list|,
name|dmu_replay_record_t
modifier|*
name|drr
parameter_list|,
name|zio_cksum_t
modifier|*
name|zc
parameter_list|,
name|char
modifier|*
modifier|*
name|top_zfs
parameter_list|,
name|int
name|cleanup_fd
parameter_list|,
name|uint64_t
modifier|*
name|action_handlep
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|stream_nv
init|=
name|NULL
decl_stmt|;
name|avl_tree_t
modifier|*
name|stream_avl
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fromsnap
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|sendsnap
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|tofs
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|sendfs
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|dmu_replay_record_t
name|drre
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|anyerr
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|softerr
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|recursive
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|drr
operator|->
name|drr_type
operator|==
name|DRR_BEGIN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_magic
operator|==
name|DMU_BACKUP_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|DMU_GET_STREAM_HDRTYPE
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_versioninfo
argument_list|)
operator|==
name|DMU_COMPOUNDSTREAM
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the nvlist from the stream. 	 */
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|recv_read_nvlist
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|drr
operator|->
name|drr_payloadlen
argument_list|,
operator|&
name|stream_nv
argument_list|,
name|flags
operator|->
name|byteswap
argument_list|,
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|recursive
operator|=
operator|(
name|nvlist_lookup_boolean
argument_list|(
name|stream_nv
argument_list|,
literal|"not_recursive"
argument_list|)
operator|==
name|ENOENT
operator|)
expr_stmt|;
if|if
condition|(
name|recursive
operator|&&
name|strchr
argument_list|(
name|destname
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot specify snapshot name for multi-snapshot stream"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Read in the end record and verify checksum. 	 */
if|if
condition|(
literal|0
operator|!=
operator|(
name|error
operator|=
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
operator|&
name|drre
argument_list|,
sizeof|sizeof
argument_list|(
name|drre
argument_list|)
argument_list|,
name|flags
operator|->
name|byteswap
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|flags
operator|->
name|byteswap
condition|)
block|{
name|drre
operator|.
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drre
operator|.
name|drr_type
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|0
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|1
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|2
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|3
index|]
operator|=
name|BSWAP_64
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
operator|.
name|zc_word
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drre
operator|.
name|drr_type
operator|!=
name|DRR_END
condition|)
block|{
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|drre
operator|.
name|drr_u
operator|.
name|drr_end
operator|.
name|drr_checksum
argument_list|,
operator|*
name|zc
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"incorrect header checksum"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|stream_nv
argument_list|,
literal|"fromsnap"
argument_list|,
operator|&
name|fromsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
condition|)
block|{
name|nvlist_t
modifier|*
name|stream_fss
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|stream_nv
argument_list|,
literal|"fss"
argument_list|,
operator|&
name|stream_fss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stream_avl
operator|=
name|fsavl_create
argument_list|(
name|stream_fss
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"couldn't allocate avl tree"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOMEM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fromsnap
operator|!=
name|NULL
operator|&&
name|recursive
condition|)
block|{
name|nvlist_t
modifier|*
name|renamed
init|=
name|NULL
decl_stmt|;
name|nvpair_t
modifier|*
name|pair
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tofs
argument_list|,
name|destname
argument_list|,
sizeof|sizeof
argument_list|(
name|tofs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|isprefix
condition|)
block|{
name|struct
name|drr_begin
modifier|*
name|drrb
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|flags
operator|->
name|istail
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|tofs
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|tofs
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
name|cp
operator|-
name|drrb
operator|->
name|drr_toname
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|strcspn
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|,
literal|"/@"
argument_list|)
expr_stmt|;
block|}
comment|/* zfs_receive_one() will create_parents() */
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|tofs
argument_list|,
operator|&
name|drrb
operator|->
name|drr_toname
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|tofs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|tofs
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flags
operator|->
name|dryrun
operator|&&
operator|!
name|flags
operator|->
name|nomount
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|renamed
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|softerr
operator|=
name|recv_incremental_replication
argument_list|(
name|hdl
argument_list|,
name|tofs
argument_list|,
name|flags
argument_list|,
name|stream_nv
argument_list|,
name|stream_avl
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
comment|/* Unmount renamed filesystems before receiving. */
while|while
condition|(
operator|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|renamed
argument_list|,
name|pair
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
init|=
name|NULL
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|!=
name|NULL
condition|)
block|{
name|softerr
operator||=
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|nvlist_free
argument_list|(
name|renamed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Get the fs specified by the first path in the stream (the top level 	 * specified by 'zfs send') and pass it to each invocation of 	 * zfs_receive_one(). 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|sendfs
argument_list|,
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|,
sizeof|sizeof
argument_list|(
name|sendfs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|sendfs
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Find the "sendsnap", the final snapshot in a replication 		 * stream.  zfs_receive_one() handles certain errors 		 * differently, depending on if the contained stream is the 		 * last one or not. 		 */
name|sendsnap
operator|=
operator|(
name|cp
operator|+
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Finally, receive each contained stream */
do|do
block|{
comment|/* 		 * we should figure out if it has a recoverable 		 * error, in which case do a recv_skip() and drive on. 		 * Note, if we fail due to already having this guid, 		 * zfs_receive_one() will take care of it (ie, 		 * recv_skip() and return 0). 		 */
name|error
operator|=
name|zfs_receive_impl
argument_list|(
name|hdl
argument_list|,
name|destname
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|sendfs
argument_list|,
name|stream_nv
argument_list|,
name|stream_avl
argument_list|,
name|top_zfs
argument_list|,
name|cleanup_fd
argument_list|,
name|action_handlep
argument_list|,
name|sendsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENODATA
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|anyerr
operator||=
name|error
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
operator|&&
name|recursive
operator|&&
name|fromsnap
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Now that we have the fs's they sent us, try the 		 * renames again. 		 */
name|softerr
operator|=
name|recv_incremental_replication
argument_list|(
name|hdl
argument_list|,
name|tofs
argument_list|,
name|flags
argument_list|,
name|stream_nv
argument_list|,
name|stream_avl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|fsavl_destroy
argument_list|(
name|stream_avl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|stream_nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|softerr
condition|)
name|error
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|anyerr
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunc_prop_errs
parameter_list|(
name|int
name|truncated
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|truncated
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|truncated
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"1 more property could not be set\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"%d more properties could not be set\n"
argument_list|)
argument_list|,
name|truncated
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|recv_skip
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|fd
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|dmu_replay_record_t
modifier|*
name|drr
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|zfs_alloc
argument_list|(
name|hdl
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive:"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX would be great to use lseek if possible... */
name|drr
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_replay_record_t
argument_list|)
argument_list|,
name|byteswap
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|byteswap
condition|)
name|drr
operator|->
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|->
name|drr_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|drr
operator|->
name|drr_type
condition|)
block|{
case|case
name|DRR_BEGIN
case|:
if|if
condition|(
name|drr
operator|->
name|drr_payloadlen
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|drr
operator|->
name|drr_payloadlen
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DRR_END
case|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DRR_OBJECT
case|:
if|if
condition|(
name|byteswap
condition|)
block|{
name|drr
operator|->
name|drr_u
operator|.
name|drr_object
operator|.
name|drr_bonuslen
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_object
operator|.
name|drr_bonuslen
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|P2ROUNDUP
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_object
operator|.
name|drr_bonuslen
argument_list|,
literal|8
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRR_WRITE
case|:
if|if
condition|(
name|byteswap
condition|)
block|{
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
operator|.
name|drr_logical_size
operator|=
name|BSWAP_64
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
operator|.
name|drr_logical_size
argument_list|)
expr_stmt|;
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
operator|.
name|drr_compressed_size
operator|=
name|BSWAP_64
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
operator|.
name|drr_compressed_size
argument_list|)
expr_stmt|;
block|}
name|uint64_t
name|payload_size
init|=
name|DRR_WRITE_PAYLOAD_SIZE
argument_list|(
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_write
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|payload_size
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRR_SPILL
case|:
if|if
condition|(
name|byteswap
condition|)
block|{
name|drr
operator|->
name|drr_u
operator|.
name|drr_spill
operator|.
name|drr_length
operator|=
name|BSWAP_64
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_spill
operator|.
name|drr_length
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|drr
operator|->
name|drr_u
operator|.
name|drr_spill
operator|.
name|drr_length
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRR_WRITE_EMBEDDED
case|:
if|if
condition|(
name|byteswap
condition|)
block|{
name|drr
operator|->
name|drr_u
operator|.
name|drr_write_embedded
operator|.
name|drr_psize
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_write_embedded
operator|.
name|drr_psize
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|P2ROUNDUP
argument_list|(
name|drr
operator|->
name|drr_u
operator|.
name|drr_write_embedded
operator|.
name|drr_psize
argument_list|,
literal|8
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRR_WRITE_BYREF
case|:
case|case
name|DRR_FREEOBJECTS
case|:
case|case
name|DRR_FREE
case|:
break|break;
default|default:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid record type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recv_ecksum_set_aux
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|target_snap
parameter_list|,
name|boolean_t
name|resumable
parameter_list|)
block|{
name|char
name|target_fs
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"checksum mismatch or incomplete stream"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resumable
condition|)
return|return;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|target_fs
argument_list|,
name|target_snap
argument_list|,
sizeof|sizeof
argument_list|(
name|target_fs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|target_fs
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|zfs_handle_t
modifier|*
name|zhp
init|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|target_fs
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
decl_stmt|;
if|if
condition|(
name|zhp
operator|==
name|NULL
condition|)
return|return;
name|char
name|token_buf
index|[
name|ZFS_MAXPROPLEN
index|]
decl_stmt|;
name|int
name|error
init|=
name|zfs_prop_get
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_RECEIVE_RESUME_TOKEN
argument_list|,
name|token_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|token_buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"checksum mismatch or incomplete stream.\n"
literal|"Partially received snapshot is saved.\n"
literal|"A resuming stream can be generated on the sending "
literal|"system by running:\n"
literal|"    zfs send -t %s"
argument_list|)
argument_list|,
name|token_buf
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restores a backup of tosnap from the file descriptor specified by infd.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_receive_one
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
name|int
name|infd
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
specifier|const
name|char
modifier|*
name|originsnap
parameter_list|,
name|recvflags_t
modifier|*
name|flags
parameter_list|,
name|dmu_replay_record_t
modifier|*
name|drr
parameter_list|,
name|dmu_replay_record_t
modifier|*
name|drr_noswap
parameter_list|,
specifier|const
name|char
modifier|*
name|sendfs
parameter_list|,
name|nvlist_t
modifier|*
name|stream_nv
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|,
name|char
modifier|*
modifier|*
name|top_zfs
parameter_list|,
name|int
name|cleanup_fd
parameter_list|,
name|uint64_t
modifier|*
name|action_handlep
parameter_list|,
specifier|const
name|char
modifier|*
name|finalsnap
parameter_list|)
block|{
name|zfs_cmd_t
name|zc
init|=
block|{
literal|0
block|}
decl_stmt|;
name|time_t
name|begin_time
decl_stmt|;
name|int
name|ioctl_err
decl_stmt|,
name|ioctl_errno
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|drr_begin
modifier|*
name|drrb
init|=
operator|&
name|drr
operator|->
name|drr_u
operator|.
name|drr_begin
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|prop_errbuf
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|chopprefix
decl_stmt|;
name|boolean_t
name|newfs
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|stream_wantsnewfs
decl_stmt|;
name|uint64_t
name|parent_snapguid
init|=
literal|0
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|snapprops_nvlist
init|=
name|NULL
decl_stmt|;
name|zprop_errflags_t
name|prop_errflags
decl_stmt|;
name|boolean_t
name|recursive
decl_stmt|;
name|char
modifier|*
name|snapname
init|=
name|NULL
decl_stmt|;
name|begin_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
expr_stmt|;
name|recursive
operator|=
operator|(
name|nvlist_lookup_boolean
argument_list|(
name|stream_nv
argument_list|,
literal|"not_recursive"
argument_list|)
operator|==
name|ENOENT
operator|)
expr_stmt|;
if|if
condition|(
name|stream_avl
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|fs
init|=
name|fsavl_find
argument_list|(
name|stream_avl
argument_list|,
name|drrb
operator|->
name|drr_toguid
argument_list|,
operator|&
name|snapname
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|props
decl_stmt|;
name|int
name|ret
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|fs
argument_list|,
literal|"parentfromsnap"
argument_list|,
operator|&
name|parent_snapguid
argument_list|)
expr_stmt|;
name|err
operator|=
name|nvlist_lookup_nvlist
argument_list|(
name|fs
argument_list|,
literal|"props"
argument_list|,
operator|&
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
operator|&
name|props
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|canmountoff
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CANMOUNT
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc
argument_list|,
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|nvlist_free
argument_list|(
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|fs
argument_list|,
literal|"snapprops"
argument_list|,
operator|&
name|props
argument_list|)
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_lookup_nvlist
argument_list|(
name|props
argument_list|,
name|snapname
argument_list|,
operator|&
name|snapprops_nvlist
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Determine how much of the snapshot name stored in the stream 	 * we are going to tack on to the name they specified on the 	 * command line, and how much we are going to chop off. 	 * 	 * If they specified a snapshot, chop the entire name stored in 	 * the stream. 	 */
if|if
condition|(
name|flags
operator|->
name|istail
condition|)
block|{
comment|/* 		 * A filesystem was specified with -e. We want to tack on only 		 * the tail of the sent snapshot path. 		 */
if|if
condition|(
name|strchr
argument_list|(
name|tosnap
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"argument - snapshot not allowed with -e"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|chopprefix
operator|=
name|strrchr
argument_list|(
name|sendfs
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|chopprefix
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * The tail is the poolname, so we need to 			 * prepend a path separator. 			 */
name|int
name|len
init|=
name|strlen
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|)
decl_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|cp
index|[
literal|1
index|]
argument_list|,
name|drrb
operator|->
name|drr_toname
argument_list|)
expr_stmt|;
name|chopprefix
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|chopprefix
operator|=
name|drrb
operator|->
name|drr_toname
operator|+
operator|(
name|chopprefix
operator|-
name|sendfs
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|->
name|isprefix
condition|)
block|{
comment|/* 		 * A filesystem was specified with -d. We want to tack on 		 * everything but the first element of the sent snapshot path 		 * (all but the pool name). 		 */
if|if
condition|(
name|strchr
argument_list|(
name|tosnap
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"argument - snapshot not allowed with -d"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|chopprefix
operator|=
name|strchr
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|chopprefix
operator|==
name|NULL
condition|)
name|chopprefix
operator|=
name|strchr
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|tosnap
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If a filesystem was specified without -d or -e, we want to 		 * tack on everything after the fs specified by 'zfs send'. 		 */
name|chopprefix
operator|=
name|drrb
operator|->
name|drr_toname
operator|+
name|strlen
argument_list|(
name|sendfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A snapshot was specified as an exact path (no -d or -e). */
if|if
condition|(
name|recursive
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot specify snapshot name for multi-snapshot "
literal|"stream"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|chopprefix
operator|=
name|drrb
operator|->
name|drr_toname
operator|+
name|strlen
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|strstr
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|,
name|sendfs
argument_list|)
operator|==
name|drrb
operator|->
name|drr_toname
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|chopprefix
operator|>
name|drrb
operator|->
name|drr_toname
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|chopprefix
operator|<=
name|drrb
operator|->
name|drr_toname
operator|+
name|strlen
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|chopprefix
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|chopprefix
index|[
literal|0
index|]
operator|==
literal|'@'
operator|||
name|chopprefix
index|[
literal|0
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* 	 * Determine name of destination snapshot, store in zc_value. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|chopprefix
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_name_valid
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_INVALIDNAME
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Determine the name of the origin snapshot, store in zc_string. 	 */
if|if
condition|(
name|originsnap
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|,
name|originsnap
argument_list|,
sizeof|sizeof
argument_list|(
name|zc
operator|.
name|zc_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"using provided clone origin %s\n"
argument_list|,
name|zc
operator|.
name|zc_string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drrb
operator|->
name|drr_flags
operator|&
name|DRR_FLAG_CLONE
condition|)
block|{
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|drrb
operator|->
name|drr_fromguid
argument_list|,
name|B_FALSE
argument_list|,
name|zc
operator|.
name|zc_string
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"local origin for clone %s does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"found clone origin %s\n"
argument_list|,
name|zc
operator|.
name|zc_string
argument_list|)
expr_stmt|;
block|}
name|boolean_t
name|resuming
init|=
name|DMU_GET_FEATUREFLAGS
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|)
operator|&
name|DMU_BACKUP_FEATURE_RESUMING
decl_stmt|;
name|stream_wantsnewfs
operator|=
operator|(
name|drrb
operator|->
name|drr_fromguid
operator|==
name|NULL
operator|||
operator|(
name|drrb
operator|->
name|drr_flags
operator|&
name|DRR_FLAG_CLONE
operator|)
operator|||
name|originsnap
operator|)
operator|&&
operator|!
name|resuming
expr_stmt|;
if|if
condition|(
name|stream_wantsnewfs
condition|)
block|{
comment|/* 		 * if the parent fs does not exist, look for it based on 		 * the parent snap GUID 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive new filesystem stream"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|!
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|char
name|suffix
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|suffix
argument_list|,
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|parent_snapguid
argument_list|,
name|B_FALSE
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * if the fs does not exist, look for it based on the 		 * fromsnap GUID 		 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive incremental stream"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * If the exact receive path was specified and this is the 		 * topmost path in the stream, then if the fs does not exist we 		 * should look no further. 		 */
if|if
condition|(
operator|(
name|flags
operator|->
name|isprefix
operator|||
operator|(
operator|*
operator|(
name|chopprefix
operator|=
name|drrb
operator|->
name|drr_toname
operator|+
name|strlen
argument_list|(
name|sendfs
argument_list|)
operator|)
operator|!=
literal|'\0'
operator|&&
operator|*
name|chopprefix
operator|!=
literal|'@'
operator|)
operator|)
operator|&&
operator|!
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|char
name|snap
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|snap
argument_list|,
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid_to_name
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|drrb
operator|->
name|drr_fromguid
argument_list|,
name|B_FALSE
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
name|snap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
comment|/* 		 * Destination fs exists.  It must be one of these cases: 		 *  - an incremental send stream 		 *  - the stream specifies a new fs (full stream or clone) 		 *    and they want us to blow away the existing fs (and 		 *    have therefore specified -F and removed any snapshots) 		 *  - we are resuming a failed receive. 		 */
if|if
condition|(
name|stream_wantsnewfs
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|->
name|force
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination '%s' exists\n"
literal|"must specify -F to overwrite it"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|hdl
operator|->
name|libzfs_fd
argument_list|,
name|ZFS_IOC_SNAPSHOT_LIST_NEXT
argument_list|,
operator|&
name|zc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination has snapshots (eg. %s)\n"
literal|"must destroy them to overwrite it"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stream_wantsnewfs
operator|&&
name|zhp
operator|->
name|zfs_dmustats
operator|.
name|dds_origin
index|[
literal|0
index|]
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination '%s' is a clone\n"
literal|"must destroy it to overwrite it"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|flags
operator|->
name|dryrun
operator|&&
name|zhp
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_FILESYSTEM
operator|&&
name|stream_wantsnewfs
condition|)
block|{
comment|/* We can't do online recv in this case */
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|changelist_prefix
argument_list|(
name|clp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 		 * If we are resuming a newfs, set newfs here so that we will 		 * mount it if the recv succeeds this time.  We can tell 		 * that it was a newfs on the first recv because the fs 		 * itself will be inconsistent (if the fs existed when we 		 * did the first recv, we would have received it into 		 * .../%recv). 		 */
if|if
condition|(
name|resuming
operator|&&
name|zfs_prop_get_int
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_INCONSISTENT
argument_list|)
condition|)
name|newfs
operator|=
name|B_TRUE
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Destination filesystem does not exist.  Therefore we better 		 * be creating a new filesystem (either from a full backup, or 		 * a clone).  It would therefore be invalid if the user 		 * specified only the pool name (i.e. if the destination name 		 * contained no slash character). 		 */
if|if
condition|(
operator|!
name|stream_wantsnewfs
operator|||
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|zc
operator|.
name|zc_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination '%s' does not exist"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Trim off the final dataset component so we perform the 		 * recvbackup ioctl to the filesystems's parent. 		 */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|isprefix
operator|&&
operator|!
name|flags
operator|->
name|istail
operator|&&
operator|!
name|flags
operator|->
name|dryrun
operator|&&
name|create_parents
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|strlen
argument_list|(
name|tosnap
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|newfs
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|zc
operator|.
name|zc_begin_record
operator|=
operator|*
name|drr_noswap
expr_stmt|;
name|zc
operator|.
name|zc_cookie
operator|=
name|infd
expr_stmt|;
name|zc
operator|.
name|zc_guid
operator|=
name|flags
operator|->
name|force
expr_stmt|;
name|zc
operator|.
name|zc_resumable
operator|=
name|flags
operator|->
name|resumable
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s stream of %s into %s\n"
argument_list|,
name|flags
operator|->
name|dryrun
condition|?
literal|"would receive"
else|:
literal|"receiving"
argument_list|,
name|drrb
operator|->
name|drr_fromguid
condition|?
literal|"incremental"
else|:
literal|"full"
argument_list|,
name|drrb
operator|->
name|drr_toname
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|->
name|dryrun
condition|)
block|{
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|recv_skip
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|flags
operator|->
name|byteswap
argument_list|)
operator|)
return|;
block|}
name|zc
operator|.
name|zc_nvlist_dst
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|prop_errbuf
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
sizeof|sizeof
argument_list|(
name|prop_errbuf
argument_list|)
expr_stmt|;
name|zc
operator|.
name|zc_cleanup_fd
operator|=
name|cleanup_fd
expr_stmt|;
name|zc
operator|.
name|zc_action_handle
operator|=
operator|*
name|action_handlep
expr_stmt|;
name|err
operator|=
name|ioctl_err
operator|=
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_RECV
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|ioctl_errno
operator|=
name|errno
expr_stmt|;
name|prop_errflags
operator|=
operator|(
name|zprop_errflags_t
operator|)
name|zc
operator|.
name|zc_obj
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|nvlist_t
modifier|*
name|prop_errors
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_unpack
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|.
name|zc_nvlist_dst
argument_list|,
name|zc
operator|.
name|zc_nvlist_dst_size
argument_list|,
operator|&
name|prop_errors
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|nvpair_t
modifier|*
name|prop_err
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|prop_err
operator|=
name|nvlist_next_nvpair
argument_list|(
name|prop_errors
argument_list|,
name|prop_err
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|tbuf
index|[
literal|1024
index|]
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|int
name|intval
decl_stmt|;
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|prop_err
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int32
argument_list|(
name|prop_err
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|prop_err
argument_list|)
argument_list|,
name|ZPROP_N_MORE_ERRORS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|trunc_prop_errs
argument_list|(
name|intval
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|snapname
operator|==
name|NULL
operator|||
name|finalsnap
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|finalsnap
argument_list|,
name|snapname
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|prop_err
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFQUOTA
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Skip the special case of, for example, 				 * "refquota", errors on intermediate 				 * snapshots leading up to a final one. 				 * That's why we have all of the checks above. 				 * 				 * See zfs_ioctl.c's extract_delay_props() for 				 * a list of props which can fail on 				 * intermediate snapshots, but shouldn't 				 * affect the overall receive. 				 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive %s property on %s"
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|prop_err
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
name|zfs_setprop_error
argument_list|(
name|hdl
argument_list|,
name|prop
argument_list|,
name|intval
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|nvlist_free
argument_list|(
name|prop_errors
argument_list|)
expr_stmt|;
block|}
name|zc
operator|.
name|zc_nvlist_dst
operator|=
literal|0
expr_stmt|;
name|zc
operator|.
name|zc_nvlist_dst_size
operator|=
literal|0
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|snapprops_nvlist
condition|)
block|{
name|zfs_cmd_t
name|zc2
init|=
block|{
literal|0
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zc2
operator|.
name|zc_name
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
name|zc2
operator|.
name|zc_cookie
operator|=
name|B_TRUE
expr_stmt|;
comment|/* received */
if|if
condition|(
name|zcmd_write_src_nvlist
argument_list|(
name|hdl
argument_list|,
operator|&
name|zc2
argument_list|,
name|snapprops_nvlist
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zfs_ioctl
argument_list|(
name|hdl
argument_list|,
name|ZFS_IOC_SET_PROP
argument_list|,
operator|&
name|zc2
argument_list|)
expr_stmt|;
name|zcmd_free_nvlists
argument_list|(
operator|&
name|zc2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|&&
operator|(
name|ioctl_errno
operator|==
name|ENOENT
operator|||
name|ioctl_errno
operator|==
name|EEXIST
operator|)
condition|)
block|{
comment|/* 		 * It may be that this snapshot already exists, 		 * in which case we want to consume& ignore it 		 * rather than failing. 		 */
name|avl_tree_t
modifier|*
name|local_avl
decl_stmt|;
name|nvlist_t
modifier|*
name|local_nv
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
comment|/* 		 * XXX Do this faster by just iterating over snaps in 		 * this fs.  Also if zc_value does not exist, we will 		 * get a strange "does not exist" error message. 		 */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|gather_nvlist
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|local_nv
argument_list|,
operator|&
name|local_avl
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
name|fs
operator|=
name|fsavl_find
argument_list|(
name|local_avl
argument_list|,
name|drrb
operator|->
name|drr_toguid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fsavl_destroy
argument_list|(
name|local_avl
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|local_nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"snap %s already exists; "
literal|"ignoring\n"
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|ioctl_err
operator|=
name|recv_skip
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|flags
operator|->
name|byteswap
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
if|if
condition|(
name|ioctl_err
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|ioctl_errno
condition|)
block|{
case|case
name|ENODEV
case|:
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"most recent snapshot of %s does not\n"
literal|"match incremental source"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
break|break;
case|case
name|ETXTBSY
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination %s has been modified\n"
literal|"since most recent snapshot"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADRESTORE
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EEXIST
case|:
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfs
condition|)
block|{
comment|/* it's the containing fs that exists */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination already exists"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error_fmt
argument_list|(
name|hdl
argument_list|,
name|EZFS_EXISTS
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot restore to %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
break|break;
case|case
name|EINVAL
case|:
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECKSUM
case|:
name|recv_ecksum_set_aux
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|flags
operator|->
name|resumable
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOTSUP
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"pool must be upgraded to receive this stream."
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADVERSION
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDQUOT
case|:
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"destination %s space quota exceeded"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOSPC
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|zfs_standard_error
argument_list|(
name|hdl
argument_list|,
name|ioctl_errno
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Mount the target filesystem (if created).  Also mount any 	 * children of the target filesystem if we did a replication 	 * receive (indicated by stream_avl being non-NULL). 	 */
name|cp
operator|=
name|strchr
argument_list|(
name|zc
operator|.
name|zc_value
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|(
name|ioctl_err
operator|==
literal|0
operator|||
operator|!
name|newfs
operator|)
condition|)
block|{
name|zfs_handle_t
modifier|*
name|h
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|h
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|,
name|ZFS_TYPE_FILESYSTEM
operator||
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|zfs_type
operator|==
name|ZFS_TYPE_VOLUME
condition|)
block|{
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newfs
operator|||
name|stream_avl
condition|)
block|{
comment|/* 				 * Track the first/top of hierarchy fs, 				 * for mounting and sharing later. 				 */
if|if
condition|(
name|top_zfs
operator|&&
operator|*
name|top_zfs
operator|==
name|NULL
condition|)
operator|*
name|top_zfs
operator|=
name|zfs_strdup
argument_list|(
name|hdl
argument_list|,
name|zc
operator|.
name|zc_value
argument_list|)
expr_stmt|;
block|}
name|zfs_close
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
if|if
condition|(
name|clp
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|->
name|nomount
condition|)
name|err
operator||=
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_errflags
operator|&
name|ZPROP_ERR_NOCLEAR
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Warning: "
literal|"failed to clear unreceived properties on %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_errflags
operator|&
name|ZPROP_ERR_NORESTORE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"Warning: "
literal|"failed to restore original properties on %s"
argument_list|)
argument_list|,
name|zc
operator|.
name|zc_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
name|ioctl_err
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|action_handlep
operator|=
name|zc
operator|.
name|zc_action_handle
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|verbose
condition|)
block|{
name|char
name|buf1
index|[
literal|64
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|64
index|]
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|zc
operator|.
name|zc_cookie
decl_stmt|;
name|time_t
name|delta
init|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|begin_time
decl_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|delta
operator|=
literal|1
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|bytes
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_nicenum
argument_list|(
name|bytes
operator|/
name|delta
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"received %sB stream in %lu seconds (%sB/sec)\n"
argument_list|,
name|buf1
argument_list|,
name|delta
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_receive_impl
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
specifier|const
name|char
modifier|*
name|originsnap
parameter_list|,
name|recvflags_t
modifier|*
name|flags
parameter_list|,
name|int
name|infd
parameter_list|,
specifier|const
name|char
modifier|*
name|sendfs
parameter_list|,
name|nvlist_t
modifier|*
name|stream_nv
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|,
name|char
modifier|*
modifier|*
name|top_zfs
parameter_list|,
name|int
name|cleanup_fd
parameter_list|,
name|uint64_t
modifier|*
name|action_handlep
parameter_list|,
specifier|const
name|char
modifier|*
name|finalsnap
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dmu_replay_record_t
name|drr
decl_stmt|,
name|drr_noswap
decl_stmt|;
name|struct
name|drr_begin
modifier|*
name|drrb
init|=
operator|&
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
decl_stmt|;
name|char
name|errbuf
index|[
literal|1024
index|]
decl_stmt|;
name|zio_cksum_t
name|zcksum
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|featureflags
decl_stmt|;
name|int
name|hdrtype
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"cannot receive"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|->
name|isprefix
operator|&&
operator|!
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|tosnap
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"specified fs "
literal|"(%s) does not exist"
argument_list|)
argument_list|,
name|tosnap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|originsnap
operator|&&
operator|!
name|zfs_dataset_exists
argument_list|(
name|hdl
argument_list|,
name|originsnap
argument_list|,
name|ZFS_TYPE_DATASET
argument_list|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"specified origin fs "
literal|"(%s) does not exist"
argument_list|)
argument_list|,
name|originsnap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_NOENT
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
comment|/* read in the BEGIN record */
if|if
condition|(
literal|0
operator|!=
operator|(
name|err
operator|=
name|recv_read
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
operator|&
name|zcksum
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|drr
operator|.
name|drr_type
operator|==
name|DRR_END
operator|||
name|drr
operator|.
name|drr_type
operator|==
name|BSWAP_32
argument_list|(
name|DRR_END
argument_list|)
condition|)
block|{
comment|/* It's the double end record at the end of a package */
return|return
operator|(
name|ENODATA
operator|)
return|;
block|}
comment|/* the kernel needs the non-byteswapped begin record */
name|drr_noswap
operator|=
name|drr
expr_stmt|;
name|flags
operator|->
name|byteswap
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|drrb
operator|->
name|drr_magic
operator|==
name|BSWAP_64
argument_list|(
name|DMU_BACKUP_MAGIC
argument_list|)
condition|)
block|{
comment|/* 		 * We computed the checksum in the wrong byteorder in 		 * recv_read() above; do it again correctly. 		 */
name|bzero
argument_list|(
operator|&
name|zcksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|fletcher_4_incremental_byteswap
argument_list|(
operator|&
name|drr
argument_list|,
sizeof|sizeof
argument_list|(
name|drr
argument_list|)
argument_list|,
operator|&
name|zcksum
argument_list|)
expr_stmt|;
name|flags
operator|->
name|byteswap
operator|=
name|B_TRUE
expr_stmt|;
name|drr
operator|.
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|.
name|drr_type
argument_list|)
expr_stmt|;
name|drr
operator|.
name|drr_payloadlen
operator|=
name|BSWAP_32
argument_list|(
name|drr
operator|.
name|drr_payloadlen
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_magic
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_magic
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_versioninfo
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_creation_time
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_creation_time
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_type
operator|=
name|BSWAP_32
argument_list|(
name|drrb
operator|->
name|drr_type
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_flags
operator|=
name|BSWAP_32
argument_list|(
name|drrb
operator|->
name|drr_flags
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_toguid
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_toguid
argument_list|)
expr_stmt|;
name|drrb
operator|->
name|drr_fromguid
operator|=
name|BSWAP_64
argument_list|(
name|drrb
operator|->
name|drr_fromguid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drrb
operator|->
name|drr_magic
operator|!=
name|DMU_BACKUP_MAGIC
operator|||
name|drr
operator|.
name|drr_type
operator|!=
name|DRR_BEGIN
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (bad magic number)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
name|featureflags
operator|=
name|DMU_GET_FEATUREFLAGS
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|)
expr_stmt|;
name|hdrtype
operator|=
name|DMU_GET_STREAM_HDRTYPE
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DMU_STREAM_SUPPORTED
argument_list|(
name|featureflags
argument_list|)
operator|||
operator|(
name|hdrtype
operator|!=
name|DMU_SUBSTREAM
operator|&&
name|hdrtype
operator|!=
name|DMU_COMPOUNDSTREAM
operator|)
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"stream has unsupported feature, feature flags = %lx"
argument_list|)
argument_list|,
name|featureflags
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|drrb
operator|->
name|drr_toname
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|zfs_error_aux
argument_list|(
name|hdl
argument_list|,
name|dgettext
argument_list|(
name|TEXT_DOMAIN
argument_list|,
literal|"invalid "
literal|"stream (bad snapshot name)"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_error
argument_list|(
name|hdl
argument_list|,
name|EZFS_BADSTREAM
argument_list|,
name|errbuf
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|DMU_GET_STREAM_HDRTYPE
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|)
operator|==
name|DMU_SUBSTREAM
condition|)
block|{
name|char
name|nonpackage_sendfs
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
if|if
condition|(
name|sendfs
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We were not called from zfs_receive_package(). Get 			 * the fs specified by 'zfs send'. 			 */
name|char
modifier|*
name|cp
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|nonpackage_sendfs
argument_list|,
name|drr
operator|.
name|drr_u
operator|.
name|drr_begin
operator|.
name|drr_toname
argument_list|,
sizeof|sizeof
argument_list|(
name|nonpackage_sendfs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|nonpackage_sendfs
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|sendfs
operator|=
name|nonpackage_sendfs
expr_stmt|;
name|VERIFY
argument_list|(
name|finalsnap
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_receive_one
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|tosnap
argument_list|,
name|originsnap
argument_list|,
name|flags
argument_list|,
operator|&
name|drr
argument_list|,
operator|&
name|drr_noswap
argument_list|,
name|sendfs
argument_list|,
name|stream_nv
argument_list|,
name|stream_avl
argument_list|,
name|top_zfs
argument_list|,
name|cleanup_fd
argument_list|,
name|action_handlep
argument_list|,
name|finalsnap
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|assert
argument_list|(
name|DMU_GET_STREAM_HDRTYPE
argument_list|(
name|drrb
operator|->
name|drr_versioninfo
argument_list|)
operator|==
name|DMU_COMPOUNDSTREAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_receive_package
argument_list|(
name|hdl
argument_list|,
name|infd
argument_list|,
name|tosnap
argument_list|,
name|flags
argument_list|,
operator|&
name|drr
argument_list|,
operator|&
name|zcksum
argument_list|,
name|top_zfs
argument_list|,
name|cleanup_fd
argument_list|,
name|action_handlep
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Restores a backup of tosnap from the file descriptor specified by infd.  * Return 0 on total success, -2 if some things couldn't be  * destroyed/renamed/promoted, -1 if some things couldn't be received.  * (-1 will override -2, if -1 and the resumable flag was specified the  * transfer can be resumed if the sending side supports it).  */
end_comment

begin_function
name|int
name|zfs_receive
parameter_list|(
name|libzfs_handle_t
modifier|*
name|hdl
parameter_list|,
specifier|const
name|char
modifier|*
name|tosnap
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|recvflags_t
modifier|*
name|flags
parameter_list|,
name|int
name|infd
parameter_list|,
name|avl_tree_t
modifier|*
name|stream_avl
parameter_list|)
block|{
name|char
modifier|*
name|top_zfs
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|cleanup_fd
decl_stmt|;
name|uint64_t
name|action_handle
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|originsnap
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|props
condition|)
block|{
name|err
operator|=
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
literal|"origin"
argument_list|,
operator|&
name|originsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|cleanup_fd
operator|=
name|open
argument_list|(
name|ZFS_DEV
argument_list|,
name|O_RDWR
operator||
name|O_EXCL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|cleanup_fd
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_receive_impl
argument_list|(
name|hdl
argument_list|,
name|tosnap
argument_list|,
name|originsnap
argument_list|,
name|flags
argument_list|,
name|infd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|stream_avl
argument_list|,
operator|&
name|top_zfs
argument_list|,
name|cleanup_fd
argument_list|,
operator|&
name|action_handle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|close
argument_list|(
name|cleanup_fd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|flags
operator|->
name|nomount
operator|&&
name|top_zfs
condition|)
block|{
name|zfs_handle_t
modifier|*
name|zhp
decl_stmt|;
name|prop_changelist_t
modifier|*
name|clp
decl_stmt|;
name|zhp
operator|=
name|zfs_open
argument_list|(
name|hdl
argument_list|,
name|top_zfs
argument_list|,
name|ZFS_TYPE_FILESYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|zhp
operator|!=
name|NULL
condition|)
block|{
name|clp
operator|=
name|changelist_gather
argument_list|(
name|zhp
argument_list|,
name|ZFS_PROP_MOUNTPOINT
argument_list|,
name|CL_GATHER_MOUNT_ALWAYS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_close
argument_list|(
name|zhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|!=
name|NULL
condition|)
block|{
comment|/* mount and share received datasets */
name|err
operator|=
name|changelist_postfix
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|changelist_free
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zhp
operator|==
name|NULL
operator|||
name|clp
operator|==
name|NULL
operator|||
name|err
condition|)
name|err
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|top_zfs
condition|)
name|free
argument_list|(
name|top_zfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

