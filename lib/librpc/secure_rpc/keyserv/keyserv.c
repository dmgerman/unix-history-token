begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)keyserv.c	2.4 88/08/15 4.0 RPCSRC Copyr 1988 Sun Micro"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *   * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *   * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *   * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *   * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *   * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1986, Sun Microsystems, Inc.  */
end_comment

begin_comment
comment|/*  * Keyserver   * Store secret keys per uid. Do public key encryption and decryption  * operations. Generate "random" keys. Do not talk to anything but a local root  * process (by checking that the source port< IPPORT_RESERVED and by binding  * to the loopback address).   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<des_crypt.h>
end_include

begin_include
include|#
directive|include
file|<rpc/key_prot.h>
end_include

begin_decl_stmt
name|char
name|ROOTKEY
index|[]
init|=
literal|"/etc/.rootkey"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|long
name|random
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|keystatus
name|pk_setkey
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|keystatus
name|pk_encrypt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|keystatus
name|pk_decrypt
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debugging
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|debugging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|keyprogram
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|des_block
name|masterkey
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|SVCXPRT
modifier|*
name|transp
decl_stmt|;
name|int
name|nflag
decl_stmt|;
name|nflag
operator|=
operator|(
name|argc
operator|==
literal|2
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-n"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|argc
operator|==
literal|1
operator|||
name|nflag
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-n]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize  	 */
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|066
argument_list|)
expr_stmt|;
comment|/* paranoia */
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s must be run as root\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setmodulus
argument_list|(
name|HEXMODULUS
argument_list|)
expr_stmt|;
name|openstore
argument_list|()
expr_stmt|;
name|getrootkey
argument_list|(
operator|&
name|masterkey
argument_list|,
name|nflag
argument_list|)
expr_stmt|;
name|readkeys
argument_list|()
expr_stmt|;
comment|/* 	 * create the service, register it, and run  	 */
name|transp
operator|=
name|svcudp_create
argument_list|(
name|RPC_ANYSOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|transp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unable to create udp service\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pmap_unset
argument_list|(
name|KEY_PROG
argument_list|,
name|KEY_VERS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_register
argument_list|(
name|transp
argument_list|,
name|KEY_PROG
argument_list|,
name|KEY_VERS
argument_list|,
name|keyprogram
argument_list|,
name|IPPROTO_UDP
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unable to register service\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * run  	 */
if|if
condition|(
operator|!
name|debugging
condition|)
block|{
name|detachfromtty
argument_list|()
expr_stmt|;
block|}
name|svc_run
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * In the event that we don't get a root password, we try to randomize the  * master key the best we can   */
end_comment

begin_macro
name|randomize
argument_list|(
argument|master
argument_list|)
end_macro

begin_decl_stmt
name|des_block
modifier|*
name|master
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|seed
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|seed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|shift
operator|=
name|i
operator|%
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|seed
operator|^=
operator|(
name|tv
operator|.
name|tv_usec
operator|<<
name|shift
operator|)
operator||
operator|(
name|tv
operator|.
name|tv_usec
operator|>>
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
block|}
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|master
operator|->
name|key
operator|.
name|low
operator|=
name|random
argument_list|()
expr_stmt|;
name|master
operator|->
name|key
operator|.
name|high
operator|=
name|random
argument_list|()
expr_stmt|;
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Try to get root's secret key, by prompting if terminal is a tty, else trying  * from standard input.   */
end_comment

begin_macro
name|getrootkey
argument_list|(
argument|master
argument_list|,
argument|prompt
argument_list|)
end_macro

begin_decl_stmt
name|des_block
modifier|*
name|master
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prompt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|getpass
parameter_list|()
function_decl|;
name|char
modifier|*
name|passwd
decl_stmt|;
name|char
name|name
index|[
name|MAXNETNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|secret
index|[
name|HEXKEYBYTES
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|prompt
condition|)
block|{
comment|/* 		 * Read secret key out of $ROOTKEY  		 */
name|fd
operator|=
name|open
argument_list|(
name|ROOTKEY
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|randomize
argument_list|(
name|master
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|secret
argument_list|,
name|HEXKEYBYTES
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid %s\n"
argument_list|,
name|ROOTKEY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|secret
index|[
name|HEXKEYBYTES
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Decrypt yellow pages entry to get secret key  		 */
name|passwd
operator|=
name|getpass
argument_list|(
literal|"root password:"
argument_list|)
expr_stmt|;
name|passwd2des
argument_list|(
name|passwd
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|getnetname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getsecretkey
argument_list|(
name|name
argument_list|,
name|secret
argument_list|,
name|passwd
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find %s's secret key\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|secret
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid password for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|pk_setkey
argument_list|(
literal|0
argument_list|,
name|secret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Procedures to implement RPC service  */
end_comment

begin_function
name|char
modifier|*
name|strstatus
parameter_list|(
name|status
parameter_list|)
name|keystatus
name|status
decl_stmt|;
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|KEY_SUCCESS
case|:
return|return
operator|(
literal|"KEY_SUCCESS"
operator|)
return|;
case|case
name|KEY_NOSECRET
case|:
return|return
operator|(
literal|"KEY_NOSECRET"
operator|)
return|;
case|case
name|KEY_UNKNOWN
case|:
return|return
operator|(
literal|"KEY_UNKNOWN"
operator|)
return|;
case|case
name|KEY_SYSTEMERR
case|:
return|return
operator|(
literal|"KEY_SYSTEMERR"
operator|)
return|;
default|default:
return|return
operator|(
literal|"(bad result code)"
operator|)
return|;
block|}
block|}
end_function

begin_function
name|keystatus
modifier|*
name|key_set_1
parameter_list|(
name|uid
parameter_list|,
name|key
parameter_list|)
name|short
name|uid
decl_stmt|;
name|keybuf
name|key
decl_stmt|;
block|{
specifier|static
name|keystatus
name|status
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"set(%d, %.*s) = "
argument_list|,
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|keybuf
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|pk_setkey
argument_list|(
name|uid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|status
operator|)
return|;
block|}
end_function

begin_function
name|cryptkeyres
modifier|*
name|key_encrypt_1
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|short
name|uid
decl_stmt|;
name|cryptkeyarg
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|cryptkeyres
name|res
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"encrypt(%d, %s, %08x%08x) = "
argument_list|,
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|=
name|arg
operator|->
name|deskey
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|pk_encrypt
argument_list|(
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
operator|&
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%08x%08x\n"
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|cryptkeyres
modifier|*
name|key_decrypt_1
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|short
name|uid
decl_stmt|;
name|cryptkeyarg
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|cryptkeyres
name|res
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"decrypt(%d, %s, %08x%08x) = "
argument_list|,
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|=
name|arg
operator|->
name|deskey
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|pk_decrypt
argument_list|(
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
operator|&
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%08x%08x\n"
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|des_block
modifier|*
name|key_gen_1
parameter_list|()
block|{
name|struct
name|timeval
name|time
decl_stmt|;
specifier|static
name|des_block
name|keygen
decl_stmt|;
specifier|static
name|des_block
name|key
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|keygen
operator|.
name|key
operator|.
name|high
operator|+=
operator|(
name|time
operator|.
name|tv_sec
operator|^
name|time
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|keygen
operator|.
name|key
operator|.
name|low
operator|+=
operator|(
name|time
operator|.
name|tv_sec
operator|^
name|time
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|ecb_crypt
argument_list|(
operator|&
name|masterkey
argument_list|,
operator|&
name|keygen
argument_list|,
sizeof|sizeof
argument_list|(
name|keygen
argument_list|)
argument_list|,
name|DES_ENCRYPT
operator||
name|DES_HW
argument_list|)
expr_stmt|;
name|key
operator|=
name|keygen
expr_stmt|;
name|des_setparity
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gen() = %08x%08x\n"
argument_list|,
name|key
operator|.
name|key
operator|.
name|high
argument_list|,
name|key
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|key
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|getcredres
modifier|*
name|key_getcred_1
parameter_list|(
name|uid
parameter_list|,
name|name
parameter_list|)
name|short
name|uid
decl_stmt|;
name|netnamestr
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|getcredres
name|res
decl_stmt|;
specifier|static
name|int
name|gids
index|[
name|NGROUPS
index|]
decl_stmt|;
name|struct
name|unixcred
modifier|*
name|cred
decl_stmt|;
name|cred
operator|=
operator|&
name|res
operator|.
name|getcredres_u
operator|.
name|cred
expr_stmt|;
name|cred
operator|->
name|gids
operator|.
name|gids_val
operator|=
name|gids
expr_stmt|;
if|if
condition|(
operator|!
name|netname2user
argument_list|(
operator|*
name|name
argument_list|,
operator|&
name|cred
operator|->
name|uid
argument_list|,
operator|&
name|cred
operator|->
name|gid
argument_list|,
operator|&
name|cred
operator|->
name|gids
operator|.
name|gids_len
argument_list|,
name|gids
argument_list|)
condition|)
block|{
name|res
operator|.
name|status
operator|=
name|KEY_UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|status
operator|=
name|KEY_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getcred(%s) = "
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uid=%d,gid=%d,grouplen=%d\n"
argument_list|,
name|cred
operator|->
name|uid
argument_list|,
name|cred
operator|->
name|gid
argument_list|,
name|cred
operator|->
name|gids
operator|.
name|gids_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * RPC boilerplate   */
end_comment

begin_function
specifier|static
name|void
name|keyprogram
parameter_list|(
name|rqstp
parameter_list|,
name|transp
parameter_list|)
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
name|SVCXPRT
modifier|*
name|transp
decl_stmt|;
block|{
union|union
block|{
name|keybuf
name|key_set_1_arg
decl_stmt|;
name|cryptkeyarg
name|key_encrypt_1_arg
decl_stmt|;
name|cryptkeyarg
name|key_decrypt_1_arg
decl_stmt|;
name|des_block
name|key_gen_1_arg
decl_stmt|;
block|}
name|argument
union|;
name|char
modifier|*
name|result
decl_stmt|;
name|bool_t
argument_list|(
operator|*
name|xdr_argument
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|xdr_result
argument_list|)
argument_list|()
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|local
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|sockaddr_in
name|remote
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|int
name|check_auth
decl_stmt|;
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|NULLPROC
case|:
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
name|xdr_void
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|KEY_SET
case|:
name|xdr_argument
operator|=
name|xdr_keybuf
expr_stmt|;
name|xdr_result
operator|=
name|xdr_int
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_set_1
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_ENCRYPT
case|:
name|xdr_argument
operator|=
name|xdr_cryptkeyarg
expr_stmt|;
name|xdr_result
operator|=
name|xdr_cryptkeyres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_encrypt_1
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DECRYPT
case|:
name|xdr_argument
operator|=
name|xdr_cryptkeyarg
expr_stmt|;
name|xdr_result
operator|=
name|xdr_cryptkeyres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_decrypt_1
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_GEN
case|:
name|xdr_argument
operator|=
name|xdr_void
expr_stmt|;
name|xdr_result
operator|=
name|xdr_des_block
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_gen_1
expr_stmt|;
name|check_auth
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_GETCRED
case|:
name|xdr_argument
operator|=
name|xdr_netnamestr
expr_stmt|;
name|xdr_result
operator|=
name|xdr_getcredres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_getcred_1
expr_stmt|;
name|check_auth
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|check_auth
condition|)
block|{
name|remote
operator|=
operator|*
name|svc_getcaller
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|remote
operator|.
name|sin_port
argument_list|)
operator|>=
name|IPPORT_RESERVED
operator|||
name|ntohl
argument_list|(
name|remote
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|!=
name|INADDR_LOOPBACK
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not local privileged process\n"
argument_list|)
expr_stmt|;
block|}
name|svcerr_weakauth
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rqstp
operator|->
name|rq_cred
operator|.
name|oa_flavor
operator|!=
name|AUTH_UNIX
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not unix authentication\n"
argument_list|)
expr_stmt|;
block|}
name|svcerr_weakauth
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|uid
operator|=
operator|(
operator|(
expr|struct
name|authunix_parms
operator|*
operator|)
name|rqstp
operator|->
name|rq_clntcred
operator|)
operator|->
name|aup_uid
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|argument
argument_list|,
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|result
operator|=
call|(
modifier|*
name|local
call|)
argument_list|(
name|uid
argument_list|,
operator|&
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
name|xdr_result
argument_list|,
operator|(
name|char
operator|*
operator|)
name|result
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to reply\n"
argument_list|)
expr_stmt|;
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_freeargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to free arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

