begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013, 2014, 2015 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * Authors: Ken Merry           (Spectra Logic Corporation)  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<bsdxml.h>
end_include

begin_include
include|#
directive|include
file|<mtlib.h>
end_include

begin_comment
comment|/*  * Called at the start of each XML element, and includes the list of  * attributes for the element.  */
end_comment

begin_function
name|void
name|mt_start_element
parameter_list|(
name|void
modifier|*
name|user_data
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|attr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mt_status_data
modifier|*
name|mtinfo
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|mtinfo
operator|=
operator|(
expr|struct
name|mt_status_data
operator|*
operator|)
name|user_data
expr_stmt|;
if|if
condition|(
name|mtinfo
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|mtinfo
operator|->
name|level
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|mtinfo
operator|->
name|level
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|cur_sb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|cur_sb
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|mtinfo
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: too many nesting levels, %zd max"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|cur_sb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|cur_sb
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
operator|==
name|NULL
condition|)
block|{
name|mtinfo
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: Unable to allocate sbuf"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|mtinfo
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: unable to allocate %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|entry
operator|->
name|nv_list
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|entry
operator|->
name|child_entries
argument_list|)
expr_stmt|;
name|entry
operator|->
name|entry_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|mtinfo
operator|->
name|cur_entry
index|[
name|mtinfo
operator|->
name|level
index|]
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|mtinfo
operator|->
name|cur_entry
index|[
name|mtinfo
operator|->
name|level
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mtinfo
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mtinfo
operator|->
name|cur_entry
index|[
name|mtinfo
operator|->
name|level
operator|-
literal|1
index|]
operator|->
name|child_entries
argument_list|,
name|entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|entry
operator|->
name|parent
operator|=
name|mtinfo
operator|->
name|cur_entry
index|[
name|mtinfo
operator|->
name|level
operator|-
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|attr
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|struct
name|mt_status_nv
modifier|*
name|nv
decl_stmt|;
name|int
name|need_nv
decl_stmt|;
name|need_nv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|size
operator|=
name|strtoull
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"int"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|var_type
operator|=
name|MT_TYPE_INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"uint"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|var_type
operator|=
name|MT_TYPE_UINT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|var_type
operator|=
name|MT_TYPE_STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"node"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|var_type
operator|=
name|MT_TYPE_NODE
expr_stmt|;
block|}
else|else
block|{
name|need_nv
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"fmt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|fmt
operator|=
name|strdup
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|,
literal|"desc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|->
name|desc
operator|=
name|strdup
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|need_nv
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_nv
operator|!=
literal|0
condition|)
block|{
name|nv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv
operator|==
name|NULL
condition|)
block|{
name|mtinfo
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: error allocating %zd bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|nv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nv
argument_list|)
argument_list|)
expr_stmt|;
name|nv
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|attr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nv
operator|->
name|value
operator|=
name|strdup
argument_list|(
name|attr
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|entry
operator|->
name|nv_list
argument_list|,
name|nv
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Called on XML element close.  */
end_comment

begin_function
name|void
name|mt_end_element
parameter_list|(
name|void
modifier|*
name|user_data
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|mt_status_data
modifier|*
name|mtinfo
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|mtinfo
operator|=
operator|(
expr|struct
name|mt_status_data
operator|*
operator|)
name|user_data
expr_stmt|;
if|if
condition|(
name|mtinfo
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
operator|==
name|NULL
condition|)
block|{
name|mtinfo
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s: no valid sbuf at level %d (name %s)"
argument_list|,
name|__func__
argument_list|,
name|mtinfo
operator|->
name|level
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|sbuf_finish
argument_list|(
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
argument_list|)
expr_stmt|;
name|str
operator|=
name|strdup
argument_list|(
name|sbuf_data
argument_list|(
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
block|{
name|mtinfo
operator|->
name|error
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|,
sizeof|sizeof
argument_list|(
name|mtinfo
operator|->
name|error_str
argument_list|)
argument_list|,
literal|"%s can't allocate %zd bytes for string"
argument_list|,
name|__func__
argument_list|,
name|sbuf_len
argument_list|(
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|mtinfo
operator|->
name|cur_entry
index|[
name|mtinfo
operator|->
name|level
index|]
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|var_type
condition|)
block|{
case|case
name|MT_TYPE_INT
case|:
name|entry
operator|->
name|value_signed
operator|=
name|strtoll
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MT_TYPE_UINT
case|:
name|entry
operator|->
name|value_unsigned
operator|=
name|strtoull
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|mtinfo
operator|->
name|cur_entry
index|[
name|mtinfo
operator|->
name|level
index|]
operator|->
name|value
operator|=
name|str
expr_stmt|;
name|sbuf_delete
argument_list|(
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
argument_list|)
expr_stmt|;
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|mtinfo
operator|->
name|cur_entry
index|[
name|mtinfo
operator|->
name|level
index|]
operator|=
name|NULL
expr_stmt|;
name|mtinfo
operator|->
name|level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to handle character strings in the current element.  */
end_comment

begin_function
name|void
name|mt_char_handler
parameter_list|(
name|void
modifier|*
name|user_data
parameter_list|,
specifier|const
name|XML_Char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mt_status_data
modifier|*
name|mtinfo
decl_stmt|;
name|mtinfo
operator|=
operator|(
expr|struct
name|mt_status_data
operator|*
operator|)
name|user_data
expr_stmt|;
if|if
condition|(
name|mtinfo
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|sbuf_bcat
argument_list|(
name|mtinfo
operator|->
name|cur_sb
index|[
name|mtinfo
operator|->
name|level
index|]
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mt_status_tree_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|int
name|indent
parameter_list|,
name|void
function_decl|(
modifier|*
name|sbuf_func
function_decl|)
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mt_status_nv
modifier|*
name|nv
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|entry2
decl_stmt|;
if|if
condition|(
name|sbuf_func
operator|!=
name|NULL
condition|)
block|{
name|sbuf_func
argument_list|(
name|sb
argument_list|,
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%*sname: %s, value: %s, fmt: %s, size: %zd, "
literal|"type: %d, desc: %s\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
name|entry
operator|->
name|value
argument_list|,
name|entry
operator|->
name|fmt
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|entry
operator|->
name|var_type
argument_list|,
name|entry
operator|->
name|desc
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|nv
argument_list|,
argument|&entry->nv_list
argument_list|,
argument|links
argument_list|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%*snv: name: %s, value: %s\n"
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
literal|""
argument_list|,
name|nv
operator|->
name|name
argument_list|,
name|nv
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|STAILQ_FOREACH
argument_list|(
argument|entry2
argument_list|,
argument|&entry->child_entries
argument_list|,
argument|links
argument_list|)
name|mt_status_tree_sbuf
argument_list|(
name|sb
argument_list|,
name|entry2
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|sbuf_func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mt_status_tree_print
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|int
name|indent
parameter_list|,
name|void
function_decl|(
modifier|*
name|print_func
function_decl|)
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|print_func
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry2
decl_stmt|;
name|print_func
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|entry2
argument_list|,
argument|&entry->child_entries
argument_list|,
argument|links
argument_list|)
name|mt_status_tree_print
argument_list|(
name|entry2
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|print_func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return;
name|mt_status_tree_sbuf
argument_list|(
name|sb
argument_list|,
name|entry
argument_list|,
name|indent
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given a parameter name in the form "foo" or "foo.bar.baz", traverse the  * tree looking for the parameter (the first case) or series of parameters  * (second case).  */
end_comment

begin_function
name|struct
name|mt_status_entry
modifier|*
name|mt_entry_find
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry2
decl_stmt|;
name|char
modifier|*
name|tmpname
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmpname2
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmpstr
init|=
name|NULL
decl_stmt|;
name|tmpname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpname
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
comment|/* Save a pointer so we can free this later */
name|tmpname2
operator|=
name|tmpname
expr_stmt|;
name|tmpstr
operator|=
name|strsep
argument_list|(
operator|&
name|tmpname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* 	 * Is this the entry we're looking for?  Or do we have further 	 * child entries that we need to grab? 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
name|tmpstr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmpname
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There are no further child entries to find.  We 			 * have a complete match. 			 */
name|free
argument_list|(
name|tmpname2
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * There are more child entries that we need to find. 			 * Fall through to the recursive search off of this 			 * entry, below.  Use tmpname, which will contain 			 * everything after the first period. 			 */
name|name
operator|=
name|tmpname
expr_stmt|;
block|}
block|}
comment|/* 	 * Recursively look for further entries. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|entry2
argument_list|,
argument|&entry->child_entries
argument_list|,
argument|links
argument_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry3
decl_stmt|;
name|entry3
operator|=
name|mt_entry_find
argument_list|(
name|entry2
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry3
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tmpname2
argument_list|)
expr_stmt|;
return|return
operator|(
name|entry3
operator|)
return|;
block|}
block|}
name|bailout
label|:
name|free
argument_list|(
name|tmpname2
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mt_status_entry
modifier|*
name|mt_status_entry_find
parameter_list|(
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry2
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&status_data->entries
argument_list|,
argument|links
argument_list|)
block|{
name|entry2
operator|=
name|mt_entry_find
argument_list|(
name|entry
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry2
operator|!=
name|NULL
condition|)
return|return
operator|(
name|entry2
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mt_status_entry_free
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry2
decl_stmt|,
modifier|*
name|entry3
decl_stmt|;
name|struct
name|mt_status_nv
modifier|*
name|nv
decl_stmt|,
modifier|*
name|nv2
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|entry2
argument_list|,
argument|&entry->child_entries
argument_list|,
argument|links
argument_list|,
argument|entry3
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|entry
operator|->
name|child_entries
argument_list|,
name|entry2
argument_list|,
name|mt_status_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mt_status_entry_free
argument_list|(
name|entry2
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|fmt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
operator|->
name|desc
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|nv
argument_list|,
argument|&entry->nv_list
argument_list|,
argument|links
argument_list|,
argument|nv2
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|entry
operator|->
name|nv_list
argument_list|,
name|nv
argument_list|,
name|mt_status_nv
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nv
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nv
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mt_status_free
parameter_list|(
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry2
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|&status_data->entries
argument_list|,
argument|links
argument_list|,
argument|entry2
argument_list|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|status_data
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|mt_status_entry
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|mt_status_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mt_entry_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|var_type
condition|)
block|{
case|case
name|MT_TYPE_INT
case|:
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
name|fmt
argument_list|,
operator|(
name|intmax_t
operator|)
name|entry
operator|->
name|value_signed
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|entry
operator|->
name|value_signed
argument_list|)
expr_stmt|;
break|break;
case|case
name|MT_TYPE_UINT
case|:
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
name|fmt
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|value_unsigned
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|value_unsigned
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
name|fmt
argument_list|,
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|mt_param_parent_print
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|mt_print_params
modifier|*
name|print_params
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|mt_param_parent_print
argument_list|(
name|entry
operator|->
name|parent
argument_list|,
name|print_params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|print_params
operator|->
name|flags
operator|&
name|MT_PF_INCLUDE_ROOT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
name|print_params
operator|->
name|root_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|printf
argument_list|(
literal|"%s."
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mt_param_parent_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|mt_print_params
modifier|*
name|print_params
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|mt_param_parent_sbuf
argument_list|(
name|sb
argument_list|,
name|entry
operator|->
name|parent
argument_list|,
name|print_params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|print_params
operator|->
name|flags
operator|&
name|MT_PF_INCLUDE_ROOT
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|entry_name
argument_list|,
name|print_params
operator|->
name|root_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s."
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mt_param_entry_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mt_print_params
modifier|*
name|print_params
decl_stmt|;
name|print_params
operator|=
operator|(
expr|struct
name|mt_print_params
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * We don't want to print nodes. 	 */
if|if
condition|(
name|entry
operator|->
name|var_type
operator|==
name|MT_TYPE_NODE
condition|)
return|return;
if|if
condition|(
operator|(
name|print_params
operator|->
name|flags
operator|&
name|MT_PF_FULL_PATH
operator|)
operator|&&
operator|(
name|entry
operator|->
name|parent
operator|!=
name|NULL
operator|)
condition|)
name|mt_param_parent_sbuf
argument_list|(
name|sb
argument_list|,
name|entry
operator|->
name|parent
argument_list|,
name|print_params
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s: %s"
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|print_params
operator|->
name|flags
operator|&
name|MT_PF_VERBOSE
operator|)
operator|&&
operator|(
name|entry
operator|->
name|desc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|entry
operator|->
name|desc
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" (%s)"
argument_list|,
name|entry
operator|->
name|desc
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mt_param_entry_print
parameter_list|(
name|struct
name|mt_status_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mt_print_params
modifier|*
name|print_params
decl_stmt|;
name|print_params
operator|=
operator|(
expr|struct
name|mt_print_params
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * We don't want to print nodes. 	 */
if|if
condition|(
name|entry
operator|->
name|var_type
operator|==
name|MT_TYPE_NODE
condition|)
return|return;
if|if
condition|(
operator|(
name|print_params
operator|->
name|flags
operator|&
name|MT_PF_FULL_PATH
operator|)
operator|&&
operator|(
name|entry
operator|->
name|parent
operator|!=
name|NULL
operator|)
condition|)
name|mt_param_parent_print
argument_list|(
name|entry
operator|->
name|parent
argument_list|,
name|print_params
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|entry
operator|->
name|entry_name
argument_list|,
name|entry
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|print_params
operator|->
name|flags
operator|&
name|MT_PF_VERBOSE
operator|)
operator|&&
operator|(
name|entry
operator|->
name|desc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|entry
operator|->
name|desc
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|entry
operator|->
name|desc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mt_protect_print
parameter_list|(
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|prot_name
init|=
name|MT_PROTECTION_NAME
decl_stmt|;
name|struct
name|mt_print_params
name|print_params
decl_stmt|;
name|snprintf
argument_list|(
name|print_params
operator|.
name|root_name
argument_list|,
sizeof|sizeof
argument_list|(
name|print_params
operator|.
name|root_name
argument_list|)
argument_list|,
name|MT_PARAM_ROOT_NAME
argument_list|)
expr_stmt|;
name|print_params
operator|.
name|flags
operator|=
name|MT_PF_FULL_PATH
expr_stmt|;
if|if
condition|(
name|verbose
operator|!=
literal|0
condition|)
name|print_params
operator|.
name|flags
operator||=
name|MT_PF_VERBOSE
expr_stmt|;
name|entry
operator|=
name|mt_status_entry_find
argument_list|(
name|status_data
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|prot_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mt_status_tree_print
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
name|mt_param_entry_print
argument_list|,
operator|&
name|print_params
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mt_param_list
parameter_list|(
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|,
name|char
modifier|*
name|param_name
parameter_list|,
name|int
name|quiet
parameter_list|)
block|{
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|mt_print_params
name|print_params
decl_stmt|;
name|char
name|root_name
index|[
literal|20
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|root_name
argument_list|,
sizeof|sizeof
argument_list|(
name|root_name
argument_list|)
argument_list|,
literal|"mtparamget"
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|print_params
operator|.
name|root_name
argument_list|,
name|root_name
argument_list|,
sizeof|sizeof
argument_list|(
name|print_params
operator|.
name|root_name
argument_list|)
argument_list|)
expr_stmt|;
name|print_params
operator|.
name|flags
operator|=
name|MT_PF_FULL_PATH
expr_stmt|;
if|if
condition|(
name|quiet
operator|==
literal|0
condition|)
name|print_params
operator|.
name|flags
operator||=
name|MT_PF_VERBOSE
expr_stmt|;
if|if
condition|(
name|param_name
operator|!=
name|NULL
condition|)
block|{
name|entry
operator|=
name|mt_status_entry_find
argument_list|(
name|status_data
argument_list|,
name|param_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mt_param_entry_print
argument_list|(
name|entry
argument_list|,
operator|&
name|print_params
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|entry
operator|=
name|mt_status_entry_find
argument_list|(
name|status_data
argument_list|,
name|root_name
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&status_data->entries
argument_list|,
argument|links
argument_list|)
name|mt_status_tree_print
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|,
name|mt_param_entry_print
argument_list|,
operator|&
name|print_params
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|densities
block|{
name|int
name|dens
decl_stmt|;
name|int
name|bpmm
decl_stmt|;
name|int
name|bpi
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|dens
index|[]
init|=
block|{
comment|/* 	 * Taken from T10 Project 997D  	 * SCSI-3 Stream Device Commands (SSC) 	 * Revision 11, 4-Nov-97 	 * 	 * LTO 1-6 definitions obtained from the eighth edition of the 	 * IBM TotalStorage LTO Ultrium Tape Drive SCSI Reference 	 * (July 2007) and the second edition of the IBM System Storage LTO 	 * Tape Drive SCSI Reference (February 13, 2013). 	 * 	 * IBM 3592 definitions obtained from second edition of the IBM 	 * System Storage Tape Drive 3592 SCSI Reference (May 25, 2012). 	 * 	 * DAT-72 and DAT-160 bpi values taken from "HP StorageWorks DAT160 	 * tape drive white paper", dated June 2007. 	 * 	 * DAT-160 / SDLT220 density code (0x48) conflict information 	 * found here: 	 * 	 * http://h20564.www2.hp.com/hpsc/doc/public/display?docId=emr_na-c01065117&sp4ts.oid=429311  	 * (Document ID c01065117) 	 */
comment|/*Num.  bpmm    bpi     Reference     */
block|{
literal|0x1
block|,
literal|32
block|,
literal|800
block|,
literal|"X3.22-1983"
block|}
block|,
block|{
literal|0x2
block|,
literal|63
block|,
literal|1600
block|,
literal|"X3.39-1986"
block|}
block|,
block|{
literal|0x3
block|,
literal|246
block|,
literal|6250
block|,
literal|"X3.54-1986"
block|}
block|,
block|{
literal|0x5
block|,
literal|315
block|,
literal|8000
block|,
literal|"X3.136-1986"
block|}
block|,
block|{
literal|0x6
block|,
literal|126
block|,
literal|3200
block|,
literal|"X3.157-1987"
block|}
block|,
block|{
literal|0x7
block|,
literal|252
block|,
literal|6400
block|,
literal|"X3.116-1986"
block|}
block|,
block|{
literal|0x8
block|,
literal|315
block|,
literal|8000
block|,
literal|"X3.158-1987"
block|}
block|,
block|{
literal|0x9
block|,
literal|491
block|,
literal|37871
block|,
literal|"X3.180"
block|}
block|,
block|{
literal|0xA
block|,
literal|262
block|,
literal|6667
block|,
literal|"X3B5/86-199"
block|}
block|,
block|{
literal|0xB
block|,
literal|63
block|,
literal|1600
block|,
literal|"X3.56-1986"
block|}
block|,
block|{
literal|0xC
block|,
literal|500
block|,
literal|12690
block|,
literal|"HI-TC1"
block|}
block|,
block|{
literal|0xD
block|,
literal|999
block|,
literal|25380
block|,
literal|"HI-TC2"
block|}
block|,
block|{
literal|0xF
block|,
literal|394
block|,
literal|10000
block|,
literal|"QIC-120"
block|}
block|,
block|{
literal|0x10
block|,
literal|394
block|,
literal|10000
block|,
literal|"QIC-150"
block|}
block|,
block|{
literal|0x11
block|,
literal|630
block|,
literal|16000
block|,
literal|"QIC-320"
block|}
block|,
block|{
literal|0x12
block|,
literal|2034
block|,
literal|51667
block|,
literal|"QIC-1350"
block|}
block|,
block|{
literal|0x13
block|,
literal|2400
block|,
literal|61000
block|,
literal|"X3B5/88-185A"
block|}
block|,
block|{
literal|0x14
block|,
literal|1703
block|,
literal|43245
block|,
literal|"X3.202-1991"
block|}
block|,
block|{
literal|0x15
block|,
literal|1789
block|,
literal|45434
block|,
literal|"ECMA TC17"
block|}
block|,
block|{
literal|0x16
block|,
literal|394
block|,
literal|10000
block|,
literal|"X3.193-1990"
block|}
block|,
block|{
literal|0x17
block|,
literal|1673
block|,
literal|42500
block|,
literal|"X3B5/91-174"
block|}
block|,
block|{
literal|0x18
block|,
literal|1673
block|,
literal|42500
block|,
literal|"X3B5/92-50"
block|}
block|,
block|{
literal|0x19
block|,
literal|2460
block|,
literal|62500
block|,
literal|"DLTapeIII"
block|}
block|,
block|{
literal|0x1A
block|,
literal|3214
block|,
literal|81633
block|,
literal|"DLTapeIV(20GB)"
block|}
block|,
block|{
literal|0x1B
block|,
literal|3383
block|,
literal|85937
block|,
literal|"DLTapeIV(35GB)"
block|}
block|,
block|{
literal|0x1C
block|,
literal|1654
block|,
literal|42000
block|,
literal|"QIC-385M"
block|}
block|,
block|{
literal|0x1D
block|,
literal|1512
block|,
literal|38400
block|,
literal|"QIC-410M"
block|}
block|,
block|{
literal|0x1E
block|,
literal|1385
block|,
literal|36000
block|,
literal|"QIC-1000C"
block|}
block|,
block|{
literal|0x1F
block|,
literal|2666
block|,
literal|67733
block|,
literal|"QIC-2100C"
block|}
block|,
block|{
literal|0x20
block|,
literal|2666
block|,
literal|67733
block|,
literal|"QIC-6GB(M)"
block|}
block|,
block|{
literal|0x21
block|,
literal|2666
block|,
literal|67733
block|,
literal|"QIC-20GB(C)"
block|}
block|,
block|{
literal|0x22
block|,
literal|1600
block|,
literal|40640
block|,
literal|"QIC-2GB(C)"
block|}
block|,
block|{
literal|0x23
block|,
literal|2666
block|,
literal|67733
block|,
literal|"QIC-875M"
block|}
block|,
block|{
literal|0x24
block|,
literal|2400
block|,
literal|61000
block|,
literal|"DDS-2"
block|}
block|,
block|{
literal|0x25
block|,
literal|3816
block|,
literal|97000
block|,
literal|"DDS-3"
block|}
block|,
block|{
literal|0x26
block|,
literal|3816
block|,
literal|97000
block|,
literal|"DDS-4"
block|}
block|,
block|{
literal|0x27
block|,
literal|3056
block|,
literal|77611
block|,
literal|"Mammoth"
block|}
block|,
block|{
literal|0x28
block|,
literal|1491
block|,
literal|37871
block|,
literal|"X3.224"
block|}
block|,
block|{
literal|0x40
block|,
literal|4880
block|,
literal|123952
block|,
literal|"LTO-1"
block|}
block|,
block|{
literal|0x41
block|,
literal|3868
block|,
literal|98250
block|,
literal|"DLTapeIV(40GB)"
block|}
block|,
block|{
literal|0x42
block|,
literal|7398
block|,
literal|187909
block|,
literal|"LTO-2"
block|}
block|,
block|{
literal|0x44
block|,
literal|9638
block|,
literal|244805
block|,
literal|"LTO-3"
block|}
block|,
block|{
literal|0x46
block|,
literal|12725
block|,
literal|323215
block|,
literal|"LTO-4"
block|}
block|,
block|{
literal|0x47
block|,
literal|6417
block|,
literal|163000
block|,
literal|"DAT-72"
block|}
block|,
comment|/* 	 * XXX KDM note that 0x48 is also the density code for DAT-160. 	 * For some reason they used overlapping density codes. 	 */
if|#
directive|if
literal|0
block|{ 0x48, 6870,   174500, "DAT-160" },
endif|#
directive|endif
block|{
literal|0x48
block|,
literal|5236
block|,
literal|133000
block|,
literal|"SDLTapeI(110)"
block|}
block|,
block|{
literal|0x49
block|,
literal|7598
block|,
literal|193000
block|,
literal|"SDLTapeI(160)"
block|}
block|,
block|{
literal|0x4a
block|,
literal|0
block|,
literal|0
block|,
literal|"T10000A"
block|}
block|,
block|{
literal|0x4b
block|,
literal|0
block|,
literal|0
block|,
literal|"T10000B"
block|}
block|,
block|{
literal|0x4c
block|,
literal|0
block|,
literal|0
block|,
literal|"T10000C"
block|}
block|,
block|{
literal|0x4d
block|,
literal|0
block|,
literal|0
block|,
literal|"T10000D"
block|}
block|,
block|{
literal|0x51
block|,
literal|11800
block|,
literal|299720
block|,
literal|"3592A1 (unencrypted)"
block|}
block|,
block|{
literal|0x52
block|,
literal|11800
block|,
literal|299720
block|,
literal|"3592A2 (unencrypted)"
block|}
block|,
block|{
literal|0x53
block|,
literal|13452
block|,
literal|341681
block|,
literal|"3592A3 (unencrypted)"
block|}
block|,
block|{
literal|0x54
block|,
literal|19686
block|,
literal|500024
block|,
literal|"3592A4 (unencrypted)"
block|}
block|,
block|{
literal|0x55
block|,
literal|20670
block|,
literal|525018
block|,
literal|"3592A5 (unencrypted)"
block|}
block|,
block|{
literal|0x58
block|,
literal|15142
block|,
literal|384607
block|,
literal|"LTO-5"
block|}
block|,
block|{
literal|0x5A
block|,
literal|15142
block|,
literal|384607
block|,
literal|"LTO-6"
block|}
block|,
block|{
literal|0x71
block|,
literal|11800
block|,
literal|299720
block|,
literal|"3592A1 (encrypted)"
block|}
block|,
block|{
literal|0x72
block|,
literal|11800
block|,
literal|299720
block|,
literal|"3592A2 (encrypted)"
block|}
block|,
block|{
literal|0x73
block|,
literal|13452
block|,
literal|341681
block|,
literal|"3592A3 (encrypted)"
block|}
block|,
block|{
literal|0x74
block|,
literal|19686
block|,
literal|500024
block|,
literal|"3592A4 (encrypted)"
block|}
block|,
block|{
literal|0x75
block|,
literal|20670
block|,
literal|525018
block|,
literal|"3592A5 (encrypted)"
block|}
block|,
block|{
literal|0x8c
block|,
literal|1789
block|,
literal|45434
block|,
literal|"EXB-8500c"
block|}
block|,
block|{
literal|0x90
block|,
literal|1703
block|,
literal|43245
block|,
literal|"EXB-8200c"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|const
name|char
modifier|*
name|mt_density_name
parameter_list|(
name|int
name|density_num
parameter_list|)
block|{
name|struct
name|densities
modifier|*
name|sd
decl_stmt|;
comment|/* densities 0 and 0x7f are handled as special cases */
if|if
condition|(
name|density_num
operator|==
literal|0
condition|)
return|return
operator|(
literal|"default"
operator|)
return|;
if|if
condition|(
name|density_num
operator|==
literal|0x7f
condition|)
return|return
operator|(
literal|"same"
operator|)
return|;
for|for
control|(
name|sd
operator|=
name|dens
init|;
name|sd
operator|->
name|dens
operator|!=
literal|0
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|sd
operator|->
name|dens
operator|==
name|density_num
condition|)
break|break;
if|if
condition|(
name|sd
operator|->
name|dens
operator|==
literal|0
condition|)
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
return|return
operator|(
name|sd
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a specific density number, return either the bits per inch or bits  * per millimeter for the given density.  */
end_comment

begin_function
name|int
name|mt_density_bp
parameter_list|(
name|int
name|density_num
parameter_list|,
name|int
name|bpi
parameter_list|)
block|{
name|struct
name|densities
modifier|*
name|sd
decl_stmt|;
for|for
control|(
name|sd
operator|=
name|dens
init|;
name|sd
operator|->
name|dens
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|sd
operator|->
name|dens
operator|==
name|density_num
condition|)
break|break;
if|if
condition|(
name|sd
operator|->
name|dens
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bpi
condition|)
return|return
operator|(
name|sd
operator|->
name|bpi
operator|)
return|;
else|else
return|return
operator|(
name|sd
operator|->
name|bpmm
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mt_density_num
parameter_list|(
specifier|const
name|char
modifier|*
name|density_name
parameter_list|)
block|{
name|struct
name|densities
modifier|*
name|sd
decl_stmt|;
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|density_name
argument_list|)
decl_stmt|;
for|for
control|(
name|sd
operator|=
name|dens
init|;
name|sd
operator|->
name|dens
condition|;
name|sd
operator|++
control|)
if|if
condition|(
name|strncasecmp
argument_list|(
name|sd
operator|->
name|name
argument_list|,
name|density_name
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|sd
operator|->
name|dens
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current status XML string.  * Returns 0 on success, -1 on failure (with errno set, and *xml_str == NULL).  */
end_comment

begin_function
name|int
name|mt_get_xml_str
parameter_list|(
name|int
name|mtfd
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|char
modifier|*
modifier|*
name|xml_str
parameter_list|)
block|{
name|size_t
name|alloc_len
init|=
literal|32768
decl_stmt|;
name|struct
name|mtextget
name|extget
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|xml_str
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bzero
argument_list|(
operator|&
name|extget
argument_list|,
sizeof|sizeof
argument_list|(
name|extget
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|xml_str
operator|=
name|malloc
argument_list|(
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|xml_str
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|extget
operator|.
name|status_xml
operator|=
operator|*
name|xml_str
expr_stmt|;
name|extget
operator|.
name|alloc_len
operator|=
name|alloc_len
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|mtfd
argument_list|,
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|extget
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|extget
operator|.
name|status
operator|==
name|MT_EXT_GET_OK
condition|)
break|break;
name|free
argument_list|(
operator|*
name|xml_str
argument_list|)
expr_stmt|;
operator|*
name|xml_str
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|extget
operator|.
name|status
operator|!=
name|MT_EXT_GET_NEED_MORE_SPACE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* The driver needs more space, so double and try again. */
name|alloc_len
operator|*=
literal|2
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Populate a struct mt_status_data from the XML string via mt_get_xml_str().  *  * Returns XML_STATUS_OK on success.  * If XML_STATUS_ERROR is returned, errno may be set to indicate the reason.  * The caller must check status_data->error.  */
end_comment

begin_function
name|int
name|mt_get_status
parameter_list|(
name|char
modifier|*
name|xml_str
parameter_list|,
name|struct
name|mt_status_data
modifier|*
name|status_data
parameter_list|)
block|{
name|XML_Parser
name|parser
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|bzero
argument_list|(
name|status_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status_data
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|status_data
operator|->
name|entries
argument_list|)
expr_stmt|;
name|parser
operator|=
name|XML_ParserCreate
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|XML_STATUS_ERROR
operator|)
return|;
block|}
name|XML_SetUserData
argument_list|(
name|parser
argument_list|,
name|status_data
argument_list|)
expr_stmt|;
name|XML_SetElementHandler
argument_list|(
name|parser
argument_list|,
name|mt_start_element
argument_list|,
name|mt_end_element
argument_list|)
expr_stmt|;
name|XML_SetCharacterDataHandler
argument_list|(
name|parser
argument_list|,
name|mt_char_handler
argument_list|)
expr_stmt|;
name|retval
operator|=
name|XML_Parse
argument_list|(
name|parser
argument_list|,
name|xml_str
argument_list|,
name|strlen
argument_list|(
name|xml_str
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XML_ParserFree
argument_list|(
name|parser
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

