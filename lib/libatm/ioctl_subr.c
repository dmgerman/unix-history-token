begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * User Space Library Functions  * ----------------------------  *  * IOCTL subroutines  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"libatm.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Issue an informational IOCTL  *   * The user fills out the opcode and any subtype information.  This  * routine will allocate a buffer and issue the IOCTL.  If the request  * fails because the buffer wasn't big enough, this routine will double  * the buffer size and retry the request repeatedly.  The buffer must  * be freed by the caller.  *   * Arguments:  *	req	pointer to an ATM information request IOCTL structure  *	buf_len	length of buffer to be allocated  *  * Returns:  *	-1	error encountered (reason in errno)  *	int 	length of the returned VCC information  *  */
end_comment

begin_function
name|int
name|do_info_ioctl
parameter_list|(
name|req
parameter_list|,
name|buf_len
parameter_list|)
name|struct
name|atminfreq
modifier|*
name|req
decl_stmt|;
name|int
name|buf_len
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|s
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
comment|/* 	 * Open a socket for the IOCTL 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get memory for returned information 	 */
name|mem_retry
label|:
name|buf
operator|=
name|malloc
argument_list|(
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/* 	 * Set the buffer address and length in the request 	 */
name|req
operator|->
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
name|req
operator|->
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
comment|/* 	 * Issue the IOCTL 	 */
name|rc
operator|=
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCINFO
argument_list|,
operator|(
name|caddr_t
operator|)
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOSPC
condition|)
block|{
name|buf_len
operator|=
name|buf_len
operator|*
literal|2
expr_stmt|;
goto|goto
name|mem_retry
goto|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Set a pointer to the returned info in the request 	 * and return its length 	 */
name|req
operator|->
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|req
operator|->
name|air_buf_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get VCC information  *   * Arguments:  *	intf	pointer to interface name (or null string)  *	vccp	pointer to a pointer to a struct air_vcc_rsp for the  *		address of the returned VCC information  *  * Returns:  *	int 	length of the retuned VCC information  *  */
end_comment

begin_function
name|int
name|get_vcc_info
parameter_list|(
name|intf
parameter_list|,
name|vccp
parameter_list|)
name|char
modifier|*
name|intf
decl_stmt|;
name|struct
name|air_vcc_rsp
modifier|*
modifier|*
name|vccp
decl_stmt|;
block|{
name|int
name|buf_len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_vcc_rsp
argument_list|)
operator|*
literal|100
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
comment|/* 	 * Initialize IOCTL request 	 */
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_VCC
expr_stmt|;
name|bzero
argument_list|(
name|air
operator|.
name|air_vcc_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|air
operator|.
name|air_vcc_intf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intf
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|intf
argument_list|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|air
operator|.
name|air_vcc_intf
argument_list|,
name|intf
argument_list|)
expr_stmt|;
name|buf_len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/* 	 * Return a pointer to the VCC info and its length 	 */
operator|*
name|vccp
operator|=
operator|(
expr|struct
name|air_vcc_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
return|return
operator|(
name|buf_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get subnet mask  *   * Arguments:  *	intf	pointer to an interface name  *	mask	pointer to a struct sockaddr_in to receive the mask  *  * Returns:  *	0 	good completion  *	-1 	error  *  */
end_comment

begin_function
name|int
name|get_subnet_mask
parameter_list|(
name|intf
parameter_list|,
name|mask
parameter_list|)
name|char
modifier|*
name|intf
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|mask
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|ifreq
name|req
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|ip_mask
decl_stmt|;
comment|/* 	 * Check parameters 	 */
if|if
condition|(
operator|!
name|intf
operator|||
operator|!
name|mask
operator|||
name|strlen
argument_list|(
name|intf
argument_list|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
name|intf
argument_list|)
operator|>
name|IFNAMSIZ
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Open a socket for the IOCTL 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Set up and issue the IOCTL 	 */
name|bzero
argument_list|(
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|req
operator|.
name|ifr_name
argument_list|,
name|intf
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|req
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Give the answer back to the caller 	 */
name|ip_mask
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|req
operator|.
name|ifr_addr
expr_stmt|;
operator|*
name|mask
operator|=
operator|*
name|ip_mask
expr_stmt|;
name|mask
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get an interface's MTU  *   * Arguments:  *	intf	pointer to an interface name  *	mtu	pointer to an int to receive the MTU  *  * Returns:  *>= 0 	interface MTU  *	-1 	error  *  */
end_comment

begin_function
name|int
name|get_mtu
parameter_list|(
name|intf
parameter_list|)
name|char
modifier|*
name|intf
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|ifreq
name|req
decl_stmt|;
comment|/* 	 * Check parameters 	 */
if|if
condition|(
operator|!
name|intf
operator|||
name|strlen
argument_list|(
name|intf
argument_list|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
name|intf
argument_list|)
operator|>
name|IFNAMSIZ
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Open a socket for the IOCTL 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Set up and issue the IOCTL 	 */
name|bzero
argument_list|(
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|req
operator|.
name|ifr_name
argument_list|,
name|intf
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFMTU
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|req
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Set the appropriate return value 	 */
if|if
condition|(
name|rc
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|req
operator|.
name|ifr_mtu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify netif name  *   * This routine issues an IOCTL to check whether the passed string is  * a valid network interface name.  *   * Arguments:  *	req	pointer to an ATM information request IOCTL structure  *  * Returns:  *	-1		error encountered  *	FALSE (0) 	the string is not a NIF name  *	TRUE (> 0) 	the string is a valid NIF name  *  */
end_comment

begin_function
name|int
name|verify_nif_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
name|struct
name|air_netif_rsp
modifier|*
name|nif_info
decl_stmt|;
comment|/* 	 * Check whether name is of a valid length 	 */
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
name|IFNAMSIZ
operator|-
literal|1
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
literal|1
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * Open a socket for the IOCTL 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_ATM
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get memory for returned information 	 */
name|nif_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|air_netif_rsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nif_info
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|nif_info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|air_netif_rsp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the request 	 */
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_NIF
expr_stmt|;
name|air
operator|.
name|air_buf_addr
operator|=
operator|(
name|caddr_t
operator|)
name|nif_info
expr_stmt|;
name|air
operator|.
name|air_buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_netif_rsp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|air
operator|.
name|air_netif_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|air
operator|.
name|air_netif_intf
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|air
operator|.
name|air_netif_intf
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Issue the IOCTL 	 */
name|rc
operator|=
name|ioctl
argument_list|(
name|s
argument_list|,
name|AIOCINFO
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|air
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nif_info
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Base return value on IOCTL return code 	 */
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get Config information  *  * Arguments:  *      intf    pointer to interface name (or null string)  *      cfgp    pointer to a pointer to a struct air_cfg_rsp for the  *              address of the returned Config information  *  * Returns:  *      int     length of returned Config information  *  */
end_comment

begin_function
name|int
name|get_cfg_info
parameter_list|(
name|intf
parameter_list|,
name|cfgp
parameter_list|)
name|char
modifier|*
name|intf
decl_stmt|;
name|struct
name|air_cfg_rsp
modifier|*
modifier|*
name|cfgp
decl_stmt|;
block|{
name|int
name|buf_len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
operator|*
literal|4
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
comment|/*          * Initialize IOCTL request          */
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_CFG
expr_stmt|;
name|bzero
argument_list|(
name|air
operator|.
name|air_cfg_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|air
operator|.
name|air_cfg_intf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intf
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|intf
argument_list|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|air
operator|.
name|air_cfg_intf
argument_list|,
name|intf
argument_list|)
expr_stmt|;
name|buf_len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/*          * Return a pointer to the Config info and its length          */
operator|*
name|cfgp
operator|=
operator|(
expr|struct
name|air_cfg_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
return|return
operator|(
name|buf_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get Physical Interface information  *  * Arguments:  *      intf    pointer to interface name (or null string)  *      intp    pointer to a pointer to a struct air_cfg_rsp for the  *              address of the returned Config information  *  * Returns:  *      int     length of returned Config information  *  */
end_comment

begin_function
name|int
name|get_intf_info
parameter_list|(
name|intf
parameter_list|,
name|intp
parameter_list|)
name|char
modifier|*
name|intf
decl_stmt|;
name|struct
name|air_int_rsp
modifier|*
modifier|*
name|intp
decl_stmt|;
block|{
name|int
name|buf_len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_int_rsp
argument_list|)
operator|*
literal|4
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
comment|/*          * Initialize IOCTL request          */
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_INT
expr_stmt|;
name|bzero
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intf
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|intf
argument_list|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
name|intf
argument_list|)
expr_stmt|;
name|buf_len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/*          * Return a pointer to the Physical Interface info and its length          */
operator|*
name|intp
operator|=
operator|(
expr|struct
name|air_int_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
return|return
operator|(
name|buf_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get Netif information  *  * Arguments:  *      intf    pointer to interface name (or null string)  *      netp    pointer to a pointer to a struct air_netif_rsp for the  *              address of the returned Netif information  *  * Returns:  *      int     length of returned Netif information  *  */
end_comment

begin_function
name|int
name|get_netif_info
parameter_list|(
name|intf
parameter_list|,
name|netp
parameter_list|)
name|char
modifier|*
name|intf
decl_stmt|;
name|struct
name|air_netif_rsp
modifier|*
modifier|*
name|netp
decl_stmt|;
block|{
name|int
name|buf_len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_netif_rsp
argument_list|)
operator|*
literal|10
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
comment|/*          * Initialize IOCTL request          */
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_NIF
expr_stmt|;
name|bzero
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
sizeof|sizeof
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intf
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|intf
argument_list|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
name|intf
argument_list|)
expr_stmt|;
name|buf_len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/*          * Return a pointer to the Netif info and its length          */
operator|*
name|netp
operator|=
operator|(
expr|struct
name|air_netif_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
return|return
operator|(
name|buf_len
operator|)
return|;
block|}
end_function

end_unit

