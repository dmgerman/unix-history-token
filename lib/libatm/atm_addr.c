begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * User Space Library Functions  * ----------------------------  *  * ATM address utility functions  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"libatm.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get NSAP, NSAP prefix or MAC address  *  * Arguments:  *	in	pointer to an address in ASCII  *	out	pointer to a buffer for the converted address  *	len	the length of the output buffer  *  * Returns:  *	0	error in format  *	len	the length of the data in the output buffer  *  */
end_comment

begin_function
name|int
name|get_hex_atm_addr
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|in
decl_stmt|;
name|u_char
modifier|*
name|out
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|c_type
decl_stmt|,
name|c_value
decl_stmt|,
name|i
decl_stmt|,
name|out_len
decl_stmt|,
name|state
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
comment|/* 	 * Character table 	 */
specifier|static
struct|struct
block|{
name|char
name|c
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|char_table
index|[]
init|=
block|{
block|{
literal|'.'
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Type 0 -- period */
block|{
literal|':'
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Type 0 -- colon */
block|{
literal|'0'
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* Type 1 -- hex digit */
block|{
literal|'1'
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|'2'
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|'3'
block|,
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|'4'
block|,
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|'5'
block|,
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|'6'
block|,
literal|1
block|,
literal|6
block|}
block|,
block|{
literal|'7'
block|,
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|'8'
block|,
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|'9'
block|,
literal|1
block|,
literal|9
block|}
block|,
block|{
literal|'a'
block|,
literal|1
block|,
literal|10
block|}
block|,
block|{
literal|'b'
block|,
literal|1
block|,
literal|11
block|}
block|,
block|{
literal|'c'
block|,
literal|1
block|,
literal|12
block|}
block|,
block|{
literal|'d'
block|,
literal|1
block|,
literal|13
block|}
block|,
block|{
literal|'e'
block|,
literal|1
block|,
literal|14
block|}
block|,
block|{
literal|'f'
block|,
literal|1
block|,
literal|15
block|}
block|,
block|{
literal|'A'
block|,
literal|1
block|,
literal|10
block|}
block|,
block|{
literal|'B'
block|,
literal|1
block|,
literal|11
block|}
block|,
block|{
literal|'C'
block|,
literal|1
block|,
literal|12
block|}
block|,
block|{
literal|'D'
block|,
literal|1
block|,
literal|13
block|}
block|,
block|{
literal|'E'
block|,
literal|1
block|,
literal|14
block|}
block|,
block|{
literal|'F'
block|,
literal|1
block|,
literal|15
block|}
block|,
block|{
literal|'\0'
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* Type 2 -- end of input */
block|}
struct|;
comment|/* 	 * State table 	 */
specifier|static
struct|struct
block|{
name|int
name|action
decl_stmt|;
name|int
name|state
decl_stmt|;
block|}
name|state_table
index|[
literal|3
index|]
index|[
literal|3
index|]
init|=
block|{
comment|/* Period     Hex       End			*/
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|0
block|}
block|}
block|,
comment|/* Init	*/
block|{
block|{
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|0
block|}
block|}
block|,
comment|/* C1	*/
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|0
block|}
block|}
block|,
comment|/* C2	*/
block|}
struct|;
comment|/* 	 * Initialize 	 */
name|state
operator|=
literal|0
expr_stmt|;
name|out_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|in
argument_list|,
literal|"0x"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|in
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Loop through input until state table says to return 	 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 		 * Get the character type and value 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|char_table
index|[
name|i
index|]
operator|.
name|c
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|char_table
index|[
name|i
index|]
operator|.
name|c
operator|==
operator|*
name|in
condition|)
break|break;
if|if
condition|(
name|char_table
index|[
name|i
index|]
operator|.
name|c
operator|!=
operator|*
name|in
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c_type
operator|=
name|char_table
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
name|c_value
operator|=
name|char_table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
comment|/* 		 * Process next character based on state and type 		 */
switch|switch
condition|(
name|state_table
index|[
name|state
index|]
index|[
name|c_type
index|]
operator|.
name|action
condition|)
block|{
case|case
literal|0
case|:
comment|/* 			 * Ignore the character 			 */
break|break;
case|case
literal|1
case|:
comment|/* 			 * Save the character's value 			 */
name|val
operator|=
name|c_value
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Return the assembled NSAP 			 */
return|return
operator|(
name|out_len
operator|)
return|;
case|case
literal|3
case|:
comment|/* 			 * Assemble and save the output byte 			 */
name|val
operator|=
name|val
operator|<<
literal|4
expr_stmt|;
name|val
operator|+=
name|c_value
expr_stmt|;
name|out
index|[
name|out_len
index|]
operator|=
operator|(
name|u_char
operator|)
name|val
expr_stmt|;
name|out_len
operator|++
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* 			 * Invalid input sequence 			 */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Set the next state and go on to the next character 		 */
name|state
operator|=
name|state_table
index|[
name|state
index|]
index|[
name|c_type
index|]
operator|.
name|state
expr_stmt|;
name|in
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Format an ATM address into a string  *   * Arguments:  *	addr	pointer to an atm address  *  * Returns:  *	none  *  */
end_comment

begin_function
name|char
modifier|*
name|format_atm_addr
parameter_list|(
name|addr
parameter_list|)
name|Atm_addr
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|nsap_format
decl_stmt|;
name|Atm_addr_nsap
modifier|*
name|atm_nsap
decl_stmt|;
name|Atm_addr_e164
modifier|*
name|atm_e164
decl_stmt|;
name|Atm_addr_spans
modifier|*
name|atm_spans
decl_stmt|;
name|Atm_addr_pvc
modifier|*
name|atm_pvc
decl_stmt|;
specifier|static
name|char
name|str
index|[
literal|256
index|]
decl_stmt|;
union|union
block|{
name|int
name|w
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|u1
union|,
name|u2
union|;
specifier|static
name|char
name|nsap_format_DCC
index|[]
init|=
literal|"0x%02x.%02x%02x.%02x.%02x%02x%02x.%02x%02x.%02x%02x.%02x%02x.%02x%02x%02x%02x%02x%02x.%02x"
decl_stmt|;
specifier|static
name|char
name|nsap_format_ICD
index|[]
init|=
literal|"0x%02x.%02x%02x.%02x.%02x%02x%02x.%02x%02x.%02x%02x.%02x%02x.%02x%02x%02x%02x%02x%02x.%02x"
decl_stmt|;
specifier|static
name|char
name|nsap_format_E164
index|[]
init|=
literal|"0x%02x.%02x%02x%02x%02x%02x%02x%02x%02x.%02x%02x.%02x%02x.%02x%02x%02x%02x%02x%02x.%02x"
decl_stmt|;
comment|/* 	 * Clear the returned string 	 */
name|UM_ZERO
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/* 	 * Print format is determined by address type 	 */
switch|switch
condition|(
name|addr
operator|->
name|address_format
condition|)
block|{
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|atm_nsap
operator|=
operator|(
name|Atm_addr_nsap
operator|*
operator|)
name|addr
operator|->
name|address
expr_stmt|;
switch|switch
condition|(
name|atm_nsap
operator|->
name|aan_afi
condition|)
block|{
default|default:
case|case
name|AFI_DCC
case|:
name|nsap_format
operator|=
name|nsap_format_DCC
expr_stmt|;
break|break;
case|case
name|AFI_ICD
case|:
name|nsap_format
operator|=
name|nsap_format_ICD
expr_stmt|;
break|break;
case|case
name|AFI_E164
case|:
name|nsap_format
operator|=
name|nsap_format_E164
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|str
argument_list|,
name|nsap_format
argument_list|,
name|atm_nsap
operator|->
name|aan_afi
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|0
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|1
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|2
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|3
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|4
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|5
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|6
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|7
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|8
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|9
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|10
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_afspec
index|[
literal|11
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_esi
index|[
literal|0
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_esi
index|[
literal|1
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_esi
index|[
literal|2
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_esi
index|[
literal|3
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_esi
index|[
literal|4
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_esi
index|[
literal|5
index|]
argument_list|,
name|atm_nsap
operator|->
name|aan_sel
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ATM_E164_ADDR
case|:
name|atm_e164
operator|=
operator|(
name|Atm_addr_e164
operator|*
operator|)
name|addr
operator|->
name|address
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addr
operator|->
name|address_length
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
operator|&
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
index|]
argument_list|,
literal|"%c"
argument_list|,
name|atm_e164
operator|->
name|aae_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_ATM_SPANS_ADDR
case|:
comment|/* 		 * Print SPANS address as two words, xxxx.yyyy 		 */
name|atm_spans
operator|=
operator|(
name|Atm_addr_spans
operator|*
operator|)
name|addr
operator|->
name|address
expr_stmt|;
name|u1
operator|.
name|c
index|[
literal|0
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|0
index|]
expr_stmt|;
name|u1
operator|.
name|c
index|[
literal|1
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|1
index|]
expr_stmt|;
name|u1
operator|.
name|c
index|[
literal|2
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|2
index|]
expr_stmt|;
name|u1
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|3
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|0
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|4
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|1
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|5
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|2
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|6
index|]
expr_stmt|;
name|u2
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|atm_spans
operator|->
name|aas_addr
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|u1
operator|.
name|w
operator|==
literal|0
operator|&&
name|u2
operator|.
name|w
operator|==
literal|0
operator|)
condition|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"0x%08lx.%08lx"
argument_list|,
name|ntohl
argument_list|(
name|u1
operator|.
name|w
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|u2
operator|.
name|w
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ATM_PVC_ADDR
case|:
comment|/* 		 * Print PVC as VPI, VCI 		 */
name|atm_pvc
operator|=
operator|(
name|Atm_addr_pvc
operator|*
operator|)
name|addr
operator|->
name|address
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%d, %d"
argument_list|,
name|ATM_PVC_GET_VPI
argument_list|(
name|atm_pvc
argument_list|)
argument_list|,
name|ATM_PVC_GET_VCI
argument_list|(
name|atm_pvc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_ATM_ABSENT
case|:
default|default:
break|break;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

end_unit

