begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001 Dima Dorfman.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This is the traditional Berkeley MP library implemented in terms of  * the OpenSSL BIGNUM library.  It was written to replace libgmp, and  * is meant to be as compatible with the latter as feasible.  *  * There seems to be a lack of documentation for the Berkeley MP  * interface.  All I could find was libgmp documentation (which didn't  * talk about the semantics of the functions) and an old SunOS 4.1  * manual page from 1989.  The latter wasn't very detailed, either,  * but at least described what the function's arguments were.  In  * general the interface seems to be archaic, somewhat poorly  * designed, and poorly, if at all, documented.  It is considered  * harmful.  *  * Miscellaneous notes on this implementation:  *  *  - The SunOS manual page mentioned above indicates that if an error  *  occurs, the library should "produce messages and core images."  *  Given that most of the functions don't have return values (and  *  thus no sane way of alerting the caller to an error), this seems  *  reasonable.  The MPERR and MPERRX macros call warn and warnx,  *  respectively, then abort().  *  *  - All the functions which take an argument to be "filled in"  *  assume that the argument has been initialized by one of the *tom()  *  routines before being passed to it.  I never saw this documented  *  anywhere, but this seems to be consistent with the way this  *  library is used.  *  *  - msqrt() is the only routine which had to be implemented which  *  doesn't have a close counterpart in the OpenSSL BIGNUM library.  *  It was implemented by hand using Newton's recursive formula.  *  Doing it this way, although more error-prone, has the positive  *  sideaffect of testing a lot of other functions; if msqrt()  *  produces the correct results, most of the other routines will as  *  well.  *  *  - Internal-use-only routines (i.e., those defined here statically  *  and not in mp.h) have an underscore prepended to their name (this  *  is more for aesthetical reasons than technical).  All such  *  routines take an extra argument, 'msg', that denotes what they  *  should call themselves in an error message.  This is so a user  *  doesn't get an error message from a function they didn't call.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|"openssl/crypto/bn/bn_lcl.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_define
define|#
directive|define
name|MPERR
parameter_list|(
name|s
parameter_list|)
value|do { warn s; abort(); } while (0)
end_define

begin_define
define|#
directive|define
name|MPERRX
parameter_list|(
name|s
parameter_list|)
value|do { warnx s; abort(); } while (0)
end_define

begin_define
define|#
directive|define
name|BN_ERRCHECK
parameter_list|(
name|msg
parameter_list|,
name|expr
parameter_list|)
value|do {		\ 	if (!(expr)) _bnerr(msg);		\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|_bnerr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MINT
modifier|*
name|_dtom
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MINT
modifier|*
name|_itom
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_madd
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_mcmpa
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_mdiv
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_mfree
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_moveb
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_movem
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_msub
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_mtod
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_mtox
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_mult
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
name|MINT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_sdiv
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|MINT
modifier|*
parameter_list|,
name|short
parameter_list|,
name|MINT
modifier|*
parameter_list|,
name|short
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|MINT
modifier|*
name|_xtom
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Report an error from one of the BN_* functions using MPERRX.  */
end_comment

begin_function
specifier|static
name|void
name|_bnerr
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|MPERRX
argument_list|(
operator|(
literal|"%s: %s"
operator|,
name|msg
operator|,
name|ERR_reason_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a decimal string to an MINT.  */
end_comment

begin_function
specifier|static
name|MINT
modifier|*
name|_dtom
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|MINT
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|MPERR
argument_list|(
operator|(
literal|"%s"
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|bn
operator|==
name|NULL
condition|)
name|_bnerr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_dec2bn
argument_list|(
operator|&
name|mp
operator|->
name|bn
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the greatest common divisor of mp1 and mp2; result goes in rmp.  */
end_comment

begin_function
name|void
name|gcd
parameter_list|(
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|BIGNUM
name|b
decl_stmt|;
name|BN_CTX
name|c
decl_stmt|;
name|BN_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
literal|"gcd"
argument_list|,
name|BN_gcd
argument_list|(
operator|&
name|b
argument_list|,
name|mp1
operator|->
name|bn
argument_list|,
name|mp2
operator|->
name|bn
argument_list|,
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
literal|"gcd"
argument_list|,
operator|&
name|b
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an MINT out of a short integer.  Return value must be mfree()'d.  */
end_comment

begin_function
specifier|static
name|MINT
modifier|*
name|_itom
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|short
name|n
parameter_list|)
block|{
name|MINT
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|s
argument_list|,
literal|"%x"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|MPERR
argument_list|(
operator|(
literal|"%s"
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|=
name|_xtom
argument_list|(
name|msg
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
block|}
end_function

begin_function
name|MINT
modifier|*
name|itom
parameter_list|(
name|short
name|n
parameter_list|)
block|{
return|return
operator|(
name|_itom
argument_list|(
literal|"itom"
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute rmp=mp1+mp2.  */
end_comment

begin_function
specifier|static
name|void
name|_madd
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|BIGNUM
name|b
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_add
argument_list|(
operator|&
name|b
argument_list|,
name|mp1
operator|->
name|bn
argument_list|,
name|mp2
operator|->
name|bn
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
name|msg
argument_list|,
operator|&
name|b
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|madd
parameter_list|(
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|_madd
argument_list|(
literal|"madd"
argument_list|,
name|mp1
argument_list|,
name|mp2
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return -1, 0, or 1 if mp1<mp2, mp1==mp2, or mp1>mp2, respectivley.  */
end_comment

begin_function
name|int
name|mcmp
parameter_list|(
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|)
block|{
return|return
operator|(
name|BN_cmp
argument_list|(
name|mp1
operator|->
name|bn
argument_list|,
name|mp2
operator|->
name|bn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as mcmp but compares absolute values.  */
end_comment

begin_function
specifier|static
name|int
name|_mcmpa
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
name|__unused
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|)
block|{
return|return
operator|(
name|BN_ucmp
argument_list|(
name|mp1
operator|->
name|bn
argument_list|,
name|mp2
operator|->
name|bn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute qmp=nmp/dmp and rmp=nmp%dmp.  */
end_comment

begin_function
specifier|static
name|void
name|_mdiv
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|nmp
parameter_list|,
specifier|const
name|MINT
modifier|*
name|dmp
parameter_list|,
name|MINT
modifier|*
name|qmp
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|BIGNUM
name|q
decl_stmt|,
name|r
decl_stmt|;
name|BN_CTX
name|c
decl_stmt|;
name|BN_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_div
argument_list|(
operator|&
name|q
argument_list|,
operator|&
name|r
argument_list|,
name|nmp
operator|->
name|bn
argument_list|,
name|dmp
operator|->
name|bn
argument_list|,
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
name|msg
argument_list|,
operator|&
name|q
argument_list|,
name|qmp
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
name|msg
argument_list|,
operator|&
name|r
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mdiv
parameter_list|(
specifier|const
name|MINT
modifier|*
name|nmp
parameter_list|,
specifier|const
name|MINT
modifier|*
name|dmp
parameter_list|,
name|MINT
modifier|*
name|qmp
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|_mdiv
argument_list|(
literal|"mdiv"
argument_list|,
name|nmp
argument_list|,
name|dmp
argument_list|,
name|qmp
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free memory associated with an MINT.  */
end_comment

begin_function
specifier|static
name|void
name|_mfree
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
name|__unused
parameter_list|,
name|MINT
modifier|*
name|mp
parameter_list|)
block|{
name|BN_clear
argument_list|(
name|mp
operator|->
name|bn
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|mp
operator|->
name|bn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfree
parameter_list|(
name|MINT
modifier|*
name|mp
parameter_list|)
block|{
name|_mfree
argument_list|(
literal|"mfree"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read an integer from standard input and stick the result in mp.  * The input is treated to be in base 10.  This must be the silliest  * API in existence; why can't the program read in a string and call  * xtom()?  (Or if base 10 is desires, perhaps dtom() could be  * exported.)  */
end_comment

begin_function
name|void
name|min
parameter_list|(
name|MINT
modifier|*
name|mp
parameter_list|)
block|{
name|MINT
modifier|*
name|rmp
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|nline
decl_stmt|;
name|size_t
name|linelen
decl_stmt|;
name|line
operator|=
name|fgetln
argument_list|(
name|stdin
argument_list|,
operator|&
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
name|MPERR
argument_list|(
operator|(
literal|"min"
operator|)
argument_list|)
expr_stmt|;
name|nline
operator|=
name|malloc
argument_list|(
name|linelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nline
operator|==
name|NULL
condition|)
name|MPERR
argument_list|(
operator|(
literal|"min"
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|nline
argument_list|,
name|line
argument_list|,
name|linelen
argument_list|)
expr_stmt|;
name|nline
index|[
name|linelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rmp
operator|=
name|_dtom
argument_list|(
literal|"min"
argument_list|,
name|nline
argument_list|)
expr_stmt|;
name|_movem
argument_list|(
literal|"min"
argument_list|,
name|rmp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"min"
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nline
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the value of mp to standard output in base 10.  See blurb  * above min() for why this is so useless.  */
end_comment

begin_function
name|void
name|mout
parameter_list|(
specifier|const
name|MINT
modifier|*
name|mp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|_mtod
argument_list|(
literal|"mout"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the value of tmp to the value of smp (i.e., tmp=smp).  */
end_comment

begin_function
name|void
name|move
parameter_list|(
specifier|const
name|MINT
modifier|*
name|smp
parameter_list|,
name|MINT
modifier|*
name|tmp
parameter_list|)
block|{
name|_movem
argument_list|(
literal|"move"
argument_list|,
name|smp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Internal routine to set the value of tmp to that of sbp.  */
end_comment

begin_function
specifier|static
name|void
name|_moveb
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|sbp
parameter_list|,
name|MINT
modifier|*
name|tmp
parameter_list|)
block|{
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_copy
argument_list|(
name|tmp
operator|->
name|bn
argument_list|,
name|sbp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Internal routine to set the value of tmp to that of smp.  */
end_comment

begin_function
specifier|static
name|void
name|_movem
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|smp
parameter_list|,
name|MINT
modifier|*
name|tmp
parameter_list|)
block|{
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_copy
argument_list|(
name|tmp
operator|->
name|bn
argument_list|,
name|smp
operator|->
name|bn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the square root of nmp and put the result in xmp.  The  * remainder goes in rmp.  Should satisfy: rmp=nmp-(xmp*xmp).  *  * Note that the OpenSSL BIGNUM library does not have a square root  * function, so this had to be implemented by hand using Newton's  * recursive formula:  *  *		x = (x + (n / x)) / 2  *  * where x is the square root of the positive number n.  In the  * beginning, x should be a reasonable guess, but the value 1,  * although suboptimal, works, too; this is that is used below.  */
end_comment

begin_function
name|void
name|msqrt
parameter_list|(
specifier|const
name|MINT
modifier|*
name|nmp
parameter_list|,
name|MINT
modifier|*
name|xmp
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|MINT
modifier|*
name|tolerance
decl_stmt|;
name|MINT
modifier|*
name|ox
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|MINT
modifier|*
name|z1
decl_stmt|,
modifier|*
name|z2
decl_stmt|,
modifier|*
name|z3
decl_stmt|;
name|short
name|i
decl_stmt|;
name|tolerance
operator|=
name|_itom
argument_list|(
literal|"msqrt"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|_itom
argument_list|(
literal|"msqrt"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ox
operator|=
name|_itom
argument_list|(
literal|"msqrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z1
operator|=
name|_itom
argument_list|(
literal|"msqrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z2
operator|=
name|_itom
argument_list|(
literal|"msqrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z3
operator|=
name|_itom
argument_list|(
literal|"msqrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|_movem
argument_list|(
literal|"msqrt"
argument_list|,
name|x
argument_list|,
name|ox
argument_list|)
expr_stmt|;
name|_mdiv
argument_list|(
literal|"msqrt"
argument_list|,
name|nmp
argument_list|,
name|x
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|_madd
argument_list|(
literal|"msqrt"
argument_list|,
name|x
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|_sdiv
argument_list|(
literal|"msqrt"
argument_list|,
name|z2
argument_list|,
literal|2
argument_list|,
name|x
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|_msub
argument_list|(
literal|"msqrt"
argument_list|,
name|ox
argument_list|,
name|x
argument_list|,
name|z3
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|_mcmpa
argument_list|(
literal|"msqrt"
argument_list|,
name|z3
argument_list|,
name|tolerance
argument_list|)
operator|==
literal|1
condition|)
do|;
name|_movem
argument_list|(
literal|"msqrt"
argument_list|,
name|x
argument_list|,
name|xmp
argument_list|)
expr_stmt|;
name|_mult
argument_list|(
literal|"msqrt"
argument_list|,
name|x
argument_list|,
name|x
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|_msub
argument_list|(
literal|"msqrt"
argument_list|,
name|nmp
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|_movem
argument_list|(
literal|"msqrt"
argument_list|,
name|z2
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"msqrt"
argument_list|,
name|tolerance
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"msqrt"
argument_list|,
name|ox
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"msqrt"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"msqrt"
argument_list|,
name|z1
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"msqrt"
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"msqrt"
argument_list|,
name|z3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute rmp=mp1-mp2.  */
end_comment

begin_function
specifier|static
name|void
name|_msub
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|BIGNUM
name|b
decl_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_sub
argument_list|(
operator|&
name|b
argument_list|,
name|mp1
operator|->
name|bn
argument_list|,
name|mp2
operator|->
name|bn
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
name|msg
argument_list|,
operator|&
name|b
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msub
parameter_list|(
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|_msub
argument_list|(
literal|"msub"
argument_list|,
name|mp1
argument_list|,
name|mp2
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a decimal representation of mp.  Return value must be  * free()'d.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_mtod
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|s
operator|=
name|BN_bn2dec
argument_list|(
name|mp
operator|->
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|_bnerr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|s2
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
name|MPERR
argument_list|(
operator|(
literal|"%s"
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|s2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a hexadecimal representation of mp.  Return value must be  * free()'d.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_mtox
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|s
operator|=
name|BN_bn2hex
argument_list|(
name|mp
operator|->
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|_bnerr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|s2
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
name|MPERR
argument_list|(
operator|(
literal|"%s"
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * This is a kludge for libgmp compatibility.  The latter's 	 * implementation of this function returns lower-case letters, 	 * but BN_bn2hex returns upper-case.  Some programs (e.g., 	 * newkey(1)) are sensitive to this.  Although it's probably 	 * their fault, it's nice to be compatible. 	 */
name|len
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s2
init|;
name|p
operator|<
name|s2
operator|+
name|len
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|s2
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|mtox
parameter_list|(
specifier|const
name|MINT
modifier|*
name|mp
parameter_list|)
block|{
return|return
operator|(
name|_mtox
argument_list|(
literal|"mtox"
argument_list|,
name|mp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute rmp=mp1*mp2.  */
end_comment

begin_function
specifier|static
name|void
name|_mult
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|BIGNUM
name|b
decl_stmt|;
name|BN_CTX
name|c
decl_stmt|;
name|BN_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_mul
argument_list|(
operator|&
name|b
argument_list|,
name|mp1
operator|->
name|bn
argument_list|,
name|mp2
operator|->
name|bn
argument_list|,
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
name|msg
argument_list|,
operator|&
name|b
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mult
parameter_list|(
specifier|const
name|MINT
modifier|*
name|mp1
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mp2
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|_mult
argument_list|(
literal|"mult"
argument_list|,
name|mp1
argument_list|,
name|mp2
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute rmp=(bmp^emp)mod mmp.  (Note that here and above rpow() '^'  * means 'raise to power', not 'bitwise XOR'.)  */
end_comment

begin_function
name|void
name|pow
parameter_list|(
specifier|const
name|MINT
modifier|*
name|bmp
parameter_list|,
specifier|const
name|MINT
modifier|*
name|emp
parameter_list|,
specifier|const
name|MINT
modifier|*
name|mmp
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|BIGNUM
name|b
decl_stmt|;
name|BN_CTX
name|c
decl_stmt|;
name|BN_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
literal|"pow"
argument_list|,
name|BN_mod_exp
argument_list|(
operator|&
name|b
argument_list|,
name|bmp
operator|->
name|bn
argument_list|,
name|emp
operator|->
name|bn
argument_list|,
name|mmp
operator|->
name|bn
argument_list|,
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
literal|"pow"
argument_list|,
operator|&
name|b
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute rmp=bmp^e.  (See note above pow().)  */
end_comment

begin_function
name|void
name|rpow
parameter_list|(
specifier|const
name|MINT
modifier|*
name|bmp
parameter_list|,
name|short
name|e
parameter_list|,
name|MINT
modifier|*
name|rmp
parameter_list|)
block|{
name|MINT
modifier|*
name|emp
decl_stmt|;
name|BIGNUM
name|b
decl_stmt|;
name|BN_CTX
name|c
decl_stmt|;
name|BN_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|emp
operator|=
name|_itom
argument_list|(
literal|"rpow"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
literal|"rpow"
argument_list|,
name|BN_exp
argument_list|(
operator|&
name|b
argument_list|,
name|bmp
operator|->
name|bn
argument_list|,
name|emp
operator|->
name|bn
argument_list|,
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
literal|"rpow"
argument_list|,
operator|&
name|b
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
literal|"rpow"
argument_list|,
name|emp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute qmp=nmp/d and ro=nmp%d.  */
end_comment

begin_function
specifier|static
name|void
name|_sdiv
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|MINT
modifier|*
name|nmp
parameter_list|,
name|short
name|d
parameter_list|,
name|MINT
modifier|*
name|qmp
parameter_list|,
name|short
modifier|*
name|ro
parameter_list|)
block|{
name|MINT
modifier|*
name|dmp
decl_stmt|,
modifier|*
name|rmp
decl_stmt|;
name|BIGNUM
name|q
decl_stmt|,
name|r
decl_stmt|;
name|BN_CTX
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|BN_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|dmp
operator|=
name|_itom
argument_list|(
name|msg
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|rmp
operator|=
name|_itom
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_div
argument_list|(
operator|&
name|q
argument_list|,
operator|&
name|r
argument_list|,
name|nmp
operator|->
name|bn
argument_list|,
name|dmp
operator|->
name|bn
argument_list|,
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
name|msg
argument_list|,
operator|&
name|q
argument_list|,
name|qmp
argument_list|)
expr_stmt|;
name|_moveb
argument_list|(
name|msg
argument_list|,
operator|&
name|r
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|s
operator|=
name|_mtox
argument_list|(
name|msg
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
name|ro
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|MPERR
argument_list|(
operator|(
literal|"%s underflow or overflow"
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
name|msg
argument_list|,
name|dmp
argument_list|)
expr_stmt|;
name|_mfree
argument_list|(
name|msg
argument_list|,
name|rmp
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
operator|&
name|q
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sdiv
parameter_list|(
specifier|const
name|MINT
modifier|*
name|nmp
parameter_list|,
name|short
name|d
parameter_list|,
name|MINT
modifier|*
name|qmp
parameter_list|,
name|short
modifier|*
name|ro
parameter_list|)
block|{
name|_sdiv
argument_list|(
literal|"sdiv"
argument_list|,
name|nmp
argument_list|,
name|d
argument_list|,
name|qmp
argument_list|,
name|ro
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a hexadecimal string to an MINT.  */
end_comment

begin_function
specifier|static
name|MINT
modifier|*
name|_xtom
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|MINT
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|MPERR
argument_list|(
operator|(
literal|"%s"
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|bn
operator|==
name|NULL
condition|)
name|_bnerr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|BN_ERRCHECK
argument_list|(
name|msg
argument_list|,
name|BN_hex2bn
argument_list|(
operator|&
name|mp
operator|->
name|bn
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
block|}
end_function

begin_function
name|MINT
modifier|*
name|xtom
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
return|return
operator|(
name|_xtom
argument_list|(
literal|"xtom"
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

