begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************* 	mach_override.c 		Copyright (c) 2003-2009 Jonathan 'Wolf' Rentzsch:<http://rentzsch.com> 		Some rights reserved:<http://opensource.org/licenses/mit-license.php>  	***************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_include
include|#
directive|include
file|"mach_override.h"
end_include

begin_include
include|#
directive|include
file|<mach-o/dyld.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach_host.h>
end_include

begin_include
include|#
directive|include
file|<mach/mach_init.h>
end_include

begin_include
include|#
directive|include
file|<mach/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<CoreServices/CoreServices.h>
end_include

begin_comment
comment|//#define DEBUG_DISASM 1
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG_DISASM
end_undef

begin_comment
comment|/************************** *	 *	Constants *	 **************************/
end_comment

begin_pragma
pragma|#
directive|pragma
name|mark
name|-
end_pragma

begin_pragma
pragma|#
directive|pragma
name|mark
name|(
name|Constants
name|)
end_pragma

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POWERPC__
argument_list|)
end_if

begin_decl_stmt
name|long
name|kIslandTemplate
index|[]
init|=
block|{
literal|0x9001FFFC
block|,
comment|//	stw		r0,-4(SP)
literal|0x3C00DEAD
block|,
comment|//	lis		r0,0xDEAD
literal|0x6000BEEF
block|,
comment|//	ori		r0,r0,0xBEEF
literal|0x7C0903A6
block|,
comment|//	mtctr	r0
literal|0x8001FFFC
block|,
comment|//	lwz		r0,-4(SP)
literal|0x60000000
block|,
comment|//	nop		; optionally replaced
literal|0x4E800420
comment|//	bctr
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|kAddressHi
value|3
end_define

begin_define
define|#
directive|define
name|kAddressLo
value|5
end_define

begin_define
define|#
directive|define
name|kInstructionHi
value|10
end_define

begin_define
define|#
directive|define
name|kInstructionLo
value|11
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|kOriginalInstructionsSize
value|16
end_define

begin_decl_stmt
name|char
name|kIslandTemplate
index|[]
init|=
block|{
comment|// kOriginalInstructionsSize nop instructions so that we
comment|// should have enough space to host original instructions
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
comment|// Now the real jump instruction
literal|0xE9
block|,
literal|0xEF
block|,
literal|0xBE
block|,
literal|0xAD
block|,
literal|0xDE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|kInstructions
value|0
end_define

begin_define
define|#
directive|define
name|kJumpAddress
value|kInstructions + kOriginalInstructionsSize + 1
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|kOriginalInstructionsSize
value|32
end_define

begin_define
define|#
directive|define
name|kJumpAddress
value|kOriginalInstructionsSize + 6
end_define

begin_decl_stmt
name|char
name|kIslandTemplate
index|[]
init|=
block|{
comment|// kOriginalInstructionsSize nop instructions so that we
comment|// should have enough space to host original instructions
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x90
block|,
comment|// Now the real jump instruction
literal|0xFF
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|kAllocateHigh
value|1
end_define

begin_define
define|#
directive|define
name|kAllocateNormal
value|0
end_define

begin_comment
comment|/************************** *	 *	Data Types *	 **************************/
end_comment

begin_pragma
pragma|#
directive|pragma
name|mark
name|-
end_pragma

begin_pragma
pragma|#
directive|pragma
name|mark
name|(
name|Data
name|Types
name|)
end_pragma

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|instructions
index|[
sizeof|sizeof
argument_list|(
name|kIslandTemplate
argument_list|)
index|]
decl_stmt|;
name|int
name|allocatedHigh
decl_stmt|;
block|}
name|BranchIsland
typedef|;
end_typedef

begin_comment
comment|/************************** *	 *	Funky Protos *	 **************************/
end_comment

begin_pragma
pragma|#
directive|pragma
name|mark
name|-
end_pragma

begin_pragma
pragma|#
directive|pragma
name|mark
name|(
name|Funky
name|Protos
name|)
end_pragma

begin_function_decl
name|mach_error_t
name|allocateBranchIsland
parameter_list|(
name|BranchIsland
modifier|*
modifier|*
name|island
parameter_list|,
name|int
name|allocateHigh
parameter_list|,
name|void
modifier|*
name|originalFunctionAddress
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|mach_error_t
name|freeBranchIsland
parameter_list|(
name|BranchIsland
modifier|*
name|island
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|mach_error_t
name|defaultIslandMalloc
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
name|unused_size
parameter_list|,
name|void
modifier|*
name|hint
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|mach_error_t
name|defaultIslandFree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POWERPC__
argument_list|)
end_if

begin_function_decl
name|mach_error_t
name|setBranchIslandTarget
parameter_list|(
name|BranchIsland
modifier|*
name|island
parameter_list|,
specifier|const
name|void
modifier|*
name|branchTo
parameter_list|,
name|long
name|instruction
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_if

begin_function_decl
name|mach_error_t
name|setBranchIslandTarget_i386
parameter_list|(
name|BranchIsland
modifier|*
name|island
parameter_list|,
specifier|const
name|void
modifier|*
name|branchTo
parameter_list|,
name|char
modifier|*
name|instructions
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|atomic_mov64
parameter_list|(
name|uint64_t
modifier|*
name|targetAddress
parameter_list|,
name|uint64_t
name|value
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|Boolean
name|eatKnownInstructions
parameter_list|(
name|unsigned
name|char
modifier|*
name|code
parameter_list|,
name|uint64_t
modifier|*
name|newInstruction
parameter_list|,
name|int
modifier|*
name|howManyEaten
parameter_list|,
name|char
modifier|*
name|originalInstructions
parameter_list|,
name|int
modifier|*
name|originalInstructionCount
parameter_list|,
name|uint8_t
modifier|*
name|originalInstructionSizes
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|fixupInstructions
parameter_list|(
name|void
modifier|*
name|originalFunction
parameter_list|,
name|void
modifier|*
name|escapeIsland
parameter_list|,
name|void
modifier|*
name|instructionsToFix
parameter_list|,
name|int
name|instructionCount
parameter_list|,
name|uint8_t
modifier|*
name|instructionSizes
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(visibility
parameter_list|(
function_decl|"hidden"
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_DISASM
end_ifdef

begin_function_decl
specifier|static
name|void
name|dump16Bytes
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// DEBUG_DISASM
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************* *	 *	Interface *	 *******************************************************************************/
end_comment

begin_pragma
pragma|#
directive|pragma
name|mark
name|-
end_pragma

begin_pragma
pragma|#
directive|pragma
name|mark
name|(
name|Interface
name|)
end_pragma

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_if

begin_function
name|mach_error_t
name|makeIslandExecutable
parameter_list|(
name|void
modifier|*
name|address
parameter_list|)
block|{
name|mach_error_t
name|err
init|=
name|err_none
decl_stmt|;
name|vm_size_t
name|pageSize
decl_stmt|;
name|host_page_size
argument_list|(
name|mach_host_self
argument_list|()
argument_list|,
operator|&
name|pageSize
argument_list|)
expr_stmt|;
name|uintptr_t
name|page
init|=
operator|(
name|uintptr_t
operator|)
name|address
operator|&
operator|~
call|(
name|uintptr_t
call|)
argument_list|(
name|pageSize
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|err_none
decl_stmt|;
name|e
operator||=
name|mprotect
argument_list|(
operator|(
name|void
operator|*
operator|)
name|page
argument_list|,
name|pageSize
argument_list|,
name|PROT_EXEC
operator||
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|)
expr_stmt|;
name|e
operator||=
name|msync
argument_list|(
operator|(
name|void
operator|*
operator|)
name|page
argument_list|,
name|pageSize
argument_list|,
name|MS_INVALIDATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|err
operator|=
name|err_cannot_override
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|mach_error_t
name|defaultIslandMalloc
parameter_list|(
name|void
modifier|*
modifier|*
name|ptr
parameter_list|,
name|size_t
name|unused_size
parameter_list|,
name|void
modifier|*
name|hint
parameter_list|)
block|{
return|return
name|allocateBranchIsland
argument_list|(
operator|(
name|BranchIsland
operator|*
operator|*
operator|)
name|ptr
argument_list|,
name|kAllocateHigh
argument_list|,
name|hint
argument_list|)
return|;
block|}
end_function

begin_function
name|mach_error_t
name|defaultIslandFree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|freeBranchIsland
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|mach_error_t
name|__asan_mach_override_ptr
parameter_list|(
name|void
modifier|*
name|originalFunctionAddress
parameter_list|,
specifier|const
name|void
modifier|*
name|overrideFunctionAddress
parameter_list|,
name|void
modifier|*
modifier|*
name|originalFunctionReentryIsland
parameter_list|)
block|{
return|return
name|__asan_mach_override_ptr_custom
argument_list|(
name|originalFunctionAddress
argument_list|,
name|overrideFunctionAddress
argument_list|,
name|originalFunctionReentryIsland
argument_list|,
name|defaultIslandMalloc
argument_list|,
name|defaultIslandFree
argument_list|)
return|;
block|}
end_function

begin_function
name|mach_error_t
name|__asan_mach_override_ptr_custom
parameter_list|(
name|void
modifier|*
name|originalFunctionAddress
parameter_list|,
specifier|const
name|void
modifier|*
name|overrideFunctionAddress
parameter_list|,
name|void
modifier|*
modifier|*
name|originalFunctionReentryIsland
parameter_list|,
name|island_malloc
modifier|*
name|alloc
parameter_list|,
name|island_free
modifier|*
name|dealloc
parameter_list|)
block|{
name|assert
argument_list|(
name|originalFunctionAddress
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|overrideFunctionAddress
argument_list|)
expr_stmt|;
comment|// this addresses overriding such functions as AudioOutputUnitStart()
comment|// test with modified DefaultOutputUnit project
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|originalFunctionAddress
operator|==
literal|0x25FF
condition|)
comment|// jmp qword near [rip+0x????????]
name|originalFunctionAddress
operator|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|originalFunctionAddress
operator|+
literal|6
operator|+
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|originalFunctionAddress
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
else|else
break|break;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|originalFunctionAddress
operator|==
literal|0x25FF
condition|)
comment|// jmp *0x????????
name|originalFunctionAddress
operator|=
operator|*
operator|*
operator|(
name|void
operator|*
operator|*
operator|*
operator|)
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|originalFunctionAddress
operator|+
literal|1
operator|)
expr_stmt|;
else|else
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG_DISASM
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Replacing function at %p\n"
argument_list|,
name|originalFunctionAddress
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"First 16 bytes of the function: "
argument_list|)
expr_stmt|;
name|unsigned
name|char
modifier|*
name|orig
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|originalFunctionAddress
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|orig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"To disassemble, save the following function as disas.c"
literal|" and run:\n  gcc -c disas.c&& gobjdump -d disas.o\n"
literal|"The first 16 bytes of the original function will start"
literal|" after four nop instructions.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nvoid foo() {\n  asm volatile(\"nop;nop;nop;nop;\");\n"
argument_list|)
expr_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  asm volatile(\".byte "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
operator|*
name|j
init|;
name|i
operator|<
literal|8
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%x, "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|orig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%x;\");\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|orig
index|[
literal|8
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|long
modifier|*
name|originalFunctionPtr
init|=
operator|(
name|long
operator|*
operator|)
name|originalFunctionAddress
decl_stmt|;
name|mach_error_t
name|err
init|=
name|err_none
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POWERPC__
argument_list|)
comment|//	Ensure first instruction isn't 'mfctr'.
define|#
directive|define
name|kMFCTRMask
value|0xfc1fffff
define|#
directive|define
name|kMFCTRInstruction
value|0x7c0903a6
name|long
name|originalInstruction
init|=
operator|*
name|originalFunctionPtr
decl_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
operator|(
name|originalInstruction
operator|&
name|kMFCTRMask
operator|)
operator|==
name|kMFCTRInstruction
operator|)
condition|)
name|err
operator|=
name|err_cannot_override
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
name|int
name|eatenCount
init|=
literal|0
decl_stmt|;
name|int
name|originalInstructionCount
init|=
literal|0
decl_stmt|;
name|char
name|originalInstructions
index|[
name|kOriginalInstructionsSize
index|]
decl_stmt|;
name|uint8_t
name|originalInstructionSizes
index|[
name|kOriginalInstructionsSize
index|]
decl_stmt|;
name|uint64_t
name|jumpRelativeInstruction
init|=
literal|0
decl_stmt|;
comment|// JMP
name|Boolean
name|overridePossible
init|=
name|eatKnownInstructions
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|originalFunctionPtr
argument_list|,
operator|&
name|jumpRelativeInstruction
argument_list|,
operator|&
name|eatenCount
argument_list|,
name|originalInstructions
argument_list|,
operator|&
name|originalInstructionCount
argument_list|,
name|originalInstructionSizes
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DISASM
if|if
condition|(
operator|!
name|overridePossible
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"overridePossible = false @%d\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|eatenCount
operator|>
name|kOriginalInstructionsSize
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_DISASM
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many instructions eaten\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|overridePossible
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|overridePossible
condition|)
name|err
operator|=
name|err_cannot_override
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"err = %x %s:%d\n"
argument_list|,
name|err
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//	Make the original function implementation writable.
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|vm_protect
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|originalFunctionPtr
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
operator|(
name|VM_PROT_ALL
operator||
name|VM_PROT_COPY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|err
operator|=
name|vm_protect
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|originalFunctionPtr
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
operator|(
name|VM_PROT_DEFAULT
operator||
name|VM_PROT_COPY
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"err = %x %s:%d\n"
argument_list|,
name|err
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|//	Allocate and target the escape island to the overriding function.
name|BranchIsland
modifier|*
name|escapeIsland
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|alloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|escapeIsland
argument_list|,
sizeof|sizeof
argument_list|(
name|BranchIsland
argument_list|)
argument_list|,
name|originalFunctionAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"err = %x %s:%d\n"
argument_list|,
name|err
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POWERPC__
argument_list|)
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|setBranchIslandTarget
argument_list|(
name|escapeIsland
argument_list|,
name|overrideFunctionAddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//	Build the branch absolute instruction to the escape island.
name|long
name|branchAbsoluteInstruction
init|=
literal|0
decl_stmt|;
comment|// Set to 0 just to silence warning.
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|long
name|escapeIslandAddress
init|=
operator|(
operator|(
name|long
operator|)
name|escapeIsland
operator|)
operator|&
literal|0x3FFFFFF
decl_stmt|;
name|branchAbsoluteInstruction
operator|=
literal|0x48000002
operator||
name|escapeIslandAddress
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
if|if
condition|(
name|err
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"err = %x %s:%d\n"
argument_list|,
name|err
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|setBranchIslandTarget_i386
argument_list|(
name|escapeIsland
argument_list|,
name|overrideFunctionAddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"err = %x %s:%d\n"
argument_list|,
name|err
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|// Build the jump relative instruction to the escape island
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|uint32_t
name|addressOffset
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|escapeIsland
operator|-
operator|(
name|char
operator|*
operator|)
name|originalFunctionPtr
operator|-
literal|5
operator|)
decl_stmt|;
name|addressOffset
operator|=
name|OSSwapInt32
argument_list|(
name|addressOffset
argument_list|)
expr_stmt|;
name|jumpRelativeInstruction
operator||=
literal|0xE900000000000000LL
expr_stmt|;
name|jumpRelativeInstruction
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|addressOffset
operator|&
literal|0xffffffff
operator|)
operator|<<
literal|24
expr_stmt|;
name|jumpRelativeInstruction
operator|=
name|OSSwapInt64
argument_list|(
name|jumpRelativeInstruction
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//	Optionally allocate& return the reentry island. This may contain relocated
comment|//  jmp instructions and so has all the same addressing reachability requirements
comment|//  the escape island has to the original function, except the escape island is
comment|//  technically our original function.
name|BranchIsland
modifier|*
name|reentryIsland
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|originalFunctionReentryIsland
condition|)
block|{
name|err
operator|=
name|alloc
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|reentryIsland
argument_list|,
sizeof|sizeof
argument_list|(
name|BranchIsland
argument_list|)
argument_list|,
name|escapeIsland
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|originalFunctionReentryIsland
operator|=
name|reentryIsland
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POWERPC__
argument_list|)
comment|//	Atomically:
comment|//	o If the reentry island was allocated:
comment|//		o Insert the original instruction into the reentry island.
comment|//		o Target the reentry island at the 2nd instruction of the
comment|//		  original function.
comment|//	o Replace the original instruction with the branch absolute.
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|int
name|escapeIslandEngaged
init|=
name|false
decl_stmt|;
do|do
block|{
if|if
condition|(
name|reentryIsland
condition|)
name|err
operator|=
name|setBranchIslandTarget
argument_list|(
name|reentryIsland
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|originalFunctionPtr
operator|+
literal|1
operator|)
argument_list|,
name|originalInstruction
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|escapeIslandEngaged
operator|=
name|CompareAndSwap
argument_list|(
name|originalInstruction
argument_list|,
name|branchAbsoluteInstruction
argument_list|,
operator|(
name|UInt32
operator|*
operator|)
name|originalFunctionPtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|escapeIslandEngaged
condition|)
block|{
comment|//	Someone replaced the instruction out from under us,
comment|//	re-read the instruction, make sure it's still not
comment|//	'mfctr' and try again.
name|originalInstruction
operator|=
operator|*
name|originalFunctionPtr
expr_stmt|;
if|if
condition|(
operator|(
name|originalInstruction
operator|&
name|kMFCTRMask
operator|)
operator|==
name|kMFCTRInstruction
condition|)
name|err
operator|=
name|err_cannot_override
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|err
operator|&&
operator|!
name|escapeIslandEngaged
condition|)
do|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
comment|// Atomically:
comment|//	o If the reentry island was allocated:
comment|//		o Insert the original instructions into the reentry island.
comment|//		o Target the reentry island at the first non-replaced
comment|//        instruction of the original function.
comment|//	o Replace the original first instructions with the jump relative.
comment|//
comment|// Note that on i386, we do not support someone else changing the code under our feet
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|fixupInstructions
argument_list|(
name|originalFunctionPtr
argument_list|,
name|reentryIsland
argument_list|,
name|originalInstructions
argument_list|,
name|originalInstructionCount
argument_list|,
name|originalInstructionSizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|reentryIsland
condition|)
name|err
operator|=
name|setBranchIslandTarget_i386
argument_list|(
name|reentryIsland
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|originalFunctionPtr
operator|+
name|eatenCount
operator|)
argument_list|,
name|originalInstructions
argument_list|)
expr_stmt|;
comment|// try making islands executable before planting the jmp
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|makeIslandExecutable
argument_list|(
name|escapeIsland
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|reentryIsland
condition|)
name|err
operator|=
name|makeIslandExecutable
argument_list|(
name|reentryIsland
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|err
condition|)
name|atomic_mov64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|originalFunctionPtr
argument_list|,
name|jumpRelativeInstruction
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|//	Clean up on error.
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|reentryIsland
condition|)
name|dealloc
argument_list|(
name|reentryIsland
argument_list|)
expr_stmt|;
if|if
condition|(
name|escapeIsland
condition|)
name|dealloc
argument_list|(
name|escapeIsland
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_DISASM
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"First 16 bytes of the function after slicing: "
argument_list|)
expr_stmt|;
name|unsigned
name|char
modifier|*
name|orig
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|originalFunctionAddress
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|orig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************* *	 *	Implementation *	 *******************************************************************************/
end_comment

begin_pragma
pragma|#
directive|pragma
name|mark
name|-
end_pragma

begin_pragma
pragma|#
directive|pragma
name|mark
name|(
name|Implementation
name|)
end_pragma

begin_comment
comment|/***************************************************************************/
end_comment

begin_comment
comment|/** 	Implementation: Allocates memory for a branch island. 	 	@param	island<-	The allocated island. 	@param	allocateHigh	->	Whether to allocate the island at the end of the 								address space (for use with the branch absolute 								instruction). 	@result<-	mach_error_t  	***************************************************************************/
end_comment

begin_function
name|mach_error_t
name|allocateBranchIsland
parameter_list|(
name|BranchIsland
modifier|*
modifier|*
name|island
parameter_list|,
name|int
name|allocateHigh
parameter_list|,
name|void
modifier|*
name|originalFunctionAddress
parameter_list|)
block|{
name|assert
argument_list|(
name|island
argument_list|)
expr_stmt|;
name|mach_error_t
name|err
init|=
name|err_none
decl_stmt|;
if|if
condition|(
name|allocateHigh
condition|)
block|{
name|vm_size_t
name|pageSize
decl_stmt|;
name|err
operator|=
name|host_page_size
argument_list|(
name|mach_host_self
argument_list|()
argument_list|,
operator|&
name|pageSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|BranchIsland
argument_list|)
operator|<=
name|pageSize
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POWERPC__
argument_list|)
name|vm_address_t
name|first
init|=
literal|0xfeffffff
decl_stmt|;
name|vm_address_t
name|last
init|=
literal|0xfe000000
operator|+
name|pageSize
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64__
argument_list|)
name|vm_address_t
name|first
init|=
operator|(
operator|(
name|uint64_t
operator|)
name|originalFunctionAddress
operator|&
operator|~
call|(
name|uint64_t
call|)
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|31
operator|)
operator|-
literal|1
argument_list|)
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|31
operator|)
decl_stmt|;
comment|// start in the middle of the page?
name|vm_address_t
name|last
init|=
literal|0x0
decl_stmt|;
else|#
directive|else
name|vm_address_t
name|first
init|=
literal|0xffc00000
decl_stmt|;
name|vm_address_t
name|last
init|=
literal|0xfffe0000
decl_stmt|;
endif|#
directive|endif
name|vm_address_t
name|page
init|=
name|first
decl_stmt|;
name|int
name|allocated
init|=
literal|0
decl_stmt|;
name|vm_map_t
name|task_self
init|=
name|mach_task_self
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|err
operator|&&
operator|!
name|allocated
operator|&&
name|page
operator|!=
name|last
condition|)
block|{
name|err
operator|=
name|vm_allocate
argument_list|(
name|task_self
argument_list|,
operator|&
name|page
argument_list|,
name|pageSize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|err_none
condition|)
name|allocated
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|KERN_NO_SPACE
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
name|page
operator|-=
name|pageSize
expr_stmt|;
else|#
directive|else
name|page
operator|+=
name|pageSize
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|err_none
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allocated
condition|)
operator|*
name|island
operator|=
operator|(
name|BranchIsland
operator|*
operator|)
name|page
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|allocated
operator|&&
operator|!
name|err
condition|)
name|err
operator|=
name|KERN_NO_SPACE
expr_stmt|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|block
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BranchIsland
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
condition|)
operator|*
name|island
operator|=
name|block
expr_stmt|;
else|else
name|err
operator|=
name|KERN_NO_SPACE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
operator|(
operator|*
operator|*
name|island
operator|)
operator|.
name|allocatedHigh
operator|=
name|allocateHigh
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************/
end_comment

begin_comment
comment|/** 	Implementation: Deallocates memory for a branch island. 	 	@param	island	->	The island to deallocate. 	@result<-	mach_error_t  	***************************************************************************/
end_comment

begin_function
name|mach_error_t
name|freeBranchIsland
parameter_list|(
name|BranchIsland
modifier|*
name|island
parameter_list|)
block|{
name|assert
argument_list|(
name|island
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|island
operator|->
name|instructions
index|[
literal|0
index|]
operator|)
operator|==
name|kIslandTemplate
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|island
operator|->
name|allocatedHigh
argument_list|)
expr_stmt|;
name|mach_error_t
name|err
init|=
name|err_none
decl_stmt|;
if|if
condition|(
name|island
operator|->
name|allocatedHigh
condition|)
block|{
name|vm_size_t
name|pageSize
decl_stmt|;
name|err
operator|=
name|host_page_size
argument_list|(
name|mach_host_self
argument_list|()
argument_list|,
operator|&
name|pageSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|BranchIsland
argument_list|)
operator|<=
name|pageSize
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm_deallocate
argument_list|(
name|mach_task_self
argument_list|()
argument_list|,
operator|(
name|vm_address_t
operator|)
name|island
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|island
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/***************************************************************************/
end_comment

begin_comment
comment|/** 	Implementation: Sets the branch island's target, with an optional 	instruction. 	 	@param	island		->	The branch island to insert target into. 	@param	branchTo	->	The address of the target. 	@param	instruction	->	Optional instruction to execute prior to branch. Set 							to zero for nop. 	@result<-	mach_error_t  	***************************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ppc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__POWERPC__
argument_list|)
end_if

begin_function
name|mach_error_t
name|setBranchIslandTarget
parameter_list|(
name|BranchIsland
modifier|*
name|island
parameter_list|,
specifier|const
name|void
modifier|*
name|branchTo
parameter_list|,
name|long
name|instruction
parameter_list|)
block|{
comment|//	Copy over the template code.
name|bcopy
argument_list|(
name|kIslandTemplate
argument_list|,
name|island
operator|->
name|instructions
argument_list|,
sizeof|sizeof
argument_list|(
name|kIslandTemplate
argument_list|)
argument_list|)
expr_stmt|;
comment|//	Fill in the address.
operator|(
operator|(
name|short
operator|*
operator|)
name|island
operator|->
name|instructions
operator|)
index|[
name|kAddressLo
index|]
operator|=
operator|(
operator|(
name|long
operator|)
name|branchTo
operator|)
operator|&
literal|0x0000FFFF
expr_stmt|;
operator|(
operator|(
name|short
operator|*
operator|)
name|island
operator|->
name|instructions
operator|)
index|[
name|kAddressHi
index|]
operator|=
operator|(
operator|(
operator|(
name|long
operator|)
name|branchTo
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0x0000FFFF
expr_stmt|;
comment|//	Fill in the (optional) instuction.
if|if
condition|(
name|instruction
operator|!=
literal|0
condition|)
block|{
operator|(
operator|(
name|short
operator|*
operator|)
name|island
operator|->
name|instructions
operator|)
index|[
name|kInstructionLo
index|]
operator|=
name|instruction
operator|&
literal|0x0000FFFF
expr_stmt|;
operator|(
operator|(
name|short
operator|*
operator|)
name|island
operator|->
name|instructions
operator|)
index|[
name|kInstructionHi
index|]
operator|=
operator|(
name|instruction
operator|>>
literal|16
operator|)
operator|&
literal|0x0000FFFF
expr_stmt|;
block|}
comment|//MakeDataExecutable( island->instructions, sizeof( kIslandTemplate ) );
name|msync
argument_list|(
name|island
operator|->
name|instructions
argument_list|,
sizeof|sizeof
argument_list|(
name|kIslandTemplate
argument_list|)
argument_list|,
name|MS_INVALIDATE
argument_list|)
expr_stmt|;
return|return
name|err_none
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_function
name|mach_error_t
name|setBranchIslandTarget_i386
parameter_list|(
name|BranchIsland
modifier|*
name|island
parameter_list|,
specifier|const
name|void
modifier|*
name|branchTo
parameter_list|,
name|char
modifier|*
name|instructions
parameter_list|)
block|{
comment|//	Copy over the template code.
name|bcopy
argument_list|(
name|kIslandTemplate
argument_list|,
name|island
operator|->
name|instructions
argument_list|,
sizeof|sizeof
argument_list|(
name|kIslandTemplate
argument_list|)
argument_list|)
expr_stmt|;
comment|// copy original instructions
if|if
condition|(
name|instructions
condition|)
block|{
name|bcopy
argument_list|(
name|instructions
argument_list|,
name|island
operator|->
name|instructions
operator|+
name|kInstructions
argument_list|,
name|kOriginalInstructionsSize
argument_list|)
expr_stmt|;
block|}
comment|// Fill in the address.
name|int32_t
name|addressOffset
init|=
operator|(
name|char
operator|*
operator|)
name|branchTo
operator|-
operator|(
name|island
operator|->
name|instructions
operator|+
name|kJumpAddress
operator|+
literal|4
operator|)
decl_stmt|;
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|island
operator|->
name|instructions
operator|+
name|kJumpAddress
operator|)
operator|)
operator|=
name|addressOffset
expr_stmt|;
name|msync
argument_list|(
name|island
operator|->
name|instructions
argument_list|,
sizeof|sizeof
argument_list|(
name|kIslandTemplate
argument_list|)
argument_list|,
name|MS_INVALIDATE
argument_list|)
expr_stmt|;
return|return
name|err_none
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_elif

begin_function
name|mach_error_t
name|setBranchIslandTarget_i386
parameter_list|(
name|BranchIsland
modifier|*
name|island
parameter_list|,
specifier|const
name|void
modifier|*
name|branchTo
parameter_list|,
name|char
modifier|*
name|instructions
parameter_list|)
block|{
comment|// Copy over the template code.
name|bcopy
argument_list|(
name|kIslandTemplate
argument_list|,
name|island
operator|->
name|instructions
argument_list|,
sizeof|sizeof
argument_list|(
name|kIslandTemplate
argument_list|)
argument_list|)
expr_stmt|;
comment|// Copy original instructions.
if|if
condition|(
name|instructions
condition|)
block|{
name|bcopy
argument_list|(
name|instructions
argument_list|,
name|island
operator|->
name|instructions
argument_list|,
name|kOriginalInstructionsSize
argument_list|)
expr_stmt|;
block|}
comment|//	Fill in the address.
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|island
operator|->
name|instructions
operator|+
name|kJumpAddress
operator|)
operator|)
operator|=
operator|(
name|uint64_t
operator|)
name|branchTo
expr_stmt|;
name|msync
argument_list|(
name|island
operator|->
name|instructions
argument_list|,
sizeof|sizeof
argument_list|(
name|kIslandTemplate
argument_list|)
argument_list|,
name|MS_INVALIDATE
argument_list|)
expr_stmt|;
return|return
name|err_none
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_if

begin_comment
comment|// simplistic instruction matching
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|// max 15
name|unsigned
name|char
name|mask
index|[
literal|15
index|]
decl_stmt|;
comment|// sequence of bytes in memory order
name|unsigned
name|char
name|constraint
index|[
literal|15
index|]
decl_stmt|;
comment|// sequence of bytes in memory order
block|}
name|AsmInstructionMatch
typedef|;
end_typedef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|AsmInstructionMatch
name|possibleInstructions
index|[]
init|=
block|{
block|{
literal|0x5
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0xE9
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// jmp 0x????????
block|{
literal|0x5
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x55
block|,
literal|0x89
block|,
literal|0xe5
block|,
literal|0xc9
block|,
literal|0xc3
block|}
block|}
block|,
comment|// push %esp; mov %esp,%ebp; leave; ret
block|{
literal|0x1
block|,
block|{
literal|0xFF
block|}
block|,
block|{
literal|0x90
block|}
block|}
block|,
comment|// nop
block|{
literal|0x1
block|,
block|{
literal|0xF8
block|}
block|,
block|{
literal|0x50
block|}
block|}
block|,
comment|// push %reg
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x89
block|,
literal|0xE5
block|}
block|}
block|,
comment|// mov %esp,%ebp
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x89
block|,
literal|0x1C
block|,
literal|0x24
block|}
block|}
block|,
comment|// mov %ebx,(%esp)
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x83
block|,
literal|0xEC
block|,
literal|0x00
block|}
block|}
block|,
comment|// sub 0x??, %esp
block|{
literal|0x6
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x81
block|,
literal|0xEC
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// sub 0x??, %esp with 32bit immediate
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x31
block|,
literal|0xC0
block|}
block|}
block|,
comment|// xor %eax, %eax
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0x4F
block|,
literal|0x00
block|}
block|,
block|{
literal|0x8B
block|,
literal|0x45
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm(%ebp), %reg
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0x4C
block|,
literal|0x00
block|}
block|,
block|{
literal|0x8B
block|,
literal|0x40
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm(%eax-%edx), %reg
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xCF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x8B
block|,
literal|0x4D
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm(%rpb), %reg
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0x4F
block|,
literal|0x00
block|}
block|,
block|{
literal|0x8A
block|,
literal|0x4D
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm(%ebp), %cl
block|{
literal|0x4
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x8B
block|,
literal|0x4C
block|,
literal|0x24
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm(%esp), %ecx
block|{
literal|0x4
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x8B
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov r16,r/m16 or r32,r/m32
block|{
literal|0x5
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0xB9
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm, %ecx
block|{
literal|0x5
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0xB8
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm, %eax
block|{
literal|0x4
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x66
block|,
literal|0x0F
block|,
literal|0xEF
block|,
literal|0x00
block|}
block|}
block|,
comment|// pxor xmm2/128, xmm1
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0xDB
block|,
literal|0xE3
block|}
block|}
block|,
comment|// fninit
block|{
literal|0x5
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0xE8
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// call $imm
block|{
literal|0x0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_elif

begin_comment
comment|// TODO(glider): disassembling the "0x48, 0x89" sequences is trickier than it's done below.
end_comment

begin_comment
comment|// If it stops working, refer to http://ref.x86asm.net/geek.html#modrm_byte_32_64 to do it
end_comment

begin_comment
comment|// more accurately.
end_comment

begin_comment
comment|// Note: 0x48 is in fact the REX.W prefix, but it might be wrong to treat it as a separate
end_comment

begin_comment
comment|// instruction.
end_comment

begin_decl_stmt
specifier|static
name|AsmInstructionMatch
name|possibleInstructions
index|[]
init|=
block|{
block|{
literal|0x5
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0xE9
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// jmp 0x????????
block|{
literal|0x1
block|,
block|{
literal|0xFF
block|}
block|,
block|{
literal|0x90
block|}
block|}
block|,
comment|// nop
block|{
literal|0x1
block|,
block|{
literal|0xF8
block|}
block|,
block|{
literal|0x50
block|}
block|}
block|,
comment|// push %rX
block|{
literal|0x1
block|,
block|{
literal|0xFF
block|}
block|,
block|{
literal|0x65
block|}
block|}
block|,
comment|// GS prefix
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x48
block|,
literal|0x89
block|,
literal|0xE5
block|}
block|}
block|,
comment|// mov %rsp,%rbp
block|{
literal|0x4
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x48
block|,
literal|0x83
block|,
literal|0xEC
block|,
literal|0x00
block|}
block|}
block|,
comment|// sub 0x??, %rsp
block|{
literal|0x4
block|,
block|{
literal|0xFB
block|,
literal|0xFF
block|,
literal|0x07
block|,
literal|0x00
block|}
block|,
block|{
literal|0x48
block|,
literal|0x89
block|,
literal|0x05
block|,
literal|0x00
block|}
block|}
block|,
comment|// move onto rbp
block|{
literal|0x3
block|,
block|{
literal|0xFB
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x48
block|,
literal|0x89
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov %reg, %reg
block|{
literal|0x3
block|,
block|{
literal|0xFB
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x49
block|,
literal|0x89
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov %reg, %reg (REX.WB)
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x41
block|,
literal|0x00
block|}
block|}
block|,
comment|// push %rXX
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x85
block|,
literal|0x00
block|}
block|}
block|,
comment|// test %rX,%rX
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x77
block|,
literal|0x00
block|}
block|}
block|,
comment|// ja $i8
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x74
block|,
literal|0x00
block|}
block|}
block|,
comment|// je $i8
block|{
literal|0x5
block|,
block|{
literal|0xF8
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0xB8
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm, %reg
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0xFF
block|,
literal|0x77
block|,
literal|0x00
block|}
block|}
block|,
comment|// pushq $imm(%rdi)
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x31
block|,
literal|0xC0
block|}
block|}
block|,
comment|// xor %eax, %eax
block|{
literal|0x5
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// and $imm, %eax
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x80
block|,
literal|0x3F
block|,
literal|0x00
block|}
block|}
block|,
comment|// cmpb $imm, (%rdi)
block|{
literal|0x8
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xCF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x48
block|,
literal|0x8B
block|,
literal|0x04
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|, }
block|,
comment|// mov $imm, %{rax,rdx,rsp,rsi}
block|{
literal|0x4
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x48
block|,
literal|0x83
block|,
literal|0xFA
block|,
literal|0x00
block|}
block|, }
block|,
comment|// cmp $i8, %rdx
block|{
literal|0x4
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x83
block|,
literal|0x7f
block|,
literal|0x00
block|,
literal|0x00
block|}
block|, }
block|,
comment|// cmpl $imm, $imm(%rdi)
block|{
literal|0xa
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x48
block|,
literal|0xB8
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov $imm, %rax
block|{
literal|0x6
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0x81
block|,
literal|0xE6
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// and $imm, %esi
block|{
literal|0x6
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
block|{
literal|0xFF
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
comment|// jmpq *(%rip)
block|{
literal|0x4
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x66
block|,
literal|0x0F
block|,
literal|0xEF
block|,
literal|0x00
block|}
block|}
block|,
comment|// pxor xmm2/128, xmm1
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x89
block|,
literal|0x00
block|}
block|}
block|,
comment|// mov r/m32,r32 or r/m16,r16
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x49
block|,
literal|0x89
block|,
literal|0xF8
block|}
block|}
block|,
comment|// mov %rdi,%r8
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0xFF
block|,
literal|0x77
block|,
literal|0x00
block|}
block|}
block|,
comment|// pushq $imm(%rdi)
block|{
literal|0x2
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0xDB
block|,
literal|0xE3
block|}
block|}
block|,
comment|// fninit
block|{
literal|0x3
block|,
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
block|,
block|{
literal|0x48
block|,
literal|0x85
block|,
literal|0xD2
block|}
block|}
block|,
comment|// test %rdx,%rdx
block|{
literal|0x0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|Boolean
name|codeMatchesInstruction
parameter_list|(
name|unsigned
name|char
modifier|*
name|code
parameter_list|,
name|AsmInstructionMatch
modifier|*
name|instruction
parameter_list|)
block|{
name|Boolean
name|match
init|=
name|true
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|assert
argument_list|(
name|instruction
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DISASM
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Matching: "
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|instruction
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|mask
init|=
name|instruction
operator|->
name|mask
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|char
name|constraint
init|=
name|instruction
operator|->
name|constraint
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|char
name|codeValue
init|=
name|code
index|[
name|i
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DISASM
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%x "
argument_list|,
operator|(
name|unsigned
operator|)
name|codeValue
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|match
operator|=
operator|(
operator|(
name|codeValue
operator|&
name|mask
operator|)
operator|==
name|constraint
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG_DISASM
if|if
condition|(
name|match
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" OK\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" FAIL\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|match
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_if

begin_function
specifier|static
name|Boolean
name|eatKnownInstructions
parameter_list|(
name|unsigned
name|char
modifier|*
name|code
parameter_list|,
name|uint64_t
modifier|*
name|newInstruction
parameter_list|,
name|int
modifier|*
name|howManyEaten
parameter_list|,
name|char
modifier|*
name|originalInstructions
parameter_list|,
name|int
modifier|*
name|originalInstructionCount
parameter_list|,
name|uint8_t
modifier|*
name|originalInstructionSizes
parameter_list|)
block|{
name|Boolean
name|allInstructionsKnown
init|=
name|true
decl_stmt|;
name|int
name|totalEaten
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
init|=
name|code
decl_stmt|;
name|int
name|remainsToEat
init|=
literal|5
decl_stmt|;
comment|// a JMP instruction takes 5 bytes
name|int
name|instructionIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|howManyEaten
condition|)
operator|*
name|howManyEaten
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|originalInstructionCount
condition|)
operator|*
name|originalInstructionCount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|remainsToEat
operator|>
literal|0
condition|)
block|{
name|Boolean
name|curInstructionKnown
init|=
name|false
decl_stmt|;
comment|// See if instruction matches one  we know
name|AsmInstructionMatch
modifier|*
name|curInstr
init|=
name|possibleInstructions
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|curInstructionKnown
operator|=
name|codeMatchesInstruction
argument_list|(
name|ptr
argument_list|,
name|curInstr
argument_list|)
operator|)
condition|)
break|break;
name|curInstr
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|curInstr
operator|->
name|length
operator|>
literal|0
condition|)
do|;
comment|// if all instruction matches failed, we don't know current instruction then, stop here
if|if
condition|(
operator|!
name|curInstructionKnown
condition|)
block|{
name|allInstructionsKnown
operator|=
name|false
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mach_override: some instructions unknown! Need to update mach_override.c\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// At this point, we've matched curInstr
name|int
name|eaten
init|=
name|curInstr
operator|->
name|length
decl_stmt|;
name|ptr
operator|+=
name|eaten
expr_stmt|;
name|remainsToEat
operator|-=
name|eaten
expr_stmt|;
name|totalEaten
operator|+=
name|eaten
expr_stmt|;
if|if
condition|(
name|originalInstructionSizes
condition|)
name|originalInstructionSizes
index|[
name|instructionIndex
index|]
operator|=
name|eaten
expr_stmt|;
name|instructionIndex
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|originalInstructionCount
condition|)
operator|*
name|originalInstructionCount
operator|=
name|instructionIndex
expr_stmt|;
block|}
if|if
condition|(
name|howManyEaten
condition|)
operator|*
name|howManyEaten
operator|=
name|totalEaten
expr_stmt|;
if|if
condition|(
name|originalInstructions
condition|)
block|{
name|Boolean
name|enoughSpaceForOriginalInstructions
init|=
operator|(
name|totalEaten
operator|<
name|kOriginalInstructionsSize
operator|)
decl_stmt|;
if|if
condition|(
name|enoughSpaceForOriginalInstructions
condition|)
block|{
name|memset
argument_list|(
name|originalInstructions
argument_list|,
literal|0x90
comment|/* NOP */
argument_list|,
name|kOriginalInstructionsSize
argument_list|)
expr_stmt|;
comment|// fill instructions with NOP
name|bcopy
argument_list|(
name|code
argument_list|,
name|originalInstructions
argument_list|,
name|totalEaten
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_DISASM
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not enough space in island to store original instructions. Adapt the island definition and kOriginalInstructionsSize\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|allInstructionsKnown
condition|)
block|{
comment|// save last 3 bytes of first 64bits of codre we'll replace
name|uint64_t
name|currentFirst64BitsOfCode
init|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|code
operator|)
decl_stmt|;
name|currentFirst64BitsOfCode
operator|=
name|OSSwapInt64
argument_list|(
name|currentFirst64BitsOfCode
argument_list|)
expr_stmt|;
comment|// back to memory representation
name|currentFirst64BitsOfCode
operator|&=
literal|0x0000000000FFFFFFLL
expr_stmt|;
comment|// keep only last 3 instructions bytes, first 5 will be replaced by JMP instr
operator|*
name|newInstruction
operator|&=
literal|0xFFFFFFFFFF000000LL
expr_stmt|;
comment|// clear last 3 bytes
operator|*
name|newInstruction
operator||=
operator|(
name|currentFirst64BitsOfCode
operator|&
literal|0x0000000000FFFFFFLL
operator|)
expr_stmt|;
comment|// set last 3 bytes
block|}
return|return
name|allInstructionsKnown
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fixupInstructions
parameter_list|(
name|void
modifier|*
name|originalFunction
parameter_list|,
name|void
modifier|*
name|escapeIsland
parameter_list|,
name|void
modifier|*
name|instructionsToFix
parameter_list|,
name|int
name|instructionCount
parameter_list|,
name|uint8_t
modifier|*
name|instructionSizes
parameter_list|)
block|{
name|void
modifier|*
name|initialOriginalFunction
init|=
name|originalFunction
decl_stmt|;
name|int
name|index
decl_stmt|,
name|fixed_size
decl_stmt|,
name|code_size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|instructionCount
condition|;
name|index
operator|+=
literal|1
control|)
name|code_size
operator|+=
name|instructionSizes
index|[
name|index
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_DISASM
name|void
modifier|*
name|initialInstructionsToFix
init|=
name|instructionsToFix
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BEFORE FIXING:\n"
argument_list|)
expr_stmt|;
name|dump16Bytes
argument_list|(
name|initialOriginalFunction
argument_list|)
expr_stmt|;
name|dump16Bytes
argument_list|(
name|initialInstructionsToFix
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// DEBUG_DISASM
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|instructionCount
condition|;
name|index
operator|+=
literal|1
control|)
block|{
name|fixed_size
operator|=
name|instructionSizes
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|instructionsToFix
operator|==
literal|0xE9
operator|)
operator|||
comment|// 32-bit jump relative
operator|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|instructionsToFix
operator|==
literal|0xE8
operator|)
condition|)
comment|// 32-bit call relative
block|{
name|uint32_t
name|offset
init|=
operator|(
name|uintptr_t
operator|)
name|originalFunction
operator|-
operator|(
name|uintptr_t
operator|)
name|escapeIsland
decl_stmt|;
name|uint32_t
modifier|*
name|jumpOffsetPtr
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|instructionsToFix
operator|+
literal|1
operator|)
decl_stmt|;
operator|*
name|jumpOffsetPtr
operator|+=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|instructionsToFix
operator|==
literal|0x74
operator|)
operator|||
comment|// Near jump if equal (je), 2 bytes.
operator|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|instructionsToFix
operator|==
literal|0x77
operator|)
condition|)
comment|// Near jump if above (ja), 2 bytes.
block|{
comment|// We replace a near je/ja instruction, "7P JJ", with a 32-bit je/ja, "0F 8P WW XX YY ZZ".
comment|// This is critical, otherwise a near jump will likely fall outside the original function.
name|uint32_t
name|offset
init|=
operator|(
name|uintptr_t
operator|)
name|initialOriginalFunction
operator|-
operator|(
name|uintptr_t
operator|)
name|escapeIsland
decl_stmt|;
name|uint32_t
name|jumpOffset
init|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|instructionsToFix
operator|+
literal|1
operator|)
decl_stmt|;
operator|*
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|instructionsToFix
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|instructionsToFix
operator|+
literal|0x10
expr_stmt|;
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|instructionsToFix
operator|=
literal|0x0F
expr_stmt|;
name|uint32_t
modifier|*
name|jumpOffsetPtr
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|instructionsToFix
operator|+
literal|2
operator|)
decl_stmt|;
operator|*
name|jumpOffsetPtr
operator|=
name|offset
operator|+
name|jumpOffset
expr_stmt|;
name|fixed_size
operator|=
literal|6
expr_stmt|;
block|}
name|originalFunction
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|originalFunction
operator|+
name|instructionSizes
index|[
name|index
index|]
operator|)
expr_stmt|;
name|escapeIsland
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|escapeIsland
operator|+
name|instructionSizes
index|[
name|index
index|]
operator|)
expr_stmt|;
name|instructionsToFix
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|instructionsToFix
operator|+
name|fixed_size
operator|)
expr_stmt|;
comment|// Expanding short instructions into longer ones may overwrite the next instructions,
comment|// so we must restore them.
name|code_size
operator|-=
name|fixed_size
expr_stmt|;
if|if
condition|(
operator|(
name|code_size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|fixed_size
operator|!=
name|instructionSizes
index|[
name|index
index|]
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|originalFunction
argument_list|,
name|instructionsToFix
argument_list|,
name|code_size
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG_DISASM
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"AFTER_FIXING:\n"
argument_list|)
expr_stmt|;
name|dump16Bytes
argument_list|(
name|initialOriginalFunction
argument_list|)
expr_stmt|;
name|dump16Bytes
argument_list|(
name|initialInstructionsToFix
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// DEBUG_DISASM
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_DISASM
end_ifdef

begin_define
define|#
directive|define
name|HEX_DIGIT
parameter_list|(
name|x
parameter_list|)
value|((((x) % 16)< 10) ? ('0' + ((x) % 16)) : ('A' + ((x) % 16 - 10)))
end_define

begin_function
specifier|static
name|void
name|dump16Bytes
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|bytes
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|HEX_DIGIT
argument_list|(
name|bytes
index|[
name|i
index|]
operator|/
literal|16
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|HEX_DIGIT
argument_list|(
name|bytes
index|[
name|i
index|]
operator|%
literal|16
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// DEBUG_DISASM
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_asm
asm|__asm(
end_asm

begin_expr_stmt
literal|".text;"
literal|".align 2, 0x90;"
literal|"_atomic_mov64:;"
literal|"	pushl %ebp;"
literal|"	movl %esp, %ebp;"
literal|"	pushl %esi;"
literal|"	pushl %ebx;"
literal|"	pushl %ecx;"
literal|"	pushl %eax;"
literal|"	pushl %edx;"
comment|// atomic push of value to an address
comment|// we use cmpxchg8b, which compares content of an address with
comment|// edx:eax. If they are equal, it atomically puts 64bit value
comment|// ecx:ebx in address.
comment|// We thus put contents of address in edx:eax to force ecx:ebx
comment|// in address
literal|"	mov		8(%ebp), %esi;"
comment|// esi contains target address
literal|"	mov		12(%ebp), %ebx;"
literal|"	mov		16(%ebp), %ecx;"
comment|// ecx:ebx now contains value to put in target address
literal|"	mov		(%esi), %eax;"
literal|"	mov		4(%esi), %edx;"
comment|// edx:eax now contains value currently contained in target address
literal|"	lock; cmpxchg8b	(%esi);"
comment|// atomic move.
comment|// restore registers
literal|"	popl %edx;"
literal|"	popl %eax;"
literal|"	popl %ecx;"
literal|"	popl %ebx;"
literal|"	popl %esi;"
literal|"	popl %ebp;"
literal|"	ret"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_elif

begin_function
name|void
name|atomic_mov64
parameter_list|(
name|uint64_t
modifier|*
name|targetAddress
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
operator|*
name|targetAddress
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// __APPLE__
end_comment

end_unit

