begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-2-Clause-FreeBSD  *  * Copyright (c) 2011 The FreeBSD Project. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Based on:  * SHA256-based Unix crypt implementation. Released into the Public Domain by  * Ulrich Drepper<drepper@redhat.com>. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sha256.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_comment
comment|/* Define our magic string to mark salt for SHA256 "encryption" replacement. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sha256_salt_prefix
index|[]
init|=
literal|"$5$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix for optional rounds specification. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sha256_rounds_prefix
index|[]
init|=
literal|"rounds="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum salt string length. */
end_comment

begin_define
define|#
directive|define
name|SALT_LEN_MAX
value|16
end_define

begin_comment
comment|/* Default number of rounds if not explicitly specified. */
end_comment

begin_define
define|#
directive|define
name|ROUNDS_DEFAULT
value|5000
end_define

begin_comment
comment|/* Minimum number of rounds. */
end_comment

begin_define
define|#
directive|define
name|ROUNDS_MIN
value|1000
end_define

begin_comment
comment|/* Maximum number of rounds. */
end_comment

begin_define
define|#
directive|define
name|ROUNDS_MAX
value|999999999
end_define

begin_function
name|int
name|crypt_sha256
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|u_long
name|srounds
decl_stmt|;
name|uint8_t
name|alt_result
index|[
literal|32
index|]
decl_stmt|,
name|temp_result
index|[
literal|32
index|]
decl_stmt|;
name|SHA256_CTX
name|ctx
decl_stmt|,
name|alt_ctx
decl_stmt|;
name|size_t
name|salt_len
decl_stmt|,
name|key_len
decl_stmt|,
name|cnt
decl_stmt|,
name|rounds
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|copied_key
decl_stmt|,
modifier|*
name|copied_salt
decl_stmt|,
modifier|*
name|p_bytes
decl_stmt|,
modifier|*
name|s_bytes
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
specifier|const
name|char
modifier|*
name|num
decl_stmt|;
name|bool
name|rounds_custom
decl_stmt|;
name|copied_key
operator|=
name|NULL
expr_stmt|;
name|copied_salt
operator|=
name|NULL
expr_stmt|;
comment|/* Default number of rounds. */
name|rounds
operator|=
name|ROUNDS_DEFAULT
expr_stmt|;
name|rounds_custom
operator|=
name|false
expr_stmt|;
comment|/* Find beginning of salt string. The prefix should normally always 	 * be present. Just in case it is not. */
if|if
condition|(
name|strncmp
argument_list|(
name|sha256_salt_prefix
argument_list|,
name|salt
argument_list|,
sizeof|sizeof
argument_list|(
name|sha256_salt_prefix
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* Skip salt prefix. */
name|salt
operator|+=
sizeof|sizeof
argument_list|(
name|sha256_salt_prefix
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|salt
argument_list|,
name|sha256_rounds_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|sha256_rounds_prefix
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|num
operator|=
name|salt
operator|+
sizeof|sizeof
argument_list|(
name|sha256_rounds_prefix
argument_list|)
operator|-
literal|1
expr_stmt|;
name|srounds
operator|=
name|strtoul
argument_list|(
name|num
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|'$'
condition|)
block|{
name|salt
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
name|rounds
operator|=
name|MAX
argument_list|(
name|ROUNDS_MIN
argument_list|,
name|MIN
argument_list|(
name|srounds
argument_list|,
name|ROUNDS_MAX
argument_list|)
argument_list|)
expr_stmt|;
name|rounds_custom
operator|=
name|true
expr_stmt|;
block|}
block|}
name|salt_len
operator|=
name|MIN
argument_list|(
name|strcspn
argument_list|(
name|salt
argument_list|,
literal|"$"
argument_list|)
argument_list|,
name|SALT_LEN_MAX
argument_list|)
expr_stmt|;
name|key_len
operator|=
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Prepare for the real work. */
name|SHA256_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Add the key string. */
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* The last part is the salt string. This must be at most 8 	 * characters and it ends at the first `$' character (for 	 * compatibility with existing implementations). */
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Compute alternate SHA256 sum with input KEY, SALT, and KEY. The 	 * final result will be added to the first context. */
name|SHA256_Init
argument_list|(
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Add key. */
name|SHA256_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Add salt. */
name|SHA256_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Add key again. */
name|SHA256_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Now get result of this (32 bytes) and add it to the other context. */
name|SHA256_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Add for any character in the key one byte of the alternate sum. */
for|for
control|(
name|cnt
operator|=
name|key_len
init|;
name|cnt
operator|>
literal|32
condition|;
name|cnt
operator|-=
literal|32
control|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Take the binary representation of the length of the key and for 	 * every 1 add the alternate sum, for every 0 the key. */
for|for
control|(
name|cnt
operator|=
name|key_len
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|32
argument_list|)
expr_stmt|;
else|else
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Create intermediate result. */
name|SHA256_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Start computation of P byte sequence. */
name|SHA256_Init
argument_list|(
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* For every character in the password add the entire password. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|key_len
condition|;
operator|++
name|cnt
control|)
name|SHA256_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Finish the digest. */
name|SHA256_Final
argument_list|(
name|temp_result
argument_list|,
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Create byte sequence P. */
name|cp
operator|=
name|p_bytes
operator|=
name|alloca
argument_list|(
name|key_len
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|key_len
init|;
name|cnt
operator|>=
literal|32
condition|;
name|cnt
operator|-=
literal|32
control|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|32
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Start computation of S byte sequence. */
name|SHA256_Init
argument_list|(
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* For every character in the password add the entire password. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|16
operator|+
name|alt_result
index|[
literal|0
index|]
condition|;
operator|++
name|cnt
control|)
name|SHA256_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Finish the digest. */
name|SHA256_Final
argument_list|(
name|temp_result
argument_list|,
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Create byte sequence S. */
name|cp
operator|=
name|s_bytes
operator|=
name|alloca
argument_list|(
name|salt_len
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|salt_len
init|;
name|cnt
operator|>=
literal|32
condition|;
name|cnt
operator|-=
literal|32
control|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|32
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Repeatedly run the collected hash value through SHA256 to burn CPU 	 * cycles. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|rounds
condition|;
operator|++
name|cnt
control|)
block|{
comment|/* New context. */
name|SHA256_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Add key or last result. */
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|p_bytes
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
else|else
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Add salt for numbers not divisible by 3. */
if|if
condition|(
name|cnt
operator|%
literal|3
operator|!=
literal|0
condition|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|s_bytes
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Add key for numbers not divisible by 7. */
if|if
condition|(
name|cnt
operator|%
literal|7
operator|!=
literal|0
condition|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|p_bytes
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Add key or last result. */
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|32
argument_list|)
expr_stmt|;
else|else
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|p_bytes
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Create intermediate result. */
name|SHA256_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* Now we can construct the result string. It consists of three 	 * parts. */
name|cp
operator|=
name|stpcpy
argument_list|(
name|buffer
argument_list|,
name|sha256_salt_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|rounds_custom
condition|)
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%s%zu$"
argument_list|,
name|sha256_rounds_prefix
argument_list|,
name|rounds
argument_list|)
expr_stmt|;
name|cp
operator|=
name|stpncpy
argument_list|(
name|cp
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'$'
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|0
index|]
argument_list|,
name|alt_result
index|[
literal|10
index|]
argument_list|,
name|alt_result
index|[
literal|20
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|21
index|]
argument_list|,
name|alt_result
index|[
literal|1
index|]
argument_list|,
name|alt_result
index|[
literal|11
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|12
index|]
argument_list|,
name|alt_result
index|[
literal|22
index|]
argument_list|,
name|alt_result
index|[
literal|2
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|3
index|]
argument_list|,
name|alt_result
index|[
literal|13
index|]
argument_list|,
name|alt_result
index|[
literal|23
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|24
index|]
argument_list|,
name|alt_result
index|[
literal|4
index|]
argument_list|,
name|alt_result
index|[
literal|14
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|15
index|]
argument_list|,
name|alt_result
index|[
literal|25
index|]
argument_list|,
name|alt_result
index|[
literal|5
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|6
index|]
argument_list|,
name|alt_result
index|[
literal|16
index|]
argument_list|,
name|alt_result
index|[
literal|26
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|27
index|]
argument_list|,
name|alt_result
index|[
literal|7
index|]
argument_list|,
name|alt_result
index|[
literal|17
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|18
index|]
argument_list|,
name|alt_result
index|[
literal|28
index|]
argument_list|,
name|alt_result
index|[
literal|8
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|9
index|]
argument_list|,
name|alt_result
index|[
literal|19
index|]
argument_list|,
name|alt_result
index|[
literal|29
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
literal|0
argument_list|,
name|alt_result
index|[
literal|31
index|]
argument_list|,
name|alt_result
index|[
literal|30
index|]
argument_list|,
literal|3
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate the string. */
comment|/* Clear the buffer for the intermediate result so that people 	 * attaching to processes or reading core dumps cannot get any 	 * information. We do it in this way to clear correct_words[] inside 	 * the SHA256 implementation as well. */
name|SHA256_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|SHA256_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_result
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_result
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_bytes
argument_list|,
literal|'\0'
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s_bytes
argument_list|,
literal|'\0'
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|alt_ctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|alt_ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied_key
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|copied_key
argument_list|,
literal|'\0'
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied_salt
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|copied_salt
argument_list|,
literal|'\0'
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
specifier|const
name|char
name|result
index|[
literal|32
index|]
decl_stmt|;
block|}
name|tests
index|[]
init|=
block|{
comment|/* Test vectors from FIPS 180-2: appendix B.1. */
block|{
literal|"abc"
block|,
literal|"\xba\x78\x16\xbf\x8f\x01\xcf\xea\x41\x41\x40\xde\x5d\xae\x22\x23"
literal|"\xb0\x03\x61\xa3\x96\x17\x7a\x9c\xb4\x10\xff\x61\xf2\x00\x15\xad"
block|}
block|,
comment|/* Test vectors from FIPS 180-2: appendix B.2. */
block|{
literal|"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
block|,
literal|"\x24\x8d\x6a\x61\xd2\x06\x38\xb8\xe5\xc0\x26\x93\x0c\x3e\x60\x39"
literal|"\xa3\x3c\xe4\x59\x64\xff\x21\x67\xf6\xec\xed\xd4\x19\xdb\x06\xc1"
block|}
block|,
comment|/* Test vectors from the NESSIE project. */
block|{
literal|""
block|,
literal|"\xe3\xb0\xc4\x42\x98\xfc\x1c\x14\x9a\xfb\xf4\xc8\x99\x6f\xb9\x24"
literal|"\x27\xae\x41\xe4\x64\x9b\x93\x4c\xa4\x95\x99\x1b\x78\x52\xb8\x55"
block|}
block|,
block|{
literal|"a"
block|,
literal|"\xca\x97\x81\x12\xca\x1b\xbd\xca\xfa\xc2\x31\xb3\x9a\x23\xdc\x4d"
literal|"\xa7\x86\xef\xf8\x14\x7c\x4e\x72\xb9\x80\x77\x85\xaf\xee\x48\xbb"
block|}
block|,
block|{
literal|"message digest"
block|,
literal|"\xf7\x84\x6f\x55\xcf\x23\xe1\x4e\xeb\xea\xb5\xb4\xe1\x55\x0c\xad"
literal|"\x5b\x50\x9e\x33\x48\xfb\xc4\xef\xa3\xa1\x41\x3d\x39\x3c\xb6\x50"
block|}
block|,
block|{
literal|"abcdefghijklmnopqrstuvwxyz"
block|,
literal|"\x71\xc4\x80\xdf\x93\xd6\xae\x2f\x1e\xfa\xd1\x44\x7c\x66\xc9\x52"
literal|"\x5e\x31\x62\x18\xcf\x51\xfc\x8d\x9e\xd8\x32\xf2\xda\xf1\x8b\x73"
block|}
block|,
block|{
literal|"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
block|,
literal|"\x24\x8d\x6a\x61\xd2\x06\x38\xb8\xe5\xc0\x26\x93\x0c\x3e\x60\x39"
literal|"\xa3\x3c\xe4\x59\x64\xff\x21\x67\xf6\xec\xed\xd4\x19\xdb\x06\xc1"
block|}
block|,
block|{
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
block|,
literal|"\xdb\x4b\xfc\xbd\x4d\xa0\xcd\x85\xa6\x0c\x3c\x37\xd3\xfb\xd8\x80"
literal|"\x5c\x77\xf1\x5f\xc6\xb1\xfd\xfe\x61\x4e\xe0\xa7\xc8\xfd\xb4\xc0"
block|}
block|,
block|{
literal|"123456789012345678901234567890123456789012345678901234567890"
literal|"12345678901234567890"
block|,
literal|"\xf3\x71\xbc\x4a\x31\x1f\x2b\x00\x9e\xef\x95\x2d\xd8\x3c\xa8\x0e"
literal|"\x2b\x60\x02\x6c\x8e\x93\x55\x92\xd0\xf9\xc3\x08\x45\x3c\x81\x3e"
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ntests
value|(sizeof (tests) / sizeof (tests[0]))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|salt
decl_stmt|;
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
decl_stmt|;
block|}
name|tests2
index|[]
init|=
block|{
block|{
literal|"$5$saltstring"
block|,
literal|"Hello world!"
block|,
literal|"$5$saltstring$5B8vYYiY.CVt1RlTTf8KbXBH3hsxY/GNooZaBBGWEc5"
block|}
block|,
block|{
literal|"$5$rounds=10000$saltstringsaltstring"
block|,
literal|"Hello world!"
block|,
literal|"$5$rounds=10000$saltstringsaltst$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2."
literal|"opqey6IcA"
block|}
block|,
block|{
literal|"$5$rounds=5000$toolongsaltstring"
block|,
literal|"This is just a test"
block|,
literal|"$5$rounds=5000$toolongsaltstrin$Un/5jzAHMgOGZ5.mWJpuVolil07guHPvOW8"
literal|"mGRcvxa5"
block|}
block|,
block|{
literal|"$5$rounds=1400$anotherlongsaltstring"
block|,
literal|"a very much longer text to encrypt.  This one even stretches over more"
literal|"than one line."
block|,
literal|"$5$rounds=1400$anotherlongsalts$Rx.j8H.h8HjEDGomFU8bDkXm3XIUnzyxf12"
literal|"oP84Bnq1"
block|}
block|,
block|{
literal|"$5$rounds=77777$short"
block|,
literal|"we have a short salt string but not a short password"
block|,
literal|"$5$rounds=77777$short$JiO1O3ZpDAxGJeaDIuqCoEFysAe1mZNJRs3pw0KQRd/"
block|}
block|,
block|{
literal|"$5$rounds=123456$asaltof16chars.."
block|,
literal|"a short string"
block|,
literal|"$5$rounds=123456$asaltof16chars..$gP3VQ/6X7UUEW3HkBn2w1/Ptq2jxPyzV/"
literal|"cZKmF/wJvD"
block|}
block|,
block|{
literal|"$5$rounds=10$roundstoolow"
block|,
literal|"the minimum number is still observed"
block|,
literal|"$5$rounds=1000$roundstoolow$yfvwcWrQ8l/K0DAWyuPMDNHpIVlTQebY9l/gL97"
literal|"2bIC"
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|ntests2
value|(sizeof (tests2) / sizeof (tests2[0]))
end_define

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|SHA256_CTX
name|ctx
decl_stmt|;
name|uint8_t
name|sum
index|[
literal|32
index|]
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
operator|(
name|int
operator|)
name|ntests
condition|;
operator|++
name|cnt
control|)
block|{
name|SHA256_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|tests
index|[
name|cnt
index|]
operator|.
name|input
argument_list|,
name|strlen
argument_list|(
name|tests
index|[
name|cnt
index|]
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Final
argument_list|(
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|tests
index|[
name|cnt
index|]
operator|.
name|result
argument_list|,
name|sum
argument_list|,
literal|32
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02X"
argument_list|,
name|tests
index|[
name|cnt
index|]
operator|.
name|result
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02X"
argument_list|,
name|sum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"test %d run %d failed\n"
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
name|SHA256_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tests
index|[
name|cnt
index|]
operator|.
name|input
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|tests
index|[
name|cnt
index|]
operator|.
name|input
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SHA256_Final
argument_list|(
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|tests
index|[
name|cnt
index|]
operator|.
name|result
argument_list|,
name|sum
argument_list|,
literal|32
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02X"
argument_list|,
name|tests
index|[
name|cnt
index|]
operator|.
name|result
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02X"
argument_list|,
name|sum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"test %d run %d failed\n"
argument_list|,
name|cnt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Test vector from FIPS 180-2: appendix B.3. */
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|'a'
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Final
argument_list|(
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|char
name|expected
index|[
literal|32
index|]
init|=
literal|"\xcd\xc7\x6e\x5c\x99\x14\xfb\x92\x81\xa1\xc7\xe2\x84\xd7\x3e\x67"
literal|"\xf1\x80\x9a\x48\xa4\x97\x20\x0e\x04\x6d\x39\xcc\xc7\x11\x2c\xd0"
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|expected
argument_list|,
name|sum
argument_list|,
literal|32
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"test %d failed\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ntests2
condition|;
operator|++
name|cnt
control|)
block|{
name|char
modifier|*
name|cp
init|=
name|crypt_sha256
argument_list|(
name|tests2
index|[
name|cnt
index|]
operator|.
name|input
argument_list|,
name|tests2
index|[
name|cnt
index|]
operator|.
name|salt
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|tests2
index|[
name|cnt
index|]
operator|.
name|expected
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"test %d: expected \"%s\", got \"%s\"\n"
argument_list|,
name|cnt
argument_list|,
name|tests2
index|[
name|cnt
index|]
operator|.
name|expected
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|"all tests OK"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

